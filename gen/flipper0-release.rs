/* automatically generated by rust-bindgen 0.60.1 */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage> {
	storage: Storage,
}
impl<Storage> __BindgenBitfieldUnit<Storage> {
	#[inline]
	pub const fn new(storage: Storage) -> Self { Self { storage } }
}
impl<Storage> __BindgenBitfieldUnit<Storage> where Storage: AsRef<[u8]> + AsMut<[u8]> {
	#[inline]
	pub fn get_bit(&self, index: usize) -> bool {
		debug_assert!(index / 8 < self.storage.as_ref().len());
		let byte_index = index / 8;
		let byte = self.storage.as_ref()[byte_index];
		let bit_index = if cfg!(target_endian = "big") {
			7 - (index % 8)
		} else {
			index % 8
		};
		let mask = 1 << bit_index;
		byte & mask == mask
	}
	#[inline]
	pub fn set_bit(&mut self, index: usize, val: bool) {
		debug_assert!(index / 8 < self.storage.as_ref().len());
		let byte_index = index / 8;
		let byte = &mut self.storage.as_mut()[byte_index];
		let bit_index = if cfg!(target_endian = "big") {
			7 - (index % 8)
		} else {
			index % 8
		};
		let mask = 1 << bit_index;
		if val {
			*byte |= mask;
		} else {
			*byte &= !mask;
		}
	}
	#[inline]
	pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
		debug_assert!(bit_width <= 64);
		debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
		debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
		let mut val = 0;
		for i in 0..(bit_width as usize) {
			if self.get_bit(i + bit_offset) {
				let index = if cfg!(target_endian = "big") {
					bit_width as usize - 1 - i
				} else {
					i
				};
				val |= 1 << index;
			}
		}
		val
	}
	#[inline]
	pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
		debug_assert!(bit_width <= 64);
		debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
		debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
		for i in 0..(bit_width as usize) {
			let mask = 1 << i;
			let val_bit_is_set = val & mask == mask;
			let index = if cfg!(target_endian = "big") {
				bit_width as usize - 1 - i
			} else {
				i
			};
			self.set_bit(index + bit_offset, val_bit_is_set);
		}
	}
}
#[repr(C)]
#[derive(Default)]
pub struct __IncompleteArrayField<T>(::core::marker::PhantomData<T>, [T; 0]);
impl<T> __IncompleteArrayField<T> {
	#[inline]
	pub const fn new() -> Self { __IncompleteArrayField(::core::marker::PhantomData, []) }
	#[inline]
	pub fn as_ptr(&self) -> *const T { self as *const _ as *const T }
	#[inline]
	pub fn as_mut_ptr(&mut self) -> *mut T { self as *mut _ as *mut T }
	#[inline]
	pub unsafe fn as_slice(&self, len: usize) -> &[T] { ::core::slice::from_raw_parts(self.as_ptr(), len) }
	#[inline]
	pub unsafe fn as_mut_slice(&mut self, len: usize) -> &mut [T] { ::core::slice::from_raw_parts_mut(self.as_mut_ptr(), len) }
}
impl<T> ::core::fmt::Debug for __IncompleteArrayField<T> {
	fn fmt(&self, fmt: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result { fmt.write_str("__IncompleteArrayField") }
}
#[repr(C)]
pub struct __BindgenUnionField<T>(::core::marker::PhantomData<T>);
impl<T> __BindgenUnionField<T> {
	#[inline]
	pub const fn new() -> Self { __BindgenUnionField(::core::marker::PhantomData) }
	#[inline]
	pub unsafe fn as_ref(&self) -> &T { ::core::mem::transmute(self) }
	#[inline]
	pub unsafe fn as_mut(&mut self) -> &mut T { ::core::mem::transmute(self) }
}
impl<T> ::core::default::Default for __BindgenUnionField<T> {
	#[inline]
	fn default() -> Self { Self::new() }
}
impl<T> ::core::clone::Clone for __BindgenUnionField<T> {
	#[inline]
	fn clone(&self) -> Self { Self::new() }
}
impl<T> ::core::marker::Copy for __BindgenUnionField<T> {}
impl<T> ::core::fmt::Debug for __BindgenUnionField<T> {
	fn fmt(&self, fmt: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result { fmt.write_str("__BindgenUnionField") }
}
impl<T> ::core::hash::Hash for __BindgenUnionField<T> {
	fn hash<H: ::core::hash::Hasher>(&self, _state: &mut H) {}
}
impl<T> ::core::cmp::PartialEq for __BindgenUnionField<T> {
	fn eq(&self, _other: &__BindgenUnionField<T>) -> bool { true }
}
impl<T> ::core::cmp::Eq for __BindgenUnionField<T> {}
pub const true_: u32 = 1;
pub const false_: u32 = 0;
pub const __bool_true_false_are_defined: u32 = 1;
pub const _NEWLIB_VERSION_H__: u32 = 1;
pub const _NEWLIB_VERSION: &[u8; 6usize] = b"4.1.0\0";
pub const __NEWLIB__: u32 = 4;
pub const __NEWLIB_MINOR__: u32 = 1;
pub const __NEWLIB_PATCHLEVEL__: u32 = 0;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __ATFILE_VISIBLE: u32 = 1;
pub const __BSD_VISIBLE: u32 = 1;
pub const __GNU_VISIBLE: u32 = 0;
pub const __ISO_C_VISIBLE: u32 = 2011;
pub const __LARGEFILE_VISIBLE: u32 = 0;
pub const __MISC_VISIBLE: u32 = 1;
pub const __POSIX_VISIBLE: u32 = 200809;
pub const __SVID_VISIBLE: u32 = 1;
pub const __XSI_VISIBLE: u32 = 0;
pub const __SSP_FORTIFY_LEVEL: u32 = 0;
pub const __have_longlong64: u32 = 1;
pub const __have_long32: u32 = 1;
pub const ___int8_t_defined: u32 = 1;
pub const ___int16_t_defined: u32 = 1;
pub const ___int32_t_defined: u32 = 1;
pub const ___int64_t_defined: u32 = 1;
pub const ___int_least8_t_defined: u32 = 1;
pub const ___int_least16_t_defined: u32 = 1;
pub const ___int_least32_t_defined: u32 = 1;
pub const ___int_least64_t_defined: u32 = 1;
pub const __int20: u32 = 2;
pub const __int20__: u32 = 2;
pub const __INT8: &[u8; 3usize] = b"hh\0";
pub const __INT16: &[u8; 2usize] = b"h\0";
pub const __INT64: &[u8; 3usize] = b"ll\0";
pub const __FAST8: &[u8; 3usize] = b"hh\0";
pub const __FAST16: &[u8; 2usize] = b"h\0";
pub const __FAST64: &[u8; 3usize] = b"ll\0";
pub const __LEAST8: &[u8; 3usize] = b"hh\0";
pub const __LEAST16: &[u8; 2usize] = b"h\0";
pub const __LEAST64: &[u8; 3usize] = b"ll\0";
pub const __int8_t_defined: u32 = 1;
pub const __int16_t_defined: u32 = 1;
pub const __int32_t_defined: u32 = 1;
pub const __int64_t_defined: u32 = 1;
pub const __int_least8_t_defined: u32 = 1;
pub const __int_least16_t_defined: u32 = 1;
pub const __int_least32_t_defined: u32 = 1;
pub const __int_least64_t_defined: u32 = 1;
pub const __int_fast8_t_defined: u32 = 1;
pub const __int_fast16_t_defined: u32 = 1;
pub const __int_fast32_t_defined: u32 = 1;
pub const __int_fast64_t_defined: u32 = 1;
pub const WINT_MIN: u32 = 0;
pub const RECORD_BT: &[u8; 3usize] = b"bt\0";
pub const _LIBC_LIMITS_H_: u32 = 1;
pub const __NEWLIB_H__: u32 = 1;
pub const _WANT_IO_C99_FORMATS: u32 = 1;
pub const _WANT_IO_LONG_LONG: u32 = 1;
pub const _WANT_REGISTER_FINI: u32 = 1;
pub const _REENT_CHECK_VERIFY: u32 = 1;
pub const _MB_LEN_MAX: u32 = 1;
pub const HAVE_INITFINI_ARRAY: u32 = 1;
pub const _ATEXIT_DYNAMIC_ALLOC: u32 = 1;
pub const _HAVE_LONG_DOUBLE: u32 = 1;
pub const _HAVE_CC_INHIBIT_LOOP_TO_LIBCALL: u32 = 1;
pub const _LDBL_EQ_DBL: u32 = 1;
pub const _FVWRITE_IN_STREAMIO: u32 = 1;
pub const _FSEEK_OPTIMIZATION: u32 = 1;
pub const _WIDE_ORIENT: u32 = 1;
pub const _UNBUF_STREAM_OPT: u32 = 1;
pub const _RETARGETABLE_LOCKING: u32 = 1;
pub const __GNUCLIKE_ASM: u32 = 3;
pub const __GNUCLIKE___TYPEOF: u32 = 1;
pub const __GNUCLIKE___OFFSETOF: u32 = 1;
pub const __GNUCLIKE___SECTION: u32 = 1;
pub const __GNUCLIKE_CTOR_SECTION_HANDLING: u32 = 1;
pub const __GNUCLIKE_BUILTIN_CONSTANT_P: u32 = 1;
pub const __GNUCLIKE_BUILTIN_VARARGS: u32 = 1;
pub const __GNUCLIKE_BUILTIN_STDARG: u32 = 1;
pub const __GNUCLIKE_BUILTIN_VAALIST: u32 = 1;
pub const __GNUC_VA_LIST_COMPATIBILITY: u32 = 1;
pub const __GNUCLIKE_BUILTIN_NEXT_ARG: u32 = 1;
pub const __GNUCLIKE_BUILTIN_MEMCPY: u32 = 1;
pub const __CC_SUPPORTS_INLINE: u32 = 1;
pub const __CC_SUPPORTS___INLINE: u32 = 1;
pub const __CC_SUPPORTS___INLINE__: u32 = 1;
pub const __CC_SUPPORTS___FUNC__: u32 = 1;
pub const __CC_SUPPORTS_WARNING: u32 = 1;
pub const __CC_SUPPORTS_VARADIC_XXX: u32 = 1;
pub const __CC_SUPPORTS_DYNAMIC_ARRAY_INIT: u32 = 1;
pub const ARG_MAX: u32 = 65536;
pub const CHILD_MAX: u32 = 40;
pub const LINK_MAX: u32 = 32767;
pub const MAX_CANON: u32 = 255;
pub const MAX_INPUT: u32 = 255;
pub const NAME_MAX: u32 = 255;
pub const NGROUPS_MAX: u32 = 16;
pub const OPEN_MAX: u32 = 64;
pub const PATH_MAX: u32 = 1024;
pub const PIPE_BUF: u32 = 512;
pub const IOV_MAX: u32 = 1024;
pub const BC_BASE_MAX: u32 = 99;
pub const BC_DIM_MAX: u32 = 2048;
pub const BC_SCALE_MAX: u32 = 99;
pub const BC_STRING_MAX: u32 = 1000;
pub const COLL_WEIGHTS_MAX: u32 = 0;
pub const EXPR_NEST_MAX: u32 = 32;
pub const LINE_MAX: u32 = 2048;
pub const RE_DUP_MAX: u32 = 255;
pub const MB_LEN_MAX: u32 = 1;
pub const NL_ARGMAX: u32 = 32;
pub const CHAR_MIN: u32 = 0;
pub const _POSIX2_RE_DUP_MAX: u32 = 255;
pub const __OBSOLETE_MATH_DEFAULT: u32 = 1;
pub const __OBSOLETE_MATH: u32 = 1;
pub const __RAND_MAX: u32 = 2147483647;
pub const _NULL: u32 = 0;
pub const _ATEXIT_SIZE: u32 = 32;
pub const _RAND48_SEED_0: u32 = 13070;
pub const _RAND48_SEED_1: u32 = 43981;
pub const _RAND48_SEED_2: u32 = 4660;
pub const _RAND48_MULT_0: u32 = 58989;
pub const _RAND48_MULT_1: u32 = 57068;
pub const _RAND48_MULT_2: u32 = 5;
pub const _RAND48_ADD: u32 = 11;
pub const _REENT_EMERGENCY_SIZE: u32 = 25;
pub const _REENT_ASCTIME_SIZE: u32 = 26;
pub const _REENT_SIGNAL_SIZE: u32 = 24;
pub const _N_LISTS: u32 = 30;
pub const _U: u32 = 1;
pub const _L: u32 = 2;
pub const _N: u32 = 4;
pub const _S: u32 = 8;
pub const _P: u32 = 16;
pub const _C: u32 = 32;
pub const _X: u32 = 64;
pub const _B: u32 = 128;
pub const EXIT_FAILURE: u32 = 1;
pub const EXIT_SUCCESS: u32 = 0;
pub const RAND_MAX: u32 = 2147483647;
pub const M_USE_STDIO: u32 = 1;
pub const __GNUC_VA_LIST: u32 = 1;
pub const __BIT_TYPES_DEFINED__: u32 = 1;
pub const _LITTLE_ENDIAN: u32 = 1234;
pub const _BIG_ENDIAN: u32 = 4321;
pub const _PDP_ENDIAN: u32 = 3412;
pub const _BYTE_ORDER: u32 = 1234;
pub const _QUAD_HIGHWORD: u32 = 1;
pub const _QUAD_LOWWORD: u32 = 0;
pub const LITTLE_ENDIAN: u32 = 1234;
pub const BIG_ENDIAN: u32 = 4321;
pub const PDP_ENDIAN: u32 = 3412;
pub const BYTE_ORDER: u32 = 1234;
pub const FD_SETSIZE: u32 = 64;
pub const SCHED_OTHER: u32 = 0;
pub const SCHED_FIFO: u32 = 1;
pub const SCHED_RR: u32 = 2;
pub const PTHREAD_SCOPE_PROCESS: u32 = 0;
pub const PTHREAD_SCOPE_SYSTEM: u32 = 1;
pub const PTHREAD_INHERIT_SCHED: u32 = 1;
pub const PTHREAD_EXPLICIT_SCHED: u32 = 2;
pub const PTHREAD_CREATE_DETACHED: u32 = 0;
pub const PTHREAD_CREATE_JOINABLE: u32 = 1;
pub const __SLBF: u32 = 1;
pub const __SNBF: u32 = 2;
pub const __SRD: u32 = 4;
pub const __SWR: u32 = 8;
pub const __SRW: u32 = 16;
pub const __SEOF: u32 = 32;
pub const __SERR: u32 = 64;
pub const __SMBF: u32 = 128;
pub const __SAPP: u32 = 256;
pub const __SSTR: u32 = 512;
pub const __SOPT: u32 = 1024;
pub const __SNPT: u32 = 2048;
pub const __SOFF: u32 = 4096;
pub const __SORD: u32 = 8192;
pub const __SL64: u32 = 32768;
pub const __SNLK: u32 = 1;
pub const __SWID: u32 = 8192;
pub const _IOFBF: u32 = 0;
pub const _IOLBF: u32 = 1;
pub const _IONBF: u32 = 2;
pub const EOF: i32 = -1;
pub const BUFSIZ: u32 = 1024;
pub const FOPEN_MAX: u32 = 20;
pub const FILENAME_MAX: u32 = 1024;
pub const L_tmpnam: u32 = 1024;
pub const P_tmpdir: &[u8; 5usize] = b"/tmp\0";
pub const SEEK_SET: u32 = 0;
pub const SEEK_CUR: u32 = 1;
pub const SEEK_END: u32 = 2;
pub const TMP_MAX: u32 = 26;
pub const L_ctermid: u32 = 16;
pub const M_USE_STDARG: u32 = 1;
pub const M_CORE_VERSION_MAJOR: u32 = 0;
pub const M_CORE_VERSION_MINOR: u32 = 6;
pub const M_CORE_VERSION_PATCHLEVEL: u32 = 0;
pub const M_ALIGN_FOR_CACHELINE_EXCLUSION: u32 = 64;
pub const M_MAX_NB_ARGUMENT: u32 = 52;
pub const M_INC_0: u32 = 1;
pub const M_INC_1: u32 = 2;
pub const M_INC_2: u32 = 3;
pub const M_INC_3: u32 = 4;
pub const M_INC_4: u32 = 5;
pub const M_INC_5: u32 = 6;
pub const M_INC_6: u32 = 7;
pub const M_INC_7: u32 = 8;
pub const M_INC_8: u32 = 9;
pub const M_INC_9: u32 = 10;
pub const M_INC_10: u32 = 11;
pub const M_INC_11: u32 = 12;
pub const M_INC_12: u32 = 13;
pub const M_INC_13: u32 = 14;
pub const M_INC_14: u32 = 15;
pub const M_INC_15: u32 = 16;
pub const M_INC_16: u32 = 17;
pub const M_INC_17: u32 = 18;
pub const M_INC_18: u32 = 19;
pub const M_INC_19: u32 = 20;
pub const M_INC_20: u32 = 21;
pub const M_INC_21: u32 = 22;
pub const M_INC_22: u32 = 23;
pub const M_INC_23: u32 = 24;
pub const M_INC_24: u32 = 25;
pub const M_INC_25: u32 = 26;
pub const M_INC_26: u32 = 27;
pub const M_INC_27: u32 = 28;
pub const M_INC_28: u32 = 29;
pub const M_INC_29: u32 = 30;
pub const M_INC_30: u32 = 31;
pub const M_INC_31: u32 = 32;
pub const M_INC_32: u32 = 33;
pub const M_INC_33: u32 = 34;
pub const M_INC_34: u32 = 35;
pub const M_INC_35: u32 = 36;
pub const M_INC_36: u32 = 37;
pub const M_INC_37: u32 = 38;
pub const M_INC_38: u32 = 39;
pub const M_INC_39: u32 = 40;
pub const M_INC_40: u32 = 41;
pub const M_INC_41: u32 = 42;
pub const M_INC_42: u32 = 43;
pub const M_INC_43: u32 = 44;
pub const M_INC_44: u32 = 45;
pub const M_INC_45: u32 = 46;
pub const M_INC_46: u32 = 47;
pub const M_INC_47: u32 = 48;
pub const M_INC_48: u32 = 49;
pub const M_INC_49: u32 = 50;
pub const M_INC_50: u32 = 51;
pub const M_INC_51: u32 = 52;
pub const M_INC_52: u32 = 53;
pub const M_DEC_1: u32 = 0;
pub const M_DEC_2: u32 = 1;
pub const M_DEC_3: u32 = 2;
pub const M_DEC_4: u32 = 3;
pub const M_DEC_5: u32 = 4;
pub const M_DEC_6: u32 = 5;
pub const M_DEC_7: u32 = 6;
pub const M_DEC_8: u32 = 7;
pub const M_DEC_9: u32 = 8;
pub const M_DEC_10: u32 = 9;
pub const M_DEC_11: u32 = 10;
pub const M_DEC_12: u32 = 11;
pub const M_DEC_13: u32 = 12;
pub const M_DEC_14: u32 = 13;
pub const M_DEC_15: u32 = 14;
pub const M_DEC_16: u32 = 15;
pub const M_DEC_17: u32 = 16;
pub const M_DEC_18: u32 = 17;
pub const M_DEC_19: u32 = 18;
pub const M_DEC_20: u32 = 19;
pub const M_DEC_21: u32 = 20;
pub const M_DEC_22: u32 = 21;
pub const M_DEC_23: u32 = 22;
pub const M_DEC_24: u32 = 23;
pub const M_DEC_25: u32 = 24;
pub const M_DEC_26: u32 = 25;
pub const M_DEC_27: u32 = 26;
pub const M_DEC_28: u32 = 27;
pub const M_DEC_29: u32 = 28;
pub const M_DEC_30: u32 = 29;
pub const M_DEC_31: u32 = 30;
pub const M_DEC_32: u32 = 31;
pub const M_DEC_33: u32 = 32;
pub const M_DEC_34: u32 = 33;
pub const M_DEC_35: u32 = 34;
pub const M_DEC_36: u32 = 35;
pub const M_DEC_37: u32 = 36;
pub const M_DEC_38: u32 = 37;
pub const M_DEC_39: u32 = 38;
pub const M_DEC_40: u32 = 39;
pub const M_DEC_41: u32 = 40;
pub const M_DEC_42: u32 = 41;
pub const M_DEC_43: u32 = 42;
pub const M_DEC_44: u32 = 43;
pub const M_DEC_45: u32 = 44;
pub const M_DEC_46: u32 = 45;
pub const M_DEC_47: u32 = 46;
pub const M_DEC_48: u32 = 47;
pub const M_DEC_49: u32 = 48;
pub const M_DEC_50: u32 = 49;
pub const M_DEC_51: u32 = 50;
pub const M_DEC_52: u32 = 51;
pub const M_INVI_0: u32 = 1;
pub const M_INVI_1: u32 = 0;
pub const M_ANDI_00: u32 = 0;
pub const M_ANDI_01: u32 = 0;
pub const M_ANDI_10: u32 = 0;
pub const M_ANDI_11: u32 = 1;
pub const M_ORI_00: u32 = 0;
pub const M_ORI_01: u32 = 1;
pub const M_ORI_10: u32 = 1;
pub const M_ORI_11: u32 = 1;
pub const M_NDEBUG_TEST: u32 = 0;
pub const M_NOTEQUAL_0_0: u32 = 0;
pub const M_NOTEQUAL_1_1: u32 = 0;
pub const M_NOTEQUAL_2_2: u32 = 0;
pub const M_NOTEQUAL_3_3: u32 = 0;
pub const M_NOTEQUAL_4_4: u32 = 0;
pub const M_NOTEQUAL_5_5: u32 = 0;
pub const M_NOTEQUAL_6_6: u32 = 0;
pub const M_NOTEQUAL_7_7: u32 = 0;
pub const M_NOTEQUAL_8_8: u32 = 0;
pub const M_NOTEQUAL_9_9: u32 = 0;
pub const M_NOTEQUAL_10_10: u32 = 0;
pub const M_NOTEQUAL_11_11: u32 = 0;
pub const M_NOTEQUAL_12_12: u32 = 0;
pub const M_NOTEQUAL_13_13: u32 = 0;
pub const M_NOTEQUAL_14_14: u32 = 0;
pub const M_NOTEQUAL_15_15: u32 = 0;
pub const M_NOTEQUAL_16_16: u32 = 0;
pub const M_NOTEQUAL_17_17: u32 = 0;
pub const M_NOTEQUAL_18_18: u32 = 0;
pub const M_NOTEQUAL_19_19: u32 = 0;
pub const M_NOTEQUAL_20_20: u32 = 0;
pub const M_NOTEQUAL_21_21: u32 = 0;
pub const M_NOTEQUAL_22_22: u32 = 0;
pub const M_NOTEQUAL_23_23: u32 = 0;
pub const M_NOTEQUAL_24_24: u32 = 0;
pub const M_NOTEQUAL_25_25: u32 = 0;
pub const M_NOTEQUAL_26_26: u32 = 0;
pub const M_NOTEQUAL_27_27: u32 = 0;
pub const M_NOTEQUAL_28_28: u32 = 0;
pub const M_NOTEQUAL_29_29: u32 = 0;
pub const M_NOTEQUAL_30_30: u32 = 0;
pub const M_NOTEQUAL_31_31: u32 = 0;
pub const M_NOTEQUAL_32_32: u32 = 0;
pub const M_NOTEQUAL_33_33: u32 = 0;
pub const M_NOTEQUAL_34_34: u32 = 0;
pub const M_NOTEQUAL_35_35: u32 = 0;
pub const M_NOTEQUAL_36_36: u32 = 0;
pub const M_NOTEQUAL_37_37: u32 = 0;
pub const M_NOTEQUAL_38_38: u32 = 0;
pub const M_NOTEQUAL_39_39: u32 = 0;
pub const M_NOTEQUAL_40_40: u32 = 0;
pub const M_NOTEQUAL_41_41: u32 = 0;
pub const M_NOTEQUAL_42_42: u32 = 0;
pub const M_NOTEQUAL_43_43: u32 = 0;
pub const M_NOTEQUAL_44_44: u32 = 0;
pub const M_NOTEQUAL_45_45: u32 = 0;
pub const M_NOTEQUAL_46_46: u32 = 0;
pub const M_NOTEQUAL_47_47: u32 = 0;
pub const M_NOTEQUAL_48_48: u32 = 0;
pub const M_NOTEQUAL_49_49: u32 = 0;
pub const M_NOTEQUAL_50_50: u32 = 0;
pub const M_NOTEQUAL_51_51: u32 = 0;
pub const M_NOTEQUAL_52_52: u32 = 0;
pub const M_USE_IDENTIFIER_ALLOC: u32 = 128;
pub const M_USE_CSTR_ALLOC: u32 = 256;
pub const M_USE_HASH_SEED: u32 = 0;
pub const M_HASH_INIT: u32 = 0;
pub const M_LIMIT_BASE_TYPE_DFT: u32 = 6;
pub const M_LIMIT_IT_TYPE_DFT: u32 = 4;
pub const M_LIMIT_IT_REF_DFT: u32 = 0;
pub const M_USE_BACKOFF_MAX_COUNT: u32 = 6;
pub const M_USE_SERIAL_MAX_DATA_SIZE: u32 = 4;
pub const M_STRING_UTF8_STATE_TAB: &[u8; 41usize] = b"\0 \x08\x10\x18    \0       \x08       \x10              \0";
pub const RECORD_CLI: &[u8; 4usize] = b"cli\0";
pub const __noreturn_is_defined: u32 = 1;
pub const CMSIS_device_header: &[u8; 12usize] = b"stm32wbxx.h\0";
pub const configENABLE_FPU: u32 = 1;
pub const configENABLE_MPU: u32 = 0;
pub const configUSE_PREEMPTION: u32 = 1;
pub const configSUPPORT_STATIC_ALLOCATION: u32 = 1;
pub const configSUPPORT_DYNAMIC_ALLOCATION: u32 = 1;
pub const configUSE_IDLE_HOOK: u32 = 0;
pub const configUSE_TICK_HOOK: u32 = 0;
pub const configTICK_RATE_HZ_RAW: u32 = 1000;
pub const configMAX_PRIORITIES: u32 = 32;
pub const configMAX_TASK_NAME_LEN: u32 = 16;
pub const configGENERATE_RUN_TIME_STATS: u32 = 0;
pub const configUSE_TRACE_FACILITY: u32 = 1;
pub const configUSE_16_BIT_TICKS: u32 = 0;
pub const configUSE_MUTEXES: u32 = 1;
pub const configQUEUE_REGISTRY_SIZE: u32 = 0;
pub const configCHECK_FOR_STACK_OVERFLOW: u32 = 0;
pub const configUSE_RECURSIVE_MUTEXES: u32 = 1;
pub const configUSE_COUNTING_SEMAPHORES: u32 = 1;
pub const configENABLE_BACKWARD_COMPATIBILITY: u32 = 0;
pub const configUSE_PORT_OPTIMISED_TASK_SELECTION: u32 = 1;
pub const configUSE_TICKLESS_IDLE: u32 = 2;
pub const configRECORD_STACK_HIGH_ADDRESS: u32 = 1;
pub const configUSE_NEWLIB_REENTRANT: u32 = 0;
pub const configNUM_THREAD_LOCAL_STORAGE_POINTERS: u32 = 1;
pub const configEXPECTED_IDLE_TIME_BEFORE_SLEEP: u32 = 4;
pub const configUSE_CO_ROUTINES: u32 = 0;
pub const configUSE_TIMERS: u32 = 1;
pub const configTIMER_TASK_PRIORITY: u32 = 2;
pub const configTIMER_QUEUE_LENGTH: u32 = 32;
pub const configTIMER_TASK_STACK_DEPTH: u32 = 256;
pub const configTIMER_SERVICE_TASK_NAME: &[u8; 10usize] = b"TimersSrv\0";
pub const configIDLE_TASK_NAME: &[u8; 6usize] = b"(-_-)\0";
pub const INCLUDE_xTaskGetHandle: u32 = 1;
pub const INCLUDE_eTaskGetState: u32 = 1;
pub const INCLUDE_uxTaskGetStackHighWaterMark: u32 = 1;
pub const INCLUDE_uxTaskPriorityGet: u32 = 1;
pub const INCLUDE_vTaskCleanUpResources: u32 = 0;
pub const INCLUDE_vTaskDelay: u32 = 1;
pub const INCLUDE_vTaskDelayUntil: u32 = 1;
pub const INCLUDE_vTaskDelete: u32 = 1;
pub const INCLUDE_vTaskPrioritySet: u32 = 1;
pub const INCLUDE_vTaskSuspend: u32 = 1;
pub const INCLUDE_xQueueGetMutexHolder: u32 = 1;
pub const INCLUDE_xTaskGetCurrentTaskHandle: u32 = 1;
pub const INCLUDE_xTaskGetSchedulerState: u32 = 1;
pub const INCLUDE_xTimerPendFunctionCall: u32 = 1;
pub const configTASK_NOTIFICATION_ARRAY_ENTRIES: u32 = 2;
pub const configPRIO_BITS: u32 = 4;
pub const configLIBRARY_LOWEST_INTERRUPT_PRIORITY: u32 = 15;
pub const configLIBRARY_MAX_SYSCALL_INTERRUPT_PRIORITY: u32 = 5;
pub const configKERNEL_INTERRUPT_PRIORITY: u32 = 240;
pub const configMAX_SYSCALL_INTERRUPT_PRIORITY: u32 = 80;
pub const USE_CUSTOM_SYSTICK_HANDLER_IMPLEMENTATION: u32 = 1;
pub const configOVERRIDE_DEFAULT_TICK_CONFIGURATION: u32 = 1;
pub const errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY: i32 = -1;
pub const errQUEUE_BLOCKED: i32 = -4;
pub const errQUEUE_YIELD: i32 = -5;
pub const configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES: u32 = 0;
pub const pdINTEGRITY_CHECK_VALUE: u32 = 1515870810;
pub const pdFREERTOS_ERRNO_NONE: u32 = 0;
pub const pdFREERTOS_ERRNO_ENOENT: u32 = 2;
pub const pdFREERTOS_ERRNO_EINTR: u32 = 4;
pub const pdFREERTOS_ERRNO_EIO: u32 = 5;
pub const pdFREERTOS_ERRNO_ENXIO: u32 = 6;
pub const pdFREERTOS_ERRNO_EBADF: u32 = 9;
pub const pdFREERTOS_ERRNO_EAGAIN: u32 = 11;
pub const pdFREERTOS_ERRNO_EWOULDBLOCK: u32 = 11;
pub const pdFREERTOS_ERRNO_ENOMEM: u32 = 12;
pub const pdFREERTOS_ERRNO_EACCES: u32 = 13;
pub const pdFREERTOS_ERRNO_EFAULT: u32 = 14;
pub const pdFREERTOS_ERRNO_EBUSY: u32 = 16;
pub const pdFREERTOS_ERRNO_EEXIST: u32 = 17;
pub const pdFREERTOS_ERRNO_EXDEV: u32 = 18;
pub const pdFREERTOS_ERRNO_ENODEV: u32 = 19;
pub const pdFREERTOS_ERRNO_ENOTDIR: u32 = 20;
pub const pdFREERTOS_ERRNO_EISDIR: u32 = 21;
pub const pdFREERTOS_ERRNO_EINVAL: u32 = 22;
pub const pdFREERTOS_ERRNO_ENOSPC: u32 = 28;
pub const pdFREERTOS_ERRNO_ESPIPE: u32 = 29;
pub const pdFREERTOS_ERRNO_EROFS: u32 = 30;
pub const pdFREERTOS_ERRNO_EUNATCH: u32 = 42;
pub const pdFREERTOS_ERRNO_EBADE: u32 = 50;
pub const pdFREERTOS_ERRNO_EFTYPE: u32 = 79;
pub const pdFREERTOS_ERRNO_ENMFILE: u32 = 89;
pub const pdFREERTOS_ERRNO_ENOTEMPTY: u32 = 90;
pub const pdFREERTOS_ERRNO_ENAMETOOLONG: u32 = 91;
pub const pdFREERTOS_ERRNO_EOPNOTSUPP: u32 = 95;
pub const pdFREERTOS_ERRNO_ENOBUFS: u32 = 105;
pub const pdFREERTOS_ERRNO_ENOPROTOOPT: u32 = 109;
pub const pdFREERTOS_ERRNO_EADDRINUSE: u32 = 112;
pub const pdFREERTOS_ERRNO_ETIMEDOUT: u32 = 116;
pub const pdFREERTOS_ERRNO_EINPROGRESS: u32 = 119;
pub const pdFREERTOS_ERRNO_EALREADY: u32 = 120;
pub const pdFREERTOS_ERRNO_EADDRNOTAVAIL: u32 = 125;
pub const pdFREERTOS_ERRNO_EISCONN: u32 = 127;
pub const pdFREERTOS_ERRNO_ENOTCONN: u32 = 128;
pub const pdFREERTOS_ERRNO_ENOMEDIUM: u32 = 135;
pub const pdFREERTOS_ERRNO_EILSEQ: u32 = 138;
pub const pdFREERTOS_ERRNO_ECANCELED: u32 = 140;
pub const pdFREERTOS_LITTLE_ENDIAN: u32 = 0;
pub const pdFREERTOS_BIG_ENDIAN: u32 = 1;
pub const pdLITTLE_ENDIAN: u32 = 0;
pub const pdBIG_ENDIAN: u32 = 1;
pub const portTICK_TYPE_IS_ATOMIC: u32 = 1;
pub const portSTACK_GROWTH: i32 = -1;
pub const portBYTE_ALIGNMENT: u32 = 8;
pub const portNVIC_PENDSVSET_BIT: u32 = 268435456;
pub const portBYTE_ALIGNMENT_MASK: u32 = 7;
pub const portUSING_MPU_WRAPPERS: u32 = 0;
pub const portNUM_CONFIGURABLE_REGIONS: u32 = 1;
pub const portHAS_STACK_OVERFLOW_CHECKING: u32 = 0;
pub const configSTACK_ALLOCATION_FROM_SEPARATE_HEAP: u32 = 0;
pub const INCLUDE_xTaskDelayUntil: u32 = 1;
pub const INCLUDE_xTaskGetIdleTaskHandle: u32 = 0;
pub const INCLUDE_xTaskAbortDelay: u32 = 0;
pub const INCLUDE_xSemaphoreGetMutexHolder: u32 = 1;
pub const INCLUDE_uxTaskGetStackHighWaterMark2: u32 = 0;
pub const INCLUDE_xTaskResumeFromISR: u32 = 1;
pub const configUSE_DAEMON_TASK_STARTUP_HOOK: u32 = 0;
pub const configUSE_APPLICATION_TASK_TAG: u32 = 0;
pub const configUSE_ALTERNATIVE_API: u32 = 0;
pub const portCRITICAL_NESTING_IN_TCB: u32 = 0;
pub const configIDLE_SHOULD_YIELD: u32 = 1;
pub const configASSERT_DEFINED: u32 = 0;
pub const configPRECONDITION_DEFINED: u32 = 0;
pub const configINCLUDE_FREERTOS_TASK_C_ADDITIONS_H: u32 = 0;
pub const configUSE_MALLOC_FAILED_HOOK: u32 = 0;
pub const configUSE_QUEUE_SETS: u32 = 0;
pub const configUSE_TIME_SLICING: u32 = 1;
pub const configINCLUDE_APPLICATION_DEFINED_PRIVILEGED_FUNCTIONS: u32 = 0;
pub const configUSE_STATS_FORMATTING_FUNCTIONS: u32 = 0;
pub const configAPPLICATION_ALLOCATED_HEAP: u32 = 0;
pub const configUSE_TASK_NOTIFICATIONS: u32 = 1;
pub const configUSE_POSIX_ERRNO: u32 = 0;
pub const configINITIAL_TICK_COUNT: u32 = 0;
pub const configUSE_TASK_FPU_SUPPORT: u32 = 1;
pub const configENABLE_TRUSTZONE: u32 = 1;
pub const configRUN_FREERTOS_SECURE_ONLY: u32 = 0;
pub const configRUN_ADDITIONAL_TESTS: u32 = 0;
pub const tskKERNEL_VERSION_NUMBER: &[u8; 9usize] = b"V10.4.4+\0";
pub const tskKERNEL_VERSION_MAJOR: u32 = 10;
pub const tskKERNEL_VERSION_MINOR: u32 = 4;
pub const tskKERNEL_VERSION_BUILD: u32 = 4;
pub const tskMPU_REGION_READ_ONLY: u32 = 1;
pub const tskMPU_REGION_READ_WRITE: u32 = 2;
pub const tskMPU_REGION_EXECUTE_NEVER: u32 = 4;
pub const tskMPU_REGION_NORMAL_MEMORY: u32 = 8;
pub const tskMPU_REGION_DEVICE_MEMORY: u32 = 16;
pub const tskDEFAULT_INDEX_TO_NOTIFY: u32 = 0;
pub const FURI_LOG_CLR_RESET: &[u8; 5usize] = b"\x1B[0m\0";
pub const FURI_LOG_CLR_BLACK: &[u8; 3usize] = b"30\0";
pub const FURI_LOG_CLR_RED: &[u8; 3usize] = b"31\0";
pub const FURI_LOG_CLR_GREEN: &[u8; 3usize] = b"32\0";
pub const FURI_LOG_CLR_BROWN: &[u8; 3usize] = b"33\0";
pub const FURI_LOG_CLR_BLUE: &[u8; 3usize] = b"34\0";
pub const FURI_LOG_CLR_PURPLE: &[u8; 3usize] = b"35\0";
pub const FURI_MEMMGR_GUARD: u32 = 1;
pub const MEMMGR_HEAP_UNKNOWN: u32 = 4294967295;
pub const __STM32WBxx_CMSIS_VERSION_MAIN: u32 = 1;
pub const __STM32WBxx_CMSIS_VERSION_SUB1: u32 = 10;
pub const __STM32WBxx_CMSIS_VERSION_SUB2: u32 = 1;
pub const __STM32WBxx_CMSIS_VERSION_RC: u32 = 0;
pub const __STM32WBxx_CMSIS_DEVICE_VERSION: u32 = 17432832;
pub const __CM4_REV: u32 = 1;
pub const __MPU_PRESENT: u32 = 1;
pub const __VTOR_PRESENT: u32 = 1;
pub const __NVIC_PRIO_BITS: u32 = 4;
pub const __Vendor_SysTickConfig: u32 = 0;
pub const __FPU_PRESENT: u32 = 1;
pub const __CM_CMSIS_VERSION_MAIN: u32 = 5;
pub const __CM_CMSIS_VERSION_SUB: u32 = 3;
pub const __CM_CMSIS_VERSION: u32 = 327683;
pub const __CM4_CMSIS_VERSION_MAIN: u32 = 5;
pub const __CM4_CMSIS_VERSION_SUB: u32 = 3;
pub const __CM4_CMSIS_VERSION: u32 = 327683;
pub const __CORTEX_M: u32 = 4;
pub const __FPU_USED: u32 = 1;
pub const APSR_N_Pos: u32 = 31;
pub const APSR_N_Msk: u32 = 2147483648;
pub const APSR_Z_Pos: u32 = 30;
pub const APSR_Z_Msk: u32 = 1073741824;
pub const APSR_C_Pos: u32 = 29;
pub const APSR_C_Msk: u32 = 536870912;
pub const APSR_V_Pos: u32 = 28;
pub const APSR_V_Msk: u32 = 268435456;
pub const APSR_Q_Pos: u32 = 27;
pub const APSR_Q_Msk: u32 = 134217728;
pub const APSR_GE_Pos: u32 = 16;
pub const APSR_GE_Msk: u32 = 983040;
pub const IPSR_ISR_Pos: u32 = 0;
pub const IPSR_ISR_Msk: u32 = 511;
pub const xPSR_N_Pos: u32 = 31;
pub const xPSR_N_Msk: u32 = 2147483648;
pub const xPSR_Z_Pos: u32 = 30;
pub const xPSR_Z_Msk: u32 = 1073741824;
pub const xPSR_C_Pos: u32 = 29;
pub const xPSR_C_Msk: u32 = 536870912;
pub const xPSR_V_Pos: u32 = 28;
pub const xPSR_V_Msk: u32 = 268435456;
pub const xPSR_Q_Pos: u32 = 27;
pub const xPSR_Q_Msk: u32 = 134217728;
pub const xPSR_ICI_IT_2_Pos: u32 = 25;
pub const xPSR_ICI_IT_2_Msk: u32 = 100663296;
pub const xPSR_T_Pos: u32 = 24;
pub const xPSR_T_Msk: u32 = 16777216;
pub const xPSR_GE_Pos: u32 = 16;
pub const xPSR_GE_Msk: u32 = 983040;
pub const xPSR_ICI_IT_1_Pos: u32 = 10;
pub const xPSR_ICI_IT_1_Msk: u32 = 64512;
pub const xPSR_ISR_Pos: u32 = 0;
pub const xPSR_ISR_Msk: u32 = 511;
pub const CONTROL_FPCA_Pos: u32 = 2;
pub const CONTROL_FPCA_Msk: u32 = 4;
pub const CONTROL_SPSEL_Pos: u32 = 1;
pub const CONTROL_SPSEL_Msk: u32 = 2;
pub const CONTROL_nPRIV_Pos: u32 = 0;
pub const CONTROL_nPRIV_Msk: u32 = 1;
pub const NVIC_STIR_INTID_Pos: u32 = 0;
pub const NVIC_STIR_INTID_Msk: u32 = 511;
pub const SCB_CPUID_IMPLEMENTER_Pos: u32 = 24;
pub const SCB_CPUID_IMPLEMENTER_Msk: u32 = 4278190080;
pub const SCB_CPUID_VARIANT_Pos: u32 = 20;
pub const SCB_CPUID_VARIANT_Msk: u32 = 15728640;
pub const SCB_CPUID_ARCHITECTURE_Pos: u32 = 16;
pub const SCB_CPUID_ARCHITECTURE_Msk: u32 = 983040;
pub const SCB_CPUID_PARTNO_Pos: u32 = 4;
pub const SCB_CPUID_PARTNO_Msk: u32 = 65520;
pub const SCB_CPUID_REVISION_Pos: u32 = 0;
pub const SCB_CPUID_REVISION_Msk: u32 = 15;
pub const SCB_ICSR_NMIPENDSET_Pos: u32 = 31;
pub const SCB_ICSR_NMIPENDSET_Msk: u32 = 2147483648;
pub const SCB_ICSR_PENDSVSET_Pos: u32 = 28;
pub const SCB_ICSR_PENDSVSET_Msk: u32 = 268435456;
pub const SCB_ICSR_PENDSVCLR_Pos: u32 = 27;
pub const SCB_ICSR_PENDSVCLR_Msk: u32 = 134217728;
pub const SCB_ICSR_PENDSTSET_Pos: u32 = 26;
pub const SCB_ICSR_PENDSTSET_Msk: u32 = 67108864;
pub const SCB_ICSR_PENDSTCLR_Pos: u32 = 25;
pub const SCB_ICSR_PENDSTCLR_Msk: u32 = 33554432;
pub const SCB_ICSR_ISRPREEMPT_Pos: u32 = 23;
pub const SCB_ICSR_ISRPREEMPT_Msk: u32 = 8388608;
pub const SCB_ICSR_ISRPENDING_Pos: u32 = 22;
pub const SCB_ICSR_ISRPENDING_Msk: u32 = 4194304;
pub const SCB_ICSR_VECTPENDING_Pos: u32 = 12;
pub const SCB_ICSR_VECTPENDING_Msk: u32 = 2093056;
pub const SCB_ICSR_RETTOBASE_Pos: u32 = 11;
pub const SCB_ICSR_RETTOBASE_Msk: u32 = 2048;
pub const SCB_ICSR_VECTACTIVE_Pos: u32 = 0;
pub const SCB_ICSR_VECTACTIVE_Msk: u32 = 511;
pub const SCB_VTOR_TBLOFF_Pos: u32 = 7;
pub const SCB_VTOR_TBLOFF_Msk: u32 = 4294967168;
pub const SCB_AIRCR_VECTKEY_Pos: u32 = 16;
pub const SCB_AIRCR_VECTKEY_Msk: u32 = 4294901760;
pub const SCB_AIRCR_VECTKEYSTAT_Pos: u32 = 16;
pub const SCB_AIRCR_VECTKEYSTAT_Msk: u32 = 4294901760;
pub const SCB_AIRCR_ENDIANESS_Pos: u32 = 15;
pub const SCB_AIRCR_ENDIANESS_Msk: u32 = 32768;
pub const SCB_AIRCR_PRIGROUP_Pos: u32 = 8;
pub const SCB_AIRCR_PRIGROUP_Msk: u32 = 1792;
pub const SCB_AIRCR_SYSRESETREQ_Pos: u32 = 2;
pub const SCB_AIRCR_SYSRESETREQ_Msk: u32 = 4;
pub const SCB_AIRCR_VECTCLRACTIVE_Pos: u32 = 1;
pub const SCB_AIRCR_VECTCLRACTIVE_Msk: u32 = 2;
pub const SCB_AIRCR_VECTRESET_Pos: u32 = 0;
pub const SCB_AIRCR_VECTRESET_Msk: u32 = 1;
pub const SCB_SCR_SEVONPEND_Pos: u32 = 4;
pub const SCB_SCR_SEVONPEND_Msk: u32 = 16;
pub const SCB_SCR_SLEEPDEEP_Pos: u32 = 2;
pub const SCB_SCR_SLEEPDEEP_Msk: u32 = 4;
pub const SCB_SCR_SLEEPONEXIT_Pos: u32 = 1;
pub const SCB_SCR_SLEEPONEXIT_Msk: u32 = 2;
pub const SCB_CCR_STKALIGN_Pos: u32 = 9;
pub const SCB_CCR_STKALIGN_Msk: u32 = 512;
pub const SCB_CCR_BFHFNMIGN_Pos: u32 = 8;
pub const SCB_CCR_BFHFNMIGN_Msk: u32 = 256;
pub const SCB_CCR_DIV_0_TRP_Pos: u32 = 4;
pub const SCB_CCR_DIV_0_TRP_Msk: u32 = 16;
pub const SCB_CCR_UNALIGN_TRP_Pos: u32 = 3;
pub const SCB_CCR_UNALIGN_TRP_Msk: u32 = 8;
pub const SCB_CCR_USERSETMPEND_Pos: u32 = 1;
pub const SCB_CCR_USERSETMPEND_Msk: u32 = 2;
pub const SCB_CCR_NONBASETHRDENA_Pos: u32 = 0;
pub const SCB_CCR_NONBASETHRDENA_Msk: u32 = 1;
pub const SCB_SHCSR_USGFAULTENA_Pos: u32 = 18;
pub const SCB_SHCSR_USGFAULTENA_Msk: u32 = 262144;
pub const SCB_SHCSR_BUSFAULTENA_Pos: u32 = 17;
pub const SCB_SHCSR_BUSFAULTENA_Msk: u32 = 131072;
pub const SCB_SHCSR_MEMFAULTENA_Pos: u32 = 16;
pub const SCB_SHCSR_MEMFAULTENA_Msk: u32 = 65536;
pub const SCB_SHCSR_SVCALLPENDED_Pos: u32 = 15;
pub const SCB_SHCSR_SVCALLPENDED_Msk: u32 = 32768;
pub const SCB_SHCSR_BUSFAULTPENDED_Pos: u32 = 14;
pub const SCB_SHCSR_BUSFAULTPENDED_Msk: u32 = 16384;
pub const SCB_SHCSR_MEMFAULTPENDED_Pos: u32 = 13;
pub const SCB_SHCSR_MEMFAULTPENDED_Msk: u32 = 8192;
pub const SCB_SHCSR_USGFAULTPENDED_Pos: u32 = 12;
pub const SCB_SHCSR_USGFAULTPENDED_Msk: u32 = 4096;
pub const SCB_SHCSR_SYSTICKACT_Pos: u32 = 11;
pub const SCB_SHCSR_SYSTICKACT_Msk: u32 = 2048;
pub const SCB_SHCSR_PENDSVACT_Pos: u32 = 10;
pub const SCB_SHCSR_PENDSVACT_Msk: u32 = 1024;
pub const SCB_SHCSR_MONITORACT_Pos: u32 = 8;
pub const SCB_SHCSR_MONITORACT_Msk: u32 = 256;
pub const SCB_SHCSR_SVCALLACT_Pos: u32 = 7;
pub const SCB_SHCSR_SVCALLACT_Msk: u32 = 128;
pub const SCB_SHCSR_USGFAULTACT_Pos: u32 = 3;
pub const SCB_SHCSR_USGFAULTACT_Msk: u32 = 8;
pub const SCB_SHCSR_BUSFAULTACT_Pos: u32 = 1;
pub const SCB_SHCSR_BUSFAULTACT_Msk: u32 = 2;
pub const SCB_SHCSR_MEMFAULTACT_Pos: u32 = 0;
pub const SCB_SHCSR_MEMFAULTACT_Msk: u32 = 1;
pub const SCB_CFSR_USGFAULTSR_Pos: u32 = 16;
pub const SCB_CFSR_USGFAULTSR_Msk: u32 = 4294901760;
pub const SCB_CFSR_BUSFAULTSR_Pos: u32 = 8;
pub const SCB_CFSR_BUSFAULTSR_Msk: u32 = 65280;
pub const SCB_CFSR_MEMFAULTSR_Pos: u32 = 0;
pub const SCB_CFSR_MEMFAULTSR_Msk: u32 = 255;
pub const SCB_CFSR_MMARVALID_Pos: u32 = 7;
pub const SCB_CFSR_MMARVALID_Msk: u32 = 128;
pub const SCB_CFSR_MLSPERR_Pos: u32 = 5;
pub const SCB_CFSR_MLSPERR_Msk: u32 = 32;
pub const SCB_CFSR_MSTKERR_Pos: u32 = 4;
pub const SCB_CFSR_MSTKERR_Msk: u32 = 16;
pub const SCB_CFSR_MUNSTKERR_Pos: u32 = 3;
pub const SCB_CFSR_MUNSTKERR_Msk: u32 = 8;
pub const SCB_CFSR_DACCVIOL_Pos: u32 = 1;
pub const SCB_CFSR_DACCVIOL_Msk: u32 = 2;
pub const SCB_CFSR_IACCVIOL_Pos: u32 = 0;
pub const SCB_CFSR_IACCVIOL_Msk: u32 = 1;
pub const SCB_CFSR_BFARVALID_Pos: u32 = 15;
pub const SCB_CFSR_BFARVALID_Msk: u32 = 32768;
pub const SCB_CFSR_LSPERR_Pos: u32 = 13;
pub const SCB_CFSR_LSPERR_Msk: u32 = 8192;
pub const SCB_CFSR_STKERR_Pos: u32 = 12;
pub const SCB_CFSR_STKERR_Msk: u32 = 4096;
pub const SCB_CFSR_UNSTKERR_Pos: u32 = 11;
pub const SCB_CFSR_UNSTKERR_Msk: u32 = 2048;
pub const SCB_CFSR_IMPRECISERR_Pos: u32 = 10;
pub const SCB_CFSR_IMPRECISERR_Msk: u32 = 1024;
pub const SCB_CFSR_PRECISERR_Pos: u32 = 9;
pub const SCB_CFSR_PRECISERR_Msk: u32 = 512;
pub const SCB_CFSR_IBUSERR_Pos: u32 = 8;
pub const SCB_CFSR_IBUSERR_Msk: u32 = 256;
pub const SCB_CFSR_DIVBYZERO_Pos: u32 = 25;
pub const SCB_CFSR_DIVBYZERO_Msk: u32 = 33554432;
pub const SCB_CFSR_UNALIGNED_Pos: u32 = 24;
pub const SCB_CFSR_UNALIGNED_Msk: u32 = 16777216;
pub const SCB_CFSR_NOCP_Pos: u32 = 19;
pub const SCB_CFSR_NOCP_Msk: u32 = 524288;
pub const SCB_CFSR_INVPC_Pos: u32 = 18;
pub const SCB_CFSR_INVPC_Msk: u32 = 262144;
pub const SCB_CFSR_INVSTATE_Pos: u32 = 17;
pub const SCB_CFSR_INVSTATE_Msk: u32 = 131072;
pub const SCB_CFSR_UNDEFINSTR_Pos: u32 = 16;
pub const SCB_CFSR_UNDEFINSTR_Msk: u32 = 65536;
pub const SCB_HFSR_DEBUGEVT_Pos: u32 = 31;
pub const SCB_HFSR_DEBUGEVT_Msk: u32 = 2147483648;
pub const SCB_HFSR_FORCED_Pos: u32 = 30;
pub const SCB_HFSR_FORCED_Msk: u32 = 1073741824;
pub const SCB_HFSR_VECTTBL_Pos: u32 = 1;
pub const SCB_HFSR_VECTTBL_Msk: u32 = 2;
pub const SCB_DFSR_EXTERNAL_Pos: u32 = 4;
pub const SCB_DFSR_EXTERNAL_Msk: u32 = 16;
pub const SCB_DFSR_VCATCH_Pos: u32 = 3;
pub const SCB_DFSR_VCATCH_Msk: u32 = 8;
pub const SCB_DFSR_DWTTRAP_Pos: u32 = 2;
pub const SCB_DFSR_DWTTRAP_Msk: u32 = 4;
pub const SCB_DFSR_BKPT_Pos: u32 = 1;
pub const SCB_DFSR_BKPT_Msk: u32 = 2;
pub const SCB_DFSR_HALTED_Pos: u32 = 0;
pub const SCB_DFSR_HALTED_Msk: u32 = 1;
pub const SCnSCB_ICTR_INTLINESNUM_Pos: u32 = 0;
pub const SCnSCB_ICTR_INTLINESNUM_Msk: u32 = 15;
pub const SCnSCB_ACTLR_DISOOFP_Pos: u32 = 9;
pub const SCnSCB_ACTLR_DISOOFP_Msk: u32 = 512;
pub const SCnSCB_ACTLR_DISFPCA_Pos: u32 = 8;
pub const SCnSCB_ACTLR_DISFPCA_Msk: u32 = 256;
pub const SCnSCB_ACTLR_DISFOLD_Pos: u32 = 2;
pub const SCnSCB_ACTLR_DISFOLD_Msk: u32 = 4;
pub const SCnSCB_ACTLR_DISDEFWBUF_Pos: u32 = 1;
pub const SCnSCB_ACTLR_DISDEFWBUF_Msk: u32 = 2;
pub const SCnSCB_ACTLR_DISMCYCINT_Pos: u32 = 0;
pub const SCnSCB_ACTLR_DISMCYCINT_Msk: u32 = 1;
pub const SysTick_CTRL_COUNTFLAG_Pos: u32 = 16;
pub const SysTick_CTRL_COUNTFLAG_Msk: u32 = 65536;
pub const SysTick_CTRL_CLKSOURCE_Pos: u32 = 2;
pub const SysTick_CTRL_CLKSOURCE_Msk: u32 = 4;
pub const SysTick_CTRL_TICKINT_Pos: u32 = 1;
pub const SysTick_CTRL_TICKINT_Msk: u32 = 2;
pub const SysTick_CTRL_ENABLE_Pos: u32 = 0;
pub const SysTick_CTRL_ENABLE_Msk: u32 = 1;
pub const SysTick_LOAD_RELOAD_Pos: u32 = 0;
pub const SysTick_LOAD_RELOAD_Msk: u32 = 16777215;
pub const SysTick_VAL_CURRENT_Pos: u32 = 0;
pub const SysTick_VAL_CURRENT_Msk: u32 = 16777215;
pub const SysTick_CALIB_NOREF_Pos: u32 = 31;
pub const SysTick_CALIB_NOREF_Msk: u32 = 2147483648;
pub const SysTick_CALIB_SKEW_Pos: u32 = 30;
pub const SysTick_CALIB_SKEW_Msk: u32 = 1073741824;
pub const SysTick_CALIB_TENMS_Pos: u32 = 0;
pub const SysTick_CALIB_TENMS_Msk: u32 = 16777215;
pub const ITM_TPR_PRIVMASK_Pos: u32 = 0;
pub const ITM_TPR_PRIVMASK_Msk: u32 = 4294967295;
pub const ITM_TCR_BUSY_Pos: u32 = 23;
pub const ITM_TCR_BUSY_Msk: u32 = 8388608;
pub const ITM_TCR_TraceBusID_Pos: u32 = 16;
pub const ITM_TCR_TraceBusID_Msk: u32 = 8323072;
pub const ITM_TCR_GTSFREQ_Pos: u32 = 10;
pub const ITM_TCR_GTSFREQ_Msk: u32 = 3072;
pub const ITM_TCR_TSPrescale_Pos: u32 = 8;
pub const ITM_TCR_TSPrescale_Msk: u32 = 768;
pub const ITM_TCR_SWOENA_Pos: u32 = 4;
pub const ITM_TCR_SWOENA_Msk: u32 = 16;
pub const ITM_TCR_DWTENA_Pos: u32 = 3;
pub const ITM_TCR_DWTENA_Msk: u32 = 8;
pub const ITM_TCR_SYNCENA_Pos: u32 = 2;
pub const ITM_TCR_SYNCENA_Msk: u32 = 4;
pub const ITM_TCR_TSENA_Pos: u32 = 1;
pub const ITM_TCR_TSENA_Msk: u32 = 2;
pub const ITM_TCR_ITMENA_Pos: u32 = 0;
pub const ITM_TCR_ITMENA_Msk: u32 = 1;
pub const ITM_LSR_ByteAcc_Pos: u32 = 2;
pub const ITM_LSR_ByteAcc_Msk: u32 = 4;
pub const ITM_LSR_Access_Pos: u32 = 1;
pub const ITM_LSR_Access_Msk: u32 = 2;
pub const ITM_LSR_Present_Pos: u32 = 0;
pub const ITM_LSR_Present_Msk: u32 = 1;
pub const DWT_CTRL_NUMCOMP_Pos: u32 = 28;
pub const DWT_CTRL_NUMCOMP_Msk: u32 = 4026531840;
pub const DWT_CTRL_NOTRCPKT_Pos: u32 = 27;
pub const DWT_CTRL_NOTRCPKT_Msk: u32 = 134217728;
pub const DWT_CTRL_NOEXTTRIG_Pos: u32 = 26;
pub const DWT_CTRL_NOEXTTRIG_Msk: u32 = 67108864;
pub const DWT_CTRL_NOCYCCNT_Pos: u32 = 25;
pub const DWT_CTRL_NOCYCCNT_Msk: u32 = 33554432;
pub const DWT_CTRL_NOPRFCNT_Pos: u32 = 24;
pub const DWT_CTRL_NOPRFCNT_Msk: u32 = 16777216;
pub const DWT_CTRL_CYCEVTENA_Pos: u32 = 22;
pub const DWT_CTRL_CYCEVTENA_Msk: u32 = 4194304;
pub const DWT_CTRL_FOLDEVTENA_Pos: u32 = 21;
pub const DWT_CTRL_FOLDEVTENA_Msk: u32 = 2097152;
pub const DWT_CTRL_LSUEVTENA_Pos: u32 = 20;
pub const DWT_CTRL_LSUEVTENA_Msk: u32 = 1048576;
pub const DWT_CTRL_SLEEPEVTENA_Pos: u32 = 19;
pub const DWT_CTRL_SLEEPEVTENA_Msk: u32 = 524288;
pub const DWT_CTRL_EXCEVTENA_Pos: u32 = 18;
pub const DWT_CTRL_EXCEVTENA_Msk: u32 = 262144;
pub const DWT_CTRL_CPIEVTENA_Pos: u32 = 17;
pub const DWT_CTRL_CPIEVTENA_Msk: u32 = 131072;
pub const DWT_CTRL_EXCTRCENA_Pos: u32 = 16;
pub const DWT_CTRL_EXCTRCENA_Msk: u32 = 65536;
pub const DWT_CTRL_PCSAMPLENA_Pos: u32 = 12;
pub const DWT_CTRL_PCSAMPLENA_Msk: u32 = 4096;
pub const DWT_CTRL_SYNCTAP_Pos: u32 = 10;
pub const DWT_CTRL_SYNCTAP_Msk: u32 = 3072;
pub const DWT_CTRL_CYCTAP_Pos: u32 = 9;
pub const DWT_CTRL_CYCTAP_Msk: u32 = 512;
pub const DWT_CTRL_POSTINIT_Pos: u32 = 5;
pub const DWT_CTRL_POSTINIT_Msk: u32 = 480;
pub const DWT_CTRL_POSTPRESET_Pos: u32 = 1;
pub const DWT_CTRL_POSTPRESET_Msk: u32 = 30;
pub const DWT_CTRL_CYCCNTENA_Pos: u32 = 0;
pub const DWT_CTRL_CYCCNTENA_Msk: u32 = 1;
pub const DWT_CPICNT_CPICNT_Pos: u32 = 0;
pub const DWT_CPICNT_CPICNT_Msk: u32 = 255;
pub const DWT_EXCCNT_EXCCNT_Pos: u32 = 0;
pub const DWT_EXCCNT_EXCCNT_Msk: u32 = 255;
pub const DWT_SLEEPCNT_SLEEPCNT_Pos: u32 = 0;
pub const DWT_SLEEPCNT_SLEEPCNT_Msk: u32 = 255;
pub const DWT_LSUCNT_LSUCNT_Pos: u32 = 0;
pub const DWT_LSUCNT_LSUCNT_Msk: u32 = 255;
pub const DWT_FOLDCNT_FOLDCNT_Pos: u32 = 0;
pub const DWT_FOLDCNT_FOLDCNT_Msk: u32 = 255;
pub const DWT_MASK_MASK_Pos: u32 = 0;
pub const DWT_MASK_MASK_Msk: u32 = 31;
pub const DWT_FUNCTION_MATCHED_Pos: u32 = 24;
pub const DWT_FUNCTION_MATCHED_Msk: u32 = 16777216;
pub const DWT_FUNCTION_DATAVADDR1_Pos: u32 = 16;
pub const DWT_FUNCTION_DATAVADDR1_Msk: u32 = 983040;
pub const DWT_FUNCTION_DATAVADDR0_Pos: u32 = 12;
pub const DWT_FUNCTION_DATAVADDR0_Msk: u32 = 61440;
pub const DWT_FUNCTION_DATAVSIZE_Pos: u32 = 10;
pub const DWT_FUNCTION_DATAVSIZE_Msk: u32 = 3072;
pub const DWT_FUNCTION_LNK1ENA_Pos: u32 = 9;
pub const DWT_FUNCTION_LNK1ENA_Msk: u32 = 512;
pub const DWT_FUNCTION_DATAVMATCH_Pos: u32 = 8;
pub const DWT_FUNCTION_DATAVMATCH_Msk: u32 = 256;
pub const DWT_FUNCTION_CYCMATCH_Pos: u32 = 7;
pub const DWT_FUNCTION_CYCMATCH_Msk: u32 = 128;
pub const DWT_FUNCTION_EMITRANGE_Pos: u32 = 5;
pub const DWT_FUNCTION_EMITRANGE_Msk: u32 = 32;
pub const DWT_FUNCTION_FUNCTION_Pos: u32 = 0;
pub const DWT_FUNCTION_FUNCTION_Msk: u32 = 15;
pub const TPI_ACPR_PRESCALER_Pos: u32 = 0;
pub const TPI_ACPR_PRESCALER_Msk: u32 = 8191;
pub const TPI_SPPR_TXMODE_Pos: u32 = 0;
pub const TPI_SPPR_TXMODE_Msk: u32 = 3;
pub const TPI_FFSR_FtNonStop_Pos: u32 = 3;
pub const TPI_FFSR_FtNonStop_Msk: u32 = 8;
pub const TPI_FFSR_TCPresent_Pos: u32 = 2;
pub const TPI_FFSR_TCPresent_Msk: u32 = 4;
pub const TPI_FFSR_FtStopped_Pos: u32 = 1;
pub const TPI_FFSR_FtStopped_Msk: u32 = 2;
pub const TPI_FFSR_FlInProg_Pos: u32 = 0;
pub const TPI_FFSR_FlInProg_Msk: u32 = 1;
pub const TPI_FFCR_TrigIn_Pos: u32 = 8;
pub const TPI_FFCR_TrigIn_Msk: u32 = 256;
pub const TPI_FFCR_EnFCont_Pos: u32 = 1;
pub const TPI_FFCR_EnFCont_Msk: u32 = 2;
pub const TPI_TRIGGER_TRIGGER_Pos: u32 = 0;
pub const TPI_TRIGGER_TRIGGER_Msk: u32 = 1;
pub const TPI_FIFO0_ITM_ATVALID_Pos: u32 = 29;
pub const TPI_FIFO0_ITM_ATVALID_Msk: u32 = 536870912;
pub const TPI_FIFO0_ITM_bytecount_Pos: u32 = 27;
pub const TPI_FIFO0_ITM_bytecount_Msk: u32 = 402653184;
pub const TPI_FIFO0_ETM_ATVALID_Pos: u32 = 26;
pub const TPI_FIFO0_ETM_ATVALID_Msk: u32 = 67108864;
pub const TPI_FIFO0_ETM_bytecount_Pos: u32 = 24;
pub const TPI_FIFO0_ETM_bytecount_Msk: u32 = 50331648;
pub const TPI_FIFO0_ETM2_Pos: u32 = 16;
pub const TPI_FIFO0_ETM2_Msk: u32 = 16711680;
pub const TPI_FIFO0_ETM1_Pos: u32 = 8;
pub const TPI_FIFO0_ETM1_Msk: u32 = 65280;
pub const TPI_FIFO0_ETM0_Pos: u32 = 0;
pub const TPI_FIFO0_ETM0_Msk: u32 = 255;
pub const TPI_ITATBCTR2_ATREADY2_Pos: u32 = 0;
pub const TPI_ITATBCTR2_ATREADY2_Msk: u32 = 1;
pub const TPI_ITATBCTR2_ATREADY1_Pos: u32 = 0;
pub const TPI_ITATBCTR2_ATREADY1_Msk: u32 = 1;
pub const TPI_FIFO1_ITM_ATVALID_Pos: u32 = 29;
pub const TPI_FIFO1_ITM_ATVALID_Msk: u32 = 536870912;
pub const TPI_FIFO1_ITM_bytecount_Pos: u32 = 27;
pub const TPI_FIFO1_ITM_bytecount_Msk: u32 = 402653184;
pub const TPI_FIFO1_ETM_ATVALID_Pos: u32 = 26;
pub const TPI_FIFO1_ETM_ATVALID_Msk: u32 = 67108864;
pub const TPI_FIFO1_ETM_bytecount_Pos: u32 = 24;
pub const TPI_FIFO1_ETM_bytecount_Msk: u32 = 50331648;
pub const TPI_FIFO1_ITM2_Pos: u32 = 16;
pub const TPI_FIFO1_ITM2_Msk: u32 = 16711680;
pub const TPI_FIFO1_ITM1_Pos: u32 = 8;
pub const TPI_FIFO1_ITM1_Msk: u32 = 65280;
pub const TPI_FIFO1_ITM0_Pos: u32 = 0;
pub const TPI_FIFO1_ITM0_Msk: u32 = 255;
pub const TPI_ITATBCTR0_ATREADY2_Pos: u32 = 0;
pub const TPI_ITATBCTR0_ATREADY2_Msk: u32 = 1;
pub const TPI_ITATBCTR0_ATREADY1_Pos: u32 = 0;
pub const TPI_ITATBCTR0_ATREADY1_Msk: u32 = 1;
pub const TPI_ITCTRL_Mode_Pos: u32 = 0;
pub const TPI_ITCTRL_Mode_Msk: u32 = 3;
pub const TPI_DEVID_NRZVALID_Pos: u32 = 11;
pub const TPI_DEVID_NRZVALID_Msk: u32 = 2048;
pub const TPI_DEVID_MANCVALID_Pos: u32 = 10;
pub const TPI_DEVID_MANCVALID_Msk: u32 = 1024;
pub const TPI_DEVID_PTINVALID_Pos: u32 = 9;
pub const TPI_DEVID_PTINVALID_Msk: u32 = 512;
pub const TPI_DEVID_MinBufSz_Pos: u32 = 6;
pub const TPI_DEVID_MinBufSz_Msk: u32 = 448;
pub const TPI_DEVID_AsynClkIn_Pos: u32 = 5;
pub const TPI_DEVID_AsynClkIn_Msk: u32 = 32;
pub const TPI_DEVID_NrTraceInput_Pos: u32 = 0;
pub const TPI_DEVID_NrTraceInput_Msk: u32 = 31;
pub const TPI_DEVTYPE_SubType_Pos: u32 = 4;
pub const TPI_DEVTYPE_SubType_Msk: u32 = 15;
pub const TPI_DEVTYPE_MajorType_Pos: u32 = 0;
pub const TPI_DEVTYPE_MajorType_Msk: u32 = 15;
pub const MPU_TYPE_RALIASES: u32 = 4;
pub const MPU_TYPE_IREGION_Pos: u32 = 16;
pub const MPU_TYPE_IREGION_Msk: u32 = 16711680;
pub const MPU_TYPE_DREGION_Pos: u32 = 8;
pub const MPU_TYPE_DREGION_Msk: u32 = 65280;
pub const MPU_TYPE_SEPARATE_Pos: u32 = 0;
pub const MPU_TYPE_SEPARATE_Msk: u32 = 1;
pub const MPU_CTRL_PRIVDEFENA_Pos: u32 = 2;
pub const MPU_CTRL_PRIVDEFENA_Msk: u32 = 4;
pub const MPU_CTRL_HFNMIENA_Pos: u32 = 1;
pub const MPU_CTRL_HFNMIENA_Msk: u32 = 2;
pub const MPU_CTRL_ENABLE_Pos: u32 = 0;
pub const MPU_CTRL_ENABLE_Msk: u32 = 1;
pub const MPU_RNR_REGION_Pos: u32 = 0;
pub const MPU_RNR_REGION_Msk: u32 = 255;
pub const MPU_RBAR_ADDR_Pos: u32 = 5;
pub const MPU_RBAR_ADDR_Msk: u32 = 4294967264;
pub const MPU_RBAR_VALID_Pos: u32 = 4;
pub const MPU_RBAR_VALID_Msk: u32 = 16;
pub const MPU_RBAR_REGION_Pos: u32 = 0;
pub const MPU_RBAR_REGION_Msk: u32 = 15;
pub const MPU_RASR_ATTRS_Pos: u32 = 16;
pub const MPU_RASR_ATTRS_Msk: u32 = 4294901760;
pub const MPU_RASR_XN_Pos: u32 = 28;
pub const MPU_RASR_XN_Msk: u32 = 268435456;
pub const MPU_RASR_AP_Pos: u32 = 24;
pub const MPU_RASR_AP_Msk: u32 = 117440512;
pub const MPU_RASR_TEX_Pos: u32 = 19;
pub const MPU_RASR_TEX_Msk: u32 = 3670016;
pub const MPU_RASR_S_Pos: u32 = 18;
pub const MPU_RASR_S_Msk: u32 = 262144;
pub const MPU_RASR_C_Pos: u32 = 17;
pub const MPU_RASR_C_Msk: u32 = 131072;
pub const MPU_RASR_B_Pos: u32 = 16;
pub const MPU_RASR_B_Msk: u32 = 65536;
pub const MPU_RASR_SRD_Pos: u32 = 8;
pub const MPU_RASR_SRD_Msk: u32 = 65280;
pub const MPU_RASR_SIZE_Pos: u32 = 1;
pub const MPU_RASR_SIZE_Msk: u32 = 62;
pub const MPU_RASR_ENABLE_Pos: u32 = 0;
pub const MPU_RASR_ENABLE_Msk: u32 = 1;
pub const FPU_FPCCR_ASPEN_Pos: u32 = 31;
pub const FPU_FPCCR_ASPEN_Msk: u32 = 2147483648;
pub const FPU_FPCCR_LSPEN_Pos: u32 = 30;
pub const FPU_FPCCR_LSPEN_Msk: u32 = 1073741824;
pub const FPU_FPCCR_MONRDY_Pos: u32 = 8;
pub const FPU_FPCCR_MONRDY_Msk: u32 = 256;
pub const FPU_FPCCR_BFRDY_Pos: u32 = 6;
pub const FPU_FPCCR_BFRDY_Msk: u32 = 64;
pub const FPU_FPCCR_MMRDY_Pos: u32 = 5;
pub const FPU_FPCCR_MMRDY_Msk: u32 = 32;
pub const FPU_FPCCR_HFRDY_Pos: u32 = 4;
pub const FPU_FPCCR_HFRDY_Msk: u32 = 16;
pub const FPU_FPCCR_THREAD_Pos: u32 = 3;
pub const FPU_FPCCR_THREAD_Msk: u32 = 8;
pub const FPU_FPCCR_USER_Pos: u32 = 1;
pub const FPU_FPCCR_USER_Msk: u32 = 2;
pub const FPU_FPCCR_LSPACT_Pos: u32 = 0;
pub const FPU_FPCCR_LSPACT_Msk: u32 = 1;
pub const FPU_FPCAR_ADDRESS_Pos: u32 = 3;
pub const FPU_FPCAR_ADDRESS_Msk: u32 = 4294967288;
pub const FPU_FPDSCR_AHP_Pos: u32 = 26;
pub const FPU_FPDSCR_AHP_Msk: u32 = 67108864;
pub const FPU_FPDSCR_DN_Pos: u32 = 25;
pub const FPU_FPDSCR_DN_Msk: u32 = 33554432;
pub const FPU_FPDSCR_FZ_Pos: u32 = 24;
pub const FPU_FPDSCR_FZ_Msk: u32 = 16777216;
pub const FPU_FPDSCR_RMode_Pos: u32 = 22;
pub const FPU_FPDSCR_RMode_Msk: u32 = 12582912;
pub const FPU_MVFR0_FP_rounding_modes_Pos: u32 = 28;
pub const FPU_MVFR0_FP_rounding_modes_Msk: u32 = 4026531840;
pub const FPU_MVFR0_Short_vectors_Pos: u32 = 24;
pub const FPU_MVFR0_Short_vectors_Msk: u32 = 251658240;
pub const FPU_MVFR0_Square_root_Pos: u32 = 20;
pub const FPU_MVFR0_Square_root_Msk: u32 = 15728640;
pub const FPU_MVFR0_Divide_Pos: u32 = 16;
pub const FPU_MVFR0_Divide_Msk: u32 = 983040;
pub const FPU_MVFR0_FP_excep_trapping_Pos: u32 = 12;
pub const FPU_MVFR0_FP_excep_trapping_Msk: u32 = 61440;
pub const FPU_MVFR0_Double_precision_Pos: u32 = 8;
pub const FPU_MVFR0_Double_precision_Msk: u32 = 3840;
pub const FPU_MVFR0_Single_precision_Pos: u32 = 4;
pub const FPU_MVFR0_Single_precision_Msk: u32 = 240;
pub const FPU_MVFR0_A_SIMD_registers_Pos: u32 = 0;
pub const FPU_MVFR0_A_SIMD_registers_Msk: u32 = 15;
pub const FPU_MVFR1_FP_fused_MAC_Pos: u32 = 28;
pub const FPU_MVFR1_FP_fused_MAC_Msk: u32 = 4026531840;
pub const FPU_MVFR1_FP_HPFP_Pos: u32 = 24;
pub const FPU_MVFR1_FP_HPFP_Msk: u32 = 251658240;
pub const FPU_MVFR1_D_NaN_mode_Pos: u32 = 4;
pub const FPU_MVFR1_D_NaN_mode_Msk: u32 = 240;
pub const FPU_MVFR1_FtZ_mode_Pos: u32 = 0;
pub const FPU_MVFR1_FtZ_mode_Msk: u32 = 15;
pub const FPU_MVFR2_VFP_Misc_Pos: u32 = 4;
pub const FPU_MVFR2_VFP_Misc_Msk: u32 = 240;
pub const CoreDebug_DHCSR_DBGKEY_Pos: u32 = 16;
pub const CoreDebug_DHCSR_DBGKEY_Msk: u32 = 4294901760;
pub const CoreDebug_DHCSR_S_RESET_ST_Pos: u32 = 25;
pub const CoreDebug_DHCSR_S_RESET_ST_Msk: u32 = 33554432;
pub const CoreDebug_DHCSR_S_RETIRE_ST_Pos: u32 = 24;
pub const CoreDebug_DHCSR_S_RETIRE_ST_Msk: u32 = 16777216;
pub const CoreDebug_DHCSR_S_LOCKUP_Pos: u32 = 19;
pub const CoreDebug_DHCSR_S_LOCKUP_Msk: u32 = 524288;
pub const CoreDebug_DHCSR_S_SLEEP_Pos: u32 = 18;
pub const CoreDebug_DHCSR_S_SLEEP_Msk: u32 = 262144;
pub const CoreDebug_DHCSR_S_HALT_Pos: u32 = 17;
pub const CoreDebug_DHCSR_S_HALT_Msk: u32 = 131072;
pub const CoreDebug_DHCSR_S_REGRDY_Pos: u32 = 16;
pub const CoreDebug_DHCSR_S_REGRDY_Msk: u32 = 65536;
pub const CoreDebug_DHCSR_C_SNAPSTALL_Pos: u32 = 5;
pub const CoreDebug_DHCSR_C_SNAPSTALL_Msk: u32 = 32;
pub const CoreDebug_DHCSR_C_MASKINTS_Pos: u32 = 3;
pub const CoreDebug_DHCSR_C_MASKINTS_Msk: u32 = 8;
pub const CoreDebug_DHCSR_C_STEP_Pos: u32 = 2;
pub const CoreDebug_DHCSR_C_STEP_Msk: u32 = 4;
pub const CoreDebug_DHCSR_C_HALT_Pos: u32 = 1;
pub const CoreDebug_DHCSR_C_HALT_Msk: u32 = 2;
pub const CoreDebug_DHCSR_C_DEBUGEN_Pos: u32 = 0;
pub const CoreDebug_DHCSR_C_DEBUGEN_Msk: u32 = 1;
pub const CoreDebug_DCRSR_REGWnR_Pos: u32 = 16;
pub const CoreDebug_DCRSR_REGWnR_Msk: u32 = 65536;
pub const CoreDebug_DCRSR_REGSEL_Pos: u32 = 0;
pub const CoreDebug_DCRSR_REGSEL_Msk: u32 = 31;
pub const CoreDebug_DEMCR_TRCENA_Pos: u32 = 24;
pub const CoreDebug_DEMCR_TRCENA_Msk: u32 = 16777216;
pub const CoreDebug_DEMCR_MON_REQ_Pos: u32 = 19;
pub const CoreDebug_DEMCR_MON_REQ_Msk: u32 = 524288;
pub const CoreDebug_DEMCR_MON_STEP_Pos: u32 = 18;
pub const CoreDebug_DEMCR_MON_STEP_Msk: u32 = 262144;
pub const CoreDebug_DEMCR_MON_PEND_Pos: u32 = 17;
pub const CoreDebug_DEMCR_MON_PEND_Msk: u32 = 131072;
pub const CoreDebug_DEMCR_MON_EN_Pos: u32 = 16;
pub const CoreDebug_DEMCR_MON_EN_Msk: u32 = 65536;
pub const CoreDebug_DEMCR_VC_HARDERR_Pos: u32 = 10;
pub const CoreDebug_DEMCR_VC_HARDERR_Msk: u32 = 1024;
pub const CoreDebug_DEMCR_VC_INTERR_Pos: u32 = 9;
pub const CoreDebug_DEMCR_VC_INTERR_Msk: u32 = 512;
pub const CoreDebug_DEMCR_VC_BUSERR_Pos: u32 = 8;
pub const CoreDebug_DEMCR_VC_BUSERR_Msk: u32 = 256;
pub const CoreDebug_DEMCR_VC_STATERR_Pos: u32 = 7;
pub const CoreDebug_DEMCR_VC_STATERR_Msk: u32 = 128;
pub const CoreDebug_DEMCR_VC_CHKERR_Pos: u32 = 6;
pub const CoreDebug_DEMCR_VC_CHKERR_Msk: u32 = 64;
pub const CoreDebug_DEMCR_VC_NOCPERR_Pos: u32 = 5;
pub const CoreDebug_DEMCR_VC_NOCPERR_Msk: u32 = 32;
pub const CoreDebug_DEMCR_VC_MMERR_Pos: u32 = 4;
pub const CoreDebug_DEMCR_VC_MMERR_Msk: u32 = 16;
pub const CoreDebug_DEMCR_VC_CORERESET_Pos: u32 = 0;
pub const CoreDebug_DEMCR_VC_CORERESET_Msk: u32 = 1;
pub const SCS_BASE: u32 = 3758153728;
pub const ITM_BASE: u32 = 3758096384;
pub const DWT_BASE: u32 = 3758100480;
pub const TPI_BASE: u32 = 3758358528;
pub const CoreDebug_BASE: u32 = 3758157296;
pub const SysTick_BASE: u32 = 3758153744;
pub const NVIC_BASE: u32 = 3758153984;
pub const SCB_BASE: u32 = 3758157056;
pub const MPU_BASE: u32 = 3758157200;
pub const FPU_BASE: u32 = 3758157616;
pub const NVIC_USER_IRQ_OFFSET: u32 = 16;
pub const EXC_RETURN_HANDLER: u32 = 4294967281;
pub const EXC_RETURN_THREAD_MSP: u32 = 4294967289;
pub const EXC_RETURN_THREAD_PSP: u32 = 4294967293;
pub const EXC_RETURN_HANDLER_FPU: u32 = 4294967265;
pub const EXC_RETURN_THREAD_MSP_FPU: u32 = 4294967273;
pub const EXC_RETURN_THREAD_PSP_FPU: u32 = 4294967277;
pub const ARM_MPU_AP_NONE: u32 = 0;
pub const ARM_MPU_AP_PRIV: u32 = 1;
pub const ARM_MPU_AP_URO: u32 = 2;
pub const ARM_MPU_AP_FULL: u32 = 3;
pub const ARM_MPU_AP_PRO: u32 = 5;
pub const ARM_MPU_AP_RO: u32 = 6;
pub const ARM_MPU_CACHEP_NOCACHE: u32 = 0;
pub const ARM_MPU_CACHEP_WB_WRA: u32 = 1;
pub const ARM_MPU_CACHEP_WT_NWA: u32 = 2;
pub const ARM_MPU_CACHEP_WB_NWA: u32 = 3;
pub const FLASH_BASE: u32 = 134217728;
pub const SRAM_BASE: u32 = 536870912;
pub const PERIPH_BASE: u32 = 1073741824;
pub const SYSTEM_MEMORY_BASE: u32 = 536805376;
pub const OTP_AREA_BASE: u32 = 536834048;
pub const OPTION_BYTE_BASE: u32 = 536838144;
pub const ENGI_BYTE_BASE: u32 = 536835072;
pub const SRAM1_BASE: u32 = 536870912;
pub const SRAM2A_BASE: u32 = 537067520;
pub const SRAM2B_BASE: u32 = 537100288;
pub const SRAM1_SIZE: u32 = 196608;
pub const SRAM2A_SIZE: u32 = 32768;
pub const SRAM2B_SIZE: u32 = 32768;
pub const SRAM1_END_ADDR: u32 = 537067519;
pub const SRAM2A_END_ADDR: u32 = 537100287;
pub const SRAM2B_END_ADDR: u32 = 537133055;
pub const SYSTEM_MEMORY_END_ADDR: u32 = 536834047;
pub const OTP_AREA_END_ADDR: u32 = 536835071;
pub const OPTION_BYTE_END_ADDR: u32 = 536842239;
pub const ENGI_BYTE_END_ADDR: u32 = 536838143;
pub const APB1PERIPH_BASE: u32 = 1073741824;
pub const APB2PERIPH_BASE: u32 = 1073807360;
pub const AHB1PERIPH_BASE: u32 = 1073872896;
pub const AHB2PERIPH_BASE: u32 = 1207959552;
pub const AHB4PERIPH_BASE: u32 = 1476395008;
pub const APB3PERIPH_BASE: u32 = 1610612736;
pub const AHB3PERIPH_BASE: u32 = 2415919104;
pub const TIM2_BASE: u32 = 1073741824;
pub const LCD_BASE: u32 = 1073751040;
pub const RTC_BASE: u32 = 1073752064;
pub const WWDG_BASE: u32 = 1073753088;
pub const IWDG_BASE: u32 = 1073754112;
pub const SPI2_BASE: u32 = 1073756160;
pub const I2C1_BASE: u32 = 1073763328;
pub const I2C3_BASE: u32 = 1073765376;
pub const CRS_BASE: u32 = 1073766400;
pub const USB1_BASE: u32 = 1073768448;
pub const USB1_PMAADDR: u32 = 1073769472;
pub const LPTIM1_BASE: u32 = 1073773568;
pub const LPUART1_BASE: u32 = 1073774592;
pub const LPTIM2_BASE: u32 = 1073779712;
pub const SYSCFG_BASE: u32 = 1073807360;
pub const VREFBUF_BASE: u32 = 1073807408;
pub const COMP1_BASE: u32 = 1073807872;
pub const COMP2_BASE: u32 = 1073807876;
pub const TIM1_BASE: u32 = 1073818624;
pub const SPI1_BASE: u32 = 1073819648;
pub const USART1_BASE: u32 = 1073821696;
pub const TIM16_BASE: u32 = 1073824768;
pub const TIM17_BASE: u32 = 1073825792;
pub const SAI1_BASE: u32 = 1073828864;
pub const SAI1_Block_A_BASE: u32 = 1073828868;
pub const SAI1_Block_B_BASE: u32 = 1073828900;
pub const DMA1_BASE: u32 = 1073872896;
pub const DMA2_BASE: u32 = 1073873920;
pub const DMAMUX1_BASE: u32 = 1073874944;
pub const CRC_BASE: u32 = 1073885184;
pub const TSC_BASE: u32 = 1073889280;
pub const DMA1_Channel1_BASE: u32 = 1073872904;
pub const DMA1_Channel2_BASE: u32 = 1073872924;
pub const DMA1_Channel3_BASE: u32 = 1073872944;
pub const DMA1_Channel4_BASE: u32 = 1073872964;
pub const DMA1_Channel5_BASE: u32 = 1073872984;
pub const DMA1_Channel6_BASE: u32 = 1073873004;
pub const DMA1_Channel7_BASE: u32 = 1073873024;
pub const DMA2_Channel1_BASE: u32 = 1073873928;
pub const DMA2_Channel2_BASE: u32 = 1073873948;
pub const DMA2_Channel3_BASE: u32 = 1073873968;
pub const DMA2_Channel4_BASE: u32 = 1073873988;
pub const DMA2_Channel5_BASE: u32 = 1073874008;
pub const DMA2_Channel6_BASE: u32 = 1073874028;
pub const DMA2_Channel7_BASE: u32 = 1073874048;
pub const DMAMUX1_Channel0_BASE: u32 = 1073874944;
pub const DMAMUX1_Channel1_BASE: u32 = 1073874948;
pub const DMAMUX1_Channel2_BASE: u32 = 1073874952;
pub const DMAMUX1_Channel3_BASE: u32 = 1073874956;
pub const DMAMUX1_Channel4_BASE: u32 = 1073874960;
pub const DMAMUX1_Channel5_BASE: u32 = 1073874964;
pub const DMAMUX1_Channel6_BASE: u32 = 1073874968;
pub const DMAMUX1_Channel7_BASE: u32 = 1073874972;
pub const DMAMUX1_Channel8_BASE: u32 = 1073874976;
pub const DMAMUX1_Channel9_BASE: u32 = 1073874980;
pub const DMAMUX1_Channel10_BASE: u32 = 1073874984;
pub const DMAMUX1_Channel11_BASE: u32 = 1073874988;
pub const DMAMUX1_Channel12_BASE: u32 = 1073874992;
pub const DMAMUX1_Channel13_BASE: u32 = 1073874996;
pub const DMAMUX1_RequestGenerator0_BASE: u32 = 1073875200;
pub const DMAMUX1_RequestGenerator1_BASE: u32 = 1073875204;
pub const DMAMUX1_RequestGenerator2_BASE: u32 = 1073875208;
pub const DMAMUX1_RequestGenerator3_BASE: u32 = 1073875212;
pub const DMAMUX1_ChannelStatus_BASE: u32 = 1073875072;
pub const DMAMUX1_RequestGenStatus_BASE: u32 = 1073875264;
pub const IOPORT_BASE: u32 = 1207959552;
pub const GPIOA_BASE: u32 = 1207959552;
pub const GPIOB_BASE: u32 = 1207960576;
pub const GPIOC_BASE: u32 = 1207961600;
pub const GPIOD_BASE: u32 = 1207962624;
pub const GPIOE_BASE: u32 = 1207963648;
pub const GPIOH_BASE: u32 = 1207966720;
pub const ADC1_BASE: u32 = 1342439424;
pub const ADC1_COMMON_BASE: u32 = 1342440192;
pub const AES1_BASE: u32 = 1342570496;
pub const RCC_BASE: u32 = 1476395008;
pub const PWR_BASE: u32 = 1476396032;
pub const EXTI_BASE: u32 = 1476397056;
pub const IPCC_BASE: u32 = 1476398080;
pub const RNG_BASE: u32 = 1476399104;
pub const HSEM_BASE: u32 = 1476400128;
pub const AES2_BASE: u32 = 1476401152;
pub const PKA_BASE: u32 = 1476403200;
pub const FLASH_REG_BASE: u32 = 1476411392;
pub const DBGMCU_BASE: u32 = 3758366720;
pub const QUADSPI_BASE: u32 = 2415919104;
pub const QUADSPI_R_BASE: u32 = 2684358656;
pub const LSI_STARTUP_TIME: u32 = 130;
pub const ADC_ISR_ADRDY_Pos: u32 = 0;
pub const ADC_ISR_ADRDY_Msk: u32 = 1;
pub const ADC_ISR_ADRDY: u32 = 1;
pub const ADC_ISR_EOSMP_Pos: u32 = 1;
pub const ADC_ISR_EOSMP_Msk: u32 = 2;
pub const ADC_ISR_EOSMP: u32 = 2;
pub const ADC_ISR_EOC_Pos: u32 = 2;
pub const ADC_ISR_EOC_Msk: u32 = 4;
pub const ADC_ISR_EOC: u32 = 4;
pub const ADC_ISR_EOS_Pos: u32 = 3;
pub const ADC_ISR_EOS_Msk: u32 = 8;
pub const ADC_ISR_EOS: u32 = 8;
pub const ADC_ISR_OVR_Pos: u32 = 4;
pub const ADC_ISR_OVR_Msk: u32 = 16;
pub const ADC_ISR_OVR: u32 = 16;
pub const ADC_ISR_JEOC_Pos: u32 = 5;
pub const ADC_ISR_JEOC_Msk: u32 = 32;
pub const ADC_ISR_JEOC: u32 = 32;
pub const ADC_ISR_JEOS_Pos: u32 = 6;
pub const ADC_ISR_JEOS_Msk: u32 = 64;
pub const ADC_ISR_JEOS: u32 = 64;
pub const ADC_ISR_AWD1_Pos: u32 = 7;
pub const ADC_ISR_AWD1_Msk: u32 = 128;
pub const ADC_ISR_AWD1: u32 = 128;
pub const ADC_ISR_AWD2_Pos: u32 = 8;
pub const ADC_ISR_AWD2_Msk: u32 = 256;
pub const ADC_ISR_AWD2: u32 = 256;
pub const ADC_ISR_AWD3_Pos: u32 = 9;
pub const ADC_ISR_AWD3_Msk: u32 = 512;
pub const ADC_ISR_AWD3: u32 = 512;
pub const ADC_ISR_JQOVF_Pos: u32 = 10;
pub const ADC_ISR_JQOVF_Msk: u32 = 1024;
pub const ADC_ISR_JQOVF: u32 = 1024;
pub const ADC_IER_ADRDYIE_Pos: u32 = 0;
pub const ADC_IER_ADRDYIE_Msk: u32 = 1;
pub const ADC_IER_ADRDYIE: u32 = 1;
pub const ADC_IER_EOSMPIE_Pos: u32 = 1;
pub const ADC_IER_EOSMPIE_Msk: u32 = 2;
pub const ADC_IER_EOSMPIE: u32 = 2;
pub const ADC_IER_EOCIE_Pos: u32 = 2;
pub const ADC_IER_EOCIE_Msk: u32 = 4;
pub const ADC_IER_EOCIE: u32 = 4;
pub const ADC_IER_EOSIE_Pos: u32 = 3;
pub const ADC_IER_EOSIE_Msk: u32 = 8;
pub const ADC_IER_EOSIE: u32 = 8;
pub const ADC_IER_OVRIE_Pos: u32 = 4;
pub const ADC_IER_OVRIE_Msk: u32 = 16;
pub const ADC_IER_OVRIE: u32 = 16;
pub const ADC_IER_JEOCIE_Pos: u32 = 5;
pub const ADC_IER_JEOCIE_Msk: u32 = 32;
pub const ADC_IER_JEOCIE: u32 = 32;
pub const ADC_IER_JEOSIE_Pos: u32 = 6;
pub const ADC_IER_JEOSIE_Msk: u32 = 64;
pub const ADC_IER_JEOSIE: u32 = 64;
pub const ADC_IER_AWD1IE_Pos: u32 = 7;
pub const ADC_IER_AWD1IE_Msk: u32 = 128;
pub const ADC_IER_AWD1IE: u32 = 128;
pub const ADC_IER_AWD2IE_Pos: u32 = 8;
pub const ADC_IER_AWD2IE_Msk: u32 = 256;
pub const ADC_IER_AWD2IE: u32 = 256;
pub const ADC_IER_AWD3IE_Pos: u32 = 9;
pub const ADC_IER_AWD3IE_Msk: u32 = 512;
pub const ADC_IER_AWD3IE: u32 = 512;
pub const ADC_IER_JQOVFIE_Pos: u32 = 10;
pub const ADC_IER_JQOVFIE_Msk: u32 = 1024;
pub const ADC_IER_JQOVFIE: u32 = 1024;
pub const ADC_CR_ADEN_Pos: u32 = 0;
pub const ADC_CR_ADEN_Msk: u32 = 1;
pub const ADC_CR_ADEN: u32 = 1;
pub const ADC_CR_ADDIS_Pos: u32 = 1;
pub const ADC_CR_ADDIS_Msk: u32 = 2;
pub const ADC_CR_ADDIS: u32 = 2;
pub const ADC_CR_ADSTART_Pos: u32 = 2;
pub const ADC_CR_ADSTART_Msk: u32 = 4;
pub const ADC_CR_ADSTART: u32 = 4;
pub const ADC_CR_JADSTART_Pos: u32 = 3;
pub const ADC_CR_JADSTART_Msk: u32 = 8;
pub const ADC_CR_JADSTART: u32 = 8;
pub const ADC_CR_ADSTP_Pos: u32 = 4;
pub const ADC_CR_ADSTP_Msk: u32 = 16;
pub const ADC_CR_ADSTP: u32 = 16;
pub const ADC_CR_JADSTP_Pos: u32 = 5;
pub const ADC_CR_JADSTP_Msk: u32 = 32;
pub const ADC_CR_JADSTP: u32 = 32;
pub const ADC_CR_ADVREGEN_Pos: u32 = 28;
pub const ADC_CR_ADVREGEN_Msk: u32 = 268435456;
pub const ADC_CR_ADVREGEN: u32 = 268435456;
pub const ADC_CR_DEEPPWD_Pos: u32 = 29;
pub const ADC_CR_DEEPPWD_Msk: u32 = 536870912;
pub const ADC_CR_DEEPPWD: u32 = 536870912;
pub const ADC_CR_ADCALDIF_Pos: u32 = 30;
pub const ADC_CR_ADCALDIF_Msk: u32 = 1073741824;
pub const ADC_CR_ADCALDIF: u32 = 1073741824;
pub const ADC_CR_ADCAL_Pos: u32 = 31;
pub const ADC_CR_ADCAL_Msk: u32 = 2147483648;
pub const ADC_CR_ADCAL: u32 = 2147483648;
pub const ADC_CFGR_DMAEN_Pos: u32 = 0;
pub const ADC_CFGR_DMAEN_Msk: u32 = 1;
pub const ADC_CFGR_DMAEN: u32 = 1;
pub const ADC_CFGR_DMACFG_Pos: u32 = 1;
pub const ADC_CFGR_DMACFG_Msk: u32 = 2;
pub const ADC_CFGR_DMACFG: u32 = 2;
pub const ADC_CFGR_RES_Pos: u32 = 3;
pub const ADC_CFGR_RES_Msk: u32 = 24;
pub const ADC_CFGR_RES: u32 = 24;
pub const ADC_CFGR_RES_0: u32 = 8;
pub const ADC_CFGR_RES_1: u32 = 16;
pub const ADC_CFGR_ALIGN_Pos: u32 = 5;
pub const ADC_CFGR_ALIGN_Msk: u32 = 32;
pub const ADC_CFGR_ALIGN: u32 = 32;
pub const ADC_CFGR_EXTSEL_Pos: u32 = 6;
pub const ADC_CFGR_EXTSEL_Msk: u32 = 960;
pub const ADC_CFGR_EXTSEL: u32 = 960;
pub const ADC_CFGR_EXTSEL_0: u32 = 64;
pub const ADC_CFGR_EXTSEL_1: u32 = 128;
pub const ADC_CFGR_EXTSEL_2: u32 = 256;
pub const ADC_CFGR_EXTSEL_3: u32 = 512;
pub const ADC_CFGR_EXTEN_Pos: u32 = 10;
pub const ADC_CFGR_EXTEN_Msk: u32 = 3072;
pub const ADC_CFGR_EXTEN: u32 = 3072;
pub const ADC_CFGR_EXTEN_0: u32 = 1024;
pub const ADC_CFGR_EXTEN_1: u32 = 2048;
pub const ADC_CFGR_OVRMOD_Pos: u32 = 12;
pub const ADC_CFGR_OVRMOD_Msk: u32 = 4096;
pub const ADC_CFGR_OVRMOD: u32 = 4096;
pub const ADC_CFGR_CONT_Pos: u32 = 13;
pub const ADC_CFGR_CONT_Msk: u32 = 8192;
pub const ADC_CFGR_CONT: u32 = 8192;
pub const ADC_CFGR_AUTDLY_Pos: u32 = 14;
pub const ADC_CFGR_AUTDLY_Msk: u32 = 16384;
pub const ADC_CFGR_AUTDLY: u32 = 16384;
pub const ADC_CFGR_DISCEN_Pos: u32 = 16;
pub const ADC_CFGR_DISCEN_Msk: u32 = 65536;
pub const ADC_CFGR_DISCEN: u32 = 65536;
pub const ADC_CFGR_DISCNUM_Pos: u32 = 17;
pub const ADC_CFGR_DISCNUM_Msk: u32 = 917504;
pub const ADC_CFGR_DISCNUM: u32 = 917504;
pub const ADC_CFGR_DISCNUM_0: u32 = 131072;
pub const ADC_CFGR_DISCNUM_1: u32 = 262144;
pub const ADC_CFGR_DISCNUM_2: u32 = 524288;
pub const ADC_CFGR_JDISCEN_Pos: u32 = 20;
pub const ADC_CFGR_JDISCEN_Msk: u32 = 1048576;
pub const ADC_CFGR_JDISCEN: u32 = 1048576;
pub const ADC_CFGR_JQM_Pos: u32 = 21;
pub const ADC_CFGR_JQM_Msk: u32 = 2097152;
pub const ADC_CFGR_JQM: u32 = 2097152;
pub const ADC_CFGR_AWD1SGL_Pos: u32 = 22;
pub const ADC_CFGR_AWD1SGL_Msk: u32 = 4194304;
pub const ADC_CFGR_AWD1SGL: u32 = 4194304;
pub const ADC_CFGR_AWD1EN_Pos: u32 = 23;
pub const ADC_CFGR_AWD1EN_Msk: u32 = 8388608;
pub const ADC_CFGR_AWD1EN: u32 = 8388608;
pub const ADC_CFGR_JAWD1EN_Pos: u32 = 24;
pub const ADC_CFGR_JAWD1EN_Msk: u32 = 16777216;
pub const ADC_CFGR_JAWD1EN: u32 = 16777216;
pub const ADC_CFGR_JAUTO_Pos: u32 = 25;
pub const ADC_CFGR_JAUTO_Msk: u32 = 33554432;
pub const ADC_CFGR_JAUTO: u32 = 33554432;
pub const ADC_CFGR_AWD1CH_Pos: u32 = 26;
pub const ADC_CFGR_AWD1CH_Msk: u32 = 2080374784;
pub const ADC_CFGR_AWD1CH: u32 = 2080374784;
pub const ADC_CFGR_AWD1CH_0: u32 = 67108864;
pub const ADC_CFGR_AWD1CH_1: u32 = 134217728;
pub const ADC_CFGR_AWD1CH_2: u32 = 268435456;
pub const ADC_CFGR_AWD1CH_3: u32 = 536870912;
pub const ADC_CFGR_AWD1CH_4: u32 = 1073741824;
pub const ADC_CFGR_JQDIS_Pos: u32 = 31;
pub const ADC_CFGR_JQDIS_Msk: u32 = 2147483648;
pub const ADC_CFGR_JQDIS: u32 = 2147483648;
pub const ADC_CFGR2_ROVSE_Pos: u32 = 0;
pub const ADC_CFGR2_ROVSE_Msk: u32 = 1;
pub const ADC_CFGR2_ROVSE: u32 = 1;
pub const ADC_CFGR2_JOVSE_Pos: u32 = 1;
pub const ADC_CFGR2_JOVSE_Msk: u32 = 2;
pub const ADC_CFGR2_JOVSE: u32 = 2;
pub const ADC_CFGR2_OVSR_Pos: u32 = 2;
pub const ADC_CFGR2_OVSR_Msk: u32 = 28;
pub const ADC_CFGR2_OVSR: u32 = 28;
pub const ADC_CFGR2_OVSR_0: u32 = 4;
pub const ADC_CFGR2_OVSR_1: u32 = 8;
pub const ADC_CFGR2_OVSR_2: u32 = 16;
pub const ADC_CFGR2_OVSS_Pos: u32 = 5;
pub const ADC_CFGR2_OVSS_Msk: u32 = 480;
pub const ADC_CFGR2_OVSS: u32 = 480;
pub const ADC_CFGR2_OVSS_0: u32 = 32;
pub const ADC_CFGR2_OVSS_1: u32 = 64;
pub const ADC_CFGR2_OVSS_2: u32 = 128;
pub const ADC_CFGR2_OVSS_3: u32 = 256;
pub const ADC_CFGR2_TROVS_Pos: u32 = 9;
pub const ADC_CFGR2_TROVS_Msk: u32 = 512;
pub const ADC_CFGR2_TROVS: u32 = 512;
pub const ADC_CFGR2_ROVSM_Pos: u32 = 10;
pub const ADC_CFGR2_ROVSM_Msk: u32 = 1024;
pub const ADC_CFGR2_ROVSM: u32 = 1024;
pub const ADC_SMPR1_SMP0_Pos: u32 = 0;
pub const ADC_SMPR1_SMP0_Msk: u32 = 7;
pub const ADC_SMPR1_SMP0: u32 = 7;
pub const ADC_SMPR1_SMP0_0: u32 = 1;
pub const ADC_SMPR1_SMP0_1: u32 = 2;
pub const ADC_SMPR1_SMP0_2: u32 = 4;
pub const ADC_SMPR1_SMP1_Pos: u32 = 3;
pub const ADC_SMPR1_SMP1_Msk: u32 = 56;
pub const ADC_SMPR1_SMP1: u32 = 56;
pub const ADC_SMPR1_SMP1_0: u32 = 8;
pub const ADC_SMPR1_SMP1_1: u32 = 16;
pub const ADC_SMPR1_SMP1_2: u32 = 32;
pub const ADC_SMPR1_SMP2_Pos: u32 = 6;
pub const ADC_SMPR1_SMP2_Msk: u32 = 448;
pub const ADC_SMPR1_SMP2: u32 = 448;
pub const ADC_SMPR1_SMP2_0: u32 = 64;
pub const ADC_SMPR1_SMP2_1: u32 = 128;
pub const ADC_SMPR1_SMP2_2: u32 = 256;
pub const ADC_SMPR1_SMP3_Pos: u32 = 9;
pub const ADC_SMPR1_SMP3_Msk: u32 = 3584;
pub const ADC_SMPR1_SMP3: u32 = 3584;
pub const ADC_SMPR1_SMP3_0: u32 = 512;
pub const ADC_SMPR1_SMP3_1: u32 = 1024;
pub const ADC_SMPR1_SMP3_2: u32 = 2048;
pub const ADC_SMPR1_SMP4_Pos: u32 = 12;
pub const ADC_SMPR1_SMP4_Msk: u32 = 28672;
pub const ADC_SMPR1_SMP4: u32 = 28672;
pub const ADC_SMPR1_SMP4_0: u32 = 4096;
pub const ADC_SMPR1_SMP4_1: u32 = 8192;
pub const ADC_SMPR1_SMP4_2: u32 = 16384;
pub const ADC_SMPR1_SMP5_Pos: u32 = 15;
pub const ADC_SMPR1_SMP5_Msk: u32 = 229376;
pub const ADC_SMPR1_SMP5: u32 = 229376;
pub const ADC_SMPR1_SMP5_0: u32 = 32768;
pub const ADC_SMPR1_SMP5_1: u32 = 65536;
pub const ADC_SMPR1_SMP5_2: u32 = 131072;
pub const ADC_SMPR1_SMP6_Pos: u32 = 18;
pub const ADC_SMPR1_SMP6_Msk: u32 = 1835008;
pub const ADC_SMPR1_SMP6: u32 = 1835008;
pub const ADC_SMPR1_SMP6_0: u32 = 262144;
pub const ADC_SMPR1_SMP6_1: u32 = 524288;
pub const ADC_SMPR1_SMP6_2: u32 = 1048576;
pub const ADC_SMPR1_SMP7_Pos: u32 = 21;
pub const ADC_SMPR1_SMP7_Msk: u32 = 14680064;
pub const ADC_SMPR1_SMP7: u32 = 14680064;
pub const ADC_SMPR1_SMP7_0: u32 = 2097152;
pub const ADC_SMPR1_SMP7_1: u32 = 4194304;
pub const ADC_SMPR1_SMP7_2: u32 = 8388608;
pub const ADC_SMPR1_SMP8_Pos: u32 = 24;
pub const ADC_SMPR1_SMP8_Msk: u32 = 117440512;
pub const ADC_SMPR1_SMP8: u32 = 117440512;
pub const ADC_SMPR1_SMP8_0: u32 = 16777216;
pub const ADC_SMPR1_SMP8_1: u32 = 33554432;
pub const ADC_SMPR1_SMP8_2: u32 = 67108864;
pub const ADC_SMPR1_SMP9_Pos: u32 = 27;
pub const ADC_SMPR1_SMP9_Msk: u32 = 939524096;
pub const ADC_SMPR1_SMP9: u32 = 939524096;
pub const ADC_SMPR1_SMP9_0: u32 = 134217728;
pub const ADC_SMPR1_SMP9_1: u32 = 268435456;
pub const ADC_SMPR1_SMP9_2: u32 = 536870912;
pub const ADC_SMPR2_SMP10_Pos: u32 = 0;
pub const ADC_SMPR2_SMP10_Msk: u32 = 7;
pub const ADC_SMPR2_SMP10: u32 = 7;
pub const ADC_SMPR2_SMP10_0: u32 = 1;
pub const ADC_SMPR2_SMP10_1: u32 = 2;
pub const ADC_SMPR2_SMP10_2: u32 = 4;
pub const ADC_SMPR2_SMP11_Pos: u32 = 3;
pub const ADC_SMPR2_SMP11_Msk: u32 = 56;
pub const ADC_SMPR2_SMP11: u32 = 56;
pub const ADC_SMPR2_SMP11_0: u32 = 8;
pub const ADC_SMPR2_SMP11_1: u32 = 16;
pub const ADC_SMPR2_SMP11_2: u32 = 32;
pub const ADC_SMPR2_SMP12_Pos: u32 = 6;
pub const ADC_SMPR2_SMP12_Msk: u32 = 448;
pub const ADC_SMPR2_SMP12: u32 = 448;
pub const ADC_SMPR2_SMP12_0: u32 = 64;
pub const ADC_SMPR2_SMP12_1: u32 = 128;
pub const ADC_SMPR2_SMP12_2: u32 = 256;
pub const ADC_SMPR2_SMP13_Pos: u32 = 9;
pub const ADC_SMPR2_SMP13_Msk: u32 = 3584;
pub const ADC_SMPR2_SMP13: u32 = 3584;
pub const ADC_SMPR2_SMP13_0: u32 = 512;
pub const ADC_SMPR2_SMP13_1: u32 = 1024;
pub const ADC_SMPR2_SMP13_2: u32 = 2048;
pub const ADC_SMPR2_SMP14_Pos: u32 = 12;
pub const ADC_SMPR2_SMP14_Msk: u32 = 28672;
pub const ADC_SMPR2_SMP14: u32 = 28672;
pub const ADC_SMPR2_SMP14_0: u32 = 4096;
pub const ADC_SMPR2_SMP14_1: u32 = 8192;
pub const ADC_SMPR2_SMP14_2: u32 = 16384;
pub const ADC_SMPR2_SMP15_Pos: u32 = 15;
pub const ADC_SMPR2_SMP15_Msk: u32 = 229376;
pub const ADC_SMPR2_SMP15: u32 = 229376;
pub const ADC_SMPR2_SMP15_0: u32 = 32768;
pub const ADC_SMPR2_SMP15_1: u32 = 65536;
pub const ADC_SMPR2_SMP15_2: u32 = 131072;
pub const ADC_SMPR2_SMP16_Pos: u32 = 18;
pub const ADC_SMPR2_SMP16_Msk: u32 = 1835008;
pub const ADC_SMPR2_SMP16: u32 = 1835008;
pub const ADC_SMPR2_SMP16_0: u32 = 262144;
pub const ADC_SMPR2_SMP16_1: u32 = 524288;
pub const ADC_SMPR2_SMP16_2: u32 = 1048576;
pub const ADC_SMPR2_SMP17_Pos: u32 = 21;
pub const ADC_SMPR2_SMP17_Msk: u32 = 14680064;
pub const ADC_SMPR2_SMP17: u32 = 14680064;
pub const ADC_SMPR2_SMP17_0: u32 = 2097152;
pub const ADC_SMPR2_SMP17_1: u32 = 4194304;
pub const ADC_SMPR2_SMP17_2: u32 = 8388608;
pub const ADC_SMPR2_SMP18_Pos: u32 = 24;
pub const ADC_SMPR2_SMP18_Msk: u32 = 117440512;
pub const ADC_SMPR2_SMP18: u32 = 117440512;
pub const ADC_SMPR2_SMP18_0: u32 = 16777216;
pub const ADC_SMPR2_SMP18_1: u32 = 33554432;
pub const ADC_SMPR2_SMP18_2: u32 = 67108864;
pub const ADC_TR1_LT1_Pos: u32 = 0;
pub const ADC_TR1_LT1_Msk: u32 = 4095;
pub const ADC_TR1_LT1: u32 = 4095;
pub const ADC_TR1_LT1_0: u32 = 1;
pub const ADC_TR1_LT1_1: u32 = 2;
pub const ADC_TR1_LT1_2: u32 = 4;
pub const ADC_TR1_LT1_3: u32 = 8;
pub const ADC_TR1_LT1_4: u32 = 16;
pub const ADC_TR1_LT1_5: u32 = 32;
pub const ADC_TR1_LT1_6: u32 = 64;
pub const ADC_TR1_LT1_7: u32 = 128;
pub const ADC_TR1_LT1_8: u32 = 256;
pub const ADC_TR1_LT1_9: u32 = 512;
pub const ADC_TR1_LT1_10: u32 = 1024;
pub const ADC_TR1_LT1_11: u32 = 2048;
pub const ADC_TR1_HT1_Pos: u32 = 16;
pub const ADC_TR1_HT1_Msk: u32 = 268369920;
pub const ADC_TR1_HT1: u32 = 268369920;
pub const ADC_TR1_HT1_0: u32 = 65536;
pub const ADC_TR1_HT1_1: u32 = 131072;
pub const ADC_TR1_HT1_2: u32 = 262144;
pub const ADC_TR1_HT1_3: u32 = 524288;
pub const ADC_TR1_HT1_4: u32 = 1048576;
pub const ADC_TR1_HT1_5: u32 = 2097152;
pub const ADC_TR1_HT1_6: u32 = 4194304;
pub const ADC_TR1_HT1_7: u32 = 8388608;
pub const ADC_TR1_HT1_8: u32 = 16777216;
pub const ADC_TR1_HT1_9: u32 = 33554432;
pub const ADC_TR1_HT1_10: u32 = 67108864;
pub const ADC_TR1_HT1_11: u32 = 134217728;
pub const ADC_TR2_LT2_Pos: u32 = 0;
pub const ADC_TR2_LT2_Msk: u32 = 255;
pub const ADC_TR2_LT2: u32 = 255;
pub const ADC_TR2_LT2_0: u32 = 1;
pub const ADC_TR2_LT2_1: u32 = 2;
pub const ADC_TR2_LT2_2: u32 = 4;
pub const ADC_TR2_LT2_3: u32 = 8;
pub const ADC_TR2_LT2_4: u32 = 16;
pub const ADC_TR2_LT2_5: u32 = 32;
pub const ADC_TR2_LT2_6: u32 = 64;
pub const ADC_TR2_LT2_7: u32 = 128;
pub const ADC_TR2_HT2_Pos: u32 = 16;
pub const ADC_TR2_HT2_Msk: u32 = 16711680;
pub const ADC_TR2_HT2: u32 = 16711680;
pub const ADC_TR2_HT2_0: u32 = 65536;
pub const ADC_TR2_HT2_1: u32 = 131072;
pub const ADC_TR2_HT2_2: u32 = 262144;
pub const ADC_TR2_HT2_3: u32 = 524288;
pub const ADC_TR2_HT2_4: u32 = 1048576;
pub const ADC_TR2_HT2_5: u32 = 2097152;
pub const ADC_TR2_HT2_6: u32 = 4194304;
pub const ADC_TR2_HT2_7: u32 = 8388608;
pub const ADC_TR3_LT3_Pos: u32 = 0;
pub const ADC_TR3_LT3_Msk: u32 = 255;
pub const ADC_TR3_LT3: u32 = 255;
pub const ADC_TR3_LT3_0: u32 = 1;
pub const ADC_TR3_LT3_1: u32 = 2;
pub const ADC_TR3_LT3_2: u32 = 4;
pub const ADC_TR3_LT3_3: u32 = 8;
pub const ADC_TR3_LT3_4: u32 = 16;
pub const ADC_TR3_LT3_5: u32 = 32;
pub const ADC_TR3_LT3_6: u32 = 64;
pub const ADC_TR3_LT3_7: u32 = 128;
pub const ADC_TR3_HT3_Pos: u32 = 16;
pub const ADC_TR3_HT3_Msk: u32 = 16711680;
pub const ADC_TR3_HT3: u32 = 16711680;
pub const ADC_TR3_HT3_0: u32 = 65536;
pub const ADC_TR3_HT3_1: u32 = 131072;
pub const ADC_TR3_HT3_2: u32 = 262144;
pub const ADC_TR3_HT3_3: u32 = 524288;
pub const ADC_TR3_HT3_4: u32 = 1048576;
pub const ADC_TR3_HT3_5: u32 = 2097152;
pub const ADC_TR3_HT3_6: u32 = 4194304;
pub const ADC_TR3_HT3_7: u32 = 8388608;
pub const ADC_SQR1_L_Pos: u32 = 0;
pub const ADC_SQR1_L_Msk: u32 = 15;
pub const ADC_SQR1_L: u32 = 15;
pub const ADC_SQR1_L_0: u32 = 1;
pub const ADC_SQR1_L_1: u32 = 2;
pub const ADC_SQR1_L_2: u32 = 4;
pub const ADC_SQR1_L_3: u32 = 8;
pub const ADC_SQR1_SQ1_Pos: u32 = 6;
pub const ADC_SQR1_SQ1_Msk: u32 = 1984;
pub const ADC_SQR1_SQ1: u32 = 1984;
pub const ADC_SQR1_SQ1_0: u32 = 64;
pub const ADC_SQR1_SQ1_1: u32 = 128;
pub const ADC_SQR1_SQ1_2: u32 = 256;
pub const ADC_SQR1_SQ1_3: u32 = 512;
pub const ADC_SQR1_SQ1_4: u32 = 1024;
pub const ADC_SQR1_SQ2_Pos: u32 = 12;
pub const ADC_SQR1_SQ2_Msk: u32 = 126976;
pub const ADC_SQR1_SQ2: u32 = 126976;
pub const ADC_SQR1_SQ2_0: u32 = 4096;
pub const ADC_SQR1_SQ2_1: u32 = 8192;
pub const ADC_SQR1_SQ2_2: u32 = 16384;
pub const ADC_SQR1_SQ2_3: u32 = 32768;
pub const ADC_SQR1_SQ2_4: u32 = 65536;
pub const ADC_SQR1_SQ3_Pos: u32 = 18;
pub const ADC_SQR1_SQ3_Msk: u32 = 8126464;
pub const ADC_SQR1_SQ3: u32 = 8126464;
pub const ADC_SQR1_SQ3_0: u32 = 262144;
pub const ADC_SQR1_SQ3_1: u32 = 524288;
pub const ADC_SQR1_SQ3_2: u32 = 1048576;
pub const ADC_SQR1_SQ3_3: u32 = 2097152;
pub const ADC_SQR1_SQ3_4: u32 = 4194304;
pub const ADC_SQR1_SQ4_Pos: u32 = 24;
pub const ADC_SQR1_SQ4_Msk: u32 = 520093696;
pub const ADC_SQR1_SQ4: u32 = 520093696;
pub const ADC_SQR1_SQ4_0: u32 = 16777216;
pub const ADC_SQR1_SQ4_1: u32 = 33554432;
pub const ADC_SQR1_SQ4_2: u32 = 67108864;
pub const ADC_SQR1_SQ4_3: u32 = 134217728;
pub const ADC_SQR1_SQ4_4: u32 = 268435456;
pub const ADC_SQR2_SQ5_Pos: u32 = 0;
pub const ADC_SQR2_SQ5_Msk: u32 = 31;
pub const ADC_SQR2_SQ5: u32 = 31;
pub const ADC_SQR2_SQ5_0: u32 = 1;
pub const ADC_SQR2_SQ5_1: u32 = 2;
pub const ADC_SQR2_SQ5_2: u32 = 4;
pub const ADC_SQR2_SQ5_3: u32 = 8;
pub const ADC_SQR2_SQ5_4: u32 = 16;
pub const ADC_SQR2_SQ6_Pos: u32 = 6;
pub const ADC_SQR2_SQ6_Msk: u32 = 1984;
pub const ADC_SQR2_SQ6: u32 = 1984;
pub const ADC_SQR2_SQ6_0: u32 = 64;
pub const ADC_SQR2_SQ6_1: u32 = 128;
pub const ADC_SQR2_SQ6_2: u32 = 256;
pub const ADC_SQR2_SQ6_3: u32 = 512;
pub const ADC_SQR2_SQ6_4: u32 = 1024;
pub const ADC_SQR2_SQ7_Pos: u32 = 12;
pub const ADC_SQR2_SQ7_Msk: u32 = 126976;
pub const ADC_SQR2_SQ7: u32 = 126976;
pub const ADC_SQR2_SQ7_0: u32 = 4096;
pub const ADC_SQR2_SQ7_1: u32 = 8192;
pub const ADC_SQR2_SQ7_2: u32 = 16384;
pub const ADC_SQR2_SQ7_3: u32 = 32768;
pub const ADC_SQR2_SQ7_4: u32 = 65536;
pub const ADC_SQR2_SQ8_Pos: u32 = 18;
pub const ADC_SQR2_SQ8_Msk: u32 = 8126464;
pub const ADC_SQR2_SQ8: u32 = 8126464;
pub const ADC_SQR2_SQ8_0: u32 = 262144;
pub const ADC_SQR2_SQ8_1: u32 = 524288;
pub const ADC_SQR2_SQ8_2: u32 = 1048576;
pub const ADC_SQR2_SQ8_3: u32 = 2097152;
pub const ADC_SQR2_SQ8_4: u32 = 4194304;
pub const ADC_SQR2_SQ9_Pos: u32 = 24;
pub const ADC_SQR2_SQ9_Msk: u32 = 520093696;
pub const ADC_SQR2_SQ9: u32 = 520093696;
pub const ADC_SQR2_SQ9_0: u32 = 16777216;
pub const ADC_SQR2_SQ9_1: u32 = 33554432;
pub const ADC_SQR2_SQ9_2: u32 = 67108864;
pub const ADC_SQR2_SQ9_3: u32 = 134217728;
pub const ADC_SQR2_SQ9_4: u32 = 268435456;
pub const ADC_SQR3_SQ10_Pos: u32 = 0;
pub const ADC_SQR3_SQ10_Msk: u32 = 31;
pub const ADC_SQR3_SQ10: u32 = 31;
pub const ADC_SQR3_SQ10_0: u32 = 1;
pub const ADC_SQR3_SQ10_1: u32 = 2;
pub const ADC_SQR3_SQ10_2: u32 = 4;
pub const ADC_SQR3_SQ10_3: u32 = 8;
pub const ADC_SQR3_SQ10_4: u32 = 16;
pub const ADC_SQR3_SQ11_Pos: u32 = 6;
pub const ADC_SQR3_SQ11_Msk: u32 = 1984;
pub const ADC_SQR3_SQ11: u32 = 1984;
pub const ADC_SQR3_SQ11_0: u32 = 64;
pub const ADC_SQR3_SQ11_1: u32 = 128;
pub const ADC_SQR3_SQ11_2: u32 = 256;
pub const ADC_SQR3_SQ11_3: u32 = 512;
pub const ADC_SQR3_SQ11_4: u32 = 1024;
pub const ADC_SQR3_SQ12_Pos: u32 = 12;
pub const ADC_SQR3_SQ12_Msk: u32 = 126976;
pub const ADC_SQR3_SQ12: u32 = 126976;
pub const ADC_SQR3_SQ12_0: u32 = 4096;
pub const ADC_SQR3_SQ12_1: u32 = 8192;
pub const ADC_SQR3_SQ12_2: u32 = 16384;
pub const ADC_SQR3_SQ12_3: u32 = 32768;
pub const ADC_SQR3_SQ12_4: u32 = 65536;
pub const ADC_SQR3_SQ13_Pos: u32 = 18;
pub const ADC_SQR3_SQ13_Msk: u32 = 8126464;
pub const ADC_SQR3_SQ13: u32 = 8126464;
pub const ADC_SQR3_SQ13_0: u32 = 262144;
pub const ADC_SQR3_SQ13_1: u32 = 524288;
pub const ADC_SQR3_SQ13_2: u32 = 1048576;
pub const ADC_SQR3_SQ13_3: u32 = 2097152;
pub const ADC_SQR3_SQ13_4: u32 = 4194304;
pub const ADC_SQR3_SQ14_Pos: u32 = 24;
pub const ADC_SQR3_SQ14_Msk: u32 = 520093696;
pub const ADC_SQR3_SQ14: u32 = 520093696;
pub const ADC_SQR3_SQ14_0: u32 = 16777216;
pub const ADC_SQR3_SQ14_1: u32 = 33554432;
pub const ADC_SQR3_SQ14_2: u32 = 67108864;
pub const ADC_SQR3_SQ14_3: u32 = 134217728;
pub const ADC_SQR3_SQ14_4: u32 = 268435456;
pub const ADC_SQR4_SQ15_Pos: u32 = 0;
pub const ADC_SQR4_SQ15_Msk: u32 = 31;
pub const ADC_SQR4_SQ15: u32 = 31;
pub const ADC_SQR4_SQ15_0: u32 = 1;
pub const ADC_SQR4_SQ15_1: u32 = 2;
pub const ADC_SQR4_SQ15_2: u32 = 4;
pub const ADC_SQR4_SQ15_3: u32 = 8;
pub const ADC_SQR4_SQ15_4: u32 = 16;
pub const ADC_SQR4_SQ16_Pos: u32 = 6;
pub const ADC_SQR4_SQ16_Msk: u32 = 1984;
pub const ADC_SQR4_SQ16: u32 = 1984;
pub const ADC_SQR4_SQ16_0: u32 = 64;
pub const ADC_SQR4_SQ16_1: u32 = 128;
pub const ADC_SQR4_SQ16_2: u32 = 256;
pub const ADC_SQR4_SQ16_3: u32 = 512;
pub const ADC_SQR4_SQ16_4: u32 = 1024;
pub const ADC_DR_RDATA_Pos: u32 = 0;
pub const ADC_DR_RDATA_Msk: u32 = 65535;
pub const ADC_DR_RDATA: u32 = 65535;
pub const ADC_DR_RDATA_0: u32 = 1;
pub const ADC_DR_RDATA_1: u32 = 2;
pub const ADC_DR_RDATA_2: u32 = 4;
pub const ADC_DR_RDATA_3: u32 = 8;
pub const ADC_DR_RDATA_4: u32 = 16;
pub const ADC_DR_RDATA_5: u32 = 32;
pub const ADC_DR_RDATA_6: u32 = 64;
pub const ADC_DR_RDATA_7: u32 = 128;
pub const ADC_DR_RDATA_8: u32 = 256;
pub const ADC_DR_RDATA_9: u32 = 512;
pub const ADC_DR_RDATA_10: u32 = 1024;
pub const ADC_DR_RDATA_11: u32 = 2048;
pub const ADC_DR_RDATA_12: u32 = 4096;
pub const ADC_DR_RDATA_13: u32 = 8192;
pub const ADC_DR_RDATA_14: u32 = 16384;
pub const ADC_DR_RDATA_15: u32 = 32768;
pub const ADC_JSQR_JL_Pos: u32 = 0;
pub const ADC_JSQR_JL_Msk: u32 = 3;
pub const ADC_JSQR_JL: u32 = 3;
pub const ADC_JSQR_JL_0: u32 = 1;
pub const ADC_JSQR_JL_1: u32 = 2;
pub const ADC_JSQR_JEXTSEL_Pos: u32 = 2;
pub const ADC_JSQR_JEXTSEL_Msk: u32 = 60;
pub const ADC_JSQR_JEXTSEL: u32 = 60;
pub const ADC_JSQR_JEXTSEL_0: u32 = 4;
pub const ADC_JSQR_JEXTSEL_1: u32 = 8;
pub const ADC_JSQR_JEXTSEL_2: u32 = 16;
pub const ADC_JSQR_JEXTSEL_3: u32 = 32;
pub const ADC_JSQR_JEXTEN_Pos: u32 = 6;
pub const ADC_JSQR_JEXTEN_Msk: u32 = 192;
pub const ADC_JSQR_JEXTEN: u32 = 192;
pub const ADC_JSQR_JEXTEN_0: u32 = 64;
pub const ADC_JSQR_JEXTEN_1: u32 = 128;
pub const ADC_JSQR_JSQ1_Pos: u32 = 8;
pub const ADC_JSQR_JSQ1_Msk: u32 = 7936;
pub const ADC_JSQR_JSQ1: u32 = 7936;
pub const ADC_JSQR_JSQ1_0: u32 = 256;
pub const ADC_JSQR_JSQ1_1: u32 = 512;
pub const ADC_JSQR_JSQ1_2: u32 = 1024;
pub const ADC_JSQR_JSQ1_3: u32 = 2048;
pub const ADC_JSQR_JSQ1_4: u32 = 4096;
pub const ADC_JSQR_JSQ2_Pos: u32 = 14;
pub const ADC_JSQR_JSQ2_Msk: u32 = 507904;
pub const ADC_JSQR_JSQ2: u32 = 507904;
pub const ADC_JSQR_JSQ2_0: u32 = 16384;
pub const ADC_JSQR_JSQ2_1: u32 = 32768;
pub const ADC_JSQR_JSQ2_2: u32 = 65536;
pub const ADC_JSQR_JSQ2_3: u32 = 131072;
pub const ADC_JSQR_JSQ2_4: u32 = 262144;
pub const ADC_JSQR_JSQ3_Pos: u32 = 20;
pub const ADC_JSQR_JSQ3_Msk: u32 = 32505856;
pub const ADC_JSQR_JSQ3: u32 = 32505856;
pub const ADC_JSQR_JSQ3_0: u32 = 1048576;
pub const ADC_JSQR_JSQ3_1: u32 = 2097152;
pub const ADC_JSQR_JSQ3_2: u32 = 4194304;
pub const ADC_JSQR_JSQ3_3: u32 = 8388608;
pub const ADC_JSQR_JSQ3_4: u32 = 16777216;
pub const ADC_JSQR_JSQ4_Pos: u32 = 26;
pub const ADC_JSQR_JSQ4_Msk: u32 = 2080374784;
pub const ADC_JSQR_JSQ4: u32 = 2080374784;
pub const ADC_JSQR_JSQ4_0: u32 = 67108864;
pub const ADC_JSQR_JSQ4_1: u32 = 134217728;
pub const ADC_JSQR_JSQ4_2: u32 = 268435456;
pub const ADC_JSQR_JSQ4_3: u32 = 536870912;
pub const ADC_JSQR_JSQ4_4: u32 = 1073741824;
pub const ADC_OFR1_OFFSET1_Pos: u32 = 0;
pub const ADC_OFR1_OFFSET1_Msk: u32 = 4095;
pub const ADC_OFR1_OFFSET1: u32 = 4095;
pub const ADC_OFR1_OFFSET1_0: u32 = 1;
pub const ADC_OFR1_OFFSET1_1: u32 = 2;
pub const ADC_OFR1_OFFSET1_2: u32 = 4;
pub const ADC_OFR1_OFFSET1_3: u32 = 8;
pub const ADC_OFR1_OFFSET1_4: u32 = 16;
pub const ADC_OFR1_OFFSET1_5: u32 = 32;
pub const ADC_OFR1_OFFSET1_6: u32 = 64;
pub const ADC_OFR1_OFFSET1_7: u32 = 128;
pub const ADC_OFR1_OFFSET1_8: u32 = 256;
pub const ADC_OFR1_OFFSET1_9: u32 = 512;
pub const ADC_OFR1_OFFSET1_10: u32 = 1024;
pub const ADC_OFR1_OFFSET1_11: u32 = 2048;
pub const ADC_OFR1_OFFSET1_CH_Pos: u32 = 26;
pub const ADC_OFR1_OFFSET1_CH_Msk: u32 = 2080374784;
pub const ADC_OFR1_OFFSET1_CH: u32 = 2080374784;
pub const ADC_OFR1_OFFSET1_CH_0: u32 = 67108864;
pub const ADC_OFR1_OFFSET1_CH_1: u32 = 134217728;
pub const ADC_OFR1_OFFSET1_CH_2: u32 = 268435456;
pub const ADC_OFR1_OFFSET1_CH_3: u32 = 536870912;
pub const ADC_OFR1_OFFSET1_CH_4: u32 = 1073741824;
pub const ADC_OFR1_OFFSET1_EN_Pos: u32 = 31;
pub const ADC_OFR1_OFFSET1_EN_Msk: u32 = 2147483648;
pub const ADC_OFR1_OFFSET1_EN: u32 = 2147483648;
pub const ADC_OFR2_OFFSET2_Pos: u32 = 0;
pub const ADC_OFR2_OFFSET2_Msk: u32 = 4095;
pub const ADC_OFR2_OFFSET2: u32 = 4095;
pub const ADC_OFR2_OFFSET2_0: u32 = 1;
pub const ADC_OFR2_OFFSET2_1: u32 = 2;
pub const ADC_OFR2_OFFSET2_2: u32 = 4;
pub const ADC_OFR2_OFFSET2_3: u32 = 8;
pub const ADC_OFR2_OFFSET2_4: u32 = 16;
pub const ADC_OFR2_OFFSET2_5: u32 = 32;
pub const ADC_OFR2_OFFSET2_6: u32 = 64;
pub const ADC_OFR2_OFFSET2_7: u32 = 128;
pub const ADC_OFR2_OFFSET2_8: u32 = 256;
pub const ADC_OFR2_OFFSET2_9: u32 = 512;
pub const ADC_OFR2_OFFSET2_10: u32 = 1024;
pub const ADC_OFR2_OFFSET2_11: u32 = 2048;
pub const ADC_OFR2_OFFSET2_CH_Pos: u32 = 26;
pub const ADC_OFR2_OFFSET2_CH_Msk: u32 = 2080374784;
pub const ADC_OFR2_OFFSET2_CH: u32 = 2080374784;
pub const ADC_OFR2_OFFSET2_CH_0: u32 = 67108864;
pub const ADC_OFR2_OFFSET2_CH_1: u32 = 134217728;
pub const ADC_OFR2_OFFSET2_CH_2: u32 = 268435456;
pub const ADC_OFR2_OFFSET2_CH_3: u32 = 536870912;
pub const ADC_OFR2_OFFSET2_CH_4: u32 = 1073741824;
pub const ADC_OFR2_OFFSET2_EN_Pos: u32 = 31;
pub const ADC_OFR2_OFFSET2_EN_Msk: u32 = 2147483648;
pub const ADC_OFR2_OFFSET2_EN: u32 = 2147483648;
pub const ADC_OFR3_OFFSET3_Pos: u32 = 0;
pub const ADC_OFR3_OFFSET3_Msk: u32 = 4095;
pub const ADC_OFR3_OFFSET3: u32 = 4095;
pub const ADC_OFR3_OFFSET3_0: u32 = 1;
pub const ADC_OFR3_OFFSET3_1: u32 = 2;
pub const ADC_OFR3_OFFSET3_2: u32 = 4;
pub const ADC_OFR3_OFFSET3_3: u32 = 8;
pub const ADC_OFR3_OFFSET3_4: u32 = 16;
pub const ADC_OFR3_OFFSET3_5: u32 = 32;
pub const ADC_OFR3_OFFSET3_6: u32 = 64;
pub const ADC_OFR3_OFFSET3_7: u32 = 128;
pub const ADC_OFR3_OFFSET3_8: u32 = 256;
pub const ADC_OFR3_OFFSET3_9: u32 = 512;
pub const ADC_OFR3_OFFSET3_10: u32 = 1024;
pub const ADC_OFR3_OFFSET3_11: u32 = 2048;
pub const ADC_OFR3_OFFSET3_CH_Pos: u32 = 26;
pub const ADC_OFR3_OFFSET3_CH_Msk: u32 = 2080374784;
pub const ADC_OFR3_OFFSET3_CH: u32 = 2080374784;
pub const ADC_OFR3_OFFSET3_CH_0: u32 = 67108864;
pub const ADC_OFR3_OFFSET3_CH_1: u32 = 134217728;
pub const ADC_OFR3_OFFSET3_CH_2: u32 = 268435456;
pub const ADC_OFR3_OFFSET3_CH_3: u32 = 536870912;
pub const ADC_OFR3_OFFSET3_CH_4: u32 = 1073741824;
pub const ADC_OFR3_OFFSET3_EN_Pos: u32 = 31;
pub const ADC_OFR3_OFFSET3_EN_Msk: u32 = 2147483648;
pub const ADC_OFR3_OFFSET3_EN: u32 = 2147483648;
pub const ADC_OFR4_OFFSET4_Pos: u32 = 0;
pub const ADC_OFR4_OFFSET4_Msk: u32 = 4095;
pub const ADC_OFR4_OFFSET4: u32 = 4095;
pub const ADC_OFR4_OFFSET4_0: u32 = 1;
pub const ADC_OFR4_OFFSET4_1: u32 = 2;
pub const ADC_OFR4_OFFSET4_2: u32 = 4;
pub const ADC_OFR4_OFFSET4_3: u32 = 8;
pub const ADC_OFR4_OFFSET4_4: u32 = 16;
pub const ADC_OFR4_OFFSET4_5: u32 = 32;
pub const ADC_OFR4_OFFSET4_6: u32 = 64;
pub const ADC_OFR4_OFFSET4_7: u32 = 128;
pub const ADC_OFR4_OFFSET4_8: u32 = 256;
pub const ADC_OFR4_OFFSET4_9: u32 = 512;
pub const ADC_OFR4_OFFSET4_10: u32 = 1024;
pub const ADC_OFR4_OFFSET4_11: u32 = 2048;
pub const ADC_OFR4_OFFSET4_CH_Pos: u32 = 26;
pub const ADC_OFR4_OFFSET4_CH_Msk: u32 = 2080374784;
pub const ADC_OFR4_OFFSET4_CH: u32 = 2080374784;
pub const ADC_OFR4_OFFSET4_CH_0: u32 = 67108864;
pub const ADC_OFR4_OFFSET4_CH_1: u32 = 134217728;
pub const ADC_OFR4_OFFSET4_CH_2: u32 = 268435456;
pub const ADC_OFR4_OFFSET4_CH_3: u32 = 536870912;
pub const ADC_OFR4_OFFSET4_CH_4: u32 = 1073741824;
pub const ADC_OFR4_OFFSET4_EN_Pos: u32 = 31;
pub const ADC_OFR4_OFFSET4_EN_Msk: u32 = 2147483648;
pub const ADC_OFR4_OFFSET4_EN: u32 = 2147483648;
pub const ADC_JDR1_JDATA_Pos: u32 = 0;
pub const ADC_JDR1_JDATA_Msk: u32 = 65535;
pub const ADC_JDR1_JDATA: u32 = 65535;
pub const ADC_JDR1_JDATA_0: u32 = 1;
pub const ADC_JDR1_JDATA_1: u32 = 2;
pub const ADC_JDR1_JDATA_2: u32 = 4;
pub const ADC_JDR1_JDATA_3: u32 = 8;
pub const ADC_JDR1_JDATA_4: u32 = 16;
pub const ADC_JDR1_JDATA_5: u32 = 32;
pub const ADC_JDR1_JDATA_6: u32 = 64;
pub const ADC_JDR1_JDATA_7: u32 = 128;
pub const ADC_JDR1_JDATA_8: u32 = 256;
pub const ADC_JDR1_JDATA_9: u32 = 512;
pub const ADC_JDR1_JDATA_10: u32 = 1024;
pub const ADC_JDR1_JDATA_11: u32 = 2048;
pub const ADC_JDR1_JDATA_12: u32 = 4096;
pub const ADC_JDR1_JDATA_13: u32 = 8192;
pub const ADC_JDR1_JDATA_14: u32 = 16384;
pub const ADC_JDR1_JDATA_15: u32 = 32768;
pub const ADC_JDR2_JDATA_Pos: u32 = 0;
pub const ADC_JDR2_JDATA_Msk: u32 = 65535;
pub const ADC_JDR2_JDATA: u32 = 65535;
pub const ADC_JDR2_JDATA_0: u32 = 1;
pub const ADC_JDR2_JDATA_1: u32 = 2;
pub const ADC_JDR2_JDATA_2: u32 = 4;
pub const ADC_JDR2_JDATA_3: u32 = 8;
pub const ADC_JDR2_JDATA_4: u32 = 16;
pub const ADC_JDR2_JDATA_5: u32 = 32;
pub const ADC_JDR2_JDATA_6: u32 = 64;
pub const ADC_JDR2_JDATA_7: u32 = 128;
pub const ADC_JDR2_JDATA_8: u32 = 256;
pub const ADC_JDR2_JDATA_9: u32 = 512;
pub const ADC_JDR2_JDATA_10: u32 = 1024;
pub const ADC_JDR2_JDATA_11: u32 = 2048;
pub const ADC_JDR2_JDATA_12: u32 = 4096;
pub const ADC_JDR2_JDATA_13: u32 = 8192;
pub const ADC_JDR2_JDATA_14: u32 = 16384;
pub const ADC_JDR2_JDATA_15: u32 = 32768;
pub const ADC_JDR3_JDATA_Pos: u32 = 0;
pub const ADC_JDR3_JDATA_Msk: u32 = 65535;
pub const ADC_JDR3_JDATA: u32 = 65535;
pub const ADC_JDR3_JDATA_0: u32 = 1;
pub const ADC_JDR3_JDATA_1: u32 = 2;
pub const ADC_JDR3_JDATA_2: u32 = 4;
pub const ADC_JDR3_JDATA_3: u32 = 8;
pub const ADC_JDR3_JDATA_4: u32 = 16;
pub const ADC_JDR3_JDATA_5: u32 = 32;
pub const ADC_JDR3_JDATA_6: u32 = 64;
pub const ADC_JDR3_JDATA_7: u32 = 128;
pub const ADC_JDR3_JDATA_8: u32 = 256;
pub const ADC_JDR3_JDATA_9: u32 = 512;
pub const ADC_JDR3_JDATA_10: u32 = 1024;
pub const ADC_JDR3_JDATA_11: u32 = 2048;
pub const ADC_JDR3_JDATA_12: u32 = 4096;
pub const ADC_JDR3_JDATA_13: u32 = 8192;
pub const ADC_JDR3_JDATA_14: u32 = 16384;
pub const ADC_JDR3_JDATA_15: u32 = 32768;
pub const ADC_JDR4_JDATA_Pos: u32 = 0;
pub const ADC_JDR4_JDATA_Msk: u32 = 65535;
pub const ADC_JDR4_JDATA: u32 = 65535;
pub const ADC_JDR4_JDATA_0: u32 = 1;
pub const ADC_JDR4_JDATA_1: u32 = 2;
pub const ADC_JDR4_JDATA_2: u32 = 4;
pub const ADC_JDR4_JDATA_3: u32 = 8;
pub const ADC_JDR4_JDATA_4: u32 = 16;
pub const ADC_JDR4_JDATA_5: u32 = 32;
pub const ADC_JDR4_JDATA_6: u32 = 64;
pub const ADC_JDR4_JDATA_7: u32 = 128;
pub const ADC_JDR4_JDATA_8: u32 = 256;
pub const ADC_JDR4_JDATA_9: u32 = 512;
pub const ADC_JDR4_JDATA_10: u32 = 1024;
pub const ADC_JDR4_JDATA_11: u32 = 2048;
pub const ADC_JDR4_JDATA_12: u32 = 4096;
pub const ADC_JDR4_JDATA_13: u32 = 8192;
pub const ADC_JDR4_JDATA_14: u32 = 16384;
pub const ADC_JDR4_JDATA_15: u32 = 32768;
pub const ADC_AWD2CR_AWD2CH_Pos: u32 = 0;
pub const ADC_AWD2CR_AWD2CH_Msk: u32 = 524287;
pub const ADC_AWD2CR_AWD2CH: u32 = 524287;
pub const ADC_AWD2CR_AWD2CH_0: u32 = 1;
pub const ADC_AWD2CR_AWD2CH_1: u32 = 2;
pub const ADC_AWD2CR_AWD2CH_2: u32 = 4;
pub const ADC_AWD2CR_AWD2CH_3: u32 = 8;
pub const ADC_AWD2CR_AWD2CH_4: u32 = 16;
pub const ADC_AWD2CR_AWD2CH_5: u32 = 32;
pub const ADC_AWD2CR_AWD2CH_6: u32 = 64;
pub const ADC_AWD2CR_AWD2CH_7: u32 = 128;
pub const ADC_AWD2CR_AWD2CH_8: u32 = 256;
pub const ADC_AWD2CR_AWD2CH_9: u32 = 512;
pub const ADC_AWD2CR_AWD2CH_10: u32 = 1024;
pub const ADC_AWD2CR_AWD2CH_11: u32 = 2048;
pub const ADC_AWD2CR_AWD2CH_12: u32 = 4096;
pub const ADC_AWD2CR_AWD2CH_13: u32 = 8192;
pub const ADC_AWD2CR_AWD2CH_14: u32 = 16384;
pub const ADC_AWD2CR_AWD2CH_15: u32 = 32768;
pub const ADC_AWD2CR_AWD2CH_16: u32 = 65536;
pub const ADC_AWD2CR_AWD2CH_17: u32 = 131072;
pub const ADC_AWD2CR_AWD2CH_18: u32 = 262144;
pub const ADC_AWD3CR_AWD3CH_Pos: u32 = 0;
pub const ADC_AWD3CR_AWD3CH_Msk: u32 = 524287;
pub const ADC_AWD3CR_AWD3CH: u32 = 524287;
pub const ADC_AWD3CR_AWD3CH_0: u32 = 1;
pub const ADC_AWD3CR_AWD3CH_1: u32 = 2;
pub const ADC_AWD3CR_AWD3CH_2: u32 = 4;
pub const ADC_AWD3CR_AWD3CH_3: u32 = 8;
pub const ADC_AWD3CR_AWD3CH_4: u32 = 16;
pub const ADC_AWD3CR_AWD3CH_5: u32 = 32;
pub const ADC_AWD3CR_AWD3CH_6: u32 = 64;
pub const ADC_AWD3CR_AWD3CH_7: u32 = 128;
pub const ADC_AWD3CR_AWD3CH_8: u32 = 256;
pub const ADC_AWD3CR_AWD3CH_9: u32 = 512;
pub const ADC_AWD3CR_AWD3CH_10: u32 = 1024;
pub const ADC_AWD3CR_AWD3CH_11: u32 = 2048;
pub const ADC_AWD3CR_AWD3CH_12: u32 = 4096;
pub const ADC_AWD3CR_AWD3CH_13: u32 = 8192;
pub const ADC_AWD3CR_AWD3CH_14: u32 = 16384;
pub const ADC_AWD3CR_AWD3CH_15: u32 = 32768;
pub const ADC_AWD3CR_AWD3CH_16: u32 = 65536;
pub const ADC_AWD3CR_AWD3CH_17: u32 = 131072;
pub const ADC_AWD3CR_AWD3CH_18: u32 = 262144;
pub const ADC_DIFSEL_DIFSEL_Pos: u32 = 0;
pub const ADC_DIFSEL_DIFSEL_Msk: u32 = 524287;
pub const ADC_DIFSEL_DIFSEL: u32 = 524287;
pub const ADC_DIFSEL_DIFSEL_0: u32 = 1;
pub const ADC_DIFSEL_DIFSEL_1: u32 = 2;
pub const ADC_DIFSEL_DIFSEL_2: u32 = 4;
pub const ADC_DIFSEL_DIFSEL_3: u32 = 8;
pub const ADC_DIFSEL_DIFSEL_4: u32 = 16;
pub const ADC_DIFSEL_DIFSEL_5: u32 = 32;
pub const ADC_DIFSEL_DIFSEL_6: u32 = 64;
pub const ADC_DIFSEL_DIFSEL_7: u32 = 128;
pub const ADC_DIFSEL_DIFSEL_8: u32 = 256;
pub const ADC_DIFSEL_DIFSEL_9: u32 = 512;
pub const ADC_DIFSEL_DIFSEL_10: u32 = 1024;
pub const ADC_DIFSEL_DIFSEL_11: u32 = 2048;
pub const ADC_DIFSEL_DIFSEL_12: u32 = 4096;
pub const ADC_DIFSEL_DIFSEL_13: u32 = 8192;
pub const ADC_DIFSEL_DIFSEL_14: u32 = 16384;
pub const ADC_DIFSEL_DIFSEL_15: u32 = 32768;
pub const ADC_DIFSEL_DIFSEL_16: u32 = 65536;
pub const ADC_DIFSEL_DIFSEL_17: u32 = 131072;
pub const ADC_DIFSEL_DIFSEL_18: u32 = 262144;
pub const ADC_CALFACT_CALFACT_S_Pos: u32 = 0;
pub const ADC_CALFACT_CALFACT_S_Msk: u32 = 127;
pub const ADC_CALFACT_CALFACT_S: u32 = 127;
pub const ADC_CALFACT_CALFACT_S_0: u32 = 1;
pub const ADC_CALFACT_CALFACT_S_1: u32 = 2;
pub const ADC_CALFACT_CALFACT_S_2: u32 = 4;
pub const ADC_CALFACT_CALFACT_S_3: u32 = 8;
pub const ADC_CALFACT_CALFACT_S_4: u32 = 16;
pub const ADC_CALFACT_CALFACT_S_5: u32 = 32;
pub const ADC_CALFACT_CALFACT_S_6: u32 = 64;
pub const ADC_CALFACT_CALFACT_D_Pos: u32 = 16;
pub const ADC_CALFACT_CALFACT_D_Msk: u32 = 8323072;
pub const ADC_CALFACT_CALFACT_D: u32 = 8323072;
pub const ADC_CALFACT_CALFACT_D_0: u32 = 65536;
pub const ADC_CALFACT_CALFACT_D_1: u32 = 131072;
pub const ADC_CALFACT_CALFACT_D_2: u32 = 262144;
pub const ADC_CALFACT_CALFACT_D_3: u32 = 524288;
pub const ADC_CALFACT_CALFACT_D_4: u32 = 1048576;
pub const ADC_CALFACT_CALFACT_D_5: u32 = 2097152;
pub const ADC_CALFACT_CALFACT_D_6: u32 = 4194304;
pub const ADC_CCR_DUAL_Pos: u32 = 0;
pub const ADC_CCR_DUAL_Msk: u32 = 31;
pub const ADC_CCR_DUAL: u32 = 31;
pub const ADC_CCR_DUAL_0: u32 = 1;
pub const ADC_CCR_DUAL_1: u32 = 2;
pub const ADC_CCR_DUAL_2: u32 = 4;
pub const ADC_CCR_DUAL_3: u32 = 8;
pub const ADC_CCR_DUAL_4: u32 = 16;
pub const ADC_CCR_DELAY_Pos: u32 = 8;
pub const ADC_CCR_DELAY_Msk: u32 = 3840;
pub const ADC_CCR_DELAY: u32 = 3840;
pub const ADC_CCR_DELAY_0: u32 = 256;
pub const ADC_CCR_DELAY_1: u32 = 512;
pub const ADC_CCR_DELAY_2: u32 = 1024;
pub const ADC_CCR_DELAY_3: u32 = 2048;
pub const ADC_CCR_DMACFG_Pos: u32 = 13;
pub const ADC_CCR_DMACFG_Msk: u32 = 8192;
pub const ADC_CCR_DMACFG: u32 = 8192;
pub const ADC_CCR_MDMA_Pos: u32 = 14;
pub const ADC_CCR_MDMA_Msk: u32 = 49152;
pub const ADC_CCR_MDMA: u32 = 49152;
pub const ADC_CCR_MDMA_0: u32 = 16384;
pub const ADC_CCR_MDMA_1: u32 = 32768;
pub const ADC_CCR_CKMODE_Pos: u32 = 16;
pub const ADC_CCR_CKMODE_Msk: u32 = 196608;
pub const ADC_CCR_CKMODE: u32 = 196608;
pub const ADC_CCR_CKMODE_0: u32 = 65536;
pub const ADC_CCR_CKMODE_1: u32 = 131072;
pub const ADC_CCR_PRESC_Pos: u32 = 18;
pub const ADC_CCR_PRESC_Msk: u32 = 3932160;
pub const ADC_CCR_PRESC: u32 = 3932160;
pub const ADC_CCR_PRESC_0: u32 = 262144;
pub const ADC_CCR_PRESC_1: u32 = 524288;
pub const ADC_CCR_PRESC_2: u32 = 1048576;
pub const ADC_CCR_PRESC_3: u32 = 2097152;
pub const ADC_CCR_VREFEN_Pos: u32 = 22;
pub const ADC_CCR_VREFEN_Msk: u32 = 4194304;
pub const ADC_CCR_VREFEN: u32 = 4194304;
pub const ADC_CCR_TSEN_Pos: u32 = 23;
pub const ADC_CCR_TSEN_Msk: u32 = 8388608;
pub const ADC_CCR_TSEN: u32 = 8388608;
pub const ADC_CCR_VBATEN_Pos: u32 = 24;
pub const ADC_CCR_VBATEN_Msk: u32 = 16777216;
pub const ADC_CCR_VBATEN: u32 = 16777216;
pub const ADC_CCR_MULTI: u32 = 31;
pub const ADC_CCR_MULTI_0: u32 = 1;
pub const ADC_CCR_MULTI_1: u32 = 2;
pub const ADC_CCR_MULTI_2: u32 = 4;
pub const ADC_CCR_MULTI_3: u32 = 8;
pub const ADC_CCR_MULTI_4: u32 = 16;
pub const COMP_CSR_EN_Pos: u32 = 0;
pub const COMP_CSR_EN_Msk: u32 = 1;
pub const COMP_CSR_EN: u32 = 1;
pub const COMP_CSR_PWRMODE_Pos: u32 = 2;
pub const COMP_CSR_PWRMODE_Msk: u32 = 12;
pub const COMP_CSR_PWRMODE: u32 = 12;
pub const COMP_CSR_PWRMODE_0: u32 = 4;
pub const COMP_CSR_PWRMODE_1: u32 = 8;
pub const COMP_CSR_INMSEL_Pos: u32 = 4;
pub const COMP_CSR_INMSEL_Msk: u32 = 112;
pub const COMP_CSR_INMSEL: u32 = 112;
pub const COMP_CSR_INMSEL_0: u32 = 16;
pub const COMP_CSR_INMSEL_1: u32 = 32;
pub const COMP_CSR_INMSEL_2: u32 = 64;
pub const COMP_CSR_INPSEL_Pos: u32 = 7;
pub const COMP_CSR_INPSEL_Msk: u32 = 384;
pub const COMP_CSR_INPSEL: u32 = 384;
pub const COMP_CSR_INPSEL_0: u32 = 128;
pub const COMP_CSR_INPSEL_1: u32 = 256;
pub const COMP_CSR_WINMODE_Pos: u32 = 9;
pub const COMP_CSR_WINMODE_Msk: u32 = 512;
pub const COMP_CSR_WINMODE: u32 = 512;
pub const COMP_CSR_POLARITY_Pos: u32 = 15;
pub const COMP_CSR_POLARITY_Msk: u32 = 32768;
pub const COMP_CSR_POLARITY: u32 = 32768;
pub const COMP_CSR_HYST_Pos: u32 = 16;
pub const COMP_CSR_HYST_Msk: u32 = 196608;
pub const COMP_CSR_HYST: u32 = 196608;
pub const COMP_CSR_HYST_0: u32 = 65536;
pub const COMP_CSR_HYST_1: u32 = 131072;
pub const COMP_CSR_BLANKING_Pos: u32 = 18;
pub const COMP_CSR_BLANKING_Msk: u32 = 1835008;
pub const COMP_CSR_BLANKING: u32 = 1835008;
pub const COMP_CSR_BLANKING_0: u32 = 262144;
pub const COMP_CSR_BLANKING_1: u32 = 524288;
pub const COMP_CSR_BLANKING_2: u32 = 1048576;
pub const COMP_CSR_BRGEN_Pos: u32 = 22;
pub const COMP_CSR_BRGEN_Msk: u32 = 4194304;
pub const COMP_CSR_BRGEN: u32 = 4194304;
pub const COMP_CSR_SCALEN_Pos: u32 = 23;
pub const COMP_CSR_SCALEN_Msk: u32 = 8388608;
pub const COMP_CSR_SCALEN: u32 = 8388608;
pub const COMP_CSR_INMESEL_Pos: u32 = 25;
pub const COMP_CSR_INMESEL_Msk: u32 = 100663296;
pub const COMP_CSR_INMESEL: u32 = 100663296;
pub const COMP_CSR_INMESEL_0: u32 = 33554432;
pub const COMP_CSR_INMESEL_1: u32 = 67108864;
pub const COMP_CSR_VALUE_Pos: u32 = 30;
pub const COMP_CSR_VALUE_Msk: u32 = 1073741824;
pub const COMP_CSR_VALUE: u32 = 1073741824;
pub const COMP_CSR_LOCK_Pos: u32 = 31;
pub const COMP_CSR_LOCK_Msk: u32 = 2147483648;
pub const COMP_CSR_LOCK: u32 = 2147483648;
pub const CRC_DR_DR_Pos: u32 = 0;
pub const CRC_DR_DR_Msk: u32 = 4294967295;
pub const CRC_DR_DR: u32 = 4294967295;
pub const CRC_IDR_IDR_Pos: u32 = 0;
pub const CRC_IDR_IDR_Msk: u32 = 4294967295;
pub const CRC_IDR_IDR: u32 = 4294967295;
pub const CRC_CR_RESET_Pos: u32 = 0;
pub const CRC_CR_RESET_Msk: u32 = 1;
pub const CRC_CR_RESET: u32 = 1;
pub const CRC_CR_POLYSIZE_Pos: u32 = 3;
pub const CRC_CR_POLYSIZE_Msk: u32 = 24;
pub const CRC_CR_POLYSIZE: u32 = 24;
pub const CRC_CR_POLYSIZE_0: u32 = 8;
pub const CRC_CR_POLYSIZE_1: u32 = 16;
pub const CRC_CR_REV_IN_Pos: u32 = 5;
pub const CRC_CR_REV_IN_Msk: u32 = 96;
pub const CRC_CR_REV_IN: u32 = 96;
pub const CRC_CR_REV_IN_0: u32 = 32;
pub const CRC_CR_REV_IN_1: u32 = 64;
pub const CRC_CR_REV_OUT_Pos: u32 = 7;
pub const CRC_CR_REV_OUT_Msk: u32 = 128;
pub const CRC_CR_REV_OUT: u32 = 128;
pub const CRC_INIT_INIT_Pos: u32 = 0;
pub const CRC_INIT_INIT_Msk: u32 = 4294967295;
pub const CRC_INIT_INIT: u32 = 4294967295;
pub const CRC_POL_POL_Pos: u32 = 0;
pub const CRC_POL_POL_Msk: u32 = 4294967295;
pub const CRC_POL_POL: u32 = 4294967295;
pub const AES_CR_EN_Pos: u32 = 0;
pub const AES_CR_EN_Msk: u32 = 1;
pub const AES_CR_EN: u32 = 1;
pub const AES_CR_DATATYPE_Pos: u32 = 1;
pub const AES_CR_DATATYPE_Msk: u32 = 6;
pub const AES_CR_DATATYPE: u32 = 6;
pub const AES_CR_DATATYPE_0: u32 = 2;
pub const AES_CR_DATATYPE_1: u32 = 4;
pub const AES_CR_MODE_Pos: u32 = 3;
pub const AES_CR_MODE_Msk: u32 = 24;
pub const AES_CR_MODE: u32 = 24;
pub const AES_CR_MODE_0: u32 = 8;
pub const AES_CR_MODE_1: u32 = 16;
pub const AES_CR_CHMOD_Pos: u32 = 5;
pub const AES_CR_CHMOD_Msk: u32 = 65632;
pub const AES_CR_CHMOD: u32 = 65632;
pub const AES_CR_CHMOD_0: u32 = 32;
pub const AES_CR_CHMOD_1: u32 = 64;
pub const AES_CR_CHMOD_2: u32 = 65536;
pub const AES_CR_CCFC_Pos: u32 = 7;
pub const AES_CR_CCFC_Msk: u32 = 128;
pub const AES_CR_CCFC: u32 = 128;
pub const AES_CR_ERRC_Pos: u32 = 8;
pub const AES_CR_ERRC_Msk: u32 = 256;
pub const AES_CR_ERRC: u32 = 256;
pub const AES_CR_CCFIE_Pos: u32 = 9;
pub const AES_CR_CCFIE_Msk: u32 = 512;
pub const AES_CR_CCFIE: u32 = 512;
pub const AES_CR_ERRIE_Pos: u32 = 10;
pub const AES_CR_ERRIE_Msk: u32 = 1024;
pub const AES_CR_ERRIE: u32 = 1024;
pub const AES_CR_DMAINEN_Pos: u32 = 11;
pub const AES_CR_DMAINEN_Msk: u32 = 2048;
pub const AES_CR_DMAINEN: u32 = 2048;
pub const AES_CR_DMAOUTEN_Pos: u32 = 12;
pub const AES_CR_DMAOUTEN_Msk: u32 = 4096;
pub const AES_CR_DMAOUTEN: u32 = 4096;
pub const AES_CR_GCMPH_Pos: u32 = 13;
pub const AES_CR_GCMPH_Msk: u32 = 24576;
pub const AES_CR_GCMPH: u32 = 24576;
pub const AES_CR_GCMPH_0: u32 = 8192;
pub const AES_CR_GCMPH_1: u32 = 16384;
pub const AES_CR_KEYSIZE_Pos: u32 = 18;
pub const AES_CR_KEYSIZE_Msk: u32 = 262144;
pub const AES_CR_KEYSIZE: u32 = 262144;
pub const AES_CR_NPBLB_Pos: u32 = 20;
pub const AES_CR_NPBLB_Msk: u32 = 15728640;
pub const AES_CR_NPBLB: u32 = 15728640;
pub const AES_CR_NPBLB_0: u32 = 1048576;
pub const AES_CR_NPBLB_1: u32 = 2097152;
pub const AES_CR_NPBLB_2: u32 = 4194304;
pub const AES_CR_NPBLB_3: u32 = 8388608;
pub const AES_SR_CCF_Pos: u32 = 0;
pub const AES_SR_CCF_Msk: u32 = 1;
pub const AES_SR_CCF: u32 = 1;
pub const AES_SR_RDERR_Pos: u32 = 1;
pub const AES_SR_RDERR_Msk: u32 = 2;
pub const AES_SR_RDERR: u32 = 2;
pub const AES_SR_WRERR_Pos: u32 = 2;
pub const AES_SR_WRERR_Msk: u32 = 4;
pub const AES_SR_WRERR: u32 = 4;
pub const AES_SR_BUSY_Pos: u32 = 3;
pub const AES_SR_BUSY_Msk: u32 = 8;
pub const AES_SR_BUSY: u32 = 8;
pub const AES_DINR_Pos: u32 = 0;
pub const AES_DINR_Msk: u32 = 4294967295;
pub const AES_DINR: u32 = 4294967295;
pub const AES_DOUTR_Pos: u32 = 0;
pub const AES_DOUTR_Msk: u32 = 4294967295;
pub const AES_DOUTR: u32 = 4294967295;
pub const AES_KEYR0_Pos: u32 = 0;
pub const AES_KEYR0_Msk: u32 = 4294967295;
pub const AES_KEYR0: u32 = 4294967295;
pub const AES_KEYR1_Pos: u32 = 0;
pub const AES_KEYR1_Msk: u32 = 4294967295;
pub const AES_KEYR1: u32 = 4294967295;
pub const AES_KEYR2_Pos: u32 = 0;
pub const AES_KEYR2_Msk: u32 = 4294967295;
pub const AES_KEYR2: u32 = 4294967295;
pub const AES_KEYR3_Pos: u32 = 0;
pub const AES_KEYR3_Msk: u32 = 4294967295;
pub const AES_KEYR3: u32 = 4294967295;
pub const AES_KEYR4_Pos: u32 = 0;
pub const AES_KEYR4_Msk: u32 = 4294967295;
pub const AES_KEYR4: u32 = 4294967295;
pub const AES_KEYR5_Pos: u32 = 0;
pub const AES_KEYR5_Msk: u32 = 4294967295;
pub const AES_KEYR5: u32 = 4294967295;
pub const AES_KEYR6_Pos: u32 = 0;
pub const AES_KEYR6_Msk: u32 = 4294967295;
pub const AES_KEYR6: u32 = 4294967295;
pub const AES_KEYR7_Pos: u32 = 0;
pub const AES_KEYR7_Msk: u32 = 4294967295;
pub const AES_KEYR7: u32 = 4294967295;
pub const AES_IVR0_Pos: u32 = 0;
pub const AES_IVR0_Msk: u32 = 4294967295;
pub const AES_IVR0: u32 = 4294967295;
pub const AES_IVR1_Pos: u32 = 0;
pub const AES_IVR1_Msk: u32 = 4294967295;
pub const AES_IVR1: u32 = 4294967295;
pub const AES_IVR2_Pos: u32 = 0;
pub const AES_IVR2_Msk: u32 = 4294967295;
pub const AES_IVR2: u32 = 4294967295;
pub const AES_IVR3_Pos: u32 = 0;
pub const AES_IVR3_Msk: u32 = 4294967295;
pub const AES_IVR3: u32 = 4294967295;
pub const AES_SUSP0R_Pos: u32 = 0;
pub const AES_SUSP0R_Msk: u32 = 4294967295;
pub const AES_SUSP0R: u32 = 4294967295;
pub const AES_SUSP1R_Pos: u32 = 0;
pub const AES_SUSP1R_Msk: u32 = 4294967295;
pub const AES_SUSP1R: u32 = 4294967295;
pub const AES_SUSP2R_Pos: u32 = 0;
pub const AES_SUSP2R_Msk: u32 = 4294967295;
pub const AES_SUSP2R: u32 = 4294967295;
pub const AES_SUSP3R_Pos: u32 = 0;
pub const AES_SUSP3R_Msk: u32 = 4294967295;
pub const AES_SUSP3R: u32 = 4294967295;
pub const AES_SUSP4R_Pos: u32 = 0;
pub const AES_SUSP4R_Msk: u32 = 4294967295;
pub const AES_SUSP4R: u32 = 4294967295;
pub const AES_SUSP5R_Pos: u32 = 0;
pub const AES_SUSP5R_Msk: u32 = 4294967295;
pub const AES_SUSP5R: u32 = 4294967295;
pub const AES_SUSP6R_Pos: u32 = 0;
pub const AES_SUSP6R_Msk: u32 = 4294967295;
pub const AES_SUSP6R: u32 = 4294967295;
pub const AES_SUSP7R_Pos: u32 = 0;
pub const AES_SUSP7R_Msk: u32 = 4294967295;
pub const AES_SUSP7R: u32 = 4294967295;
pub const DMA_ISR_GIF1_Pos: u32 = 0;
pub const DMA_ISR_GIF1_Msk: u32 = 1;
pub const DMA_ISR_GIF1: u32 = 1;
pub const DMA_ISR_TCIF1_Pos: u32 = 1;
pub const DMA_ISR_TCIF1_Msk: u32 = 2;
pub const DMA_ISR_TCIF1: u32 = 2;
pub const DMA_ISR_HTIF1_Pos: u32 = 2;
pub const DMA_ISR_HTIF1_Msk: u32 = 4;
pub const DMA_ISR_HTIF1: u32 = 4;
pub const DMA_ISR_TEIF1_Pos: u32 = 3;
pub const DMA_ISR_TEIF1_Msk: u32 = 8;
pub const DMA_ISR_TEIF1: u32 = 8;
pub const DMA_ISR_GIF2_Pos: u32 = 4;
pub const DMA_ISR_GIF2_Msk: u32 = 16;
pub const DMA_ISR_GIF2: u32 = 16;
pub const DMA_ISR_TCIF2_Pos: u32 = 5;
pub const DMA_ISR_TCIF2_Msk: u32 = 32;
pub const DMA_ISR_TCIF2: u32 = 32;
pub const DMA_ISR_HTIF2_Pos: u32 = 6;
pub const DMA_ISR_HTIF2_Msk: u32 = 64;
pub const DMA_ISR_HTIF2: u32 = 64;
pub const DMA_ISR_TEIF2_Pos: u32 = 7;
pub const DMA_ISR_TEIF2_Msk: u32 = 128;
pub const DMA_ISR_TEIF2: u32 = 128;
pub const DMA_ISR_GIF3_Pos: u32 = 8;
pub const DMA_ISR_GIF3_Msk: u32 = 256;
pub const DMA_ISR_GIF3: u32 = 256;
pub const DMA_ISR_TCIF3_Pos: u32 = 9;
pub const DMA_ISR_TCIF3_Msk: u32 = 512;
pub const DMA_ISR_TCIF3: u32 = 512;
pub const DMA_ISR_HTIF3_Pos: u32 = 10;
pub const DMA_ISR_HTIF3_Msk: u32 = 1024;
pub const DMA_ISR_HTIF3: u32 = 1024;
pub const DMA_ISR_TEIF3_Pos: u32 = 11;
pub const DMA_ISR_TEIF3_Msk: u32 = 2048;
pub const DMA_ISR_TEIF3: u32 = 2048;
pub const DMA_ISR_GIF4_Pos: u32 = 12;
pub const DMA_ISR_GIF4_Msk: u32 = 4096;
pub const DMA_ISR_GIF4: u32 = 4096;
pub const DMA_ISR_TCIF4_Pos: u32 = 13;
pub const DMA_ISR_TCIF4_Msk: u32 = 8192;
pub const DMA_ISR_TCIF4: u32 = 8192;
pub const DMA_ISR_HTIF4_Pos: u32 = 14;
pub const DMA_ISR_HTIF4_Msk: u32 = 16384;
pub const DMA_ISR_HTIF4: u32 = 16384;
pub const DMA_ISR_TEIF4_Pos: u32 = 15;
pub const DMA_ISR_TEIF4_Msk: u32 = 32768;
pub const DMA_ISR_TEIF4: u32 = 32768;
pub const DMA_ISR_GIF5_Pos: u32 = 16;
pub const DMA_ISR_GIF5_Msk: u32 = 65536;
pub const DMA_ISR_GIF5: u32 = 65536;
pub const DMA_ISR_TCIF5_Pos: u32 = 17;
pub const DMA_ISR_TCIF5_Msk: u32 = 131072;
pub const DMA_ISR_TCIF5: u32 = 131072;
pub const DMA_ISR_HTIF5_Pos: u32 = 18;
pub const DMA_ISR_HTIF5_Msk: u32 = 262144;
pub const DMA_ISR_HTIF5: u32 = 262144;
pub const DMA_ISR_TEIF5_Pos: u32 = 19;
pub const DMA_ISR_TEIF5_Msk: u32 = 524288;
pub const DMA_ISR_TEIF5: u32 = 524288;
pub const DMA_ISR_GIF6_Pos: u32 = 20;
pub const DMA_ISR_GIF6_Msk: u32 = 1048576;
pub const DMA_ISR_GIF6: u32 = 1048576;
pub const DMA_ISR_TCIF6_Pos: u32 = 21;
pub const DMA_ISR_TCIF6_Msk: u32 = 2097152;
pub const DMA_ISR_TCIF6: u32 = 2097152;
pub const DMA_ISR_HTIF6_Pos: u32 = 22;
pub const DMA_ISR_HTIF6_Msk: u32 = 4194304;
pub const DMA_ISR_HTIF6: u32 = 4194304;
pub const DMA_ISR_TEIF6_Pos: u32 = 23;
pub const DMA_ISR_TEIF6_Msk: u32 = 8388608;
pub const DMA_ISR_TEIF6: u32 = 8388608;
pub const DMA_ISR_GIF7_Pos: u32 = 24;
pub const DMA_ISR_GIF7_Msk: u32 = 16777216;
pub const DMA_ISR_GIF7: u32 = 16777216;
pub const DMA_ISR_TCIF7_Pos: u32 = 25;
pub const DMA_ISR_TCIF7_Msk: u32 = 33554432;
pub const DMA_ISR_TCIF7: u32 = 33554432;
pub const DMA_ISR_HTIF7_Pos: u32 = 26;
pub const DMA_ISR_HTIF7_Msk: u32 = 67108864;
pub const DMA_ISR_HTIF7: u32 = 67108864;
pub const DMA_ISR_TEIF7_Pos: u32 = 27;
pub const DMA_ISR_TEIF7_Msk: u32 = 134217728;
pub const DMA_ISR_TEIF7: u32 = 134217728;
pub const DMA_IFCR_CGIF1_Pos: u32 = 0;
pub const DMA_IFCR_CGIF1_Msk: u32 = 1;
pub const DMA_IFCR_CGIF1: u32 = 1;
pub const DMA_IFCR_CTCIF1_Pos: u32 = 1;
pub const DMA_IFCR_CTCIF1_Msk: u32 = 2;
pub const DMA_IFCR_CTCIF1: u32 = 2;
pub const DMA_IFCR_CHTIF1_Pos: u32 = 2;
pub const DMA_IFCR_CHTIF1_Msk: u32 = 4;
pub const DMA_IFCR_CHTIF1: u32 = 4;
pub const DMA_IFCR_CTEIF1_Pos: u32 = 3;
pub const DMA_IFCR_CTEIF1_Msk: u32 = 8;
pub const DMA_IFCR_CTEIF1: u32 = 8;
pub const DMA_IFCR_CGIF2_Pos: u32 = 4;
pub const DMA_IFCR_CGIF2_Msk: u32 = 16;
pub const DMA_IFCR_CGIF2: u32 = 16;
pub const DMA_IFCR_CTCIF2_Pos: u32 = 5;
pub const DMA_IFCR_CTCIF2_Msk: u32 = 32;
pub const DMA_IFCR_CTCIF2: u32 = 32;
pub const DMA_IFCR_CHTIF2_Pos: u32 = 6;
pub const DMA_IFCR_CHTIF2_Msk: u32 = 64;
pub const DMA_IFCR_CHTIF2: u32 = 64;
pub const DMA_IFCR_CTEIF2_Pos: u32 = 7;
pub const DMA_IFCR_CTEIF2_Msk: u32 = 128;
pub const DMA_IFCR_CTEIF2: u32 = 128;
pub const DMA_IFCR_CGIF3_Pos: u32 = 8;
pub const DMA_IFCR_CGIF3_Msk: u32 = 256;
pub const DMA_IFCR_CGIF3: u32 = 256;
pub const DMA_IFCR_CTCIF3_Pos: u32 = 9;
pub const DMA_IFCR_CTCIF3_Msk: u32 = 512;
pub const DMA_IFCR_CTCIF3: u32 = 512;
pub const DMA_IFCR_CHTIF3_Pos: u32 = 10;
pub const DMA_IFCR_CHTIF3_Msk: u32 = 1024;
pub const DMA_IFCR_CHTIF3: u32 = 1024;
pub const DMA_IFCR_CTEIF3_Pos: u32 = 11;
pub const DMA_IFCR_CTEIF3_Msk: u32 = 2048;
pub const DMA_IFCR_CTEIF3: u32 = 2048;
pub const DMA_IFCR_CGIF4_Pos: u32 = 12;
pub const DMA_IFCR_CGIF4_Msk: u32 = 4096;
pub const DMA_IFCR_CGIF4: u32 = 4096;
pub const DMA_IFCR_CTCIF4_Pos: u32 = 13;
pub const DMA_IFCR_CTCIF4_Msk: u32 = 8192;
pub const DMA_IFCR_CTCIF4: u32 = 8192;
pub const DMA_IFCR_CHTIF4_Pos: u32 = 14;
pub const DMA_IFCR_CHTIF4_Msk: u32 = 16384;
pub const DMA_IFCR_CHTIF4: u32 = 16384;
pub const DMA_IFCR_CTEIF4_Pos: u32 = 15;
pub const DMA_IFCR_CTEIF4_Msk: u32 = 32768;
pub const DMA_IFCR_CTEIF4: u32 = 32768;
pub const DMA_IFCR_CGIF5_Pos: u32 = 16;
pub const DMA_IFCR_CGIF5_Msk: u32 = 65536;
pub const DMA_IFCR_CGIF5: u32 = 65536;
pub const DMA_IFCR_CTCIF5_Pos: u32 = 17;
pub const DMA_IFCR_CTCIF5_Msk: u32 = 131072;
pub const DMA_IFCR_CTCIF5: u32 = 131072;
pub const DMA_IFCR_CHTIF5_Pos: u32 = 18;
pub const DMA_IFCR_CHTIF5_Msk: u32 = 262144;
pub const DMA_IFCR_CHTIF5: u32 = 262144;
pub const DMA_IFCR_CTEIF5_Pos: u32 = 19;
pub const DMA_IFCR_CTEIF5_Msk: u32 = 524288;
pub const DMA_IFCR_CTEIF5: u32 = 524288;
pub const DMA_IFCR_CGIF6_Pos: u32 = 20;
pub const DMA_IFCR_CGIF6_Msk: u32 = 1048576;
pub const DMA_IFCR_CGIF6: u32 = 1048576;
pub const DMA_IFCR_CTCIF6_Pos: u32 = 21;
pub const DMA_IFCR_CTCIF6_Msk: u32 = 2097152;
pub const DMA_IFCR_CTCIF6: u32 = 2097152;
pub const DMA_IFCR_CHTIF6_Pos: u32 = 22;
pub const DMA_IFCR_CHTIF6_Msk: u32 = 4194304;
pub const DMA_IFCR_CHTIF6: u32 = 4194304;
pub const DMA_IFCR_CTEIF6_Pos: u32 = 23;
pub const DMA_IFCR_CTEIF6_Msk: u32 = 8388608;
pub const DMA_IFCR_CTEIF6: u32 = 8388608;
pub const DMA_IFCR_CGIF7_Pos: u32 = 24;
pub const DMA_IFCR_CGIF7_Msk: u32 = 16777216;
pub const DMA_IFCR_CGIF7: u32 = 16777216;
pub const DMA_IFCR_CTCIF7_Pos: u32 = 25;
pub const DMA_IFCR_CTCIF7_Msk: u32 = 33554432;
pub const DMA_IFCR_CTCIF7: u32 = 33554432;
pub const DMA_IFCR_CHTIF7_Pos: u32 = 26;
pub const DMA_IFCR_CHTIF7_Msk: u32 = 67108864;
pub const DMA_IFCR_CHTIF7: u32 = 67108864;
pub const DMA_IFCR_CTEIF7_Pos: u32 = 27;
pub const DMA_IFCR_CTEIF7_Msk: u32 = 134217728;
pub const DMA_IFCR_CTEIF7: u32 = 134217728;
pub const DMA_CCR_EN_Pos: u32 = 0;
pub const DMA_CCR_EN_Msk: u32 = 1;
pub const DMA_CCR_EN: u32 = 1;
pub const DMA_CCR_TCIE_Pos: u32 = 1;
pub const DMA_CCR_TCIE_Msk: u32 = 2;
pub const DMA_CCR_TCIE: u32 = 2;
pub const DMA_CCR_HTIE_Pos: u32 = 2;
pub const DMA_CCR_HTIE_Msk: u32 = 4;
pub const DMA_CCR_HTIE: u32 = 4;
pub const DMA_CCR_TEIE_Pos: u32 = 3;
pub const DMA_CCR_TEIE_Msk: u32 = 8;
pub const DMA_CCR_TEIE: u32 = 8;
pub const DMA_CCR_DIR_Pos: u32 = 4;
pub const DMA_CCR_DIR_Msk: u32 = 16;
pub const DMA_CCR_DIR: u32 = 16;
pub const DMA_CCR_CIRC_Pos: u32 = 5;
pub const DMA_CCR_CIRC_Msk: u32 = 32;
pub const DMA_CCR_CIRC: u32 = 32;
pub const DMA_CCR_PINC_Pos: u32 = 6;
pub const DMA_CCR_PINC_Msk: u32 = 64;
pub const DMA_CCR_PINC: u32 = 64;
pub const DMA_CCR_MINC_Pos: u32 = 7;
pub const DMA_CCR_MINC_Msk: u32 = 128;
pub const DMA_CCR_MINC: u32 = 128;
pub const DMA_CCR_PSIZE_Pos: u32 = 8;
pub const DMA_CCR_PSIZE_Msk: u32 = 768;
pub const DMA_CCR_PSIZE: u32 = 768;
pub const DMA_CCR_PSIZE_0: u32 = 256;
pub const DMA_CCR_PSIZE_1: u32 = 512;
pub const DMA_CCR_MSIZE_Pos: u32 = 10;
pub const DMA_CCR_MSIZE_Msk: u32 = 3072;
pub const DMA_CCR_MSIZE: u32 = 3072;
pub const DMA_CCR_MSIZE_0: u32 = 1024;
pub const DMA_CCR_MSIZE_1: u32 = 2048;
pub const DMA_CCR_PL_Pos: u32 = 12;
pub const DMA_CCR_PL_Msk: u32 = 12288;
pub const DMA_CCR_PL: u32 = 12288;
pub const DMA_CCR_PL_0: u32 = 4096;
pub const DMA_CCR_PL_1: u32 = 8192;
pub const DMA_CCR_MEM2MEM_Pos: u32 = 14;
pub const DMA_CCR_MEM2MEM_Msk: u32 = 16384;
pub const DMA_CCR_MEM2MEM: u32 = 16384;
pub const DMA_CNDTR_NDT_Pos: u32 = 0;
pub const DMA_CNDTR_NDT_Msk: u32 = 65535;
pub const DMA_CNDTR_NDT: u32 = 65535;
pub const DMA_CPAR_PA_Pos: u32 = 0;
pub const DMA_CPAR_PA_Msk: u32 = 4294967295;
pub const DMA_CPAR_PA: u32 = 4294967295;
pub const DMA_CMAR_MA_Pos: u32 = 0;
pub const DMA_CMAR_MA_Msk: u32 = 4294967295;
pub const DMA_CMAR_MA: u32 = 4294967295;
pub const DMAMUX_CxCR_DMAREQ_ID_Pos: u32 = 0;
pub const DMAMUX_CxCR_DMAREQ_ID_Msk: u32 = 63;
pub const DMAMUX_CxCR_DMAREQ_ID: u32 = 63;
pub const DMAMUX_CxCR_DMAREQ_ID_0: u32 = 1;
pub const DMAMUX_CxCR_DMAREQ_ID_1: u32 = 2;
pub const DMAMUX_CxCR_DMAREQ_ID_2: u32 = 4;
pub const DMAMUX_CxCR_DMAREQ_ID_3: u32 = 8;
pub const DMAMUX_CxCR_DMAREQ_ID_4: u32 = 16;
pub const DMAMUX_CxCR_DMAREQ_ID_5: u32 = 32;
pub const DMAMUX_CxCR_SOIE_Pos: u32 = 8;
pub const DMAMUX_CxCR_SOIE_Msk: u32 = 256;
pub const DMAMUX_CxCR_SOIE: u32 = 256;
pub const DMAMUX_CxCR_EGE_Pos: u32 = 9;
pub const DMAMUX_CxCR_EGE_Msk: u32 = 512;
pub const DMAMUX_CxCR_EGE: u32 = 512;
pub const DMAMUX_CxCR_SE_Pos: u32 = 16;
pub const DMAMUX_CxCR_SE_Msk: u32 = 65536;
pub const DMAMUX_CxCR_SE: u32 = 65536;
pub const DMAMUX_CxCR_SPOL_Pos: u32 = 17;
pub const DMAMUX_CxCR_SPOL_Msk: u32 = 393216;
pub const DMAMUX_CxCR_SPOL: u32 = 393216;
pub const DMAMUX_CxCR_SPOL_0: u32 = 131072;
pub const DMAMUX_CxCR_SPOL_1: u32 = 262144;
pub const DMAMUX_CxCR_NBREQ_Pos: u32 = 19;
pub const DMAMUX_CxCR_NBREQ_Msk: u32 = 16252928;
pub const DMAMUX_CxCR_NBREQ: u32 = 16252928;
pub const DMAMUX_CxCR_NBREQ_0: u32 = 524288;
pub const DMAMUX_CxCR_NBREQ_1: u32 = 1048576;
pub const DMAMUX_CxCR_NBREQ_2: u32 = 2097152;
pub const DMAMUX_CxCR_NBREQ_3: u32 = 4194304;
pub const DMAMUX_CxCR_NBREQ_4: u32 = 8388608;
pub const DMAMUX_CxCR_SYNC_ID_Pos: u32 = 24;
pub const DMAMUX_CxCR_SYNC_ID_Msk: u32 = 520093696;
pub const DMAMUX_CxCR_SYNC_ID: u32 = 520093696;
pub const DMAMUX_CxCR_SYNC_ID_0: u32 = 16777216;
pub const DMAMUX_CxCR_SYNC_ID_1: u32 = 33554432;
pub const DMAMUX_CxCR_SYNC_ID_2: u32 = 67108864;
pub const DMAMUX_CxCR_SYNC_ID_3: u32 = 134217728;
pub const DMAMUX_CxCR_SYNC_ID_4: u32 = 268435456;
pub const DMAMUX_CSR_SOF0_Pos: u32 = 0;
pub const DMAMUX_CSR_SOF0_Msk: u32 = 1;
pub const DMAMUX_CSR_SOF0: u32 = 1;
pub const DMAMUX_CSR_SOF1_Pos: u32 = 1;
pub const DMAMUX_CSR_SOF1_Msk: u32 = 2;
pub const DMAMUX_CSR_SOF1: u32 = 2;
pub const DMAMUX_CSR_SOF2_Pos: u32 = 2;
pub const DMAMUX_CSR_SOF2_Msk: u32 = 4;
pub const DMAMUX_CSR_SOF2: u32 = 4;
pub const DMAMUX_CSR_SOF3_Pos: u32 = 3;
pub const DMAMUX_CSR_SOF3_Msk: u32 = 8;
pub const DMAMUX_CSR_SOF3: u32 = 8;
pub const DMAMUX_CSR_SOF4_Pos: u32 = 4;
pub const DMAMUX_CSR_SOF4_Msk: u32 = 16;
pub const DMAMUX_CSR_SOF4: u32 = 16;
pub const DMAMUX_CSR_SOF5_Pos: u32 = 5;
pub const DMAMUX_CSR_SOF5_Msk: u32 = 32;
pub const DMAMUX_CSR_SOF5: u32 = 32;
pub const DMAMUX_CSR_SOF6_Pos: u32 = 6;
pub const DMAMUX_CSR_SOF6_Msk: u32 = 64;
pub const DMAMUX_CSR_SOF6: u32 = 64;
pub const DMAMUX_CSR_SOF7_Pos: u32 = 7;
pub const DMAMUX_CSR_SOF7_Msk: u32 = 128;
pub const DMAMUX_CSR_SOF7: u32 = 128;
pub const DMAMUX_CSR_SOF8_Pos: u32 = 8;
pub const DMAMUX_CSR_SOF8_Msk: u32 = 256;
pub const DMAMUX_CSR_SOF8: u32 = 256;
pub const DMAMUX_CSR_SOF9_Pos: u32 = 9;
pub const DMAMUX_CSR_SOF9_Msk: u32 = 512;
pub const DMAMUX_CSR_SOF9: u32 = 512;
pub const DMAMUX_CSR_SOF10_Pos: u32 = 10;
pub const DMAMUX_CSR_SOF10_Msk: u32 = 1024;
pub const DMAMUX_CSR_SOF10: u32 = 1024;
pub const DMAMUX_CSR_SOF11_Pos: u32 = 11;
pub const DMAMUX_CSR_SOF11_Msk: u32 = 2048;
pub const DMAMUX_CSR_SOF11: u32 = 2048;
pub const DMAMUX_CSR_SOF12_Pos: u32 = 12;
pub const DMAMUX_CSR_SOF12_Msk: u32 = 4096;
pub const DMAMUX_CSR_SOF12: u32 = 4096;
pub const DMAMUX_CSR_SOF13_Pos: u32 = 13;
pub const DMAMUX_CSR_SOF13_Msk: u32 = 8192;
pub const DMAMUX_CSR_SOF13: u32 = 8192;
pub const DMAMUX_CFR_CSOF0_Pos: u32 = 0;
pub const DMAMUX_CFR_CSOF0_Msk: u32 = 1;
pub const DMAMUX_CFR_CSOF0: u32 = 1;
pub const DMAMUX_CFR_CSOF1_Pos: u32 = 1;
pub const DMAMUX_CFR_CSOF1_Msk: u32 = 2;
pub const DMAMUX_CFR_CSOF1: u32 = 2;
pub const DMAMUX_CFR_CSOF2_Pos: u32 = 2;
pub const DMAMUX_CFR_CSOF2_Msk: u32 = 4;
pub const DMAMUX_CFR_CSOF2: u32 = 4;
pub const DMAMUX_CFR_CSOF3_Pos: u32 = 3;
pub const DMAMUX_CFR_CSOF3_Msk: u32 = 8;
pub const DMAMUX_CFR_CSOF3: u32 = 8;
pub const DMAMUX_CFR_CSOF4_Pos: u32 = 4;
pub const DMAMUX_CFR_CSOF4_Msk: u32 = 16;
pub const DMAMUX_CFR_CSOF4: u32 = 16;
pub const DMAMUX_CFR_CSOF5_Pos: u32 = 5;
pub const DMAMUX_CFR_CSOF5_Msk: u32 = 32;
pub const DMAMUX_CFR_CSOF5: u32 = 32;
pub const DMAMUX_CFR_CSOF6_Pos: u32 = 6;
pub const DMAMUX_CFR_CSOF6_Msk: u32 = 64;
pub const DMAMUX_CFR_CSOF6: u32 = 64;
pub const DMAMUX_CFR_CSOF7_Pos: u32 = 7;
pub const DMAMUX_CFR_CSOF7_Msk: u32 = 128;
pub const DMAMUX_CFR_CSOF7: u32 = 128;
pub const DMAMUX_CFR_CSOF8_Pos: u32 = 8;
pub const DMAMUX_CFR_CSOF8_Msk: u32 = 256;
pub const DMAMUX_CFR_CSOF8: u32 = 256;
pub const DMAMUX_CFR_CSOF9_Pos: u32 = 9;
pub const DMAMUX_CFR_CSOF9_Msk: u32 = 512;
pub const DMAMUX_CFR_CSOF9: u32 = 512;
pub const DMAMUX_CFR_CSOF10_Pos: u32 = 10;
pub const DMAMUX_CFR_CSOF10_Msk: u32 = 1024;
pub const DMAMUX_CFR_CSOF10: u32 = 1024;
pub const DMAMUX_CFR_CSOF11_Pos: u32 = 11;
pub const DMAMUX_CFR_CSOF11_Msk: u32 = 2048;
pub const DMAMUX_CFR_CSOF11: u32 = 2048;
pub const DMAMUX_CFR_CSOF12_Pos: u32 = 12;
pub const DMAMUX_CFR_CSOF12_Msk: u32 = 4096;
pub const DMAMUX_CFR_CSOF12: u32 = 4096;
pub const DMAMUX_CFR_CSOF13_Pos: u32 = 13;
pub const DMAMUX_CFR_CSOF13_Msk: u32 = 8192;
pub const DMAMUX_CFR_CSOF13: u32 = 8192;
pub const DMAMUX_RGxCR_SIG_ID_Pos: u32 = 0;
pub const DMAMUX_RGxCR_SIG_ID_Msk: u32 = 31;
pub const DMAMUX_RGxCR_SIG_ID: u32 = 31;
pub const DMAMUX_RGxCR_SIG_ID_0: u32 = 1;
pub const DMAMUX_RGxCR_SIG_ID_1: u32 = 2;
pub const DMAMUX_RGxCR_SIG_ID_2: u32 = 4;
pub const DMAMUX_RGxCR_SIG_ID_3: u32 = 8;
pub const DMAMUX_RGxCR_SIG_ID_4: u32 = 16;
pub const DMAMUX_RGxCR_OIE_Pos: u32 = 8;
pub const DMAMUX_RGxCR_OIE_Msk: u32 = 256;
pub const DMAMUX_RGxCR_OIE: u32 = 256;
pub const DMAMUX_RGxCR_GE_Pos: u32 = 16;
pub const DMAMUX_RGxCR_GE_Msk: u32 = 65536;
pub const DMAMUX_RGxCR_GE: u32 = 65536;
pub const DMAMUX_RGxCR_GPOL_Pos: u32 = 17;
pub const DMAMUX_RGxCR_GPOL_Msk: u32 = 393216;
pub const DMAMUX_RGxCR_GPOL: u32 = 393216;
pub const DMAMUX_RGxCR_GPOL_0: u32 = 131072;
pub const DMAMUX_RGxCR_GPOL_1: u32 = 262144;
pub const DMAMUX_RGxCR_GNBREQ_Pos: u32 = 19;
pub const DMAMUX_RGxCR_GNBREQ_Msk: u32 = 16252928;
pub const DMAMUX_RGxCR_GNBREQ: u32 = 16252928;
pub const DMAMUX_RGxCR_GNBREQ_0: u32 = 524288;
pub const DMAMUX_RGxCR_GNBREQ_1: u32 = 1048576;
pub const DMAMUX_RGxCR_GNBREQ_2: u32 = 2097152;
pub const DMAMUX_RGxCR_GNBREQ_3: u32 = 4194304;
pub const DMAMUX_RGxCR_GNBREQ_4: u32 = 8388608;
pub const DMAMUX_RGSR_OF0_Pos: u32 = 0;
pub const DMAMUX_RGSR_OF0_Msk: u32 = 1;
pub const DMAMUX_RGSR_OF0: u32 = 1;
pub const DMAMUX_RGSR_OF1_Pos: u32 = 1;
pub const DMAMUX_RGSR_OF1_Msk: u32 = 2;
pub const DMAMUX_RGSR_OF1: u32 = 2;
pub const DMAMUX_RGSR_OF2_Pos: u32 = 2;
pub const DMAMUX_RGSR_OF2_Msk: u32 = 4;
pub const DMAMUX_RGSR_OF2: u32 = 4;
pub const DMAMUX_RGSR_OF3_Pos: u32 = 3;
pub const DMAMUX_RGSR_OF3_Msk: u32 = 8;
pub const DMAMUX_RGSR_OF3: u32 = 8;
pub const DMAMUX_RGCFR_COF0_Pos: u32 = 0;
pub const DMAMUX_RGCFR_COF0_Msk: u32 = 1;
pub const DMAMUX_RGCFR_COF0: u32 = 1;
pub const DMAMUX_RGCFR_COF1_Pos: u32 = 1;
pub const DMAMUX_RGCFR_COF1_Msk: u32 = 2;
pub const DMAMUX_RGCFR_COF1: u32 = 2;
pub const DMAMUX_RGCFR_COF2_Pos: u32 = 2;
pub const DMAMUX_RGCFR_COF2_Msk: u32 = 4;
pub const DMAMUX_RGCFR_COF2: u32 = 4;
pub const DMAMUX_RGCFR_COF3_Pos: u32 = 3;
pub const DMAMUX_RGCFR_COF3_Msk: u32 = 8;
pub const DMAMUX_RGCFR_COF3: u32 = 8;
pub const EXTI_RTSR1_RT_Pos: u32 = 0;
pub const EXTI_RTSR1_RT_Msk: u32 = 2151677951;
pub const EXTI_RTSR1_RT: u32 = 2151677951;
pub const EXTI_RTSR1_RT0_Pos: u32 = 0;
pub const EXTI_RTSR1_RT0_Msk: u32 = 1;
pub const EXTI_RTSR1_RT0: u32 = 1;
pub const EXTI_RTSR1_RT1_Pos: u32 = 1;
pub const EXTI_RTSR1_RT1_Msk: u32 = 2;
pub const EXTI_RTSR1_RT1: u32 = 2;
pub const EXTI_RTSR1_RT2_Pos: u32 = 2;
pub const EXTI_RTSR1_RT2_Msk: u32 = 4;
pub const EXTI_RTSR1_RT2: u32 = 4;
pub const EXTI_RTSR1_RT3_Pos: u32 = 3;
pub const EXTI_RTSR1_RT3_Msk: u32 = 8;
pub const EXTI_RTSR1_RT3: u32 = 8;
pub const EXTI_RTSR1_RT4_Pos: u32 = 4;
pub const EXTI_RTSR1_RT4_Msk: u32 = 16;
pub const EXTI_RTSR1_RT4: u32 = 16;
pub const EXTI_RTSR1_RT5_Pos: u32 = 5;
pub const EXTI_RTSR1_RT5_Msk: u32 = 32;
pub const EXTI_RTSR1_RT5: u32 = 32;
pub const EXTI_RTSR1_RT6_Pos: u32 = 6;
pub const EXTI_RTSR1_RT6_Msk: u32 = 64;
pub const EXTI_RTSR1_RT6: u32 = 64;
pub const EXTI_RTSR1_RT7_Pos: u32 = 7;
pub const EXTI_RTSR1_RT7_Msk: u32 = 128;
pub const EXTI_RTSR1_RT7: u32 = 128;
pub const EXTI_RTSR1_RT8_Pos: u32 = 8;
pub const EXTI_RTSR1_RT8_Msk: u32 = 256;
pub const EXTI_RTSR1_RT8: u32 = 256;
pub const EXTI_RTSR1_RT9_Pos: u32 = 9;
pub const EXTI_RTSR1_RT9_Msk: u32 = 512;
pub const EXTI_RTSR1_RT9: u32 = 512;
pub const EXTI_RTSR1_RT10_Pos: u32 = 10;
pub const EXTI_RTSR1_RT10_Msk: u32 = 1024;
pub const EXTI_RTSR1_RT10: u32 = 1024;
pub const EXTI_RTSR1_RT11_Pos: u32 = 11;
pub const EXTI_RTSR1_RT11_Msk: u32 = 2048;
pub const EXTI_RTSR1_RT11: u32 = 2048;
pub const EXTI_RTSR1_RT12_Pos: u32 = 12;
pub const EXTI_RTSR1_RT12_Msk: u32 = 4096;
pub const EXTI_RTSR1_RT12: u32 = 4096;
pub const EXTI_RTSR1_RT13_Pos: u32 = 13;
pub const EXTI_RTSR1_RT13_Msk: u32 = 8192;
pub const EXTI_RTSR1_RT13: u32 = 8192;
pub const EXTI_RTSR1_RT14_Pos: u32 = 14;
pub const EXTI_RTSR1_RT14_Msk: u32 = 16384;
pub const EXTI_RTSR1_RT14: u32 = 16384;
pub const EXTI_RTSR1_RT15_Pos: u32 = 15;
pub const EXTI_RTSR1_RT15_Msk: u32 = 32768;
pub const EXTI_RTSR1_RT15: u32 = 32768;
pub const EXTI_RTSR1_RT16_Pos: u32 = 16;
pub const EXTI_RTSR1_RT16_Msk: u32 = 65536;
pub const EXTI_RTSR1_RT16: u32 = 65536;
pub const EXTI_RTSR1_RT17_Pos: u32 = 17;
pub const EXTI_RTSR1_RT17_Msk: u32 = 131072;
pub const EXTI_RTSR1_RT17: u32 = 131072;
pub const EXTI_RTSR1_RT18_Pos: u32 = 18;
pub const EXTI_RTSR1_RT18_Msk: u32 = 262144;
pub const EXTI_RTSR1_RT18: u32 = 262144;
pub const EXTI_RTSR1_RT19_Pos: u32 = 19;
pub const EXTI_RTSR1_RT19_Msk: u32 = 524288;
pub const EXTI_RTSR1_RT19: u32 = 524288;
pub const EXTI_RTSR1_RT20_Pos: u32 = 20;
pub const EXTI_RTSR1_RT20_Msk: u32 = 1048576;
pub const EXTI_RTSR1_RT20: u32 = 1048576;
pub const EXTI_RTSR1_RT21_Pos: u32 = 21;
pub const EXTI_RTSR1_RT21_Msk: u32 = 2097152;
pub const EXTI_RTSR1_RT21: u32 = 2097152;
pub const EXTI_RTSR1_RT31_Pos: u32 = 31;
pub const EXTI_RTSR1_RT31_Msk: u32 = 2147483648;
pub const EXTI_RTSR1_RT31: u32 = 2147483648;
pub const EXTI_FTSR1_FT_Pos: u32 = 0;
pub const EXTI_FTSR1_FT_Msk: u32 = 2151677951;
pub const EXTI_FTSR1_FT: u32 = 2151677951;
pub const EXTI_FTSR1_FT0_Pos: u32 = 0;
pub const EXTI_FTSR1_FT0_Msk: u32 = 1;
pub const EXTI_FTSR1_FT0: u32 = 1;
pub const EXTI_FTSR1_FT1_Pos: u32 = 1;
pub const EXTI_FTSR1_FT1_Msk: u32 = 2;
pub const EXTI_FTSR1_FT1: u32 = 2;
pub const EXTI_FTSR1_FT2_Pos: u32 = 2;
pub const EXTI_FTSR1_FT2_Msk: u32 = 4;
pub const EXTI_FTSR1_FT2: u32 = 4;
pub const EXTI_FTSR1_FT3_Pos: u32 = 3;
pub const EXTI_FTSR1_FT3_Msk: u32 = 8;
pub const EXTI_FTSR1_FT3: u32 = 8;
pub const EXTI_FTSR1_FT4_Pos: u32 = 4;
pub const EXTI_FTSR1_FT4_Msk: u32 = 16;
pub const EXTI_FTSR1_FT4: u32 = 16;
pub const EXTI_FTSR1_FT5_Pos: u32 = 5;
pub const EXTI_FTSR1_FT5_Msk: u32 = 32;
pub const EXTI_FTSR1_FT5: u32 = 32;
pub const EXTI_FTSR1_FT6_Pos: u32 = 6;
pub const EXTI_FTSR1_FT6_Msk: u32 = 64;
pub const EXTI_FTSR1_FT6: u32 = 64;
pub const EXTI_FTSR1_FT7_Pos: u32 = 7;
pub const EXTI_FTSR1_FT7_Msk: u32 = 128;
pub const EXTI_FTSR1_FT7: u32 = 128;
pub const EXTI_FTSR1_FT8_Pos: u32 = 8;
pub const EXTI_FTSR1_FT8_Msk: u32 = 256;
pub const EXTI_FTSR1_FT8: u32 = 256;
pub const EXTI_FTSR1_FT9_Pos: u32 = 9;
pub const EXTI_FTSR1_FT9_Msk: u32 = 512;
pub const EXTI_FTSR1_FT9: u32 = 512;
pub const EXTI_FTSR1_FT10_Pos: u32 = 10;
pub const EXTI_FTSR1_FT10_Msk: u32 = 1024;
pub const EXTI_FTSR1_FT10: u32 = 1024;
pub const EXTI_FTSR1_FT11_Pos: u32 = 11;
pub const EXTI_FTSR1_FT11_Msk: u32 = 2048;
pub const EXTI_FTSR1_FT11: u32 = 2048;
pub const EXTI_FTSR1_FT12_Pos: u32 = 12;
pub const EXTI_FTSR1_FT12_Msk: u32 = 4096;
pub const EXTI_FTSR1_FT12: u32 = 4096;
pub const EXTI_FTSR1_FT13_Pos: u32 = 13;
pub const EXTI_FTSR1_FT13_Msk: u32 = 8192;
pub const EXTI_FTSR1_FT13: u32 = 8192;
pub const EXTI_FTSR1_FT14_Pos: u32 = 14;
pub const EXTI_FTSR1_FT14_Msk: u32 = 16384;
pub const EXTI_FTSR1_FT14: u32 = 16384;
pub const EXTI_FTSR1_FT15_Pos: u32 = 15;
pub const EXTI_FTSR1_FT15_Msk: u32 = 32768;
pub const EXTI_FTSR1_FT15: u32 = 32768;
pub const EXTI_FTSR1_FT16_Pos: u32 = 16;
pub const EXTI_FTSR1_FT16_Msk: u32 = 65536;
pub const EXTI_FTSR1_FT16: u32 = 65536;
pub const EXTI_FTSR1_FT17_Pos: u32 = 17;
pub const EXTI_FTSR1_FT17_Msk: u32 = 131072;
pub const EXTI_FTSR1_FT17: u32 = 131072;
pub const EXTI_FTSR1_FT18_Pos: u32 = 18;
pub const EXTI_FTSR1_FT18_Msk: u32 = 262144;
pub const EXTI_FTSR1_FT18: u32 = 262144;
pub const EXTI_FTSR1_FT19_Pos: u32 = 19;
pub const EXTI_FTSR1_FT19_Msk: u32 = 524288;
pub const EXTI_FTSR1_FT19: u32 = 524288;
pub const EXTI_FTSR1_FT20_Pos: u32 = 20;
pub const EXTI_FTSR1_FT20_Msk: u32 = 1048576;
pub const EXTI_FTSR1_FT20: u32 = 1048576;
pub const EXTI_FTSR1_FT21_Pos: u32 = 21;
pub const EXTI_FTSR1_FT21_Msk: u32 = 2097152;
pub const EXTI_FTSR1_FT21: u32 = 2097152;
pub const EXTI_FTSR1_FT31_Pos: u32 = 31;
pub const EXTI_FTSR1_FT31_Msk: u32 = 2147483648;
pub const EXTI_FTSR1_FT31: u32 = 2147483648;
pub const EXTI_SWIER1_SWI_Pos: u32 = 0;
pub const EXTI_SWIER1_SWI_Msk: u32 = 2151677951;
pub const EXTI_SWIER1_SWI: u32 = 2151677951;
pub const EXTI_SWIER1_SWI0_Pos: u32 = 0;
pub const EXTI_SWIER1_SWI0_Msk: u32 = 1;
pub const EXTI_SWIER1_SWI0: u32 = 1;
pub const EXTI_SWIER1_SWI1_Pos: u32 = 1;
pub const EXTI_SWIER1_SWI1_Msk: u32 = 2;
pub const EXTI_SWIER1_SWI1: u32 = 2;
pub const EXTI_SWIER1_SWI2_Pos: u32 = 2;
pub const EXTI_SWIER1_SWI2_Msk: u32 = 4;
pub const EXTI_SWIER1_SWI2: u32 = 4;
pub const EXTI_SWIER1_SWI3_Pos: u32 = 3;
pub const EXTI_SWIER1_SWI3_Msk: u32 = 8;
pub const EXTI_SWIER1_SWI3: u32 = 8;
pub const EXTI_SWIER1_SWI4_Pos: u32 = 4;
pub const EXTI_SWIER1_SWI4_Msk: u32 = 16;
pub const EXTI_SWIER1_SWI4: u32 = 16;
pub const EXTI_SWIER1_SWI5_Pos: u32 = 5;
pub const EXTI_SWIER1_SWI5_Msk: u32 = 32;
pub const EXTI_SWIER1_SWI5: u32 = 32;
pub const EXTI_SWIER1_SWI6_Pos: u32 = 6;
pub const EXTI_SWIER1_SWI6_Msk: u32 = 64;
pub const EXTI_SWIER1_SWI6: u32 = 64;
pub const EXTI_SWIER1_SWI7_Pos: u32 = 7;
pub const EXTI_SWIER1_SWI7_Msk: u32 = 128;
pub const EXTI_SWIER1_SWI7: u32 = 128;
pub const EXTI_SWIER1_SWI8_Pos: u32 = 8;
pub const EXTI_SWIER1_SWI8_Msk: u32 = 256;
pub const EXTI_SWIER1_SWI8: u32 = 256;
pub const EXTI_SWIER1_SWI9_Pos: u32 = 9;
pub const EXTI_SWIER1_SWI9_Msk: u32 = 512;
pub const EXTI_SWIER1_SWI9: u32 = 512;
pub const EXTI_SWIER1_SWI10_Pos: u32 = 10;
pub const EXTI_SWIER1_SWI10_Msk: u32 = 1024;
pub const EXTI_SWIER1_SWI10: u32 = 1024;
pub const EXTI_SWIER1_SWI11_Pos: u32 = 11;
pub const EXTI_SWIER1_SWI11_Msk: u32 = 2048;
pub const EXTI_SWIER1_SWI11: u32 = 2048;
pub const EXTI_SWIER1_SWI12_Pos: u32 = 12;
pub const EXTI_SWIER1_SWI12_Msk: u32 = 4096;
pub const EXTI_SWIER1_SWI12: u32 = 4096;
pub const EXTI_SWIER1_SWI13_Pos: u32 = 13;
pub const EXTI_SWIER1_SWI13_Msk: u32 = 8192;
pub const EXTI_SWIER1_SWI13: u32 = 8192;
pub const EXTI_SWIER1_SWI14_Pos: u32 = 14;
pub const EXTI_SWIER1_SWI14_Msk: u32 = 16384;
pub const EXTI_SWIER1_SWI14: u32 = 16384;
pub const EXTI_SWIER1_SWI15_Pos: u32 = 15;
pub const EXTI_SWIER1_SWI15_Msk: u32 = 32768;
pub const EXTI_SWIER1_SWI15: u32 = 32768;
pub const EXTI_SWIER1_SWI16_Pos: u32 = 16;
pub const EXTI_SWIER1_SWI16_Msk: u32 = 65536;
pub const EXTI_SWIER1_SWI16: u32 = 65536;
pub const EXTI_SWIER1_SWI17_Pos: u32 = 17;
pub const EXTI_SWIER1_SWI17_Msk: u32 = 131072;
pub const EXTI_SWIER1_SWI17: u32 = 131072;
pub const EXTI_SWIER1_SWI18_Pos: u32 = 18;
pub const EXTI_SWIER1_SWI18_Msk: u32 = 262144;
pub const EXTI_SWIER1_SWI18: u32 = 262144;
pub const EXTI_SWIER1_SWI19_Pos: u32 = 19;
pub const EXTI_SWIER1_SWI19_Msk: u32 = 524288;
pub const EXTI_SWIER1_SWI19: u32 = 524288;
pub const EXTI_SWIER1_SWI20_Pos: u32 = 20;
pub const EXTI_SWIER1_SWI20_Msk: u32 = 1048576;
pub const EXTI_SWIER1_SWI20: u32 = 1048576;
pub const EXTI_SWIER1_SWI21_Pos: u32 = 21;
pub const EXTI_SWIER1_SWI21_Msk: u32 = 2097152;
pub const EXTI_SWIER1_SWI21: u32 = 2097152;
pub const EXTI_SWIER1_SWI31_Pos: u32 = 31;
pub const EXTI_SWIER1_SWI31_Msk: u32 = 2147483648;
pub const EXTI_SWIER1_SWI31: u32 = 2147483648;
pub const EXTI_PR1_PIF_Pos: u32 = 0;
pub const EXTI_PR1_PIF_Msk: u32 = 2151677951;
pub const EXTI_PR1_PIF: u32 = 2151677951;
pub const EXTI_PR1_PIF0_Pos: u32 = 0;
pub const EXTI_PR1_PIF0_Msk: u32 = 1;
pub const EXTI_PR1_PIF0: u32 = 1;
pub const EXTI_PR1_PIF1_Pos: u32 = 1;
pub const EXTI_PR1_PIF1_Msk: u32 = 2;
pub const EXTI_PR1_PIF1: u32 = 2;
pub const EXTI_PR1_PIF2_Pos: u32 = 2;
pub const EXTI_PR1_PIF2_Msk: u32 = 4;
pub const EXTI_PR1_PIF2: u32 = 4;
pub const EXTI_PR1_PIF3_Pos: u32 = 3;
pub const EXTI_PR1_PIF3_Msk: u32 = 8;
pub const EXTI_PR1_PIF3: u32 = 8;
pub const EXTI_PR1_PIF4_Pos: u32 = 4;
pub const EXTI_PR1_PIF4_Msk: u32 = 16;
pub const EXTI_PR1_PIF4: u32 = 16;
pub const EXTI_PR1_PIF5_Pos: u32 = 5;
pub const EXTI_PR1_PIF5_Msk: u32 = 32;
pub const EXTI_PR1_PIF5: u32 = 32;
pub const EXTI_PR1_PIF6_Pos: u32 = 6;
pub const EXTI_PR1_PIF6_Msk: u32 = 64;
pub const EXTI_PR1_PIF6: u32 = 64;
pub const EXTI_PR1_PIF7_Pos: u32 = 7;
pub const EXTI_PR1_PIF7_Msk: u32 = 128;
pub const EXTI_PR1_PIF7: u32 = 128;
pub const EXTI_PR1_PIF8_Pos: u32 = 8;
pub const EXTI_PR1_PIF8_Msk: u32 = 256;
pub const EXTI_PR1_PIF8: u32 = 256;
pub const EXTI_PR1_PIF9_Pos: u32 = 9;
pub const EXTI_PR1_PIF9_Msk: u32 = 512;
pub const EXTI_PR1_PIF9: u32 = 512;
pub const EXTI_PR1_PIF10_Pos: u32 = 10;
pub const EXTI_PR1_PIF10_Msk: u32 = 1024;
pub const EXTI_PR1_PIF10: u32 = 1024;
pub const EXTI_PR1_PIF11_Pos: u32 = 11;
pub const EXTI_PR1_PIF11_Msk: u32 = 2048;
pub const EXTI_PR1_PIF11: u32 = 2048;
pub const EXTI_PR1_PIF12_Pos: u32 = 12;
pub const EXTI_PR1_PIF12_Msk: u32 = 4096;
pub const EXTI_PR1_PIF12: u32 = 4096;
pub const EXTI_PR1_PIF13_Pos: u32 = 13;
pub const EXTI_PR1_PIF13_Msk: u32 = 8192;
pub const EXTI_PR1_PIF13: u32 = 8192;
pub const EXTI_PR1_PIF14_Pos: u32 = 14;
pub const EXTI_PR1_PIF14_Msk: u32 = 16384;
pub const EXTI_PR1_PIF14: u32 = 16384;
pub const EXTI_PR1_PIF15_Pos: u32 = 15;
pub const EXTI_PR1_PIF15_Msk: u32 = 32768;
pub const EXTI_PR1_PIF15: u32 = 32768;
pub const EXTI_PR1_PIF16_Pos: u32 = 16;
pub const EXTI_PR1_PIF16_Msk: u32 = 65536;
pub const EXTI_PR1_PIF16: u32 = 65536;
pub const EXTI_PR1_PIF17_Pos: u32 = 17;
pub const EXTI_PR1_PIF17_Msk: u32 = 131072;
pub const EXTI_PR1_PIF17: u32 = 131072;
pub const EXTI_PR1_PIF18_Pos: u32 = 18;
pub const EXTI_PR1_PIF18_Msk: u32 = 262144;
pub const EXTI_PR1_PIF18: u32 = 262144;
pub const EXTI_PR1_PIF19_Pos: u32 = 19;
pub const EXTI_PR1_PIF19_Msk: u32 = 524288;
pub const EXTI_PR1_PIF19: u32 = 524288;
pub const EXTI_PR1_PIF20_Pos: u32 = 20;
pub const EXTI_PR1_PIF20_Msk: u32 = 1048576;
pub const EXTI_PR1_PIF20: u32 = 1048576;
pub const EXTI_PR1_PIF21_Pos: u32 = 21;
pub const EXTI_PR1_PIF21_Msk: u32 = 2097152;
pub const EXTI_PR1_PIF21: u32 = 2097152;
pub const EXTI_PR1_PIF31_Pos: u32 = 31;
pub const EXTI_PR1_PIF31_Msk: u32 = 2147483648;
pub const EXTI_PR1_PIF31: u32 = 2147483648;
pub const EXTI_RTSR2_RT_Pos: u32 = 0;
pub const EXTI_RTSR2_RT_Msk: u32 = 770;
pub const EXTI_RTSR2_RT: u32 = 770;
pub const EXTI_RTSR2_RT33_Pos: u32 = 1;
pub const EXTI_RTSR2_RT33_Msk: u32 = 2;
pub const EXTI_RTSR2_RT33: u32 = 2;
pub const EXTI_RTSR2_RT40_Pos: u32 = 8;
pub const EXTI_RTSR2_RT40_Msk: u32 = 256;
pub const EXTI_RTSR2_RT40: u32 = 256;
pub const EXTI_RTSR2_RT41_Pos: u32 = 9;
pub const EXTI_RTSR2_RT41_Msk: u32 = 512;
pub const EXTI_RTSR2_RT41: u32 = 512;
pub const EXTI_FTSR2_FT_Pos: u32 = 0;
pub const EXTI_FTSR2_FT_Msk: u32 = 770;
pub const EXTI_FTSR2_FT: u32 = 770;
pub const EXTI_FTSR2_FT33_Pos: u32 = 1;
pub const EXTI_FTSR2_FT33_Msk: u32 = 2;
pub const EXTI_FTSR2_FT33: u32 = 2;
pub const EXTI_FTSR2_FT40_Pos: u32 = 8;
pub const EXTI_FTSR2_FT40_Msk: u32 = 256;
pub const EXTI_FTSR2_FT40: u32 = 256;
pub const EXTI_FTSR2_FT41_Pos: u32 = 9;
pub const EXTI_FTSR2_FT41_Msk: u32 = 512;
pub const EXTI_FTSR2_FT41: u32 = 512;
pub const EXTI_SWIER2_SWI_Pos: u32 = 0;
pub const EXTI_SWIER2_SWI_Msk: u32 = 770;
pub const EXTI_SWIER2_SWI: u32 = 770;
pub const EXTI_SWIER2_SWI33_Pos: u32 = 1;
pub const EXTI_SWIER2_SWI33_Msk: u32 = 2;
pub const EXTI_SWIER2_SWI33: u32 = 2;
pub const EXTI_SWIER2_SWI40_Pos: u32 = 8;
pub const EXTI_SWIER2_SWI40_Msk: u32 = 256;
pub const EXTI_SWIER2_SWI40: u32 = 256;
pub const EXTI_SWIER2_SWI41_Pos: u32 = 9;
pub const EXTI_SWIER2_SWI41_Msk: u32 = 512;
pub const EXTI_SWIER2_SWI41: u32 = 512;
pub const EXTI_PR2_PIF_Pos: u32 = 0;
pub const EXTI_PR2_PIF_Msk: u32 = 770;
pub const EXTI_PR2_PIF: u32 = 770;
pub const EXTI_PR2_PIF33_Pos: u32 = 1;
pub const EXTI_PR2_PIF33_Msk: u32 = 2;
pub const EXTI_PR2_PIF33: u32 = 2;
pub const EXTI_PR2_PIF40_Pos: u32 = 8;
pub const EXTI_PR2_PIF40_Msk: u32 = 256;
pub const EXTI_PR2_PIF40: u32 = 256;
pub const EXTI_PR2_PIF41_Pos: u32 = 9;
pub const EXTI_PR2_PIF41_Msk: u32 = 512;
pub const EXTI_PR2_PIF41: u32 = 512;
pub const EXTI_IMR1_Pos: u32 = 0;
pub const EXTI_IMR1_Msk: u32 = 4294967295;
pub const EXTI_IMR1_IM: u32 = 4294967295;
pub const EXTI_IMR1_IM0_Pos: u32 = 0;
pub const EXTI_IMR1_IM0_Msk: u32 = 1;
pub const EXTI_IMR1_IM0: u32 = 1;
pub const EXTI_IMR1_IM1_Pos: u32 = 1;
pub const EXTI_IMR1_IM1_Msk: u32 = 2;
pub const EXTI_IMR1_IM1: u32 = 2;
pub const EXTI_IMR1_IM2_Pos: u32 = 2;
pub const EXTI_IMR1_IM2_Msk: u32 = 4;
pub const EXTI_IMR1_IM2: u32 = 4;
pub const EXTI_IMR1_IM3_Pos: u32 = 3;
pub const EXTI_IMR1_IM3_Msk: u32 = 8;
pub const EXTI_IMR1_IM3: u32 = 8;
pub const EXTI_IMR1_IM4_Pos: u32 = 4;
pub const EXTI_IMR1_IM4_Msk: u32 = 16;
pub const EXTI_IMR1_IM4: u32 = 16;
pub const EXTI_IMR1_IM5_Pos: u32 = 5;
pub const EXTI_IMR1_IM5_Msk: u32 = 32;
pub const EXTI_IMR1_IM5: u32 = 32;
pub const EXTI_IMR1_IM6_Pos: u32 = 6;
pub const EXTI_IMR1_IM6_Msk: u32 = 64;
pub const EXTI_IMR1_IM6: u32 = 64;
pub const EXTI_IMR1_IM7_Pos: u32 = 7;
pub const EXTI_IMR1_IM7_Msk: u32 = 128;
pub const EXTI_IMR1_IM7: u32 = 128;
pub const EXTI_IMR1_IM8_Pos: u32 = 8;
pub const EXTI_IMR1_IM8_Msk: u32 = 256;
pub const EXTI_IMR1_IM8: u32 = 256;
pub const EXTI_IMR1_IM9_Pos: u32 = 9;
pub const EXTI_IMR1_IM9_Msk: u32 = 512;
pub const EXTI_IMR1_IM9: u32 = 512;
pub const EXTI_IMR1_IM10_Pos: u32 = 10;
pub const EXTI_IMR1_IM10_Msk: u32 = 1024;
pub const EXTI_IMR1_IM10: u32 = 1024;
pub const EXTI_IMR1_IM11_Pos: u32 = 11;
pub const EXTI_IMR1_IM11_Msk: u32 = 2048;
pub const EXTI_IMR1_IM11: u32 = 2048;
pub const EXTI_IMR1_IM12_Pos: u32 = 12;
pub const EXTI_IMR1_IM12_Msk: u32 = 4096;
pub const EXTI_IMR1_IM12: u32 = 4096;
pub const EXTI_IMR1_IM13_Pos: u32 = 13;
pub const EXTI_IMR1_IM13_Msk: u32 = 8192;
pub const EXTI_IMR1_IM13: u32 = 8192;
pub const EXTI_IMR1_IM14_Pos: u32 = 14;
pub const EXTI_IMR1_IM14_Msk: u32 = 16384;
pub const EXTI_IMR1_IM14: u32 = 16384;
pub const EXTI_IMR1_IM15_Pos: u32 = 15;
pub const EXTI_IMR1_IM15_Msk: u32 = 32768;
pub const EXTI_IMR1_IM15: u32 = 32768;
pub const EXTI_IMR1_IM16_Pos: u32 = 16;
pub const EXTI_IMR1_IM16_Msk: u32 = 65536;
pub const EXTI_IMR1_IM16: u32 = 65536;
pub const EXTI_IMR1_IM17_Pos: u32 = 17;
pub const EXTI_IMR1_IM17_Msk: u32 = 131072;
pub const EXTI_IMR1_IM17: u32 = 131072;
pub const EXTI_IMR1_IM18_Pos: u32 = 18;
pub const EXTI_IMR1_IM18_Msk: u32 = 262144;
pub const EXTI_IMR1_IM18: u32 = 262144;
pub const EXTI_IMR1_IM19_Pos: u32 = 19;
pub const EXTI_IMR1_IM19_Msk: u32 = 524288;
pub const EXTI_IMR1_IM19: u32 = 524288;
pub const EXTI_IMR1_IM20_Pos: u32 = 20;
pub const EXTI_IMR1_IM20_Msk: u32 = 1048576;
pub const EXTI_IMR1_IM20: u32 = 1048576;
pub const EXTI_IMR1_IM21_Pos: u32 = 21;
pub const EXTI_IMR1_IM21_Msk: u32 = 2097152;
pub const EXTI_IMR1_IM21: u32 = 2097152;
pub const EXTI_IMR1_IM22_Pos: u32 = 22;
pub const EXTI_IMR1_IM22_Msk: u32 = 4194304;
pub const EXTI_IMR1_IM22: u32 = 4194304;
pub const EXTI_IMR1_IM23_Pos: u32 = 23;
pub const EXTI_IMR1_IM23_Msk: u32 = 8388608;
pub const EXTI_IMR1_IM23: u32 = 8388608;
pub const EXTI_IMR1_IM24_Pos: u32 = 24;
pub const EXTI_IMR1_IM24_Msk: u32 = 16777216;
pub const EXTI_IMR1_IM24: u32 = 16777216;
pub const EXTI_IMR1_IM25_Pos: u32 = 25;
pub const EXTI_IMR1_IM25_Msk: u32 = 33554432;
pub const EXTI_IMR1_IM25: u32 = 33554432;
pub const EXTI_IMR1_IM28_Pos: u32 = 28;
pub const EXTI_IMR1_IM28_Msk: u32 = 268435456;
pub const EXTI_IMR1_IM28: u32 = 268435456;
pub const EXTI_IMR1_IM29_Pos: u32 = 29;
pub const EXTI_IMR1_IM29_Msk: u32 = 536870912;
pub const EXTI_IMR1_IM29: u32 = 536870912;
pub const EXTI_IMR1_IM30_Pos: u32 = 30;
pub const EXTI_IMR1_IM30_Msk: u32 = 1073741824;
pub const EXTI_IMR1_IM30: u32 = 1073741824;
pub const EXTI_IMR1_IM31_Pos: u32 = 31;
pub const EXTI_IMR1_IM31_Msk: u32 = 2147483648;
pub const EXTI_IMR1_IM31: u32 = 2147483648;
pub const EXTI_EMR1_Pos: u32 = 0;
pub const EXTI_EMR1_Msk: u32 = 4128767;
pub const EXTI_EMR1_EM: u32 = 4128767;
pub const EXTI_EMR1_EM0_Pos: u32 = 0;
pub const EXTI_EMR1_EM0_Msk: u32 = 1;
pub const EXTI_EMR1_EM0: u32 = 1;
pub const EXTI_EMR1_EM1_Pos: u32 = 1;
pub const EXTI_EMR1_EM1_Msk: u32 = 2;
pub const EXTI_EMR1_EM1: u32 = 2;
pub const EXTI_EMR1_EM2_Pos: u32 = 2;
pub const EXTI_EMR1_EM2_Msk: u32 = 4;
pub const EXTI_EMR1_EM2: u32 = 4;
pub const EXTI_EMR1_EM3_Pos: u32 = 3;
pub const EXTI_EMR1_EM3_Msk: u32 = 8;
pub const EXTI_EMR1_EM3: u32 = 8;
pub const EXTI_EMR1_EM4_Pos: u32 = 4;
pub const EXTI_EMR1_EM4_Msk: u32 = 16;
pub const EXTI_EMR1_EM4: u32 = 16;
pub const EXTI_EMR1_EM5_Pos: u32 = 5;
pub const EXTI_EMR1_EM5_Msk: u32 = 32;
pub const EXTI_EMR1_EM5: u32 = 32;
pub const EXTI_EMR1_EM6_Pos: u32 = 6;
pub const EXTI_EMR1_EM6_Msk: u32 = 64;
pub const EXTI_EMR1_EM6: u32 = 64;
pub const EXTI_EMR1_EM7_Pos: u32 = 7;
pub const EXTI_EMR1_EM7_Msk: u32 = 128;
pub const EXTI_EMR1_EM7: u32 = 128;
pub const EXTI_EMR1_EM8_Pos: u32 = 8;
pub const EXTI_EMR1_EM8_Msk: u32 = 256;
pub const EXTI_EMR1_EM8: u32 = 256;
pub const EXTI_EMR1_EM9_Pos: u32 = 9;
pub const EXTI_EMR1_EM9_Msk: u32 = 512;
pub const EXTI_EMR1_EM9: u32 = 512;
pub const EXTI_EMR1_EM10_Pos: u32 = 10;
pub const EXTI_EMR1_EM10_Msk: u32 = 1024;
pub const EXTI_EMR1_EM10: u32 = 1024;
pub const EXTI_EMR1_EM11_Pos: u32 = 11;
pub const EXTI_EMR1_EM11_Msk: u32 = 2048;
pub const EXTI_EMR1_EM11: u32 = 2048;
pub const EXTI_EMR1_EM12_Pos: u32 = 12;
pub const EXTI_EMR1_EM12_Msk: u32 = 4096;
pub const EXTI_EMR1_EM12: u32 = 4096;
pub const EXTI_EMR1_EM13_Pos: u32 = 13;
pub const EXTI_EMR1_EM13_Msk: u32 = 8192;
pub const EXTI_EMR1_EM13: u32 = 8192;
pub const EXTI_EMR1_EM14_Pos: u32 = 14;
pub const EXTI_EMR1_EM14_Msk: u32 = 16384;
pub const EXTI_EMR1_EM14: u32 = 16384;
pub const EXTI_EMR1_EM15_Pos: u32 = 15;
pub const EXTI_EMR1_EM15_Msk: u32 = 32768;
pub const EXTI_EMR1_EM15: u32 = 32768;
pub const EXTI_EMR1_EM17_Pos: u32 = 17;
pub const EXTI_EMR1_EM17_Msk: u32 = 131072;
pub const EXTI_EMR1_EM17: u32 = 131072;
pub const EXTI_EMR1_EM18_Pos: u32 = 18;
pub const EXTI_EMR1_EM18_Msk: u32 = 262144;
pub const EXTI_EMR1_EM18: u32 = 262144;
pub const EXTI_EMR1_EM19_Pos: u32 = 19;
pub const EXTI_EMR1_EM19_Msk: u32 = 524288;
pub const EXTI_EMR1_EM19: u32 = 524288;
pub const EXTI_EMR1_EM20_Pos: u32 = 20;
pub const EXTI_EMR1_EM20_Msk: u32 = 1048576;
pub const EXTI_EMR1_EM20: u32 = 1048576;
pub const EXTI_EMR1_EM21_Pos: u32 = 21;
pub const EXTI_EMR1_EM21_Msk: u32 = 2097152;
pub const EXTI_EMR1_EM21: u32 = 2097152;
pub const EXTI_IMR2_Pos: u32 = 0;
pub const EXTI_IMR2_Msk: u32 = 131071;
pub const EXTI_IMR2_IM: u32 = 131071;
pub const EXTI_IMR2_IM33_Pos: u32 = 1;
pub const EXTI_IMR2_IM33_Msk: u32 = 2;
pub const EXTI_IMR2_IM33: u32 = 2;
pub const EXTI_IMR2_IM36_Pos: u32 = 4;
pub const EXTI_IMR2_IM36_Msk: u32 = 16;
pub const EXTI_IMR2_IM36: u32 = 16;
pub const EXTI_IMR2_IM37_Pos: u32 = 5;
pub const EXTI_IMR2_IM37_Msk: u32 = 32;
pub const EXTI_IMR2_IM37: u32 = 32;
pub const EXTI_IMR2_IM38_Pos: u32 = 6;
pub const EXTI_IMR2_IM38_Msk: u32 = 64;
pub const EXTI_IMR2_IM38: u32 = 64;
pub const EXTI_IMR2_IM39_Pos: u32 = 7;
pub const EXTI_IMR2_IM39_Msk: u32 = 128;
pub const EXTI_IMR2_IM39: u32 = 128;
pub const EXTI_IMR2_IM40_Pos: u32 = 8;
pub const EXTI_IMR2_IM40_Msk: u32 = 256;
pub const EXTI_IMR2_IM40: u32 = 256;
pub const EXTI_IMR2_IM41_Pos: u32 = 9;
pub const EXTI_IMR2_IM41_Msk: u32 = 512;
pub const EXTI_IMR2_IM41: u32 = 512;
pub const EXTI_IMR2_IM42_Pos: u32 = 10;
pub const EXTI_IMR2_IM42_Msk: u32 = 1024;
pub const EXTI_IMR2_IM42: u32 = 1024;
pub const EXTI_IMR2_IM43_Pos: u32 = 11;
pub const EXTI_IMR2_IM43_Msk: u32 = 2048;
pub const EXTI_IMR2_IM43: u32 = 2048;
pub const EXTI_IMR2_IM44_Pos: u32 = 12;
pub const EXTI_IMR2_IM44_Msk: u32 = 4096;
pub const EXTI_IMR2_IM44: u32 = 4096;
pub const EXTI_IMR2_IM45_Pos: u32 = 13;
pub const EXTI_IMR2_IM45_Msk: u32 = 8192;
pub const EXTI_IMR2_IM45: u32 = 8192;
pub const EXTI_IMR2_IM46_Pos: u32 = 14;
pub const EXTI_IMR2_IM46_Msk: u32 = 16384;
pub const EXTI_IMR2_IM46: u32 = 16384;
pub const EXTI_IMR2_IM48_Pos: u32 = 16;
pub const EXTI_IMR2_IM48_Msk: u32 = 65536;
pub const EXTI_IMR2_IM48: u32 = 65536;
pub const EXTI_EMR2_Pos: u32 = 0;
pub const EXTI_EMR2_Msk: u32 = 768;
pub const EXTI_EMR2_EM: u32 = 768;
pub const EXTI_EMR2_EM40_Pos: u32 = 8;
pub const EXTI_EMR2_EM40_Msk: u32 = 256;
pub const EXTI_EMR2_EM40: u32 = 256;
pub const EXTI_EMR2_EM41_Pos: u32 = 9;
pub const EXTI_EMR2_EM41_Msk: u32 = 512;
pub const EXTI_EMR2_EM41: u32 = 512;
pub const EXTI_C2IMR1_Pos: u32 = 0;
pub const EXTI_C2IMR1_Msk: u32 = 4294967295;
pub const EXTI_C2IMR1_IM: u32 = 4294967295;
pub const EXTI_C2IMR1_IM0_Pos: u32 = 0;
pub const EXTI_C2IMR1_IM0_Msk: u32 = 1;
pub const EXTI_C2IMR1_IM0: u32 = 1;
pub const EXTI_C2IMR1_IM1_Pos: u32 = 1;
pub const EXTI_C2IMR1_IM1_Msk: u32 = 2;
pub const EXTI_C2IMR1_IM1: u32 = 2;
pub const EXTI_C2IMR1_IM2_Pos: u32 = 2;
pub const EXTI_C2IMR1_IM2_Msk: u32 = 4;
pub const EXTI_C2IMR1_IM2: u32 = 4;
pub const EXTI_C2IMR1_IM3_Pos: u32 = 3;
pub const EXTI_C2IMR1_IM3_Msk: u32 = 8;
pub const EXTI_C2IMR1_IM3: u32 = 8;
pub const EXTI_C2IMR1_IM4_Pos: u32 = 4;
pub const EXTI_C2IMR1_IM4_Msk: u32 = 16;
pub const EXTI_C2IMR1_IM4: u32 = 16;
pub const EXTI_C2IMR1_IM5_Pos: u32 = 5;
pub const EXTI_C2IMR1_IM5_Msk: u32 = 32;
pub const EXTI_C2IMR1_IM5: u32 = 32;
pub const EXTI_C2IMR1_IM6_Pos: u32 = 6;
pub const EXTI_C2IMR1_IM6_Msk: u32 = 64;
pub const EXTI_C2IMR1_IM6: u32 = 64;
pub const EXTI_C2IMR1_IM7_Pos: u32 = 7;
pub const EXTI_C2IMR1_IM7_Msk: u32 = 128;
pub const EXTI_C2IMR1_IM7: u32 = 128;
pub const EXTI_C2IMR1_IM8_Pos: u32 = 8;
pub const EXTI_C2IMR1_IM8_Msk: u32 = 256;
pub const EXTI_C2IMR1_IM8: u32 = 256;
pub const EXTI_C2IMR1_IM9_Pos: u32 = 9;
pub const EXTI_C2IMR1_IM9_Msk: u32 = 512;
pub const EXTI_C2IMR1_IM9: u32 = 512;
pub const EXTI_C2IMR1_IM10_Pos: u32 = 10;
pub const EXTI_C2IMR1_IM10_Msk: u32 = 1024;
pub const EXTI_C2IMR1_IM10: u32 = 1024;
pub const EXTI_C2IMR1_IM11_Pos: u32 = 11;
pub const EXTI_C2IMR1_IM11_Msk: u32 = 2048;
pub const EXTI_C2IMR1_IM11: u32 = 2048;
pub const EXTI_C2IMR1_IM12_Pos: u32 = 12;
pub const EXTI_C2IMR1_IM12_Msk: u32 = 4096;
pub const EXTI_C2IMR1_IM12: u32 = 4096;
pub const EXTI_C2IMR1_IM13_Pos: u32 = 13;
pub const EXTI_C2IMR1_IM13_Msk: u32 = 8192;
pub const EXTI_C2IMR1_IM13: u32 = 8192;
pub const EXTI_C2IMR1_IM14_Pos: u32 = 14;
pub const EXTI_C2IMR1_IM14_Msk: u32 = 16384;
pub const EXTI_C2IMR1_IM14: u32 = 16384;
pub const EXTI_C2IMR1_IM15_Pos: u32 = 15;
pub const EXTI_C2IMR1_IM15_Msk: u32 = 32768;
pub const EXTI_C2IMR1_IM15: u32 = 32768;
pub const EXTI_C2IMR1_IM16_Pos: u32 = 16;
pub const EXTI_C2IMR1_IM16_Msk: u32 = 65536;
pub const EXTI_C2IMR1_IM16: u32 = 65536;
pub const EXTI_C2IMR1_IM17_Pos: u32 = 17;
pub const EXTI_C2IMR1_IM17_Msk: u32 = 131072;
pub const EXTI_C2IMR1_IM17: u32 = 131072;
pub const EXTI_C2IMR1_IM18_Pos: u32 = 18;
pub const EXTI_C2IMR1_IM18_Msk: u32 = 262144;
pub const EXTI_C2IMR1_IM18: u32 = 262144;
pub const EXTI_C2IMR1_IM19_Pos: u32 = 19;
pub const EXTI_C2IMR1_IM19_Msk: u32 = 524288;
pub const EXTI_C2IMR1_IM19: u32 = 524288;
pub const EXTI_C2IMR1_IM20_Pos: u32 = 20;
pub const EXTI_C2IMR1_IM20_Msk: u32 = 1048576;
pub const EXTI_C2IMR1_IM20: u32 = 1048576;
pub const EXTI_C2IMR1_IM21_Pos: u32 = 21;
pub const EXTI_C2IMR1_IM21_Msk: u32 = 2097152;
pub const EXTI_C2IMR1_IM21: u32 = 2097152;
pub const EXTI_C2IMR1_IM22_Pos: u32 = 22;
pub const EXTI_C2IMR1_IM22_Msk: u32 = 4194304;
pub const EXTI_C2IMR1_IM22: u32 = 4194304;
pub const EXTI_C2IMR1_IM23_Pos: u32 = 23;
pub const EXTI_C2IMR1_IM23_Msk: u32 = 8388608;
pub const EXTI_C2IMR1_IM23: u32 = 8388608;
pub const EXTI_C2IMR1_IM24_Pos: u32 = 24;
pub const EXTI_C2IMR1_IM24_Msk: u32 = 16777216;
pub const EXTI_C2IMR1_IM24: u32 = 16777216;
pub const EXTI_C2IMR1_IM25_Pos: u32 = 25;
pub const EXTI_C2IMR1_IM25_Msk: u32 = 33554432;
pub const EXTI_C2IMR1_IM25: u32 = 33554432;
pub const EXTI_C2IMR1_IM28_Pos: u32 = 28;
pub const EXTI_C2IMR1_IM28_Msk: u32 = 268435456;
pub const EXTI_C2IMR1_IM28: u32 = 268435456;
pub const EXTI_C2IMR1_IM29_Pos: u32 = 29;
pub const EXTI_C2IMR1_IM29_Msk: u32 = 536870912;
pub const EXTI_C2IMR1_IM29: u32 = 536870912;
pub const EXTI_C2IMR1_IM30_Pos: u32 = 30;
pub const EXTI_C2IMR1_IM30_Msk: u32 = 1073741824;
pub const EXTI_C2IMR1_IM30: u32 = 1073741824;
pub const EXTI_C2IMR1_IM31_Pos: u32 = 31;
pub const EXTI_C2IMR1_IM31_Msk: u32 = 2147483648;
pub const EXTI_C2IMR1_IM31: u32 = 2147483648;
pub const EXTI_C2EMR1_Pos: u32 = 0;
pub const EXTI_C2EMR1_Msk: u32 = 4128767;
pub const EXTI_C2EMR1_EM: u32 = 4128767;
pub const EXTI_C2EMR1_EM0_Pos: u32 = 0;
pub const EXTI_C2EMR1_EM0_Msk: u32 = 1;
pub const EXTI_C2EMR1_EM0: u32 = 1;
pub const EXTI_C2EMR1_EM1_Pos: u32 = 1;
pub const EXTI_C2EMR1_EM1_Msk: u32 = 2;
pub const EXTI_C2EMR1_EM1: u32 = 2;
pub const EXTI_C2EMR1_EM2_Pos: u32 = 2;
pub const EXTI_C2EMR1_EM2_Msk: u32 = 4;
pub const EXTI_C2EMR1_EM2: u32 = 4;
pub const EXTI_C2EMR1_EM3_Pos: u32 = 3;
pub const EXTI_C2EMR1_EM3_Msk: u32 = 8;
pub const EXTI_C2EMR1_EM3: u32 = 8;
pub const EXTI_C2EMR1_EM4_Pos: u32 = 4;
pub const EXTI_C2EMR1_EM4_Msk: u32 = 16;
pub const EXTI_C2EMR1_EM4: u32 = 16;
pub const EXTI_C2EMR1_EM5_Pos: u32 = 5;
pub const EXTI_C2EMR1_EM5_Msk: u32 = 32;
pub const EXTI_C2EMR1_EM5: u32 = 32;
pub const EXTI_C2EMR1_EM6_Pos: u32 = 6;
pub const EXTI_C2EMR1_EM6_Msk: u32 = 64;
pub const EXTI_C2EMR1_EM6: u32 = 64;
pub const EXTI_C2EMR1_EM7_Pos: u32 = 7;
pub const EXTI_C2EMR1_EM7_Msk: u32 = 128;
pub const EXTI_C2EMR1_EM7: u32 = 128;
pub const EXTI_C2EMR1_EM8_Pos: u32 = 8;
pub const EXTI_C2EMR1_EM8_Msk: u32 = 256;
pub const EXTI_C2EMR1_EM8: u32 = 256;
pub const EXTI_C2EMR1_EM9_Pos: u32 = 9;
pub const EXTI_C2EMR1_EM9_Msk: u32 = 512;
pub const EXTI_C2EMR1_EM9: u32 = 512;
pub const EXTI_C2EMR1_EM10_Pos: u32 = 10;
pub const EXTI_C2EMR1_EM10_Msk: u32 = 1024;
pub const EXTI_C2EMR1_EM10: u32 = 1024;
pub const EXTI_C2EMR1_EM11_Pos: u32 = 11;
pub const EXTI_C2EMR1_EM11_Msk: u32 = 2048;
pub const EXTI_C2EMR1_EM11: u32 = 2048;
pub const EXTI_C2EMR1_EM12_Pos: u32 = 12;
pub const EXTI_C2EMR1_EM12_Msk: u32 = 4096;
pub const EXTI_C2EMR1_EM12: u32 = 4096;
pub const EXTI_C2EMR1_EM13_Pos: u32 = 13;
pub const EXTI_C2EMR1_EM13_Msk: u32 = 8192;
pub const EXTI_C2EMR1_EM13: u32 = 8192;
pub const EXTI_C2EMR1_EM14_Pos: u32 = 14;
pub const EXTI_C2EMR1_EM14_Msk: u32 = 16384;
pub const EXTI_C2EMR1_EM14: u32 = 16384;
pub const EXTI_C2EMR1_EM15_Pos: u32 = 15;
pub const EXTI_C2EMR1_EM15_Msk: u32 = 32768;
pub const EXTI_C2EMR1_EM15: u32 = 32768;
pub const EXTI_C2EMR1_EM17_Pos: u32 = 17;
pub const EXTI_C2EMR1_EM17_Msk: u32 = 131072;
pub const EXTI_C2EMR1_EM17: u32 = 131072;
pub const EXTI_C2EMR1_EM18_Pos: u32 = 18;
pub const EXTI_C2EMR1_EM18_Msk: u32 = 262144;
pub const EXTI_C2EMR1_EM18: u32 = 262144;
pub const EXTI_C2EMR1_EM19_Pos: u32 = 19;
pub const EXTI_C2EMR1_EM19_Msk: u32 = 524288;
pub const EXTI_C2EMR1_EM19: u32 = 524288;
pub const EXTI_C2EMR1_EM20_Pos: u32 = 20;
pub const EXTI_C2EMR1_EM20_Msk: u32 = 1048576;
pub const EXTI_C2EMR1_EM20: u32 = 1048576;
pub const EXTI_C2EMR1_EM21_Pos: u32 = 21;
pub const EXTI_C2EMR1_EM21_Msk: u32 = 2097152;
pub const EXTI_C2EMR1_EM21: u32 = 2097152;
pub const EXTI_C2IMR2_Pos: u32 = 0;
pub const EXTI_C2IMR2_Msk: u32 = 131071;
pub const EXTI_C2IMR2_IM: u32 = 131071;
pub const EXTI_C2IMR2_IM33_Pos: u32 = 1;
pub const EXTI_C2IMR2_IM33_Msk: u32 = 2;
pub const EXTI_C2IMR2_IM33: u32 = 2;
pub const EXTI_C2IMR2_IM36_Pos: u32 = 4;
pub const EXTI_C2IMR2_IM36_Msk: u32 = 16;
pub const EXTI_C2IMR2_IM36: u32 = 16;
pub const EXTI_C2IMR2_IM37_Pos: u32 = 5;
pub const EXTI_C2IMR2_IM37_Msk: u32 = 32;
pub const EXTI_C2IMR2_IM37: u32 = 32;
pub const EXTI_C2IMR2_IM38_Pos: u32 = 6;
pub const EXTI_C2IMR2_IM38_Msk: u32 = 64;
pub const EXTI_C2IMR2_IM38: u32 = 64;
pub const EXTI_C2IMR2_IM39_Pos: u32 = 7;
pub const EXTI_C2IMR2_IM39_Msk: u32 = 128;
pub const EXTI_C2IMR2_IM39: u32 = 128;
pub const EXTI_C2IMR2_IM40_Pos: u32 = 8;
pub const EXTI_C2IMR2_IM40_Msk: u32 = 256;
pub const EXTI_C2IMR2_IM40: u32 = 256;
pub const EXTI_C2IMR2_IM41_Pos: u32 = 9;
pub const EXTI_C2IMR2_IM41_Msk: u32 = 512;
pub const EXTI_C2IMR2_IM41: u32 = 512;
pub const EXTI_C2IMR2_IM42_Pos: u32 = 10;
pub const EXTI_C2IMR2_IM42_Msk: u32 = 1024;
pub const EXTI_C2IMR2_IM42: u32 = 1024;
pub const EXTI_C2IMR2_IM43_Pos: u32 = 11;
pub const EXTI_C2IMR2_IM43_Msk: u32 = 2048;
pub const EXTI_C2IMR2_IM43: u32 = 2048;
pub const EXTI_C2IMR2_IM44_Pos: u32 = 12;
pub const EXTI_C2IMR2_IM44_Msk: u32 = 4096;
pub const EXTI_C2IMR2_IM44: u32 = 4096;
pub const EXTI_C2IMR2_IM45_Pos: u32 = 13;
pub const EXTI_C2IMR2_IM45_Msk: u32 = 8192;
pub const EXTI_C2IMR2_IM45: u32 = 8192;
pub const EXTI_C2IMR2_IM46_Pos: u32 = 14;
pub const EXTI_C2IMR2_IM46_Msk: u32 = 16384;
pub const EXTI_C2IMR2_IM46: u32 = 16384;
pub const EXTI_C2IMR2_IM48_Pos: u32 = 16;
pub const EXTI_C2IMR2_IM48_Msk: u32 = 65536;
pub const EXTI_C2IMR2_IM48: u32 = 65536;
pub const EXTI_C2EMR2_Pos: u32 = 8;
pub const EXTI_C2EMR2_Msk: u32 = 196608;
pub const EXTI_C2EMR2_EM: u32 = 196608;
pub const EXTI_C2EMR2_EM40_Pos: u32 = 8;
pub const EXTI_C2EMR2_EM40_Msk: u32 = 256;
pub const EXTI_C2EMR2_EM40: u32 = 256;
pub const EXTI_C2EMR2_EM41_Pos: u32 = 9;
pub const EXTI_C2EMR2_EM41_Msk: u32 = 512;
pub const EXTI_C2EMR2_EM41: u32 = 512;
pub const PKA_CR_EN_Pos: u32 = 0;
pub const PKA_CR_EN_Msk: u32 = 1;
pub const PKA_CR_EN: u32 = 1;
pub const PKA_CR_START_Pos: u32 = 1;
pub const PKA_CR_START_Msk: u32 = 2;
pub const PKA_CR_START: u32 = 2;
pub const PKA_CR_MODE_Pos: u32 = 8;
pub const PKA_CR_MODE_Msk: u32 = 16128;
pub const PKA_CR_MODE: u32 = 16128;
pub const PKA_CR_MODE_0: u32 = 256;
pub const PKA_CR_MODE_1: u32 = 512;
pub const PKA_CR_MODE_2: u32 = 1024;
pub const PKA_CR_MODE_3: u32 = 2048;
pub const PKA_CR_MODE_4: u32 = 4096;
pub const PKA_CR_MODE_5: u32 = 8192;
pub const PKA_CR_PROCENDIE_Pos: u32 = 17;
pub const PKA_CR_PROCENDIE_Msk: u32 = 131072;
pub const PKA_CR_PROCENDIE: u32 = 131072;
pub const PKA_CR_RAMERRIE_Pos: u32 = 19;
pub const PKA_CR_RAMERRIE_Msk: u32 = 524288;
pub const PKA_CR_RAMERRIE: u32 = 524288;
pub const PKA_CR_ADDRERRIE_Pos: u32 = 20;
pub const PKA_CR_ADDRERRIE_Msk: u32 = 1048576;
pub const PKA_CR_ADDRERRIE: u32 = 1048576;
pub const PKA_SR_BUSY_Pos: u32 = 16;
pub const PKA_SR_BUSY_Msk: u32 = 65536;
pub const PKA_SR_BUSY: u32 = 65536;
pub const PKA_SR_PROCENDF_Pos: u32 = 17;
pub const PKA_SR_PROCENDF_Msk: u32 = 131072;
pub const PKA_SR_PROCENDF: u32 = 131072;
pub const PKA_SR_RAMERRF_Pos: u32 = 19;
pub const PKA_SR_RAMERRF_Msk: u32 = 524288;
pub const PKA_SR_RAMERRF: u32 = 524288;
pub const PKA_SR_ADDRERRF_Pos: u32 = 20;
pub const PKA_SR_ADDRERRF_Msk: u32 = 1048576;
pub const PKA_SR_ADDRERRF: u32 = 1048576;
pub const PKA_CLRFR_PROCENDFC_Pos: u32 = 17;
pub const PKA_CLRFR_PROCENDFC_Msk: u32 = 131072;
pub const PKA_CLRFR_PROCENDFC: u32 = 131072;
pub const PKA_CLRFR_RAMERRFC_Pos: u32 = 19;
pub const PKA_CLRFR_RAMERRFC_Msk: u32 = 524288;
pub const PKA_CLRFR_RAMERRFC: u32 = 524288;
pub const PKA_CLRFR_ADDRERRFC_Pos: u32 = 20;
pub const PKA_CLRFR_ADDRERRFC_Msk: u32 = 1048576;
pub const PKA_CLRFR_ADDRERRFC: u32 = 1048576;
pub const PKA_RAM_OFFSET: u32 = 1024;
pub const PKA_MONTGOMERY_PARAM_IN_MOD_NB_BITS: u32 = 1;
pub const PKA_MONTGOMERY_PARAM_IN_MODULUS: u32 = 599;
pub const PKA_MONTGOMERY_PARAM_OUT_PARAMETER: u32 = 101;
pub const PKA_MODULAR_EXP_IN_EXP_NB_BITS: u32 = 0;
pub const PKA_MODULAR_EXP_IN_OP_NB_BITS: u32 = 1;
pub const PKA_MODULAR_EXP_IN_MONTGOMERY_PARAM: u32 = 101;
pub const PKA_MODULAR_EXP_IN_EXPONENT_BASE: u32 = 401;
pub const PKA_MODULAR_EXP_IN_EXPONENT: u32 = 500;
pub const PKA_MODULAR_EXP_IN_MODULUS: u32 = 599;
pub const PKA_MODULAR_EXP_OUT_MONTGOMERY_PARAM: u32 = 101;
pub const PKA_MODULAR_EXP_OUT_SM_ALGO_ACC1: u32 = 201;
pub const PKA_MODULAR_EXP_OUT_SM_ALGO_ACC2: u32 = 301;
pub const PKA_MODULAR_EXP_OUT_EXPONENT_BASE: u32 = 401;
pub const PKA_MODULAR_EXP_OUT_SM_ALGO_ACC3: u32 = 655;
pub const PKA_ECC_SCALAR_MUL_IN_EXP_NB_BITS: u32 = 0;
pub const PKA_ECC_SCALAR_MUL_IN_OP_NB_BITS: u32 = 1;
pub const PKA_ECC_SCALAR_MUL_IN_A_COEFF_SIGN: u32 = 2;
pub const PKA_ECC_SCALAR_MUL_IN_A_COEFF: u32 = 3;
pub const PKA_ECC_SCALAR_MUL_IN_MOD_GF: u32 = 24;
pub const PKA_ECC_SCALAR_MUL_IN_MONTGOMERY_PARAM: u32 = 45;
pub const PKA_ECC_SCALAR_MUL_IN_K: u32 = 66;
pub const PKA_ECC_SCALAR_MUL_IN_INITIAL_POINT_X: u32 = 87;
pub const PKA_ECC_SCALAR_MUL_IN_INITIAL_POINT_Y: u32 = 108;
pub const PKA_ECC_SCALAR_MUL_OUT_RESULT_X: u32 = 87;
pub const PKA_ECC_SCALAR_MUL_OUT_RESULT_Y: u32 = 108;
pub const PKA_ECC_SCALAR_MUL_OUT_LAST_DOUBLE_X1: u32 = 634;
pub const PKA_ECC_SCALAR_MUL_OUT_LAST_DOUBLE_Y1: u32 = 655;
pub const PKA_ECC_SCALAR_MUL_OUT_LAST_DOUBLE_Z1: u32 = 676;
pub const PKA_ECC_SCALAR_MUL_OUT_CHECK_POINT_X2: u32 = 697;
pub const PKA_ECC_SCALAR_MUL_OUT_CHECK_POINT_Y2: u32 = 718;
pub const PKA_ECC_SCALAR_MUL_OUT_CHECK_POINT_Z2: u32 = 739;
pub const PKA_POINT_CHECK_IN_MOD_NB_BITS: u32 = 1;
pub const PKA_POINT_CHECK_IN_A_COEFF_SIGN: u32 = 2;
pub const PKA_POINT_CHECK_IN_A_COEFF: u32 = 3;
pub const PKA_POINT_CHECK_IN_B_COEFF: u32 = 255;
pub const PKA_POINT_CHECK_IN_MOD_GF: u32 = 24;
pub const PKA_POINT_CHECK_IN_INITIAL_POINT_X: u32 = 87;
pub const PKA_POINT_CHECK_IN_INITIAL_POINT_Y: u32 = 108;
pub const PKA_POINT_CHECK_OUT_ERROR: u32 = 0;
pub const PKA_ECDSA_SIGN_IN_ORDER_NB_BITS: u32 = 0;
pub const PKA_ECDSA_SIGN_IN_MOD_NB_BITS: u32 = 1;
pub const PKA_ECDSA_SIGN_IN_A_COEFF_SIGN: u32 = 2;
pub const PKA_ECDSA_SIGN_IN_A_COEFF: u32 = 3;
pub const PKA_ECDSA_SIGN_IN_MOD_GF: u32 = 24;
pub const PKA_ECDSA_SIGN_IN_K: u32 = 66;
pub const PKA_ECDSA_SIGN_IN_INITIAL_POINT_X: u32 = 87;
pub const PKA_ECDSA_SIGN_IN_INITIAL_POINT_Y: u32 = 108;
pub const PKA_ECDSA_SIGN_IN_HASH_E: u32 = 634;
pub const PKA_ECDSA_SIGN_IN_PRIVATE_KEY_D: u32 = 655;
pub const PKA_ECDSA_SIGN_IN_ORDER_N: u32 = 677;
pub const PKA_ECDSA_SIGN_OUT_ERROR: u32 = 698;
pub const PKA_ECDSA_SIGN_OUT_SIGNATURE_R: u32 = 192;
pub const PKA_ECDSA_SIGN_OUT_SIGNATURE_S: u32 = 213;
pub const PKA_ECDSA_SIGN_OUT_FINAL_POINT_X: u32 = 783;
pub const PKA_ECDSA_SIGN_OUT_FINAL_POINT_Y: u32 = 804;
pub const PKA_ECDSA_VERIF_IN_ORDER_NB_BITS: u32 = 1;
pub const PKA_ECDSA_VERIF_IN_MOD_NB_BITS: u32 = 45;
pub const PKA_ECDSA_VERIF_IN_A_COEFF_SIGN: u32 = 23;
pub const PKA_ECDSA_VERIF_IN_A_COEFF: u32 = 24;
pub const PKA_ECDSA_VERIF_IN_MOD_GF: u32 = 46;
pub const PKA_ECDSA_VERIF_IN_INITIAL_POINT_X: u32 = 122;
pub const PKA_ECDSA_VERIF_IN_INITIAL_POINT_Y: u32 = 143;
pub const PKA_ECDSA_VERIF_IN_PUBLIC_KEY_POINT_X: u32 = 720;
pub const PKA_ECDSA_VERIF_IN_PUBLIC_KEY_POINT_Y: u32 = 741;
pub const PKA_ECDSA_VERIF_IN_SIGNATURE_R: u32 = 806;
pub const PKA_ECDSA_VERIF_IN_SIGNATURE_S: u32 = 401;
pub const PKA_ECDSA_VERIF_IN_HASH_E: u32 = 762;
pub const PKA_ECDSA_VERIF_IN_ORDER_N: u32 = 599;
pub const PKA_ECDSA_VERIF_OUT_RESULT: u32 = 108;
pub const PKA_RSA_CRT_EXP_IN_MOD_NB_BITS: u32 = 1;
pub const PKA_RSA_CRT_EXP_IN_DP_CRT: u32 = 151;
pub const PKA_RSA_CRT_EXP_IN_DQ_CRT: u32 = 500;
pub const PKA_RSA_CRT_EXP_IN_QINV_CRT: u32 = 251;
pub const PKA_RSA_CRT_EXP_IN_PRIME_P: u32 = 351;
pub const PKA_RSA_CRT_EXP_IN_PRIME_Q: u32 = 599;
pub const PKA_RSA_CRT_EXP_IN_EXPONENT_BASE: u32 = 699;
pub const PKA_RSA_CRT_EXP_OUT_RESULT: u32 = 201;
pub const PKA_MODULAR_REDUC_IN_OP_LENGTH: u32 = 0;
pub const PKA_MODULAR_REDUC_IN_OPERAND: u32 = 301;
pub const PKA_MODULAR_REDUC_IN_MOD_LENGTH: u32 = 1;
pub const PKA_MODULAR_REDUC_IN_MODULUS: u32 = 401;
pub const PKA_MODULAR_REDUC_OUT_RESULT: u32 = 500;
pub const PKA_ARITHMETIC_ADD_NB_BITS: u32 = 1;
pub const PKA_ARITHMETIC_ADD_IN_OP1: u32 = 301;
pub const PKA_ARITHMETIC_ADD_IN_OP2: u32 = 401;
pub const PKA_ARITHMETIC_ADD_OUT_RESULT: u32 = 500;
pub const PKA_ARITHMETIC_SUB_NB_BITS: u32 = 1;
pub const PKA_ARITHMETIC_SUB_IN_OP1: u32 = 301;
pub const PKA_ARITHMETIC_SUB_IN_OP2: u32 = 401;
pub const PKA_ARITHMETIC_SUB_OUT_RESULT: u32 = 500;
pub const PKA_ARITHMETIC_MUL_NB_BITS: u32 = 1;
pub const PKA_ARITHMETIC_MUL_IN_OP1: u32 = 301;
pub const PKA_ARITHMETIC_MUL_IN_OP2: u32 = 401;
pub const PKA_ARITHMETIC_MUL_OUT_RESULT: u32 = 500;
pub const PKA_COMPARISON_NB_BITS: u32 = 1;
pub const PKA_COMPARISON_IN_OP1: u32 = 301;
pub const PKA_COMPARISON_IN_OP2: u32 = 401;
pub const PKA_COMPARISON_OUT_RESULT: u32 = 500;
pub const PKA_MODULAR_ADD_NB_BITS: u32 = 1;
pub const PKA_MODULAR_ADD_IN_OP1: u32 = 301;
pub const PKA_MODULAR_ADD_IN_OP2: u32 = 401;
pub const PKA_MODULAR_ADD_IN_OP3_MOD: u32 = 599;
pub const PKA_MODULAR_ADD_OUT_RESULT: u32 = 500;
pub const PKA_MODULAR_INV_NB_BITS: u32 = 1;
pub const PKA_MODULAR_INV_IN_OP1: u32 = 301;
pub const PKA_MODULAR_INV_IN_OP2_MOD: u32 = 401;
pub const PKA_MODULAR_INV_OUT_RESULT: u32 = 500;
pub const PKA_MODULAR_SUB_NB_BITS: u32 = 1;
pub const PKA_MODULAR_SUB_IN_OP1: u32 = 301;
pub const PKA_MODULAR_SUB_IN_OP2: u32 = 401;
pub const PKA_MODULAR_SUB_IN_OP3_MOD: u32 = 599;
pub const PKA_MODULAR_SUB_OUT_RESULT: u32 = 500;
pub const PKA_MONTGOMERY_MUL_NB_BITS: u32 = 1;
pub const PKA_MONTGOMERY_MUL_IN_OP1: u32 = 301;
pub const PKA_MONTGOMERY_MUL_IN_OP2: u32 = 401;
pub const PKA_MONTGOMERY_MUL_IN_OP3_MOD: u32 = 599;
pub const PKA_MONTGOMERY_MUL_OUT_RESULT: u32 = 500;
pub const PKA_ARITHMETIC_ALL_OPS_NB_BITS: u32 = 1;
pub const PKA_ARITHMETIC_ALL_OPS_IN_OP1: u32 = 301;
pub const PKA_ARITHMETIC_ALL_OPS_IN_OP2: u32 = 401;
pub const PKA_ARITHMETIC_ALL_OPS_IN_OP3: u32 = 599;
pub const PKA_ARITHMETIC_ALL_OPS_OUT_RESULT: u32 = 500;
pub const FLASH_ACR_LATENCY_Pos: u32 = 0;
pub const FLASH_ACR_LATENCY_Msk: u32 = 7;
pub const FLASH_ACR_LATENCY: u32 = 7;
pub const FLASH_ACR_LATENCY_0: u32 = 1;
pub const FLASH_ACR_LATENCY_1: u32 = 2;
pub const FLASH_ACR_LATENCY_2: u32 = 4;
pub const FLASH_ACR_PRFTEN_Pos: u32 = 8;
pub const FLASH_ACR_PRFTEN_Msk: u32 = 256;
pub const FLASH_ACR_PRFTEN: u32 = 256;
pub const FLASH_ACR_ICEN_Pos: u32 = 9;
pub const FLASH_ACR_ICEN_Msk: u32 = 512;
pub const FLASH_ACR_ICEN: u32 = 512;
pub const FLASH_ACR_DCEN_Pos: u32 = 10;
pub const FLASH_ACR_DCEN_Msk: u32 = 1024;
pub const FLASH_ACR_DCEN: u32 = 1024;
pub const FLASH_ACR_ICRST_Pos: u32 = 11;
pub const FLASH_ACR_ICRST_Msk: u32 = 2048;
pub const FLASH_ACR_ICRST: u32 = 2048;
pub const FLASH_ACR_DCRST_Pos: u32 = 12;
pub const FLASH_ACR_DCRST_Msk: u32 = 4096;
pub const FLASH_ACR_DCRST: u32 = 4096;
pub const FLASH_ACR_PES_Pos: u32 = 15;
pub const FLASH_ACR_PES_Msk: u32 = 32768;
pub const FLASH_ACR_PES: u32 = 32768;
pub const FLASH_ACR_EMPTY_Pos: u32 = 16;
pub const FLASH_ACR_EMPTY_Msk: u32 = 65536;
pub const FLASH_ACR_EMPTY: u32 = 65536;
pub const FLASH_ACR_LATENCY_0WS: u32 = 0;
pub const FLASH_ACR_LATENCY_1WS: u32 = 1;
pub const FLASH_ACR_LATENCY_2WS: u32 = 2;
pub const FLASH_ACR_LATENCY_3WS: u32 = 3;
pub const FLASH_SR_EOP_Pos: u32 = 0;
pub const FLASH_SR_EOP_Msk: u32 = 1;
pub const FLASH_SR_EOP: u32 = 1;
pub const FLASH_SR_OPERR_Pos: u32 = 1;
pub const FLASH_SR_OPERR_Msk: u32 = 2;
pub const FLASH_SR_OPERR: u32 = 2;
pub const FLASH_SR_PROGERR_Pos: u32 = 3;
pub const FLASH_SR_PROGERR_Msk: u32 = 8;
pub const FLASH_SR_PROGERR: u32 = 8;
pub const FLASH_SR_WRPERR_Pos: u32 = 4;
pub const FLASH_SR_WRPERR_Msk: u32 = 16;
pub const FLASH_SR_WRPERR: u32 = 16;
pub const FLASH_SR_PGAERR_Pos: u32 = 5;
pub const FLASH_SR_PGAERR_Msk: u32 = 32;
pub const FLASH_SR_PGAERR: u32 = 32;
pub const FLASH_SR_SIZERR_Pos: u32 = 6;
pub const FLASH_SR_SIZERR_Msk: u32 = 64;
pub const FLASH_SR_SIZERR: u32 = 64;
pub const FLASH_SR_PGSERR_Pos: u32 = 7;
pub const FLASH_SR_PGSERR_Msk: u32 = 128;
pub const FLASH_SR_PGSERR: u32 = 128;
pub const FLASH_SR_MISERR_Pos: u32 = 8;
pub const FLASH_SR_MISERR_Msk: u32 = 256;
pub const FLASH_SR_MISERR: u32 = 256;
pub const FLASH_SR_FASTERR_Pos: u32 = 9;
pub const FLASH_SR_FASTERR_Msk: u32 = 512;
pub const FLASH_SR_FASTERR: u32 = 512;
pub const FLASH_SR_OPTNV_Pos: u32 = 13;
pub const FLASH_SR_OPTNV_Msk: u32 = 8192;
pub const FLASH_SR_OPTNV: u32 = 8192;
pub const FLASH_SR_RDERR_Pos: u32 = 14;
pub const FLASH_SR_RDERR_Msk: u32 = 16384;
pub const FLASH_SR_RDERR: u32 = 16384;
pub const FLASH_SR_OPTVERR_Pos: u32 = 15;
pub const FLASH_SR_OPTVERR_Msk: u32 = 32768;
pub const FLASH_SR_OPTVERR: u32 = 32768;
pub const FLASH_SR_BSY_Pos: u32 = 16;
pub const FLASH_SR_BSY_Msk: u32 = 65536;
pub const FLASH_SR_BSY: u32 = 65536;
pub const FLASH_SR_CFGBSY_Pos: u32 = 18;
pub const FLASH_SR_CFGBSY_Msk: u32 = 262144;
pub const FLASH_SR_CFGBSY: u32 = 262144;
pub const FLASH_SR_PESD_Pos: u32 = 19;
pub const FLASH_SR_PESD_Msk: u32 = 524288;
pub const FLASH_SR_PESD: u32 = 524288;
pub const FLASH_CR_PG_Pos: u32 = 0;
pub const FLASH_CR_PG_Msk: u32 = 1;
pub const FLASH_CR_PG: u32 = 1;
pub const FLASH_CR_PER_Pos: u32 = 1;
pub const FLASH_CR_PER_Msk: u32 = 2;
pub const FLASH_CR_PER: u32 = 2;
pub const FLASH_CR_MER_Pos: u32 = 2;
pub const FLASH_CR_MER_Msk: u32 = 4;
pub const FLASH_CR_MER: u32 = 4;
pub const FLASH_CR_PNB_Pos: u32 = 3;
pub const FLASH_CR_PNB_Msk: u32 = 2040;
pub const FLASH_CR_PNB: u32 = 2040;
pub const FLASH_CR_STRT_Pos: u32 = 16;
pub const FLASH_CR_STRT_Msk: u32 = 65536;
pub const FLASH_CR_STRT: u32 = 65536;
pub const FLASH_CR_OPTSTRT_Pos: u32 = 17;
pub const FLASH_CR_OPTSTRT_Msk: u32 = 131072;
pub const FLASH_CR_OPTSTRT: u32 = 131072;
pub const FLASH_CR_FSTPG_Pos: u32 = 18;
pub const FLASH_CR_FSTPG_Msk: u32 = 262144;
pub const FLASH_CR_FSTPG: u32 = 262144;
pub const FLASH_CR_EOPIE_Pos: u32 = 24;
pub const FLASH_CR_EOPIE_Msk: u32 = 16777216;
pub const FLASH_CR_EOPIE: u32 = 16777216;
pub const FLASH_CR_ERRIE_Pos: u32 = 25;
pub const FLASH_CR_ERRIE_Msk: u32 = 33554432;
pub const FLASH_CR_ERRIE: u32 = 33554432;
pub const FLASH_CR_RDERRIE_Pos: u32 = 26;
pub const FLASH_CR_RDERRIE_Msk: u32 = 67108864;
pub const FLASH_CR_RDERRIE: u32 = 67108864;
pub const FLASH_CR_OBL_LAUNCH_Pos: u32 = 27;
pub const FLASH_CR_OBL_LAUNCH_Msk: u32 = 134217728;
pub const FLASH_CR_OBL_LAUNCH: u32 = 134217728;
pub const FLASH_CR_OPTLOCK_Pos: u32 = 30;
pub const FLASH_CR_OPTLOCK_Msk: u32 = 1073741824;
pub const FLASH_CR_OPTLOCK: u32 = 1073741824;
pub const FLASH_CR_LOCK_Pos: u32 = 31;
pub const FLASH_CR_LOCK_Msk: u32 = 2147483648;
pub const FLASH_CR_LOCK: u32 = 2147483648;
pub const FLASH_ECCR_ADDR_ECC_Pos: u32 = 0;
pub const FLASH_ECCR_ADDR_ECC_Msk: u32 = 131071;
pub const FLASH_ECCR_ADDR_ECC: u32 = 131071;
pub const FLASH_ECCR_SYSF_ECC_Pos: u32 = 20;
pub const FLASH_ECCR_SYSF_ECC_Msk: u32 = 1048576;
pub const FLASH_ECCR_SYSF_ECC: u32 = 1048576;
pub const FLASH_ECCR_ECCCIE_Pos: u32 = 24;
pub const FLASH_ECCR_ECCCIE_Msk: u32 = 16777216;
pub const FLASH_ECCR_ECCCIE: u32 = 16777216;
pub const FLASH_ECCR_CPUID_Pos: u32 = 26;
pub const FLASH_ECCR_CPUID_Msk: u32 = 469762048;
pub const FLASH_ECCR_CPUID: u32 = 469762048;
pub const FLASH_ECCR_CPUID_0: u32 = 67108864;
pub const FLASH_ECCR_CPUID_1: u32 = 134217728;
pub const FLASH_ECCR_CPUID_2: u32 = 268435456;
pub const FLASH_ECCR_ECCC_Pos: u32 = 30;
pub const FLASH_ECCR_ECCC_Msk: u32 = 1073741824;
pub const FLASH_ECCR_ECCC: u32 = 1073741824;
pub const FLASH_ECCR_ECCD_Pos: u32 = 31;
pub const FLASH_ECCR_ECCD_Msk: u32 = 2147483648;
pub const FLASH_ECCR_ECCD: u32 = 2147483648;
pub const FLASH_OPTR_RDP_Pos: u32 = 0;
pub const FLASH_OPTR_RDP_Msk: u32 = 255;
pub const FLASH_OPTR_RDP: u32 = 255;
pub const FLASH_OPTR_ESE_Pos: u32 = 8;
pub const FLASH_OPTR_ESE_Msk: u32 = 256;
pub const FLASH_OPTR_ESE: u32 = 256;
pub const FLASH_OPTR_BOR_LEV_Pos: u32 = 9;
pub const FLASH_OPTR_BOR_LEV_Msk: u32 = 3584;
pub const FLASH_OPTR_BOR_LEV: u32 = 3584;
pub const FLASH_OPTR_BOR_LEV_0: u32 = 512;
pub const FLASH_OPTR_BOR_LEV_1: u32 = 1024;
pub const FLASH_OPTR_BOR_LEV_2: u32 = 2048;
pub const FLASH_OPTR_nRST_STOP_Pos: u32 = 12;
pub const FLASH_OPTR_nRST_STOP_Msk: u32 = 4096;
pub const FLASH_OPTR_nRST_STOP: u32 = 4096;
pub const FLASH_OPTR_nRST_STDBY_Pos: u32 = 13;
pub const FLASH_OPTR_nRST_STDBY_Msk: u32 = 8192;
pub const FLASH_OPTR_nRST_STDBY: u32 = 8192;
pub const FLASH_OPTR_nRST_SHDW_Pos: u32 = 14;
pub const FLASH_OPTR_nRST_SHDW_Msk: u32 = 16384;
pub const FLASH_OPTR_nRST_SHDW: u32 = 16384;
pub const FLASH_OPTR_IWDG_SW_Pos: u32 = 16;
pub const FLASH_OPTR_IWDG_SW_Msk: u32 = 65536;
pub const FLASH_OPTR_IWDG_SW: u32 = 65536;
pub const FLASH_OPTR_IWDG_STOP_Pos: u32 = 17;
pub const FLASH_OPTR_IWDG_STOP_Msk: u32 = 131072;
pub const FLASH_OPTR_IWDG_STOP: u32 = 131072;
pub const FLASH_OPTR_IWDG_STDBY_Pos: u32 = 18;
pub const FLASH_OPTR_IWDG_STDBY_Msk: u32 = 262144;
pub const FLASH_OPTR_IWDG_STDBY: u32 = 262144;
pub const FLASH_OPTR_WWDG_SW_Pos: u32 = 19;
pub const FLASH_OPTR_WWDG_SW_Msk: u32 = 524288;
pub const FLASH_OPTR_WWDG_SW: u32 = 524288;
pub const FLASH_OPTR_nBOOT1_Pos: u32 = 23;
pub const FLASH_OPTR_nBOOT1_Msk: u32 = 8388608;
pub const FLASH_OPTR_nBOOT1: u32 = 8388608;
pub const FLASH_OPTR_SRAM2PE_Pos: u32 = 24;
pub const FLASH_OPTR_SRAM2PE_Msk: u32 = 16777216;
pub const FLASH_OPTR_SRAM2PE: u32 = 16777216;
pub const FLASH_OPTR_SRAM2RST_Pos: u32 = 25;
pub const FLASH_OPTR_SRAM2RST_Msk: u32 = 33554432;
pub const FLASH_OPTR_SRAM2RST: u32 = 33554432;
pub const FLASH_OPTR_nSWBOOT0_Pos: u32 = 26;
pub const FLASH_OPTR_nSWBOOT0_Msk: u32 = 67108864;
pub const FLASH_OPTR_nSWBOOT0: u32 = 67108864;
pub const FLASH_OPTR_nBOOT0_Pos: u32 = 27;
pub const FLASH_OPTR_nBOOT0_Msk: u32 = 134217728;
pub const FLASH_OPTR_nBOOT0: u32 = 134217728;
pub const FLASH_OPTR_AGC_TRIM_Pos: u32 = 29;
pub const FLASH_OPTR_AGC_TRIM_Msk: u32 = 3758096384;
pub const FLASH_OPTR_AGC_TRIM: u32 = 3758096384;
pub const FLASH_OPTR_AGC_TRIM_0: u32 = 536870912;
pub const FLASH_OPTR_AGC_TRIM_1: u32 = 1073741824;
pub const FLASH_OPTR_AGC_TRIM_2: u32 = 2147483648;
pub const FLASH_PCROP1ASR_PCROP1A_STRT_Pos: u32 = 0;
pub const FLASH_PCROP1ASR_PCROP1A_STRT_Msk: u32 = 511;
pub const FLASH_PCROP1ASR_PCROP1A_STRT: u32 = 511;
pub const FLASH_PCROP1AER_PCROP1A_END_Pos: u32 = 0;
pub const FLASH_PCROP1AER_PCROP1A_END_Msk: u32 = 511;
pub const FLASH_PCROP1AER_PCROP1A_END: u32 = 511;
pub const FLASH_PCROP1AER_PCROP_RDP_Pos: u32 = 31;
pub const FLASH_PCROP1AER_PCROP_RDP_Msk: u32 = 2147483648;
pub const FLASH_PCROP1AER_PCROP_RDP: u32 = 2147483648;
pub const FLASH_WRP1AR_WRP1A_STRT_Pos: u32 = 0;
pub const FLASH_WRP1AR_WRP1A_STRT_Msk: u32 = 255;
pub const FLASH_WRP1AR_WRP1A_STRT: u32 = 255;
pub const FLASH_WRP1AR_WRP1A_END_Pos: u32 = 16;
pub const FLASH_WRP1AR_WRP1A_END_Msk: u32 = 16711680;
pub const FLASH_WRP1AR_WRP1A_END: u32 = 16711680;
pub const FLASH_WRP1BR_WRP1B_STRT_Pos: u32 = 0;
pub const FLASH_WRP1BR_WRP1B_STRT_Msk: u32 = 255;
pub const FLASH_WRP1BR_WRP1B_STRT: u32 = 255;
pub const FLASH_WRP1BR_WRP1B_END_Pos: u32 = 16;
pub const FLASH_WRP1BR_WRP1B_END_Msk: u32 = 16711680;
pub const FLASH_WRP1BR_WRP1B_END: u32 = 16711680;
pub const FLASH_PCROP1BSR_PCROP1B_STRT_Pos: u32 = 0;
pub const FLASH_PCROP1BSR_PCROP1B_STRT_Msk: u32 = 511;
pub const FLASH_PCROP1BSR_PCROP1B_STRT: u32 = 511;
pub const FLASH_PCROP1BER_PCROP1B_END_Pos: u32 = 0;
pub const FLASH_PCROP1BER_PCROP1B_END_Msk: u32 = 511;
pub const FLASH_PCROP1BER_PCROP1B_END: u32 = 511;
pub const FLASH_IPCCBR_IPCCDBA_Pos: u32 = 0;
pub const FLASH_IPCCBR_IPCCDBA_Msk: u32 = 16383;
pub const FLASH_IPCCBR_IPCCDBA: u32 = 16383;
pub const FLASH_SFR_SFSA_Pos: u32 = 0;
pub const FLASH_SFR_SFSA_Msk: u32 = 255;
pub const FLASH_SFR_SFSA: u32 = 255;
pub const FLASH_SFR_FSD_Pos: u32 = 8;
pub const FLASH_SFR_FSD_Msk: u32 = 256;
pub const FLASH_SFR_FSD: u32 = 256;
pub const FLASH_SFR_DDS_Pos: u32 = 12;
pub const FLASH_SFR_DDS_Msk: u32 = 4096;
pub const FLASH_SFR_DDS: u32 = 4096;
pub const FLASH_SRRVR_SBRV_Pos: u32 = 0;
pub const FLASH_SRRVR_SBRV_Msk: u32 = 262143;
pub const FLASH_SRRVR_SBRV: u32 = 262143;
pub const FLASH_SRRVR_SBRSA_Pos: u32 = 18;
pub const FLASH_SRRVR_SBRSA_Msk: u32 = 8126464;
pub const FLASH_SRRVR_SBRSA: u32 = 8126464;
pub const FLASH_SRRVR_BRSD_Pos: u32 = 23;
pub const FLASH_SRRVR_BRSD_Msk: u32 = 8388608;
pub const FLASH_SRRVR_BRSD: u32 = 8388608;
pub const FLASH_SRRVR_SNBRSA_Pos: u32 = 25;
pub const FLASH_SRRVR_SNBRSA_Msk: u32 = 1040187392;
pub const FLASH_SRRVR_SNBRSA: u32 = 1040187392;
pub const FLASH_SRRVR_NBRSD_Pos: u32 = 30;
pub const FLASH_SRRVR_NBRSD_Msk: u32 = 1073741824;
pub const FLASH_SRRVR_NBRSD: u32 = 1073741824;
pub const FLASH_SRRVR_C2OPT_Pos: u32 = 31;
pub const FLASH_SRRVR_C2OPT_Msk: u32 = 2147483648;
pub const FLASH_SRRVR_C2OPT: u32 = 2147483648;
pub const FLASH_C2ACR_PRFTEN_Pos: u32 = 8;
pub const FLASH_C2ACR_PRFTEN_Msk: u32 = 256;
pub const FLASH_C2ACR_PRFTEN: u32 = 256;
pub const FLASH_C2ACR_ICEN_Pos: u32 = 9;
pub const FLASH_C2ACR_ICEN_Msk: u32 = 512;
pub const FLASH_C2ACR_ICEN: u32 = 512;
pub const FLASH_C2ACR_ICRST_Pos: u32 = 11;
pub const FLASH_C2ACR_ICRST_Msk: u32 = 2048;
pub const FLASH_C2ACR_ICRST: u32 = 2048;
pub const FLASH_C2ACR_PES_Pos: u32 = 15;
pub const FLASH_C2ACR_PES_Msk: u32 = 32768;
pub const FLASH_C2ACR_PES: u32 = 32768;
pub const FLASH_C2SR_EOP_Pos: u32 = 0;
pub const FLASH_C2SR_EOP_Msk: u32 = 1;
pub const FLASH_C2SR_EOP: u32 = 1;
pub const FLASH_C2SR_OPERR_Pos: u32 = 1;
pub const FLASH_C2SR_OPERR_Msk: u32 = 2;
pub const FLASH_C2SR_OPERR: u32 = 2;
pub const FLASH_C2SR_PROGERR_Pos: u32 = 3;
pub const FLASH_C2SR_PROGERR_Msk: u32 = 8;
pub const FLASH_C2SR_PROGERR: u32 = 8;
pub const FLASH_C2SR_WRPERR_Pos: u32 = 4;
pub const FLASH_C2SR_WRPERR_Msk: u32 = 16;
pub const FLASH_C2SR_WRPERR: u32 = 16;
pub const FLASH_C2SR_PGAERR_Pos: u32 = 5;
pub const FLASH_C2SR_PGAERR_Msk: u32 = 32;
pub const FLASH_C2SR_PGAERR: u32 = 32;
pub const FLASH_C2SR_SIZERR_Pos: u32 = 6;
pub const FLASH_C2SR_SIZERR_Msk: u32 = 64;
pub const FLASH_C2SR_SIZERR: u32 = 64;
pub const FLASH_C2SR_PGSERR_Pos: u32 = 7;
pub const FLASH_C2SR_PGSERR_Msk: u32 = 128;
pub const FLASH_C2SR_PGSERR: u32 = 128;
pub const FLASH_C2SR_MISERR_Pos: u32 = 8;
pub const FLASH_C2SR_MISERR_Msk: u32 = 256;
pub const FLASH_C2SR_MISERR: u32 = 256;
pub const FLASH_C2SR_FASTERR_Pos: u32 = 9;
pub const FLASH_C2SR_FASTERR_Msk: u32 = 512;
pub const FLASH_C2SR_FASTERR: u32 = 512;
pub const FLASH_C2SR_RDERR_Pos: u32 = 14;
pub const FLASH_C2SR_RDERR_Msk: u32 = 16384;
pub const FLASH_C2SR_RDERR: u32 = 16384;
pub const FLASH_C2SR_BSY_Pos: u32 = 16;
pub const FLASH_C2SR_BSY_Msk: u32 = 65536;
pub const FLASH_C2SR_BSY: u32 = 65536;
pub const FLASH_C2SR_CFGBSY_Pos: u32 = 18;
pub const FLASH_C2SR_CFGBSY_Msk: u32 = 262144;
pub const FLASH_C2SR_CFGBSY: u32 = 262144;
pub const FLASH_C2SR_PESD_Pos: u32 = 19;
pub const FLASH_C2SR_PESD_Msk: u32 = 524288;
pub const FLASH_C2SR_PESD: u32 = 524288;
pub const FLASH_C2CR_PG_Pos: u32 = 0;
pub const FLASH_C2CR_PG_Msk: u32 = 1;
pub const FLASH_C2CR_PG: u32 = 1;
pub const FLASH_C2CR_PER_Pos: u32 = 1;
pub const FLASH_C2CR_PER_Msk: u32 = 2;
pub const FLASH_C2CR_PER: u32 = 2;
pub const FLASH_C2CR_MER_Pos: u32 = 2;
pub const FLASH_C2CR_MER_Msk: u32 = 4;
pub const FLASH_C2CR_MER: u32 = 4;
pub const FLASH_C2CR_PNB_Pos: u32 = 3;
pub const FLASH_C2CR_PNB_Msk: u32 = 2040;
pub const FLASH_C2CR_PNB: u32 = 2040;
pub const FLASH_C2CR_STRT_Pos: u32 = 16;
pub const FLASH_C2CR_STRT_Msk: u32 = 65536;
pub const FLASH_C2CR_STRT: u32 = 65536;
pub const FLASH_C2CR_FSTPG_Pos: u32 = 18;
pub const FLASH_C2CR_FSTPG_Msk: u32 = 262144;
pub const FLASH_C2CR_FSTPG: u32 = 262144;
pub const FLASH_C2CR_EOPIE_Pos: u32 = 24;
pub const FLASH_C2CR_EOPIE_Msk: u32 = 16777216;
pub const FLASH_C2CR_EOPIE: u32 = 16777216;
pub const FLASH_C2CR_ERRIE_Pos: u32 = 25;
pub const FLASH_C2CR_ERRIE_Msk: u32 = 33554432;
pub const FLASH_C2CR_ERRIE: u32 = 33554432;
pub const FLASH_C2CR_RDERRIE_Pos: u32 = 26;
pub const FLASH_C2CR_RDERRIE_Msk: u32 = 67108864;
pub const FLASH_C2CR_RDERRIE: u32 = 67108864;
pub const GPIO_MODER_MODE0_Pos: u32 = 0;
pub const GPIO_MODER_MODE0_Msk: u32 = 3;
pub const GPIO_MODER_MODE0: u32 = 3;
pub const GPIO_MODER_MODE0_0: u32 = 1;
pub const GPIO_MODER_MODE0_1: u32 = 2;
pub const GPIO_MODER_MODE1_Pos: u32 = 2;
pub const GPIO_MODER_MODE1_Msk: u32 = 12;
pub const GPIO_MODER_MODE1: u32 = 12;
pub const GPIO_MODER_MODE1_0: u32 = 4;
pub const GPIO_MODER_MODE1_1: u32 = 8;
pub const GPIO_MODER_MODE2_Pos: u32 = 4;
pub const GPIO_MODER_MODE2_Msk: u32 = 48;
pub const GPIO_MODER_MODE2: u32 = 48;
pub const GPIO_MODER_MODE2_0: u32 = 16;
pub const GPIO_MODER_MODE2_1: u32 = 32;
pub const GPIO_MODER_MODE3_Pos: u32 = 6;
pub const GPIO_MODER_MODE3_Msk: u32 = 192;
pub const GPIO_MODER_MODE3: u32 = 192;
pub const GPIO_MODER_MODE3_0: u32 = 64;
pub const GPIO_MODER_MODE3_1: u32 = 128;
pub const GPIO_MODER_MODE4_Pos: u32 = 8;
pub const GPIO_MODER_MODE4_Msk: u32 = 768;
pub const GPIO_MODER_MODE4: u32 = 768;
pub const GPIO_MODER_MODE4_0: u32 = 256;
pub const GPIO_MODER_MODE4_1: u32 = 512;
pub const GPIO_MODER_MODE5_Pos: u32 = 10;
pub const GPIO_MODER_MODE5_Msk: u32 = 3072;
pub const GPIO_MODER_MODE5: u32 = 3072;
pub const GPIO_MODER_MODE5_0: u32 = 1024;
pub const GPIO_MODER_MODE5_1: u32 = 2048;
pub const GPIO_MODER_MODE6_Pos: u32 = 12;
pub const GPIO_MODER_MODE6_Msk: u32 = 12288;
pub const GPIO_MODER_MODE6: u32 = 12288;
pub const GPIO_MODER_MODE6_0: u32 = 4096;
pub const GPIO_MODER_MODE6_1: u32 = 8192;
pub const GPIO_MODER_MODE7_Pos: u32 = 14;
pub const GPIO_MODER_MODE7_Msk: u32 = 49152;
pub const GPIO_MODER_MODE7: u32 = 49152;
pub const GPIO_MODER_MODE7_0: u32 = 16384;
pub const GPIO_MODER_MODE7_1: u32 = 32768;
pub const GPIO_MODER_MODE8_Pos: u32 = 16;
pub const GPIO_MODER_MODE8_Msk: u32 = 196608;
pub const GPIO_MODER_MODE8: u32 = 196608;
pub const GPIO_MODER_MODE8_0: u32 = 65536;
pub const GPIO_MODER_MODE8_1: u32 = 131072;
pub const GPIO_MODER_MODE9_Pos: u32 = 18;
pub const GPIO_MODER_MODE9_Msk: u32 = 786432;
pub const GPIO_MODER_MODE9: u32 = 786432;
pub const GPIO_MODER_MODE9_0: u32 = 262144;
pub const GPIO_MODER_MODE9_1: u32 = 524288;
pub const GPIO_MODER_MODE10_Pos: u32 = 20;
pub const GPIO_MODER_MODE10_Msk: u32 = 3145728;
pub const GPIO_MODER_MODE10: u32 = 3145728;
pub const GPIO_MODER_MODE10_0: u32 = 1048576;
pub const GPIO_MODER_MODE10_1: u32 = 2097152;
pub const GPIO_MODER_MODE11_Pos: u32 = 22;
pub const GPIO_MODER_MODE11_Msk: u32 = 12582912;
pub const GPIO_MODER_MODE11: u32 = 12582912;
pub const GPIO_MODER_MODE11_0: u32 = 4194304;
pub const GPIO_MODER_MODE11_1: u32 = 8388608;
pub const GPIO_MODER_MODE12_Pos: u32 = 24;
pub const GPIO_MODER_MODE12_Msk: u32 = 50331648;
pub const GPIO_MODER_MODE12: u32 = 50331648;
pub const GPIO_MODER_MODE12_0: u32 = 16777216;
pub const GPIO_MODER_MODE12_1: u32 = 33554432;
pub const GPIO_MODER_MODE13_Pos: u32 = 26;
pub const GPIO_MODER_MODE13_Msk: u32 = 201326592;
pub const GPIO_MODER_MODE13: u32 = 201326592;
pub const GPIO_MODER_MODE13_0: u32 = 67108864;
pub const GPIO_MODER_MODE13_1: u32 = 134217728;
pub const GPIO_MODER_MODE14_Pos: u32 = 28;
pub const GPIO_MODER_MODE14_Msk: u32 = 805306368;
pub const GPIO_MODER_MODE14: u32 = 805306368;
pub const GPIO_MODER_MODE14_0: u32 = 268435456;
pub const GPIO_MODER_MODE14_1: u32 = 536870912;
pub const GPIO_MODER_MODE15_Pos: u32 = 30;
pub const GPIO_MODER_MODE15_Msk: u32 = 3221225472;
pub const GPIO_MODER_MODE15: u32 = 3221225472;
pub const GPIO_MODER_MODE15_0: u32 = 1073741824;
pub const GPIO_MODER_MODE15_1: u32 = 2147483648;
pub const GPIO_OTYPER_OT0_Pos: u32 = 0;
pub const GPIO_OTYPER_OT0_Msk: u32 = 1;
pub const GPIO_OTYPER_OT0: u32 = 1;
pub const GPIO_OTYPER_OT1_Pos: u32 = 1;
pub const GPIO_OTYPER_OT1_Msk: u32 = 2;
pub const GPIO_OTYPER_OT1: u32 = 2;
pub const GPIO_OTYPER_OT2_Pos: u32 = 2;
pub const GPIO_OTYPER_OT2_Msk: u32 = 4;
pub const GPIO_OTYPER_OT2: u32 = 4;
pub const GPIO_OTYPER_OT3_Pos: u32 = 3;
pub const GPIO_OTYPER_OT3_Msk: u32 = 8;
pub const GPIO_OTYPER_OT3: u32 = 8;
pub const GPIO_OTYPER_OT4_Pos: u32 = 4;
pub const GPIO_OTYPER_OT4_Msk: u32 = 16;
pub const GPIO_OTYPER_OT4: u32 = 16;
pub const GPIO_OTYPER_OT5_Pos: u32 = 5;
pub const GPIO_OTYPER_OT5_Msk: u32 = 32;
pub const GPIO_OTYPER_OT5: u32 = 32;
pub const GPIO_OTYPER_OT6_Pos: u32 = 6;
pub const GPIO_OTYPER_OT6_Msk: u32 = 64;
pub const GPIO_OTYPER_OT6: u32 = 64;
pub const GPIO_OTYPER_OT7_Pos: u32 = 7;
pub const GPIO_OTYPER_OT7_Msk: u32 = 128;
pub const GPIO_OTYPER_OT7: u32 = 128;
pub const GPIO_OTYPER_OT8_Pos: u32 = 8;
pub const GPIO_OTYPER_OT8_Msk: u32 = 256;
pub const GPIO_OTYPER_OT8: u32 = 256;
pub const GPIO_OTYPER_OT9_Pos: u32 = 9;
pub const GPIO_OTYPER_OT9_Msk: u32 = 512;
pub const GPIO_OTYPER_OT9: u32 = 512;
pub const GPIO_OTYPER_OT10_Pos: u32 = 10;
pub const GPIO_OTYPER_OT10_Msk: u32 = 1024;
pub const GPIO_OTYPER_OT10: u32 = 1024;
pub const GPIO_OTYPER_OT11_Pos: u32 = 11;
pub const GPIO_OTYPER_OT11_Msk: u32 = 2048;
pub const GPIO_OTYPER_OT11: u32 = 2048;
pub const GPIO_OTYPER_OT12_Pos: u32 = 12;
pub const GPIO_OTYPER_OT12_Msk: u32 = 4096;
pub const GPIO_OTYPER_OT12: u32 = 4096;
pub const GPIO_OTYPER_OT13_Pos: u32 = 13;
pub const GPIO_OTYPER_OT13_Msk: u32 = 8192;
pub const GPIO_OTYPER_OT13: u32 = 8192;
pub const GPIO_OTYPER_OT14_Pos: u32 = 14;
pub const GPIO_OTYPER_OT14_Msk: u32 = 16384;
pub const GPIO_OTYPER_OT14: u32 = 16384;
pub const GPIO_OTYPER_OT15_Pos: u32 = 15;
pub const GPIO_OTYPER_OT15_Msk: u32 = 32768;
pub const GPIO_OTYPER_OT15: u32 = 32768;
pub const GPIO_OSPEEDR_OSPEED0_Pos: u32 = 0;
pub const GPIO_OSPEEDR_OSPEED0_Msk: u32 = 3;
pub const GPIO_OSPEEDR_OSPEED0: u32 = 3;
pub const GPIO_OSPEEDR_OSPEED0_0: u32 = 1;
pub const GPIO_OSPEEDR_OSPEED0_1: u32 = 2;
pub const GPIO_OSPEEDR_OSPEED1_Pos: u32 = 2;
pub const GPIO_OSPEEDR_OSPEED1_Msk: u32 = 12;
pub const GPIO_OSPEEDR_OSPEED1: u32 = 12;
pub const GPIO_OSPEEDR_OSPEED1_0: u32 = 4;
pub const GPIO_OSPEEDR_OSPEED1_1: u32 = 8;
pub const GPIO_OSPEEDR_OSPEED2_Pos: u32 = 4;
pub const GPIO_OSPEEDR_OSPEED2_Msk: u32 = 48;
pub const GPIO_OSPEEDR_OSPEED2: u32 = 48;
pub const GPIO_OSPEEDR_OSPEED2_0: u32 = 16;
pub const GPIO_OSPEEDR_OSPEED2_1: u32 = 32;
pub const GPIO_OSPEEDR_OSPEED3_Pos: u32 = 6;
pub const GPIO_OSPEEDR_OSPEED3_Msk: u32 = 192;
pub const GPIO_OSPEEDR_OSPEED3: u32 = 192;
pub const GPIO_OSPEEDR_OSPEED3_0: u32 = 64;
pub const GPIO_OSPEEDR_OSPEED3_1: u32 = 128;
pub const GPIO_OSPEEDR_OSPEED4_Pos: u32 = 8;
pub const GPIO_OSPEEDR_OSPEED4_Msk: u32 = 768;
pub const GPIO_OSPEEDR_OSPEED4: u32 = 768;
pub const GPIO_OSPEEDR_OSPEED4_0: u32 = 256;
pub const GPIO_OSPEEDR_OSPEED4_1: u32 = 512;
pub const GPIO_OSPEEDR_OSPEED5_Pos: u32 = 10;
pub const GPIO_OSPEEDR_OSPEED5_Msk: u32 = 3072;
pub const GPIO_OSPEEDR_OSPEED5: u32 = 3072;
pub const GPIO_OSPEEDR_OSPEED5_0: u32 = 1024;
pub const GPIO_OSPEEDR_OSPEED5_1: u32 = 2048;
pub const GPIO_OSPEEDR_OSPEED6_Pos: u32 = 12;
pub const GPIO_OSPEEDR_OSPEED6_Msk: u32 = 12288;
pub const GPIO_OSPEEDR_OSPEED6: u32 = 12288;
pub const GPIO_OSPEEDR_OSPEED6_0: u32 = 4096;
pub const GPIO_OSPEEDR_OSPEED6_1: u32 = 8192;
pub const GPIO_OSPEEDR_OSPEED7_Pos: u32 = 14;
pub const GPIO_OSPEEDR_OSPEED7_Msk: u32 = 49152;
pub const GPIO_OSPEEDR_OSPEED7: u32 = 49152;
pub const GPIO_OSPEEDR_OSPEED7_0: u32 = 16384;
pub const GPIO_OSPEEDR_OSPEED7_1: u32 = 32768;
pub const GPIO_OSPEEDR_OSPEED8_Pos: u32 = 16;
pub const GPIO_OSPEEDR_OSPEED8_Msk: u32 = 196608;
pub const GPIO_OSPEEDR_OSPEED8: u32 = 196608;
pub const GPIO_OSPEEDR_OSPEED8_0: u32 = 65536;
pub const GPIO_OSPEEDR_OSPEED8_1: u32 = 131072;
pub const GPIO_OSPEEDR_OSPEED9_Pos: u32 = 18;
pub const GPIO_OSPEEDR_OSPEED9_Msk: u32 = 786432;
pub const GPIO_OSPEEDR_OSPEED9: u32 = 786432;
pub const GPIO_OSPEEDR_OSPEED9_0: u32 = 262144;
pub const GPIO_OSPEEDR_OSPEED9_1: u32 = 524288;
pub const GPIO_OSPEEDR_OSPEED10_Pos: u32 = 20;
pub const GPIO_OSPEEDR_OSPEED10_Msk: u32 = 3145728;
pub const GPIO_OSPEEDR_OSPEED10: u32 = 3145728;
pub const GPIO_OSPEEDR_OSPEED10_0: u32 = 1048576;
pub const GPIO_OSPEEDR_OSPEED10_1: u32 = 2097152;
pub const GPIO_OSPEEDR_OSPEED11_Pos: u32 = 22;
pub const GPIO_OSPEEDR_OSPEED11_Msk: u32 = 12582912;
pub const GPIO_OSPEEDR_OSPEED11: u32 = 12582912;
pub const GPIO_OSPEEDR_OSPEED11_0: u32 = 4194304;
pub const GPIO_OSPEEDR_OSPEED11_1: u32 = 8388608;
pub const GPIO_OSPEEDR_OSPEED12_Pos: u32 = 24;
pub const GPIO_OSPEEDR_OSPEED12_Msk: u32 = 50331648;
pub const GPIO_OSPEEDR_OSPEED12: u32 = 50331648;
pub const GPIO_OSPEEDR_OSPEED12_0: u32 = 16777216;
pub const GPIO_OSPEEDR_OSPEED12_1: u32 = 33554432;
pub const GPIO_OSPEEDR_OSPEED13_Pos: u32 = 26;
pub const GPIO_OSPEEDR_OSPEED13_Msk: u32 = 201326592;
pub const GPIO_OSPEEDR_OSPEED13: u32 = 201326592;
pub const GPIO_OSPEEDR_OSPEED13_0: u32 = 67108864;
pub const GPIO_OSPEEDR_OSPEED13_1: u32 = 134217728;
pub const GPIO_OSPEEDR_OSPEED14_Pos: u32 = 28;
pub const GPIO_OSPEEDR_OSPEED14_Msk: u32 = 805306368;
pub const GPIO_OSPEEDR_OSPEED14: u32 = 805306368;
pub const GPIO_OSPEEDR_OSPEED14_0: u32 = 268435456;
pub const GPIO_OSPEEDR_OSPEED14_1: u32 = 536870912;
pub const GPIO_OSPEEDR_OSPEED15_Pos: u32 = 30;
pub const GPIO_OSPEEDR_OSPEED15_Msk: u32 = 3221225472;
pub const GPIO_OSPEEDR_OSPEED15: u32 = 3221225472;
pub const GPIO_OSPEEDR_OSPEED15_0: u32 = 1073741824;
pub const GPIO_OSPEEDR_OSPEED15_1: u32 = 2147483648;
pub const GPIO_PUPDR_PUPD0_Pos: u32 = 0;
pub const GPIO_PUPDR_PUPD0_Msk: u32 = 3;
pub const GPIO_PUPDR_PUPD0: u32 = 3;
pub const GPIO_PUPDR_PUPD0_0: u32 = 1;
pub const GPIO_PUPDR_PUPD0_1: u32 = 2;
pub const GPIO_PUPDR_PUPD1_Pos: u32 = 2;
pub const GPIO_PUPDR_PUPD1_Msk: u32 = 12;
pub const GPIO_PUPDR_PUPD1: u32 = 12;
pub const GPIO_PUPDR_PUPD1_0: u32 = 4;
pub const GPIO_PUPDR_PUPD1_1: u32 = 8;
pub const GPIO_PUPDR_PUPD2_Pos: u32 = 4;
pub const GPIO_PUPDR_PUPD2_Msk: u32 = 48;
pub const GPIO_PUPDR_PUPD2: u32 = 48;
pub const GPIO_PUPDR_PUPD2_0: u32 = 16;
pub const GPIO_PUPDR_PUPD2_1: u32 = 32;
pub const GPIO_PUPDR_PUPD3_Pos: u32 = 6;
pub const GPIO_PUPDR_PUPD3_Msk: u32 = 192;
pub const GPIO_PUPDR_PUPD3: u32 = 192;
pub const GPIO_PUPDR_PUPD3_0: u32 = 64;
pub const GPIO_PUPDR_PUPD3_1: u32 = 128;
pub const GPIO_PUPDR_PUPD4_Pos: u32 = 8;
pub const GPIO_PUPDR_PUPD4_Msk: u32 = 768;
pub const GPIO_PUPDR_PUPD4: u32 = 768;
pub const GPIO_PUPDR_PUPD4_0: u32 = 256;
pub const GPIO_PUPDR_PUPD4_1: u32 = 512;
pub const GPIO_PUPDR_PUPD5_Pos: u32 = 10;
pub const GPIO_PUPDR_PUPD5_Msk: u32 = 3072;
pub const GPIO_PUPDR_PUPD5: u32 = 3072;
pub const GPIO_PUPDR_PUPD5_0: u32 = 1024;
pub const GPIO_PUPDR_PUPD5_1: u32 = 2048;
pub const GPIO_PUPDR_PUPD6_Pos: u32 = 12;
pub const GPIO_PUPDR_PUPD6_Msk: u32 = 12288;
pub const GPIO_PUPDR_PUPD6: u32 = 12288;
pub const GPIO_PUPDR_PUPD6_0: u32 = 4096;
pub const GPIO_PUPDR_PUPD6_1: u32 = 8192;
pub const GPIO_PUPDR_PUPD7_Pos: u32 = 14;
pub const GPIO_PUPDR_PUPD7_Msk: u32 = 49152;
pub const GPIO_PUPDR_PUPD7: u32 = 49152;
pub const GPIO_PUPDR_PUPD7_0: u32 = 16384;
pub const GPIO_PUPDR_PUPD7_1: u32 = 32768;
pub const GPIO_PUPDR_PUPD8_Pos: u32 = 16;
pub const GPIO_PUPDR_PUPD8_Msk: u32 = 196608;
pub const GPIO_PUPDR_PUPD8: u32 = 196608;
pub const GPIO_PUPDR_PUPD8_0: u32 = 65536;
pub const GPIO_PUPDR_PUPD8_1: u32 = 131072;
pub const GPIO_PUPDR_PUPD9_Pos: u32 = 18;
pub const GPIO_PUPDR_PUPD9_Msk: u32 = 786432;
pub const GPIO_PUPDR_PUPD9: u32 = 786432;
pub const GPIO_PUPDR_PUPD9_0: u32 = 262144;
pub const GPIO_PUPDR_PUPD9_1: u32 = 524288;
pub const GPIO_PUPDR_PUPD10_Pos: u32 = 20;
pub const GPIO_PUPDR_PUPD10_Msk: u32 = 3145728;
pub const GPIO_PUPDR_PUPD10: u32 = 3145728;
pub const GPIO_PUPDR_PUPD10_0: u32 = 1048576;
pub const GPIO_PUPDR_PUPD10_1: u32 = 2097152;
pub const GPIO_PUPDR_PUPD11_Pos: u32 = 22;
pub const GPIO_PUPDR_PUPD11_Msk: u32 = 12582912;
pub const GPIO_PUPDR_PUPD11: u32 = 12582912;
pub const GPIO_PUPDR_PUPD11_0: u32 = 4194304;
pub const GPIO_PUPDR_PUPD11_1: u32 = 8388608;
pub const GPIO_PUPDR_PUPD12_Pos: u32 = 24;
pub const GPIO_PUPDR_PUPD12_Msk: u32 = 50331648;
pub const GPIO_PUPDR_PUPD12: u32 = 50331648;
pub const GPIO_PUPDR_PUPD12_0: u32 = 16777216;
pub const GPIO_PUPDR_PUPD12_1: u32 = 33554432;
pub const GPIO_PUPDR_PUPD13_Pos: u32 = 26;
pub const GPIO_PUPDR_PUPD13_Msk: u32 = 201326592;
pub const GPIO_PUPDR_PUPD13: u32 = 201326592;
pub const GPIO_PUPDR_PUPD13_0: u32 = 67108864;
pub const GPIO_PUPDR_PUPD13_1: u32 = 134217728;
pub const GPIO_PUPDR_PUPD14_Pos: u32 = 28;
pub const GPIO_PUPDR_PUPD14_Msk: u32 = 805306368;
pub const GPIO_PUPDR_PUPD14: u32 = 805306368;
pub const GPIO_PUPDR_PUPD14_0: u32 = 268435456;
pub const GPIO_PUPDR_PUPD14_1: u32 = 536870912;
pub const GPIO_PUPDR_PUPD15_Pos: u32 = 30;
pub const GPIO_PUPDR_PUPD15_Msk: u32 = 3221225472;
pub const GPIO_PUPDR_PUPD15: u32 = 3221225472;
pub const GPIO_PUPDR_PUPD15_0: u32 = 1073741824;
pub const GPIO_PUPDR_PUPD15_1: u32 = 2147483648;
pub const GPIO_IDR_ID0_Pos: u32 = 0;
pub const GPIO_IDR_ID0_Msk: u32 = 1;
pub const GPIO_IDR_ID0: u32 = 1;
pub const GPIO_IDR_ID1_Pos: u32 = 1;
pub const GPIO_IDR_ID1_Msk: u32 = 2;
pub const GPIO_IDR_ID1: u32 = 2;
pub const GPIO_IDR_ID2_Pos: u32 = 2;
pub const GPIO_IDR_ID2_Msk: u32 = 4;
pub const GPIO_IDR_ID2: u32 = 4;
pub const GPIO_IDR_ID3_Pos: u32 = 3;
pub const GPIO_IDR_ID3_Msk: u32 = 8;
pub const GPIO_IDR_ID3: u32 = 8;
pub const GPIO_IDR_ID4_Pos: u32 = 4;
pub const GPIO_IDR_ID4_Msk: u32 = 16;
pub const GPIO_IDR_ID4: u32 = 16;
pub const GPIO_IDR_ID5_Pos: u32 = 5;
pub const GPIO_IDR_ID5_Msk: u32 = 32;
pub const GPIO_IDR_ID5: u32 = 32;
pub const GPIO_IDR_ID6_Pos: u32 = 6;
pub const GPIO_IDR_ID6_Msk: u32 = 64;
pub const GPIO_IDR_ID6: u32 = 64;
pub const GPIO_IDR_ID7_Pos: u32 = 7;
pub const GPIO_IDR_ID7_Msk: u32 = 128;
pub const GPIO_IDR_ID7: u32 = 128;
pub const GPIO_IDR_ID8_Pos: u32 = 8;
pub const GPIO_IDR_ID8_Msk: u32 = 256;
pub const GPIO_IDR_ID8: u32 = 256;
pub const GPIO_IDR_ID9_Pos: u32 = 9;
pub const GPIO_IDR_ID9_Msk: u32 = 512;
pub const GPIO_IDR_ID9: u32 = 512;
pub const GPIO_IDR_ID10_Pos: u32 = 10;
pub const GPIO_IDR_ID10_Msk: u32 = 1024;
pub const GPIO_IDR_ID10: u32 = 1024;
pub const GPIO_IDR_ID11_Pos: u32 = 11;
pub const GPIO_IDR_ID11_Msk: u32 = 2048;
pub const GPIO_IDR_ID11: u32 = 2048;
pub const GPIO_IDR_ID12_Pos: u32 = 12;
pub const GPIO_IDR_ID12_Msk: u32 = 4096;
pub const GPIO_IDR_ID12: u32 = 4096;
pub const GPIO_IDR_ID13_Pos: u32 = 13;
pub const GPIO_IDR_ID13_Msk: u32 = 8192;
pub const GPIO_IDR_ID13: u32 = 8192;
pub const GPIO_IDR_ID14_Pos: u32 = 14;
pub const GPIO_IDR_ID14_Msk: u32 = 16384;
pub const GPIO_IDR_ID14: u32 = 16384;
pub const GPIO_IDR_ID15_Pos: u32 = 15;
pub const GPIO_IDR_ID15_Msk: u32 = 32768;
pub const GPIO_IDR_ID15: u32 = 32768;
pub const GPIO_ODR_OD0_Pos: u32 = 0;
pub const GPIO_ODR_OD0_Msk: u32 = 1;
pub const GPIO_ODR_OD0: u32 = 1;
pub const GPIO_ODR_OD1_Pos: u32 = 1;
pub const GPIO_ODR_OD1_Msk: u32 = 2;
pub const GPIO_ODR_OD1: u32 = 2;
pub const GPIO_ODR_OD2_Pos: u32 = 2;
pub const GPIO_ODR_OD2_Msk: u32 = 4;
pub const GPIO_ODR_OD2: u32 = 4;
pub const GPIO_ODR_OD3_Pos: u32 = 3;
pub const GPIO_ODR_OD3_Msk: u32 = 8;
pub const GPIO_ODR_OD3: u32 = 8;
pub const GPIO_ODR_OD4_Pos: u32 = 4;
pub const GPIO_ODR_OD4_Msk: u32 = 16;
pub const GPIO_ODR_OD4: u32 = 16;
pub const GPIO_ODR_OD5_Pos: u32 = 5;
pub const GPIO_ODR_OD5_Msk: u32 = 32;
pub const GPIO_ODR_OD5: u32 = 32;
pub const GPIO_ODR_OD6_Pos: u32 = 6;
pub const GPIO_ODR_OD6_Msk: u32 = 64;
pub const GPIO_ODR_OD6: u32 = 64;
pub const GPIO_ODR_OD7_Pos: u32 = 7;
pub const GPIO_ODR_OD7_Msk: u32 = 128;
pub const GPIO_ODR_OD7: u32 = 128;
pub const GPIO_ODR_OD8_Pos: u32 = 8;
pub const GPIO_ODR_OD8_Msk: u32 = 256;
pub const GPIO_ODR_OD8: u32 = 256;
pub const GPIO_ODR_OD9_Pos: u32 = 9;
pub const GPIO_ODR_OD9_Msk: u32 = 512;
pub const GPIO_ODR_OD9: u32 = 512;
pub const GPIO_ODR_OD10_Pos: u32 = 10;
pub const GPIO_ODR_OD10_Msk: u32 = 1024;
pub const GPIO_ODR_OD10: u32 = 1024;
pub const GPIO_ODR_OD11_Pos: u32 = 11;
pub const GPIO_ODR_OD11_Msk: u32 = 2048;
pub const GPIO_ODR_OD11: u32 = 2048;
pub const GPIO_ODR_OD12_Pos: u32 = 12;
pub const GPIO_ODR_OD12_Msk: u32 = 4096;
pub const GPIO_ODR_OD12: u32 = 4096;
pub const GPIO_ODR_OD13_Pos: u32 = 13;
pub const GPIO_ODR_OD13_Msk: u32 = 8192;
pub const GPIO_ODR_OD13: u32 = 8192;
pub const GPIO_ODR_OD14_Pos: u32 = 14;
pub const GPIO_ODR_OD14_Msk: u32 = 16384;
pub const GPIO_ODR_OD14: u32 = 16384;
pub const GPIO_ODR_OD15_Pos: u32 = 15;
pub const GPIO_ODR_OD15_Msk: u32 = 32768;
pub const GPIO_ODR_OD15: u32 = 32768;
pub const GPIO_BSRR_BS0_Pos: u32 = 0;
pub const GPIO_BSRR_BS0_Msk: u32 = 1;
pub const GPIO_BSRR_BS0: u32 = 1;
pub const GPIO_BSRR_BS1_Pos: u32 = 1;
pub const GPIO_BSRR_BS1_Msk: u32 = 2;
pub const GPIO_BSRR_BS1: u32 = 2;
pub const GPIO_BSRR_BS2_Pos: u32 = 2;
pub const GPIO_BSRR_BS2_Msk: u32 = 4;
pub const GPIO_BSRR_BS2: u32 = 4;
pub const GPIO_BSRR_BS3_Pos: u32 = 3;
pub const GPIO_BSRR_BS3_Msk: u32 = 8;
pub const GPIO_BSRR_BS3: u32 = 8;
pub const GPIO_BSRR_BS4_Pos: u32 = 4;
pub const GPIO_BSRR_BS4_Msk: u32 = 16;
pub const GPIO_BSRR_BS4: u32 = 16;
pub const GPIO_BSRR_BS5_Pos: u32 = 5;
pub const GPIO_BSRR_BS5_Msk: u32 = 32;
pub const GPIO_BSRR_BS5: u32 = 32;
pub const GPIO_BSRR_BS6_Pos: u32 = 6;
pub const GPIO_BSRR_BS6_Msk: u32 = 64;
pub const GPIO_BSRR_BS6: u32 = 64;
pub const GPIO_BSRR_BS7_Pos: u32 = 7;
pub const GPIO_BSRR_BS7_Msk: u32 = 128;
pub const GPIO_BSRR_BS7: u32 = 128;
pub const GPIO_BSRR_BS8_Pos: u32 = 8;
pub const GPIO_BSRR_BS8_Msk: u32 = 256;
pub const GPIO_BSRR_BS8: u32 = 256;
pub const GPIO_BSRR_BS9_Pos: u32 = 9;
pub const GPIO_BSRR_BS9_Msk: u32 = 512;
pub const GPIO_BSRR_BS9: u32 = 512;
pub const GPIO_BSRR_BS10_Pos: u32 = 10;
pub const GPIO_BSRR_BS10_Msk: u32 = 1024;
pub const GPIO_BSRR_BS10: u32 = 1024;
pub const GPIO_BSRR_BS11_Pos: u32 = 11;
pub const GPIO_BSRR_BS11_Msk: u32 = 2048;
pub const GPIO_BSRR_BS11: u32 = 2048;
pub const GPIO_BSRR_BS12_Pos: u32 = 12;
pub const GPIO_BSRR_BS12_Msk: u32 = 4096;
pub const GPIO_BSRR_BS12: u32 = 4096;
pub const GPIO_BSRR_BS13_Pos: u32 = 13;
pub const GPIO_BSRR_BS13_Msk: u32 = 8192;
pub const GPIO_BSRR_BS13: u32 = 8192;
pub const GPIO_BSRR_BS14_Pos: u32 = 14;
pub const GPIO_BSRR_BS14_Msk: u32 = 16384;
pub const GPIO_BSRR_BS14: u32 = 16384;
pub const GPIO_BSRR_BS15_Pos: u32 = 15;
pub const GPIO_BSRR_BS15_Msk: u32 = 32768;
pub const GPIO_BSRR_BS15: u32 = 32768;
pub const GPIO_BSRR_BR0_Pos: u32 = 16;
pub const GPIO_BSRR_BR0_Msk: u32 = 65536;
pub const GPIO_BSRR_BR0: u32 = 65536;
pub const GPIO_BSRR_BR1_Pos: u32 = 17;
pub const GPIO_BSRR_BR1_Msk: u32 = 131072;
pub const GPIO_BSRR_BR1: u32 = 131072;
pub const GPIO_BSRR_BR2_Pos: u32 = 18;
pub const GPIO_BSRR_BR2_Msk: u32 = 262144;
pub const GPIO_BSRR_BR2: u32 = 262144;
pub const GPIO_BSRR_BR3_Pos: u32 = 19;
pub const GPIO_BSRR_BR3_Msk: u32 = 524288;
pub const GPIO_BSRR_BR3: u32 = 524288;
pub const GPIO_BSRR_BR4_Pos: u32 = 20;
pub const GPIO_BSRR_BR4_Msk: u32 = 1048576;
pub const GPIO_BSRR_BR4: u32 = 1048576;
pub const GPIO_BSRR_BR5_Pos: u32 = 21;
pub const GPIO_BSRR_BR5_Msk: u32 = 2097152;
pub const GPIO_BSRR_BR5: u32 = 2097152;
pub const GPIO_BSRR_BR6_Pos: u32 = 22;
pub const GPIO_BSRR_BR6_Msk: u32 = 4194304;
pub const GPIO_BSRR_BR6: u32 = 4194304;
pub const GPIO_BSRR_BR7_Pos: u32 = 23;
pub const GPIO_BSRR_BR7_Msk: u32 = 8388608;
pub const GPIO_BSRR_BR7: u32 = 8388608;
pub const GPIO_BSRR_BR8_Pos: u32 = 24;
pub const GPIO_BSRR_BR8_Msk: u32 = 16777216;
pub const GPIO_BSRR_BR8: u32 = 16777216;
pub const GPIO_BSRR_BR9_Pos: u32 = 25;
pub const GPIO_BSRR_BR9_Msk: u32 = 33554432;
pub const GPIO_BSRR_BR9: u32 = 33554432;
pub const GPIO_BSRR_BR10_Pos: u32 = 26;
pub const GPIO_BSRR_BR10_Msk: u32 = 67108864;
pub const GPIO_BSRR_BR10: u32 = 67108864;
pub const GPIO_BSRR_BR11_Pos: u32 = 27;
pub const GPIO_BSRR_BR11_Msk: u32 = 134217728;
pub const GPIO_BSRR_BR11: u32 = 134217728;
pub const GPIO_BSRR_BR12_Pos: u32 = 28;
pub const GPIO_BSRR_BR12_Msk: u32 = 268435456;
pub const GPIO_BSRR_BR12: u32 = 268435456;
pub const GPIO_BSRR_BR13_Pos: u32 = 29;
pub const GPIO_BSRR_BR13_Msk: u32 = 536870912;
pub const GPIO_BSRR_BR13: u32 = 536870912;
pub const GPIO_BSRR_BR14_Pos: u32 = 30;
pub const GPIO_BSRR_BR14_Msk: u32 = 1073741824;
pub const GPIO_BSRR_BR14: u32 = 1073741824;
pub const GPIO_BSRR_BR15_Pos: u32 = 31;
pub const GPIO_BSRR_BR15_Msk: u32 = 2147483648;
pub const GPIO_BSRR_BR15: u32 = 2147483648;
pub const GPIO_LCKR_LCK0_Pos: u32 = 0;
pub const GPIO_LCKR_LCK0_Msk: u32 = 1;
pub const GPIO_LCKR_LCK0: u32 = 1;
pub const GPIO_LCKR_LCK1_Pos: u32 = 1;
pub const GPIO_LCKR_LCK1_Msk: u32 = 2;
pub const GPIO_LCKR_LCK1: u32 = 2;
pub const GPIO_LCKR_LCK2_Pos: u32 = 2;
pub const GPIO_LCKR_LCK2_Msk: u32 = 4;
pub const GPIO_LCKR_LCK2: u32 = 4;
pub const GPIO_LCKR_LCK3_Pos: u32 = 3;
pub const GPIO_LCKR_LCK3_Msk: u32 = 8;
pub const GPIO_LCKR_LCK3: u32 = 8;
pub const GPIO_LCKR_LCK4_Pos: u32 = 4;
pub const GPIO_LCKR_LCK4_Msk: u32 = 16;
pub const GPIO_LCKR_LCK4: u32 = 16;
pub const GPIO_LCKR_LCK5_Pos: u32 = 5;
pub const GPIO_LCKR_LCK5_Msk: u32 = 32;
pub const GPIO_LCKR_LCK5: u32 = 32;
pub const GPIO_LCKR_LCK6_Pos: u32 = 6;
pub const GPIO_LCKR_LCK6_Msk: u32 = 64;
pub const GPIO_LCKR_LCK6: u32 = 64;
pub const GPIO_LCKR_LCK7_Pos: u32 = 7;
pub const GPIO_LCKR_LCK7_Msk: u32 = 128;
pub const GPIO_LCKR_LCK7: u32 = 128;
pub const GPIO_LCKR_LCK8_Pos: u32 = 8;
pub const GPIO_LCKR_LCK8_Msk: u32 = 256;
pub const GPIO_LCKR_LCK8: u32 = 256;
pub const GPIO_LCKR_LCK9_Pos: u32 = 9;
pub const GPIO_LCKR_LCK9_Msk: u32 = 512;
pub const GPIO_LCKR_LCK9: u32 = 512;
pub const GPIO_LCKR_LCK10_Pos: u32 = 10;
pub const GPIO_LCKR_LCK10_Msk: u32 = 1024;
pub const GPIO_LCKR_LCK10: u32 = 1024;
pub const GPIO_LCKR_LCK11_Pos: u32 = 11;
pub const GPIO_LCKR_LCK11_Msk: u32 = 2048;
pub const GPIO_LCKR_LCK11: u32 = 2048;
pub const GPIO_LCKR_LCK12_Pos: u32 = 12;
pub const GPIO_LCKR_LCK12_Msk: u32 = 4096;
pub const GPIO_LCKR_LCK12: u32 = 4096;
pub const GPIO_LCKR_LCK13_Pos: u32 = 13;
pub const GPIO_LCKR_LCK13_Msk: u32 = 8192;
pub const GPIO_LCKR_LCK13: u32 = 8192;
pub const GPIO_LCKR_LCK14_Pos: u32 = 14;
pub const GPIO_LCKR_LCK14_Msk: u32 = 16384;
pub const GPIO_LCKR_LCK14: u32 = 16384;
pub const GPIO_LCKR_LCK15_Pos: u32 = 15;
pub const GPIO_LCKR_LCK15_Msk: u32 = 32768;
pub const GPIO_LCKR_LCK15: u32 = 32768;
pub const GPIO_LCKR_LCKK_Pos: u32 = 16;
pub const GPIO_LCKR_LCKK_Msk: u32 = 65536;
pub const GPIO_LCKR_LCKK: u32 = 65536;
pub const GPIO_AFRL_AFSEL0_Pos: u32 = 0;
pub const GPIO_AFRL_AFSEL0_Msk: u32 = 15;
pub const GPIO_AFRL_AFSEL0: u32 = 15;
pub const GPIO_AFRL_AFSEL0_0: u32 = 1;
pub const GPIO_AFRL_AFSEL0_1: u32 = 2;
pub const GPIO_AFRL_AFSEL0_2: u32 = 4;
pub const GPIO_AFRL_AFSEL0_3: u32 = 8;
pub const GPIO_AFRL_AFSEL1_Pos: u32 = 4;
pub const GPIO_AFRL_AFSEL1_Msk: u32 = 240;
pub const GPIO_AFRL_AFSEL1: u32 = 240;
pub const GPIO_AFRL_AFSEL1_0: u32 = 16;
pub const GPIO_AFRL_AFSEL1_1: u32 = 32;
pub const GPIO_AFRL_AFSEL1_2: u32 = 64;
pub const GPIO_AFRL_AFSEL1_3: u32 = 128;
pub const GPIO_AFRL_AFSEL2_Pos: u32 = 8;
pub const GPIO_AFRL_AFSEL2_Msk: u32 = 3840;
pub const GPIO_AFRL_AFSEL2: u32 = 3840;
pub const GPIO_AFRL_AFSEL2_0: u32 = 256;
pub const GPIO_AFRL_AFSEL2_1: u32 = 512;
pub const GPIO_AFRL_AFSEL2_2: u32 = 1024;
pub const GPIO_AFRL_AFSEL2_3: u32 = 2048;
pub const GPIO_AFRL_AFSEL3_Pos: u32 = 12;
pub const GPIO_AFRL_AFSEL3_Msk: u32 = 61440;
pub const GPIO_AFRL_AFSEL3: u32 = 61440;
pub const GPIO_AFRL_AFSEL3_0: u32 = 4096;
pub const GPIO_AFRL_AFSEL3_1: u32 = 8192;
pub const GPIO_AFRL_AFSEL3_2: u32 = 16384;
pub const GPIO_AFRL_AFSEL3_3: u32 = 32768;
pub const GPIO_AFRL_AFSEL4_Pos: u32 = 16;
pub const GPIO_AFRL_AFSEL4_Msk: u32 = 983040;
pub const GPIO_AFRL_AFSEL4: u32 = 983040;
pub const GPIO_AFRL_AFSEL4_0: u32 = 65536;
pub const GPIO_AFRL_AFSEL4_1: u32 = 131072;
pub const GPIO_AFRL_AFSEL4_2: u32 = 262144;
pub const GPIO_AFRL_AFSEL4_3: u32 = 524288;
pub const GPIO_AFRL_AFSEL5_Pos: u32 = 20;
pub const GPIO_AFRL_AFSEL5_Msk: u32 = 15728640;
pub const GPIO_AFRL_AFSEL5: u32 = 15728640;
pub const GPIO_AFRL_AFSEL5_0: u32 = 1048576;
pub const GPIO_AFRL_AFSEL5_1: u32 = 2097152;
pub const GPIO_AFRL_AFSEL5_2: u32 = 4194304;
pub const GPIO_AFRL_AFSEL5_3: u32 = 8388608;
pub const GPIO_AFRL_AFSEL6_Pos: u32 = 24;
pub const GPIO_AFRL_AFSEL6_Msk: u32 = 251658240;
pub const GPIO_AFRL_AFSEL6: u32 = 251658240;
pub const GPIO_AFRL_AFSEL6_0: u32 = 16777216;
pub const GPIO_AFRL_AFSEL6_1: u32 = 33554432;
pub const GPIO_AFRL_AFSEL6_2: u32 = 67108864;
pub const GPIO_AFRL_AFSEL6_3: u32 = 134217728;
pub const GPIO_AFRL_AFSEL7_Pos: u32 = 28;
pub const GPIO_AFRL_AFSEL7_Msk: u32 = 4026531840;
pub const GPIO_AFRL_AFSEL7: u32 = 4026531840;
pub const GPIO_AFRL_AFSEL7_0: u32 = 268435456;
pub const GPIO_AFRL_AFSEL7_1: u32 = 536870912;
pub const GPIO_AFRL_AFSEL7_2: u32 = 1073741824;
pub const GPIO_AFRL_AFSEL7_3: u32 = 2147483648;
pub const GPIO_AFRH_AFSEL8_Pos: u32 = 0;
pub const GPIO_AFRH_AFSEL8_Msk: u32 = 15;
pub const GPIO_AFRH_AFSEL8: u32 = 15;
pub const GPIO_AFRH_AFSEL8_0: u32 = 1;
pub const GPIO_AFRH_AFSEL8_1: u32 = 2;
pub const GPIO_AFRH_AFSEL8_2: u32 = 4;
pub const GPIO_AFRH_AFSEL8_3: u32 = 8;
pub const GPIO_AFRH_AFSEL9_Pos: u32 = 4;
pub const GPIO_AFRH_AFSEL9_Msk: u32 = 240;
pub const GPIO_AFRH_AFSEL9: u32 = 240;
pub const GPIO_AFRH_AFSEL9_0: u32 = 16;
pub const GPIO_AFRH_AFSEL9_1: u32 = 32;
pub const GPIO_AFRH_AFSEL9_2: u32 = 64;
pub const GPIO_AFRH_AFSEL9_3: u32 = 128;
pub const GPIO_AFRH_AFSEL10_Pos: u32 = 8;
pub const GPIO_AFRH_AFSEL10_Msk: u32 = 3840;
pub const GPIO_AFRH_AFSEL10: u32 = 3840;
pub const GPIO_AFRH_AFSEL10_0: u32 = 256;
pub const GPIO_AFRH_AFSEL10_1: u32 = 512;
pub const GPIO_AFRH_AFSEL10_2: u32 = 1024;
pub const GPIO_AFRH_AFSEL10_3: u32 = 2048;
pub const GPIO_AFRH_AFSEL11_Pos: u32 = 12;
pub const GPIO_AFRH_AFSEL11_Msk: u32 = 61440;
pub const GPIO_AFRH_AFSEL11: u32 = 61440;
pub const GPIO_AFRH_AFSEL11_0: u32 = 4096;
pub const GPIO_AFRH_AFSEL11_1: u32 = 8192;
pub const GPIO_AFRH_AFSEL11_2: u32 = 16384;
pub const GPIO_AFRH_AFSEL11_3: u32 = 32768;
pub const GPIO_AFRH_AFSEL12_Pos: u32 = 16;
pub const GPIO_AFRH_AFSEL12_Msk: u32 = 983040;
pub const GPIO_AFRH_AFSEL12: u32 = 983040;
pub const GPIO_AFRH_AFSEL12_0: u32 = 65536;
pub const GPIO_AFRH_AFSEL12_1: u32 = 131072;
pub const GPIO_AFRH_AFSEL12_2: u32 = 262144;
pub const GPIO_AFRH_AFSEL12_3: u32 = 524288;
pub const GPIO_AFRH_AFSEL13_Pos: u32 = 20;
pub const GPIO_AFRH_AFSEL13_Msk: u32 = 15728640;
pub const GPIO_AFRH_AFSEL13: u32 = 15728640;
pub const GPIO_AFRH_AFSEL13_0: u32 = 1048576;
pub const GPIO_AFRH_AFSEL13_1: u32 = 2097152;
pub const GPIO_AFRH_AFSEL13_2: u32 = 4194304;
pub const GPIO_AFRH_AFSEL13_3: u32 = 8388608;
pub const GPIO_AFRH_AFSEL14_Pos: u32 = 24;
pub const GPIO_AFRH_AFSEL14_Msk: u32 = 251658240;
pub const GPIO_AFRH_AFSEL14: u32 = 251658240;
pub const GPIO_AFRH_AFSEL14_0: u32 = 16777216;
pub const GPIO_AFRH_AFSEL14_1: u32 = 33554432;
pub const GPIO_AFRH_AFSEL14_2: u32 = 67108864;
pub const GPIO_AFRH_AFSEL14_3: u32 = 134217728;
pub const GPIO_AFRH_AFSEL15_Pos: u32 = 28;
pub const GPIO_AFRH_AFSEL15_Msk: u32 = 4026531840;
pub const GPIO_AFRH_AFSEL15: u32 = 4026531840;
pub const GPIO_AFRH_AFSEL15_0: u32 = 268435456;
pub const GPIO_AFRH_AFSEL15_1: u32 = 536870912;
pub const GPIO_AFRH_AFSEL15_2: u32 = 1073741824;
pub const GPIO_AFRH_AFSEL15_3: u32 = 2147483648;
pub const GPIO_BRR_BR0_Pos: u32 = 0;
pub const GPIO_BRR_BR0_Msk: u32 = 1;
pub const GPIO_BRR_BR0: u32 = 1;
pub const GPIO_BRR_BR1_Pos: u32 = 1;
pub const GPIO_BRR_BR1_Msk: u32 = 2;
pub const GPIO_BRR_BR1: u32 = 2;
pub const GPIO_BRR_BR2_Pos: u32 = 2;
pub const GPIO_BRR_BR2_Msk: u32 = 4;
pub const GPIO_BRR_BR2: u32 = 4;
pub const GPIO_BRR_BR3_Pos: u32 = 3;
pub const GPIO_BRR_BR3_Msk: u32 = 8;
pub const GPIO_BRR_BR3: u32 = 8;
pub const GPIO_BRR_BR4_Pos: u32 = 4;
pub const GPIO_BRR_BR4_Msk: u32 = 16;
pub const GPIO_BRR_BR4: u32 = 16;
pub const GPIO_BRR_BR5_Pos: u32 = 5;
pub const GPIO_BRR_BR5_Msk: u32 = 32;
pub const GPIO_BRR_BR5: u32 = 32;
pub const GPIO_BRR_BR6_Pos: u32 = 6;
pub const GPIO_BRR_BR6_Msk: u32 = 64;
pub const GPIO_BRR_BR6: u32 = 64;
pub const GPIO_BRR_BR7_Pos: u32 = 7;
pub const GPIO_BRR_BR7_Msk: u32 = 128;
pub const GPIO_BRR_BR7: u32 = 128;
pub const GPIO_BRR_BR8_Pos: u32 = 8;
pub const GPIO_BRR_BR8_Msk: u32 = 256;
pub const GPIO_BRR_BR8: u32 = 256;
pub const GPIO_BRR_BR9_Pos: u32 = 9;
pub const GPIO_BRR_BR9_Msk: u32 = 512;
pub const GPIO_BRR_BR9: u32 = 512;
pub const GPIO_BRR_BR10_Pos: u32 = 10;
pub const GPIO_BRR_BR10_Msk: u32 = 1024;
pub const GPIO_BRR_BR10: u32 = 1024;
pub const GPIO_BRR_BR11_Pos: u32 = 11;
pub const GPIO_BRR_BR11_Msk: u32 = 2048;
pub const GPIO_BRR_BR11: u32 = 2048;
pub const GPIO_BRR_BR12_Pos: u32 = 12;
pub const GPIO_BRR_BR12_Msk: u32 = 4096;
pub const GPIO_BRR_BR12: u32 = 4096;
pub const GPIO_BRR_BR13_Pos: u32 = 13;
pub const GPIO_BRR_BR13_Msk: u32 = 8192;
pub const GPIO_BRR_BR13: u32 = 8192;
pub const GPIO_BRR_BR14_Pos: u32 = 14;
pub const GPIO_BRR_BR14_Msk: u32 = 16384;
pub const GPIO_BRR_BR14: u32 = 16384;
pub const GPIO_BRR_BR15_Pos: u32 = 15;
pub const GPIO_BRR_BR15_Msk: u32 = 32768;
pub const GPIO_BRR_BR15: u32 = 32768;
pub const HSEM_R_PROCID_Pos: u32 = 0;
pub const HSEM_R_PROCID_Msk: u32 = 255;
pub const HSEM_R_PROCID: u32 = 255;
pub const HSEM_R_COREID_Pos: u32 = 8;
pub const HSEM_R_COREID_Msk: u32 = 3840;
pub const HSEM_R_COREID: u32 = 3840;
pub const HSEM_R_LOCK_Pos: u32 = 31;
pub const HSEM_R_LOCK_Msk: u32 = 2147483648;
pub const HSEM_R_LOCK: u32 = 2147483648;
pub const HSEM_RLR_PROCID_Pos: u32 = 0;
pub const HSEM_RLR_PROCID_Msk: u32 = 255;
pub const HSEM_RLR_PROCID: u32 = 255;
pub const HSEM_RLR_COREID_Pos: u32 = 8;
pub const HSEM_RLR_COREID_Msk: u32 = 3840;
pub const HSEM_RLR_COREID: u32 = 3840;
pub const HSEM_RLR_LOCK_Pos: u32 = 31;
pub const HSEM_RLR_LOCK_Msk: u32 = 2147483648;
pub const HSEM_RLR_LOCK: u32 = 2147483648;
pub const HSEM_C1IER_ISE0_Pos: u32 = 0;
pub const HSEM_C1IER_ISE0_Msk: u32 = 1;
pub const HSEM_C1IER_ISE0: u32 = 1;
pub const HSEM_C1IER_ISE1_Pos: u32 = 1;
pub const HSEM_C1IER_ISE1_Msk: u32 = 2;
pub const HSEM_C1IER_ISE1: u32 = 2;
pub const HSEM_C1IER_ISE2_Pos: u32 = 2;
pub const HSEM_C1IER_ISE2_Msk: u32 = 4;
pub const HSEM_C1IER_ISE2: u32 = 4;
pub const HSEM_C1IER_ISE3_Pos: u32 = 3;
pub const HSEM_C1IER_ISE3_Msk: u32 = 8;
pub const HSEM_C1IER_ISE3: u32 = 8;
pub const HSEM_C1IER_ISE4_Pos: u32 = 4;
pub const HSEM_C1IER_ISE4_Msk: u32 = 16;
pub const HSEM_C1IER_ISE4: u32 = 16;
pub const HSEM_C1IER_ISE5_Pos: u32 = 5;
pub const HSEM_C1IER_ISE5_Msk: u32 = 32;
pub const HSEM_C1IER_ISE5: u32 = 32;
pub const HSEM_C1IER_ISE6_Pos: u32 = 6;
pub const HSEM_C1IER_ISE6_Msk: u32 = 64;
pub const HSEM_C1IER_ISE6: u32 = 64;
pub const HSEM_C1IER_ISE7_Pos: u32 = 7;
pub const HSEM_C1IER_ISE7_Msk: u32 = 128;
pub const HSEM_C1IER_ISE7: u32 = 128;
pub const HSEM_C1IER_ISE8_Pos: u32 = 8;
pub const HSEM_C1IER_ISE8_Msk: u32 = 256;
pub const HSEM_C1IER_ISE8: u32 = 256;
pub const HSEM_C1IER_ISE9_Pos: u32 = 9;
pub const HSEM_C1IER_ISE9_Msk: u32 = 512;
pub const HSEM_C1IER_ISE9: u32 = 512;
pub const HSEM_C1IER_ISE10_Pos: u32 = 10;
pub const HSEM_C1IER_ISE10_Msk: u32 = 1024;
pub const HSEM_C1IER_ISE10: u32 = 1024;
pub const HSEM_C1IER_ISE11_Pos: u32 = 11;
pub const HSEM_C1IER_ISE11_Msk: u32 = 2048;
pub const HSEM_C1IER_ISE11: u32 = 2048;
pub const HSEM_C1IER_ISE12_Pos: u32 = 12;
pub const HSEM_C1IER_ISE12_Msk: u32 = 4096;
pub const HSEM_C1IER_ISE12: u32 = 4096;
pub const HSEM_C1IER_ISE13_Pos: u32 = 13;
pub const HSEM_C1IER_ISE13_Msk: u32 = 8192;
pub const HSEM_C1IER_ISE13: u32 = 8192;
pub const HSEM_C1IER_ISE14_Pos: u32 = 14;
pub const HSEM_C1IER_ISE14_Msk: u32 = 16384;
pub const HSEM_C1IER_ISE14: u32 = 16384;
pub const HSEM_C1IER_ISE15_Pos: u32 = 15;
pub const HSEM_C1IER_ISE15_Msk: u32 = 32768;
pub const HSEM_C1IER_ISE15: u32 = 32768;
pub const HSEM_C1IER_ISE16_Pos: u32 = 16;
pub const HSEM_C1IER_ISE16_Msk: u32 = 65536;
pub const HSEM_C1IER_ISE16: u32 = 65536;
pub const HSEM_C1IER_ISE17_Pos: u32 = 17;
pub const HSEM_C1IER_ISE17_Msk: u32 = 131072;
pub const HSEM_C1IER_ISE17: u32 = 131072;
pub const HSEM_C1IER_ISE18_Pos: u32 = 18;
pub const HSEM_C1IER_ISE18_Msk: u32 = 262144;
pub const HSEM_C1IER_ISE18: u32 = 262144;
pub const HSEM_C1IER_ISE19_Pos: u32 = 19;
pub const HSEM_C1IER_ISE19_Msk: u32 = 524288;
pub const HSEM_C1IER_ISE19: u32 = 524288;
pub const HSEM_C1IER_ISE20_Pos: u32 = 20;
pub const HSEM_C1IER_ISE20_Msk: u32 = 1048576;
pub const HSEM_C1IER_ISE20: u32 = 1048576;
pub const HSEM_C1IER_ISE21_Pos: u32 = 21;
pub const HSEM_C1IER_ISE21_Msk: u32 = 2097152;
pub const HSEM_C1IER_ISE21: u32 = 2097152;
pub const HSEM_C1IER_ISE22_Pos: u32 = 22;
pub const HSEM_C1IER_ISE22_Msk: u32 = 4194304;
pub const HSEM_C1IER_ISE22: u32 = 4194304;
pub const HSEM_C1IER_ISE23_Pos: u32 = 23;
pub const HSEM_C1IER_ISE23_Msk: u32 = 8388608;
pub const HSEM_C1IER_ISE23: u32 = 8388608;
pub const HSEM_C1IER_ISE24_Pos: u32 = 24;
pub const HSEM_C1IER_ISE24_Msk: u32 = 16777216;
pub const HSEM_C1IER_ISE24: u32 = 16777216;
pub const HSEM_C1IER_ISE25_Pos: u32 = 25;
pub const HSEM_C1IER_ISE25_Msk: u32 = 33554432;
pub const HSEM_C1IER_ISE25: u32 = 33554432;
pub const HSEM_C1IER_ISE26_Pos: u32 = 26;
pub const HSEM_C1IER_ISE26_Msk: u32 = 67108864;
pub const HSEM_C1IER_ISE26: u32 = 67108864;
pub const HSEM_C1IER_ISE27_Pos: u32 = 27;
pub const HSEM_C1IER_ISE27_Msk: u32 = 134217728;
pub const HSEM_C1IER_ISE27: u32 = 134217728;
pub const HSEM_C1IER_ISE28_Pos: u32 = 28;
pub const HSEM_C1IER_ISE28_Msk: u32 = 268435456;
pub const HSEM_C1IER_ISE28: u32 = 268435456;
pub const HSEM_C1IER_ISE29_Pos: u32 = 29;
pub const HSEM_C1IER_ISE29_Msk: u32 = 536870912;
pub const HSEM_C1IER_ISE29: u32 = 536870912;
pub const HSEM_C1IER_ISE30_Pos: u32 = 30;
pub const HSEM_C1IER_ISE30_Msk: u32 = 1073741824;
pub const HSEM_C1IER_ISE30: u32 = 1073741824;
pub const HSEM_C1IER_ISE31_Pos: u32 = 31;
pub const HSEM_C1IER_ISE31_Msk: u32 = 2147483648;
pub const HSEM_C1IER_ISE31: u32 = 2147483648;
pub const HSEM_C1ICR_ISC0_Pos: u32 = 0;
pub const HSEM_C1ICR_ISC0_Msk: u32 = 1;
pub const HSEM_C1ICR_ISC0: u32 = 1;
pub const HSEM_C1ICR_ISC1_Pos: u32 = 1;
pub const HSEM_C1ICR_ISC1_Msk: u32 = 2;
pub const HSEM_C1ICR_ISC1: u32 = 2;
pub const HSEM_C1ICR_ISC2_Pos: u32 = 2;
pub const HSEM_C1ICR_ISC2_Msk: u32 = 4;
pub const HSEM_C1ICR_ISC2: u32 = 4;
pub const HSEM_C1ICR_ISC3_Pos: u32 = 3;
pub const HSEM_C1ICR_ISC3_Msk: u32 = 8;
pub const HSEM_C1ICR_ISC3: u32 = 8;
pub const HSEM_C1ICR_ISC4_Pos: u32 = 4;
pub const HSEM_C1ICR_ISC4_Msk: u32 = 16;
pub const HSEM_C1ICR_ISC4: u32 = 16;
pub const HSEM_C1ICR_ISC5_Pos: u32 = 5;
pub const HSEM_C1ICR_ISC5_Msk: u32 = 32;
pub const HSEM_C1ICR_ISC5: u32 = 32;
pub const HSEM_C1ICR_ISC6_Pos: u32 = 6;
pub const HSEM_C1ICR_ISC6_Msk: u32 = 64;
pub const HSEM_C1ICR_ISC6: u32 = 64;
pub const HSEM_C1ICR_ISC7_Pos: u32 = 7;
pub const HSEM_C1ICR_ISC7_Msk: u32 = 128;
pub const HSEM_C1ICR_ISC7: u32 = 128;
pub const HSEM_C1ICR_ISC8_Pos: u32 = 8;
pub const HSEM_C1ICR_ISC8_Msk: u32 = 256;
pub const HSEM_C1ICR_ISC8: u32 = 256;
pub const HSEM_C1ICR_ISC9_Pos: u32 = 9;
pub const HSEM_C1ICR_ISC9_Msk: u32 = 512;
pub const HSEM_C1ICR_ISC9: u32 = 512;
pub const HSEM_C1ICR_ISC10_Pos: u32 = 10;
pub const HSEM_C1ICR_ISC10_Msk: u32 = 1024;
pub const HSEM_C1ICR_ISC10: u32 = 1024;
pub const HSEM_C1ICR_ISC11_Pos: u32 = 11;
pub const HSEM_C1ICR_ISC11_Msk: u32 = 2048;
pub const HSEM_C1ICR_ISC11: u32 = 2048;
pub const HSEM_C1ICR_ISC12_Pos: u32 = 12;
pub const HSEM_C1ICR_ISC12_Msk: u32 = 4096;
pub const HSEM_C1ICR_ISC12: u32 = 4096;
pub const HSEM_C1ICR_ISC13_Pos: u32 = 13;
pub const HSEM_C1ICR_ISC13_Msk: u32 = 8192;
pub const HSEM_C1ICR_ISC13: u32 = 8192;
pub const HSEM_C1ICR_ISC14_Pos: u32 = 14;
pub const HSEM_C1ICR_ISC14_Msk: u32 = 16384;
pub const HSEM_C1ICR_ISC14: u32 = 16384;
pub const HSEM_C1ICR_ISC15_Pos: u32 = 15;
pub const HSEM_C1ICR_ISC15_Msk: u32 = 32768;
pub const HSEM_C1ICR_ISC15: u32 = 32768;
pub const HSEM_C1ICR_ISC16_Pos: u32 = 16;
pub const HSEM_C1ICR_ISC16_Msk: u32 = 65536;
pub const HSEM_C1ICR_ISC16: u32 = 65536;
pub const HSEM_C1ICR_ISC17_Pos: u32 = 17;
pub const HSEM_C1ICR_ISC17_Msk: u32 = 131072;
pub const HSEM_C1ICR_ISC17: u32 = 131072;
pub const HSEM_C1ICR_ISC18_Pos: u32 = 18;
pub const HSEM_C1ICR_ISC18_Msk: u32 = 262144;
pub const HSEM_C1ICR_ISC18: u32 = 262144;
pub const HSEM_C1ICR_ISC19_Pos: u32 = 19;
pub const HSEM_C1ICR_ISC19_Msk: u32 = 524288;
pub const HSEM_C1ICR_ISC19: u32 = 524288;
pub const HSEM_C1ICR_ISC20_Pos: u32 = 20;
pub const HSEM_C1ICR_ISC20_Msk: u32 = 1048576;
pub const HSEM_C1ICR_ISC20: u32 = 1048576;
pub const HSEM_C1ICR_ISC21_Pos: u32 = 21;
pub const HSEM_C1ICR_ISC21_Msk: u32 = 2097152;
pub const HSEM_C1ICR_ISC21: u32 = 2097152;
pub const HSEM_C1ICR_ISC22_Pos: u32 = 22;
pub const HSEM_C1ICR_ISC22_Msk: u32 = 4194304;
pub const HSEM_C1ICR_ISC22: u32 = 4194304;
pub const HSEM_C1ICR_ISC23_Pos: u32 = 23;
pub const HSEM_C1ICR_ISC23_Msk: u32 = 8388608;
pub const HSEM_C1ICR_ISC23: u32 = 8388608;
pub const HSEM_C1ICR_ISC24_Pos: u32 = 24;
pub const HSEM_C1ICR_ISC24_Msk: u32 = 16777216;
pub const HSEM_C1ICR_ISC24: u32 = 16777216;
pub const HSEM_C1ICR_ISC25_Pos: u32 = 25;
pub const HSEM_C1ICR_ISC25_Msk: u32 = 33554432;
pub const HSEM_C1ICR_ISC25: u32 = 33554432;
pub const HSEM_C1ICR_ISC26_Pos: u32 = 26;
pub const HSEM_C1ICR_ISC26_Msk: u32 = 67108864;
pub const HSEM_C1ICR_ISC26: u32 = 67108864;
pub const HSEM_C1ICR_ISC27_Pos: u32 = 27;
pub const HSEM_C1ICR_ISC27_Msk: u32 = 134217728;
pub const HSEM_C1ICR_ISC27: u32 = 134217728;
pub const HSEM_C1ICR_ISC28_Pos: u32 = 28;
pub const HSEM_C1ICR_ISC28_Msk: u32 = 268435456;
pub const HSEM_C1ICR_ISC28: u32 = 268435456;
pub const HSEM_C1ICR_ISC29_Pos: u32 = 29;
pub const HSEM_C1ICR_ISC29_Msk: u32 = 536870912;
pub const HSEM_C1ICR_ISC29: u32 = 536870912;
pub const HSEM_C1ICR_ISC30_Pos: u32 = 30;
pub const HSEM_C1ICR_ISC30_Msk: u32 = 1073741824;
pub const HSEM_C1ICR_ISC30: u32 = 1073741824;
pub const HSEM_C1ICR_ISC31_Pos: u32 = 31;
pub const HSEM_C1ICR_ISC31_Msk: u32 = 2147483648;
pub const HSEM_C1ICR_ISC31: u32 = 2147483648;
pub const HSEM_C1ISR_ISF0_Pos: u32 = 0;
pub const HSEM_C1ISR_ISF0_Msk: u32 = 1;
pub const HSEM_C1ISR_ISF0: u32 = 1;
pub const HSEM_C1ISR_ISF1_Pos: u32 = 1;
pub const HSEM_C1ISR_ISF1_Msk: u32 = 2;
pub const HSEM_C1ISR_ISF1: u32 = 2;
pub const HSEM_C1ISR_ISF2_Pos: u32 = 2;
pub const HSEM_C1ISR_ISF2_Msk: u32 = 4;
pub const HSEM_C1ISR_ISF2: u32 = 4;
pub const HSEM_C1ISR_ISF3_Pos: u32 = 3;
pub const HSEM_C1ISR_ISF3_Msk: u32 = 8;
pub const HSEM_C1ISR_ISF3: u32 = 8;
pub const HSEM_C1ISR_ISF4_Pos: u32 = 4;
pub const HSEM_C1ISR_ISF4_Msk: u32 = 16;
pub const HSEM_C1ISR_ISF4: u32 = 16;
pub const HSEM_C1ISR_ISF5_Pos: u32 = 5;
pub const HSEM_C1ISR_ISF5_Msk: u32 = 32;
pub const HSEM_C1ISR_ISF5: u32 = 32;
pub const HSEM_C1ISR_ISF6_Pos: u32 = 6;
pub const HSEM_C1ISR_ISF6_Msk: u32 = 64;
pub const HSEM_C1ISR_ISF6: u32 = 64;
pub const HSEM_C1ISR_ISF7_Pos: u32 = 7;
pub const HSEM_C1ISR_ISF7_Msk: u32 = 128;
pub const HSEM_C1ISR_ISF7: u32 = 128;
pub const HSEM_C1ISR_ISF8_Pos: u32 = 8;
pub const HSEM_C1ISR_ISF8_Msk: u32 = 256;
pub const HSEM_C1ISR_ISF8: u32 = 256;
pub const HSEM_C1ISR_ISF9_Pos: u32 = 9;
pub const HSEM_C1ISR_ISF9_Msk: u32 = 512;
pub const HSEM_C1ISR_ISF9: u32 = 512;
pub const HSEM_C1ISR_ISF10_Pos: u32 = 10;
pub const HSEM_C1ISR_ISF10_Msk: u32 = 1024;
pub const HSEM_C1ISR_ISF10: u32 = 1024;
pub const HSEM_C1ISR_ISF11_Pos: u32 = 11;
pub const HSEM_C1ISR_ISF11_Msk: u32 = 2048;
pub const HSEM_C1ISR_ISF11: u32 = 2048;
pub const HSEM_C1ISR_ISF12_Pos: u32 = 12;
pub const HSEM_C1ISR_ISF12_Msk: u32 = 4096;
pub const HSEM_C1ISR_ISF12: u32 = 4096;
pub const HSEM_C1ISR_ISF13_Pos: u32 = 13;
pub const HSEM_C1ISR_ISF13_Msk: u32 = 8192;
pub const HSEM_C1ISR_ISF13: u32 = 8192;
pub const HSEM_C1ISR_ISF14_Pos: u32 = 14;
pub const HSEM_C1ISR_ISF14_Msk: u32 = 16384;
pub const HSEM_C1ISR_ISF14: u32 = 16384;
pub const HSEM_C1ISR_ISF15_Pos: u32 = 15;
pub const HSEM_C1ISR_ISF15_Msk: u32 = 32768;
pub const HSEM_C1ISR_ISF15: u32 = 32768;
pub const HSEM_C1ISR_ISF16_Pos: u32 = 16;
pub const HSEM_C1ISR_ISF16_Msk: u32 = 65536;
pub const HSEM_C1ISR_ISF16: u32 = 65536;
pub const HSEM_C1ISR_ISF17_Pos: u32 = 17;
pub const HSEM_C1ISR_ISF17_Msk: u32 = 131072;
pub const HSEM_C1ISR_ISF17: u32 = 131072;
pub const HSEM_C1ISR_ISF18_Pos: u32 = 18;
pub const HSEM_C1ISR_ISF18_Msk: u32 = 262144;
pub const HSEM_C1ISR_ISF18: u32 = 262144;
pub const HSEM_C1ISR_ISF19_Pos: u32 = 19;
pub const HSEM_C1ISR_ISF19_Msk: u32 = 524288;
pub const HSEM_C1ISR_ISF19: u32 = 524288;
pub const HSEM_C1ISR_ISF20_Pos: u32 = 20;
pub const HSEM_C1ISR_ISF20_Msk: u32 = 1048576;
pub const HSEM_C1ISR_ISF20: u32 = 1048576;
pub const HSEM_C1ISR_ISF21_Pos: u32 = 21;
pub const HSEM_C1ISR_ISF21_Msk: u32 = 2097152;
pub const HSEM_C1ISR_ISF21: u32 = 2097152;
pub const HSEM_C1ISR_ISF22_Pos: u32 = 22;
pub const HSEM_C1ISR_ISF22_Msk: u32 = 4194304;
pub const HSEM_C1ISR_ISF22: u32 = 4194304;
pub const HSEM_C1ISR_ISF23_Pos: u32 = 23;
pub const HSEM_C1ISR_ISF23_Msk: u32 = 8388608;
pub const HSEM_C1ISR_ISF23: u32 = 8388608;
pub const HSEM_C1ISR_ISF24_Pos: u32 = 24;
pub const HSEM_C1ISR_ISF24_Msk: u32 = 16777216;
pub const HSEM_C1ISR_ISF24: u32 = 16777216;
pub const HSEM_C1ISR_ISF25_Pos: u32 = 25;
pub const HSEM_C1ISR_ISF25_Msk: u32 = 33554432;
pub const HSEM_C1ISR_ISF25: u32 = 33554432;
pub const HSEM_C1ISR_ISF26_Pos: u32 = 26;
pub const HSEM_C1ISR_ISF26_Msk: u32 = 67108864;
pub const HSEM_C1ISR_ISF26: u32 = 67108864;
pub const HSEM_C1ISR_ISF27_Pos: u32 = 27;
pub const HSEM_C1ISR_ISF27_Msk: u32 = 134217728;
pub const HSEM_C1ISR_ISF27: u32 = 134217728;
pub const HSEM_C1ISR_ISF28_Pos: u32 = 28;
pub const HSEM_C1ISR_ISF28_Msk: u32 = 268435456;
pub const HSEM_C1ISR_ISF28: u32 = 268435456;
pub const HSEM_C1ISR_ISF29_Pos: u32 = 29;
pub const HSEM_C1ISR_ISF29_Msk: u32 = 536870912;
pub const HSEM_C1ISR_ISF29: u32 = 536870912;
pub const HSEM_C1ISR_ISF30_Pos: u32 = 30;
pub const HSEM_C1ISR_ISF30_Msk: u32 = 1073741824;
pub const HSEM_C1ISR_ISF30: u32 = 1073741824;
pub const HSEM_C1ISR_ISF31_Pos: u32 = 31;
pub const HSEM_C1ISR_ISF31_Msk: u32 = 2147483648;
pub const HSEM_C1ISR_ISF31: u32 = 2147483648;
pub const HSEM_C1MISR_MISF0_Pos: u32 = 0;
pub const HSEM_C1MISR_MISF0_Msk: u32 = 1;
pub const HSEM_C1MISR_MISF0: u32 = 1;
pub const HSEM_C1MISR_MISF1_Pos: u32 = 1;
pub const HSEM_C1MISR_MISF1_Msk: u32 = 2;
pub const HSEM_C1MISR_MISF1: u32 = 2;
pub const HSEM_C1MISR_MISF2_Pos: u32 = 2;
pub const HSEM_C1MISR_MISF2_Msk: u32 = 4;
pub const HSEM_C1MISR_MISF2: u32 = 4;
pub const HSEM_C1MISR_MISF3_Pos: u32 = 3;
pub const HSEM_C1MISR_MISF3_Msk: u32 = 8;
pub const HSEM_C1MISR_MISF3: u32 = 8;
pub const HSEM_C1MISR_MISF4_Pos: u32 = 4;
pub const HSEM_C1MISR_MISF4_Msk: u32 = 16;
pub const HSEM_C1MISR_MISF4: u32 = 16;
pub const HSEM_C1MISR_MISF5_Pos: u32 = 5;
pub const HSEM_C1MISR_MISF5_Msk: u32 = 32;
pub const HSEM_C1MISR_MISF5: u32 = 32;
pub const HSEM_C1MISR_MISF6_Pos: u32 = 6;
pub const HSEM_C1MISR_MISF6_Msk: u32 = 64;
pub const HSEM_C1MISR_MISF6: u32 = 64;
pub const HSEM_C1MISR_MISF7_Pos: u32 = 7;
pub const HSEM_C1MISR_MISF7_Msk: u32 = 128;
pub const HSEM_C1MISR_MISF7: u32 = 128;
pub const HSEM_C1MISR_MISF8_Pos: u32 = 8;
pub const HSEM_C1MISR_MISF8_Msk: u32 = 256;
pub const HSEM_C1MISR_MISF8: u32 = 256;
pub const HSEM_C1MISR_MISF9_Pos: u32 = 9;
pub const HSEM_C1MISR_MISF9_Msk: u32 = 512;
pub const HSEM_C1MISR_MISF9: u32 = 512;
pub const HSEM_C1MISR_MISF10_Pos: u32 = 10;
pub const HSEM_C1MISR_MISF10_Msk: u32 = 1024;
pub const HSEM_C1MISR_MISF10: u32 = 1024;
pub const HSEM_C1MISR_MISF11_Pos: u32 = 11;
pub const HSEM_C1MISR_MISF11_Msk: u32 = 2048;
pub const HSEM_C1MISR_MISF11: u32 = 2048;
pub const HSEM_C1MISR_MISF12_Pos: u32 = 12;
pub const HSEM_C1MISR_MISF12_Msk: u32 = 4096;
pub const HSEM_C1MISR_MISF12: u32 = 4096;
pub const HSEM_C1MISR_MISF13_Pos: u32 = 13;
pub const HSEM_C1MISR_MISF13_Msk: u32 = 8192;
pub const HSEM_C1MISR_MISF13: u32 = 8192;
pub const HSEM_C1MISR_MISF14_Pos: u32 = 14;
pub const HSEM_C1MISR_MISF14_Msk: u32 = 16384;
pub const HSEM_C1MISR_MISF14: u32 = 16384;
pub const HSEM_C1MISR_MISF15_Pos: u32 = 15;
pub const HSEM_C1MISR_MISF15_Msk: u32 = 32768;
pub const HSEM_C1MISR_MISF15: u32 = 32768;
pub const HSEM_C1MISR_MISF16_Pos: u32 = 16;
pub const HSEM_C1MISR_MISF16_Msk: u32 = 65536;
pub const HSEM_C1MISR_MISF16: u32 = 65536;
pub const HSEM_C1MISR_MISF17_Pos: u32 = 17;
pub const HSEM_C1MISR_MISF17_Msk: u32 = 131072;
pub const HSEM_C1MISR_MISF17: u32 = 131072;
pub const HSEM_C1MISR_MISF18_Pos: u32 = 18;
pub const HSEM_C1MISR_MISF18_Msk: u32 = 262144;
pub const HSEM_C1MISR_MISF18: u32 = 262144;
pub const HSEM_C1MISR_MISF19_Pos: u32 = 19;
pub const HSEM_C1MISR_MISF19_Msk: u32 = 524288;
pub const HSEM_C1MISR_MISF19: u32 = 524288;
pub const HSEM_C1MISR_MISF20_Pos: u32 = 20;
pub const HSEM_C1MISR_MISF20_Msk: u32 = 1048576;
pub const HSEM_C1MISR_MISF20: u32 = 1048576;
pub const HSEM_C1MISR_MISF21_Pos: u32 = 21;
pub const HSEM_C1MISR_MISF21_Msk: u32 = 2097152;
pub const HSEM_C1MISR_MISF21: u32 = 2097152;
pub const HSEM_C1MISR_MISF22_Pos: u32 = 22;
pub const HSEM_C1MISR_MISF22_Msk: u32 = 4194304;
pub const HSEM_C1MISR_MISF22: u32 = 4194304;
pub const HSEM_C1MISR_MISF23_Pos: u32 = 23;
pub const HSEM_C1MISR_MISF23_Msk: u32 = 8388608;
pub const HSEM_C1MISR_MISF23: u32 = 8388608;
pub const HSEM_C1MISR_MISF24_Pos: u32 = 24;
pub const HSEM_C1MISR_MISF24_Msk: u32 = 16777216;
pub const HSEM_C1MISR_MISF24: u32 = 16777216;
pub const HSEM_C1MISR_MISF25_Pos: u32 = 25;
pub const HSEM_C1MISR_MISF25_Msk: u32 = 33554432;
pub const HSEM_C1MISR_MISF25: u32 = 33554432;
pub const HSEM_C1MISR_MISF26_Pos: u32 = 26;
pub const HSEM_C1MISR_MISF26_Msk: u32 = 67108864;
pub const HSEM_C1MISR_MISF26: u32 = 67108864;
pub const HSEM_C1MISR_MISF27_Pos: u32 = 27;
pub const HSEM_C1MISR_MISF27_Msk: u32 = 134217728;
pub const HSEM_C1MISR_MISF27: u32 = 134217728;
pub const HSEM_C1MISR_MISF28_Pos: u32 = 28;
pub const HSEM_C1MISR_MISF28_Msk: u32 = 268435456;
pub const HSEM_C1MISR_MISF28: u32 = 268435456;
pub const HSEM_C1MISR_MISF29_Pos: u32 = 29;
pub const HSEM_C1MISR_MISF29_Msk: u32 = 536870912;
pub const HSEM_C1MISR_MISF29: u32 = 536870912;
pub const HSEM_C1MISR_MISF30_Pos: u32 = 30;
pub const HSEM_C1MISR_MISF30_Msk: u32 = 1073741824;
pub const HSEM_C1MISR_MISF30: u32 = 1073741824;
pub const HSEM_C1MISR_MISF31_Pos: u32 = 31;
pub const HSEM_C1MISR_MISF31_Msk: u32 = 2147483648;
pub const HSEM_C1MISR_MISF31: u32 = 2147483648;
pub const HSEM_C2IER_ISE0_Pos: u32 = 0;
pub const HSEM_C2IER_ISE0_Msk: u32 = 1;
pub const HSEM_C2IER_ISE0: u32 = 1;
pub const HSEM_C2IER_ISE1_Pos: u32 = 1;
pub const HSEM_C2IER_ISE1_Msk: u32 = 2;
pub const HSEM_C2IER_ISE1: u32 = 2;
pub const HSEM_C2IER_ISE2_Pos: u32 = 2;
pub const HSEM_C2IER_ISE2_Msk: u32 = 4;
pub const HSEM_C2IER_ISE2: u32 = 4;
pub const HSEM_C2IER_ISE3_Pos: u32 = 3;
pub const HSEM_C2IER_ISE3_Msk: u32 = 8;
pub const HSEM_C2IER_ISE3: u32 = 8;
pub const HSEM_C2IER_ISE4_Pos: u32 = 4;
pub const HSEM_C2IER_ISE4_Msk: u32 = 16;
pub const HSEM_C2IER_ISE4: u32 = 16;
pub const HSEM_C2IER_ISE5_Pos: u32 = 5;
pub const HSEM_C2IER_ISE5_Msk: u32 = 32;
pub const HSEM_C2IER_ISE5: u32 = 32;
pub const HSEM_C2IER_ISE6_Pos: u32 = 6;
pub const HSEM_C2IER_ISE6_Msk: u32 = 64;
pub const HSEM_C2IER_ISE6: u32 = 64;
pub const HSEM_C2IER_ISE7_Pos: u32 = 7;
pub const HSEM_C2IER_ISE7_Msk: u32 = 128;
pub const HSEM_C2IER_ISE7: u32 = 128;
pub const HSEM_C2IER_ISE8_Pos: u32 = 8;
pub const HSEM_C2IER_ISE8_Msk: u32 = 256;
pub const HSEM_C2IER_ISE8: u32 = 256;
pub const HSEM_C2IER_ISE9_Pos: u32 = 9;
pub const HSEM_C2IER_ISE9_Msk: u32 = 512;
pub const HSEM_C2IER_ISE9: u32 = 512;
pub const HSEM_C2IER_ISE10_Pos: u32 = 10;
pub const HSEM_C2IER_ISE10_Msk: u32 = 1024;
pub const HSEM_C2IER_ISE10: u32 = 1024;
pub const HSEM_C2IER_ISE11_Pos: u32 = 11;
pub const HSEM_C2IER_ISE11_Msk: u32 = 2048;
pub const HSEM_C2IER_ISE11: u32 = 2048;
pub const HSEM_C2IER_ISE12_Pos: u32 = 12;
pub const HSEM_C2IER_ISE12_Msk: u32 = 4096;
pub const HSEM_C2IER_ISE12: u32 = 4096;
pub const HSEM_C2IER_ISE13_Pos: u32 = 13;
pub const HSEM_C2IER_ISE13_Msk: u32 = 8192;
pub const HSEM_C2IER_ISE13: u32 = 8192;
pub const HSEM_C2IER_ISE14_Pos: u32 = 14;
pub const HSEM_C2IER_ISE14_Msk: u32 = 16384;
pub const HSEM_C2IER_ISE14: u32 = 16384;
pub const HSEM_C2IER_ISE15_Pos: u32 = 15;
pub const HSEM_C2IER_ISE15_Msk: u32 = 32768;
pub const HSEM_C2IER_ISE15: u32 = 32768;
pub const HSEM_C2IER_ISE16_Pos: u32 = 16;
pub const HSEM_C2IER_ISE16_Msk: u32 = 65536;
pub const HSEM_C2IER_ISE16: u32 = 65536;
pub const HSEM_C2IER_ISE17_Pos: u32 = 17;
pub const HSEM_C2IER_ISE17_Msk: u32 = 131072;
pub const HSEM_C2IER_ISE17: u32 = 131072;
pub const HSEM_C2IER_ISE18_Pos: u32 = 18;
pub const HSEM_C2IER_ISE18_Msk: u32 = 262144;
pub const HSEM_C2IER_ISE18: u32 = 262144;
pub const HSEM_C2IER_ISE19_Pos: u32 = 19;
pub const HSEM_C2IER_ISE19_Msk: u32 = 524288;
pub const HSEM_C2IER_ISE19: u32 = 524288;
pub const HSEM_C2IER_ISE20_Pos: u32 = 20;
pub const HSEM_C2IER_ISE20_Msk: u32 = 1048576;
pub const HSEM_C2IER_ISE20: u32 = 1048576;
pub const HSEM_C2IER_ISE21_Pos: u32 = 21;
pub const HSEM_C2IER_ISE21_Msk: u32 = 2097152;
pub const HSEM_C2IER_ISE21: u32 = 2097152;
pub const HSEM_C2IER_ISE22_Pos: u32 = 22;
pub const HSEM_C2IER_ISE22_Msk: u32 = 4194304;
pub const HSEM_C2IER_ISE22: u32 = 4194304;
pub const HSEM_C2IER_ISE23_Pos: u32 = 23;
pub const HSEM_C2IER_ISE23_Msk: u32 = 8388608;
pub const HSEM_C2IER_ISE23: u32 = 8388608;
pub const HSEM_C2IER_ISE24_Pos: u32 = 24;
pub const HSEM_C2IER_ISE24_Msk: u32 = 16777216;
pub const HSEM_C2IER_ISE24: u32 = 16777216;
pub const HSEM_C2IER_ISE25_Pos: u32 = 25;
pub const HSEM_C2IER_ISE25_Msk: u32 = 33554432;
pub const HSEM_C2IER_ISE25: u32 = 33554432;
pub const HSEM_C2IER_ISE26_Pos: u32 = 26;
pub const HSEM_C2IER_ISE26_Msk: u32 = 67108864;
pub const HSEM_C2IER_ISE26: u32 = 67108864;
pub const HSEM_C2IER_ISE27_Pos: u32 = 27;
pub const HSEM_C2IER_ISE27_Msk: u32 = 134217728;
pub const HSEM_C2IER_ISE27: u32 = 134217728;
pub const HSEM_C2IER_ISE28_Pos: u32 = 28;
pub const HSEM_C2IER_ISE28_Msk: u32 = 268435456;
pub const HSEM_C2IER_ISE28: u32 = 268435456;
pub const HSEM_C2IER_ISE29_Pos: u32 = 29;
pub const HSEM_C2IER_ISE29_Msk: u32 = 536870912;
pub const HSEM_C2IER_ISE29: u32 = 536870912;
pub const HSEM_C2IER_ISE30_Pos: u32 = 30;
pub const HSEM_C2IER_ISE30_Msk: u32 = 1073741824;
pub const HSEM_C2IER_ISE30: u32 = 1073741824;
pub const HSEM_C2IER_ISE31_Pos: u32 = 31;
pub const HSEM_C2IER_ISE31_Msk: u32 = 2147483648;
pub const HSEM_C2IER_ISE31: u32 = 2147483648;
pub const HSEM_C2ICR_ISC0_Pos: u32 = 0;
pub const HSEM_C2ICR_ISC0_Msk: u32 = 1;
pub const HSEM_C2ICR_ISC0: u32 = 1;
pub const HSEM_C2ICR_ISC1_Pos: u32 = 1;
pub const HSEM_C2ICR_ISC1_Msk: u32 = 2;
pub const HSEM_C2ICR_ISC1: u32 = 2;
pub const HSEM_C2ICR_ISC2_Pos: u32 = 2;
pub const HSEM_C2ICR_ISC2_Msk: u32 = 4;
pub const HSEM_C2ICR_ISC2: u32 = 4;
pub const HSEM_C2ICR_ISC3_Pos: u32 = 3;
pub const HSEM_C2ICR_ISC3_Msk: u32 = 8;
pub const HSEM_C2ICR_ISC3: u32 = 8;
pub const HSEM_C2ICR_ISC4_Pos: u32 = 4;
pub const HSEM_C2ICR_ISC4_Msk: u32 = 16;
pub const HSEM_C2ICR_ISC4: u32 = 16;
pub const HSEM_C2ICR_ISC5_Pos: u32 = 5;
pub const HSEM_C2ICR_ISC5_Msk: u32 = 32;
pub const HSEM_C2ICR_ISC5: u32 = 32;
pub const HSEM_C2ICR_ISC6_Pos: u32 = 6;
pub const HSEM_C2ICR_ISC6_Msk: u32 = 64;
pub const HSEM_C2ICR_ISC6: u32 = 64;
pub const HSEM_C2ICR_ISC7_Pos: u32 = 7;
pub const HSEM_C2ICR_ISC7_Msk: u32 = 128;
pub const HSEM_C2ICR_ISC7: u32 = 128;
pub const HSEM_C2ICR_ISC8_Pos: u32 = 8;
pub const HSEM_C2ICR_ISC8_Msk: u32 = 256;
pub const HSEM_C2ICR_ISC8: u32 = 256;
pub const HSEM_C2ICR_ISC9_Pos: u32 = 9;
pub const HSEM_C2ICR_ISC9_Msk: u32 = 512;
pub const HSEM_C2ICR_ISC9: u32 = 512;
pub const HSEM_C2ICR_ISC10_Pos: u32 = 10;
pub const HSEM_C2ICR_ISC10_Msk: u32 = 1024;
pub const HSEM_C2ICR_ISC10: u32 = 1024;
pub const HSEM_C2ICR_ISC11_Pos: u32 = 11;
pub const HSEM_C2ICR_ISC11_Msk: u32 = 2048;
pub const HSEM_C2ICR_ISC11: u32 = 2048;
pub const HSEM_C2ICR_ISC12_Pos: u32 = 12;
pub const HSEM_C2ICR_ISC12_Msk: u32 = 4096;
pub const HSEM_C2ICR_ISC12: u32 = 4096;
pub const HSEM_C2ICR_ISC13_Pos: u32 = 13;
pub const HSEM_C2ICR_ISC13_Msk: u32 = 8192;
pub const HSEM_C2ICR_ISC13: u32 = 8192;
pub const HSEM_C2ICR_ISC14_Pos: u32 = 14;
pub const HSEM_C2ICR_ISC14_Msk: u32 = 16384;
pub const HSEM_C2ICR_ISC14: u32 = 16384;
pub const HSEM_C2ICR_ISC15_Pos: u32 = 15;
pub const HSEM_C2ICR_ISC15_Msk: u32 = 32768;
pub const HSEM_C2ICR_ISC15: u32 = 32768;
pub const HSEM_C2ICR_ISC16_Pos: u32 = 16;
pub const HSEM_C2ICR_ISC16_Msk: u32 = 65536;
pub const HSEM_C2ICR_ISC16: u32 = 65536;
pub const HSEM_C2ICR_ISC17_Pos: u32 = 17;
pub const HSEM_C2ICR_ISC17_Msk: u32 = 131072;
pub const HSEM_C2ICR_ISC17: u32 = 131072;
pub const HSEM_C2ICR_ISC18_Pos: u32 = 18;
pub const HSEM_C2ICR_ISC18_Msk: u32 = 262144;
pub const HSEM_C2ICR_ISC18: u32 = 262144;
pub const HSEM_C2ICR_ISC19_Pos: u32 = 19;
pub const HSEM_C2ICR_ISC19_Msk: u32 = 524288;
pub const HSEM_C2ICR_ISC19: u32 = 524288;
pub const HSEM_C2ICR_ISC20_Pos: u32 = 20;
pub const HSEM_C2ICR_ISC20_Msk: u32 = 1048576;
pub const HSEM_C2ICR_ISC20: u32 = 1048576;
pub const HSEM_C2ICR_ISC21_Pos: u32 = 21;
pub const HSEM_C2ICR_ISC21_Msk: u32 = 2097152;
pub const HSEM_C2ICR_ISC21: u32 = 2097152;
pub const HSEM_C2ICR_ISC22_Pos: u32 = 22;
pub const HSEM_C2ICR_ISC22_Msk: u32 = 4194304;
pub const HSEM_C2ICR_ISC22: u32 = 4194304;
pub const HSEM_C2ICR_ISC23_Pos: u32 = 23;
pub const HSEM_C2ICR_ISC23_Msk: u32 = 8388608;
pub const HSEM_C2ICR_ISC23: u32 = 8388608;
pub const HSEM_C2ICR_ISC24_Pos: u32 = 24;
pub const HSEM_C2ICR_ISC24_Msk: u32 = 16777216;
pub const HSEM_C2ICR_ISC24: u32 = 16777216;
pub const HSEM_C2ICR_ISC25_Pos: u32 = 25;
pub const HSEM_C2ICR_ISC25_Msk: u32 = 33554432;
pub const HSEM_C2ICR_ISC25: u32 = 33554432;
pub const HSEM_C2ICR_ISC26_Pos: u32 = 26;
pub const HSEM_C2ICR_ISC26_Msk: u32 = 67108864;
pub const HSEM_C2ICR_ISC26: u32 = 67108864;
pub const HSEM_C2ICR_ISC27_Pos: u32 = 27;
pub const HSEM_C2ICR_ISC27_Msk: u32 = 134217728;
pub const HSEM_C2ICR_ISC27: u32 = 134217728;
pub const HSEM_C2ICR_ISC28_Pos: u32 = 28;
pub const HSEM_C2ICR_ISC28_Msk: u32 = 268435456;
pub const HSEM_C2ICR_ISC28: u32 = 268435456;
pub const HSEM_C2ICR_ISC29_Pos: u32 = 29;
pub const HSEM_C2ICR_ISC29_Msk: u32 = 536870912;
pub const HSEM_C2ICR_ISC29: u32 = 536870912;
pub const HSEM_C2ICR_ISC30_Pos: u32 = 30;
pub const HSEM_C2ICR_ISC30_Msk: u32 = 1073741824;
pub const HSEM_C2ICR_ISC30: u32 = 1073741824;
pub const HSEM_C2ICR_ISC31_Pos: u32 = 31;
pub const HSEM_C2ICR_ISC31_Msk: u32 = 2147483648;
pub const HSEM_C2ICR_ISC31: u32 = 2147483648;
pub const HSEM_C2ISR_ISF0_Pos: u32 = 0;
pub const HSEM_C2ISR_ISF0_Msk: u32 = 1;
pub const HSEM_C2ISR_ISF0: u32 = 1;
pub const HSEM_C2ISR_ISF1_Pos: u32 = 1;
pub const HSEM_C2ISR_ISF1_Msk: u32 = 2;
pub const HSEM_C2ISR_ISF1: u32 = 2;
pub const HSEM_C2ISR_ISF2_Pos: u32 = 2;
pub const HSEM_C2ISR_ISF2_Msk: u32 = 4;
pub const HSEM_C2ISR_ISF2: u32 = 4;
pub const HSEM_C2ISR_ISF3_Pos: u32 = 3;
pub const HSEM_C2ISR_ISF3_Msk: u32 = 8;
pub const HSEM_C2ISR_ISF3: u32 = 8;
pub const HSEM_C2ISR_ISF4_Pos: u32 = 4;
pub const HSEM_C2ISR_ISF4_Msk: u32 = 16;
pub const HSEM_C2ISR_ISF4: u32 = 16;
pub const HSEM_C2ISR_ISF5_Pos: u32 = 5;
pub const HSEM_C2ISR_ISF5_Msk: u32 = 32;
pub const HSEM_C2ISR_ISF5: u32 = 32;
pub const HSEM_C2ISR_ISF6_Pos: u32 = 6;
pub const HSEM_C2ISR_ISF6_Msk: u32 = 64;
pub const HSEM_C2ISR_ISF6: u32 = 64;
pub const HSEM_C2ISR_ISF7_Pos: u32 = 7;
pub const HSEM_C2ISR_ISF7_Msk: u32 = 128;
pub const HSEM_C2ISR_ISF7: u32 = 128;
pub const HSEM_C2ISR_ISF8_Pos: u32 = 8;
pub const HSEM_C2ISR_ISF8_Msk: u32 = 256;
pub const HSEM_C2ISR_ISF8: u32 = 256;
pub const HSEM_C2ISR_ISF9_Pos: u32 = 9;
pub const HSEM_C2ISR_ISF9_Msk: u32 = 512;
pub const HSEM_C2ISR_ISF9: u32 = 512;
pub const HSEM_C2ISR_ISF10_Pos: u32 = 10;
pub const HSEM_C2ISR_ISF10_Msk: u32 = 1024;
pub const HSEM_C2ISR_ISF10: u32 = 1024;
pub const HSEM_C2ISR_ISF11_Pos: u32 = 11;
pub const HSEM_C2ISR_ISF11_Msk: u32 = 2048;
pub const HSEM_C2ISR_ISF11: u32 = 2048;
pub const HSEM_C2ISR_ISF12_Pos: u32 = 12;
pub const HSEM_C2ISR_ISF12_Msk: u32 = 4096;
pub const HSEM_C2ISR_ISF12: u32 = 4096;
pub const HSEM_C2ISR_ISF13_Pos: u32 = 13;
pub const HSEM_C2ISR_ISF13_Msk: u32 = 8192;
pub const HSEM_C2ISR_ISF13: u32 = 8192;
pub const HSEM_C2ISR_ISF14_Pos: u32 = 14;
pub const HSEM_C2ISR_ISF14_Msk: u32 = 16384;
pub const HSEM_C2ISR_ISF14: u32 = 16384;
pub const HSEM_C2ISR_ISF15_Pos: u32 = 15;
pub const HSEM_C2ISR_ISF15_Msk: u32 = 32768;
pub const HSEM_C2ISR_ISF15: u32 = 32768;
pub const HSEM_C2ISR_ISF16_Pos: u32 = 16;
pub const HSEM_C2ISR_ISF16_Msk: u32 = 65536;
pub const HSEM_C2ISR_ISF16: u32 = 65536;
pub const HSEM_C2ISR_ISF17_Pos: u32 = 17;
pub const HSEM_C2ISR_ISF17_Msk: u32 = 131072;
pub const HSEM_C2ISR_ISF17: u32 = 131072;
pub const HSEM_C2ISR_ISF18_Pos: u32 = 18;
pub const HSEM_C2ISR_ISF18_Msk: u32 = 262144;
pub const HSEM_C2ISR_ISF18: u32 = 262144;
pub const HSEM_C2ISR_ISF19_Pos: u32 = 19;
pub const HSEM_C2ISR_ISF19_Msk: u32 = 524288;
pub const HSEM_C2ISR_ISF19: u32 = 524288;
pub const HSEM_C2ISR_ISF20_Pos: u32 = 20;
pub const HSEM_C2ISR_ISF20_Msk: u32 = 1048576;
pub const HSEM_C2ISR_ISF20: u32 = 1048576;
pub const HSEM_C2ISR_ISF21_Pos: u32 = 21;
pub const HSEM_C2ISR_ISF21_Msk: u32 = 2097152;
pub const HSEM_C2ISR_ISF21: u32 = 2097152;
pub const HSEM_C2ISR_ISF22_Pos: u32 = 22;
pub const HSEM_C2ISR_ISF22_Msk: u32 = 4194304;
pub const HSEM_C2ISR_ISF22: u32 = 4194304;
pub const HSEM_C2ISR_ISF23_Pos: u32 = 23;
pub const HSEM_C2ISR_ISF23_Msk: u32 = 8388608;
pub const HSEM_C2ISR_ISF23: u32 = 8388608;
pub const HSEM_C2ISR_ISF24_Pos: u32 = 24;
pub const HSEM_C2ISR_ISF24_Msk: u32 = 16777216;
pub const HSEM_C2ISR_ISF24: u32 = 16777216;
pub const HSEM_C2ISR_ISF25_Pos: u32 = 25;
pub const HSEM_C2ISR_ISF25_Msk: u32 = 33554432;
pub const HSEM_C2ISR_ISF25: u32 = 33554432;
pub const HSEM_C2ISR_ISF26_Pos: u32 = 26;
pub const HSEM_C2ISR_ISF26_Msk: u32 = 67108864;
pub const HSEM_C2ISR_ISF26: u32 = 67108864;
pub const HSEM_C2ISR_ISF27_Pos: u32 = 27;
pub const HSEM_C2ISR_ISF27_Msk: u32 = 134217728;
pub const HSEM_C2ISR_ISF27: u32 = 134217728;
pub const HSEM_C2ISR_ISF28_Pos: u32 = 28;
pub const HSEM_C2ISR_ISF28_Msk: u32 = 268435456;
pub const HSEM_C2ISR_ISF28: u32 = 268435456;
pub const HSEM_C2ISR_ISF29_Pos: u32 = 29;
pub const HSEM_C2ISR_ISF29_Msk: u32 = 536870912;
pub const HSEM_C2ISR_ISF29: u32 = 536870912;
pub const HSEM_C2ISR_ISF30_Pos: u32 = 30;
pub const HSEM_C2ISR_ISF30_Msk: u32 = 1073741824;
pub const HSEM_C2ISR_ISF30: u32 = 1073741824;
pub const HSEM_C2ISR_ISF31_Pos: u32 = 31;
pub const HSEM_C2ISR_ISF31_Msk: u32 = 2147483648;
pub const HSEM_C2ISR_ISF31: u32 = 2147483648;
pub const HSEM_C2MISR_MISF0_Pos: u32 = 0;
pub const HSEM_C2MISR_MISF0_Msk: u32 = 1;
pub const HSEM_C2MISR_MISF0: u32 = 1;
pub const HSEM_C2MISR_MISF1_Pos: u32 = 1;
pub const HSEM_C2MISR_MISF1_Msk: u32 = 2;
pub const HSEM_C2MISR_MISF1: u32 = 2;
pub const HSEM_C2MISR_MISF2_Pos: u32 = 2;
pub const HSEM_C2MISR_MISF2_Msk: u32 = 4;
pub const HSEM_C2MISR_MISF2: u32 = 4;
pub const HSEM_C2MISR_MISF3_Pos: u32 = 3;
pub const HSEM_C2MISR_MISF3_Msk: u32 = 8;
pub const HSEM_C2MISR_MISF3: u32 = 8;
pub const HSEM_C2MISR_MISF4_Pos: u32 = 4;
pub const HSEM_C2MISR_MISF4_Msk: u32 = 16;
pub const HSEM_C2MISR_MISF4: u32 = 16;
pub const HSEM_C2MISR_MISF5_Pos: u32 = 5;
pub const HSEM_C2MISR_MISF5_Msk: u32 = 32;
pub const HSEM_C2MISR_MISF5: u32 = 32;
pub const HSEM_C2MISR_MISF6_Pos: u32 = 6;
pub const HSEM_C2MISR_MISF6_Msk: u32 = 64;
pub const HSEM_C2MISR_MISF6: u32 = 64;
pub const HSEM_C2MISR_MISF7_Pos: u32 = 7;
pub const HSEM_C2MISR_MISF7_Msk: u32 = 128;
pub const HSEM_C2MISR_MISF7: u32 = 128;
pub const HSEM_C2MISR_MISF8_Pos: u32 = 8;
pub const HSEM_C2MISR_MISF8_Msk: u32 = 256;
pub const HSEM_C2MISR_MISF8: u32 = 256;
pub const HSEM_C2MISR_MISF9_Pos: u32 = 9;
pub const HSEM_C2MISR_MISF9_Msk: u32 = 512;
pub const HSEM_C2MISR_MISF9: u32 = 512;
pub const HSEM_C2MISR_MISF10_Pos: u32 = 10;
pub const HSEM_C2MISR_MISF10_Msk: u32 = 1024;
pub const HSEM_C2MISR_MISF10: u32 = 1024;
pub const HSEM_C2MISR_MISF11_Pos: u32 = 11;
pub const HSEM_C2MISR_MISF11_Msk: u32 = 2048;
pub const HSEM_C2MISR_MISF11: u32 = 2048;
pub const HSEM_C2MISR_MISF12_Pos: u32 = 12;
pub const HSEM_C2MISR_MISF12_Msk: u32 = 4096;
pub const HSEM_C2MISR_MISF12: u32 = 4096;
pub const HSEM_C2MISR_MISF13_Pos: u32 = 13;
pub const HSEM_C2MISR_MISF13_Msk: u32 = 8192;
pub const HSEM_C2MISR_MISF13: u32 = 8192;
pub const HSEM_C2MISR_MISF14_Pos: u32 = 14;
pub const HSEM_C2MISR_MISF14_Msk: u32 = 16384;
pub const HSEM_C2MISR_MISF14: u32 = 16384;
pub const HSEM_C2MISR_MISF15_Pos: u32 = 15;
pub const HSEM_C2MISR_MISF15_Msk: u32 = 32768;
pub const HSEM_C2MISR_MISF15: u32 = 32768;
pub const HSEM_C2MISR_MISF16_Pos: u32 = 16;
pub const HSEM_C2MISR_MISF16_Msk: u32 = 65536;
pub const HSEM_C2MISR_MISF16: u32 = 65536;
pub const HSEM_C2MISR_MISF17_Pos: u32 = 17;
pub const HSEM_C2MISR_MISF17_Msk: u32 = 131072;
pub const HSEM_C2MISR_MISF17: u32 = 131072;
pub const HSEM_C2MISR_MISF18_Pos: u32 = 18;
pub const HSEM_C2MISR_MISF18_Msk: u32 = 262144;
pub const HSEM_C2MISR_MISF18: u32 = 262144;
pub const HSEM_C2MISR_MISF19_Pos: u32 = 19;
pub const HSEM_C2MISR_MISF19_Msk: u32 = 524288;
pub const HSEM_C2MISR_MISF19: u32 = 524288;
pub const HSEM_C2MISR_MISF20_Pos: u32 = 20;
pub const HSEM_C2MISR_MISF20_Msk: u32 = 1048576;
pub const HSEM_C2MISR_MISF20: u32 = 1048576;
pub const HSEM_C2MISR_MISF21_Pos: u32 = 21;
pub const HSEM_C2MISR_MISF21_Msk: u32 = 2097152;
pub const HSEM_C2MISR_MISF21: u32 = 2097152;
pub const HSEM_C2MISR_MISF22_Pos: u32 = 22;
pub const HSEM_C2MISR_MISF22_Msk: u32 = 4194304;
pub const HSEM_C2MISR_MISF22: u32 = 4194304;
pub const HSEM_C2MISR_MISF23_Pos: u32 = 23;
pub const HSEM_C2MISR_MISF23_Msk: u32 = 8388608;
pub const HSEM_C2MISR_MISF23: u32 = 8388608;
pub const HSEM_C2MISR_MISF24_Pos: u32 = 24;
pub const HSEM_C2MISR_MISF24_Msk: u32 = 16777216;
pub const HSEM_C2MISR_MISF24: u32 = 16777216;
pub const HSEM_C2MISR_MISF25_Pos: u32 = 25;
pub const HSEM_C2MISR_MISF25_Msk: u32 = 33554432;
pub const HSEM_C2MISR_MISF25: u32 = 33554432;
pub const HSEM_C2MISR_MISF26_Pos: u32 = 26;
pub const HSEM_C2MISR_MISF26_Msk: u32 = 67108864;
pub const HSEM_C2MISR_MISF26: u32 = 67108864;
pub const HSEM_C2MISR_MISF27_Pos: u32 = 27;
pub const HSEM_C2MISR_MISF27_Msk: u32 = 134217728;
pub const HSEM_C2MISR_MISF27: u32 = 134217728;
pub const HSEM_C2MISR_MISF28_Pos: u32 = 28;
pub const HSEM_C2MISR_MISF28_Msk: u32 = 268435456;
pub const HSEM_C2MISR_MISF28: u32 = 268435456;
pub const HSEM_C2MISR_MISF29_Pos: u32 = 29;
pub const HSEM_C2MISR_MISF29_Msk: u32 = 536870912;
pub const HSEM_C2MISR_MISF29: u32 = 536870912;
pub const HSEM_C2MISR_MISF30_Pos: u32 = 30;
pub const HSEM_C2MISR_MISF30_Msk: u32 = 1073741824;
pub const HSEM_C2MISR_MISF30: u32 = 1073741824;
pub const HSEM_C2MISR_MISF31_Pos: u32 = 31;
pub const HSEM_C2MISR_MISF31_Msk: u32 = 2147483648;
pub const HSEM_C2MISR_MISF31: u32 = 2147483648;
pub const HSEM_CR_COREID_Pos: u32 = 8;
pub const HSEM_CR_COREID_Msk: u32 = 3840;
pub const HSEM_CR_COREID: u32 = 3840;
pub const HSEM_CR_COREID_CPU1: u32 = 1024;
pub const HSEM_CR_COREID_CPU2: u32 = 2048;
pub const HSEM_CR_COREID_CURRENT: u32 = 1024;
pub const HSEM_CR_KEY_Pos: u32 = 16;
pub const HSEM_CR_KEY_Msk: u32 = 4294901760;
pub const HSEM_CR_KEY: u32 = 4294901760;
pub const HSEM_KEYR_KEY_Pos: u32 = 16;
pub const HSEM_KEYR_KEY_Msk: u32 = 4294901760;
pub const HSEM_KEYR_KEY: u32 = 4294901760;
pub const I2C_CR1_PE_Pos: u32 = 0;
pub const I2C_CR1_PE_Msk: u32 = 1;
pub const I2C_CR1_PE: u32 = 1;
pub const I2C_CR1_TXIE_Pos: u32 = 1;
pub const I2C_CR1_TXIE_Msk: u32 = 2;
pub const I2C_CR1_TXIE: u32 = 2;
pub const I2C_CR1_RXIE_Pos: u32 = 2;
pub const I2C_CR1_RXIE_Msk: u32 = 4;
pub const I2C_CR1_RXIE: u32 = 4;
pub const I2C_CR1_ADDRIE_Pos: u32 = 3;
pub const I2C_CR1_ADDRIE_Msk: u32 = 8;
pub const I2C_CR1_ADDRIE: u32 = 8;
pub const I2C_CR1_NACKIE_Pos: u32 = 4;
pub const I2C_CR1_NACKIE_Msk: u32 = 16;
pub const I2C_CR1_NACKIE: u32 = 16;
pub const I2C_CR1_STOPIE_Pos: u32 = 5;
pub const I2C_CR1_STOPIE_Msk: u32 = 32;
pub const I2C_CR1_STOPIE: u32 = 32;
pub const I2C_CR1_TCIE_Pos: u32 = 6;
pub const I2C_CR1_TCIE_Msk: u32 = 64;
pub const I2C_CR1_TCIE: u32 = 64;
pub const I2C_CR1_ERRIE_Pos: u32 = 7;
pub const I2C_CR1_ERRIE_Msk: u32 = 128;
pub const I2C_CR1_ERRIE: u32 = 128;
pub const I2C_CR1_DNF_Pos: u32 = 8;
pub const I2C_CR1_DNF_Msk: u32 = 3840;
pub const I2C_CR1_DNF: u32 = 3840;
pub const I2C_CR1_ANFOFF_Pos: u32 = 12;
pub const I2C_CR1_ANFOFF_Msk: u32 = 4096;
pub const I2C_CR1_ANFOFF: u32 = 4096;
pub const I2C_CR1_SWRST_Pos: u32 = 13;
pub const I2C_CR1_SWRST_Msk: u32 = 8192;
pub const I2C_CR1_SWRST: u32 = 8192;
pub const I2C_CR1_TXDMAEN_Pos: u32 = 14;
pub const I2C_CR1_TXDMAEN_Msk: u32 = 16384;
pub const I2C_CR1_TXDMAEN: u32 = 16384;
pub const I2C_CR1_RXDMAEN_Pos: u32 = 15;
pub const I2C_CR1_RXDMAEN_Msk: u32 = 32768;
pub const I2C_CR1_RXDMAEN: u32 = 32768;
pub const I2C_CR1_SBC_Pos: u32 = 16;
pub const I2C_CR1_SBC_Msk: u32 = 65536;
pub const I2C_CR1_SBC: u32 = 65536;
pub const I2C_CR1_NOSTRETCH_Pos: u32 = 17;
pub const I2C_CR1_NOSTRETCH_Msk: u32 = 131072;
pub const I2C_CR1_NOSTRETCH: u32 = 131072;
pub const I2C_CR1_WUPEN_Pos: u32 = 18;
pub const I2C_CR1_WUPEN_Msk: u32 = 262144;
pub const I2C_CR1_WUPEN: u32 = 262144;
pub const I2C_CR1_GCEN_Pos: u32 = 19;
pub const I2C_CR1_GCEN_Msk: u32 = 524288;
pub const I2C_CR1_GCEN: u32 = 524288;
pub const I2C_CR1_SMBHEN_Pos: u32 = 20;
pub const I2C_CR1_SMBHEN_Msk: u32 = 1048576;
pub const I2C_CR1_SMBHEN: u32 = 1048576;
pub const I2C_CR1_SMBDEN_Pos: u32 = 21;
pub const I2C_CR1_SMBDEN_Msk: u32 = 2097152;
pub const I2C_CR1_SMBDEN: u32 = 2097152;
pub const I2C_CR1_ALERTEN_Pos: u32 = 22;
pub const I2C_CR1_ALERTEN_Msk: u32 = 4194304;
pub const I2C_CR1_ALERTEN: u32 = 4194304;
pub const I2C_CR1_PECEN_Pos: u32 = 23;
pub const I2C_CR1_PECEN_Msk: u32 = 8388608;
pub const I2C_CR1_PECEN: u32 = 8388608;
pub const I2C_CR2_SADD_Pos: u32 = 0;
pub const I2C_CR2_SADD_Msk: u32 = 1023;
pub const I2C_CR2_SADD: u32 = 1023;
pub const I2C_CR2_RD_WRN_Pos: u32 = 10;
pub const I2C_CR2_RD_WRN_Msk: u32 = 1024;
pub const I2C_CR2_RD_WRN: u32 = 1024;
pub const I2C_CR2_ADD10_Pos: u32 = 11;
pub const I2C_CR2_ADD10_Msk: u32 = 2048;
pub const I2C_CR2_ADD10: u32 = 2048;
pub const I2C_CR2_HEAD10R_Pos: u32 = 12;
pub const I2C_CR2_HEAD10R_Msk: u32 = 4096;
pub const I2C_CR2_HEAD10R: u32 = 4096;
pub const I2C_CR2_START_Pos: u32 = 13;
pub const I2C_CR2_START_Msk: u32 = 8192;
pub const I2C_CR2_START: u32 = 8192;
pub const I2C_CR2_STOP_Pos: u32 = 14;
pub const I2C_CR2_STOP_Msk: u32 = 16384;
pub const I2C_CR2_STOP: u32 = 16384;
pub const I2C_CR2_NACK_Pos: u32 = 15;
pub const I2C_CR2_NACK_Msk: u32 = 32768;
pub const I2C_CR2_NACK: u32 = 32768;
pub const I2C_CR2_NBYTES_Pos: u32 = 16;
pub const I2C_CR2_NBYTES_Msk: u32 = 16711680;
pub const I2C_CR2_NBYTES: u32 = 16711680;
pub const I2C_CR2_RELOAD_Pos: u32 = 24;
pub const I2C_CR2_RELOAD_Msk: u32 = 16777216;
pub const I2C_CR2_RELOAD: u32 = 16777216;
pub const I2C_CR2_AUTOEND_Pos: u32 = 25;
pub const I2C_CR2_AUTOEND_Msk: u32 = 33554432;
pub const I2C_CR2_AUTOEND: u32 = 33554432;
pub const I2C_CR2_PECBYTE_Pos: u32 = 26;
pub const I2C_CR2_PECBYTE_Msk: u32 = 67108864;
pub const I2C_CR2_PECBYTE: u32 = 67108864;
pub const I2C_OAR1_OA1_Pos: u32 = 0;
pub const I2C_OAR1_OA1_Msk: u32 = 1023;
pub const I2C_OAR1_OA1: u32 = 1023;
pub const I2C_OAR1_OA1MODE_Pos: u32 = 10;
pub const I2C_OAR1_OA1MODE_Msk: u32 = 1024;
pub const I2C_OAR1_OA1MODE: u32 = 1024;
pub const I2C_OAR1_OA1EN_Pos: u32 = 15;
pub const I2C_OAR1_OA1EN_Msk: u32 = 32768;
pub const I2C_OAR1_OA1EN: u32 = 32768;
pub const I2C_OAR2_OA2_Pos: u32 = 1;
pub const I2C_OAR2_OA2_Msk: u32 = 254;
pub const I2C_OAR2_OA2: u32 = 254;
pub const I2C_OAR2_OA2MSK_Pos: u32 = 8;
pub const I2C_OAR2_OA2MSK_Msk: u32 = 1792;
pub const I2C_OAR2_OA2MSK: u32 = 1792;
pub const I2C_OAR2_OA2NOMASK: u32 = 0;
pub const I2C_OAR2_OA2MASK01_Pos: u32 = 8;
pub const I2C_OAR2_OA2MASK01_Msk: u32 = 256;
pub const I2C_OAR2_OA2MASK01: u32 = 256;
pub const I2C_OAR2_OA2MASK02_Pos: u32 = 9;
pub const I2C_OAR2_OA2MASK02_Msk: u32 = 512;
pub const I2C_OAR2_OA2MASK02: u32 = 512;
pub const I2C_OAR2_OA2MASK03_Pos: u32 = 8;
pub const I2C_OAR2_OA2MASK03_Msk: u32 = 768;
pub const I2C_OAR2_OA2MASK03: u32 = 768;
pub const I2C_OAR2_OA2MASK04_Pos: u32 = 10;
pub const I2C_OAR2_OA2MASK04_Msk: u32 = 1024;
pub const I2C_OAR2_OA2MASK04: u32 = 1024;
pub const I2C_OAR2_OA2MASK05_Pos: u32 = 8;
pub const I2C_OAR2_OA2MASK05_Msk: u32 = 1280;
pub const I2C_OAR2_OA2MASK05: u32 = 1280;
pub const I2C_OAR2_OA2MASK06_Pos: u32 = 9;
pub const I2C_OAR2_OA2MASK06_Msk: u32 = 1536;
pub const I2C_OAR2_OA2MASK06: u32 = 1536;
pub const I2C_OAR2_OA2MASK07_Pos: u32 = 8;
pub const I2C_OAR2_OA2MASK07_Msk: u32 = 1792;
pub const I2C_OAR2_OA2MASK07: u32 = 1792;
pub const I2C_OAR2_OA2EN_Pos: u32 = 15;
pub const I2C_OAR2_OA2EN_Msk: u32 = 32768;
pub const I2C_OAR2_OA2EN: u32 = 32768;
pub const I2C_TIMINGR_SCLL_Pos: u32 = 0;
pub const I2C_TIMINGR_SCLL_Msk: u32 = 255;
pub const I2C_TIMINGR_SCLL: u32 = 255;
pub const I2C_TIMINGR_SCLH_Pos: u32 = 8;
pub const I2C_TIMINGR_SCLH_Msk: u32 = 65280;
pub const I2C_TIMINGR_SCLH: u32 = 65280;
pub const I2C_TIMINGR_SDADEL_Pos: u32 = 16;
pub const I2C_TIMINGR_SDADEL_Msk: u32 = 983040;
pub const I2C_TIMINGR_SDADEL: u32 = 983040;
pub const I2C_TIMINGR_SCLDEL_Pos: u32 = 20;
pub const I2C_TIMINGR_SCLDEL_Msk: u32 = 15728640;
pub const I2C_TIMINGR_SCLDEL: u32 = 15728640;
pub const I2C_TIMINGR_PRESC_Pos: u32 = 28;
pub const I2C_TIMINGR_PRESC_Msk: u32 = 4026531840;
pub const I2C_TIMINGR_PRESC: u32 = 4026531840;
pub const I2C_TIMEOUTR_TIMEOUTA_Pos: u32 = 0;
pub const I2C_TIMEOUTR_TIMEOUTA_Msk: u32 = 4095;
pub const I2C_TIMEOUTR_TIMEOUTA: u32 = 4095;
pub const I2C_TIMEOUTR_TIDLE_Pos: u32 = 12;
pub const I2C_TIMEOUTR_TIDLE_Msk: u32 = 4096;
pub const I2C_TIMEOUTR_TIDLE: u32 = 4096;
pub const I2C_TIMEOUTR_TIMOUTEN_Pos: u32 = 15;
pub const I2C_TIMEOUTR_TIMOUTEN_Msk: u32 = 32768;
pub const I2C_TIMEOUTR_TIMOUTEN: u32 = 32768;
pub const I2C_TIMEOUTR_TIMEOUTB_Pos: u32 = 16;
pub const I2C_TIMEOUTR_TIMEOUTB_Msk: u32 = 268369920;
pub const I2C_TIMEOUTR_TIMEOUTB: u32 = 268369920;
pub const I2C_TIMEOUTR_TEXTEN_Pos: u32 = 31;
pub const I2C_TIMEOUTR_TEXTEN_Msk: u32 = 2147483648;
pub const I2C_TIMEOUTR_TEXTEN: u32 = 2147483648;
pub const I2C_ISR_TXE_Pos: u32 = 0;
pub const I2C_ISR_TXE_Msk: u32 = 1;
pub const I2C_ISR_TXE: u32 = 1;
pub const I2C_ISR_TXIS_Pos: u32 = 1;
pub const I2C_ISR_TXIS_Msk: u32 = 2;
pub const I2C_ISR_TXIS: u32 = 2;
pub const I2C_ISR_RXNE_Pos: u32 = 2;
pub const I2C_ISR_RXNE_Msk: u32 = 4;
pub const I2C_ISR_RXNE: u32 = 4;
pub const I2C_ISR_ADDR_Pos: u32 = 3;
pub const I2C_ISR_ADDR_Msk: u32 = 8;
pub const I2C_ISR_ADDR: u32 = 8;
pub const I2C_ISR_NACKF_Pos: u32 = 4;
pub const I2C_ISR_NACKF_Msk: u32 = 16;
pub const I2C_ISR_NACKF: u32 = 16;
pub const I2C_ISR_STOPF_Pos: u32 = 5;
pub const I2C_ISR_STOPF_Msk: u32 = 32;
pub const I2C_ISR_STOPF: u32 = 32;
pub const I2C_ISR_TC_Pos: u32 = 6;
pub const I2C_ISR_TC_Msk: u32 = 64;
pub const I2C_ISR_TC: u32 = 64;
pub const I2C_ISR_TCR_Pos: u32 = 7;
pub const I2C_ISR_TCR_Msk: u32 = 128;
pub const I2C_ISR_TCR: u32 = 128;
pub const I2C_ISR_BERR_Pos: u32 = 8;
pub const I2C_ISR_BERR_Msk: u32 = 256;
pub const I2C_ISR_BERR: u32 = 256;
pub const I2C_ISR_ARLO_Pos: u32 = 9;
pub const I2C_ISR_ARLO_Msk: u32 = 512;
pub const I2C_ISR_ARLO: u32 = 512;
pub const I2C_ISR_OVR_Pos: u32 = 10;
pub const I2C_ISR_OVR_Msk: u32 = 1024;
pub const I2C_ISR_OVR: u32 = 1024;
pub const I2C_ISR_PECERR_Pos: u32 = 11;
pub const I2C_ISR_PECERR_Msk: u32 = 2048;
pub const I2C_ISR_PECERR: u32 = 2048;
pub const I2C_ISR_TIMEOUT_Pos: u32 = 12;
pub const I2C_ISR_TIMEOUT_Msk: u32 = 4096;
pub const I2C_ISR_TIMEOUT: u32 = 4096;
pub const I2C_ISR_ALERT_Pos: u32 = 13;
pub const I2C_ISR_ALERT_Msk: u32 = 8192;
pub const I2C_ISR_ALERT: u32 = 8192;
pub const I2C_ISR_BUSY_Pos: u32 = 15;
pub const I2C_ISR_BUSY_Msk: u32 = 32768;
pub const I2C_ISR_BUSY: u32 = 32768;
pub const I2C_ISR_DIR_Pos: u32 = 16;
pub const I2C_ISR_DIR_Msk: u32 = 65536;
pub const I2C_ISR_DIR: u32 = 65536;
pub const I2C_ISR_ADDCODE_Pos: u32 = 17;
pub const I2C_ISR_ADDCODE_Msk: u32 = 16646144;
pub const I2C_ISR_ADDCODE: u32 = 16646144;
pub const I2C_ICR_ADDRCF_Pos: u32 = 3;
pub const I2C_ICR_ADDRCF_Msk: u32 = 8;
pub const I2C_ICR_ADDRCF: u32 = 8;
pub const I2C_ICR_NACKCF_Pos: u32 = 4;
pub const I2C_ICR_NACKCF_Msk: u32 = 16;
pub const I2C_ICR_NACKCF: u32 = 16;
pub const I2C_ICR_STOPCF_Pos: u32 = 5;
pub const I2C_ICR_STOPCF_Msk: u32 = 32;
pub const I2C_ICR_STOPCF: u32 = 32;
pub const I2C_ICR_BERRCF_Pos: u32 = 8;
pub const I2C_ICR_BERRCF_Msk: u32 = 256;
pub const I2C_ICR_BERRCF: u32 = 256;
pub const I2C_ICR_ARLOCF_Pos: u32 = 9;
pub const I2C_ICR_ARLOCF_Msk: u32 = 512;
pub const I2C_ICR_ARLOCF: u32 = 512;
pub const I2C_ICR_OVRCF_Pos: u32 = 10;
pub const I2C_ICR_OVRCF_Msk: u32 = 1024;
pub const I2C_ICR_OVRCF: u32 = 1024;
pub const I2C_ICR_PECCF_Pos: u32 = 11;
pub const I2C_ICR_PECCF_Msk: u32 = 2048;
pub const I2C_ICR_PECCF: u32 = 2048;
pub const I2C_ICR_TIMOUTCF_Pos: u32 = 12;
pub const I2C_ICR_TIMOUTCF_Msk: u32 = 4096;
pub const I2C_ICR_TIMOUTCF: u32 = 4096;
pub const I2C_ICR_ALERTCF_Pos: u32 = 13;
pub const I2C_ICR_ALERTCF_Msk: u32 = 8192;
pub const I2C_ICR_ALERTCF: u32 = 8192;
pub const I2C_PECR_PEC_Pos: u32 = 0;
pub const I2C_PECR_PEC_Msk: u32 = 255;
pub const I2C_PECR_PEC: u32 = 255;
pub const I2C_RXDR_RXDATA_Pos: u32 = 0;
pub const I2C_RXDR_RXDATA_Msk: u32 = 255;
pub const I2C_RXDR_RXDATA: u32 = 255;
pub const I2C_TXDR_TXDATA_Pos: u32 = 0;
pub const I2C_TXDR_TXDATA_Msk: u32 = 255;
pub const I2C_TXDR_TXDATA: u32 = 255;
pub const IWDG_KR_KEY_Pos: u32 = 0;
pub const IWDG_KR_KEY_Msk: u32 = 65535;
pub const IWDG_KR_KEY: u32 = 65535;
pub const IWDG_PR_PR_Pos: u32 = 0;
pub const IWDG_PR_PR_Msk: u32 = 7;
pub const IWDG_PR_PR: u32 = 7;
pub const IWDG_PR_PR_0: u32 = 1;
pub const IWDG_PR_PR_1: u32 = 2;
pub const IWDG_PR_PR_2: u32 = 4;
pub const IWDG_RLR_RL_Pos: u32 = 0;
pub const IWDG_RLR_RL_Msk: u32 = 4095;
pub const IWDG_RLR_RL: u32 = 4095;
pub const IWDG_SR_PVU_Pos: u32 = 0;
pub const IWDG_SR_PVU_Msk: u32 = 1;
pub const IWDG_SR_PVU: u32 = 1;
pub const IWDG_SR_RVU_Pos: u32 = 1;
pub const IWDG_SR_RVU_Msk: u32 = 2;
pub const IWDG_SR_RVU: u32 = 2;
pub const IWDG_SR_WVU_Pos: u32 = 2;
pub const IWDG_SR_WVU_Msk: u32 = 4;
pub const IWDG_SR_WVU: u32 = 4;
pub const IWDG_WINR_WIN_Pos: u32 = 0;
pub const IWDG_WINR_WIN_Msk: u32 = 4095;
pub const IWDG_WINR_WIN: u32 = 4095;
pub const PWR_CR1_LPMS_Pos: u32 = 0;
pub const PWR_CR1_LPMS_Msk: u32 = 7;
pub const PWR_CR1_LPMS: u32 = 7;
pub const PWR_CR1_LPMS_0: u32 = 1;
pub const PWR_CR1_LPMS_1: u32 = 2;
pub const PWR_CR1_LPMS_2: u32 = 4;
pub const PWR_CR1_FPDR_Pos: u32 = 4;
pub const PWR_CR1_FPDR_Msk: u32 = 16;
pub const PWR_CR1_FPDR: u32 = 16;
pub const PWR_CR1_FPDS_Pos: u32 = 5;
pub const PWR_CR1_FPDS_Msk: u32 = 32;
pub const PWR_CR1_FPDS: u32 = 32;
pub const PWR_CR1_DBP_Pos: u32 = 8;
pub const PWR_CR1_DBP_Msk: u32 = 256;
pub const PWR_CR1_DBP: u32 = 256;
pub const PWR_CR1_VOS_Pos: u32 = 9;
pub const PWR_CR1_VOS_Msk: u32 = 1536;
pub const PWR_CR1_VOS: u32 = 1536;
pub const PWR_CR1_VOS_0: u32 = 512;
pub const PWR_CR1_VOS_1: u32 = 1024;
pub const PWR_CR1_LPR_Pos: u32 = 14;
pub const PWR_CR1_LPR_Msk: u32 = 16384;
pub const PWR_CR1_LPR: u32 = 16384;
pub const PWR_CR2_PVDE_Pos: u32 = 0;
pub const PWR_CR2_PVDE_Msk: u32 = 1;
pub const PWR_CR2_PVDE: u32 = 1;
pub const PWR_CR2_PLS_Pos: u32 = 1;
pub const PWR_CR2_PLS_Msk: u32 = 14;
pub const PWR_CR2_PLS: u32 = 14;
pub const PWR_CR2_PLS_0: u32 = 2;
pub const PWR_CR2_PLS_1: u32 = 4;
pub const PWR_CR2_PLS_2: u32 = 8;
pub const PWR_CR2_PVME_Pos: u32 = 4;
pub const PWR_CR2_PVME_Msk: u32 = 80;
pub const PWR_CR2_PVME: u32 = 80;
pub const PWR_CR2_PVME1_Pos: u32 = 4;
pub const PWR_CR2_PVME1_Msk: u32 = 16;
pub const PWR_CR2_PVME1: u32 = 16;
pub const PWR_CR2_PVME3_Pos: u32 = 6;
pub const PWR_CR2_PVME3_Msk: u32 = 64;
pub const PWR_CR2_PVME3: u32 = 64;
pub const PWR_CR2_USV_Pos: u32 = 10;
pub const PWR_CR2_USV_Msk: u32 = 1024;
pub const PWR_CR2_USV: u32 = 1024;
pub const PWR_CR3_EWUP_Pos: u32 = 0;
pub const PWR_CR3_EWUP_Msk: u32 = 31;
pub const PWR_CR3_EWUP: u32 = 31;
pub const PWR_CR3_EWUP1_Pos: u32 = 0;
pub const PWR_CR3_EWUP1_Msk: u32 = 1;
pub const PWR_CR3_EWUP1: u32 = 1;
pub const PWR_CR3_EWUP2_Pos: u32 = 1;
pub const PWR_CR3_EWUP2_Msk: u32 = 2;
pub const PWR_CR3_EWUP2: u32 = 2;
pub const PWR_CR3_EWUP3_Pos: u32 = 2;
pub const PWR_CR3_EWUP3_Msk: u32 = 4;
pub const PWR_CR3_EWUP3: u32 = 4;
pub const PWR_CR3_EWUP4_Pos: u32 = 3;
pub const PWR_CR3_EWUP4_Msk: u32 = 8;
pub const PWR_CR3_EWUP4: u32 = 8;
pub const PWR_CR3_EWUP5_Pos: u32 = 4;
pub const PWR_CR3_EWUP5_Msk: u32 = 16;
pub const PWR_CR3_EWUP5: u32 = 16;
pub const PWR_CR3_EBORHSMPSFB_Pos: u32 = 8;
pub const PWR_CR3_EBORHSMPSFB_Msk: u32 = 256;
pub const PWR_CR3_EBORHSMPSFB: u32 = 256;
pub const PWR_CR3_RRS_Pos: u32 = 9;
pub const PWR_CR3_RRS_Msk: u32 = 512;
pub const PWR_CR3_RRS: u32 = 512;
pub const PWR_CR3_APC_Pos: u32 = 10;
pub const PWR_CR3_APC_Msk: u32 = 1024;
pub const PWR_CR3_APC: u32 = 1024;
pub const PWR_CR3_ECRPE_Pos: u32 = 11;
pub const PWR_CR3_ECRPE_Msk: u32 = 2048;
pub const PWR_CR3_ECRPE: u32 = 2048;
pub const PWR_CR3_EBLEA_Pos: u32 = 12;
pub const PWR_CR3_EBLEA_Msk: u32 = 4096;
pub const PWR_CR3_EBLEA: u32 = 4096;
pub const PWR_CR3_E802A_Pos: u32 = 13;
pub const PWR_CR3_E802A_Msk: u32 = 8192;
pub const PWR_CR3_E802A: u32 = 8192;
pub const PWR_CR3_EC2H_Pos: u32 = 14;
pub const PWR_CR3_EC2H_Msk: u32 = 16384;
pub const PWR_CR3_EC2H: u32 = 16384;
pub const PWR_CR3_EIWUL_Pos: u32 = 15;
pub const PWR_CR3_EIWUL_Msk: u32 = 32768;
pub const PWR_CR3_EIWUL: u32 = 32768;
pub const PWR_CR4_WP_Pos: u32 = 0;
pub const PWR_CR4_WP_Msk: u32 = 31;
pub const PWR_CR4_WP: u32 = 31;
pub const PWR_CR4_WP1_Pos: u32 = 0;
pub const PWR_CR4_WP1_Msk: u32 = 1;
pub const PWR_CR4_WP1: u32 = 1;
pub const PWR_CR4_WP2_Pos: u32 = 1;
pub const PWR_CR4_WP2_Msk: u32 = 2;
pub const PWR_CR4_WP2: u32 = 2;
pub const PWR_CR4_WP3_Pos: u32 = 2;
pub const PWR_CR4_WP3_Msk: u32 = 4;
pub const PWR_CR4_WP3: u32 = 4;
pub const PWR_CR4_WP4_Pos: u32 = 3;
pub const PWR_CR4_WP4_Msk: u32 = 8;
pub const PWR_CR4_WP4: u32 = 8;
pub const PWR_CR4_WP5_Pos: u32 = 4;
pub const PWR_CR4_WP5_Msk: u32 = 16;
pub const PWR_CR4_WP5: u32 = 16;
pub const PWR_CR4_VBE_Pos: u32 = 8;
pub const PWR_CR4_VBE_Msk: u32 = 256;
pub const PWR_CR4_VBE: u32 = 256;
pub const PWR_CR4_VBRS_Pos: u32 = 9;
pub const PWR_CR4_VBRS_Msk: u32 = 512;
pub const PWR_CR4_VBRS: u32 = 512;
pub const PWR_CR4_C2BOOT_Pos: u32 = 15;
pub const PWR_CR4_C2BOOT_Msk: u32 = 32768;
pub const PWR_CR4_C2BOOT: u32 = 32768;
pub const PWR_SR1_WUF_Pos: u32 = 0;
pub const PWR_SR1_WUF_Msk: u32 = 31;
pub const PWR_SR1_WUF: u32 = 31;
pub const PWR_SR1_WUF1_Pos: u32 = 0;
pub const PWR_SR1_WUF1_Msk: u32 = 1;
pub const PWR_SR1_WUF1: u32 = 1;
pub const PWR_SR1_WUF2_Pos: u32 = 1;
pub const PWR_SR1_WUF2_Msk: u32 = 2;
pub const PWR_SR1_WUF2: u32 = 2;
pub const PWR_SR1_WUF3_Pos: u32 = 2;
pub const PWR_SR1_WUF3_Msk: u32 = 4;
pub const PWR_SR1_WUF3: u32 = 4;
pub const PWR_SR1_WUF4_Pos: u32 = 3;
pub const PWR_SR1_WUF4_Msk: u32 = 8;
pub const PWR_SR1_WUF4: u32 = 8;
pub const PWR_SR1_WUF5_Pos: u32 = 4;
pub const PWR_SR1_WUF5_Msk: u32 = 16;
pub const PWR_SR1_WUF5: u32 = 16;
pub const PWR_SR1_SMPSFBF_Pos: u32 = 7;
pub const PWR_SR1_SMPSFBF_Msk: u32 = 128;
pub const PWR_SR1_SMPSFBF: u32 = 128;
pub const PWR_SR1_BORHF_Pos: u32 = 8;
pub const PWR_SR1_BORHF_Msk: u32 = 256;
pub const PWR_SR1_BORHF: u32 = 256;
pub const PWR_SR1_BLEWUF_Pos: u32 = 9;
pub const PWR_SR1_BLEWUF_Msk: u32 = 512;
pub const PWR_SR1_BLEWUF: u32 = 512;
pub const PWR_SR1_802WUF_Pos: u32 = 10;
pub const PWR_SR1_802WUF_Msk: u32 = 1024;
pub const PWR_SR1_802WUF: u32 = 1024;
pub const PWR_SR1_CRPEF_Pos: u32 = 11;
pub const PWR_SR1_CRPEF_Msk: u32 = 2048;
pub const PWR_SR1_CRPEF: u32 = 2048;
pub const PWR_SR1_BLEAF_Pos: u32 = 12;
pub const PWR_SR1_BLEAF_Msk: u32 = 4096;
pub const PWR_SR1_BLEAF: u32 = 4096;
pub const PWR_SR1_802AF_Pos: u32 = 13;
pub const PWR_SR1_802AF_Msk: u32 = 8192;
pub const PWR_SR1_802AF: u32 = 8192;
pub const PWR_SR1_C2HF_Pos: u32 = 14;
pub const PWR_SR1_C2HF_Msk: u32 = 16384;
pub const PWR_SR1_C2HF: u32 = 16384;
pub const PWR_SR1_WUFI_Pos: u32 = 15;
pub const PWR_SR1_WUFI_Msk: u32 = 32768;
pub const PWR_SR1_WUFI: u32 = 32768;
pub const PWR_SR2_SMPSBF_Pos: u32 = 0;
pub const PWR_SR2_SMPSBF_Msk: u32 = 1;
pub const PWR_SR2_SMPSBF: u32 = 1;
pub const PWR_SR2_SMPSF_Pos: u32 = 1;
pub const PWR_SR2_SMPSF_Msk: u32 = 2;
pub const PWR_SR2_SMPSF: u32 = 2;
pub const PWR_SR2_REGLPS_Pos: u32 = 8;
pub const PWR_SR2_REGLPS_Msk: u32 = 256;
pub const PWR_SR2_REGLPS: u32 = 256;
pub const PWR_SR2_REGLPF_Pos: u32 = 9;
pub const PWR_SR2_REGLPF_Msk: u32 = 512;
pub const PWR_SR2_REGLPF: u32 = 512;
pub const PWR_SR2_VOSF_Pos: u32 = 10;
pub const PWR_SR2_VOSF_Msk: u32 = 1024;
pub const PWR_SR2_VOSF: u32 = 1024;
pub const PWR_SR2_PVDO_Pos: u32 = 11;
pub const PWR_SR2_PVDO_Msk: u32 = 2048;
pub const PWR_SR2_PVDO: u32 = 2048;
pub const PWR_SR2_PVMO_Pos: u32 = 12;
pub const PWR_SR2_PVMO_Msk: u32 = 20480;
pub const PWR_SR2_PVMO: u32 = 20480;
pub const PWR_SR2_PVMO1_Pos: u32 = 12;
pub const PWR_SR2_PVMO1_Msk: u32 = 4096;
pub const PWR_SR2_PVMO1: u32 = 4096;
pub const PWR_SR2_PVMO3_Pos: u32 = 14;
pub const PWR_SR2_PVMO3_Msk: u32 = 16384;
pub const PWR_SR2_PVMO3: u32 = 16384;
pub const PWR_SCR_CWUF_Pos: u32 = 0;
pub const PWR_SCR_CWUF_Msk: u32 = 31;
pub const PWR_SCR_CWUF: u32 = 31;
pub const PWR_SCR_CWUF1_Pos: u32 = 0;
pub const PWR_SCR_CWUF1_Msk: u32 = 1;
pub const PWR_SCR_CWUF1: u32 = 1;
pub const PWR_SCR_CWUF2_Pos: u32 = 1;
pub const PWR_SCR_CWUF2_Msk: u32 = 2;
pub const PWR_SCR_CWUF2: u32 = 2;
pub const PWR_SCR_CWUF3_Pos: u32 = 2;
pub const PWR_SCR_CWUF3_Msk: u32 = 4;
pub const PWR_SCR_CWUF3: u32 = 4;
pub const PWR_SCR_CWUF4_Pos: u32 = 3;
pub const PWR_SCR_CWUF4_Msk: u32 = 8;
pub const PWR_SCR_CWUF4: u32 = 8;
pub const PWR_SCR_CWUF5_Pos: u32 = 4;
pub const PWR_SCR_CWUF5_Msk: u32 = 16;
pub const PWR_SCR_CWUF5: u32 = 16;
pub const PWR_SCR_CSMPSFBF_Pos: u32 = 7;
pub const PWR_SCR_CSMPSFBF_Msk: u32 = 128;
pub const PWR_SCR_CSMPSFBF: u32 = 128;
pub const PWR_SCR_CBORHF_Pos: u32 = 8;
pub const PWR_SCR_CBORHF_Msk: u32 = 256;
pub const PWR_SCR_CBORHF: u32 = 256;
pub const PWR_SCR_CBLEWUF_Pos: u32 = 9;
pub const PWR_SCR_CBLEWUF_Msk: u32 = 512;
pub const PWR_SCR_CBLEWUF: u32 = 512;
pub const PWR_SCR_C802WUF_Pos: u32 = 10;
pub const PWR_SCR_C802WUF_Msk: u32 = 1024;
pub const PWR_SCR_C802WUF: u32 = 1024;
pub const PWR_SCR_CCRPEF_Pos: u32 = 11;
pub const PWR_SCR_CCRPEF_Msk: u32 = 2048;
pub const PWR_SCR_CCRPEF: u32 = 2048;
pub const PWR_SCR_CBLEAF_Pos: u32 = 12;
pub const PWR_SCR_CBLEAF_Msk: u32 = 4096;
pub const PWR_SCR_CBLEAF: u32 = 4096;
pub const PWR_SCR_C802AF_Pos: u32 = 13;
pub const PWR_SCR_C802AF_Msk: u32 = 8192;
pub const PWR_SCR_C802AF: u32 = 8192;
pub const PWR_SCR_CC2HF_Pos: u32 = 14;
pub const PWR_SCR_CC2HF_Msk: u32 = 16384;
pub const PWR_SCR_CC2HF: u32 = 16384;
pub const PWR_CR5_SMPSVOS_Pos: u32 = 0;
pub const PWR_CR5_SMPSVOS_Msk: u32 = 15;
pub const PWR_CR5_SMPSVOS: u32 = 15;
pub const PWR_CR5_SMPSVOS_0: u32 = 1;
pub const PWR_CR5_SMPSVOS_1: u32 = 2;
pub const PWR_CR5_SMPSVOS_2: u32 = 4;
pub const PWR_CR5_SMPSVOS_3: u32 = 8;
pub const PWR_CR5_SMPSSC_Pos: u32 = 4;
pub const PWR_CR5_SMPSSC_Msk: u32 = 112;
pub const PWR_CR5_SMPSSC: u32 = 112;
pub const PWR_CR5_SMPSSC_0: u32 = 16;
pub const PWR_CR5_SMPSSC_1: u32 = 32;
pub const PWR_CR5_SMPSSC_2: u32 = 64;
pub const PWR_CR5_BORHC_Pos: u32 = 8;
pub const PWR_CR5_BORHC_Msk: u32 = 256;
pub const PWR_CR5_BORHC: u32 = 256;
pub const PWR_CR5_SMPSEN_Pos: u32 = 15;
pub const PWR_CR5_SMPSEN_Msk: u32 = 32768;
pub const PWR_CR5_SMPSEN: u32 = 32768;
pub const PWR_PUCRA_PA0_Pos: u32 = 0;
pub const PWR_PUCRA_PA0_Msk: u32 = 1;
pub const PWR_PUCRA_PA0: u32 = 1;
pub const PWR_PUCRA_PA1_Pos: u32 = 1;
pub const PWR_PUCRA_PA1_Msk: u32 = 2;
pub const PWR_PUCRA_PA1: u32 = 2;
pub const PWR_PUCRA_PA2_Pos: u32 = 2;
pub const PWR_PUCRA_PA2_Msk: u32 = 4;
pub const PWR_PUCRA_PA2: u32 = 4;
pub const PWR_PUCRA_PA3_Pos: u32 = 3;
pub const PWR_PUCRA_PA3_Msk: u32 = 8;
pub const PWR_PUCRA_PA3: u32 = 8;
pub const PWR_PUCRA_PA4_Pos: u32 = 4;
pub const PWR_PUCRA_PA4_Msk: u32 = 16;
pub const PWR_PUCRA_PA4: u32 = 16;
pub const PWR_PUCRA_PA5_Pos: u32 = 5;
pub const PWR_PUCRA_PA5_Msk: u32 = 32;
pub const PWR_PUCRA_PA5: u32 = 32;
pub const PWR_PUCRA_PA6_Pos: u32 = 6;
pub const PWR_PUCRA_PA6_Msk: u32 = 64;
pub const PWR_PUCRA_PA6: u32 = 64;
pub const PWR_PUCRA_PA7_Pos: u32 = 7;
pub const PWR_PUCRA_PA7_Msk: u32 = 128;
pub const PWR_PUCRA_PA7: u32 = 128;
pub const PWR_PUCRA_PA8_Pos: u32 = 8;
pub const PWR_PUCRA_PA8_Msk: u32 = 256;
pub const PWR_PUCRA_PA8: u32 = 256;
pub const PWR_PUCRA_PA9_Pos: u32 = 9;
pub const PWR_PUCRA_PA9_Msk: u32 = 512;
pub const PWR_PUCRA_PA9: u32 = 512;
pub const PWR_PUCRA_PA10_Pos: u32 = 10;
pub const PWR_PUCRA_PA10_Msk: u32 = 1024;
pub const PWR_PUCRA_PA10: u32 = 1024;
pub const PWR_PUCRA_PA11_Pos: u32 = 11;
pub const PWR_PUCRA_PA11_Msk: u32 = 2048;
pub const PWR_PUCRA_PA11: u32 = 2048;
pub const PWR_PUCRA_PA12_Pos: u32 = 12;
pub const PWR_PUCRA_PA12_Msk: u32 = 4096;
pub const PWR_PUCRA_PA12: u32 = 4096;
pub const PWR_PUCRA_PA13_Pos: u32 = 13;
pub const PWR_PUCRA_PA13_Msk: u32 = 8192;
pub const PWR_PUCRA_PA13: u32 = 8192;
pub const PWR_PUCRA_PA15_Pos: u32 = 15;
pub const PWR_PUCRA_PA15_Msk: u32 = 32768;
pub const PWR_PUCRA_PA15: u32 = 32768;
pub const PWR_PDCRA_PA0_Pos: u32 = 0;
pub const PWR_PDCRA_PA0_Msk: u32 = 1;
pub const PWR_PDCRA_PA0: u32 = 1;
pub const PWR_PDCRA_PA1_Pos: u32 = 1;
pub const PWR_PDCRA_PA1_Msk: u32 = 2;
pub const PWR_PDCRA_PA1: u32 = 2;
pub const PWR_PDCRA_PA2_Pos: u32 = 2;
pub const PWR_PDCRA_PA2_Msk: u32 = 4;
pub const PWR_PDCRA_PA2: u32 = 4;
pub const PWR_PDCRA_PA3_Pos: u32 = 3;
pub const PWR_PDCRA_PA3_Msk: u32 = 8;
pub const PWR_PDCRA_PA3: u32 = 8;
pub const PWR_PDCRA_PA4_Pos: u32 = 4;
pub const PWR_PDCRA_PA4_Msk: u32 = 16;
pub const PWR_PDCRA_PA4: u32 = 16;
pub const PWR_PDCRA_PA5_Pos: u32 = 5;
pub const PWR_PDCRA_PA5_Msk: u32 = 32;
pub const PWR_PDCRA_PA5: u32 = 32;
pub const PWR_PDCRA_PA6_Pos: u32 = 6;
pub const PWR_PDCRA_PA6_Msk: u32 = 64;
pub const PWR_PDCRA_PA6: u32 = 64;
pub const PWR_PDCRA_PA7_Pos: u32 = 7;
pub const PWR_PDCRA_PA7_Msk: u32 = 128;
pub const PWR_PDCRA_PA7: u32 = 128;
pub const PWR_PDCRA_PA8_Pos: u32 = 8;
pub const PWR_PDCRA_PA8_Msk: u32 = 256;
pub const PWR_PDCRA_PA8: u32 = 256;
pub const PWR_PDCRA_PA9_Pos: u32 = 9;
pub const PWR_PDCRA_PA9_Msk: u32 = 512;
pub const PWR_PDCRA_PA9: u32 = 512;
pub const PWR_PDCRA_PA10_Pos: u32 = 10;
pub const PWR_PDCRA_PA10_Msk: u32 = 1024;
pub const PWR_PDCRA_PA10: u32 = 1024;
pub const PWR_PDCRA_PA11_Pos: u32 = 11;
pub const PWR_PDCRA_PA11_Msk: u32 = 2048;
pub const PWR_PDCRA_PA11: u32 = 2048;
pub const PWR_PDCRA_PA12_Pos: u32 = 12;
pub const PWR_PDCRA_PA12_Msk: u32 = 4096;
pub const PWR_PDCRA_PA12: u32 = 4096;
pub const PWR_PDCRA_PA14_Pos: u32 = 14;
pub const PWR_PDCRA_PA14_Msk: u32 = 16384;
pub const PWR_PDCRA_PA14: u32 = 16384;
pub const PWR_PUCRB_PB0_Pos: u32 = 0;
pub const PWR_PUCRB_PB0_Msk: u32 = 1;
pub const PWR_PUCRB_PB0: u32 = 1;
pub const PWR_PUCRB_PB1_Pos: u32 = 1;
pub const PWR_PUCRB_PB1_Msk: u32 = 2;
pub const PWR_PUCRB_PB1: u32 = 2;
pub const PWR_PUCRB_PB2_Pos: u32 = 2;
pub const PWR_PUCRB_PB2_Msk: u32 = 4;
pub const PWR_PUCRB_PB2: u32 = 4;
pub const PWR_PUCRB_PB3_Pos: u32 = 3;
pub const PWR_PUCRB_PB3_Msk: u32 = 8;
pub const PWR_PUCRB_PB3: u32 = 8;
pub const PWR_PUCRB_PB4_Pos: u32 = 4;
pub const PWR_PUCRB_PB4_Msk: u32 = 16;
pub const PWR_PUCRB_PB4: u32 = 16;
pub const PWR_PUCRB_PB5_Pos: u32 = 5;
pub const PWR_PUCRB_PB5_Msk: u32 = 32;
pub const PWR_PUCRB_PB5: u32 = 32;
pub const PWR_PUCRB_PB6_Pos: u32 = 6;
pub const PWR_PUCRB_PB6_Msk: u32 = 64;
pub const PWR_PUCRB_PB6: u32 = 64;
pub const PWR_PUCRB_PB7_Pos: u32 = 7;
pub const PWR_PUCRB_PB7_Msk: u32 = 128;
pub const PWR_PUCRB_PB7: u32 = 128;
pub const PWR_PUCRB_PB8_Pos: u32 = 8;
pub const PWR_PUCRB_PB8_Msk: u32 = 256;
pub const PWR_PUCRB_PB8: u32 = 256;
pub const PWR_PUCRB_PB9_Pos: u32 = 9;
pub const PWR_PUCRB_PB9_Msk: u32 = 512;
pub const PWR_PUCRB_PB9: u32 = 512;
pub const PWR_PUCRB_PB10_Pos: u32 = 10;
pub const PWR_PUCRB_PB10_Msk: u32 = 1024;
pub const PWR_PUCRB_PB10: u32 = 1024;
pub const PWR_PUCRB_PB11_Pos: u32 = 11;
pub const PWR_PUCRB_PB11_Msk: u32 = 2048;
pub const PWR_PUCRB_PB11: u32 = 2048;
pub const PWR_PUCRB_PB12_Pos: u32 = 12;
pub const PWR_PUCRB_PB12_Msk: u32 = 4096;
pub const PWR_PUCRB_PB12: u32 = 4096;
pub const PWR_PUCRB_PB13_Pos: u32 = 13;
pub const PWR_PUCRB_PB13_Msk: u32 = 8192;
pub const PWR_PUCRB_PB13: u32 = 8192;
pub const PWR_PUCRB_PB14_Pos: u32 = 14;
pub const PWR_PUCRB_PB14_Msk: u32 = 16384;
pub const PWR_PUCRB_PB14: u32 = 16384;
pub const PWR_PUCRB_PB15_Pos: u32 = 15;
pub const PWR_PUCRB_PB15_Msk: u32 = 32768;
pub const PWR_PUCRB_PB15: u32 = 32768;
pub const PWR_PDCRB_PB0_Pos: u32 = 0;
pub const PWR_PDCRB_PB0_Msk: u32 = 1;
pub const PWR_PDCRB_PB0: u32 = 1;
pub const PWR_PDCRB_PB1_Pos: u32 = 1;
pub const PWR_PDCRB_PB1_Msk: u32 = 2;
pub const PWR_PDCRB_PB1: u32 = 2;
pub const PWR_PDCRB_PB2_Pos: u32 = 2;
pub const PWR_PDCRB_PB2_Msk: u32 = 4;
pub const PWR_PDCRB_PB2: u32 = 4;
pub const PWR_PDCRB_PB3_Pos: u32 = 3;
pub const PWR_PDCRB_PB3_Msk: u32 = 8;
pub const PWR_PDCRB_PB3: u32 = 8;
pub const PWR_PDCRB_PB5_Pos: u32 = 5;
pub const PWR_PDCRB_PB5_Msk: u32 = 32;
pub const PWR_PDCRB_PB5: u32 = 32;
pub const PWR_PDCRB_PB6_Pos: u32 = 6;
pub const PWR_PDCRB_PB6_Msk: u32 = 64;
pub const PWR_PDCRB_PB6: u32 = 64;
pub const PWR_PDCRB_PB7_Pos: u32 = 7;
pub const PWR_PDCRB_PB7_Msk: u32 = 128;
pub const PWR_PDCRB_PB7: u32 = 128;
pub const PWR_PDCRB_PB8_Pos: u32 = 8;
pub const PWR_PDCRB_PB8_Msk: u32 = 256;
pub const PWR_PDCRB_PB8: u32 = 256;
pub const PWR_PDCRB_PB9_Pos: u32 = 9;
pub const PWR_PDCRB_PB9_Msk: u32 = 512;
pub const PWR_PDCRB_PB9: u32 = 512;
pub const PWR_PDCRB_PB10_Pos: u32 = 10;
pub const PWR_PDCRB_PB10_Msk: u32 = 1024;
pub const PWR_PDCRB_PB10: u32 = 1024;
pub const PWR_PDCRB_PB11_Pos: u32 = 11;
pub const PWR_PDCRB_PB11_Msk: u32 = 2048;
pub const PWR_PDCRB_PB11: u32 = 2048;
pub const PWR_PDCRB_PB12_Pos: u32 = 12;
pub const PWR_PDCRB_PB12_Msk: u32 = 4096;
pub const PWR_PDCRB_PB12: u32 = 4096;
pub const PWR_PDCRB_PB13_Pos: u32 = 13;
pub const PWR_PDCRB_PB13_Msk: u32 = 8192;
pub const PWR_PDCRB_PB13: u32 = 8192;
pub const PWR_PDCRB_PB14_Pos: u32 = 14;
pub const PWR_PDCRB_PB14_Msk: u32 = 16384;
pub const PWR_PDCRB_PB14: u32 = 16384;
pub const PWR_PDCRB_PB15_Pos: u32 = 15;
pub const PWR_PDCRB_PB15_Msk: u32 = 32768;
pub const PWR_PDCRB_PB15: u32 = 32768;
pub const PWR_PUCRC_PC0_Pos: u32 = 0;
pub const PWR_PUCRC_PC0_Msk: u32 = 1;
pub const PWR_PUCRC_PC0: u32 = 1;
pub const PWR_PUCRC_PC1_Pos: u32 = 1;
pub const PWR_PUCRC_PC1_Msk: u32 = 2;
pub const PWR_PUCRC_PC1: u32 = 2;
pub const PWR_PUCRC_PC2_Pos: u32 = 2;
pub const PWR_PUCRC_PC2_Msk: u32 = 4;
pub const PWR_PUCRC_PC2: u32 = 4;
pub const PWR_PUCRC_PC3_Pos: u32 = 3;
pub const PWR_PUCRC_PC3_Msk: u32 = 8;
pub const PWR_PUCRC_PC3: u32 = 8;
pub const PWR_PUCRC_PC4_Pos: u32 = 4;
pub const PWR_PUCRC_PC4_Msk: u32 = 16;
pub const PWR_PUCRC_PC4: u32 = 16;
pub const PWR_PUCRC_PC5_Pos: u32 = 5;
pub const PWR_PUCRC_PC5_Msk: u32 = 32;
pub const PWR_PUCRC_PC5: u32 = 32;
pub const PWR_PUCRC_PC6_Pos: u32 = 6;
pub const PWR_PUCRC_PC6_Msk: u32 = 64;
pub const PWR_PUCRC_PC6: u32 = 64;
pub const PWR_PUCRC_PC7_Pos: u32 = 7;
pub const PWR_PUCRC_PC7_Msk: u32 = 128;
pub const PWR_PUCRC_PC7: u32 = 128;
pub const PWR_PUCRC_PC8_Pos: u32 = 8;
pub const PWR_PUCRC_PC8_Msk: u32 = 256;
pub const PWR_PUCRC_PC8: u32 = 256;
pub const PWR_PUCRC_PC9_Pos: u32 = 9;
pub const PWR_PUCRC_PC9_Msk: u32 = 512;
pub const PWR_PUCRC_PC9: u32 = 512;
pub const PWR_PUCRC_PC10_Pos: u32 = 10;
pub const PWR_PUCRC_PC10_Msk: u32 = 1024;
pub const PWR_PUCRC_PC10: u32 = 1024;
pub const PWR_PUCRC_PC11_Pos: u32 = 11;
pub const PWR_PUCRC_PC11_Msk: u32 = 2048;
pub const PWR_PUCRC_PC11: u32 = 2048;
pub const PWR_PUCRC_PC12_Pos: u32 = 12;
pub const PWR_PUCRC_PC12_Msk: u32 = 4096;
pub const PWR_PUCRC_PC12: u32 = 4096;
pub const PWR_PUCRC_PC13_Pos: u32 = 13;
pub const PWR_PUCRC_PC13_Msk: u32 = 8192;
pub const PWR_PUCRC_PC13: u32 = 8192;
pub const PWR_PUCRC_PC14_Pos: u32 = 14;
pub const PWR_PUCRC_PC14_Msk: u32 = 16384;
pub const PWR_PUCRC_PC14: u32 = 16384;
pub const PWR_PUCRC_PC15_Pos: u32 = 15;
pub const PWR_PUCRC_PC15_Msk: u32 = 32768;
pub const PWR_PUCRC_PC15: u32 = 32768;
pub const PWR_PDCRC_PC0_Pos: u32 = 0;
pub const PWR_PDCRC_PC0_Msk: u32 = 1;
pub const PWR_PDCRC_PC0: u32 = 1;
pub const PWR_PDCRC_PC1_Pos: u32 = 1;
pub const PWR_PDCRC_PC1_Msk: u32 = 2;
pub const PWR_PDCRC_PC1: u32 = 2;
pub const PWR_PDCRC_PC2_Pos: u32 = 2;
pub const PWR_PDCRC_PC2_Msk: u32 = 4;
pub const PWR_PDCRC_PC2: u32 = 4;
pub const PWR_PDCRC_PC3_Pos: u32 = 3;
pub const PWR_PDCRC_PC3_Msk: u32 = 8;
pub const PWR_PDCRC_PC3: u32 = 8;
pub const PWR_PDCRC_PC4_Pos: u32 = 4;
pub const PWR_PDCRC_PC4_Msk: u32 = 16;
pub const PWR_PDCRC_PC4: u32 = 16;
pub const PWR_PDCRC_PC5_Pos: u32 = 5;
pub const PWR_PDCRC_PC5_Msk: u32 = 32;
pub const PWR_PDCRC_PC5: u32 = 32;
pub const PWR_PDCRC_PC6_Pos: u32 = 6;
pub const PWR_PDCRC_PC6_Msk: u32 = 64;
pub const PWR_PDCRC_PC6: u32 = 64;
pub const PWR_PDCRC_PC7_Pos: u32 = 7;
pub const PWR_PDCRC_PC7_Msk: u32 = 128;
pub const PWR_PDCRC_PC7: u32 = 128;
pub const PWR_PDCRC_PC8_Pos: u32 = 8;
pub const PWR_PDCRC_PC8_Msk: u32 = 256;
pub const PWR_PDCRC_PC8: u32 = 256;
pub const PWR_PDCRC_PC9_Pos: u32 = 9;
pub const PWR_PDCRC_PC9_Msk: u32 = 512;
pub const PWR_PDCRC_PC9: u32 = 512;
pub const PWR_PDCRC_PC10_Pos: u32 = 10;
pub const PWR_PDCRC_PC10_Msk: u32 = 1024;
pub const PWR_PDCRC_PC10: u32 = 1024;
pub const PWR_PDCRC_PC11_Pos: u32 = 11;
pub const PWR_PDCRC_PC11_Msk: u32 = 2048;
pub const PWR_PDCRC_PC11: u32 = 2048;
pub const PWR_PDCRC_PC12_Pos: u32 = 12;
pub const PWR_PDCRC_PC12_Msk: u32 = 4096;
pub const PWR_PDCRC_PC12: u32 = 4096;
pub const PWR_PDCRC_PC13_Pos: u32 = 13;
pub const PWR_PDCRC_PC13_Msk: u32 = 8192;
pub const PWR_PDCRC_PC13: u32 = 8192;
pub const PWR_PDCRC_PC14_Pos: u32 = 14;
pub const PWR_PDCRC_PC14_Msk: u32 = 16384;
pub const PWR_PDCRC_PC14: u32 = 16384;
pub const PWR_PDCRC_PC15_Pos: u32 = 15;
pub const PWR_PDCRC_PC15_Msk: u32 = 32768;
pub const PWR_PDCRC_PC15: u32 = 32768;
pub const PWR_PUCRD_PD0_Pos: u32 = 0;
pub const PWR_PUCRD_PD0_Msk: u32 = 1;
pub const PWR_PUCRD_PD0: u32 = 1;
pub const PWR_PUCRD_PD1_Pos: u32 = 1;
pub const PWR_PUCRD_PD1_Msk: u32 = 2;
pub const PWR_PUCRD_PD1: u32 = 2;
pub const PWR_PUCRD_PD2_Pos: u32 = 2;
pub const PWR_PUCRD_PD2_Msk: u32 = 4;
pub const PWR_PUCRD_PD2: u32 = 4;
pub const PWR_PUCRD_PD3_Pos: u32 = 3;
pub const PWR_PUCRD_PD3_Msk: u32 = 8;
pub const PWR_PUCRD_PD3: u32 = 8;
pub const PWR_PUCRD_PD4_Pos: u32 = 4;
pub const PWR_PUCRD_PD4_Msk: u32 = 16;
pub const PWR_PUCRD_PD4: u32 = 16;
pub const PWR_PUCRD_PD5_Pos: u32 = 5;
pub const PWR_PUCRD_PD5_Msk: u32 = 32;
pub const PWR_PUCRD_PD5: u32 = 32;
pub const PWR_PUCRD_PD6_Pos: u32 = 6;
pub const PWR_PUCRD_PD6_Msk: u32 = 64;
pub const PWR_PUCRD_PD6: u32 = 64;
pub const PWR_PUCRD_PD8_Pos: u32 = 8;
pub const PWR_PUCRD_PD8_Msk: u32 = 256;
pub const PWR_PUCRD_PD8: u32 = 256;
pub const PWR_PUCRD_PD9_Pos: u32 = 9;
pub const PWR_PUCRD_PD9_Msk: u32 = 512;
pub const PWR_PUCRD_PD9: u32 = 512;
pub const PWR_PUCRD_PD10_Pos: u32 = 10;
pub const PWR_PUCRD_PD10_Msk: u32 = 1024;
pub const PWR_PUCRD_PD10: u32 = 1024;
pub const PWR_PUCRD_PD11_Pos: u32 = 11;
pub const PWR_PUCRD_PD11_Msk: u32 = 2048;
pub const PWR_PUCRD_PD11: u32 = 2048;
pub const PWR_PUCRD_PD12_Pos: u32 = 12;
pub const PWR_PUCRD_PD12_Msk: u32 = 4096;
pub const PWR_PUCRD_PD12: u32 = 4096;
pub const PWR_PUCRD_PD13_Pos: u32 = 13;
pub const PWR_PUCRD_PD13_Msk: u32 = 8192;
pub const PWR_PUCRD_PD13: u32 = 8192;
pub const PWR_PUCRD_PD14_Pos: u32 = 14;
pub const PWR_PUCRD_PD14_Msk: u32 = 16384;
pub const PWR_PUCRD_PD14: u32 = 16384;
pub const PWR_PUCRD_PD15_Pos: u32 = 15;
pub const PWR_PUCRD_PD15_Msk: u32 = 32768;
pub const PWR_PUCRD_PD15: u32 = 32768;
pub const PWR_PDCRD_PD0_Pos: u32 = 0;
pub const PWR_PDCRD_PD0_Msk: u32 = 1;
pub const PWR_PDCRD_PD0: u32 = 1;
pub const PWR_PDCRD_PD1_Pos: u32 = 1;
pub const PWR_PDCRD_PD1_Msk: u32 = 2;
pub const PWR_PDCRD_PD1: u32 = 2;
pub const PWR_PDCRD_PD2_Pos: u32 = 2;
pub const PWR_PDCRD_PD2_Msk: u32 = 4;
pub const PWR_PDCRD_PD2: u32 = 4;
pub const PWR_PDCRD_PD3_Pos: u32 = 3;
pub const PWR_PDCRD_PD3_Msk: u32 = 8;
pub const PWR_PDCRD_PD3: u32 = 8;
pub const PWR_PDCRD_PD4_Pos: u32 = 4;
pub const PWR_PDCRD_PD4_Msk: u32 = 16;
pub const PWR_PDCRD_PD4: u32 = 16;
pub const PWR_PDCRD_PD5_Pos: u32 = 5;
pub const PWR_PDCRD_PD5_Msk: u32 = 32;
pub const PWR_PDCRD_PD5: u32 = 32;
pub const PWR_PDCRD_PD6_Pos: u32 = 6;
pub const PWR_PDCRD_PD6_Msk: u32 = 64;
pub const PWR_PDCRD_PD6: u32 = 64;
pub const PWR_PDCRD_PD8_Pos: u32 = 8;
pub const PWR_PDCRD_PD8_Msk: u32 = 256;
pub const PWR_PDCRD_PD8: u32 = 256;
pub const PWR_PDCRD_PD9_Pos: u32 = 9;
pub const PWR_PDCRD_PD9_Msk: u32 = 512;
pub const PWR_PDCRD_PD9: u32 = 512;
pub const PWR_PDCRD_PD10_Pos: u32 = 10;
pub const PWR_PDCRD_PD10_Msk: u32 = 1024;
pub const PWR_PDCRD_PD10: u32 = 1024;
pub const PWR_PDCRD_PD11_Pos: u32 = 11;
pub const PWR_PDCRD_PD11_Msk: u32 = 2048;
pub const PWR_PDCRD_PD11: u32 = 2048;
pub const PWR_PDCRD_PD12_Pos: u32 = 12;
pub const PWR_PDCRD_PD12_Msk: u32 = 4096;
pub const PWR_PDCRD_PD12: u32 = 4096;
pub const PWR_PDCRD_PD13_Pos: u32 = 13;
pub const PWR_PDCRD_PD13_Msk: u32 = 8192;
pub const PWR_PDCRD_PD13: u32 = 8192;
pub const PWR_PDCRD_PD14_Pos: u32 = 14;
pub const PWR_PDCRD_PD14_Msk: u32 = 16384;
pub const PWR_PDCRD_PD14: u32 = 16384;
pub const PWR_PDCRD_PD15_Pos: u32 = 15;
pub const PWR_PDCRD_PD15_Msk: u32 = 32768;
pub const PWR_PDCRD_PD15: u32 = 32768;
pub const PWR_PUCRE_PE0_Pos: u32 = 0;
pub const PWR_PUCRE_PE0_Msk: u32 = 1;
pub const PWR_PUCRE_PE0: u32 = 1;
pub const PWR_PUCRE_PE1_Pos: u32 = 1;
pub const PWR_PUCRE_PE1_Msk: u32 = 2;
pub const PWR_PUCRE_PE1: u32 = 2;
pub const PWR_PUCRE_PE2_Pos: u32 = 2;
pub const PWR_PUCRE_PE2_Msk: u32 = 4;
pub const PWR_PUCRE_PE2: u32 = 4;
pub const PWR_PUCRE_PE3_Pos: u32 = 3;
pub const PWR_PUCRE_PE3_Msk: u32 = 8;
pub const PWR_PUCRE_PE3: u32 = 8;
pub const PWR_PUCRE_PE4_Pos: u32 = 4;
pub const PWR_PUCRE_PE4_Msk: u32 = 16;
pub const PWR_PUCRE_PE4: u32 = 16;
pub const PWR_PDCRE_PE0_Pos: u32 = 0;
pub const PWR_PDCRE_PE0_Msk: u32 = 1;
pub const PWR_PDCRE_PE0: u32 = 1;
pub const PWR_PDCRE_PE1_Pos: u32 = 1;
pub const PWR_PDCRE_PE1_Msk: u32 = 2;
pub const PWR_PDCRE_PE1: u32 = 2;
pub const PWR_PDCRE_PE2_Pos: u32 = 2;
pub const PWR_PDCRE_PE2_Msk: u32 = 4;
pub const PWR_PDCRE_PE2: u32 = 4;
pub const PWR_PDCRE_PE3_Pos: u32 = 3;
pub const PWR_PDCRE_PE3_Msk: u32 = 8;
pub const PWR_PDCRE_PE3: u32 = 8;
pub const PWR_PDCRE_PE4_Pos: u32 = 4;
pub const PWR_PDCRE_PE4_Msk: u32 = 16;
pub const PWR_PDCRE_PE4: u32 = 16;
pub const PWR_PUCRH_PH0_Pos: u32 = 0;
pub const PWR_PUCRH_PH0_Msk: u32 = 1;
pub const PWR_PUCRH_PH0: u32 = 1;
pub const PWR_PUCRH_PH1_Pos: u32 = 1;
pub const PWR_PUCRH_PH1_Msk: u32 = 2;
pub const PWR_PUCRH_PH1: u32 = 2;
pub const PWR_PUCRH_PH3_Pos: u32 = 3;
pub const PWR_PUCRH_PH3_Msk: u32 = 8;
pub const PWR_PUCRH_PH3: u32 = 8;
pub const PWR_PDCRH_PH0_Pos: u32 = 0;
pub const PWR_PDCRH_PH0_Msk: u32 = 1;
pub const PWR_PDCRH_PH0: u32 = 1;
pub const PWR_PDCRH_PH1_Pos: u32 = 1;
pub const PWR_PDCRH_PH1_Msk: u32 = 2;
pub const PWR_PDCRH_PH1: u32 = 2;
pub const PWR_PDCRH_PH3_Pos: u32 = 3;
pub const PWR_PDCRH_PH3_Msk: u32 = 8;
pub const PWR_PDCRH_PH3: u32 = 8;
pub const PWR_C2CR1_LPMS_Pos: u32 = 0;
pub const PWR_C2CR1_LPMS_Msk: u32 = 7;
pub const PWR_C2CR1_LPMS: u32 = 7;
pub const PWR_C2CR1_LPMS_0: u32 = 1;
pub const PWR_C2CR1_LPMS_1: u32 = 2;
pub const PWR_C2CR1_LPMS_2: u32 = 4;
pub const PWR_C2CR1_FPDR_Pos: u32 = 4;
pub const PWR_C2CR1_FPDR_Msk: u32 = 16;
pub const PWR_C2CR1_FPDR: u32 = 16;
pub const PWR_C2CR1_FPDS_Pos: u32 = 5;
pub const PWR_C2CR1_FPDS_Msk: u32 = 32;
pub const PWR_C2CR1_FPDS: u32 = 32;
pub const PWR_C2CR1_BLEEWKUP_Pos: u32 = 14;
pub const PWR_C2CR1_BLEEWKUP_Msk: u32 = 16384;
pub const PWR_C2CR1_BLEEWKUP: u32 = 16384;
pub const PWR_C2CR1_802EWKUP_Pos: u32 = 15;
pub const PWR_C2CR1_802EWKUP_Msk: u32 = 32768;
pub const PWR_C2CR1_802EWKUP: u32 = 32768;
pub const PWR_C2CR3_EWUP_Pos: u32 = 0;
pub const PWR_C2CR3_EWUP_Msk: u32 = 31;
pub const PWR_C2CR3_EWUP: u32 = 31;
pub const PWR_C2CR3_EWUP1_Pos: u32 = 0;
pub const PWR_C2CR3_EWUP1_Msk: u32 = 1;
pub const PWR_C2CR3_EWUP1: u32 = 1;
pub const PWR_C2CR3_EWUP2_Pos: u32 = 1;
pub const PWR_C2CR3_EWUP2_Msk: u32 = 2;
pub const PWR_C2CR3_EWUP2: u32 = 2;
pub const PWR_C2CR3_EWUP3_Pos: u32 = 2;
pub const PWR_C2CR3_EWUP3_Msk: u32 = 4;
pub const PWR_C2CR3_EWUP3: u32 = 4;
pub const PWR_C2CR3_EWUP4_Pos: u32 = 3;
pub const PWR_C2CR3_EWUP4_Msk: u32 = 8;
pub const PWR_C2CR3_EWUP4: u32 = 8;
pub const PWR_C2CR3_EWUP5_Pos: u32 = 4;
pub const PWR_C2CR3_EWUP5_Msk: u32 = 16;
pub const PWR_C2CR3_EWUP5: u32 = 16;
pub const PWR_C2CR3_EBLEWUP_Pos: u32 = 9;
pub const PWR_C2CR3_EBLEWUP_Msk: u32 = 512;
pub const PWR_C2CR3_EBLEWUP: u32 = 512;
pub const PWR_C2CR3_E802WUP_Pos: u32 = 10;
pub const PWR_C2CR3_E802WUP_Msk: u32 = 1024;
pub const PWR_C2CR3_E802WUP: u32 = 1024;
pub const PWR_C2CR3_APC_Pos: u32 = 12;
pub const PWR_C2CR3_APC_Msk: u32 = 4096;
pub const PWR_C2CR3_APC: u32 = 4096;
pub const PWR_C2CR3_EIWUL_Pos: u32 = 15;
pub const PWR_C2CR3_EIWUL_Msk: u32 = 32768;
pub const PWR_C2CR3_EIWUL: u32 = 32768;
pub const PWR_EXTSCR_C1CSSF_Pos: u32 = 0;
pub const PWR_EXTSCR_C1CSSF_Msk: u32 = 1;
pub const PWR_EXTSCR_C1CSSF: u32 = 1;
pub const PWR_EXTSCR_C2CSSF_Pos: u32 = 1;
pub const PWR_EXTSCR_C2CSSF_Msk: u32 = 2;
pub const PWR_EXTSCR_C2CSSF: u32 = 2;
pub const PWR_EXTSCR_CCRPF_Pos: u32 = 2;
pub const PWR_EXTSCR_CCRPF_Msk: u32 = 4;
pub const PWR_EXTSCR_CCRPF: u32 = 4;
pub const PWR_EXTSCR_C1SBF_Pos: u32 = 8;
pub const PWR_EXTSCR_C1SBF_Msk: u32 = 256;
pub const PWR_EXTSCR_C1SBF: u32 = 256;
pub const PWR_EXTSCR_C1STOPF_Pos: u32 = 9;
pub const PWR_EXTSCR_C1STOPF_Msk: u32 = 512;
pub const PWR_EXTSCR_C1STOPF: u32 = 512;
pub const PWR_EXTSCR_C2SBF_Pos: u32 = 10;
pub const PWR_EXTSCR_C2SBF_Msk: u32 = 1024;
pub const PWR_EXTSCR_C2SBF: u32 = 1024;
pub const PWR_EXTSCR_C2STOPF_Pos: u32 = 11;
pub const PWR_EXTSCR_C2STOPF_Msk: u32 = 2048;
pub const PWR_EXTSCR_C2STOPF: u32 = 2048;
pub const PWR_EXTSCR_CRPF_Pos: u32 = 13;
pub const PWR_EXTSCR_CRPF_Msk: u32 = 8192;
pub const PWR_EXTSCR_CRPF: u32 = 8192;
pub const PWR_EXTSCR_C1DS_Pos: u32 = 14;
pub const PWR_EXTSCR_C1DS_Msk: u32 = 16384;
pub const PWR_EXTSCR_C1DS: u32 = 16384;
pub const PWR_EXTSCR_C2DS_Pos: u32 = 15;
pub const PWR_EXTSCR_C2DS_Msk: u32 = 32768;
pub const PWR_EXTSCR_C2DS: u32 = 32768;
pub const QUADSPI_CR_EN_Pos: u32 = 0;
pub const QUADSPI_CR_EN_Msk: u32 = 1;
pub const QUADSPI_CR_EN: u32 = 1;
pub const QUADSPI_CR_ABORT_Pos: u32 = 1;
pub const QUADSPI_CR_ABORT_Msk: u32 = 2;
pub const QUADSPI_CR_ABORT: u32 = 2;
pub const QUADSPI_CR_DMAEN_Pos: u32 = 2;
pub const QUADSPI_CR_DMAEN_Msk: u32 = 4;
pub const QUADSPI_CR_DMAEN: u32 = 4;
pub const QUADSPI_CR_TCEN_Pos: u32 = 3;
pub const QUADSPI_CR_TCEN_Msk: u32 = 8;
pub const QUADSPI_CR_TCEN: u32 = 8;
pub const QUADSPI_CR_SSHIFT_Pos: u32 = 4;
pub const QUADSPI_CR_SSHIFT_Msk: u32 = 16;
pub const QUADSPI_CR_SSHIFT: u32 = 16;
pub const QUADSPI_CR_FTHRES_Pos: u32 = 8;
pub const QUADSPI_CR_FTHRES_Msk: u32 = 3840;
pub const QUADSPI_CR_FTHRES: u32 = 3840;
pub const QUADSPI_CR_TEIE_Pos: u32 = 16;
pub const QUADSPI_CR_TEIE_Msk: u32 = 65536;
pub const QUADSPI_CR_TEIE: u32 = 65536;
pub const QUADSPI_CR_TCIE_Pos: u32 = 17;
pub const QUADSPI_CR_TCIE_Msk: u32 = 131072;
pub const QUADSPI_CR_TCIE: u32 = 131072;
pub const QUADSPI_CR_FTIE_Pos: u32 = 18;
pub const QUADSPI_CR_FTIE_Msk: u32 = 262144;
pub const QUADSPI_CR_FTIE: u32 = 262144;
pub const QUADSPI_CR_SMIE_Pos: u32 = 19;
pub const QUADSPI_CR_SMIE_Msk: u32 = 524288;
pub const QUADSPI_CR_SMIE: u32 = 524288;
pub const QUADSPI_CR_TOIE_Pos: u32 = 20;
pub const QUADSPI_CR_TOIE_Msk: u32 = 1048576;
pub const QUADSPI_CR_TOIE: u32 = 1048576;
pub const QUADSPI_CR_APMS_Pos: u32 = 22;
pub const QUADSPI_CR_APMS_Msk: u32 = 4194304;
pub const QUADSPI_CR_APMS: u32 = 4194304;
pub const QUADSPI_CR_PMM_Pos: u32 = 23;
pub const QUADSPI_CR_PMM_Msk: u32 = 8388608;
pub const QUADSPI_CR_PMM: u32 = 8388608;
pub const QUADSPI_CR_PRESCALER_Pos: u32 = 24;
pub const QUADSPI_CR_PRESCALER_Msk: u32 = 4278190080;
pub const QUADSPI_CR_PRESCALER: u32 = 4278190080;
pub const QUADSPI_DCR_CKMODE_Pos: u32 = 0;
pub const QUADSPI_DCR_CKMODE_Msk: u32 = 1;
pub const QUADSPI_DCR_CKMODE: u32 = 1;
pub const QUADSPI_DCR_CSHT_Pos: u32 = 8;
pub const QUADSPI_DCR_CSHT_Msk: u32 = 1792;
pub const QUADSPI_DCR_CSHT: u32 = 1792;
pub const QUADSPI_DCR_CSHT_0: u32 = 256;
pub const QUADSPI_DCR_CSHT_1: u32 = 512;
pub const QUADSPI_DCR_CSHT_2: u32 = 1024;
pub const QUADSPI_DCR_FSIZE_Pos: u32 = 16;
pub const QUADSPI_DCR_FSIZE_Msk: u32 = 2031616;
pub const QUADSPI_DCR_FSIZE: u32 = 2031616;
pub const QUADSPI_SR_TEF_Pos: u32 = 0;
pub const QUADSPI_SR_TEF_Msk: u32 = 1;
pub const QUADSPI_SR_TEF: u32 = 1;
pub const QUADSPI_SR_TCF_Pos: u32 = 1;
pub const QUADSPI_SR_TCF_Msk: u32 = 2;
pub const QUADSPI_SR_TCF: u32 = 2;
pub const QUADSPI_SR_FTF_Pos: u32 = 2;
pub const QUADSPI_SR_FTF_Msk: u32 = 4;
pub const QUADSPI_SR_FTF: u32 = 4;
pub const QUADSPI_SR_SMF_Pos: u32 = 3;
pub const QUADSPI_SR_SMF_Msk: u32 = 8;
pub const QUADSPI_SR_SMF: u32 = 8;
pub const QUADSPI_SR_TOF_Pos: u32 = 4;
pub const QUADSPI_SR_TOF_Msk: u32 = 16;
pub const QUADSPI_SR_TOF: u32 = 16;
pub const QUADSPI_SR_BUSY_Pos: u32 = 5;
pub const QUADSPI_SR_BUSY_Msk: u32 = 32;
pub const QUADSPI_SR_BUSY: u32 = 32;
pub const QUADSPI_SR_FLEVEL_Pos: u32 = 8;
pub const QUADSPI_SR_FLEVEL_Msk: u32 = 7936;
pub const QUADSPI_SR_FLEVEL: u32 = 7936;
pub const QUADSPI_FCR_CTEF_Pos: u32 = 0;
pub const QUADSPI_FCR_CTEF_Msk: u32 = 1;
pub const QUADSPI_FCR_CTEF: u32 = 1;
pub const QUADSPI_FCR_CTCF_Pos: u32 = 1;
pub const QUADSPI_FCR_CTCF_Msk: u32 = 2;
pub const QUADSPI_FCR_CTCF: u32 = 2;
pub const QUADSPI_FCR_CSMF_Pos: u32 = 3;
pub const QUADSPI_FCR_CSMF_Msk: u32 = 8;
pub const QUADSPI_FCR_CSMF: u32 = 8;
pub const QUADSPI_FCR_CTOF_Pos: u32 = 4;
pub const QUADSPI_FCR_CTOF_Msk: u32 = 16;
pub const QUADSPI_FCR_CTOF: u32 = 16;
pub const QUADSPI_DLR_DL_Pos: u32 = 0;
pub const QUADSPI_DLR_DL_Msk: u32 = 4294967295;
pub const QUADSPI_DLR_DL: u32 = 4294967295;
pub const QUADSPI_CCR_INSTRUCTION_Pos: u32 = 0;
pub const QUADSPI_CCR_INSTRUCTION_Msk: u32 = 255;
pub const QUADSPI_CCR_INSTRUCTION: u32 = 255;
pub const QUADSPI_CCR_IMODE_Pos: u32 = 8;
pub const QUADSPI_CCR_IMODE_Msk: u32 = 768;
pub const QUADSPI_CCR_IMODE: u32 = 768;
pub const QUADSPI_CCR_IMODE_0: u32 = 256;
pub const QUADSPI_CCR_IMODE_1: u32 = 512;
pub const QUADSPI_CCR_ADMODE_Pos: u32 = 10;
pub const QUADSPI_CCR_ADMODE_Msk: u32 = 3072;
pub const QUADSPI_CCR_ADMODE: u32 = 3072;
pub const QUADSPI_CCR_ADMODE_0: u32 = 1024;
pub const QUADSPI_CCR_ADMODE_1: u32 = 2048;
pub const QUADSPI_CCR_ADSIZE_Pos: u32 = 12;
pub const QUADSPI_CCR_ADSIZE_Msk: u32 = 12288;
pub const QUADSPI_CCR_ADSIZE: u32 = 12288;
pub const QUADSPI_CCR_ADSIZE_0: u32 = 4096;
pub const QUADSPI_CCR_ADSIZE_1: u32 = 8192;
pub const QUADSPI_CCR_ABMODE_Pos: u32 = 14;
pub const QUADSPI_CCR_ABMODE_Msk: u32 = 49152;
pub const QUADSPI_CCR_ABMODE: u32 = 49152;
pub const QUADSPI_CCR_ABMODE_0: u32 = 16384;
pub const QUADSPI_CCR_ABMODE_1: u32 = 32768;
pub const QUADSPI_CCR_ABSIZE_Pos: u32 = 16;
pub const QUADSPI_CCR_ABSIZE_Msk: u32 = 196608;
pub const QUADSPI_CCR_ABSIZE: u32 = 196608;
pub const QUADSPI_CCR_ABSIZE_0: u32 = 65536;
pub const QUADSPI_CCR_ABSIZE_1: u32 = 131072;
pub const QUADSPI_CCR_DCYC_Pos: u32 = 18;
pub const QUADSPI_CCR_DCYC_Msk: u32 = 8126464;
pub const QUADSPI_CCR_DCYC: u32 = 8126464;
pub const QUADSPI_CCR_DMODE_Pos: u32 = 24;
pub const QUADSPI_CCR_DMODE_Msk: u32 = 50331648;
pub const QUADSPI_CCR_DMODE: u32 = 50331648;
pub const QUADSPI_CCR_DMODE_0: u32 = 16777216;
pub const QUADSPI_CCR_DMODE_1: u32 = 33554432;
pub const QUADSPI_CCR_FMODE_Pos: u32 = 26;
pub const QUADSPI_CCR_FMODE_Msk: u32 = 201326592;
pub const QUADSPI_CCR_FMODE: u32 = 201326592;
pub const QUADSPI_CCR_FMODE_0: u32 = 67108864;
pub const QUADSPI_CCR_FMODE_1: u32 = 134217728;
pub const QUADSPI_CCR_SIOO_Pos: u32 = 28;
pub const QUADSPI_CCR_SIOO_Msk: u32 = 268435456;
pub const QUADSPI_CCR_SIOO: u32 = 268435456;
pub const QUADSPI_CCR_DDRM_Pos: u32 = 31;
pub const QUADSPI_CCR_DDRM_Msk: u32 = 2147483648;
pub const QUADSPI_CCR_DDRM: u32 = 2147483648;
pub const QUADSPI_AR_ADDRESS_Pos: u32 = 0;
pub const QUADSPI_AR_ADDRESS_Msk: u32 = 4294967295;
pub const QUADSPI_AR_ADDRESS: u32 = 4294967295;
pub const QUADSPI_ABR_ALTERNATE_Pos: u32 = 0;
pub const QUADSPI_ABR_ALTERNATE_Msk: u32 = 4294967295;
pub const QUADSPI_ABR_ALTERNATE: u32 = 4294967295;
pub const QUADSPI_DR_DATA_Pos: u32 = 0;
pub const QUADSPI_DR_DATA_Msk: u32 = 4294967295;
pub const QUADSPI_DR_DATA: u32 = 4294967295;
pub const QUADSPI_PSMKR_MASK_Pos: u32 = 0;
pub const QUADSPI_PSMKR_MASK_Msk: u32 = 4294967295;
pub const QUADSPI_PSMKR_MASK: u32 = 4294967295;
pub const QUADSPI_PSMAR_MATCH_Pos: u32 = 0;
pub const QUADSPI_PSMAR_MATCH_Msk: u32 = 4294967295;
pub const QUADSPI_PSMAR_MATCH: u32 = 4294967295;
pub const QUADSPI_PIR_INTERVAL_Pos: u32 = 0;
pub const QUADSPI_PIR_INTERVAL_Msk: u32 = 65535;
pub const QUADSPI_PIR_INTERVAL: u32 = 65535;
pub const QUADSPI_LPTR_TIMEOUT_Pos: u32 = 0;
pub const QUADSPI_LPTR_TIMEOUT_Msk: u32 = 65535;
pub const QUADSPI_LPTR_TIMEOUT: u32 = 65535;
pub const RCC_CR_MSION_Pos: u32 = 0;
pub const RCC_CR_MSION_Msk: u32 = 1;
pub const RCC_CR_MSION: u32 = 1;
pub const RCC_CR_MSIRDY_Pos: u32 = 1;
pub const RCC_CR_MSIRDY_Msk: u32 = 2;
pub const RCC_CR_MSIRDY: u32 = 2;
pub const RCC_CR_MSIPLLEN_Pos: u32 = 2;
pub const RCC_CR_MSIPLLEN_Msk: u32 = 4;
pub const RCC_CR_MSIPLLEN: u32 = 4;
pub const RCC_CR_MSIRANGE_Pos: u32 = 4;
pub const RCC_CR_MSIRANGE_Msk: u32 = 240;
pub const RCC_CR_MSIRANGE: u32 = 240;
pub const RCC_CR_MSIRANGE_0: u32 = 0;
pub const RCC_CR_MSIRANGE_1: u32 = 16;
pub const RCC_CR_MSIRANGE_2: u32 = 32;
pub const RCC_CR_MSIRANGE_3: u32 = 48;
pub const RCC_CR_MSIRANGE_4: u32 = 64;
pub const RCC_CR_MSIRANGE_5: u32 = 80;
pub const RCC_CR_MSIRANGE_6: u32 = 96;
pub const RCC_CR_MSIRANGE_7: u32 = 112;
pub const RCC_CR_MSIRANGE_8: u32 = 128;
pub const RCC_CR_MSIRANGE_9: u32 = 144;
pub const RCC_CR_MSIRANGE_10: u32 = 160;
pub const RCC_CR_MSIRANGE_11: u32 = 176;
pub const RCC_CR_HSION_Pos: u32 = 8;
pub const RCC_CR_HSION_Msk: u32 = 256;
pub const RCC_CR_HSION: u32 = 256;
pub const RCC_CR_HSIKERON_Pos: u32 = 9;
pub const RCC_CR_HSIKERON_Msk: u32 = 512;
pub const RCC_CR_HSIKERON: u32 = 512;
pub const RCC_CR_HSIRDY_Pos: u32 = 10;
pub const RCC_CR_HSIRDY_Msk: u32 = 1024;
pub const RCC_CR_HSIRDY: u32 = 1024;
pub const RCC_CR_HSIASFS_Pos: u32 = 11;
pub const RCC_CR_HSIASFS_Msk: u32 = 2048;
pub const RCC_CR_HSIASFS: u32 = 2048;
pub const RCC_CR_HSIKERDY_Pos: u32 = 12;
pub const RCC_CR_HSIKERDY_Msk: u32 = 4096;
pub const RCC_CR_HSIKERDY: u32 = 4096;
pub const RCC_CR_HSEON_Pos: u32 = 16;
pub const RCC_CR_HSEON_Msk: u32 = 65536;
pub const RCC_CR_HSEON: u32 = 65536;
pub const RCC_CR_HSERDY_Pos: u32 = 17;
pub const RCC_CR_HSERDY_Msk: u32 = 131072;
pub const RCC_CR_HSERDY: u32 = 131072;
pub const RCC_CR_CSSON_Pos: u32 = 19;
pub const RCC_CR_CSSON_Msk: u32 = 524288;
pub const RCC_CR_CSSON: u32 = 524288;
pub const RCC_CR_HSEPRE_Pos: u32 = 20;
pub const RCC_CR_HSEPRE_Msk: u32 = 1048576;
pub const RCC_CR_HSEPRE: u32 = 1048576;
pub const RCC_CR_PLLON_Pos: u32 = 24;
pub const RCC_CR_PLLON_Msk: u32 = 16777216;
pub const RCC_CR_PLLON: u32 = 16777216;
pub const RCC_CR_PLLRDY_Pos: u32 = 25;
pub const RCC_CR_PLLRDY_Msk: u32 = 33554432;
pub const RCC_CR_PLLRDY: u32 = 33554432;
pub const RCC_CR_PLLSAI1ON_Pos: u32 = 26;
pub const RCC_CR_PLLSAI1ON_Msk: u32 = 67108864;
pub const RCC_CR_PLLSAI1ON: u32 = 67108864;
pub const RCC_CR_PLLSAI1RDY_Pos: u32 = 27;
pub const RCC_CR_PLLSAI1RDY_Msk: u32 = 134217728;
pub const RCC_CR_PLLSAI1RDY: u32 = 134217728;
pub const RCC_ICSCR_MSICAL_Pos: u32 = 0;
pub const RCC_ICSCR_MSICAL_Msk: u32 = 255;
pub const RCC_ICSCR_MSICAL: u32 = 255;
pub const RCC_ICSCR_MSICAL_0: u32 = 1;
pub const RCC_ICSCR_MSICAL_1: u32 = 2;
pub const RCC_ICSCR_MSICAL_2: u32 = 4;
pub const RCC_ICSCR_MSICAL_3: u32 = 8;
pub const RCC_ICSCR_MSICAL_4: u32 = 16;
pub const RCC_ICSCR_MSICAL_5: u32 = 32;
pub const RCC_ICSCR_MSICAL_6: u32 = 64;
pub const RCC_ICSCR_MSICAL_7: u32 = 128;
pub const RCC_ICSCR_MSITRIM_Pos: u32 = 8;
pub const RCC_ICSCR_MSITRIM_Msk: u32 = 65280;
pub const RCC_ICSCR_MSITRIM: u32 = 65280;
pub const RCC_ICSCR_MSITRIM_0: u32 = 256;
pub const RCC_ICSCR_MSITRIM_1: u32 = 512;
pub const RCC_ICSCR_MSITRIM_2: u32 = 1024;
pub const RCC_ICSCR_MSITRIM_3: u32 = 2048;
pub const RCC_ICSCR_MSITRIM_4: u32 = 4096;
pub const RCC_ICSCR_MSITRIM_5: u32 = 8192;
pub const RCC_ICSCR_MSITRIM_6: u32 = 16384;
pub const RCC_ICSCR_MSITRIM_7: u32 = 32768;
pub const RCC_ICSCR_HSICAL_Pos: u32 = 16;
pub const RCC_ICSCR_HSICAL_Msk: u32 = 16711680;
pub const RCC_ICSCR_HSICAL: u32 = 16711680;
pub const RCC_ICSCR_HSICAL_0: u32 = 65536;
pub const RCC_ICSCR_HSICAL_1: u32 = 131072;
pub const RCC_ICSCR_HSICAL_2: u32 = 262144;
pub const RCC_ICSCR_HSICAL_3: u32 = 524288;
pub const RCC_ICSCR_HSICAL_4: u32 = 1048576;
pub const RCC_ICSCR_HSICAL_5: u32 = 2097152;
pub const RCC_ICSCR_HSICAL_6: u32 = 4194304;
pub const RCC_ICSCR_HSICAL_7: u32 = 8388608;
pub const RCC_ICSCR_HSITRIM_Pos: u32 = 24;
pub const RCC_ICSCR_HSITRIM_Msk: u32 = 2130706432;
pub const RCC_ICSCR_HSITRIM: u32 = 2130706432;
pub const RCC_ICSCR_HSITRIM_0: u32 = 16777216;
pub const RCC_ICSCR_HSITRIM_1: u32 = 33554432;
pub const RCC_ICSCR_HSITRIM_2: u32 = 67108864;
pub const RCC_ICSCR_HSITRIM_3: u32 = 134217728;
pub const RCC_ICSCR_HSITRIM_4: u32 = 268435456;
pub const RCC_ICSCR_HSITRIM_5: u32 = 536870912;
pub const RCC_ICSCR_HSITRIM_6: u32 = 1073741824;
pub const RCC_CFGR_SW_Pos: u32 = 0;
pub const RCC_CFGR_SW_Msk: u32 = 3;
pub const RCC_CFGR_SW: u32 = 3;
pub const RCC_CFGR_SW_0: u32 = 1;
pub const RCC_CFGR_SW_1: u32 = 2;
pub const RCC_CFGR_SWS_Pos: u32 = 2;
pub const RCC_CFGR_SWS_Msk: u32 = 12;
pub const RCC_CFGR_SWS: u32 = 12;
pub const RCC_CFGR_SWS_0: u32 = 4;
pub const RCC_CFGR_SWS_1: u32 = 8;
pub const RCC_CFGR_HPRE_Pos: u32 = 4;
pub const RCC_CFGR_HPRE_Msk: u32 = 240;
pub const RCC_CFGR_HPRE: u32 = 240;
pub const RCC_CFGR_HPRE_0: u32 = 16;
pub const RCC_CFGR_HPRE_1: u32 = 32;
pub const RCC_CFGR_HPRE_2: u32 = 64;
pub const RCC_CFGR_HPRE_3: u32 = 128;
pub const RCC_CFGR_PPRE1_Pos: u32 = 8;
pub const RCC_CFGR_PPRE1_Msk: u32 = 1792;
pub const RCC_CFGR_PPRE1: u32 = 1792;
pub const RCC_CFGR_PPRE1_0: u32 = 256;
pub const RCC_CFGR_PPRE1_1: u32 = 512;
pub const RCC_CFGR_PPRE1_2: u32 = 1024;
pub const RCC_CFGR_PPRE2_Pos: u32 = 11;
pub const RCC_CFGR_PPRE2_Msk: u32 = 14336;
pub const RCC_CFGR_PPRE2: u32 = 14336;
pub const RCC_CFGR_PPRE2_0: u32 = 2048;
pub const RCC_CFGR_PPRE2_1: u32 = 4096;
pub const RCC_CFGR_PPRE2_2: u32 = 8192;
pub const RCC_CFGR_STOPWUCK_Pos: u32 = 15;
pub const RCC_CFGR_STOPWUCK_Msk: u32 = 32768;
pub const RCC_CFGR_STOPWUCK: u32 = 32768;
pub const RCC_CFGR_HPREF_Pos: u32 = 16;
pub const RCC_CFGR_HPREF_Msk: u32 = 65536;
pub const RCC_CFGR_HPREF: u32 = 65536;
pub const RCC_CFGR_PPRE1F_Pos: u32 = 17;
pub const RCC_CFGR_PPRE1F_Msk: u32 = 131072;
pub const RCC_CFGR_PPRE1F: u32 = 131072;
pub const RCC_CFGR_PPRE2F_Pos: u32 = 18;
pub const RCC_CFGR_PPRE2F_Msk: u32 = 262144;
pub const RCC_CFGR_PPRE2F: u32 = 262144;
pub const RCC_CFGR_MCOSEL_Pos: u32 = 24;
pub const RCC_CFGR_MCOSEL_Msk: u32 = 251658240;
pub const RCC_CFGR_MCOSEL: u32 = 251658240;
pub const RCC_CFGR_MCOSEL_0: u32 = 16777216;
pub const RCC_CFGR_MCOSEL_1: u32 = 33554432;
pub const RCC_CFGR_MCOSEL_2: u32 = 67108864;
pub const RCC_CFGR_MCOSEL_3: u32 = 134217728;
pub const RCC_CFGR_MCOPRE_Pos: u32 = 28;
pub const RCC_CFGR_MCOPRE_Msk: u32 = 1879048192;
pub const RCC_CFGR_MCOPRE: u32 = 1879048192;
pub const RCC_CFGR_MCOPRE_0: u32 = 268435456;
pub const RCC_CFGR_MCOPRE_1: u32 = 536870912;
pub const RCC_CFGR_MCOPRE_2: u32 = 1073741824;
pub const RCC_PLLCFGR_PLLSRC_Pos: u32 = 0;
pub const RCC_PLLCFGR_PLLSRC_Msk: u32 = 3;
pub const RCC_PLLCFGR_PLLSRC: u32 = 3;
pub const RCC_PLLCFGR_PLLSRC_0: u32 = 1;
pub const RCC_PLLCFGR_PLLSRC_1: u32 = 2;
pub const RCC_PLLCFGR_PLLM_Pos: u32 = 4;
pub const RCC_PLLCFGR_PLLM_Msk: u32 = 112;
pub const RCC_PLLCFGR_PLLM: u32 = 112;
pub const RCC_PLLCFGR_PLLM_0: u32 = 16;
pub const RCC_PLLCFGR_PLLM_1: u32 = 32;
pub const RCC_PLLCFGR_PLLM_2: u32 = 64;
pub const RCC_PLLCFGR_PLLN_Pos: u32 = 8;
pub const RCC_PLLCFGR_PLLN_Msk: u32 = 32512;
pub const RCC_PLLCFGR_PLLN: u32 = 32512;
pub const RCC_PLLCFGR_PLLN_0: u32 = 256;
pub const RCC_PLLCFGR_PLLN_1: u32 = 512;
pub const RCC_PLLCFGR_PLLN_2: u32 = 1024;
pub const RCC_PLLCFGR_PLLN_3: u32 = 2048;
pub const RCC_PLLCFGR_PLLN_4: u32 = 4096;
pub const RCC_PLLCFGR_PLLN_5: u32 = 8192;
pub const RCC_PLLCFGR_PLLN_6: u32 = 16384;
pub const RCC_PLLCFGR_PLLPEN_Pos: u32 = 16;
pub const RCC_PLLCFGR_PLLPEN_Msk: u32 = 65536;
pub const RCC_PLLCFGR_PLLPEN: u32 = 65536;
pub const RCC_PLLCFGR_PLLP_Pos: u32 = 17;
pub const RCC_PLLCFGR_PLLP_Msk: u32 = 4063232;
pub const RCC_PLLCFGR_PLLP: u32 = 4063232;
pub const RCC_PLLCFGR_PLLP_0: u32 = 131072;
pub const RCC_PLLCFGR_PLLP_1: u32 = 262144;
pub const RCC_PLLCFGR_PLLP_2: u32 = 524288;
pub const RCC_PLLCFGR_PLLP_3: u32 = 1048576;
pub const RCC_PLLCFGR_PLLP_4: u32 = 2097152;
pub const RCC_PLLCFGR_PLLQEN_Pos: u32 = 24;
pub const RCC_PLLCFGR_PLLQEN_Msk: u32 = 16777216;
pub const RCC_PLLCFGR_PLLQEN: u32 = 16777216;
pub const RCC_PLLCFGR_PLLQ_Pos: u32 = 25;
pub const RCC_PLLCFGR_PLLQ_Msk: u32 = 234881024;
pub const RCC_PLLCFGR_PLLQ: u32 = 234881024;
pub const RCC_PLLCFGR_PLLQ_0: u32 = 33554432;
pub const RCC_PLLCFGR_PLLQ_1: u32 = 67108864;
pub const RCC_PLLCFGR_PLLQ_2: u32 = 134217728;
pub const RCC_PLLCFGR_PLLREN_Pos: u32 = 28;
pub const RCC_PLLCFGR_PLLREN_Msk: u32 = 268435456;
pub const RCC_PLLCFGR_PLLREN: u32 = 268435456;
pub const RCC_PLLCFGR_PLLR_Pos: u32 = 29;
pub const RCC_PLLCFGR_PLLR_Msk: u32 = 3758096384;
pub const RCC_PLLCFGR_PLLR: u32 = 3758096384;
pub const RCC_PLLCFGR_PLLR_0: u32 = 536870912;
pub const RCC_PLLCFGR_PLLR_1: u32 = 1073741824;
pub const RCC_PLLCFGR_PLLR_2: u32 = 2147483648;
pub const RCC_PLLSAI1CFGR_PLLN_Pos: u32 = 8;
pub const RCC_PLLSAI1CFGR_PLLN_Msk: u32 = 32512;
pub const RCC_PLLSAI1CFGR_PLLN: u32 = 32512;
pub const RCC_PLLSAI1CFGR_PLLN_0: u32 = 256;
pub const RCC_PLLSAI1CFGR_PLLN_1: u32 = 512;
pub const RCC_PLLSAI1CFGR_PLLN_2: u32 = 1024;
pub const RCC_PLLSAI1CFGR_PLLN_3: u32 = 2048;
pub const RCC_PLLSAI1CFGR_PLLN_4: u32 = 4096;
pub const RCC_PLLSAI1CFGR_PLLN_5: u32 = 8192;
pub const RCC_PLLSAI1CFGR_PLLN_6: u32 = 16384;
pub const RCC_PLLSAI1CFGR_PLLPEN_Pos: u32 = 16;
pub const RCC_PLLSAI1CFGR_PLLPEN_Msk: u32 = 65536;
pub const RCC_PLLSAI1CFGR_PLLPEN: u32 = 65536;
pub const RCC_PLLSAI1CFGR_PLLP_Pos: u32 = 17;
pub const RCC_PLLSAI1CFGR_PLLP_Msk: u32 = 4063232;
pub const RCC_PLLSAI1CFGR_PLLP: u32 = 4063232;
pub const RCC_PLLSAI1CFGR_PLLP_0: u32 = 131072;
pub const RCC_PLLSAI1CFGR_PLLP_1: u32 = 262144;
pub const RCC_PLLSAI1CFGR_PLLP_2: u32 = 524288;
pub const RCC_PLLSAI1CFGR_PLLP_3: u32 = 1048576;
pub const RCC_PLLSAI1CFGR_PLLP_4: u32 = 2097152;
pub const RCC_PLLSAI1CFGR_PLLQEN_Pos: u32 = 24;
pub const RCC_PLLSAI1CFGR_PLLQEN_Msk: u32 = 16777216;
pub const RCC_PLLSAI1CFGR_PLLQEN: u32 = 16777216;
pub const RCC_PLLSAI1CFGR_PLLQ_Pos: u32 = 25;
pub const RCC_PLLSAI1CFGR_PLLQ_Msk: u32 = 234881024;
pub const RCC_PLLSAI1CFGR_PLLQ: u32 = 234881024;
pub const RCC_PLLSAI1CFGR_PLLQ_0: u32 = 33554432;
pub const RCC_PLLSAI1CFGR_PLLQ_1: u32 = 67108864;
pub const RCC_PLLSAI1CFGR_PLLQ_2: u32 = 134217728;
pub const RCC_PLLSAI1CFGR_PLLREN_Pos: u32 = 28;
pub const RCC_PLLSAI1CFGR_PLLREN_Msk: u32 = 268435456;
pub const RCC_PLLSAI1CFGR_PLLREN: u32 = 268435456;
pub const RCC_PLLSAI1CFGR_PLLR_Pos: u32 = 29;
pub const RCC_PLLSAI1CFGR_PLLR_Msk: u32 = 3758096384;
pub const RCC_PLLSAI1CFGR_PLLR: u32 = 3758096384;
pub const RCC_PLLSAI1CFGR_PLLR_0: u32 = 536870912;
pub const RCC_PLLSAI1CFGR_PLLR_1: u32 = 1073741824;
pub const RCC_PLLSAI1CFGR_PLLR_2: u32 = 2147483648;
pub const RCC_CIER_LSI1RDYIE_Pos: u32 = 0;
pub const RCC_CIER_LSI1RDYIE_Msk: u32 = 1;
pub const RCC_CIER_LSI1RDYIE: u32 = 1;
pub const RCC_CIER_LSERDYIE_Pos: u32 = 1;
pub const RCC_CIER_LSERDYIE_Msk: u32 = 2;
pub const RCC_CIER_LSERDYIE: u32 = 2;
pub const RCC_CIER_MSIRDYIE_Pos: u32 = 2;
pub const RCC_CIER_MSIRDYIE_Msk: u32 = 4;
pub const RCC_CIER_MSIRDYIE: u32 = 4;
pub const RCC_CIER_HSIRDYIE_Pos: u32 = 3;
pub const RCC_CIER_HSIRDYIE_Msk: u32 = 8;
pub const RCC_CIER_HSIRDYIE: u32 = 8;
pub const RCC_CIER_HSERDYIE_Pos: u32 = 4;
pub const RCC_CIER_HSERDYIE_Msk: u32 = 16;
pub const RCC_CIER_HSERDYIE: u32 = 16;
pub const RCC_CIER_PLLRDYIE_Pos: u32 = 5;
pub const RCC_CIER_PLLRDYIE_Msk: u32 = 32;
pub const RCC_CIER_PLLRDYIE: u32 = 32;
pub const RCC_CIER_PLLSAI1RDYIE_Pos: u32 = 6;
pub const RCC_CIER_PLLSAI1RDYIE_Msk: u32 = 64;
pub const RCC_CIER_PLLSAI1RDYIE: u32 = 64;
pub const RCC_CIER_LSECSSIE_Pos: u32 = 9;
pub const RCC_CIER_LSECSSIE_Msk: u32 = 512;
pub const RCC_CIER_LSECSSIE: u32 = 512;
pub const RCC_CIER_HSI48RDYIE_Pos: u32 = 10;
pub const RCC_CIER_HSI48RDYIE_Msk: u32 = 1024;
pub const RCC_CIER_HSI48RDYIE: u32 = 1024;
pub const RCC_CIER_LSI2RDYIE_Pos: u32 = 11;
pub const RCC_CIER_LSI2RDYIE_Msk: u32 = 2048;
pub const RCC_CIER_LSI2RDYIE: u32 = 2048;
pub const RCC_CIFR_LSI1RDYF_Pos: u32 = 0;
pub const RCC_CIFR_LSI1RDYF_Msk: u32 = 1;
pub const RCC_CIFR_LSI1RDYF: u32 = 1;
pub const RCC_CIFR_LSERDYF_Pos: u32 = 1;
pub const RCC_CIFR_LSERDYF_Msk: u32 = 2;
pub const RCC_CIFR_LSERDYF: u32 = 2;
pub const RCC_CIFR_MSIRDYF_Pos: u32 = 2;
pub const RCC_CIFR_MSIRDYF_Msk: u32 = 4;
pub const RCC_CIFR_MSIRDYF: u32 = 4;
pub const RCC_CIFR_HSIRDYF_Pos: u32 = 3;
pub const RCC_CIFR_HSIRDYF_Msk: u32 = 8;
pub const RCC_CIFR_HSIRDYF: u32 = 8;
pub const RCC_CIFR_HSERDYF_Pos: u32 = 4;
pub const RCC_CIFR_HSERDYF_Msk: u32 = 16;
pub const RCC_CIFR_HSERDYF: u32 = 16;
pub const RCC_CIFR_PLLRDYF_Pos: u32 = 5;
pub const RCC_CIFR_PLLRDYF_Msk: u32 = 32;
pub const RCC_CIFR_PLLRDYF: u32 = 32;
pub const RCC_CIFR_PLLSAI1RDYF_Pos: u32 = 6;
pub const RCC_CIFR_PLLSAI1RDYF_Msk: u32 = 64;
pub const RCC_CIFR_PLLSAI1RDYF: u32 = 64;
pub const RCC_CIFR_CSSF_Pos: u32 = 8;
pub const RCC_CIFR_CSSF_Msk: u32 = 256;
pub const RCC_CIFR_CSSF: u32 = 256;
pub const RCC_CIFR_LSECSSF_Pos: u32 = 9;
pub const RCC_CIFR_LSECSSF_Msk: u32 = 512;
pub const RCC_CIFR_LSECSSF: u32 = 512;
pub const RCC_CIFR_HSI48RDYF_Pos: u32 = 10;
pub const RCC_CIFR_HSI48RDYF_Msk: u32 = 1024;
pub const RCC_CIFR_HSI48RDYF: u32 = 1024;
pub const RCC_CIFR_LSI2RDYF_Pos: u32 = 11;
pub const RCC_CIFR_LSI2RDYF_Msk: u32 = 2048;
pub const RCC_CIFR_LSI2RDYF: u32 = 2048;
pub const RCC_CICR_LSI1RDYC_Pos: u32 = 0;
pub const RCC_CICR_LSI1RDYC_Msk: u32 = 1;
pub const RCC_CICR_LSI1RDYC: u32 = 1;
pub const RCC_CICR_LSERDYC_Pos: u32 = 1;
pub const RCC_CICR_LSERDYC_Msk: u32 = 2;
pub const RCC_CICR_LSERDYC: u32 = 2;
pub const RCC_CICR_MSIRDYC_Pos: u32 = 2;
pub const RCC_CICR_MSIRDYC_Msk: u32 = 4;
pub const RCC_CICR_MSIRDYC: u32 = 4;
pub const RCC_CICR_HSIRDYC_Pos: u32 = 3;
pub const RCC_CICR_HSIRDYC_Msk: u32 = 8;
pub const RCC_CICR_HSIRDYC: u32 = 8;
pub const RCC_CICR_HSERDYC_Pos: u32 = 4;
pub const RCC_CICR_HSERDYC_Msk: u32 = 16;
pub const RCC_CICR_HSERDYC: u32 = 16;
pub const RCC_CICR_PLLRDYC_Pos: u32 = 5;
pub const RCC_CICR_PLLRDYC_Msk: u32 = 32;
pub const RCC_CICR_PLLRDYC: u32 = 32;
pub const RCC_CICR_PLLSAI1RDYC_Pos: u32 = 6;
pub const RCC_CICR_PLLSAI1RDYC_Msk: u32 = 64;
pub const RCC_CICR_PLLSAI1RDYC: u32 = 64;
pub const RCC_CICR_CSSC_Pos: u32 = 8;
pub const RCC_CICR_CSSC_Msk: u32 = 256;
pub const RCC_CICR_CSSC: u32 = 256;
pub const RCC_CICR_LSECSSC_Pos: u32 = 9;
pub const RCC_CICR_LSECSSC_Msk: u32 = 512;
pub const RCC_CICR_LSECSSC: u32 = 512;
pub const RCC_CICR_HSI48RDYC_Pos: u32 = 10;
pub const RCC_CICR_HSI48RDYC_Msk: u32 = 1024;
pub const RCC_CICR_HSI48RDYC: u32 = 1024;
pub const RCC_CICR_LSI2RDYC_Pos: u32 = 11;
pub const RCC_CICR_LSI2RDYC_Msk: u32 = 2048;
pub const RCC_CICR_LSI2RDYC: u32 = 2048;
pub const RCC_SMPSCR_SMPSSEL_Pos: u32 = 0;
pub const RCC_SMPSCR_SMPSSEL_Msk: u32 = 3;
pub const RCC_SMPSCR_SMPSSEL: u32 = 3;
pub const RCC_SMPSCR_SMPSSEL_0: u32 = 1;
pub const RCC_SMPSCR_SMPSSEL_1: u32 = 2;
pub const RCC_SMPSCR_SMPSDIV_Pos: u32 = 4;
pub const RCC_SMPSCR_SMPSDIV_Msk: u32 = 48;
pub const RCC_SMPSCR_SMPSDIV: u32 = 48;
pub const RCC_SMPSCR_SMPSDIV_0: u32 = 16;
pub const RCC_SMPSCR_SMPSDIV_1: u32 = 32;
pub const RCC_SMPSCR_SMPSSWS_Pos: u32 = 8;
pub const RCC_SMPSCR_SMPSSWS_Msk: u32 = 768;
pub const RCC_SMPSCR_SMPSSWS: u32 = 768;
pub const RCC_SMPSCR_SMPSSWS_0: u32 = 256;
pub const RCC_SMPSCR_SMPSSWS_1: u32 = 512;
pub const RCC_AHB1RSTR_DMA1RST_Pos: u32 = 0;
pub const RCC_AHB1RSTR_DMA1RST_Msk: u32 = 1;
pub const RCC_AHB1RSTR_DMA1RST: u32 = 1;
pub const RCC_AHB1RSTR_DMA2RST_Pos: u32 = 1;
pub const RCC_AHB1RSTR_DMA2RST_Msk: u32 = 2;
pub const RCC_AHB1RSTR_DMA2RST: u32 = 2;
pub const RCC_AHB1RSTR_DMAMUX1RST_Pos: u32 = 2;
pub const RCC_AHB1RSTR_DMAMUX1RST_Msk: u32 = 4;
pub const RCC_AHB1RSTR_DMAMUX1RST: u32 = 4;
pub const RCC_AHB1RSTR_CRCRST_Pos: u32 = 12;
pub const RCC_AHB1RSTR_CRCRST_Msk: u32 = 4096;
pub const RCC_AHB1RSTR_CRCRST: u32 = 4096;
pub const RCC_AHB1RSTR_TSCRST_Pos: u32 = 16;
pub const RCC_AHB1RSTR_TSCRST_Msk: u32 = 65536;
pub const RCC_AHB1RSTR_TSCRST: u32 = 65536;
pub const RCC_AHB2RSTR_GPIOARST_Pos: u32 = 0;
pub const RCC_AHB2RSTR_GPIOARST_Msk: u32 = 1;
pub const RCC_AHB2RSTR_GPIOARST: u32 = 1;
pub const RCC_AHB2RSTR_GPIOBRST_Pos: u32 = 1;
pub const RCC_AHB2RSTR_GPIOBRST_Msk: u32 = 2;
pub const RCC_AHB2RSTR_GPIOBRST: u32 = 2;
pub const RCC_AHB2RSTR_GPIOCRST_Pos: u32 = 2;
pub const RCC_AHB2RSTR_GPIOCRST_Msk: u32 = 4;
pub const RCC_AHB2RSTR_GPIOCRST: u32 = 4;
pub const RCC_AHB2RSTR_GPIODRST_Pos: u32 = 3;
pub const RCC_AHB2RSTR_GPIODRST_Msk: u32 = 8;
pub const RCC_AHB2RSTR_GPIODRST: u32 = 8;
pub const RCC_AHB2RSTR_GPIOERST_Pos: u32 = 4;
pub const RCC_AHB2RSTR_GPIOERST_Msk: u32 = 16;
pub const RCC_AHB2RSTR_GPIOERST: u32 = 16;
pub const RCC_AHB2RSTR_GPIOHRST_Pos: u32 = 7;
pub const RCC_AHB2RSTR_GPIOHRST_Msk: u32 = 128;
pub const RCC_AHB2RSTR_GPIOHRST: u32 = 128;
pub const RCC_AHB2RSTR_ADCRST_Pos: u32 = 13;
pub const RCC_AHB2RSTR_ADCRST_Msk: u32 = 8192;
pub const RCC_AHB2RSTR_ADCRST: u32 = 8192;
pub const RCC_AHB2RSTR_AES1RST_Pos: u32 = 16;
pub const RCC_AHB2RSTR_AES1RST_Msk: u32 = 65536;
pub const RCC_AHB2RSTR_AES1RST: u32 = 65536;
pub const RCC_AHB3RSTR_QUADSPIRST_Pos: u32 = 8;
pub const RCC_AHB3RSTR_QUADSPIRST_Msk: u32 = 256;
pub const RCC_AHB3RSTR_QUADSPIRST: u32 = 256;
pub const RCC_AHB3RSTR_PKARST_Pos: u32 = 16;
pub const RCC_AHB3RSTR_PKARST_Msk: u32 = 65536;
pub const RCC_AHB3RSTR_PKARST: u32 = 65536;
pub const RCC_AHB3RSTR_AES2RST_Pos: u32 = 17;
pub const RCC_AHB3RSTR_AES2RST_Msk: u32 = 131072;
pub const RCC_AHB3RSTR_AES2RST: u32 = 131072;
pub const RCC_AHB3RSTR_RNGRST_Pos: u32 = 18;
pub const RCC_AHB3RSTR_RNGRST_Msk: u32 = 262144;
pub const RCC_AHB3RSTR_RNGRST: u32 = 262144;
pub const RCC_AHB3RSTR_HSEMRST_Pos: u32 = 19;
pub const RCC_AHB3RSTR_HSEMRST_Msk: u32 = 524288;
pub const RCC_AHB3RSTR_HSEMRST: u32 = 524288;
pub const RCC_AHB3RSTR_IPCCRST_Pos: u32 = 20;
pub const RCC_AHB3RSTR_IPCCRST_Msk: u32 = 1048576;
pub const RCC_AHB3RSTR_IPCCRST: u32 = 1048576;
pub const RCC_AHB3RSTR_FLASHRST_Pos: u32 = 25;
pub const RCC_AHB3RSTR_FLASHRST_Msk: u32 = 33554432;
pub const RCC_AHB3RSTR_FLASHRST: u32 = 33554432;
pub const RCC_APB1RSTR1_TIM2RST_Pos: u32 = 0;
pub const RCC_APB1RSTR1_TIM2RST_Msk: u32 = 1;
pub const RCC_APB1RSTR1_TIM2RST: u32 = 1;
pub const RCC_APB1RSTR1_LCDRST_Pos: u32 = 9;
pub const RCC_APB1RSTR1_LCDRST_Msk: u32 = 512;
pub const RCC_APB1RSTR1_LCDRST: u32 = 512;
pub const RCC_APB1RSTR1_SPI2RST_Pos: u32 = 14;
pub const RCC_APB1RSTR1_SPI2RST_Msk: u32 = 16384;
pub const RCC_APB1RSTR1_SPI2RST: u32 = 16384;
pub const RCC_APB1RSTR1_I2C1RST_Pos: u32 = 21;
pub const RCC_APB1RSTR1_I2C1RST_Msk: u32 = 2097152;
pub const RCC_APB1RSTR1_I2C1RST: u32 = 2097152;
pub const RCC_APB1RSTR1_I2C3RST_Pos: u32 = 23;
pub const RCC_APB1RSTR1_I2C3RST_Msk: u32 = 8388608;
pub const RCC_APB1RSTR1_I2C3RST: u32 = 8388608;
pub const RCC_APB1RSTR1_CRSRST_Pos: u32 = 24;
pub const RCC_APB1RSTR1_CRSRST_Msk: u32 = 16777216;
pub const RCC_APB1RSTR1_CRSRST: u32 = 16777216;
pub const RCC_APB1RSTR1_USBRST_Pos: u32 = 26;
pub const RCC_APB1RSTR1_USBRST_Msk: u32 = 67108864;
pub const RCC_APB1RSTR1_USBRST: u32 = 67108864;
pub const RCC_APB1RSTR1_LPTIM1RST_Pos: u32 = 31;
pub const RCC_APB1RSTR1_LPTIM1RST_Msk: u32 = 2147483648;
pub const RCC_APB1RSTR1_LPTIM1RST: u32 = 2147483648;
pub const RCC_APB1RSTR2_LPUART1RST_Pos: u32 = 0;
pub const RCC_APB1RSTR2_LPUART1RST_Msk: u32 = 1;
pub const RCC_APB1RSTR2_LPUART1RST: u32 = 1;
pub const RCC_APB1RSTR2_LPTIM2RST_Pos: u32 = 5;
pub const RCC_APB1RSTR2_LPTIM2RST_Msk: u32 = 32;
pub const RCC_APB1RSTR2_LPTIM2RST: u32 = 32;
pub const RCC_APB2RSTR_TIM1RST_Pos: u32 = 11;
pub const RCC_APB2RSTR_TIM1RST_Msk: u32 = 2048;
pub const RCC_APB2RSTR_TIM1RST: u32 = 2048;
pub const RCC_APB2RSTR_SPI1RST_Pos: u32 = 12;
pub const RCC_APB2RSTR_SPI1RST_Msk: u32 = 4096;
pub const RCC_APB2RSTR_SPI1RST: u32 = 4096;
pub const RCC_APB2RSTR_USART1RST_Pos: u32 = 14;
pub const RCC_APB2RSTR_USART1RST_Msk: u32 = 16384;
pub const RCC_APB2RSTR_USART1RST: u32 = 16384;
pub const RCC_APB2RSTR_TIM16RST_Pos: u32 = 17;
pub const RCC_APB2RSTR_TIM16RST_Msk: u32 = 131072;
pub const RCC_APB2RSTR_TIM16RST: u32 = 131072;
pub const RCC_APB2RSTR_TIM17RST_Pos: u32 = 18;
pub const RCC_APB2RSTR_TIM17RST_Msk: u32 = 262144;
pub const RCC_APB2RSTR_TIM17RST: u32 = 262144;
pub const RCC_APB2RSTR_SAI1RST_Pos: u32 = 21;
pub const RCC_APB2RSTR_SAI1RST_Msk: u32 = 2097152;
pub const RCC_APB2RSTR_SAI1RST: u32 = 2097152;
pub const RCC_APB3RSTR_RFRST_Pos: u32 = 0;
pub const RCC_APB3RSTR_RFRST_Msk: u32 = 1;
pub const RCC_APB3RSTR_RFRST: u32 = 1;
pub const RCC_AHB1ENR_DMA1EN_Pos: u32 = 0;
pub const RCC_AHB1ENR_DMA1EN_Msk: u32 = 1;
pub const RCC_AHB1ENR_DMA1EN: u32 = 1;
pub const RCC_AHB1ENR_DMA2EN_Pos: u32 = 1;
pub const RCC_AHB1ENR_DMA2EN_Msk: u32 = 2;
pub const RCC_AHB1ENR_DMA2EN: u32 = 2;
pub const RCC_AHB1ENR_DMAMUX1EN_Pos: u32 = 2;
pub const RCC_AHB1ENR_DMAMUX1EN_Msk: u32 = 4;
pub const RCC_AHB1ENR_DMAMUX1EN: u32 = 4;
pub const RCC_AHB1ENR_CRCEN_Pos: u32 = 12;
pub const RCC_AHB1ENR_CRCEN_Msk: u32 = 4096;
pub const RCC_AHB1ENR_CRCEN: u32 = 4096;
pub const RCC_AHB1ENR_TSCEN_Pos: u32 = 16;
pub const RCC_AHB1ENR_TSCEN_Msk: u32 = 65536;
pub const RCC_AHB1ENR_TSCEN: u32 = 65536;
pub const RCC_AHB2ENR_GPIOAEN_Pos: u32 = 0;
pub const RCC_AHB2ENR_GPIOAEN_Msk: u32 = 1;
pub const RCC_AHB2ENR_GPIOAEN: u32 = 1;
pub const RCC_AHB2ENR_GPIOBEN_Pos: u32 = 1;
pub const RCC_AHB2ENR_GPIOBEN_Msk: u32 = 2;
pub const RCC_AHB2ENR_GPIOBEN: u32 = 2;
pub const RCC_AHB2ENR_GPIOCEN_Pos: u32 = 2;
pub const RCC_AHB2ENR_GPIOCEN_Msk: u32 = 4;
pub const RCC_AHB2ENR_GPIOCEN: u32 = 4;
pub const RCC_AHB2ENR_GPIODEN_Pos: u32 = 3;
pub const RCC_AHB2ENR_GPIODEN_Msk: u32 = 8;
pub const RCC_AHB2ENR_GPIODEN: u32 = 8;
pub const RCC_AHB2ENR_GPIOEEN_Pos: u32 = 4;
pub const RCC_AHB2ENR_GPIOEEN_Msk: u32 = 16;
pub const RCC_AHB2ENR_GPIOEEN: u32 = 16;
pub const RCC_AHB2ENR_GPIOHEN_Pos: u32 = 7;
pub const RCC_AHB2ENR_GPIOHEN_Msk: u32 = 128;
pub const RCC_AHB2ENR_GPIOHEN: u32 = 128;
pub const RCC_AHB2ENR_ADCEN_Pos: u32 = 13;
pub const RCC_AHB2ENR_ADCEN_Msk: u32 = 8192;
pub const RCC_AHB2ENR_ADCEN: u32 = 8192;
pub const RCC_AHB2ENR_AES1EN_Pos: u32 = 16;
pub const RCC_AHB2ENR_AES1EN_Msk: u32 = 65536;
pub const RCC_AHB2ENR_AES1EN: u32 = 65536;
pub const RCC_AHB3ENR_QUADSPIEN_Pos: u32 = 8;
pub const RCC_AHB3ENR_QUADSPIEN_Msk: u32 = 256;
pub const RCC_AHB3ENR_QUADSPIEN: u32 = 256;
pub const RCC_AHB3ENR_PKAEN_Pos: u32 = 16;
pub const RCC_AHB3ENR_PKAEN_Msk: u32 = 65536;
pub const RCC_AHB3ENR_PKAEN: u32 = 65536;
pub const RCC_AHB3ENR_AES2EN_Pos: u32 = 17;
pub const RCC_AHB3ENR_AES2EN_Msk: u32 = 131072;
pub const RCC_AHB3ENR_AES2EN: u32 = 131072;
pub const RCC_AHB3ENR_RNGEN_Pos: u32 = 18;
pub const RCC_AHB3ENR_RNGEN_Msk: u32 = 262144;
pub const RCC_AHB3ENR_RNGEN: u32 = 262144;
pub const RCC_AHB3ENR_HSEMEN_Pos: u32 = 19;
pub const RCC_AHB3ENR_HSEMEN_Msk: u32 = 524288;
pub const RCC_AHB3ENR_HSEMEN: u32 = 524288;
pub const RCC_AHB3ENR_IPCCEN_Pos: u32 = 20;
pub const RCC_AHB3ENR_IPCCEN_Msk: u32 = 1048576;
pub const RCC_AHB3ENR_IPCCEN: u32 = 1048576;
pub const RCC_AHB3ENR_FLASHEN_Pos: u32 = 25;
pub const RCC_AHB3ENR_FLASHEN_Msk: u32 = 33554432;
pub const RCC_AHB3ENR_FLASHEN: u32 = 33554432;
pub const RCC_APB1ENR1_TIM2EN_Pos: u32 = 0;
pub const RCC_APB1ENR1_TIM2EN_Msk: u32 = 1;
pub const RCC_APB1ENR1_TIM2EN: u32 = 1;
pub const RCC_APB1ENR1_LCDEN_Pos: u32 = 9;
pub const RCC_APB1ENR1_LCDEN_Msk: u32 = 512;
pub const RCC_APB1ENR1_LCDEN: u32 = 512;
pub const RCC_APB1ENR1_RTCAPBEN_Pos: u32 = 10;
pub const RCC_APB1ENR1_RTCAPBEN_Msk: u32 = 1024;
pub const RCC_APB1ENR1_RTCAPBEN: u32 = 1024;
pub const RCC_APB1ENR1_WWDGEN_Pos: u32 = 11;
pub const RCC_APB1ENR1_WWDGEN_Msk: u32 = 2048;
pub const RCC_APB1ENR1_WWDGEN: u32 = 2048;
pub const RCC_APB1ENR1_SPI2EN_Pos: u32 = 14;
pub const RCC_APB1ENR1_SPI2EN_Msk: u32 = 16384;
pub const RCC_APB1ENR1_SPI2EN: u32 = 16384;
pub const RCC_APB1ENR1_I2C1EN_Pos: u32 = 21;
pub const RCC_APB1ENR1_I2C1EN_Msk: u32 = 2097152;
pub const RCC_APB1ENR1_I2C1EN: u32 = 2097152;
pub const RCC_APB1ENR1_I2C3EN_Pos: u32 = 23;
pub const RCC_APB1ENR1_I2C3EN_Msk: u32 = 8388608;
pub const RCC_APB1ENR1_I2C3EN: u32 = 8388608;
pub const RCC_APB1ENR1_CRSEN_Pos: u32 = 24;
pub const RCC_APB1ENR1_CRSEN_Msk: u32 = 16777216;
pub const RCC_APB1ENR1_CRSEN: u32 = 16777216;
pub const RCC_APB1ENR1_USBEN_Pos: u32 = 26;
pub const RCC_APB1ENR1_USBEN_Msk: u32 = 67108864;
pub const RCC_APB1ENR1_USBEN: u32 = 67108864;
pub const RCC_APB1ENR1_LPTIM1EN_Pos: u32 = 31;
pub const RCC_APB1ENR1_LPTIM1EN_Msk: u32 = 2147483648;
pub const RCC_APB1ENR1_LPTIM1EN: u32 = 2147483648;
pub const RCC_APB1ENR2_LPUART1EN_Pos: u32 = 0;
pub const RCC_APB1ENR2_LPUART1EN_Msk: u32 = 1;
pub const RCC_APB1ENR2_LPUART1EN: u32 = 1;
pub const RCC_APB1ENR2_LPTIM2EN_Pos: u32 = 5;
pub const RCC_APB1ENR2_LPTIM2EN_Msk: u32 = 32;
pub const RCC_APB1ENR2_LPTIM2EN: u32 = 32;
pub const RCC_APB2ENR_TIM1EN_Pos: u32 = 11;
pub const RCC_APB2ENR_TIM1EN_Msk: u32 = 2048;
pub const RCC_APB2ENR_TIM1EN: u32 = 2048;
pub const RCC_APB2ENR_SPI1EN_Pos: u32 = 12;
pub const RCC_APB2ENR_SPI1EN_Msk: u32 = 4096;
pub const RCC_APB2ENR_SPI1EN: u32 = 4096;
pub const RCC_APB2ENR_USART1EN_Pos: u32 = 14;
pub const RCC_APB2ENR_USART1EN_Msk: u32 = 16384;
pub const RCC_APB2ENR_USART1EN: u32 = 16384;
pub const RCC_APB2ENR_TIM16EN_Pos: u32 = 17;
pub const RCC_APB2ENR_TIM16EN_Msk: u32 = 131072;
pub const RCC_APB2ENR_TIM16EN: u32 = 131072;
pub const RCC_APB2ENR_TIM17EN_Pos: u32 = 18;
pub const RCC_APB2ENR_TIM17EN_Msk: u32 = 262144;
pub const RCC_APB2ENR_TIM17EN: u32 = 262144;
pub const RCC_APB2ENR_SAI1EN_Pos: u32 = 21;
pub const RCC_APB2ENR_SAI1EN_Msk: u32 = 2097152;
pub const RCC_APB2ENR_SAI1EN: u32 = 2097152;
pub const RCC_AHB1SMENR_DMA1SMEN_Pos: u32 = 0;
pub const RCC_AHB1SMENR_DMA1SMEN_Msk: u32 = 1;
pub const RCC_AHB1SMENR_DMA1SMEN: u32 = 1;
pub const RCC_AHB1SMENR_DMA2SMEN_Pos: u32 = 1;
pub const RCC_AHB1SMENR_DMA2SMEN_Msk: u32 = 2;
pub const RCC_AHB1SMENR_DMA2SMEN: u32 = 2;
pub const RCC_AHB1SMENR_DMAMUX1SMEN_Pos: u32 = 2;
pub const RCC_AHB1SMENR_DMAMUX1SMEN_Msk: u32 = 4;
pub const RCC_AHB1SMENR_DMAMUX1SMEN: u32 = 4;
pub const RCC_AHB1SMENR_SRAM1SMEN_Pos: u32 = 9;
pub const RCC_AHB1SMENR_SRAM1SMEN_Msk: u32 = 512;
pub const RCC_AHB1SMENR_SRAM1SMEN: u32 = 512;
pub const RCC_AHB1SMENR_CRCSMEN_Pos: u32 = 12;
pub const RCC_AHB1SMENR_CRCSMEN_Msk: u32 = 4096;
pub const RCC_AHB1SMENR_CRCSMEN: u32 = 4096;
pub const RCC_AHB1SMENR_TSCSMEN_Pos: u32 = 16;
pub const RCC_AHB1SMENR_TSCSMEN_Msk: u32 = 65536;
pub const RCC_AHB1SMENR_TSCSMEN: u32 = 65536;
pub const RCC_AHB2SMENR_GPIOASMEN_Pos: u32 = 0;
pub const RCC_AHB2SMENR_GPIOASMEN_Msk: u32 = 1;
pub const RCC_AHB2SMENR_GPIOASMEN: u32 = 1;
pub const RCC_AHB2SMENR_GPIOBSMEN_Pos: u32 = 1;
pub const RCC_AHB2SMENR_GPIOBSMEN_Msk: u32 = 2;
pub const RCC_AHB2SMENR_GPIOBSMEN: u32 = 2;
pub const RCC_AHB2SMENR_GPIOCSMEN_Pos: u32 = 2;
pub const RCC_AHB2SMENR_GPIOCSMEN_Msk: u32 = 4;
pub const RCC_AHB2SMENR_GPIOCSMEN: u32 = 4;
pub const RCC_AHB2SMENR_GPIODSMEN_Pos: u32 = 3;
pub const RCC_AHB2SMENR_GPIODSMEN_Msk: u32 = 8;
pub const RCC_AHB2SMENR_GPIODSMEN: u32 = 8;
pub const RCC_AHB2SMENR_GPIOESMEN_Pos: u32 = 4;
pub const RCC_AHB2SMENR_GPIOESMEN_Msk: u32 = 16;
pub const RCC_AHB2SMENR_GPIOESMEN: u32 = 16;
pub const RCC_AHB2SMENR_GPIOHSMEN_Pos: u32 = 7;
pub const RCC_AHB2SMENR_GPIOHSMEN_Msk: u32 = 128;
pub const RCC_AHB2SMENR_GPIOHSMEN: u32 = 128;
pub const RCC_AHB2SMENR_ADCSMEN_Pos: u32 = 13;
pub const RCC_AHB2SMENR_ADCSMEN_Msk: u32 = 8192;
pub const RCC_AHB2SMENR_ADCSMEN: u32 = 8192;
pub const RCC_AHB2SMENR_AES1SMEN_Pos: u32 = 16;
pub const RCC_AHB2SMENR_AES1SMEN_Msk: u32 = 65536;
pub const RCC_AHB2SMENR_AES1SMEN: u32 = 65536;
pub const RCC_AHB3SMENR_QUADSPISMEN_Pos: u32 = 8;
pub const RCC_AHB3SMENR_QUADSPISMEN_Msk: u32 = 256;
pub const RCC_AHB3SMENR_QUADSPISMEN: u32 = 256;
pub const RCC_AHB3SMENR_PKASMEN_Pos: u32 = 16;
pub const RCC_AHB3SMENR_PKASMEN_Msk: u32 = 65536;
pub const RCC_AHB3SMENR_PKASMEN: u32 = 65536;
pub const RCC_AHB3SMENR_AES2SMEN_Pos: u32 = 17;
pub const RCC_AHB3SMENR_AES2SMEN_Msk: u32 = 131072;
pub const RCC_AHB3SMENR_AES2SMEN: u32 = 131072;
pub const RCC_AHB3SMENR_RNGSMEN_Pos: u32 = 18;
pub const RCC_AHB3SMENR_RNGSMEN_Msk: u32 = 262144;
pub const RCC_AHB3SMENR_RNGSMEN: u32 = 262144;
pub const RCC_AHB3SMENR_SRAM2SMEN_Pos: u32 = 24;
pub const RCC_AHB3SMENR_SRAM2SMEN_Msk: u32 = 16777216;
pub const RCC_AHB3SMENR_SRAM2SMEN: u32 = 16777216;
pub const RCC_AHB3SMENR_FLASHSMEN_Pos: u32 = 25;
pub const RCC_AHB3SMENR_FLASHSMEN_Msk: u32 = 33554432;
pub const RCC_AHB3SMENR_FLASHSMEN: u32 = 33554432;
pub const RCC_APB1SMENR1_TIM2SMEN_Pos: u32 = 0;
pub const RCC_APB1SMENR1_TIM2SMEN_Msk: u32 = 1;
pub const RCC_APB1SMENR1_TIM2SMEN: u32 = 1;
pub const RCC_APB1SMENR1_LCDSMEN_Pos: u32 = 9;
pub const RCC_APB1SMENR1_LCDSMEN_Msk: u32 = 512;
pub const RCC_APB1SMENR1_LCDSMEN: u32 = 512;
pub const RCC_APB1SMENR1_RTCAPBSMEN_Pos: u32 = 10;
pub const RCC_APB1SMENR1_RTCAPBSMEN_Msk: u32 = 1024;
pub const RCC_APB1SMENR1_RTCAPBSMEN: u32 = 1024;
pub const RCC_APB1SMENR1_WWDGSMEN_Pos: u32 = 11;
pub const RCC_APB1SMENR1_WWDGSMEN_Msk: u32 = 2048;
pub const RCC_APB1SMENR1_WWDGSMEN: u32 = 2048;
pub const RCC_APB1SMENR1_SPI2SMEN_Pos: u32 = 14;
pub const RCC_APB1SMENR1_SPI2SMEN_Msk: u32 = 16384;
pub const RCC_APB1SMENR1_SPI2SMEN: u32 = 16384;
pub const RCC_APB1SMENR1_I2C1SMEN_Pos: u32 = 21;
pub const RCC_APB1SMENR1_I2C1SMEN_Msk: u32 = 2097152;
pub const RCC_APB1SMENR1_I2C1SMEN: u32 = 2097152;
pub const RCC_APB1SMENR1_I2C3SMEN_Pos: u32 = 23;
pub const RCC_APB1SMENR1_I2C3SMEN_Msk: u32 = 8388608;
pub const RCC_APB1SMENR1_I2C3SMEN: u32 = 8388608;
pub const RCC_APB1SMENR1_CRSSMEN_Pos: u32 = 24;
pub const RCC_APB1SMENR1_CRSSMEN_Msk: u32 = 16777216;
pub const RCC_APB1SMENR1_CRSSMEN: u32 = 16777216;
pub const RCC_APB1SMENR1_USBSMEN_Pos: u32 = 26;
pub const RCC_APB1SMENR1_USBSMEN_Msk: u32 = 67108864;
pub const RCC_APB1SMENR1_USBSMEN: u32 = 67108864;
pub const RCC_APB1SMENR1_LPTIM1SMEN_Pos: u32 = 31;
pub const RCC_APB1SMENR1_LPTIM1SMEN_Msk: u32 = 2147483648;
pub const RCC_APB1SMENR1_LPTIM1SMEN: u32 = 2147483648;
pub const RCC_APB1SMENR2_LPUART1SMEN_Pos: u32 = 0;
pub const RCC_APB1SMENR2_LPUART1SMEN_Msk: u32 = 1;
pub const RCC_APB1SMENR2_LPUART1SMEN: u32 = 1;
pub const RCC_APB1SMENR2_LPTIM2SMEN_Pos: u32 = 5;
pub const RCC_APB1SMENR2_LPTIM2SMEN_Msk: u32 = 32;
pub const RCC_APB1SMENR2_LPTIM2SMEN: u32 = 32;
pub const RCC_APB2SMENR_TIM1SMEN_Pos: u32 = 11;
pub const RCC_APB2SMENR_TIM1SMEN_Msk: u32 = 2048;
pub const RCC_APB2SMENR_TIM1SMEN: u32 = 2048;
pub const RCC_APB2SMENR_SPI1SMEN_Pos: u32 = 12;
pub const RCC_APB2SMENR_SPI1SMEN_Msk: u32 = 4096;
pub const RCC_APB2SMENR_SPI1SMEN: u32 = 4096;
pub const RCC_APB2SMENR_USART1SMEN_Pos: u32 = 14;
pub const RCC_APB2SMENR_USART1SMEN_Msk: u32 = 16384;
pub const RCC_APB2SMENR_USART1SMEN: u32 = 16384;
pub const RCC_APB2SMENR_TIM16SMEN_Pos: u32 = 17;
pub const RCC_APB2SMENR_TIM16SMEN_Msk: u32 = 131072;
pub const RCC_APB2SMENR_TIM16SMEN: u32 = 131072;
pub const RCC_APB2SMENR_TIM17SMEN_Pos: u32 = 18;
pub const RCC_APB2SMENR_TIM17SMEN_Msk: u32 = 262144;
pub const RCC_APB2SMENR_TIM17SMEN: u32 = 262144;
pub const RCC_APB2SMENR_SAI1SMEN_Pos: u32 = 21;
pub const RCC_APB2SMENR_SAI1SMEN_Msk: u32 = 2097152;
pub const RCC_APB2SMENR_SAI1SMEN: u32 = 2097152;
pub const RCC_CCIPR_USART1SEL_Pos: u32 = 0;
pub const RCC_CCIPR_USART1SEL_Msk: u32 = 3;
pub const RCC_CCIPR_USART1SEL: u32 = 3;
pub const RCC_CCIPR_USART1SEL_0: u32 = 1;
pub const RCC_CCIPR_USART1SEL_1: u32 = 2;
pub const RCC_CCIPR_LPUART1SEL_Pos: u32 = 10;
pub const RCC_CCIPR_LPUART1SEL_Msk: u32 = 3072;
pub const RCC_CCIPR_LPUART1SEL: u32 = 3072;
pub const RCC_CCIPR_LPUART1SEL_0: u32 = 1024;
pub const RCC_CCIPR_LPUART1SEL_1: u32 = 2048;
pub const RCC_CCIPR_I2C1SEL_Pos: u32 = 12;
pub const RCC_CCIPR_I2C1SEL_Msk: u32 = 12288;
pub const RCC_CCIPR_I2C1SEL: u32 = 12288;
pub const RCC_CCIPR_I2C1SEL_0: u32 = 4096;
pub const RCC_CCIPR_I2C1SEL_1: u32 = 8192;
pub const RCC_CCIPR_I2C3SEL_Pos: u32 = 16;
pub const RCC_CCIPR_I2C3SEL_Msk: u32 = 196608;
pub const RCC_CCIPR_I2C3SEL: u32 = 196608;
pub const RCC_CCIPR_I2C3SEL_0: u32 = 65536;
pub const RCC_CCIPR_I2C3SEL_1: u32 = 131072;
pub const RCC_CCIPR_LPTIM1SEL_Pos: u32 = 18;
pub const RCC_CCIPR_LPTIM1SEL_Msk: u32 = 786432;
pub const RCC_CCIPR_LPTIM1SEL: u32 = 786432;
pub const RCC_CCIPR_LPTIM1SEL_0: u32 = 262144;
pub const RCC_CCIPR_LPTIM1SEL_1: u32 = 524288;
pub const RCC_CCIPR_LPTIM2SEL_Pos: u32 = 20;
pub const RCC_CCIPR_LPTIM2SEL_Msk: u32 = 3145728;
pub const RCC_CCIPR_LPTIM2SEL: u32 = 3145728;
pub const RCC_CCIPR_LPTIM2SEL_0: u32 = 1048576;
pub const RCC_CCIPR_LPTIM2SEL_1: u32 = 2097152;
pub const RCC_CCIPR_SAI1SEL_Pos: u32 = 22;
pub const RCC_CCIPR_SAI1SEL_Msk: u32 = 12582912;
pub const RCC_CCIPR_SAI1SEL: u32 = 12582912;
pub const RCC_CCIPR_SAI1SEL_0: u32 = 4194304;
pub const RCC_CCIPR_SAI1SEL_1: u32 = 8388608;
pub const RCC_CCIPR_CLK48SEL_Pos: u32 = 26;
pub const RCC_CCIPR_CLK48SEL_Msk: u32 = 201326592;
pub const RCC_CCIPR_CLK48SEL: u32 = 201326592;
pub const RCC_CCIPR_CLK48SEL_0: u32 = 67108864;
pub const RCC_CCIPR_CLK48SEL_1: u32 = 134217728;
pub const RCC_CCIPR_ADCSEL_Pos: u32 = 28;
pub const RCC_CCIPR_ADCSEL_Msk: u32 = 805306368;
pub const RCC_CCIPR_ADCSEL: u32 = 805306368;
pub const RCC_CCIPR_ADCSEL_0: u32 = 268435456;
pub const RCC_CCIPR_ADCSEL_1: u32 = 536870912;
pub const RCC_CCIPR_RNGSEL_Pos: u32 = 30;
pub const RCC_CCIPR_RNGSEL_Msk: u32 = 3221225472;
pub const RCC_CCIPR_RNGSEL: u32 = 3221225472;
pub const RCC_CCIPR_RNGSEL_0: u32 = 1073741824;
pub const RCC_CCIPR_RNGSEL_1: u32 = 2147483648;
pub const RCC_BDCR_LSEON_Pos: u32 = 0;
pub const RCC_BDCR_LSEON_Msk: u32 = 1;
pub const RCC_BDCR_LSEON: u32 = 1;
pub const RCC_BDCR_LSERDY_Pos: u32 = 1;
pub const RCC_BDCR_LSERDY_Msk: u32 = 2;
pub const RCC_BDCR_LSERDY: u32 = 2;
pub const RCC_BDCR_LSEBYP_Pos: u32 = 2;
pub const RCC_BDCR_LSEBYP_Msk: u32 = 4;
pub const RCC_BDCR_LSEBYP: u32 = 4;
pub const RCC_BDCR_LSEDRV_Pos: u32 = 3;
pub const RCC_BDCR_LSEDRV_Msk: u32 = 24;
pub const RCC_BDCR_LSEDRV: u32 = 24;
pub const RCC_BDCR_LSEDRV_0: u32 = 8;
pub const RCC_BDCR_LSEDRV_1: u32 = 16;
pub const RCC_BDCR_LSECSSON_Pos: u32 = 5;
pub const RCC_BDCR_LSECSSON_Msk: u32 = 32;
pub const RCC_BDCR_LSECSSON: u32 = 32;
pub const RCC_BDCR_LSECSSD_Pos: u32 = 6;
pub const RCC_BDCR_LSECSSD_Msk: u32 = 64;
pub const RCC_BDCR_LSECSSD: u32 = 64;
pub const RCC_BDCR_RTCSEL_Pos: u32 = 8;
pub const RCC_BDCR_RTCSEL_Msk: u32 = 768;
pub const RCC_BDCR_RTCSEL: u32 = 768;
pub const RCC_BDCR_RTCSEL_0: u32 = 256;
pub const RCC_BDCR_RTCSEL_1: u32 = 512;
pub const RCC_BDCR_RTCEN_Pos: u32 = 15;
pub const RCC_BDCR_RTCEN_Msk: u32 = 32768;
pub const RCC_BDCR_RTCEN: u32 = 32768;
pub const RCC_BDCR_BDRST_Pos: u32 = 16;
pub const RCC_BDCR_BDRST_Msk: u32 = 65536;
pub const RCC_BDCR_BDRST: u32 = 65536;
pub const RCC_BDCR_LSCOEN_Pos: u32 = 24;
pub const RCC_BDCR_LSCOEN_Msk: u32 = 16777216;
pub const RCC_BDCR_LSCOEN: u32 = 16777216;
pub const RCC_BDCR_LSCOSEL_Pos: u32 = 25;
pub const RCC_BDCR_LSCOSEL_Msk: u32 = 33554432;
pub const RCC_BDCR_LSCOSEL: u32 = 33554432;
pub const RCC_CSR_LSI1ON_Pos: u32 = 0;
pub const RCC_CSR_LSI1ON_Msk: u32 = 1;
pub const RCC_CSR_LSI1ON: u32 = 1;
pub const RCC_CSR_LSI1RDY_Pos: u32 = 1;
pub const RCC_CSR_LSI1RDY_Msk: u32 = 2;
pub const RCC_CSR_LSI1RDY: u32 = 2;
pub const RCC_CSR_LSI2ON_Pos: u32 = 2;
pub const RCC_CSR_LSI2ON_Msk: u32 = 4;
pub const RCC_CSR_LSI2ON: u32 = 4;
pub const RCC_CSR_LSI2RDY_Pos: u32 = 3;
pub const RCC_CSR_LSI2RDY_Msk: u32 = 8;
pub const RCC_CSR_LSI2RDY: u32 = 8;
pub const RCC_CSR_LSI2TRIM_Pos: u32 = 8;
pub const RCC_CSR_LSI2TRIM_Msk: u32 = 3840;
pub const RCC_CSR_LSI2TRIM: u32 = 3840;
pub const RCC_CSR_LSI2TRIM_0: u32 = 256;
pub const RCC_CSR_LSI2TRIM_1: u32 = 512;
pub const RCC_CSR_LSI2TRIM_2: u32 = 1024;
pub const RCC_CSR_LSI2TRIM_3: u32 = 2048;
pub const RCC_CSR_RFWKPSEL_Pos: u32 = 14;
pub const RCC_CSR_RFWKPSEL_Msk: u32 = 49152;
pub const RCC_CSR_RFWKPSEL: u32 = 49152;
pub const RCC_CSR_RFWKPSEL_0: u32 = 16384;
pub const RCC_CSR_RFWKPSEL_1: u32 = 32768;
pub const RCC_CSR_RFRSTS_Pos: u32 = 16;
pub const RCC_CSR_RFRSTS_Msk: u32 = 65536;
pub const RCC_CSR_RFRSTS: u32 = 65536;
pub const RCC_CSR_RMVF_Pos: u32 = 23;
pub const RCC_CSR_RMVF_Msk: u32 = 8388608;
pub const RCC_CSR_RMVF: u32 = 8388608;
pub const RCC_CSR_OBLRSTF_Pos: u32 = 25;
pub const RCC_CSR_OBLRSTF_Msk: u32 = 33554432;
pub const RCC_CSR_OBLRSTF: u32 = 33554432;
pub const RCC_CSR_PINRSTF_Pos: u32 = 26;
pub const RCC_CSR_PINRSTF_Msk: u32 = 67108864;
pub const RCC_CSR_PINRSTF: u32 = 67108864;
pub const RCC_CSR_BORRSTF_Pos: u32 = 27;
pub const RCC_CSR_BORRSTF_Msk: u32 = 134217728;
pub const RCC_CSR_BORRSTF: u32 = 134217728;
pub const RCC_CSR_SFTRSTF_Pos: u32 = 28;
pub const RCC_CSR_SFTRSTF_Msk: u32 = 268435456;
pub const RCC_CSR_SFTRSTF: u32 = 268435456;
pub const RCC_CSR_IWDGRSTF_Pos: u32 = 29;
pub const RCC_CSR_IWDGRSTF_Msk: u32 = 536870912;
pub const RCC_CSR_IWDGRSTF: u32 = 536870912;
pub const RCC_CSR_WWDGRSTF_Pos: u32 = 30;
pub const RCC_CSR_WWDGRSTF_Msk: u32 = 1073741824;
pub const RCC_CSR_WWDGRSTF: u32 = 1073741824;
pub const RCC_CSR_LPWRRSTF_Pos: u32 = 31;
pub const RCC_CSR_LPWRRSTF_Msk: u32 = 2147483648;
pub const RCC_CSR_LPWRRSTF: u32 = 2147483648;
pub const RCC_CRRCR_HSI48ON_Pos: u32 = 0;
pub const RCC_CRRCR_HSI48ON_Msk: u32 = 1;
pub const RCC_CRRCR_HSI48ON: u32 = 1;
pub const RCC_CRRCR_HSI48RDY_Pos: u32 = 1;
pub const RCC_CRRCR_HSI48RDY_Msk: u32 = 2;
pub const RCC_CRRCR_HSI48RDY: u32 = 2;
pub const RCC_CRRCR_HSI48CAL_Pos: u32 = 7;
pub const RCC_CRRCR_HSI48CAL_Msk: u32 = 65408;
pub const RCC_CRRCR_HSI48CAL: u32 = 65408;
pub const RCC_CRRCR_HSI48CAL_0: u32 = 128;
pub const RCC_CRRCR_HSI48CAL_1: u32 = 256;
pub const RCC_CRRCR_HSI48CAL_2: u32 = 512;
pub const RCC_CRRCR_HSI48CAL_3: u32 = 1024;
pub const RCC_CRRCR_HSI48CAL_4: u32 = 2048;
pub const RCC_CRRCR_HSI48CAL_5: u32 = 4096;
pub const RCC_CRRCR_HSI48CAL_6: u32 = 8192;
pub const RCC_CRRCR_HSI48CAL_7: u32 = 16384;
pub const RCC_CRRCR_HSI48CAL_8: u32 = 32768;
pub const RCC_HSECR_UNLOCKED_Pos: u32 = 0;
pub const RCC_HSECR_UNLOCKED_Msk: u32 = 1;
pub const RCC_HSECR_UNLOCKED: u32 = 1;
pub const RCC_HSECR_HSES_Pos: u32 = 3;
pub const RCC_HSECR_HSES_Msk: u32 = 8;
pub const RCC_HSECR_HSES: u32 = 8;
pub const RCC_HSECR_HSEGMC_Pos: u32 = 4;
pub const RCC_HSECR_HSEGMC_Msk: u32 = 112;
pub const RCC_HSECR_HSEGMC: u32 = 112;
pub const RCC_HSECR_HSEGMC0_Pos: u32 = 4;
pub const RCC_HSECR_HSEGMC0_Msk: u32 = 16;
pub const RCC_HSECR_HSEGMC0: u32 = 16;
pub const RCC_HSECR_HSEGMC1_Pos: u32 = 5;
pub const RCC_HSECR_HSEGMC1_Msk: u32 = 32;
pub const RCC_HSECR_HSEGMC1: u32 = 32;
pub const RCC_HSECR_HSEGMC2_Pos: u32 = 6;
pub const RCC_HSECR_HSEGMC2_Msk: u32 = 64;
pub const RCC_HSECR_HSEGMC2: u32 = 64;
pub const RCC_HSECR_HSETUNE_Pos: u32 = 8;
pub const RCC_HSECR_HSETUNE_Msk: u32 = 16128;
pub const RCC_HSECR_HSETUNE: u32 = 16128;
pub const RCC_HSECR_HSETUNE0_Pos: u32 = 8;
pub const RCC_HSECR_HSETUNE0_Msk: u32 = 256;
pub const RCC_HSECR_HSETUNE0: u32 = 256;
pub const RCC_HSECR_HSETUNE1_Pos: u32 = 9;
pub const RCC_HSECR_HSETUNE1_Msk: u32 = 512;
pub const RCC_HSECR_HSETUNE1: u32 = 512;
pub const RCC_HSECR_HSETUNE2_Pos: u32 = 10;
pub const RCC_HSECR_HSETUNE2_Msk: u32 = 1024;
pub const RCC_HSECR_HSETUNE2: u32 = 1024;
pub const RCC_HSECR_HSETUNE3_Pos: u32 = 11;
pub const RCC_HSECR_HSETUNE3_Msk: u32 = 2048;
pub const RCC_HSECR_HSETUNE3: u32 = 2048;
pub const RCC_HSECR_HSETUNE4_Pos: u32 = 12;
pub const RCC_HSECR_HSETUNE4_Msk: u32 = 4096;
pub const RCC_HSECR_HSETUNE4: u32 = 4096;
pub const RCC_HSECR_HSETUNE5_Pos: u32 = 13;
pub const RCC_HSECR_HSETUNE5_Msk: u32 = 8192;
pub const RCC_HSECR_HSETUNE5: u32 = 8192;
pub const RCC_EXTCFGR_SHDHPRE_Pos: u32 = 0;
pub const RCC_EXTCFGR_SHDHPRE_Msk: u32 = 15;
pub const RCC_EXTCFGR_SHDHPRE: u32 = 15;
pub const RCC_EXTCFGR_SHDHPRE_0: u32 = 1;
pub const RCC_EXTCFGR_SHDHPRE_1: u32 = 2;
pub const RCC_EXTCFGR_SHDHPRE_2: u32 = 4;
pub const RCC_EXTCFGR_SHDHPRE_3: u32 = 8;
pub const RCC_EXTCFGR_C2HPRE_Pos: u32 = 4;
pub const RCC_EXTCFGR_C2HPRE_Msk: u32 = 240;
pub const RCC_EXTCFGR_C2HPRE: u32 = 240;
pub const RCC_EXTCFGR_C2HPRE_0: u32 = 16;
pub const RCC_EXTCFGR_C2HPRE_1: u32 = 32;
pub const RCC_EXTCFGR_C2HPRE_2: u32 = 64;
pub const RCC_EXTCFGR_C2HPRE_3: u32 = 128;
pub const RCC_EXTCFGR_SHDHPREF_Pos: u32 = 16;
pub const RCC_EXTCFGR_SHDHPREF_Msk: u32 = 65536;
pub const RCC_EXTCFGR_SHDHPREF: u32 = 65536;
pub const RCC_EXTCFGR_C2HPREF_Pos: u32 = 17;
pub const RCC_EXTCFGR_C2HPREF_Msk: u32 = 131072;
pub const RCC_EXTCFGR_C2HPREF: u32 = 131072;
pub const RCC_EXTCFGR_RFCSS_Pos: u32 = 20;
pub const RCC_EXTCFGR_RFCSS_Msk: u32 = 1048576;
pub const RCC_EXTCFGR_RFCSS: u32 = 1048576;
pub const RCC_C2AHB1ENR_DMA1EN_Pos: u32 = 0;
pub const RCC_C2AHB1ENR_DMA1EN_Msk: u32 = 1;
pub const RCC_C2AHB1ENR_DMA1EN: u32 = 1;
pub const RCC_C2AHB1ENR_DMA2EN_Pos: u32 = 1;
pub const RCC_C2AHB1ENR_DMA2EN_Msk: u32 = 2;
pub const RCC_C2AHB1ENR_DMA2EN: u32 = 2;
pub const RCC_C2AHB1ENR_DMAMUX1EN_Pos: u32 = 2;
pub const RCC_C2AHB1ENR_DMAMUX1EN_Msk: u32 = 4;
pub const RCC_C2AHB1ENR_DMAMUX1EN: u32 = 4;
pub const RCC_C2AHB1ENR_SRAM1EN_Pos: u32 = 9;
pub const RCC_C2AHB1ENR_SRAM1EN_Msk: u32 = 512;
pub const RCC_C2AHB1ENR_SRAM1EN: u32 = 512;
pub const RCC_C2AHB1ENR_CRCEN_Pos: u32 = 12;
pub const RCC_C2AHB1ENR_CRCEN_Msk: u32 = 4096;
pub const RCC_C2AHB1ENR_CRCEN: u32 = 4096;
pub const RCC_C2AHB1ENR_TSCEN_Pos: u32 = 16;
pub const RCC_C2AHB1ENR_TSCEN_Msk: u32 = 65536;
pub const RCC_C2AHB1ENR_TSCEN: u32 = 65536;
pub const RCC_C2AHB2ENR_GPIOAEN_Pos: u32 = 0;
pub const RCC_C2AHB2ENR_GPIOAEN_Msk: u32 = 1;
pub const RCC_C2AHB2ENR_GPIOAEN: u32 = 1;
pub const RCC_C2AHB2ENR_GPIOBEN_Pos: u32 = 1;
pub const RCC_C2AHB2ENR_GPIOBEN_Msk: u32 = 2;
pub const RCC_C2AHB2ENR_GPIOBEN: u32 = 2;
pub const RCC_C2AHB2ENR_GPIOCEN_Pos: u32 = 2;
pub const RCC_C2AHB2ENR_GPIOCEN_Msk: u32 = 4;
pub const RCC_C2AHB2ENR_GPIOCEN: u32 = 4;
pub const RCC_C2AHB2ENR_GPIODEN_Pos: u32 = 3;
pub const RCC_C2AHB2ENR_GPIODEN_Msk: u32 = 8;
pub const RCC_C2AHB2ENR_GPIODEN: u32 = 8;
pub const RCC_C2AHB2ENR_GPIOEEN_Pos: u32 = 4;
pub const RCC_C2AHB2ENR_GPIOEEN_Msk: u32 = 16;
pub const RCC_C2AHB2ENR_GPIOEEN: u32 = 16;
pub const RCC_C2AHB2ENR_GPIOHEN_Pos: u32 = 7;
pub const RCC_C2AHB2ENR_GPIOHEN_Msk: u32 = 128;
pub const RCC_C2AHB2ENR_GPIOHEN: u32 = 128;
pub const RCC_C2AHB2ENR_ADCEN_Pos: u32 = 13;
pub const RCC_C2AHB2ENR_ADCEN_Msk: u32 = 8192;
pub const RCC_C2AHB2ENR_ADCEN: u32 = 8192;
pub const RCC_C2AHB2ENR_AES1EN_Pos: u32 = 16;
pub const RCC_C2AHB2ENR_AES1EN_Msk: u32 = 65536;
pub const RCC_C2AHB2ENR_AES1EN: u32 = 65536;
pub const RCC_C2AHB3ENR_PKAEN_Pos: u32 = 16;
pub const RCC_C2AHB3ENR_PKAEN_Msk: u32 = 65536;
pub const RCC_C2AHB3ENR_PKAEN: u32 = 65536;
pub const RCC_C2AHB3ENR_AES2EN_Pos: u32 = 17;
pub const RCC_C2AHB3ENR_AES2EN_Msk: u32 = 131072;
pub const RCC_C2AHB3ENR_AES2EN: u32 = 131072;
pub const RCC_C2AHB3ENR_RNGEN_Pos: u32 = 18;
pub const RCC_C2AHB3ENR_RNGEN_Msk: u32 = 262144;
pub const RCC_C2AHB3ENR_RNGEN: u32 = 262144;
pub const RCC_C2AHB3ENR_HSEMEN_Pos: u32 = 19;
pub const RCC_C2AHB3ENR_HSEMEN_Msk: u32 = 524288;
pub const RCC_C2AHB3ENR_HSEMEN: u32 = 524288;
pub const RCC_C2AHB3ENR_IPCCEN_Pos: u32 = 20;
pub const RCC_C2AHB3ENR_IPCCEN_Msk: u32 = 1048576;
pub const RCC_C2AHB3ENR_IPCCEN: u32 = 1048576;
pub const RCC_C2AHB3ENR_FLASHEN_Pos: u32 = 25;
pub const RCC_C2AHB3ENR_FLASHEN_Msk: u32 = 33554432;
pub const RCC_C2AHB3ENR_FLASHEN: u32 = 33554432;
pub const RCC_C2APB1ENR1_TIM2EN_Pos: u32 = 0;
pub const RCC_C2APB1ENR1_TIM2EN_Msk: u32 = 1;
pub const RCC_C2APB1ENR1_TIM2EN: u32 = 1;
pub const RCC_C2APB1ENR1_LCDEN_Pos: u32 = 9;
pub const RCC_C2APB1ENR1_LCDEN_Msk: u32 = 512;
pub const RCC_C2APB1ENR1_LCDEN: u32 = 512;
pub const RCC_C2APB1ENR1_RTCAPBEN_Pos: u32 = 10;
pub const RCC_C2APB1ENR1_RTCAPBEN_Msk: u32 = 1024;
pub const RCC_C2APB1ENR1_RTCAPBEN: u32 = 1024;
pub const RCC_C2APB1ENR1_SPI2EN_Pos: u32 = 14;
pub const RCC_C2APB1ENR1_SPI2EN_Msk: u32 = 16384;
pub const RCC_C2APB1ENR1_SPI2EN: u32 = 16384;
pub const RCC_C2APB1ENR1_I2C1EN_Pos: u32 = 21;
pub const RCC_C2APB1ENR1_I2C1EN_Msk: u32 = 2097152;
pub const RCC_C2APB1ENR1_I2C1EN: u32 = 2097152;
pub const RCC_C2APB1ENR1_I2C3EN_Pos: u32 = 23;
pub const RCC_C2APB1ENR1_I2C3EN_Msk: u32 = 8388608;
pub const RCC_C2APB1ENR1_I2C3EN: u32 = 8388608;
pub const RCC_C2APB1ENR1_CRSEN_Pos: u32 = 24;
pub const RCC_C2APB1ENR1_CRSEN_Msk: u32 = 16777216;
pub const RCC_C2APB1ENR1_CRSEN: u32 = 16777216;
pub const RCC_C2APB1ENR1_USBEN_Pos: u32 = 26;
pub const RCC_C2APB1ENR1_USBEN_Msk: u32 = 67108864;
pub const RCC_C2APB1ENR1_USBEN: u32 = 67108864;
pub const RCC_C2APB1ENR1_LPTIM1EN_Pos: u32 = 31;
pub const RCC_C2APB1ENR1_LPTIM1EN_Msk: u32 = 2147483648;
pub const RCC_C2APB1ENR1_LPTIM1EN: u32 = 2147483648;
pub const RCC_C2APB1ENR2_LPUART1EN_Pos: u32 = 0;
pub const RCC_C2APB1ENR2_LPUART1EN_Msk: u32 = 1;
pub const RCC_C2APB1ENR2_LPUART1EN: u32 = 1;
pub const RCC_C2APB1ENR2_LPTIM2EN_Pos: u32 = 5;
pub const RCC_C2APB1ENR2_LPTIM2EN_Msk: u32 = 32;
pub const RCC_C2APB1ENR2_LPTIM2EN: u32 = 32;
pub const RCC_C2APB2ENR_TIM1EN_Pos: u32 = 11;
pub const RCC_C2APB2ENR_TIM1EN_Msk: u32 = 2048;
pub const RCC_C2APB2ENR_TIM1EN: u32 = 2048;
pub const RCC_C2APB2ENR_SPI1EN_Pos: u32 = 12;
pub const RCC_C2APB2ENR_SPI1EN_Msk: u32 = 4096;
pub const RCC_C2APB2ENR_SPI1EN: u32 = 4096;
pub const RCC_C2APB2ENR_USART1EN_Pos: u32 = 14;
pub const RCC_C2APB2ENR_USART1EN_Msk: u32 = 16384;
pub const RCC_C2APB2ENR_USART1EN: u32 = 16384;
pub const RCC_C2APB2ENR_TIM16EN_Pos: u32 = 17;
pub const RCC_C2APB2ENR_TIM16EN_Msk: u32 = 131072;
pub const RCC_C2APB2ENR_TIM16EN: u32 = 131072;
pub const RCC_C2APB2ENR_TIM17EN_Pos: u32 = 18;
pub const RCC_C2APB2ENR_TIM17EN_Msk: u32 = 262144;
pub const RCC_C2APB2ENR_TIM17EN: u32 = 262144;
pub const RCC_C2APB2ENR_SAI1EN_Pos: u32 = 21;
pub const RCC_C2APB2ENR_SAI1EN_Msk: u32 = 2097152;
pub const RCC_C2APB2ENR_SAI1EN: u32 = 2097152;
pub const RCC_C2APB3ENR_BLEEN_Pos: u32 = 0;
pub const RCC_C2APB3ENR_BLEEN_Msk: u32 = 1;
pub const RCC_C2APB3ENR_BLEEN: u32 = 1;
pub const RCC_C2APB3ENR_802EN_Pos: u32 = 1;
pub const RCC_C2APB3ENR_802EN_Msk: u32 = 2;
pub const RCC_C2APB3ENR_802EN: u32 = 2;
pub const RCC_C2AHB1SMENR_DMA1SMEN_Pos: u32 = 0;
pub const RCC_C2AHB1SMENR_DMA1SMEN_Msk: u32 = 1;
pub const RCC_C2AHB1SMENR_DMA1SMEN: u32 = 1;
pub const RCC_C2AHB1SMENR_DMA2SMEN_Pos: u32 = 1;
pub const RCC_C2AHB1SMENR_DMA2SMEN_Msk: u32 = 2;
pub const RCC_C2AHB1SMENR_DMA2SMEN: u32 = 2;
pub const RCC_C2AHB1SMENR_DMAMUX1SMEN_Pos: u32 = 2;
pub const RCC_C2AHB1SMENR_DMAMUX1SMEN_Msk: u32 = 4;
pub const RCC_C2AHB1SMENR_DMAMUX1SMEN: u32 = 4;
pub const RCC_C2AHB1SMENR_SRAM1SMEN_Pos: u32 = 9;
pub const RCC_C2AHB1SMENR_SRAM1SMEN_Msk: u32 = 512;
pub const RCC_C2AHB1SMENR_SRAM1SMEN: u32 = 512;
pub const RCC_C2AHB1SMENR_CRCSMEN_Pos: u32 = 12;
pub const RCC_C2AHB1SMENR_CRCSMEN_Msk: u32 = 4096;
pub const RCC_C2AHB1SMENR_CRCSMEN: u32 = 4096;
pub const RCC_C2AHB1SMENR_TSCSMEN_Pos: u32 = 16;
pub const RCC_C2AHB1SMENR_TSCSMEN_Msk: u32 = 65536;
pub const RCC_C2AHB1SMENR_TSCSMEN: u32 = 65536;
pub const RCC_C2AHB2SMENR_GPIOASMEN_Pos: u32 = 0;
pub const RCC_C2AHB2SMENR_GPIOASMEN_Msk: u32 = 1;
pub const RCC_C2AHB2SMENR_GPIOASMEN: u32 = 1;
pub const RCC_C2AHB2SMENR_GPIOBSMEN_Pos: u32 = 1;
pub const RCC_C2AHB2SMENR_GPIOBSMEN_Msk: u32 = 2;
pub const RCC_C2AHB2SMENR_GPIOBSMEN: u32 = 2;
pub const RCC_C2AHB2SMENR_GPIOCSMEN_Pos: u32 = 2;
pub const RCC_C2AHB2SMENR_GPIOCSMEN_Msk: u32 = 4;
pub const RCC_C2AHB2SMENR_GPIOCSMEN: u32 = 4;
pub const RCC_C2AHB2SMENR_GPIODSMEN_Pos: u32 = 3;
pub const RCC_C2AHB2SMENR_GPIODSMEN_Msk: u32 = 8;
pub const RCC_C2AHB2SMENR_GPIODSMEN: u32 = 8;
pub const RCC_C2AHB2SMENR_GPIOESMEN_Pos: u32 = 4;
pub const RCC_C2AHB2SMENR_GPIOESMEN_Msk: u32 = 16;
pub const RCC_C2AHB2SMENR_GPIOESMEN: u32 = 16;
pub const RCC_C2AHB2SMENR_GPIOHSMEN_Pos: u32 = 7;
pub const RCC_C2AHB2SMENR_GPIOHSMEN_Msk: u32 = 128;
pub const RCC_C2AHB2SMENR_GPIOHSMEN: u32 = 128;
pub const RCC_C2AHB2SMENR_ADCSMEN_Pos: u32 = 13;
pub const RCC_C2AHB2SMENR_ADCSMEN_Msk: u32 = 8192;
pub const RCC_C2AHB2SMENR_ADCSMEN: u32 = 8192;
pub const RCC_C2AHB2SMENR_AES1SMEN_Pos: u32 = 16;
pub const RCC_C2AHB2SMENR_AES1SMEN_Msk: u32 = 65536;
pub const RCC_C2AHB2SMENR_AES1SMEN: u32 = 65536;
pub const RCC_C2AHB3SMENR_PKASMEN_Pos: u32 = 16;
pub const RCC_C2AHB3SMENR_PKASMEN_Msk: u32 = 65536;
pub const RCC_C2AHB3SMENR_PKASMEN: u32 = 65536;
pub const RCC_C2AHB3SMENR_AES2SMEN_Pos: u32 = 17;
pub const RCC_C2AHB3SMENR_AES2SMEN_Msk: u32 = 131072;
pub const RCC_C2AHB3SMENR_AES2SMEN: u32 = 131072;
pub const RCC_C2AHB3SMENR_RNGSMEN_Pos: u32 = 18;
pub const RCC_C2AHB3SMENR_RNGSMEN_Msk: u32 = 262144;
pub const RCC_C2AHB3SMENR_RNGSMEN: u32 = 262144;
pub const RCC_C2AHB3SMENR_SRAM2SMEN_Pos: u32 = 24;
pub const RCC_C2AHB3SMENR_SRAM2SMEN_Msk: u32 = 16777216;
pub const RCC_C2AHB3SMENR_SRAM2SMEN: u32 = 16777216;
pub const RCC_C2AHB3SMENR_FLASHSMEN_Pos: u32 = 25;
pub const RCC_C2AHB3SMENR_FLASHSMEN_Msk: u32 = 33554432;
pub const RCC_C2AHB3SMENR_FLASHSMEN: u32 = 33554432;
pub const RCC_C2APB1SMENR1_TIM2SMEN_Pos: u32 = 0;
pub const RCC_C2APB1SMENR1_TIM2SMEN_Msk: u32 = 1;
pub const RCC_C2APB1SMENR1_TIM2SMEN: u32 = 1;
pub const RCC_C2APB1SMENR1_LCDSMEN_Pos: u32 = 9;
pub const RCC_C2APB1SMENR1_LCDSMEN_Msk: u32 = 512;
pub const RCC_C2APB1SMENR1_LCDSMEN: u32 = 512;
pub const RCC_C2APB1SMENR1_RTCAPBSMEN_Pos: u32 = 10;
pub const RCC_C2APB1SMENR1_RTCAPBSMEN_Msk: u32 = 1024;
pub const RCC_C2APB1SMENR1_RTCAPBSMEN: u32 = 1024;
pub const RCC_C2APB1SMENR1_SPI2SMEN_Pos: u32 = 14;
pub const RCC_C2APB1SMENR1_SPI2SMEN_Msk: u32 = 16384;
pub const RCC_C2APB1SMENR1_SPI2SMEN: u32 = 16384;
pub const RCC_C2APB1SMENR1_I2C1SMEN_Pos: u32 = 21;
pub const RCC_C2APB1SMENR1_I2C1SMEN_Msk: u32 = 2097152;
pub const RCC_C2APB1SMENR1_I2C1SMEN: u32 = 2097152;
pub const RCC_C2APB1SMENR1_I2C3SMEN_Pos: u32 = 23;
pub const RCC_C2APB1SMENR1_I2C3SMEN_Msk: u32 = 8388608;
pub const RCC_C2APB1SMENR1_I2C3SMEN: u32 = 8388608;
pub const RCC_C2APB1SMENR1_CRSSMEN_Pos: u32 = 24;
pub const RCC_C2APB1SMENR1_CRSSMEN_Msk: u32 = 16777216;
pub const RCC_C2APB1SMENR1_CRSSMEN: u32 = 16777216;
pub const RCC_C2APB1SMENR1_USBSMEN_Pos: u32 = 26;
pub const RCC_C2APB1SMENR1_USBSMEN_Msk: u32 = 67108864;
pub const RCC_C2APB1SMENR1_USBSMEN: u32 = 67108864;
pub const RCC_C2APB1SMENR1_LPTIM1SMEN_Pos: u32 = 31;
pub const RCC_C2APB1SMENR1_LPTIM1SMEN_Msk: u32 = 2147483648;
pub const RCC_C2APB1SMENR1_LPTIM1SMEN: u32 = 2147483648;
pub const RCC_C2APB1SMENR2_LPUART1SMEN_Pos: u32 = 0;
pub const RCC_C2APB1SMENR2_LPUART1SMEN_Msk: u32 = 1;
pub const RCC_C2APB1SMENR2_LPUART1SMEN: u32 = 1;
pub const RCC_C2APB1SMENR2_LPTIM2SMEN_Pos: u32 = 5;
pub const RCC_C2APB1SMENR2_LPTIM2SMEN_Msk: u32 = 32;
pub const RCC_C2APB1SMENR2_LPTIM2SMEN: u32 = 32;
pub const RCC_C2APB2SMENR_TIM1SMEN_Pos: u32 = 11;
pub const RCC_C2APB2SMENR_TIM1SMEN_Msk: u32 = 2048;
pub const RCC_C2APB2SMENR_TIM1SMEN: u32 = 2048;
pub const RCC_C2APB2SMENR_SPI1SMEN_Pos: u32 = 12;
pub const RCC_C2APB2SMENR_SPI1SMEN_Msk: u32 = 4096;
pub const RCC_C2APB2SMENR_SPI1SMEN: u32 = 4096;
pub const RCC_C2APB2SMENR_USART1SMEN_Pos: u32 = 14;
pub const RCC_C2APB2SMENR_USART1SMEN_Msk: u32 = 16384;
pub const RCC_C2APB2SMENR_USART1SMEN: u32 = 16384;
pub const RCC_C2APB2SMENR_TIM16SMEN_Pos: u32 = 17;
pub const RCC_C2APB2SMENR_TIM16SMEN_Msk: u32 = 131072;
pub const RCC_C2APB2SMENR_TIM16SMEN: u32 = 131072;
pub const RCC_C2APB2SMENR_TIM17SMEN_Pos: u32 = 18;
pub const RCC_C2APB2SMENR_TIM17SMEN_Msk: u32 = 262144;
pub const RCC_C2APB2SMENR_TIM17SMEN: u32 = 262144;
pub const RCC_C2APB2SMENR_SAI1SMEN_Pos: u32 = 21;
pub const RCC_C2APB2SMENR_SAI1SMEN_Msk: u32 = 2097152;
pub const RCC_C2APB2SMENR_SAI1SMEN: u32 = 2097152;
pub const RCC_C2APB3SMENR_BLESMEN_Pos: u32 = 0;
pub const RCC_C2APB3SMENR_BLESMEN_Msk: u32 = 1;
pub const RCC_C2APB3SMENR_BLESMEN: u32 = 1;
pub const RCC_C2APB3SMENR_802SMEN_Pos: u32 = 1;
pub const RCC_C2APB3SMENR_802SMEN_Msk: u32 = 2;
pub const RCC_C2APB3SMENR_802SMEN: u32 = 2;
pub const RNG_CR_RNGEN_Pos: u32 = 2;
pub const RNG_CR_RNGEN_Msk: u32 = 4;
pub const RNG_CR_RNGEN: u32 = 4;
pub const RNG_CR_IE_Pos: u32 = 3;
pub const RNG_CR_IE_Msk: u32 = 8;
pub const RNG_CR_IE: u32 = 8;
pub const RNG_CR_CED_Pos: u32 = 5;
pub const RNG_CR_CED_Msk: u32 = 32;
pub const RNG_CR_CED: u32 = 32;
pub const RNG_SR_DRDY_Pos: u32 = 0;
pub const RNG_SR_DRDY_Msk: u32 = 1;
pub const RNG_SR_DRDY: u32 = 1;
pub const RNG_SR_CECS_Pos: u32 = 1;
pub const RNG_SR_CECS_Msk: u32 = 2;
pub const RNG_SR_CECS: u32 = 2;
pub const RNG_SR_SECS_Pos: u32 = 2;
pub const RNG_SR_SECS_Msk: u32 = 4;
pub const RNG_SR_SECS: u32 = 4;
pub const RNG_SR_CEIS_Pos: u32 = 5;
pub const RNG_SR_CEIS_Msk: u32 = 32;
pub const RNG_SR_CEIS: u32 = 32;
pub const RNG_SR_SEIS_Pos: u32 = 6;
pub const RNG_SR_SEIS_Msk: u32 = 64;
pub const RNG_SR_SEIS: u32 = 64;
pub const RTC_TR_PM_Pos: u32 = 22;
pub const RTC_TR_PM_Msk: u32 = 4194304;
pub const RTC_TR_PM: u32 = 4194304;
pub const RTC_TR_HT_Pos: u32 = 20;
pub const RTC_TR_HT_Msk: u32 = 3145728;
pub const RTC_TR_HT: u32 = 3145728;
pub const RTC_TR_HT_0: u32 = 1048576;
pub const RTC_TR_HT_1: u32 = 2097152;
pub const RTC_TR_HU_Pos: u32 = 16;
pub const RTC_TR_HU_Msk: u32 = 983040;
pub const RTC_TR_HU: u32 = 983040;
pub const RTC_TR_HU_0: u32 = 65536;
pub const RTC_TR_HU_1: u32 = 131072;
pub const RTC_TR_HU_2: u32 = 262144;
pub const RTC_TR_HU_3: u32 = 524288;
pub const RTC_TR_MNT_Pos: u32 = 12;
pub const RTC_TR_MNT_Msk: u32 = 28672;
pub const RTC_TR_MNT: u32 = 28672;
pub const RTC_TR_MNT_0: u32 = 4096;
pub const RTC_TR_MNT_1: u32 = 8192;
pub const RTC_TR_MNT_2: u32 = 16384;
pub const RTC_TR_MNU_Pos: u32 = 8;
pub const RTC_TR_MNU_Msk: u32 = 3840;
pub const RTC_TR_MNU: u32 = 3840;
pub const RTC_TR_MNU_0: u32 = 256;
pub const RTC_TR_MNU_1: u32 = 512;
pub const RTC_TR_MNU_2: u32 = 1024;
pub const RTC_TR_MNU_3: u32 = 2048;
pub const RTC_TR_ST_Pos: u32 = 4;
pub const RTC_TR_ST_Msk: u32 = 112;
pub const RTC_TR_ST: u32 = 112;
pub const RTC_TR_ST_0: u32 = 16;
pub const RTC_TR_ST_1: u32 = 32;
pub const RTC_TR_ST_2: u32 = 64;
pub const RTC_TR_SU_Pos: u32 = 0;
pub const RTC_TR_SU_Msk: u32 = 15;
pub const RTC_TR_SU: u32 = 15;
pub const RTC_TR_SU_0: u32 = 1;
pub const RTC_TR_SU_1: u32 = 2;
pub const RTC_TR_SU_2: u32 = 4;
pub const RTC_TR_SU_3: u32 = 8;
pub const RTC_DR_YT_Pos: u32 = 20;
pub const RTC_DR_YT_Msk: u32 = 15728640;
pub const RTC_DR_YT: u32 = 15728640;
pub const RTC_DR_YT_0: u32 = 1048576;
pub const RTC_DR_YT_1: u32 = 2097152;
pub const RTC_DR_YT_2: u32 = 4194304;
pub const RTC_DR_YT_3: u32 = 8388608;
pub const RTC_DR_YU_Pos: u32 = 16;
pub const RTC_DR_YU_Msk: u32 = 983040;
pub const RTC_DR_YU: u32 = 983040;
pub const RTC_DR_YU_0: u32 = 65536;
pub const RTC_DR_YU_1: u32 = 131072;
pub const RTC_DR_YU_2: u32 = 262144;
pub const RTC_DR_YU_3: u32 = 524288;
pub const RTC_DR_WDU_Pos: u32 = 13;
pub const RTC_DR_WDU_Msk: u32 = 57344;
pub const RTC_DR_WDU: u32 = 57344;
pub const RTC_DR_WDU_0: u32 = 8192;
pub const RTC_DR_WDU_1: u32 = 16384;
pub const RTC_DR_WDU_2: u32 = 32768;
pub const RTC_DR_MT_Pos: u32 = 12;
pub const RTC_DR_MT_Msk: u32 = 4096;
pub const RTC_DR_MT: u32 = 4096;
pub const RTC_DR_MU_Pos: u32 = 8;
pub const RTC_DR_MU_Msk: u32 = 3840;
pub const RTC_DR_MU: u32 = 3840;
pub const RTC_DR_MU_0: u32 = 256;
pub const RTC_DR_MU_1: u32 = 512;
pub const RTC_DR_MU_2: u32 = 1024;
pub const RTC_DR_MU_3: u32 = 2048;
pub const RTC_DR_DT_Pos: u32 = 4;
pub const RTC_DR_DT_Msk: u32 = 48;
pub const RTC_DR_DT: u32 = 48;
pub const RTC_DR_DT_0: u32 = 16;
pub const RTC_DR_DT_1: u32 = 32;
pub const RTC_DR_DU_Pos: u32 = 0;
pub const RTC_DR_DU_Msk: u32 = 15;
pub const RTC_DR_DU: u32 = 15;
pub const RTC_DR_DU_0: u32 = 1;
pub const RTC_DR_DU_1: u32 = 2;
pub const RTC_DR_DU_2: u32 = 4;
pub const RTC_DR_DU_3: u32 = 8;
pub const RTC_CR_ITSE_Pos: u32 = 24;
pub const RTC_CR_ITSE_Msk: u32 = 16777216;
pub const RTC_CR_ITSE: u32 = 16777216;
pub const RTC_CR_COE_Pos: u32 = 23;
pub const RTC_CR_COE_Msk: u32 = 8388608;
pub const RTC_CR_COE: u32 = 8388608;
pub const RTC_CR_OSEL_Pos: u32 = 21;
pub const RTC_CR_OSEL_Msk: u32 = 6291456;
pub const RTC_CR_OSEL: u32 = 6291456;
pub const RTC_CR_OSEL_0: u32 = 2097152;
pub const RTC_CR_OSEL_1: u32 = 4194304;
pub const RTC_CR_POL_Pos: u32 = 20;
pub const RTC_CR_POL_Msk: u32 = 1048576;
pub const RTC_CR_POL: u32 = 1048576;
pub const RTC_CR_COSEL_Pos: u32 = 19;
pub const RTC_CR_COSEL_Msk: u32 = 524288;
pub const RTC_CR_COSEL: u32 = 524288;
pub const RTC_CR_BKP_Pos: u32 = 18;
pub const RTC_CR_BKP_Msk: u32 = 262144;
pub const RTC_CR_BKP: u32 = 262144;
pub const RTC_CR_SUB1H_Pos: u32 = 17;
pub const RTC_CR_SUB1H_Msk: u32 = 131072;
pub const RTC_CR_SUB1H: u32 = 131072;
pub const RTC_CR_ADD1H_Pos: u32 = 16;
pub const RTC_CR_ADD1H_Msk: u32 = 65536;
pub const RTC_CR_ADD1H: u32 = 65536;
pub const RTC_CR_TSIE_Pos: u32 = 15;
pub const RTC_CR_TSIE_Msk: u32 = 32768;
pub const RTC_CR_TSIE: u32 = 32768;
pub const RTC_CR_WUTIE_Pos: u32 = 14;
pub const RTC_CR_WUTIE_Msk: u32 = 16384;
pub const RTC_CR_WUTIE: u32 = 16384;
pub const RTC_CR_ALRBIE_Pos: u32 = 13;
pub const RTC_CR_ALRBIE_Msk: u32 = 8192;
pub const RTC_CR_ALRBIE: u32 = 8192;
pub const RTC_CR_ALRAIE_Pos: u32 = 12;
pub const RTC_CR_ALRAIE_Msk: u32 = 4096;
pub const RTC_CR_ALRAIE: u32 = 4096;
pub const RTC_CR_TSE_Pos: u32 = 11;
pub const RTC_CR_TSE_Msk: u32 = 2048;
pub const RTC_CR_TSE: u32 = 2048;
pub const RTC_CR_WUTE_Pos: u32 = 10;
pub const RTC_CR_WUTE_Msk: u32 = 1024;
pub const RTC_CR_WUTE: u32 = 1024;
pub const RTC_CR_ALRBE_Pos: u32 = 9;
pub const RTC_CR_ALRBE_Msk: u32 = 512;
pub const RTC_CR_ALRBE: u32 = 512;
pub const RTC_CR_ALRAE_Pos: u32 = 8;
pub const RTC_CR_ALRAE_Msk: u32 = 256;
pub const RTC_CR_ALRAE: u32 = 256;
pub const RTC_CR_FMT_Pos: u32 = 6;
pub const RTC_CR_FMT_Msk: u32 = 64;
pub const RTC_CR_FMT: u32 = 64;
pub const RTC_CR_BYPSHAD_Pos: u32 = 5;
pub const RTC_CR_BYPSHAD_Msk: u32 = 32;
pub const RTC_CR_BYPSHAD: u32 = 32;
pub const RTC_CR_REFCKON_Pos: u32 = 4;
pub const RTC_CR_REFCKON_Msk: u32 = 16;
pub const RTC_CR_REFCKON: u32 = 16;
pub const RTC_CR_TSEDGE_Pos: u32 = 3;
pub const RTC_CR_TSEDGE_Msk: u32 = 8;
pub const RTC_CR_TSEDGE: u32 = 8;
pub const RTC_CR_WUCKSEL_Pos: u32 = 0;
pub const RTC_CR_WUCKSEL_Msk: u32 = 7;
pub const RTC_CR_WUCKSEL: u32 = 7;
pub const RTC_CR_WUCKSEL_0: u32 = 1;
pub const RTC_CR_WUCKSEL_1: u32 = 2;
pub const RTC_CR_WUCKSEL_2: u32 = 4;
pub const RTC_ISR_ITSF_Pos: u32 = 17;
pub const RTC_ISR_ITSF_Msk: u32 = 131072;
pub const RTC_ISR_ITSF: u32 = 131072;
pub const RTC_ISR_RECALPF_Pos: u32 = 16;
pub const RTC_ISR_RECALPF_Msk: u32 = 65536;
pub const RTC_ISR_RECALPF: u32 = 65536;
pub const RTC_ISR_TAMP3F_Pos: u32 = 15;
pub const RTC_ISR_TAMP3F_Msk: u32 = 32768;
pub const RTC_ISR_TAMP3F: u32 = 32768;
pub const RTC_ISR_TAMP2F_Pos: u32 = 14;
pub const RTC_ISR_TAMP2F_Msk: u32 = 16384;
pub const RTC_ISR_TAMP2F: u32 = 16384;
pub const RTC_ISR_TAMP1F_Pos: u32 = 13;
pub const RTC_ISR_TAMP1F_Msk: u32 = 8192;
pub const RTC_ISR_TAMP1F: u32 = 8192;
pub const RTC_ISR_TSOVF_Pos: u32 = 12;
pub const RTC_ISR_TSOVF_Msk: u32 = 4096;
pub const RTC_ISR_TSOVF: u32 = 4096;
pub const RTC_ISR_TSF_Pos: u32 = 11;
pub const RTC_ISR_TSF_Msk: u32 = 2048;
pub const RTC_ISR_TSF: u32 = 2048;
pub const RTC_ISR_WUTF_Pos: u32 = 10;
pub const RTC_ISR_WUTF_Msk: u32 = 1024;
pub const RTC_ISR_WUTF: u32 = 1024;
pub const RTC_ISR_ALRBF_Pos: u32 = 9;
pub const RTC_ISR_ALRBF_Msk: u32 = 512;
pub const RTC_ISR_ALRBF: u32 = 512;
pub const RTC_ISR_ALRAF_Pos: u32 = 8;
pub const RTC_ISR_ALRAF_Msk: u32 = 256;
pub const RTC_ISR_ALRAF: u32 = 256;
pub const RTC_ISR_INIT_Pos: u32 = 7;
pub const RTC_ISR_INIT_Msk: u32 = 128;
pub const RTC_ISR_INIT: u32 = 128;
pub const RTC_ISR_INITF_Pos: u32 = 6;
pub const RTC_ISR_INITF_Msk: u32 = 64;
pub const RTC_ISR_INITF: u32 = 64;
pub const RTC_ISR_RSF_Pos: u32 = 5;
pub const RTC_ISR_RSF_Msk: u32 = 32;
pub const RTC_ISR_RSF: u32 = 32;
pub const RTC_ISR_INITS_Pos: u32 = 4;
pub const RTC_ISR_INITS_Msk: u32 = 16;
pub const RTC_ISR_INITS: u32 = 16;
pub const RTC_ISR_SHPF_Pos: u32 = 3;
pub const RTC_ISR_SHPF_Msk: u32 = 8;
pub const RTC_ISR_SHPF: u32 = 8;
pub const RTC_ISR_WUTWF_Pos: u32 = 2;
pub const RTC_ISR_WUTWF_Msk: u32 = 4;
pub const RTC_ISR_WUTWF: u32 = 4;
pub const RTC_ISR_ALRBWF_Pos: u32 = 1;
pub const RTC_ISR_ALRBWF_Msk: u32 = 2;
pub const RTC_ISR_ALRBWF: u32 = 2;
pub const RTC_ISR_ALRAWF_Pos: u32 = 0;
pub const RTC_ISR_ALRAWF_Msk: u32 = 1;
pub const RTC_ISR_ALRAWF: u32 = 1;
pub const RTC_PRER_PREDIV_A_Pos: u32 = 16;
pub const RTC_PRER_PREDIV_A_Msk: u32 = 8323072;
pub const RTC_PRER_PREDIV_A: u32 = 8323072;
pub const RTC_PRER_PREDIV_S_Pos: u32 = 0;
pub const RTC_PRER_PREDIV_S_Msk: u32 = 32767;
pub const RTC_PRER_PREDIV_S: u32 = 32767;
pub const RTC_WUTR_WUT_Pos: u32 = 0;
pub const RTC_WUTR_WUT_Msk: u32 = 65535;
pub const RTC_WUTR_WUT: u32 = 65535;
pub const RTC_ALRMAR_MSK4_Pos: u32 = 31;
pub const RTC_ALRMAR_MSK4_Msk: u32 = 2147483648;
pub const RTC_ALRMAR_MSK4: u32 = 2147483648;
pub const RTC_ALRMAR_WDSEL_Pos: u32 = 30;
pub const RTC_ALRMAR_WDSEL_Msk: u32 = 1073741824;
pub const RTC_ALRMAR_WDSEL: u32 = 1073741824;
pub const RTC_ALRMAR_DT_Pos: u32 = 28;
pub const RTC_ALRMAR_DT_Msk: u32 = 805306368;
pub const RTC_ALRMAR_DT: u32 = 805306368;
pub const RTC_ALRMAR_DT_0: u32 = 268435456;
pub const RTC_ALRMAR_DT_1: u32 = 536870912;
pub const RTC_ALRMAR_DU_Pos: u32 = 24;
pub const RTC_ALRMAR_DU_Msk: u32 = 251658240;
pub const RTC_ALRMAR_DU: u32 = 251658240;
pub const RTC_ALRMAR_DU_0: u32 = 16777216;
pub const RTC_ALRMAR_DU_1: u32 = 33554432;
pub const RTC_ALRMAR_DU_2: u32 = 67108864;
pub const RTC_ALRMAR_DU_3: u32 = 134217728;
pub const RTC_ALRMAR_MSK3_Pos: u32 = 23;
pub const RTC_ALRMAR_MSK3_Msk: u32 = 8388608;
pub const RTC_ALRMAR_MSK3: u32 = 8388608;
pub const RTC_ALRMAR_PM_Pos: u32 = 22;
pub const RTC_ALRMAR_PM_Msk: u32 = 4194304;
pub const RTC_ALRMAR_PM: u32 = 4194304;
pub const RTC_ALRMAR_HT_Pos: u32 = 20;
pub const RTC_ALRMAR_HT_Msk: u32 = 3145728;
pub const RTC_ALRMAR_HT: u32 = 3145728;
pub const RTC_ALRMAR_HT_0: u32 = 1048576;
pub const RTC_ALRMAR_HT_1: u32 = 2097152;
pub const RTC_ALRMAR_HU_Pos: u32 = 16;
pub const RTC_ALRMAR_HU_Msk: u32 = 983040;
pub const RTC_ALRMAR_HU: u32 = 983040;
pub const RTC_ALRMAR_HU_0: u32 = 65536;
pub const RTC_ALRMAR_HU_1: u32 = 131072;
pub const RTC_ALRMAR_HU_2: u32 = 262144;
pub const RTC_ALRMAR_HU_3: u32 = 524288;
pub const RTC_ALRMAR_MSK2_Pos: u32 = 15;
pub const RTC_ALRMAR_MSK2_Msk: u32 = 32768;
pub const RTC_ALRMAR_MSK2: u32 = 32768;
pub const RTC_ALRMAR_MNT_Pos: u32 = 12;
pub const RTC_ALRMAR_MNT_Msk: u32 = 28672;
pub const RTC_ALRMAR_MNT: u32 = 28672;
pub const RTC_ALRMAR_MNT_0: u32 = 4096;
pub const RTC_ALRMAR_MNT_1: u32 = 8192;
pub const RTC_ALRMAR_MNT_2: u32 = 16384;
pub const RTC_ALRMAR_MNU_Pos: u32 = 8;
pub const RTC_ALRMAR_MNU_Msk: u32 = 3840;
pub const RTC_ALRMAR_MNU: u32 = 3840;
pub const RTC_ALRMAR_MNU_0: u32 = 256;
pub const RTC_ALRMAR_MNU_1: u32 = 512;
pub const RTC_ALRMAR_MNU_2: u32 = 1024;
pub const RTC_ALRMAR_MNU_3: u32 = 2048;
pub const RTC_ALRMAR_MSK1_Pos: u32 = 7;
pub const RTC_ALRMAR_MSK1_Msk: u32 = 128;
pub const RTC_ALRMAR_MSK1: u32 = 128;
pub const RTC_ALRMAR_ST_Pos: u32 = 4;
pub const RTC_ALRMAR_ST_Msk: u32 = 112;
pub const RTC_ALRMAR_ST: u32 = 112;
pub const RTC_ALRMAR_ST_0: u32 = 16;
pub const RTC_ALRMAR_ST_1: u32 = 32;
pub const RTC_ALRMAR_ST_2: u32 = 64;
pub const RTC_ALRMAR_SU_Pos: u32 = 0;
pub const RTC_ALRMAR_SU_Msk: u32 = 15;
pub const RTC_ALRMAR_SU: u32 = 15;
pub const RTC_ALRMAR_SU_0: u32 = 1;
pub const RTC_ALRMAR_SU_1: u32 = 2;
pub const RTC_ALRMAR_SU_2: u32 = 4;
pub const RTC_ALRMAR_SU_3: u32 = 8;
pub const RTC_ALRMBR_MSK4_Pos: u32 = 31;
pub const RTC_ALRMBR_MSK4_Msk: u32 = 2147483648;
pub const RTC_ALRMBR_MSK4: u32 = 2147483648;
pub const RTC_ALRMBR_WDSEL_Pos: u32 = 30;
pub const RTC_ALRMBR_WDSEL_Msk: u32 = 1073741824;
pub const RTC_ALRMBR_WDSEL: u32 = 1073741824;
pub const RTC_ALRMBR_DT_Pos: u32 = 28;
pub const RTC_ALRMBR_DT_Msk: u32 = 805306368;
pub const RTC_ALRMBR_DT: u32 = 805306368;
pub const RTC_ALRMBR_DT_0: u32 = 268435456;
pub const RTC_ALRMBR_DT_1: u32 = 536870912;
pub const RTC_ALRMBR_DU_Pos: u32 = 24;
pub const RTC_ALRMBR_DU_Msk: u32 = 251658240;
pub const RTC_ALRMBR_DU: u32 = 251658240;
pub const RTC_ALRMBR_DU_0: u32 = 16777216;
pub const RTC_ALRMBR_DU_1: u32 = 33554432;
pub const RTC_ALRMBR_DU_2: u32 = 67108864;
pub const RTC_ALRMBR_DU_3: u32 = 134217728;
pub const RTC_ALRMBR_MSK3_Pos: u32 = 23;
pub const RTC_ALRMBR_MSK3_Msk: u32 = 8388608;
pub const RTC_ALRMBR_MSK3: u32 = 8388608;
pub const RTC_ALRMBR_PM_Pos: u32 = 22;
pub const RTC_ALRMBR_PM_Msk: u32 = 4194304;
pub const RTC_ALRMBR_PM: u32 = 4194304;
pub const RTC_ALRMBR_HT_Pos: u32 = 20;
pub const RTC_ALRMBR_HT_Msk: u32 = 3145728;
pub const RTC_ALRMBR_HT: u32 = 3145728;
pub const RTC_ALRMBR_HT_0: u32 = 1048576;
pub const RTC_ALRMBR_HT_1: u32 = 2097152;
pub const RTC_ALRMBR_HU_Pos: u32 = 16;
pub const RTC_ALRMBR_HU_Msk: u32 = 983040;
pub const RTC_ALRMBR_HU: u32 = 983040;
pub const RTC_ALRMBR_HU_0: u32 = 65536;
pub const RTC_ALRMBR_HU_1: u32 = 131072;
pub const RTC_ALRMBR_HU_2: u32 = 262144;
pub const RTC_ALRMBR_HU_3: u32 = 524288;
pub const RTC_ALRMBR_MSK2_Pos: u32 = 15;
pub const RTC_ALRMBR_MSK2_Msk: u32 = 32768;
pub const RTC_ALRMBR_MSK2: u32 = 32768;
pub const RTC_ALRMBR_MNT_Pos: u32 = 12;
pub const RTC_ALRMBR_MNT_Msk: u32 = 28672;
pub const RTC_ALRMBR_MNT: u32 = 28672;
pub const RTC_ALRMBR_MNT_0: u32 = 4096;
pub const RTC_ALRMBR_MNT_1: u32 = 8192;
pub const RTC_ALRMBR_MNT_2: u32 = 16384;
pub const RTC_ALRMBR_MNU_Pos: u32 = 8;
pub const RTC_ALRMBR_MNU_Msk: u32 = 3840;
pub const RTC_ALRMBR_MNU: u32 = 3840;
pub const RTC_ALRMBR_MNU_0: u32 = 256;
pub const RTC_ALRMBR_MNU_1: u32 = 512;
pub const RTC_ALRMBR_MNU_2: u32 = 1024;
pub const RTC_ALRMBR_MNU_3: u32 = 2048;
pub const RTC_ALRMBR_MSK1_Pos: u32 = 7;
pub const RTC_ALRMBR_MSK1_Msk: u32 = 128;
pub const RTC_ALRMBR_MSK1: u32 = 128;
pub const RTC_ALRMBR_ST_Pos: u32 = 4;
pub const RTC_ALRMBR_ST_Msk: u32 = 112;
pub const RTC_ALRMBR_ST: u32 = 112;
pub const RTC_ALRMBR_ST_0: u32 = 16;
pub const RTC_ALRMBR_ST_1: u32 = 32;
pub const RTC_ALRMBR_ST_2: u32 = 64;
pub const RTC_ALRMBR_SU_Pos: u32 = 0;
pub const RTC_ALRMBR_SU_Msk: u32 = 15;
pub const RTC_ALRMBR_SU: u32 = 15;
pub const RTC_ALRMBR_SU_0: u32 = 1;
pub const RTC_ALRMBR_SU_1: u32 = 2;
pub const RTC_ALRMBR_SU_2: u32 = 4;
pub const RTC_ALRMBR_SU_3: u32 = 8;
pub const RTC_WPR_KEY_Pos: u32 = 0;
pub const RTC_WPR_KEY_Msk: u32 = 255;
pub const RTC_WPR_KEY: u32 = 255;
pub const RTC_SSR_SS_Pos: u32 = 0;
pub const RTC_SSR_SS_Msk: u32 = 65535;
pub const RTC_SSR_SS: u32 = 65535;
pub const RTC_SHIFTR_SUBFS_Pos: u32 = 0;
pub const RTC_SHIFTR_SUBFS_Msk: u32 = 32767;
pub const RTC_SHIFTR_SUBFS: u32 = 32767;
pub const RTC_SHIFTR_ADD1S_Pos: u32 = 31;
pub const RTC_SHIFTR_ADD1S_Msk: u32 = 2147483648;
pub const RTC_SHIFTR_ADD1S: u32 = 2147483648;
pub const RTC_TSTR_PM_Pos: u32 = 22;
pub const RTC_TSTR_PM_Msk: u32 = 4194304;
pub const RTC_TSTR_PM: u32 = 4194304;
pub const RTC_TSTR_HT_Pos: u32 = 20;
pub const RTC_TSTR_HT_Msk: u32 = 3145728;
pub const RTC_TSTR_HT: u32 = 3145728;
pub const RTC_TSTR_HT_0: u32 = 1048576;
pub const RTC_TSTR_HT_1: u32 = 2097152;
pub const RTC_TSTR_HU_Pos: u32 = 16;
pub const RTC_TSTR_HU_Msk: u32 = 983040;
pub const RTC_TSTR_HU: u32 = 983040;
pub const RTC_TSTR_HU_0: u32 = 65536;
pub const RTC_TSTR_HU_1: u32 = 131072;
pub const RTC_TSTR_HU_2: u32 = 262144;
pub const RTC_TSTR_HU_3: u32 = 524288;
pub const RTC_TSTR_MNT_Pos: u32 = 12;
pub const RTC_TSTR_MNT_Msk: u32 = 28672;
pub const RTC_TSTR_MNT: u32 = 28672;
pub const RTC_TSTR_MNT_0: u32 = 4096;
pub const RTC_TSTR_MNT_1: u32 = 8192;
pub const RTC_TSTR_MNT_2: u32 = 16384;
pub const RTC_TSTR_MNU_Pos: u32 = 8;
pub const RTC_TSTR_MNU_Msk: u32 = 3840;
pub const RTC_TSTR_MNU: u32 = 3840;
pub const RTC_TSTR_MNU_0: u32 = 256;
pub const RTC_TSTR_MNU_1: u32 = 512;
pub const RTC_TSTR_MNU_2: u32 = 1024;
pub const RTC_TSTR_MNU_3: u32 = 2048;
pub const RTC_TSTR_ST_Pos: u32 = 4;
pub const RTC_TSTR_ST_Msk: u32 = 112;
pub const RTC_TSTR_ST: u32 = 112;
pub const RTC_TSTR_ST_0: u32 = 16;
pub const RTC_TSTR_ST_1: u32 = 32;
pub const RTC_TSTR_ST_2: u32 = 64;
pub const RTC_TSTR_SU_Pos: u32 = 0;
pub const RTC_TSTR_SU_Msk: u32 = 15;
pub const RTC_TSTR_SU: u32 = 15;
pub const RTC_TSTR_SU_0: u32 = 1;
pub const RTC_TSTR_SU_1: u32 = 2;
pub const RTC_TSTR_SU_2: u32 = 4;
pub const RTC_TSTR_SU_3: u32 = 8;
pub const RTC_TSDR_WDU_Pos: u32 = 13;
pub const RTC_TSDR_WDU_Msk: u32 = 57344;
pub const RTC_TSDR_WDU: u32 = 57344;
pub const RTC_TSDR_WDU_0: u32 = 8192;
pub const RTC_TSDR_WDU_1: u32 = 16384;
pub const RTC_TSDR_WDU_2: u32 = 32768;
pub const RTC_TSDR_MT_Pos: u32 = 12;
pub const RTC_TSDR_MT_Msk: u32 = 4096;
pub const RTC_TSDR_MT: u32 = 4096;
pub const RTC_TSDR_MU_Pos: u32 = 8;
pub const RTC_TSDR_MU_Msk: u32 = 3840;
pub const RTC_TSDR_MU: u32 = 3840;
pub const RTC_TSDR_MU_0: u32 = 256;
pub const RTC_TSDR_MU_1: u32 = 512;
pub const RTC_TSDR_MU_2: u32 = 1024;
pub const RTC_TSDR_MU_3: u32 = 2048;
pub const RTC_TSDR_DT_Pos: u32 = 4;
pub const RTC_TSDR_DT_Msk: u32 = 48;
pub const RTC_TSDR_DT: u32 = 48;
pub const RTC_TSDR_DT_0: u32 = 16;
pub const RTC_TSDR_DT_1: u32 = 32;
pub const RTC_TSDR_DU_Pos: u32 = 0;
pub const RTC_TSDR_DU_Msk: u32 = 15;
pub const RTC_TSDR_DU: u32 = 15;
pub const RTC_TSDR_DU_0: u32 = 1;
pub const RTC_TSDR_DU_1: u32 = 2;
pub const RTC_TSDR_DU_2: u32 = 4;
pub const RTC_TSDR_DU_3: u32 = 8;
pub const RTC_TSSSR_SS_Pos: u32 = 0;
pub const RTC_TSSSR_SS_Msk: u32 = 65535;
pub const RTC_TSSSR_SS: u32 = 65535;
pub const RTC_CALR_CALP_Pos: u32 = 15;
pub const RTC_CALR_CALP_Msk: u32 = 32768;
pub const RTC_CALR_CALP: u32 = 32768;
pub const RTC_CALR_CALW8_Pos: u32 = 14;
pub const RTC_CALR_CALW8_Msk: u32 = 16384;
pub const RTC_CALR_CALW8: u32 = 16384;
pub const RTC_CALR_CALW16_Pos: u32 = 13;
pub const RTC_CALR_CALW16_Msk: u32 = 8192;
pub const RTC_CALR_CALW16: u32 = 8192;
pub const RTC_CALR_CALM_Pos: u32 = 0;
pub const RTC_CALR_CALM_Msk: u32 = 511;
pub const RTC_CALR_CALM: u32 = 511;
pub const RTC_CALR_CALM_0: u32 = 1;
pub const RTC_CALR_CALM_1: u32 = 2;
pub const RTC_CALR_CALM_2: u32 = 4;
pub const RTC_CALR_CALM_3: u32 = 8;
pub const RTC_CALR_CALM_4: u32 = 16;
pub const RTC_CALR_CALM_5: u32 = 32;
pub const RTC_CALR_CALM_6: u32 = 64;
pub const RTC_CALR_CALM_7: u32 = 128;
pub const RTC_CALR_CALM_8: u32 = 256;
pub const RTC_TAMPCR_TAMP3MF_Pos: u32 = 24;
pub const RTC_TAMPCR_TAMP3MF_Msk: u32 = 16777216;
pub const RTC_TAMPCR_TAMP3MF: u32 = 16777216;
pub const RTC_TAMPCR_TAMP3NOERASE_Pos: u32 = 23;
pub const RTC_TAMPCR_TAMP3NOERASE_Msk: u32 = 8388608;
pub const RTC_TAMPCR_TAMP3NOERASE: u32 = 8388608;
pub const RTC_TAMPCR_TAMP3IE_Pos: u32 = 22;
pub const RTC_TAMPCR_TAMP3IE_Msk: u32 = 4194304;
pub const RTC_TAMPCR_TAMP3IE: u32 = 4194304;
pub const RTC_TAMPCR_TAMP2MF_Pos: u32 = 21;
pub const RTC_TAMPCR_TAMP2MF_Msk: u32 = 2097152;
pub const RTC_TAMPCR_TAMP2MF: u32 = 2097152;
pub const RTC_TAMPCR_TAMP2NOERASE_Pos: u32 = 20;
pub const RTC_TAMPCR_TAMP2NOERASE_Msk: u32 = 1048576;
pub const RTC_TAMPCR_TAMP2NOERASE: u32 = 1048576;
pub const RTC_TAMPCR_TAMP2IE_Pos: u32 = 19;
pub const RTC_TAMPCR_TAMP2IE_Msk: u32 = 524288;
pub const RTC_TAMPCR_TAMP2IE: u32 = 524288;
pub const RTC_TAMPCR_TAMP1MF_Pos: u32 = 18;
pub const RTC_TAMPCR_TAMP1MF_Msk: u32 = 262144;
pub const RTC_TAMPCR_TAMP1MF: u32 = 262144;
pub const RTC_TAMPCR_TAMP1NOERASE_Pos: u32 = 17;
pub const RTC_TAMPCR_TAMP1NOERASE_Msk: u32 = 131072;
pub const RTC_TAMPCR_TAMP1NOERASE: u32 = 131072;
pub const RTC_TAMPCR_TAMP1IE_Pos: u32 = 16;
pub const RTC_TAMPCR_TAMP1IE_Msk: u32 = 65536;
pub const RTC_TAMPCR_TAMP1IE: u32 = 65536;
pub const RTC_TAMPCR_TAMPPUDIS_Pos: u32 = 15;
pub const RTC_TAMPCR_TAMPPUDIS_Msk: u32 = 32768;
pub const RTC_TAMPCR_TAMPPUDIS: u32 = 32768;
pub const RTC_TAMPCR_TAMPPRCH_Pos: u32 = 13;
pub const RTC_TAMPCR_TAMPPRCH_Msk: u32 = 24576;
pub const RTC_TAMPCR_TAMPPRCH: u32 = 24576;
pub const RTC_TAMPCR_TAMPPRCH_0: u32 = 8192;
pub const RTC_TAMPCR_TAMPPRCH_1: u32 = 16384;
pub const RTC_TAMPCR_TAMPFLT_Pos: u32 = 11;
pub const RTC_TAMPCR_TAMPFLT_Msk: u32 = 6144;
pub const RTC_TAMPCR_TAMPFLT: u32 = 6144;
pub const RTC_TAMPCR_TAMPFLT_0: u32 = 2048;
pub const RTC_TAMPCR_TAMPFLT_1: u32 = 4096;
pub const RTC_TAMPCR_TAMPFREQ_Pos: u32 = 8;
pub const RTC_TAMPCR_TAMPFREQ_Msk: u32 = 1792;
pub const RTC_TAMPCR_TAMPFREQ: u32 = 1792;
pub const RTC_TAMPCR_TAMPFREQ_0: u32 = 256;
pub const RTC_TAMPCR_TAMPFREQ_1: u32 = 512;
pub const RTC_TAMPCR_TAMPFREQ_2: u32 = 1024;
pub const RTC_TAMPCR_TAMPTS_Pos: u32 = 7;
pub const RTC_TAMPCR_TAMPTS_Msk: u32 = 128;
pub const RTC_TAMPCR_TAMPTS: u32 = 128;
pub const RTC_TAMPCR_TAMP3TRG_Pos: u32 = 6;
pub const RTC_TAMPCR_TAMP3TRG_Msk: u32 = 64;
pub const RTC_TAMPCR_TAMP3TRG: u32 = 64;
pub const RTC_TAMPCR_TAMP3E_Pos: u32 = 5;
pub const RTC_TAMPCR_TAMP3E_Msk: u32 = 32;
pub const RTC_TAMPCR_TAMP3E: u32 = 32;
pub const RTC_TAMPCR_TAMP2TRG_Pos: u32 = 4;
pub const RTC_TAMPCR_TAMP2TRG_Msk: u32 = 16;
pub const RTC_TAMPCR_TAMP2TRG: u32 = 16;
pub const RTC_TAMPCR_TAMP2E_Pos: u32 = 3;
pub const RTC_TAMPCR_TAMP2E_Msk: u32 = 8;
pub const RTC_TAMPCR_TAMP2E: u32 = 8;
pub const RTC_TAMPCR_TAMPIE_Pos: u32 = 2;
pub const RTC_TAMPCR_TAMPIE_Msk: u32 = 4;
pub const RTC_TAMPCR_TAMPIE: u32 = 4;
pub const RTC_TAMPCR_TAMP1TRG_Pos: u32 = 1;
pub const RTC_TAMPCR_TAMP1TRG_Msk: u32 = 2;
pub const RTC_TAMPCR_TAMP1TRG: u32 = 2;
pub const RTC_TAMPCR_TAMP1E_Pos: u32 = 0;
pub const RTC_TAMPCR_TAMP1E_Msk: u32 = 1;
pub const RTC_TAMPCR_TAMP1E: u32 = 1;
pub const RTC_ALRMASSR_MASKSS_Pos: u32 = 24;
pub const RTC_ALRMASSR_MASKSS_Msk: u32 = 251658240;
pub const RTC_ALRMASSR_MASKSS: u32 = 251658240;
pub const RTC_ALRMASSR_MASKSS_0: u32 = 16777216;
pub const RTC_ALRMASSR_MASKSS_1: u32 = 33554432;
pub const RTC_ALRMASSR_MASKSS_2: u32 = 67108864;
pub const RTC_ALRMASSR_MASKSS_3: u32 = 134217728;
pub const RTC_ALRMASSR_SS_Pos: u32 = 0;
pub const RTC_ALRMASSR_SS_Msk: u32 = 32767;
pub const RTC_ALRMASSR_SS: u32 = 32767;
pub const RTC_ALRMBSSR_MASKSS_Pos: u32 = 24;
pub const RTC_ALRMBSSR_MASKSS_Msk: u32 = 251658240;
pub const RTC_ALRMBSSR_MASKSS: u32 = 251658240;
pub const RTC_ALRMBSSR_MASKSS_0: u32 = 16777216;
pub const RTC_ALRMBSSR_MASKSS_1: u32 = 33554432;
pub const RTC_ALRMBSSR_MASKSS_2: u32 = 67108864;
pub const RTC_ALRMBSSR_MASKSS_3: u32 = 134217728;
pub const RTC_ALRMBSSR_SS_Pos: u32 = 0;
pub const RTC_ALRMBSSR_SS_Msk: u32 = 32767;
pub const RTC_ALRMBSSR_SS: u32 = 32767;
pub const RTC_OR_OUT_RMP_Pos: u32 = 1;
pub const RTC_OR_OUT_RMP_Msk: u32 = 2;
pub const RTC_OR_OUT_RMP: u32 = 2;
pub const RTC_OR_ALARMOUTTYPE_Pos: u32 = 0;
pub const RTC_OR_ALARMOUTTYPE_Msk: u32 = 1;
pub const RTC_OR_ALARMOUTTYPE: u32 = 1;
pub const RTC_BKP0R_Pos: u32 = 0;
pub const RTC_BKP0R_Msk: u32 = 4294967295;
pub const RTC_BKP0R: u32 = 4294967295;
pub const RTC_BKP1R_Pos: u32 = 0;
pub const RTC_BKP1R_Msk: u32 = 4294967295;
pub const RTC_BKP1R: u32 = 4294967295;
pub const RTC_BKP2R_Pos: u32 = 0;
pub const RTC_BKP2R_Msk: u32 = 4294967295;
pub const RTC_BKP2R: u32 = 4294967295;
pub const RTC_BKP3R_Pos: u32 = 0;
pub const RTC_BKP3R_Msk: u32 = 4294967295;
pub const RTC_BKP3R: u32 = 4294967295;
pub const RTC_BKP4R_Pos: u32 = 0;
pub const RTC_BKP4R_Msk: u32 = 4294967295;
pub const RTC_BKP4R: u32 = 4294967295;
pub const RTC_BKP5R_Pos: u32 = 0;
pub const RTC_BKP5R_Msk: u32 = 4294967295;
pub const RTC_BKP5R: u32 = 4294967295;
pub const RTC_BKP6R_Pos: u32 = 0;
pub const RTC_BKP6R_Msk: u32 = 4294967295;
pub const RTC_BKP6R: u32 = 4294967295;
pub const RTC_BKP7R_Pos: u32 = 0;
pub const RTC_BKP7R_Msk: u32 = 4294967295;
pub const RTC_BKP7R: u32 = 4294967295;
pub const RTC_BKP8R_Pos: u32 = 0;
pub const RTC_BKP8R_Msk: u32 = 4294967295;
pub const RTC_BKP8R: u32 = 4294967295;
pub const RTC_BKP9R_Pos: u32 = 0;
pub const RTC_BKP9R_Msk: u32 = 4294967295;
pub const RTC_BKP9R: u32 = 4294967295;
pub const RTC_BKP10R_Pos: u32 = 0;
pub const RTC_BKP10R_Msk: u32 = 4294967295;
pub const RTC_BKP10R: u32 = 4294967295;
pub const RTC_BKP11R_Pos: u32 = 0;
pub const RTC_BKP11R_Msk: u32 = 4294967295;
pub const RTC_BKP11R: u32 = 4294967295;
pub const RTC_BKP12R_Pos: u32 = 0;
pub const RTC_BKP12R_Msk: u32 = 4294967295;
pub const RTC_BKP12R: u32 = 4294967295;
pub const RTC_BKP13R_Pos: u32 = 0;
pub const RTC_BKP13R_Msk: u32 = 4294967295;
pub const RTC_BKP13R: u32 = 4294967295;
pub const RTC_BKP14R_Pos: u32 = 0;
pub const RTC_BKP14R_Msk: u32 = 4294967295;
pub const RTC_BKP14R: u32 = 4294967295;
pub const RTC_BKP15R_Pos: u32 = 0;
pub const RTC_BKP15R_Msk: u32 = 4294967295;
pub const RTC_BKP15R: u32 = 4294967295;
pub const RTC_BKP16R_Pos: u32 = 0;
pub const RTC_BKP16R_Msk: u32 = 4294967295;
pub const RTC_BKP16R: u32 = 4294967295;
pub const RTC_BKP17R_Pos: u32 = 0;
pub const RTC_BKP17R_Msk: u32 = 4294967295;
pub const RTC_BKP17R: u32 = 4294967295;
pub const RTC_BKP18R_Pos: u32 = 0;
pub const RTC_BKP18R_Msk: u32 = 4294967295;
pub const RTC_BKP18R: u32 = 4294967295;
pub const RTC_BKP19R_Pos: u32 = 0;
pub const RTC_BKP19R_Msk: u32 = 4294967295;
pub const RTC_BKP19R: u32 = 4294967295;
pub const RTC_BKP_NUMBER: u32 = 20;
pub const SPI_CR1_CPHA_Pos: u32 = 0;
pub const SPI_CR1_CPHA_Msk: u32 = 1;
pub const SPI_CR1_CPHA: u32 = 1;
pub const SPI_CR1_CPOL_Pos: u32 = 1;
pub const SPI_CR1_CPOL_Msk: u32 = 2;
pub const SPI_CR1_CPOL: u32 = 2;
pub const SPI_CR1_MSTR_Pos: u32 = 2;
pub const SPI_CR1_MSTR_Msk: u32 = 4;
pub const SPI_CR1_MSTR: u32 = 4;
pub const SPI_CR1_BR_Pos: u32 = 3;
pub const SPI_CR1_BR_Msk: u32 = 56;
pub const SPI_CR1_BR: u32 = 56;
pub const SPI_CR1_BR_0: u32 = 8;
pub const SPI_CR1_BR_1: u32 = 16;
pub const SPI_CR1_BR_2: u32 = 32;
pub const SPI_CR1_SPE_Pos: u32 = 6;
pub const SPI_CR1_SPE_Msk: u32 = 64;
pub const SPI_CR1_SPE: u32 = 64;
pub const SPI_CR1_LSBFIRST_Pos: u32 = 7;
pub const SPI_CR1_LSBFIRST_Msk: u32 = 128;
pub const SPI_CR1_LSBFIRST: u32 = 128;
pub const SPI_CR1_SSI_Pos: u32 = 8;
pub const SPI_CR1_SSI_Msk: u32 = 256;
pub const SPI_CR1_SSI: u32 = 256;
pub const SPI_CR1_SSM_Pos: u32 = 9;
pub const SPI_CR1_SSM_Msk: u32 = 512;
pub const SPI_CR1_SSM: u32 = 512;
pub const SPI_CR1_RXONLY_Pos: u32 = 10;
pub const SPI_CR1_RXONLY_Msk: u32 = 1024;
pub const SPI_CR1_RXONLY: u32 = 1024;
pub const SPI_CR1_CRCL_Pos: u32 = 11;
pub const SPI_CR1_CRCL_Msk: u32 = 2048;
pub const SPI_CR1_CRCL: u32 = 2048;
pub const SPI_CR1_CRCNEXT_Pos: u32 = 12;
pub const SPI_CR1_CRCNEXT_Msk: u32 = 4096;
pub const SPI_CR1_CRCNEXT: u32 = 4096;
pub const SPI_CR1_CRCEN_Pos: u32 = 13;
pub const SPI_CR1_CRCEN_Msk: u32 = 8192;
pub const SPI_CR1_CRCEN: u32 = 8192;
pub const SPI_CR1_BIDIOE_Pos: u32 = 14;
pub const SPI_CR1_BIDIOE_Msk: u32 = 16384;
pub const SPI_CR1_BIDIOE: u32 = 16384;
pub const SPI_CR1_BIDIMODE_Pos: u32 = 15;
pub const SPI_CR1_BIDIMODE_Msk: u32 = 32768;
pub const SPI_CR1_BIDIMODE: u32 = 32768;
pub const SPI_CR2_RXDMAEN_Pos: u32 = 0;
pub const SPI_CR2_RXDMAEN_Msk: u32 = 1;
pub const SPI_CR2_RXDMAEN: u32 = 1;
pub const SPI_CR2_TXDMAEN_Pos: u32 = 1;
pub const SPI_CR2_TXDMAEN_Msk: u32 = 2;
pub const SPI_CR2_TXDMAEN: u32 = 2;
pub const SPI_CR2_SSOE_Pos: u32 = 2;
pub const SPI_CR2_SSOE_Msk: u32 = 4;
pub const SPI_CR2_SSOE: u32 = 4;
pub const SPI_CR2_NSSP_Pos: u32 = 3;
pub const SPI_CR2_NSSP_Msk: u32 = 8;
pub const SPI_CR2_NSSP: u32 = 8;
pub const SPI_CR2_FRF_Pos: u32 = 4;
pub const SPI_CR2_FRF_Msk: u32 = 16;
pub const SPI_CR2_FRF: u32 = 16;
pub const SPI_CR2_ERRIE_Pos: u32 = 5;
pub const SPI_CR2_ERRIE_Msk: u32 = 32;
pub const SPI_CR2_ERRIE: u32 = 32;
pub const SPI_CR2_RXNEIE_Pos: u32 = 6;
pub const SPI_CR2_RXNEIE_Msk: u32 = 64;
pub const SPI_CR2_RXNEIE: u32 = 64;
pub const SPI_CR2_TXEIE_Pos: u32 = 7;
pub const SPI_CR2_TXEIE_Msk: u32 = 128;
pub const SPI_CR2_TXEIE: u32 = 128;
pub const SPI_CR2_DS_Pos: u32 = 8;
pub const SPI_CR2_DS_Msk: u32 = 3840;
pub const SPI_CR2_DS: u32 = 3840;
pub const SPI_CR2_DS_0: u32 = 256;
pub const SPI_CR2_DS_1: u32 = 512;
pub const SPI_CR2_DS_2: u32 = 1024;
pub const SPI_CR2_DS_3: u32 = 2048;
pub const SPI_CR2_FRXTH_Pos: u32 = 12;
pub const SPI_CR2_FRXTH_Msk: u32 = 4096;
pub const SPI_CR2_FRXTH: u32 = 4096;
pub const SPI_CR2_LDMARX_Pos: u32 = 13;
pub const SPI_CR2_LDMARX_Msk: u32 = 8192;
pub const SPI_CR2_LDMARX: u32 = 8192;
pub const SPI_CR2_LDMATX_Pos: u32 = 14;
pub const SPI_CR2_LDMATX_Msk: u32 = 16384;
pub const SPI_CR2_LDMATX: u32 = 16384;
pub const SPI_SR_RXNE_Pos: u32 = 0;
pub const SPI_SR_RXNE_Msk: u32 = 1;
pub const SPI_SR_RXNE: u32 = 1;
pub const SPI_SR_TXE_Pos: u32 = 1;
pub const SPI_SR_TXE_Msk: u32 = 2;
pub const SPI_SR_TXE: u32 = 2;
pub const SPI_SR_CRCERR_Pos: u32 = 4;
pub const SPI_SR_CRCERR_Msk: u32 = 16;
pub const SPI_SR_CRCERR: u32 = 16;
pub const SPI_SR_MODF_Pos: u32 = 5;
pub const SPI_SR_MODF_Msk: u32 = 32;
pub const SPI_SR_MODF: u32 = 32;
pub const SPI_SR_OVR_Pos: u32 = 6;
pub const SPI_SR_OVR_Msk: u32 = 64;
pub const SPI_SR_OVR: u32 = 64;
pub const SPI_SR_BSY_Pos: u32 = 7;
pub const SPI_SR_BSY_Msk: u32 = 128;
pub const SPI_SR_BSY: u32 = 128;
pub const SPI_SR_FRE_Pos: u32 = 8;
pub const SPI_SR_FRE_Msk: u32 = 256;
pub const SPI_SR_FRE: u32 = 256;
pub const SPI_SR_FRLVL_Pos: u32 = 9;
pub const SPI_SR_FRLVL_Msk: u32 = 1536;
pub const SPI_SR_FRLVL: u32 = 1536;
pub const SPI_SR_FRLVL_0: u32 = 512;
pub const SPI_SR_FRLVL_1: u32 = 1024;
pub const SPI_SR_FTLVL_Pos: u32 = 11;
pub const SPI_SR_FTLVL_Msk: u32 = 6144;
pub const SPI_SR_FTLVL: u32 = 6144;
pub const SPI_SR_FTLVL_0: u32 = 2048;
pub const SPI_SR_FTLVL_1: u32 = 4096;
pub const SPI_DR_DR_Pos: u32 = 0;
pub const SPI_DR_DR_Msk: u32 = 65535;
pub const SPI_DR_DR: u32 = 65535;
pub const SPI_CRCPR_CRCPOLY_Pos: u32 = 0;
pub const SPI_CRCPR_CRCPOLY_Msk: u32 = 65535;
pub const SPI_CRCPR_CRCPOLY: u32 = 65535;
pub const SPI_RXCRCR_RXCRC_Pos: u32 = 0;
pub const SPI_RXCRCR_RXCRC_Msk: u32 = 65535;
pub const SPI_RXCRCR_RXCRC: u32 = 65535;
pub const SPI_TXCRCR_TXCRC_Pos: u32 = 0;
pub const SPI_TXCRCR_TXCRC_Msk: u32 = 65535;
pub const SPI_TXCRCR_TXCRC: u32 = 65535;
pub const TSC_CR_TSCE_Pos: u32 = 0;
pub const TSC_CR_TSCE_Msk: u32 = 1;
pub const TSC_CR_TSCE: u32 = 1;
pub const TSC_CR_START_Pos: u32 = 1;
pub const TSC_CR_START_Msk: u32 = 2;
pub const TSC_CR_START: u32 = 2;
pub const TSC_CR_AM_Pos: u32 = 2;
pub const TSC_CR_AM_Msk: u32 = 4;
pub const TSC_CR_AM: u32 = 4;
pub const TSC_CR_SYNCPOL_Pos: u32 = 3;
pub const TSC_CR_SYNCPOL_Msk: u32 = 8;
pub const TSC_CR_SYNCPOL: u32 = 8;
pub const TSC_CR_IODEF_Pos: u32 = 4;
pub const TSC_CR_IODEF_Msk: u32 = 16;
pub const TSC_CR_IODEF: u32 = 16;
pub const TSC_CR_MCV_Pos: u32 = 5;
pub const TSC_CR_MCV_Msk: u32 = 224;
pub const TSC_CR_MCV: u32 = 224;
pub const TSC_CR_MCV_0: u32 = 32;
pub const TSC_CR_MCV_1: u32 = 64;
pub const TSC_CR_MCV_2: u32 = 128;
pub const TSC_CR_PGPSC_Pos: u32 = 12;
pub const TSC_CR_PGPSC_Msk: u32 = 28672;
pub const TSC_CR_PGPSC: u32 = 28672;
pub const TSC_CR_PGPSC_0: u32 = 4096;
pub const TSC_CR_PGPSC_1: u32 = 8192;
pub const TSC_CR_PGPSC_2: u32 = 16384;
pub const TSC_CR_SSPSC_Pos: u32 = 15;
pub const TSC_CR_SSPSC_Msk: u32 = 32768;
pub const TSC_CR_SSPSC: u32 = 32768;
pub const TSC_CR_SSE_Pos: u32 = 16;
pub const TSC_CR_SSE_Msk: u32 = 65536;
pub const TSC_CR_SSE: u32 = 65536;
pub const TSC_CR_SSD_Pos: u32 = 17;
pub const TSC_CR_SSD_Msk: u32 = 16646144;
pub const TSC_CR_SSD: u32 = 16646144;
pub const TSC_CR_SSD_0: u32 = 131072;
pub const TSC_CR_SSD_1: u32 = 262144;
pub const TSC_CR_SSD_2: u32 = 524288;
pub const TSC_CR_SSD_3: u32 = 1048576;
pub const TSC_CR_SSD_4: u32 = 2097152;
pub const TSC_CR_SSD_5: u32 = 4194304;
pub const TSC_CR_SSD_6: u32 = 8388608;
pub const TSC_CR_CTPL_Pos: u32 = 24;
pub const TSC_CR_CTPL_Msk: u32 = 251658240;
pub const TSC_CR_CTPL: u32 = 251658240;
pub const TSC_CR_CTPL_0: u32 = 16777216;
pub const TSC_CR_CTPL_1: u32 = 33554432;
pub const TSC_CR_CTPL_2: u32 = 67108864;
pub const TSC_CR_CTPL_3: u32 = 134217728;
pub const TSC_CR_CTPH_Pos: u32 = 28;
pub const TSC_CR_CTPH_Msk: u32 = 4026531840;
pub const TSC_CR_CTPH: u32 = 4026531840;
pub const TSC_CR_CTPH_0: u32 = 268435456;
pub const TSC_CR_CTPH_1: u32 = 536870912;
pub const TSC_CR_CTPH_2: u32 = 1073741824;
pub const TSC_CR_CTPH_3: u32 = 2147483648;
pub const TSC_IER_EOAIE_Pos: u32 = 0;
pub const TSC_IER_EOAIE_Msk: u32 = 1;
pub const TSC_IER_EOAIE: u32 = 1;
pub const TSC_IER_MCEIE_Pos: u32 = 1;
pub const TSC_IER_MCEIE_Msk: u32 = 2;
pub const TSC_IER_MCEIE: u32 = 2;
pub const TSC_ICR_EOAIC_Pos: u32 = 0;
pub const TSC_ICR_EOAIC_Msk: u32 = 1;
pub const TSC_ICR_EOAIC: u32 = 1;
pub const TSC_ICR_MCEIC_Pos: u32 = 1;
pub const TSC_ICR_MCEIC_Msk: u32 = 2;
pub const TSC_ICR_MCEIC: u32 = 2;
pub const TSC_ISR_EOAF_Pos: u32 = 0;
pub const TSC_ISR_EOAF_Msk: u32 = 1;
pub const TSC_ISR_EOAF: u32 = 1;
pub const TSC_ISR_MCEF_Pos: u32 = 1;
pub const TSC_ISR_MCEF_Msk: u32 = 2;
pub const TSC_ISR_MCEF: u32 = 2;
pub const TSC_IOHCR_G1_IO1_Pos: u32 = 0;
pub const TSC_IOHCR_G1_IO1_Msk: u32 = 1;
pub const TSC_IOHCR_G1_IO1: u32 = 1;
pub const TSC_IOHCR_G1_IO2_Pos: u32 = 1;
pub const TSC_IOHCR_G1_IO2_Msk: u32 = 2;
pub const TSC_IOHCR_G1_IO2: u32 = 2;
pub const TSC_IOHCR_G1_IO3_Pos: u32 = 2;
pub const TSC_IOHCR_G1_IO3_Msk: u32 = 4;
pub const TSC_IOHCR_G1_IO3: u32 = 4;
pub const TSC_IOHCR_G1_IO4_Pos: u32 = 3;
pub const TSC_IOHCR_G1_IO4_Msk: u32 = 8;
pub const TSC_IOHCR_G1_IO4: u32 = 8;
pub const TSC_IOHCR_G2_IO1_Pos: u32 = 4;
pub const TSC_IOHCR_G2_IO1_Msk: u32 = 16;
pub const TSC_IOHCR_G2_IO1: u32 = 16;
pub const TSC_IOHCR_G2_IO2_Pos: u32 = 5;
pub const TSC_IOHCR_G2_IO2_Msk: u32 = 32;
pub const TSC_IOHCR_G2_IO2: u32 = 32;
pub const TSC_IOHCR_G2_IO3_Pos: u32 = 6;
pub const TSC_IOHCR_G2_IO3_Msk: u32 = 64;
pub const TSC_IOHCR_G2_IO3: u32 = 64;
pub const TSC_IOHCR_G2_IO4_Pos: u32 = 7;
pub const TSC_IOHCR_G2_IO4_Msk: u32 = 128;
pub const TSC_IOHCR_G2_IO4: u32 = 128;
pub const TSC_IOHCR_G3_IO1_Pos: u32 = 8;
pub const TSC_IOHCR_G3_IO1_Msk: u32 = 256;
pub const TSC_IOHCR_G3_IO1: u32 = 256;
pub const TSC_IOHCR_G3_IO2_Pos: u32 = 9;
pub const TSC_IOHCR_G3_IO2_Msk: u32 = 512;
pub const TSC_IOHCR_G3_IO2: u32 = 512;
pub const TSC_IOHCR_G3_IO3_Pos: u32 = 10;
pub const TSC_IOHCR_G3_IO3_Msk: u32 = 1024;
pub const TSC_IOHCR_G3_IO3: u32 = 1024;
pub const TSC_IOHCR_G3_IO4_Pos: u32 = 11;
pub const TSC_IOHCR_G3_IO4_Msk: u32 = 2048;
pub const TSC_IOHCR_G3_IO4: u32 = 2048;
pub const TSC_IOHCR_G4_IO1_Pos: u32 = 12;
pub const TSC_IOHCR_G4_IO1_Msk: u32 = 4096;
pub const TSC_IOHCR_G4_IO1: u32 = 4096;
pub const TSC_IOHCR_G4_IO2_Pos: u32 = 13;
pub const TSC_IOHCR_G4_IO2_Msk: u32 = 8192;
pub const TSC_IOHCR_G4_IO2: u32 = 8192;
pub const TSC_IOHCR_G4_IO3_Pos: u32 = 14;
pub const TSC_IOHCR_G4_IO3_Msk: u32 = 16384;
pub const TSC_IOHCR_G4_IO3: u32 = 16384;
pub const TSC_IOHCR_G4_IO4_Pos: u32 = 15;
pub const TSC_IOHCR_G4_IO4_Msk: u32 = 32768;
pub const TSC_IOHCR_G4_IO4: u32 = 32768;
pub const TSC_IOHCR_G5_IO1_Pos: u32 = 16;
pub const TSC_IOHCR_G5_IO1_Msk: u32 = 65536;
pub const TSC_IOHCR_G5_IO1: u32 = 65536;
pub const TSC_IOHCR_G5_IO2_Pos: u32 = 17;
pub const TSC_IOHCR_G5_IO2_Msk: u32 = 131072;
pub const TSC_IOHCR_G5_IO2: u32 = 131072;
pub const TSC_IOHCR_G5_IO3_Pos: u32 = 18;
pub const TSC_IOHCR_G5_IO3_Msk: u32 = 262144;
pub const TSC_IOHCR_G5_IO3: u32 = 262144;
pub const TSC_IOHCR_G5_IO4_Pos: u32 = 19;
pub const TSC_IOHCR_G5_IO4_Msk: u32 = 524288;
pub const TSC_IOHCR_G5_IO4: u32 = 524288;
pub const TSC_IOHCR_G6_IO1_Pos: u32 = 20;
pub const TSC_IOHCR_G6_IO1_Msk: u32 = 1048576;
pub const TSC_IOHCR_G6_IO1: u32 = 1048576;
pub const TSC_IOHCR_G6_IO2_Pos: u32 = 21;
pub const TSC_IOHCR_G6_IO2_Msk: u32 = 2097152;
pub const TSC_IOHCR_G6_IO2: u32 = 2097152;
pub const TSC_IOHCR_G6_IO3_Pos: u32 = 22;
pub const TSC_IOHCR_G6_IO3_Msk: u32 = 4194304;
pub const TSC_IOHCR_G6_IO3: u32 = 4194304;
pub const TSC_IOHCR_G6_IO4_Pos: u32 = 23;
pub const TSC_IOHCR_G6_IO4_Msk: u32 = 8388608;
pub const TSC_IOHCR_G6_IO4: u32 = 8388608;
pub const TSC_IOHCR_G7_IO1_Pos: u32 = 24;
pub const TSC_IOHCR_G7_IO1_Msk: u32 = 16777216;
pub const TSC_IOHCR_G7_IO1: u32 = 16777216;
pub const TSC_IOHCR_G7_IO2_Pos: u32 = 25;
pub const TSC_IOHCR_G7_IO2_Msk: u32 = 33554432;
pub const TSC_IOHCR_G7_IO2: u32 = 33554432;
pub const TSC_IOHCR_G7_IO3_Pos: u32 = 26;
pub const TSC_IOHCR_G7_IO3_Msk: u32 = 67108864;
pub const TSC_IOHCR_G7_IO3: u32 = 67108864;
pub const TSC_IOHCR_G7_IO4_Pos: u32 = 27;
pub const TSC_IOHCR_G7_IO4_Msk: u32 = 134217728;
pub const TSC_IOHCR_G7_IO4: u32 = 134217728;
pub const TSC_IOASCR_G1_IO1_Pos: u32 = 0;
pub const TSC_IOASCR_G1_IO1_Msk: u32 = 1;
pub const TSC_IOASCR_G1_IO1: u32 = 1;
pub const TSC_IOASCR_G1_IO2_Pos: u32 = 1;
pub const TSC_IOASCR_G1_IO2_Msk: u32 = 2;
pub const TSC_IOASCR_G1_IO2: u32 = 2;
pub const TSC_IOASCR_G1_IO3_Pos: u32 = 2;
pub const TSC_IOASCR_G1_IO3_Msk: u32 = 4;
pub const TSC_IOASCR_G1_IO3: u32 = 4;
pub const TSC_IOASCR_G1_IO4_Pos: u32 = 3;
pub const TSC_IOASCR_G1_IO4_Msk: u32 = 8;
pub const TSC_IOASCR_G1_IO4: u32 = 8;
pub const TSC_IOASCR_G2_IO1_Pos: u32 = 4;
pub const TSC_IOASCR_G2_IO1_Msk: u32 = 16;
pub const TSC_IOASCR_G2_IO1: u32 = 16;
pub const TSC_IOASCR_G2_IO2_Pos: u32 = 5;
pub const TSC_IOASCR_G2_IO2_Msk: u32 = 32;
pub const TSC_IOASCR_G2_IO2: u32 = 32;
pub const TSC_IOASCR_G2_IO3_Pos: u32 = 6;
pub const TSC_IOASCR_G2_IO3_Msk: u32 = 64;
pub const TSC_IOASCR_G2_IO3: u32 = 64;
pub const TSC_IOASCR_G2_IO4_Pos: u32 = 7;
pub const TSC_IOASCR_G2_IO4_Msk: u32 = 128;
pub const TSC_IOASCR_G2_IO4: u32 = 128;
pub const TSC_IOASCR_G3_IO1_Pos: u32 = 8;
pub const TSC_IOASCR_G3_IO1_Msk: u32 = 256;
pub const TSC_IOASCR_G3_IO1: u32 = 256;
pub const TSC_IOASCR_G3_IO2_Pos: u32 = 9;
pub const TSC_IOASCR_G3_IO2_Msk: u32 = 512;
pub const TSC_IOASCR_G3_IO2: u32 = 512;
pub const TSC_IOASCR_G3_IO3_Pos: u32 = 10;
pub const TSC_IOASCR_G3_IO3_Msk: u32 = 1024;
pub const TSC_IOASCR_G3_IO3: u32 = 1024;
pub const TSC_IOASCR_G3_IO4_Pos: u32 = 11;
pub const TSC_IOASCR_G3_IO4_Msk: u32 = 2048;
pub const TSC_IOASCR_G3_IO4: u32 = 2048;
pub const TSC_IOASCR_G4_IO1_Pos: u32 = 12;
pub const TSC_IOASCR_G4_IO1_Msk: u32 = 4096;
pub const TSC_IOASCR_G4_IO1: u32 = 4096;
pub const TSC_IOASCR_G4_IO2_Pos: u32 = 13;
pub const TSC_IOASCR_G4_IO2_Msk: u32 = 8192;
pub const TSC_IOASCR_G4_IO2: u32 = 8192;
pub const TSC_IOASCR_G4_IO3_Pos: u32 = 14;
pub const TSC_IOASCR_G4_IO3_Msk: u32 = 16384;
pub const TSC_IOASCR_G4_IO3: u32 = 16384;
pub const TSC_IOASCR_G4_IO4_Pos: u32 = 15;
pub const TSC_IOASCR_G4_IO4_Msk: u32 = 32768;
pub const TSC_IOASCR_G4_IO4: u32 = 32768;
pub const TSC_IOASCR_G5_IO1_Pos: u32 = 16;
pub const TSC_IOASCR_G5_IO1_Msk: u32 = 65536;
pub const TSC_IOASCR_G5_IO1: u32 = 65536;
pub const TSC_IOASCR_G5_IO2_Pos: u32 = 17;
pub const TSC_IOASCR_G5_IO2_Msk: u32 = 131072;
pub const TSC_IOASCR_G5_IO2: u32 = 131072;
pub const TSC_IOASCR_G5_IO3_Pos: u32 = 18;
pub const TSC_IOASCR_G5_IO3_Msk: u32 = 262144;
pub const TSC_IOASCR_G5_IO3: u32 = 262144;
pub const TSC_IOASCR_G5_IO4_Pos: u32 = 19;
pub const TSC_IOASCR_G5_IO4_Msk: u32 = 524288;
pub const TSC_IOASCR_G5_IO4: u32 = 524288;
pub const TSC_IOASCR_G6_IO1_Pos: u32 = 20;
pub const TSC_IOASCR_G6_IO1_Msk: u32 = 1048576;
pub const TSC_IOASCR_G6_IO1: u32 = 1048576;
pub const TSC_IOASCR_G6_IO2_Pos: u32 = 21;
pub const TSC_IOASCR_G6_IO2_Msk: u32 = 2097152;
pub const TSC_IOASCR_G6_IO2: u32 = 2097152;
pub const TSC_IOASCR_G6_IO3_Pos: u32 = 22;
pub const TSC_IOASCR_G6_IO3_Msk: u32 = 4194304;
pub const TSC_IOASCR_G6_IO3: u32 = 4194304;
pub const TSC_IOASCR_G6_IO4_Pos: u32 = 23;
pub const TSC_IOASCR_G6_IO4_Msk: u32 = 8388608;
pub const TSC_IOASCR_G6_IO4: u32 = 8388608;
pub const TSC_IOASCR_G7_IO1_Pos: u32 = 24;
pub const TSC_IOASCR_G7_IO1_Msk: u32 = 16777216;
pub const TSC_IOASCR_G7_IO1: u32 = 16777216;
pub const TSC_IOASCR_G7_IO2_Pos: u32 = 25;
pub const TSC_IOASCR_G7_IO2_Msk: u32 = 33554432;
pub const TSC_IOASCR_G7_IO2: u32 = 33554432;
pub const TSC_IOASCR_G7_IO3_Pos: u32 = 26;
pub const TSC_IOASCR_G7_IO3_Msk: u32 = 67108864;
pub const TSC_IOASCR_G7_IO3: u32 = 67108864;
pub const TSC_IOASCR_G7_IO4_Pos: u32 = 27;
pub const TSC_IOASCR_G7_IO4_Msk: u32 = 134217728;
pub const TSC_IOASCR_G7_IO4: u32 = 134217728;
pub const TSC_IOSCR_G1_IO1_Pos: u32 = 0;
pub const TSC_IOSCR_G1_IO1_Msk: u32 = 1;
pub const TSC_IOSCR_G1_IO1: u32 = 1;
pub const TSC_IOSCR_G1_IO2_Pos: u32 = 1;
pub const TSC_IOSCR_G1_IO2_Msk: u32 = 2;
pub const TSC_IOSCR_G1_IO2: u32 = 2;
pub const TSC_IOSCR_G1_IO3_Pos: u32 = 2;
pub const TSC_IOSCR_G1_IO3_Msk: u32 = 4;
pub const TSC_IOSCR_G1_IO3: u32 = 4;
pub const TSC_IOSCR_G1_IO4_Pos: u32 = 3;
pub const TSC_IOSCR_G1_IO4_Msk: u32 = 8;
pub const TSC_IOSCR_G1_IO4: u32 = 8;
pub const TSC_IOSCR_G2_IO1_Pos: u32 = 4;
pub const TSC_IOSCR_G2_IO1_Msk: u32 = 16;
pub const TSC_IOSCR_G2_IO1: u32 = 16;
pub const TSC_IOSCR_G2_IO2_Pos: u32 = 5;
pub const TSC_IOSCR_G2_IO2_Msk: u32 = 32;
pub const TSC_IOSCR_G2_IO2: u32 = 32;
pub const TSC_IOSCR_G2_IO3_Pos: u32 = 6;
pub const TSC_IOSCR_G2_IO3_Msk: u32 = 64;
pub const TSC_IOSCR_G2_IO3: u32 = 64;
pub const TSC_IOSCR_G2_IO4_Pos: u32 = 7;
pub const TSC_IOSCR_G2_IO4_Msk: u32 = 128;
pub const TSC_IOSCR_G2_IO4: u32 = 128;
pub const TSC_IOSCR_G3_IO1_Pos: u32 = 8;
pub const TSC_IOSCR_G3_IO1_Msk: u32 = 256;
pub const TSC_IOSCR_G3_IO1: u32 = 256;
pub const TSC_IOSCR_G3_IO2_Pos: u32 = 9;
pub const TSC_IOSCR_G3_IO2_Msk: u32 = 512;
pub const TSC_IOSCR_G3_IO2: u32 = 512;
pub const TSC_IOSCR_G3_IO3_Pos: u32 = 10;
pub const TSC_IOSCR_G3_IO3_Msk: u32 = 1024;
pub const TSC_IOSCR_G3_IO3: u32 = 1024;
pub const TSC_IOSCR_G3_IO4_Pos: u32 = 11;
pub const TSC_IOSCR_G3_IO4_Msk: u32 = 2048;
pub const TSC_IOSCR_G3_IO4: u32 = 2048;
pub const TSC_IOSCR_G4_IO1_Pos: u32 = 12;
pub const TSC_IOSCR_G4_IO1_Msk: u32 = 4096;
pub const TSC_IOSCR_G4_IO1: u32 = 4096;
pub const TSC_IOSCR_G4_IO2_Pos: u32 = 13;
pub const TSC_IOSCR_G4_IO2_Msk: u32 = 8192;
pub const TSC_IOSCR_G4_IO2: u32 = 8192;
pub const TSC_IOSCR_G4_IO3_Pos: u32 = 14;
pub const TSC_IOSCR_G4_IO3_Msk: u32 = 16384;
pub const TSC_IOSCR_G4_IO3: u32 = 16384;
pub const TSC_IOSCR_G4_IO4_Pos: u32 = 15;
pub const TSC_IOSCR_G4_IO4_Msk: u32 = 32768;
pub const TSC_IOSCR_G4_IO4: u32 = 32768;
pub const TSC_IOSCR_G5_IO1_Pos: u32 = 16;
pub const TSC_IOSCR_G5_IO1_Msk: u32 = 65536;
pub const TSC_IOSCR_G5_IO1: u32 = 65536;
pub const TSC_IOSCR_G5_IO2_Pos: u32 = 17;
pub const TSC_IOSCR_G5_IO2_Msk: u32 = 131072;
pub const TSC_IOSCR_G5_IO2: u32 = 131072;
pub const TSC_IOSCR_G5_IO3_Pos: u32 = 18;
pub const TSC_IOSCR_G5_IO3_Msk: u32 = 262144;
pub const TSC_IOSCR_G5_IO3: u32 = 262144;
pub const TSC_IOSCR_G5_IO4_Pos: u32 = 19;
pub const TSC_IOSCR_G5_IO4_Msk: u32 = 524288;
pub const TSC_IOSCR_G5_IO4: u32 = 524288;
pub const TSC_IOSCR_G6_IO1_Pos: u32 = 20;
pub const TSC_IOSCR_G6_IO1_Msk: u32 = 1048576;
pub const TSC_IOSCR_G6_IO1: u32 = 1048576;
pub const TSC_IOSCR_G6_IO2_Pos: u32 = 21;
pub const TSC_IOSCR_G6_IO2_Msk: u32 = 2097152;
pub const TSC_IOSCR_G6_IO2: u32 = 2097152;
pub const TSC_IOSCR_G6_IO3_Pos: u32 = 22;
pub const TSC_IOSCR_G6_IO3_Msk: u32 = 4194304;
pub const TSC_IOSCR_G6_IO3: u32 = 4194304;
pub const TSC_IOSCR_G6_IO4_Pos: u32 = 23;
pub const TSC_IOSCR_G6_IO4_Msk: u32 = 8388608;
pub const TSC_IOSCR_G6_IO4: u32 = 8388608;
pub const TSC_IOSCR_G7_IO1_Pos: u32 = 24;
pub const TSC_IOSCR_G7_IO1_Msk: u32 = 16777216;
pub const TSC_IOSCR_G7_IO1: u32 = 16777216;
pub const TSC_IOSCR_G7_IO2_Pos: u32 = 25;
pub const TSC_IOSCR_G7_IO2_Msk: u32 = 33554432;
pub const TSC_IOSCR_G7_IO2: u32 = 33554432;
pub const TSC_IOSCR_G7_IO3_Pos: u32 = 26;
pub const TSC_IOSCR_G7_IO3_Msk: u32 = 67108864;
pub const TSC_IOSCR_G7_IO3: u32 = 67108864;
pub const TSC_IOSCR_G7_IO4_Pos: u32 = 27;
pub const TSC_IOSCR_G7_IO4_Msk: u32 = 134217728;
pub const TSC_IOSCR_G7_IO4: u32 = 134217728;
pub const TSC_IOCCR_G1_IO1_Pos: u32 = 0;
pub const TSC_IOCCR_G1_IO1_Msk: u32 = 1;
pub const TSC_IOCCR_G1_IO1: u32 = 1;
pub const TSC_IOCCR_G1_IO2_Pos: u32 = 1;
pub const TSC_IOCCR_G1_IO2_Msk: u32 = 2;
pub const TSC_IOCCR_G1_IO2: u32 = 2;
pub const TSC_IOCCR_G1_IO3_Pos: u32 = 2;
pub const TSC_IOCCR_G1_IO3_Msk: u32 = 4;
pub const TSC_IOCCR_G1_IO3: u32 = 4;
pub const TSC_IOCCR_G1_IO4_Pos: u32 = 3;
pub const TSC_IOCCR_G1_IO4_Msk: u32 = 8;
pub const TSC_IOCCR_G1_IO4: u32 = 8;
pub const TSC_IOCCR_G2_IO1_Pos: u32 = 4;
pub const TSC_IOCCR_G2_IO1_Msk: u32 = 16;
pub const TSC_IOCCR_G2_IO1: u32 = 16;
pub const TSC_IOCCR_G2_IO2_Pos: u32 = 5;
pub const TSC_IOCCR_G2_IO2_Msk: u32 = 32;
pub const TSC_IOCCR_G2_IO2: u32 = 32;
pub const TSC_IOCCR_G2_IO3_Pos: u32 = 6;
pub const TSC_IOCCR_G2_IO3_Msk: u32 = 64;
pub const TSC_IOCCR_G2_IO3: u32 = 64;
pub const TSC_IOCCR_G2_IO4_Pos: u32 = 7;
pub const TSC_IOCCR_G2_IO4_Msk: u32 = 128;
pub const TSC_IOCCR_G2_IO4: u32 = 128;
pub const TSC_IOCCR_G3_IO1_Pos: u32 = 8;
pub const TSC_IOCCR_G3_IO1_Msk: u32 = 256;
pub const TSC_IOCCR_G3_IO1: u32 = 256;
pub const TSC_IOCCR_G3_IO2_Pos: u32 = 9;
pub const TSC_IOCCR_G3_IO2_Msk: u32 = 512;
pub const TSC_IOCCR_G3_IO2: u32 = 512;
pub const TSC_IOCCR_G3_IO3_Pos: u32 = 10;
pub const TSC_IOCCR_G3_IO3_Msk: u32 = 1024;
pub const TSC_IOCCR_G3_IO3: u32 = 1024;
pub const TSC_IOCCR_G3_IO4_Pos: u32 = 11;
pub const TSC_IOCCR_G3_IO4_Msk: u32 = 2048;
pub const TSC_IOCCR_G3_IO4: u32 = 2048;
pub const TSC_IOCCR_G4_IO1_Pos: u32 = 12;
pub const TSC_IOCCR_G4_IO1_Msk: u32 = 4096;
pub const TSC_IOCCR_G4_IO1: u32 = 4096;
pub const TSC_IOCCR_G4_IO2_Pos: u32 = 13;
pub const TSC_IOCCR_G4_IO2_Msk: u32 = 8192;
pub const TSC_IOCCR_G4_IO2: u32 = 8192;
pub const TSC_IOCCR_G4_IO3_Pos: u32 = 14;
pub const TSC_IOCCR_G4_IO3_Msk: u32 = 16384;
pub const TSC_IOCCR_G4_IO3: u32 = 16384;
pub const TSC_IOCCR_G4_IO4_Pos: u32 = 15;
pub const TSC_IOCCR_G4_IO4_Msk: u32 = 32768;
pub const TSC_IOCCR_G4_IO4: u32 = 32768;
pub const TSC_IOCCR_G5_IO1_Pos: u32 = 16;
pub const TSC_IOCCR_G5_IO1_Msk: u32 = 65536;
pub const TSC_IOCCR_G5_IO1: u32 = 65536;
pub const TSC_IOCCR_G5_IO2_Pos: u32 = 17;
pub const TSC_IOCCR_G5_IO2_Msk: u32 = 131072;
pub const TSC_IOCCR_G5_IO2: u32 = 131072;
pub const TSC_IOCCR_G5_IO3_Pos: u32 = 18;
pub const TSC_IOCCR_G5_IO3_Msk: u32 = 262144;
pub const TSC_IOCCR_G5_IO3: u32 = 262144;
pub const TSC_IOCCR_G5_IO4_Pos: u32 = 19;
pub const TSC_IOCCR_G5_IO4_Msk: u32 = 524288;
pub const TSC_IOCCR_G5_IO4: u32 = 524288;
pub const TSC_IOCCR_G6_IO1_Pos: u32 = 20;
pub const TSC_IOCCR_G6_IO1_Msk: u32 = 1048576;
pub const TSC_IOCCR_G6_IO1: u32 = 1048576;
pub const TSC_IOCCR_G6_IO2_Pos: u32 = 21;
pub const TSC_IOCCR_G6_IO2_Msk: u32 = 2097152;
pub const TSC_IOCCR_G6_IO2: u32 = 2097152;
pub const TSC_IOCCR_G6_IO3_Pos: u32 = 22;
pub const TSC_IOCCR_G6_IO3_Msk: u32 = 4194304;
pub const TSC_IOCCR_G6_IO3: u32 = 4194304;
pub const TSC_IOCCR_G6_IO4_Pos: u32 = 23;
pub const TSC_IOCCR_G6_IO4_Msk: u32 = 8388608;
pub const TSC_IOCCR_G6_IO4: u32 = 8388608;
pub const TSC_IOCCR_G7_IO1_Pos: u32 = 24;
pub const TSC_IOCCR_G7_IO1_Msk: u32 = 16777216;
pub const TSC_IOCCR_G7_IO1: u32 = 16777216;
pub const TSC_IOCCR_G7_IO2_Pos: u32 = 25;
pub const TSC_IOCCR_G7_IO2_Msk: u32 = 33554432;
pub const TSC_IOCCR_G7_IO2: u32 = 33554432;
pub const TSC_IOCCR_G7_IO3_Pos: u32 = 26;
pub const TSC_IOCCR_G7_IO3_Msk: u32 = 67108864;
pub const TSC_IOCCR_G7_IO3: u32 = 67108864;
pub const TSC_IOCCR_G7_IO4_Pos: u32 = 27;
pub const TSC_IOCCR_G7_IO4_Msk: u32 = 134217728;
pub const TSC_IOCCR_G7_IO4: u32 = 134217728;
pub const TSC_IOGCSR_G1E_Pos: u32 = 0;
pub const TSC_IOGCSR_G1E_Msk: u32 = 1;
pub const TSC_IOGCSR_G1E: u32 = 1;
pub const TSC_IOGCSR_G2E_Pos: u32 = 1;
pub const TSC_IOGCSR_G2E_Msk: u32 = 2;
pub const TSC_IOGCSR_G2E: u32 = 2;
pub const TSC_IOGCSR_G3E_Pos: u32 = 2;
pub const TSC_IOGCSR_G3E_Msk: u32 = 4;
pub const TSC_IOGCSR_G3E: u32 = 4;
pub const TSC_IOGCSR_G4E_Pos: u32 = 3;
pub const TSC_IOGCSR_G4E_Msk: u32 = 8;
pub const TSC_IOGCSR_G4E: u32 = 8;
pub const TSC_IOGCSR_G5E_Pos: u32 = 4;
pub const TSC_IOGCSR_G5E_Msk: u32 = 16;
pub const TSC_IOGCSR_G5E: u32 = 16;
pub const TSC_IOGCSR_G6E_Pos: u32 = 5;
pub const TSC_IOGCSR_G6E_Msk: u32 = 32;
pub const TSC_IOGCSR_G6E: u32 = 32;
pub const TSC_IOGCSR_G7E_Pos: u32 = 6;
pub const TSC_IOGCSR_G7E_Msk: u32 = 64;
pub const TSC_IOGCSR_G7E: u32 = 64;
pub const TSC_IOGCSR_G1S_Pos: u32 = 16;
pub const TSC_IOGCSR_G1S_Msk: u32 = 65536;
pub const TSC_IOGCSR_G1S: u32 = 65536;
pub const TSC_IOGCSR_G2S_Pos: u32 = 17;
pub const TSC_IOGCSR_G2S_Msk: u32 = 131072;
pub const TSC_IOGCSR_G2S: u32 = 131072;
pub const TSC_IOGCSR_G3S_Pos: u32 = 18;
pub const TSC_IOGCSR_G3S_Msk: u32 = 262144;
pub const TSC_IOGCSR_G3S: u32 = 262144;
pub const TSC_IOGCSR_G4S_Pos: u32 = 19;
pub const TSC_IOGCSR_G4S_Msk: u32 = 524288;
pub const TSC_IOGCSR_G4S: u32 = 524288;
pub const TSC_IOGCSR_G5S_Pos: u32 = 20;
pub const TSC_IOGCSR_G5S_Msk: u32 = 1048576;
pub const TSC_IOGCSR_G5S: u32 = 1048576;
pub const TSC_IOGCSR_G6S_Pos: u32 = 21;
pub const TSC_IOGCSR_G6S_Msk: u32 = 2097152;
pub const TSC_IOGCSR_G6S: u32 = 2097152;
pub const TSC_IOGCSR_G7S_Pos: u32 = 22;
pub const TSC_IOGCSR_G7S_Msk: u32 = 4194304;
pub const TSC_IOGCSR_G7S: u32 = 4194304;
pub const TSC_IOGXCR_CNT_Pos: u32 = 0;
pub const TSC_IOGXCR_CNT_Msk: u32 = 16383;
pub const TSC_IOGXCR_CNT: u32 = 16383;
pub const LCD_CR_LCDEN_Pos: u32 = 0;
pub const LCD_CR_LCDEN_Msk: u32 = 1;
pub const LCD_CR_LCDEN: u32 = 1;
pub const LCD_CR_VSEL_Pos: u32 = 1;
pub const LCD_CR_VSEL_Msk: u32 = 2;
pub const LCD_CR_VSEL: u32 = 2;
pub const LCD_CR_DUTY_Pos: u32 = 2;
pub const LCD_CR_DUTY_Msk: u32 = 28;
pub const LCD_CR_DUTY: u32 = 28;
pub const LCD_CR_DUTY_0: u32 = 4;
pub const LCD_CR_DUTY_1: u32 = 8;
pub const LCD_CR_DUTY_2: u32 = 16;
pub const LCD_CR_BIAS_Pos: u32 = 5;
pub const LCD_CR_BIAS_Msk: u32 = 96;
pub const LCD_CR_BIAS: u32 = 96;
pub const LCD_CR_BIAS_0: u32 = 32;
pub const LCD_CR_BIAS_1: u32 = 64;
pub const LCD_CR_MUX_SEG_Pos: u32 = 7;
pub const LCD_CR_MUX_SEG_Msk: u32 = 128;
pub const LCD_CR_MUX_SEG: u32 = 128;
pub const LCD_CR_BUFEN_Pos: u32 = 8;
pub const LCD_CR_BUFEN_Msk: u32 = 256;
pub const LCD_CR_BUFEN: u32 = 256;
pub const LCD_FCR_HD_Pos: u32 = 0;
pub const LCD_FCR_HD_Msk: u32 = 1;
pub const LCD_FCR_HD: u32 = 1;
pub const LCD_FCR_SOFIE_Pos: u32 = 1;
pub const LCD_FCR_SOFIE_Msk: u32 = 2;
pub const LCD_FCR_SOFIE: u32 = 2;
pub const LCD_FCR_UDDIE_Pos: u32 = 3;
pub const LCD_FCR_UDDIE_Msk: u32 = 8;
pub const LCD_FCR_UDDIE: u32 = 8;
pub const LCD_FCR_PON_Pos: u32 = 4;
pub const LCD_FCR_PON_Msk: u32 = 112;
pub const LCD_FCR_PON: u32 = 112;
pub const LCD_FCR_PON_0: u32 = 16;
pub const LCD_FCR_PON_1: u32 = 32;
pub const LCD_FCR_PON_2: u32 = 64;
pub const LCD_FCR_DEAD_Pos: u32 = 7;
pub const LCD_FCR_DEAD_Msk: u32 = 896;
pub const LCD_FCR_DEAD: u32 = 896;
pub const LCD_FCR_DEAD_0: u32 = 128;
pub const LCD_FCR_DEAD_1: u32 = 256;
pub const LCD_FCR_DEAD_2: u32 = 512;
pub const LCD_FCR_CC_Pos: u32 = 10;
pub const LCD_FCR_CC_Msk: u32 = 7168;
pub const LCD_FCR_CC: u32 = 7168;
pub const LCD_FCR_CC_0: u32 = 1024;
pub const LCD_FCR_CC_1: u32 = 2048;
pub const LCD_FCR_CC_2: u32 = 4096;
pub const LCD_FCR_BLINKF_Pos: u32 = 13;
pub const LCD_FCR_BLINKF_Msk: u32 = 57344;
pub const LCD_FCR_BLINKF: u32 = 57344;
pub const LCD_FCR_BLINKF_0: u32 = 8192;
pub const LCD_FCR_BLINKF_1: u32 = 16384;
pub const LCD_FCR_BLINKF_2: u32 = 32768;
pub const LCD_FCR_BLINK_Pos: u32 = 16;
pub const LCD_FCR_BLINK_Msk: u32 = 196608;
pub const LCD_FCR_BLINK: u32 = 196608;
pub const LCD_FCR_BLINK_0: u32 = 65536;
pub const LCD_FCR_BLINK_1: u32 = 131072;
pub const LCD_FCR_DIV_Pos: u32 = 18;
pub const LCD_FCR_DIV_Msk: u32 = 3932160;
pub const LCD_FCR_DIV: u32 = 3932160;
pub const LCD_FCR_PS_Pos: u32 = 22;
pub const LCD_FCR_PS_Msk: u32 = 62914560;
pub const LCD_FCR_PS: u32 = 62914560;
pub const LCD_SR_ENS_Pos: u32 = 0;
pub const LCD_SR_ENS_Msk: u32 = 1;
pub const LCD_SR_ENS: u32 = 1;
pub const LCD_SR_SOF_Pos: u32 = 1;
pub const LCD_SR_SOF_Msk: u32 = 2;
pub const LCD_SR_SOF: u32 = 2;
pub const LCD_SR_UDR_Pos: u32 = 2;
pub const LCD_SR_UDR_Msk: u32 = 4;
pub const LCD_SR_UDR: u32 = 4;
pub const LCD_SR_UDD_Pos: u32 = 3;
pub const LCD_SR_UDD_Msk: u32 = 8;
pub const LCD_SR_UDD: u32 = 8;
pub const LCD_SR_RDY_Pos: u32 = 4;
pub const LCD_SR_RDY_Msk: u32 = 16;
pub const LCD_SR_RDY: u32 = 16;
pub const LCD_SR_FCRSR_Pos: u32 = 5;
pub const LCD_SR_FCRSR_Msk: u32 = 32;
pub const LCD_SR_FCRSR: u32 = 32;
pub const LCD_CLR_SOFC_Pos: u32 = 1;
pub const LCD_CLR_SOFC_Msk: u32 = 2;
pub const LCD_CLR_SOFC: u32 = 2;
pub const LCD_CLR_UDDC_Pos: u32 = 3;
pub const LCD_CLR_UDDC_Msk: u32 = 8;
pub const LCD_CLR_UDDC: u32 = 8;
pub const LCD_RAM_SEGMENT_DATA_Pos: u32 = 0;
pub const LCD_RAM_SEGMENT_DATA_Msk: u32 = 4294967295;
pub const LCD_RAM_SEGMENT_DATA: u32 = 4294967295;
pub const SAI_GCR_SYNCIN_Pos: u32 = 0;
pub const SAI_GCR_SYNCIN_Msk: u32 = 3;
pub const SAI_GCR_SYNCIN: u32 = 3;
pub const SAI_GCR_SYNCIN_0: u32 = 1;
pub const SAI_GCR_SYNCIN_1: u32 = 2;
pub const SAI_GCR_SYNCOUT_Pos: u32 = 4;
pub const SAI_GCR_SYNCOUT_Msk: u32 = 48;
pub const SAI_GCR_SYNCOUT: u32 = 48;
pub const SAI_GCR_SYNCOUT_0: u32 = 16;
pub const SAI_GCR_SYNCOUT_1: u32 = 32;
pub const SAI_xCR1_MODE_Pos: u32 = 0;
pub const SAI_xCR1_MODE_Msk: u32 = 3;
pub const SAI_xCR1_MODE: u32 = 3;
pub const SAI_xCR1_MODE_0: u32 = 1;
pub const SAI_xCR1_MODE_1: u32 = 2;
pub const SAI_xCR1_PRTCFG_Pos: u32 = 2;
pub const SAI_xCR1_PRTCFG_Msk: u32 = 12;
pub const SAI_xCR1_PRTCFG: u32 = 12;
pub const SAI_xCR1_PRTCFG_0: u32 = 4;
pub const SAI_xCR1_PRTCFG_1: u32 = 8;
pub const SAI_xCR1_DS_Pos: u32 = 5;
pub const SAI_xCR1_DS_Msk: u32 = 224;
pub const SAI_xCR1_DS: u32 = 224;
pub const SAI_xCR1_DS_0: u32 = 32;
pub const SAI_xCR1_DS_1: u32 = 64;
pub const SAI_xCR1_DS_2: u32 = 128;
pub const SAI_xCR1_LSBFIRST_Pos: u32 = 8;
pub const SAI_xCR1_LSBFIRST_Msk: u32 = 256;
pub const SAI_xCR1_LSBFIRST: u32 = 256;
pub const SAI_xCR1_CKSTR_Pos: u32 = 9;
pub const SAI_xCR1_CKSTR_Msk: u32 = 512;
pub const SAI_xCR1_CKSTR: u32 = 512;
pub const SAI_xCR1_SYNCEN_Pos: u32 = 10;
pub const SAI_xCR1_SYNCEN_Msk: u32 = 3072;
pub const SAI_xCR1_SYNCEN: u32 = 3072;
pub const SAI_xCR1_SYNCEN_0: u32 = 1024;
pub const SAI_xCR1_SYNCEN_1: u32 = 2048;
pub const SAI_xCR1_MONO_Pos: u32 = 12;
pub const SAI_xCR1_MONO_Msk: u32 = 4096;
pub const SAI_xCR1_MONO: u32 = 4096;
pub const SAI_xCR1_OUTDRIV_Pos: u32 = 13;
pub const SAI_xCR1_OUTDRIV_Msk: u32 = 8192;
pub const SAI_xCR1_OUTDRIV: u32 = 8192;
pub const SAI_xCR1_SAIEN_Pos: u32 = 16;
pub const SAI_xCR1_SAIEN_Msk: u32 = 65536;
pub const SAI_xCR1_SAIEN: u32 = 65536;
pub const SAI_xCR1_DMAEN_Pos: u32 = 17;
pub const SAI_xCR1_DMAEN_Msk: u32 = 131072;
pub const SAI_xCR1_DMAEN: u32 = 131072;
pub const SAI_xCR1_NODIV_Pos: u32 = 19;
pub const SAI_xCR1_NODIV_Msk: u32 = 524288;
pub const SAI_xCR1_NODIV: u32 = 524288;
pub const SAI_xCR1_MCKDIV_Pos: u32 = 20;
pub const SAI_xCR1_MCKDIV_Msk: u32 = 66060288;
pub const SAI_xCR1_MCKDIV: u32 = 66060288;
pub const SAI_xCR1_MCKDIV_0: u32 = 1048576;
pub const SAI_xCR1_MCKDIV_1: u32 = 2097152;
pub const SAI_xCR1_MCKDIV_2: u32 = 4194304;
pub const SAI_xCR1_MCKDIV_3: u32 = 8388608;
pub const SAI_xCR1_MCKDIV_4: u32 = 16777216;
pub const SAI_xCR1_MCKDIV_5: u32 = 33554432;
pub const SAI_xCR1_OSR_Pos: u32 = 26;
pub const SAI_xCR1_OSR_Msk: u32 = 67108864;
pub const SAI_xCR1_OSR: u32 = 67108864;
pub const SAI_xCR1_MCKEN_Pos: u32 = 27;
pub const SAI_xCR1_MCKEN_Msk: u32 = 134217728;
pub const SAI_xCR1_MCKEN: u32 = 134217728;
pub const SAI_xCR2_FTH_Pos: u32 = 0;
pub const SAI_xCR2_FTH_Msk: u32 = 7;
pub const SAI_xCR2_FTH: u32 = 7;
pub const SAI_xCR2_FTH_0: u32 = 1;
pub const SAI_xCR2_FTH_1: u32 = 2;
pub const SAI_xCR2_FTH_2: u32 = 4;
pub const SAI_xCR2_FFLUSH_Pos: u32 = 3;
pub const SAI_xCR2_FFLUSH_Msk: u32 = 8;
pub const SAI_xCR2_FFLUSH: u32 = 8;
pub const SAI_xCR2_TRIS_Pos: u32 = 4;
pub const SAI_xCR2_TRIS_Msk: u32 = 16;
pub const SAI_xCR2_TRIS: u32 = 16;
pub const SAI_xCR2_MUTE_Pos: u32 = 5;
pub const SAI_xCR2_MUTE_Msk: u32 = 32;
pub const SAI_xCR2_MUTE: u32 = 32;
pub const SAI_xCR2_MUTEVAL_Pos: u32 = 6;
pub const SAI_xCR2_MUTEVAL_Msk: u32 = 64;
pub const SAI_xCR2_MUTEVAL: u32 = 64;
pub const SAI_xCR2_MUTECNT_Pos: u32 = 7;
pub const SAI_xCR2_MUTECNT_Msk: u32 = 8064;
pub const SAI_xCR2_MUTECNT: u32 = 8064;
pub const SAI_xCR2_MUTECNT_0: u32 = 128;
pub const SAI_xCR2_MUTECNT_1: u32 = 256;
pub const SAI_xCR2_MUTECNT_2: u32 = 512;
pub const SAI_xCR2_MUTECNT_3: u32 = 1024;
pub const SAI_xCR2_MUTECNT_4: u32 = 2048;
pub const SAI_xCR2_MUTECNT_5: u32 = 4096;
pub const SAI_xCR2_CPL_Pos: u32 = 13;
pub const SAI_xCR2_CPL_Msk: u32 = 8192;
pub const SAI_xCR2_CPL: u32 = 8192;
pub const SAI_xCR2_COMP_Pos: u32 = 14;
pub const SAI_xCR2_COMP_Msk: u32 = 49152;
pub const SAI_xCR2_COMP: u32 = 49152;
pub const SAI_xCR2_COMP_0: u32 = 16384;
pub const SAI_xCR2_COMP_1: u32 = 32768;
pub const SAI_xFRCR_FRL_Pos: u32 = 0;
pub const SAI_xFRCR_FRL_Msk: u32 = 255;
pub const SAI_xFRCR_FRL: u32 = 255;
pub const SAI_xFRCR_FRL_0: u32 = 1;
pub const SAI_xFRCR_FRL_1: u32 = 2;
pub const SAI_xFRCR_FRL_2: u32 = 4;
pub const SAI_xFRCR_FRL_3: u32 = 8;
pub const SAI_xFRCR_FRL_4: u32 = 16;
pub const SAI_xFRCR_FRL_5: u32 = 32;
pub const SAI_xFRCR_FRL_6: u32 = 64;
pub const SAI_xFRCR_FRL_7: u32 = 128;
pub const SAI_xFRCR_FSALL_Pos: u32 = 8;
pub const SAI_xFRCR_FSALL_Msk: u32 = 32512;
pub const SAI_xFRCR_FSALL: u32 = 32512;
pub const SAI_xFRCR_FSALL_0: u32 = 256;
pub const SAI_xFRCR_FSALL_1: u32 = 512;
pub const SAI_xFRCR_FSALL_2: u32 = 1024;
pub const SAI_xFRCR_FSALL_3: u32 = 2048;
pub const SAI_xFRCR_FSALL_4: u32 = 4096;
pub const SAI_xFRCR_FSALL_5: u32 = 8192;
pub const SAI_xFRCR_FSALL_6: u32 = 16384;
pub const SAI_xFRCR_FSDEF_Pos: u32 = 16;
pub const SAI_xFRCR_FSDEF_Msk: u32 = 65536;
pub const SAI_xFRCR_FSDEF: u32 = 65536;
pub const SAI_xFRCR_FSPOL_Pos: u32 = 17;
pub const SAI_xFRCR_FSPOL_Msk: u32 = 131072;
pub const SAI_xFRCR_FSPOL: u32 = 131072;
pub const SAI_xFRCR_FSOFF_Pos: u32 = 18;
pub const SAI_xFRCR_FSOFF_Msk: u32 = 262144;
pub const SAI_xFRCR_FSOFF: u32 = 262144;
pub const SAI_xSLOTR_FBOFF_Pos: u32 = 0;
pub const SAI_xSLOTR_FBOFF_Msk: u32 = 31;
pub const SAI_xSLOTR_FBOFF: u32 = 31;
pub const SAI_xSLOTR_FBOFF_0: u32 = 1;
pub const SAI_xSLOTR_FBOFF_1: u32 = 2;
pub const SAI_xSLOTR_FBOFF_2: u32 = 4;
pub const SAI_xSLOTR_FBOFF_3: u32 = 8;
pub const SAI_xSLOTR_FBOFF_4: u32 = 16;
pub const SAI_xSLOTR_SLOTSZ_Pos: u32 = 6;
pub const SAI_xSLOTR_SLOTSZ_Msk: u32 = 192;
pub const SAI_xSLOTR_SLOTSZ: u32 = 192;
pub const SAI_xSLOTR_SLOTSZ_0: u32 = 64;
pub const SAI_xSLOTR_SLOTSZ_1: u32 = 128;
pub const SAI_xSLOTR_NBSLOT_Pos: u32 = 8;
pub const SAI_xSLOTR_NBSLOT_Msk: u32 = 3840;
pub const SAI_xSLOTR_NBSLOT: u32 = 3840;
pub const SAI_xSLOTR_NBSLOT_0: u32 = 256;
pub const SAI_xSLOTR_NBSLOT_1: u32 = 512;
pub const SAI_xSLOTR_NBSLOT_2: u32 = 1024;
pub const SAI_xSLOTR_NBSLOT_3: u32 = 2048;
pub const SAI_xSLOTR_SLOTEN_Pos: u32 = 16;
pub const SAI_xSLOTR_SLOTEN_Msk: u32 = 4294901760;
pub const SAI_xSLOTR_SLOTEN: u32 = 4294901760;
pub const SAI_xIMR_OVRUDRIE_Pos: u32 = 0;
pub const SAI_xIMR_OVRUDRIE_Msk: u32 = 1;
pub const SAI_xIMR_OVRUDRIE: u32 = 1;
pub const SAI_xIMR_MUTEDETIE_Pos: u32 = 1;
pub const SAI_xIMR_MUTEDETIE_Msk: u32 = 2;
pub const SAI_xIMR_MUTEDETIE: u32 = 2;
pub const SAI_xIMR_WCKCFGIE_Pos: u32 = 2;
pub const SAI_xIMR_WCKCFGIE_Msk: u32 = 4;
pub const SAI_xIMR_WCKCFGIE: u32 = 4;
pub const SAI_xIMR_FREQIE_Pos: u32 = 3;
pub const SAI_xIMR_FREQIE_Msk: u32 = 8;
pub const SAI_xIMR_FREQIE: u32 = 8;
pub const SAI_xIMR_CNRDYIE_Pos: u32 = 4;
pub const SAI_xIMR_CNRDYIE_Msk: u32 = 16;
pub const SAI_xIMR_CNRDYIE: u32 = 16;
pub const SAI_xIMR_AFSDETIE_Pos: u32 = 5;
pub const SAI_xIMR_AFSDETIE_Msk: u32 = 32;
pub const SAI_xIMR_AFSDETIE: u32 = 32;
pub const SAI_xIMR_LFSDETIE_Pos: u32 = 6;
pub const SAI_xIMR_LFSDETIE_Msk: u32 = 64;
pub const SAI_xIMR_LFSDETIE: u32 = 64;
pub const SAI_xSR_OVRUDR_Pos: u32 = 0;
pub const SAI_xSR_OVRUDR_Msk: u32 = 1;
pub const SAI_xSR_OVRUDR: u32 = 1;
pub const SAI_xSR_MUTEDET_Pos: u32 = 1;
pub const SAI_xSR_MUTEDET_Msk: u32 = 2;
pub const SAI_xSR_MUTEDET: u32 = 2;
pub const SAI_xSR_WCKCFG_Pos: u32 = 2;
pub const SAI_xSR_WCKCFG_Msk: u32 = 4;
pub const SAI_xSR_WCKCFG: u32 = 4;
pub const SAI_xSR_FREQ_Pos: u32 = 3;
pub const SAI_xSR_FREQ_Msk: u32 = 8;
pub const SAI_xSR_FREQ: u32 = 8;
pub const SAI_xSR_CNRDY_Pos: u32 = 4;
pub const SAI_xSR_CNRDY_Msk: u32 = 16;
pub const SAI_xSR_CNRDY: u32 = 16;
pub const SAI_xSR_AFSDET_Pos: u32 = 5;
pub const SAI_xSR_AFSDET_Msk: u32 = 32;
pub const SAI_xSR_AFSDET: u32 = 32;
pub const SAI_xSR_LFSDET_Pos: u32 = 6;
pub const SAI_xSR_LFSDET_Msk: u32 = 64;
pub const SAI_xSR_LFSDET: u32 = 64;
pub const SAI_xSR_FLVL_Pos: u32 = 16;
pub const SAI_xSR_FLVL_Msk: u32 = 458752;
pub const SAI_xSR_FLVL: u32 = 458752;
pub const SAI_xSR_FLVL_0: u32 = 65536;
pub const SAI_xSR_FLVL_1: u32 = 131072;
pub const SAI_xSR_FLVL_2: u32 = 262144;
pub const SAI_xCLRFR_COVRUDR_Pos: u32 = 0;
pub const SAI_xCLRFR_COVRUDR_Msk: u32 = 1;
pub const SAI_xCLRFR_COVRUDR: u32 = 1;
pub const SAI_xCLRFR_CMUTEDET_Pos: u32 = 1;
pub const SAI_xCLRFR_CMUTEDET_Msk: u32 = 2;
pub const SAI_xCLRFR_CMUTEDET: u32 = 2;
pub const SAI_xCLRFR_CWCKCFG_Pos: u32 = 2;
pub const SAI_xCLRFR_CWCKCFG_Msk: u32 = 4;
pub const SAI_xCLRFR_CWCKCFG: u32 = 4;
pub const SAI_xCLRFR_CFREQ_Pos: u32 = 3;
pub const SAI_xCLRFR_CFREQ_Msk: u32 = 8;
pub const SAI_xCLRFR_CFREQ: u32 = 8;
pub const SAI_xCLRFR_CCNRDY_Pos: u32 = 4;
pub const SAI_xCLRFR_CCNRDY_Msk: u32 = 16;
pub const SAI_xCLRFR_CCNRDY: u32 = 16;
pub const SAI_xCLRFR_CAFSDET_Pos: u32 = 5;
pub const SAI_xCLRFR_CAFSDET_Msk: u32 = 32;
pub const SAI_xCLRFR_CAFSDET: u32 = 32;
pub const SAI_xCLRFR_CLFSDET_Pos: u32 = 6;
pub const SAI_xCLRFR_CLFSDET_Msk: u32 = 64;
pub const SAI_xCLRFR_CLFSDET: u32 = 64;
pub const SAI_xDR_DATA_Pos: u32 = 0;
pub const SAI_xDR_DATA_Msk: u32 = 4294967295;
pub const SAI_xDR_DATA: u32 = 4294967295;
pub const SAI_PDMCR_PDMEN_Pos: u32 = 0;
pub const SAI_PDMCR_PDMEN_Msk: u32 = 1;
pub const SAI_PDMCR_PDMEN: u32 = 1;
pub const SAI_PDMCR_MICNBR_Pos: u32 = 4;
pub const SAI_PDMCR_MICNBR_Msk: u32 = 48;
pub const SAI_PDMCR_MICNBR: u32 = 48;
pub const SAI_PDMCR_MICNBR_0: u32 = 16;
pub const SAI_PDMCR_MICNBR_1: u32 = 32;
pub const SAI_PDMCR_CKEN1_Pos: u32 = 8;
pub const SAI_PDMCR_CKEN1_Msk: u32 = 256;
pub const SAI_PDMCR_CKEN1: u32 = 256;
pub const SAI_PDMCR_CKEN2_Pos: u32 = 9;
pub const SAI_PDMCR_CKEN2_Msk: u32 = 512;
pub const SAI_PDMCR_CKEN2: u32 = 512;
pub const SAI_PDMCR_CKEN3_Pos: u32 = 10;
pub const SAI_PDMCR_CKEN3_Msk: u32 = 1024;
pub const SAI_PDMCR_CKEN3: u32 = 1024;
pub const SAI_PDMCR_CKEN4_Pos: u32 = 11;
pub const SAI_PDMCR_CKEN4_Msk: u32 = 2048;
pub const SAI_PDMCR_CKEN4: u32 = 2048;
pub const SAI_PDMDLY_DLYM1L_Pos: u32 = 0;
pub const SAI_PDMDLY_DLYM1L_Msk: u32 = 7;
pub const SAI_PDMDLY_DLYM1L: u32 = 7;
pub const SAI_PDMDLY_DLYM1L_0: u32 = 1;
pub const SAI_PDMDLY_DLYM1L_1: u32 = 2;
pub const SAI_PDMDLY_DLYM1L_2: u32 = 4;
pub const SAI_PDMDLY_DLYM1R_Pos: u32 = 4;
pub const SAI_PDMDLY_DLYM1R_Msk: u32 = 112;
pub const SAI_PDMDLY_DLYM1R: u32 = 112;
pub const SAI_PDMDLY_DLYM1R_0: u32 = 16;
pub const SAI_PDMDLY_DLYM1R_1: u32 = 32;
pub const SAI_PDMDLY_DLYM1R_2: u32 = 64;
pub const SAI_PDMDLY_DLYM2L_Pos: u32 = 8;
pub const SAI_PDMDLY_DLYM2L_Msk: u32 = 1792;
pub const SAI_PDMDLY_DLYM2L: u32 = 1792;
pub const SAI_PDMDLY_DLYM2L_0: u32 = 256;
pub const SAI_PDMDLY_DLYM2L_1: u32 = 512;
pub const SAI_PDMDLY_DLYM2L_2: u32 = 1024;
pub const SAI_PDMDLY_DLYM2R_Pos: u32 = 12;
pub const SAI_PDMDLY_DLYM2R_Msk: u32 = 28672;
pub const SAI_PDMDLY_DLYM2R: u32 = 28672;
pub const SAI_PDMDLY_DLYM2R_0: u32 = 4096;
pub const SAI_PDMDLY_DLYM2R_1: u32 = 8192;
pub const SAI_PDMDLY_DLYM2R_2: u32 = 16384;
pub const SAI_PDMDLY_DLYM3L_Pos: u32 = 16;
pub const SAI_PDMDLY_DLYM3L_Msk: u32 = 458752;
pub const SAI_PDMDLY_DLYM3L: u32 = 458752;
pub const SAI_PDMDLY_DLYM3L_0: u32 = 65536;
pub const SAI_PDMDLY_DLYM3L_1: u32 = 131072;
pub const SAI_PDMDLY_DLYM3L_2: u32 = 262144;
pub const SAI_PDMDLY_DLYM3R_Pos: u32 = 20;
pub const SAI_PDMDLY_DLYM3R_Msk: u32 = 7340032;
pub const SAI_PDMDLY_DLYM3R: u32 = 7340032;
pub const SAI_PDMDLY_DLYM3R_0: u32 = 1048576;
pub const SAI_PDMDLY_DLYM3R_1: u32 = 2097152;
pub const SAI_PDMDLY_DLYM3R_2: u32 = 4194304;
pub const SAI_PDMDLY_DLYM4L_Pos: u32 = 24;
pub const SAI_PDMDLY_DLYM4L_Msk: u32 = 117440512;
pub const SAI_PDMDLY_DLYM4L: u32 = 117440512;
pub const SAI_PDMDLY_DLYM4L_0: u32 = 16777216;
pub const SAI_PDMDLY_DLYM4L_1: u32 = 33554432;
pub const SAI_PDMDLY_DLYM4L_2: u32 = 67108864;
pub const SAI_PDMDLY_DLYM4R_Pos: u32 = 28;
pub const SAI_PDMDLY_DLYM4R_Msk: u32 = 1879048192;
pub const SAI_PDMDLY_DLYM4R: u32 = 1879048192;
pub const SAI_PDMDLY_DLYM4R_0: u32 = 268435456;
pub const SAI_PDMDLY_DLYM4R_1: u32 = 536870912;
pub const SAI_PDMDLY_DLYM4R_2: u32 = 1073741824;
pub const SYSCFG_MEMRMP_MEM_MODE_Pos: u32 = 0;
pub const SYSCFG_MEMRMP_MEM_MODE_Msk: u32 = 7;
pub const SYSCFG_MEMRMP_MEM_MODE: u32 = 7;
pub const SYSCFG_MEMRMP_MEM_MODE_0: u32 = 1;
pub const SYSCFG_MEMRMP_MEM_MODE_1: u32 = 2;
pub const SYSCFG_MEMRMP_MEM_MODE_2: u32 = 4;
pub const SYSCFG_CFGR1_BOOSTEN_Pos: u32 = 8;
pub const SYSCFG_CFGR1_BOOSTEN_Msk: u32 = 256;
pub const SYSCFG_CFGR1_BOOSTEN: u32 = 256;
pub const SYSCFG_CFGR1_ANASWVDD_Pos: u32 = 9;
pub const SYSCFG_CFGR1_ANASWVDD_Msk: u32 = 512;
pub const SYSCFG_CFGR1_ANASWVDD: u32 = 512;
pub const SYSCFG_CFGR1_I2C_PB6_FMP_Pos: u32 = 16;
pub const SYSCFG_CFGR1_I2C_PB6_FMP_Msk: u32 = 65536;
pub const SYSCFG_CFGR1_I2C_PB6_FMP: u32 = 65536;
pub const SYSCFG_CFGR1_I2C_PB7_FMP_Pos: u32 = 17;
pub const SYSCFG_CFGR1_I2C_PB7_FMP_Msk: u32 = 131072;
pub const SYSCFG_CFGR1_I2C_PB7_FMP: u32 = 131072;
pub const SYSCFG_CFGR1_I2C_PB8_FMP_Pos: u32 = 18;
pub const SYSCFG_CFGR1_I2C_PB8_FMP_Msk: u32 = 262144;
pub const SYSCFG_CFGR1_I2C_PB8_FMP: u32 = 262144;
pub const SYSCFG_CFGR1_I2C_PB9_FMP_Pos: u32 = 19;
pub const SYSCFG_CFGR1_I2C_PB9_FMP_Msk: u32 = 524288;
pub const SYSCFG_CFGR1_I2C_PB9_FMP: u32 = 524288;
pub const SYSCFG_CFGR1_I2C1_FMP_Pos: u32 = 20;
pub const SYSCFG_CFGR1_I2C1_FMP_Msk: u32 = 1048576;
pub const SYSCFG_CFGR1_I2C1_FMP: u32 = 1048576;
pub const SYSCFG_CFGR1_I2C3_FMP_Pos: u32 = 22;
pub const SYSCFG_CFGR1_I2C3_FMP_Msk: u32 = 4194304;
pub const SYSCFG_CFGR1_I2C3_FMP: u32 = 4194304;
pub const SYSCFG_CFGR1_FPU_IE_Pos: u32 = 26;
pub const SYSCFG_CFGR1_FPU_IE_Msk: u32 = 4227858432;
pub const SYSCFG_CFGR1_FPU_IE: u32 = 4227858432;
pub const SYSCFG_CFGR1_FPU_IE_0: u32 = 67108864;
pub const SYSCFG_CFGR1_FPU_IE_1: u32 = 134217728;
pub const SYSCFG_CFGR1_FPU_IE_2: u32 = 268435456;
pub const SYSCFG_CFGR1_FPU_IE_3: u32 = 536870912;
pub const SYSCFG_CFGR1_FPU_IE_4: u32 = 1073741824;
pub const SYSCFG_CFGR1_FPU_IE_5: u32 = 2147483648;
pub const SYSCFG_EXTICR1_EXTI0_Pos: u32 = 0;
pub const SYSCFG_EXTICR1_EXTI0_Msk: u32 = 7;
pub const SYSCFG_EXTICR1_EXTI0: u32 = 7;
pub const SYSCFG_EXTICR1_EXTI1_Pos: u32 = 4;
pub const SYSCFG_EXTICR1_EXTI1_Msk: u32 = 112;
pub const SYSCFG_EXTICR1_EXTI1: u32 = 112;
pub const SYSCFG_EXTICR1_EXTI2_Pos: u32 = 8;
pub const SYSCFG_EXTICR1_EXTI2_Msk: u32 = 1792;
pub const SYSCFG_EXTICR1_EXTI2: u32 = 1792;
pub const SYSCFG_EXTICR1_EXTI3_Pos: u32 = 12;
pub const SYSCFG_EXTICR1_EXTI3_Msk: u32 = 28672;
pub const SYSCFG_EXTICR1_EXTI3: u32 = 28672;
pub const SYSCFG_EXTICR1_EXTI0_PA: u32 = 0;
pub const SYSCFG_EXTICR1_EXTI0_PB: u32 = 1;
pub const SYSCFG_EXTICR1_EXTI0_PC: u32 = 2;
pub const SYSCFG_EXTICR1_EXTI0_PD: u32 = 3;
pub const SYSCFG_EXTICR1_EXTI0_PE: u32 = 4;
pub const SYSCFG_EXTICR1_EXTI0_PH: u32 = 7;
pub const SYSCFG_EXTICR1_EXTI1_PA: u32 = 0;
pub const SYSCFG_EXTICR1_EXTI1_PB: u32 = 16;
pub const SYSCFG_EXTICR1_EXTI1_PC: u32 = 32;
pub const SYSCFG_EXTICR1_EXTI1_PD: u32 = 48;
pub const SYSCFG_EXTICR1_EXTI1_PE: u32 = 64;
pub const SYSCFG_EXTICR1_EXTI1_PH: u32 = 112;
pub const SYSCFG_EXTICR1_EXTI2_PA: u32 = 0;
pub const SYSCFG_EXTICR1_EXTI2_PB: u32 = 256;
pub const SYSCFG_EXTICR1_EXTI2_PC: u32 = 512;
pub const SYSCFG_EXTICR1_EXTI2_PD: u32 = 768;
pub const SYSCFG_EXTICR1_EXTI2_PE: u32 = 1024;
pub const SYSCFG_EXTICR1_EXTI3_PA: u32 = 0;
pub const SYSCFG_EXTICR1_EXTI3_PB: u32 = 4096;
pub const SYSCFG_EXTICR1_EXTI3_PC: u32 = 8192;
pub const SYSCFG_EXTICR1_EXTI3_PD: u32 = 12288;
pub const SYSCFG_EXTICR1_EXTI3_PE: u32 = 16384;
pub const SYSCFG_EXTICR1_EXTI3_PH: u32 = 28672;
pub const SYSCFG_EXTICR2_EXTI4_Pos: u32 = 0;
pub const SYSCFG_EXTICR2_EXTI4_Msk: u32 = 7;
pub const SYSCFG_EXTICR2_EXTI4: u32 = 7;
pub const SYSCFG_EXTICR2_EXTI5_Pos: u32 = 4;
pub const SYSCFG_EXTICR2_EXTI5_Msk: u32 = 112;
pub const SYSCFG_EXTICR2_EXTI5: u32 = 112;
pub const SYSCFG_EXTICR2_EXTI6_Pos: u32 = 8;
pub const SYSCFG_EXTICR2_EXTI6_Msk: u32 = 1792;
pub const SYSCFG_EXTICR2_EXTI6: u32 = 1792;
pub const SYSCFG_EXTICR2_EXTI7_Pos: u32 = 12;
pub const SYSCFG_EXTICR2_EXTI7_Msk: u32 = 28672;
pub const SYSCFG_EXTICR2_EXTI7: u32 = 28672;
pub const SYSCFG_EXTICR2_EXTI4_PA: u32 = 0;
pub const SYSCFG_EXTICR2_EXTI4_PB: u32 = 1;
pub const SYSCFG_EXTICR2_EXTI4_PC: u32 = 2;
pub const SYSCFG_EXTICR2_EXTI4_PD: u32 = 3;
pub const SYSCFG_EXTICR2_EXTI4_PE: u32 = 4;
pub const SYSCFG_EXTICR2_EXTI5_PA: u32 = 0;
pub const SYSCFG_EXTICR2_EXTI5_PB: u32 = 16;
pub const SYSCFG_EXTICR2_EXTI5_PC: u32 = 32;
pub const SYSCFG_EXTICR2_EXTI5_PD: u32 = 48;
pub const SYSCFG_EXTICR2_EXTI6_PA: u32 = 0;
pub const SYSCFG_EXTICR2_EXTI6_PB: u32 = 256;
pub const SYSCFG_EXTICR2_EXTI6_PC: u32 = 512;
pub const SYSCFG_EXTICR2_EXTI6_PD: u32 = 768;
pub const SYSCFG_EXTICR2_EXTI7_PA: u32 = 0;
pub const SYSCFG_EXTICR2_EXTI7_PB: u32 = 4096;
pub const SYSCFG_EXTICR2_EXTI7_PC: u32 = 8192;
pub const SYSCFG_EXTICR2_EXTI7_PD: u32 = 12288;
pub const SYSCFG_EXTICR3_EXTI8_Pos: u32 = 0;
pub const SYSCFG_EXTICR3_EXTI8_Msk: u32 = 7;
pub const SYSCFG_EXTICR3_EXTI8: u32 = 7;
pub const SYSCFG_EXTICR3_EXTI9_Pos: u32 = 4;
pub const SYSCFG_EXTICR3_EXTI9_Msk: u32 = 112;
pub const SYSCFG_EXTICR3_EXTI9: u32 = 112;
pub const SYSCFG_EXTICR3_EXTI10_Pos: u32 = 8;
pub const SYSCFG_EXTICR3_EXTI10_Msk: u32 = 1792;
pub const SYSCFG_EXTICR3_EXTI10: u32 = 1792;
pub const SYSCFG_EXTICR3_EXTI11_Pos: u32 = 12;
pub const SYSCFG_EXTICR3_EXTI11_Msk: u32 = 61440;
pub const SYSCFG_EXTICR3_EXTI11: u32 = 61440;
pub const SYSCFG_EXTICR3_EXTI8_PA: u32 = 0;
pub const SYSCFG_EXTICR3_EXTI8_PB: u32 = 1;
pub const SYSCFG_EXTICR3_EXTI8_PC: u32 = 2;
pub const SYSCFG_EXTICR3_EXTI8_PD: u32 = 3;
pub const SYSCFG_EXTICR3_EXTI9_PA: u32 = 0;
pub const SYSCFG_EXTICR3_EXTI9_PB: u32 = 16;
pub const SYSCFG_EXTICR3_EXTI9_PC: u32 = 32;
pub const SYSCFG_EXTICR3_EXTI9_PD: u32 = 48;
pub const SYSCFG_EXTICR3_EXTI10_PA: u32 = 0;
pub const SYSCFG_EXTICR3_EXTI10_PB: u32 = 256;
pub const SYSCFG_EXTICR3_EXTI10_PC: u32 = 512;
pub const SYSCFG_EXTICR3_EXTI10_PD: u32 = 768;
pub const SYSCFG_EXTICR3_EXTI11_PA: u32 = 0;
pub const SYSCFG_EXTICR3_EXTI11_PB: u32 = 4096;
pub const SYSCFG_EXTICR3_EXTI11_PC: u32 = 8192;
pub const SYSCFG_EXTICR3_EXTI11_PD: u32 = 12288;
pub const SYSCFG_EXTICR4_EXTI12_Pos: u32 = 0;
pub const SYSCFG_EXTICR4_EXTI12_Msk: u32 = 7;
pub const SYSCFG_EXTICR4_EXTI12: u32 = 7;
pub const SYSCFG_EXTICR4_EXTI13_Pos: u32 = 4;
pub const SYSCFG_EXTICR4_EXTI13_Msk: u32 = 112;
pub const SYSCFG_EXTICR4_EXTI13: u32 = 112;
pub const SYSCFG_EXTICR4_EXTI14_Pos: u32 = 8;
pub const SYSCFG_EXTICR4_EXTI14_Msk: u32 = 1792;
pub const SYSCFG_EXTICR4_EXTI14: u32 = 1792;
pub const SYSCFG_EXTICR4_EXTI15_Pos: u32 = 12;
pub const SYSCFG_EXTICR4_EXTI15_Msk: u32 = 28672;
pub const SYSCFG_EXTICR4_EXTI15: u32 = 28672;
pub const SYSCFG_EXTICR4_EXTI12_PA: u32 = 0;
pub const SYSCFG_EXTICR4_EXTI12_PB: u32 = 1;
pub const SYSCFG_EXTICR4_EXTI12_PC: u32 = 2;
pub const SYSCFG_EXTICR4_EXTI12_PD: u32 = 3;
pub const SYSCFG_EXTICR4_EXTI13_PA: u32 = 0;
pub const SYSCFG_EXTICR4_EXTI13_PB: u32 = 16;
pub const SYSCFG_EXTICR4_EXTI13_PC: u32 = 32;
pub const SYSCFG_EXTICR4_EXTI13_PD: u32 = 48;
pub const SYSCFG_EXTICR4_EXTI14_PA: u32 = 0;
pub const SYSCFG_EXTICR4_EXTI14_PB: u32 = 256;
pub const SYSCFG_EXTICR4_EXTI14_PC: u32 = 512;
pub const SYSCFG_EXTICR4_EXTI14_PD: u32 = 768;
pub const SYSCFG_EXTICR4_EXTI15_PA: u32 = 0;
pub const SYSCFG_EXTICR4_EXTI15_PB: u32 = 4096;
pub const SYSCFG_EXTICR4_EXTI15_PC: u32 = 8192;
pub const SYSCFG_EXTICR4_EXTI15_PD: u32 = 12288;
pub const SYSCFG_SCSR_SRAM2ER_Pos: u32 = 0;
pub const SYSCFG_SCSR_SRAM2ER_Msk: u32 = 1;
pub const SYSCFG_SCSR_SRAM2ER: u32 = 1;
pub const SYSCFG_SCSR_SRAM2BSY_Pos: u32 = 1;
pub const SYSCFG_SCSR_SRAM2BSY_Msk: u32 = 2;
pub const SYSCFG_SCSR_SRAM2BSY: u32 = 2;
pub const SYSCFG_SCSR_C2RFD_Pos: u32 = 31;
pub const SYSCFG_SCSR_C2RFD_Msk: u32 = 2147483648;
pub const SYSCFG_SCSR_C2RFD: u32 = 2147483648;
pub const SYSCFG_CFGR2_CLL_Pos: u32 = 0;
pub const SYSCFG_CFGR2_CLL_Msk: u32 = 1;
pub const SYSCFG_CFGR2_CLL: u32 = 1;
pub const SYSCFG_CFGR2_SPL_Pos: u32 = 1;
pub const SYSCFG_CFGR2_SPL_Msk: u32 = 2;
pub const SYSCFG_CFGR2_SPL: u32 = 2;
pub const SYSCFG_CFGR2_PVDL_Pos: u32 = 2;
pub const SYSCFG_CFGR2_PVDL_Msk: u32 = 4;
pub const SYSCFG_CFGR2_PVDL: u32 = 4;
pub const SYSCFG_CFGR2_ECCL_Pos: u32 = 3;
pub const SYSCFG_CFGR2_ECCL_Msk: u32 = 8;
pub const SYSCFG_CFGR2_ECCL: u32 = 8;
pub const SYSCFG_CFGR2_SPF_Pos: u32 = 8;
pub const SYSCFG_CFGR2_SPF_Msk: u32 = 256;
pub const SYSCFG_CFGR2_SPF: u32 = 256;
pub const SYSCFG_SWPR1_PAGE0_Pos: u32 = 0;
pub const SYSCFG_SWPR1_PAGE0_Msk: u32 = 1;
pub const SYSCFG_SWPR1_PAGE0: u32 = 1;
pub const SYSCFG_SWPR1_PAGE1_Pos: u32 = 1;
pub const SYSCFG_SWPR1_PAGE1_Msk: u32 = 2;
pub const SYSCFG_SWPR1_PAGE1: u32 = 2;
pub const SYSCFG_SWPR1_PAGE2_Pos: u32 = 2;
pub const SYSCFG_SWPR1_PAGE2_Msk: u32 = 4;
pub const SYSCFG_SWPR1_PAGE2: u32 = 4;
pub const SYSCFG_SWPR1_PAGE3_Pos: u32 = 3;
pub const SYSCFG_SWPR1_PAGE3_Msk: u32 = 8;
pub const SYSCFG_SWPR1_PAGE3: u32 = 8;
pub const SYSCFG_SWPR1_PAGE4_Pos: u32 = 4;
pub const SYSCFG_SWPR1_PAGE4_Msk: u32 = 16;
pub const SYSCFG_SWPR1_PAGE4: u32 = 16;
pub const SYSCFG_SWPR1_PAGE5_Pos: u32 = 5;
pub const SYSCFG_SWPR1_PAGE5_Msk: u32 = 32;
pub const SYSCFG_SWPR1_PAGE5: u32 = 32;
pub const SYSCFG_SWPR1_PAGE6_Pos: u32 = 6;
pub const SYSCFG_SWPR1_PAGE6_Msk: u32 = 64;
pub const SYSCFG_SWPR1_PAGE6: u32 = 64;
pub const SYSCFG_SWPR1_PAGE7_Pos: u32 = 7;
pub const SYSCFG_SWPR1_PAGE7_Msk: u32 = 128;
pub const SYSCFG_SWPR1_PAGE7: u32 = 128;
pub const SYSCFG_SWPR1_PAGE8_Pos: u32 = 8;
pub const SYSCFG_SWPR1_PAGE8_Msk: u32 = 256;
pub const SYSCFG_SWPR1_PAGE8: u32 = 256;
pub const SYSCFG_SWPR1_PAGE9_Pos: u32 = 9;
pub const SYSCFG_SWPR1_PAGE9_Msk: u32 = 512;
pub const SYSCFG_SWPR1_PAGE9: u32 = 512;
pub const SYSCFG_SWPR1_PAGE10_Pos: u32 = 10;
pub const SYSCFG_SWPR1_PAGE10_Msk: u32 = 1024;
pub const SYSCFG_SWPR1_PAGE10: u32 = 1024;
pub const SYSCFG_SWPR1_PAGE11_Pos: u32 = 11;
pub const SYSCFG_SWPR1_PAGE11_Msk: u32 = 2048;
pub const SYSCFG_SWPR1_PAGE11: u32 = 2048;
pub const SYSCFG_SWPR1_PAGE12_Pos: u32 = 12;
pub const SYSCFG_SWPR1_PAGE12_Msk: u32 = 4096;
pub const SYSCFG_SWPR1_PAGE12: u32 = 4096;
pub const SYSCFG_SWPR1_PAGE13_Pos: u32 = 13;
pub const SYSCFG_SWPR1_PAGE13_Msk: u32 = 8192;
pub const SYSCFG_SWPR1_PAGE13: u32 = 8192;
pub const SYSCFG_SWPR1_PAGE14_Pos: u32 = 14;
pub const SYSCFG_SWPR1_PAGE14_Msk: u32 = 16384;
pub const SYSCFG_SWPR1_PAGE14: u32 = 16384;
pub const SYSCFG_SWPR1_PAGE15_Pos: u32 = 15;
pub const SYSCFG_SWPR1_PAGE15_Msk: u32 = 32768;
pub const SYSCFG_SWPR1_PAGE15: u32 = 32768;
pub const SYSCFG_SWPR1_PAGE16_Pos: u32 = 16;
pub const SYSCFG_SWPR1_PAGE16_Msk: u32 = 65536;
pub const SYSCFG_SWPR1_PAGE16: u32 = 65536;
pub const SYSCFG_SWPR1_PAGE17_Pos: u32 = 17;
pub const SYSCFG_SWPR1_PAGE17_Msk: u32 = 131072;
pub const SYSCFG_SWPR1_PAGE17: u32 = 131072;
pub const SYSCFG_SWPR1_PAGE18_Pos: u32 = 18;
pub const SYSCFG_SWPR1_PAGE18_Msk: u32 = 262144;
pub const SYSCFG_SWPR1_PAGE18: u32 = 262144;
pub const SYSCFG_SWPR1_PAGE19_Pos: u32 = 19;
pub const SYSCFG_SWPR1_PAGE19_Msk: u32 = 524288;
pub const SYSCFG_SWPR1_PAGE19: u32 = 524288;
pub const SYSCFG_SWPR1_PAGE20_Pos: u32 = 20;
pub const SYSCFG_SWPR1_PAGE20_Msk: u32 = 1048576;
pub const SYSCFG_SWPR1_PAGE20: u32 = 1048576;
pub const SYSCFG_SWPR1_PAGE21_Pos: u32 = 21;
pub const SYSCFG_SWPR1_PAGE21_Msk: u32 = 2097152;
pub const SYSCFG_SWPR1_PAGE21: u32 = 2097152;
pub const SYSCFG_SWPR1_PAGE22_Pos: u32 = 22;
pub const SYSCFG_SWPR1_PAGE22_Msk: u32 = 4194304;
pub const SYSCFG_SWPR1_PAGE22: u32 = 4194304;
pub const SYSCFG_SWPR1_PAGE23_Pos: u32 = 23;
pub const SYSCFG_SWPR1_PAGE23_Msk: u32 = 8388608;
pub const SYSCFG_SWPR1_PAGE23: u32 = 8388608;
pub const SYSCFG_SWPR1_PAGE24_Pos: u32 = 24;
pub const SYSCFG_SWPR1_PAGE24_Msk: u32 = 16777216;
pub const SYSCFG_SWPR1_PAGE24: u32 = 16777216;
pub const SYSCFG_SWPR1_PAGE25_Pos: u32 = 25;
pub const SYSCFG_SWPR1_PAGE25_Msk: u32 = 33554432;
pub const SYSCFG_SWPR1_PAGE25: u32 = 33554432;
pub const SYSCFG_SWPR1_PAGE26_Pos: u32 = 26;
pub const SYSCFG_SWPR1_PAGE26_Msk: u32 = 67108864;
pub const SYSCFG_SWPR1_PAGE26: u32 = 67108864;
pub const SYSCFG_SWPR1_PAGE27_Pos: u32 = 27;
pub const SYSCFG_SWPR1_PAGE27_Msk: u32 = 134217728;
pub const SYSCFG_SWPR1_PAGE27: u32 = 134217728;
pub const SYSCFG_SWPR1_PAGE28_Pos: u32 = 28;
pub const SYSCFG_SWPR1_PAGE28_Msk: u32 = 268435456;
pub const SYSCFG_SWPR1_PAGE28: u32 = 268435456;
pub const SYSCFG_SWPR1_PAGE29_Pos: u32 = 29;
pub const SYSCFG_SWPR1_PAGE29_Msk: u32 = 536870912;
pub const SYSCFG_SWPR1_PAGE29: u32 = 536870912;
pub const SYSCFG_SWPR1_PAGE30_Pos: u32 = 30;
pub const SYSCFG_SWPR1_PAGE30_Msk: u32 = 1073741824;
pub const SYSCFG_SWPR1_PAGE30: u32 = 1073741824;
pub const SYSCFG_SWPR1_PAGE31_Pos: u32 = 31;
pub const SYSCFG_SWPR1_PAGE31_Msk: u32 = 2147483648;
pub const SYSCFG_SWPR1_PAGE31: u32 = 2147483648;
pub const SYSCFG_SKR_KEY_Pos: u32 = 0;
pub const SYSCFG_SKR_KEY_Msk: u32 = 255;
pub const SYSCFG_SKR_KEY: u32 = 255;
pub const SYSCFG_SWPR2_PAGE32_Pos: u32 = 0;
pub const SYSCFG_SWPR2_PAGE32_Msk: u32 = 1;
pub const SYSCFG_SWPR2_PAGE32: u32 = 1;
pub const SYSCFG_SWPR2_PAGE33_Pos: u32 = 1;
pub const SYSCFG_SWPR2_PAGE33_Msk: u32 = 2;
pub const SYSCFG_SWPR2_PAGE33: u32 = 2;
pub const SYSCFG_SWPR2_PAGE34_Pos: u32 = 2;
pub const SYSCFG_SWPR2_PAGE34_Msk: u32 = 4;
pub const SYSCFG_SWPR2_PAGE34: u32 = 4;
pub const SYSCFG_SWPR2_PAGE35_Pos: u32 = 3;
pub const SYSCFG_SWPR2_PAGE35_Msk: u32 = 8;
pub const SYSCFG_SWPR2_PAGE35: u32 = 8;
pub const SYSCFG_SWPR2_PAGE36_Pos: u32 = 4;
pub const SYSCFG_SWPR2_PAGE36_Msk: u32 = 16;
pub const SYSCFG_SWPR2_PAGE36: u32 = 16;
pub const SYSCFG_SWPR2_PAGE37_Pos: u32 = 5;
pub const SYSCFG_SWPR2_PAGE37_Msk: u32 = 32;
pub const SYSCFG_SWPR2_PAGE37: u32 = 32;
pub const SYSCFG_SWPR2_PAGE38_Pos: u32 = 6;
pub const SYSCFG_SWPR2_PAGE38_Msk: u32 = 64;
pub const SYSCFG_SWPR2_PAGE38: u32 = 64;
pub const SYSCFG_SWPR2_PAGE39_Pos: u32 = 7;
pub const SYSCFG_SWPR2_PAGE39_Msk: u32 = 128;
pub const SYSCFG_SWPR2_PAGE39: u32 = 128;
pub const SYSCFG_SWPR2_PAGE40_Pos: u32 = 8;
pub const SYSCFG_SWPR2_PAGE40_Msk: u32 = 256;
pub const SYSCFG_SWPR2_PAGE40: u32 = 256;
pub const SYSCFG_SWPR2_PAGE41_Pos: u32 = 9;
pub const SYSCFG_SWPR2_PAGE41_Msk: u32 = 512;
pub const SYSCFG_SWPR2_PAGE41: u32 = 512;
pub const SYSCFG_SWPR2_PAGE42_Pos: u32 = 10;
pub const SYSCFG_SWPR2_PAGE42_Msk: u32 = 1024;
pub const SYSCFG_SWPR2_PAGE42: u32 = 1024;
pub const SYSCFG_SWPR2_PAGE43_Pos: u32 = 11;
pub const SYSCFG_SWPR2_PAGE43_Msk: u32 = 2048;
pub const SYSCFG_SWPR2_PAGE43: u32 = 2048;
pub const SYSCFG_SWPR2_PAGE44_Pos: u32 = 12;
pub const SYSCFG_SWPR2_PAGE44_Msk: u32 = 4096;
pub const SYSCFG_SWPR2_PAGE44: u32 = 4096;
pub const SYSCFG_SWPR2_PAGE45_Pos: u32 = 13;
pub const SYSCFG_SWPR2_PAGE45_Msk: u32 = 8192;
pub const SYSCFG_SWPR2_PAGE45: u32 = 8192;
pub const SYSCFG_SWPR2_PAGE46_Pos: u32 = 14;
pub const SYSCFG_SWPR2_PAGE46_Msk: u32 = 16384;
pub const SYSCFG_SWPR2_PAGE46: u32 = 16384;
pub const SYSCFG_SWPR2_PAGE47_Pos: u32 = 15;
pub const SYSCFG_SWPR2_PAGE47_Msk: u32 = 32768;
pub const SYSCFG_SWPR2_PAGE47: u32 = 32768;
pub const SYSCFG_SWPR2_PAGE48_Pos: u32 = 16;
pub const SYSCFG_SWPR2_PAGE48_Msk: u32 = 65536;
pub const SYSCFG_SWPR2_PAGE48: u32 = 65536;
pub const SYSCFG_SWPR2_PAGE49_Pos: u32 = 17;
pub const SYSCFG_SWPR2_PAGE49_Msk: u32 = 131072;
pub const SYSCFG_SWPR2_PAGE49: u32 = 131072;
pub const SYSCFG_SWPR2_PAGE50_Pos: u32 = 18;
pub const SYSCFG_SWPR2_PAGE50_Msk: u32 = 262144;
pub const SYSCFG_SWPR2_PAGE50: u32 = 262144;
pub const SYSCFG_SWPR2_PAGE51_Pos: u32 = 19;
pub const SYSCFG_SWPR2_PAGE51_Msk: u32 = 524288;
pub const SYSCFG_SWPR2_PAGE51: u32 = 524288;
pub const SYSCFG_SWPR2_PAGE52_Pos: u32 = 20;
pub const SYSCFG_SWPR2_PAGE52_Msk: u32 = 1048576;
pub const SYSCFG_SWPR2_PAGE52: u32 = 1048576;
pub const SYSCFG_SWPR2_PAGE53_Pos: u32 = 21;
pub const SYSCFG_SWPR2_PAGE53_Msk: u32 = 2097152;
pub const SYSCFG_SWPR2_PAGE53: u32 = 2097152;
pub const SYSCFG_SWPR2_PAGE54_Pos: u32 = 22;
pub const SYSCFG_SWPR2_PAGE54_Msk: u32 = 4194304;
pub const SYSCFG_SWPR2_PAGE54: u32 = 4194304;
pub const SYSCFG_SWPR2_PAGE55_Pos: u32 = 23;
pub const SYSCFG_SWPR2_PAGE55_Msk: u32 = 8388608;
pub const SYSCFG_SWPR2_PAGE55: u32 = 8388608;
pub const SYSCFG_SWPR2_PAGE56_Pos: u32 = 24;
pub const SYSCFG_SWPR2_PAGE56_Msk: u32 = 16777216;
pub const SYSCFG_SWPR2_PAGE56: u32 = 16777216;
pub const SYSCFG_SWPR2_PAGE57_Pos: u32 = 25;
pub const SYSCFG_SWPR2_PAGE57_Msk: u32 = 33554432;
pub const SYSCFG_SWPR2_PAGE57: u32 = 33554432;
pub const SYSCFG_SWPR2_PAGE58_Pos: u32 = 26;
pub const SYSCFG_SWPR2_PAGE58_Msk: u32 = 67108864;
pub const SYSCFG_SWPR2_PAGE58: u32 = 67108864;
pub const SYSCFG_SWPR2_PAGE59_Pos: u32 = 27;
pub const SYSCFG_SWPR2_PAGE59_Msk: u32 = 134217728;
pub const SYSCFG_SWPR2_PAGE59: u32 = 134217728;
pub const SYSCFG_SWPR2_PAGE60_Pos: u32 = 28;
pub const SYSCFG_SWPR2_PAGE60_Msk: u32 = 268435456;
pub const SYSCFG_SWPR2_PAGE60: u32 = 268435456;
pub const SYSCFG_SWPR2_PAGE61_Pos: u32 = 29;
pub const SYSCFG_SWPR2_PAGE61_Msk: u32 = 536870912;
pub const SYSCFG_SWPR2_PAGE61: u32 = 536870912;
pub const SYSCFG_SWPR2_PAGE62_Pos: u32 = 30;
pub const SYSCFG_SWPR2_PAGE62_Msk: u32 = 1073741824;
pub const SYSCFG_SWPR2_PAGE62: u32 = 1073741824;
pub const SYSCFG_SWPR2_PAGE63_Pos: u32 = 31;
pub const SYSCFG_SWPR2_PAGE63_Msk: u32 = 2147483648;
pub const SYSCFG_SWPR2_PAGE63: u32 = 2147483648;
pub const SYSCFG_IMR1_TIM1IM_Pos: u32 = 13;
pub const SYSCFG_IMR1_TIM1IM_Msk: u32 = 8192;
pub const SYSCFG_IMR1_TIM1IM: u32 = 8192;
pub const SYSCFG_IMR1_TIM16IM_Pos: u32 = 14;
pub const SYSCFG_IMR1_TIM16IM_Msk: u32 = 16384;
pub const SYSCFG_IMR1_TIM16IM: u32 = 16384;
pub const SYSCFG_IMR1_TIM17IM_Pos: u32 = 15;
pub const SYSCFG_IMR1_TIM17IM_Msk: u32 = 32768;
pub const SYSCFG_IMR1_TIM17IM: u32 = 32768;
pub const SYSCFG_IMR1_EXTI5IM_Pos: u32 = 21;
pub const SYSCFG_IMR1_EXTI5IM_Msk: u32 = 2097152;
pub const SYSCFG_IMR1_EXTI5IM: u32 = 2097152;
pub const SYSCFG_IMR1_EXTI6IM_Pos: u32 = 22;
pub const SYSCFG_IMR1_EXTI6IM_Msk: u32 = 4194304;
pub const SYSCFG_IMR1_EXTI6IM: u32 = 4194304;
pub const SYSCFG_IMR1_EXTI7IM_Pos: u32 = 23;
pub const SYSCFG_IMR1_EXTI7IM_Msk: u32 = 8388608;
pub const SYSCFG_IMR1_EXTI7IM: u32 = 8388608;
pub const SYSCFG_IMR1_EXTI8IM_Pos: u32 = 24;
pub const SYSCFG_IMR1_EXTI8IM_Msk: u32 = 16777216;
pub const SYSCFG_IMR1_EXTI8IM: u32 = 16777216;
pub const SYSCFG_IMR1_EXTI9IM_Pos: u32 = 25;
pub const SYSCFG_IMR1_EXTI9IM_Msk: u32 = 33554432;
pub const SYSCFG_IMR1_EXTI9IM: u32 = 33554432;
pub const SYSCFG_IMR1_EXTI10IM_Pos: u32 = 26;
pub const SYSCFG_IMR1_EXTI10IM_Msk: u32 = 67108864;
pub const SYSCFG_IMR1_EXTI10IM: u32 = 67108864;
pub const SYSCFG_IMR1_EXTI11IM_Pos: u32 = 27;
pub const SYSCFG_IMR1_EXTI11IM_Msk: u32 = 134217728;
pub const SYSCFG_IMR1_EXTI11IM: u32 = 134217728;
pub const SYSCFG_IMR1_EXTI12IM_Pos: u32 = 28;
pub const SYSCFG_IMR1_EXTI12IM_Msk: u32 = 268435456;
pub const SYSCFG_IMR1_EXTI12IM: u32 = 268435456;
pub const SYSCFG_IMR1_EXTI13IM_Pos: u32 = 29;
pub const SYSCFG_IMR1_EXTI13IM_Msk: u32 = 536870912;
pub const SYSCFG_IMR1_EXTI13IM: u32 = 536870912;
pub const SYSCFG_IMR1_EXTI14IM_Pos: u32 = 30;
pub const SYSCFG_IMR1_EXTI14IM_Msk: u32 = 1073741824;
pub const SYSCFG_IMR1_EXTI14IM: u32 = 1073741824;
pub const SYSCFG_IMR1_EXTI15IM_Pos: u32 = 31;
pub const SYSCFG_IMR1_EXTI15IM_Msk: u32 = 2147483648;
pub const SYSCFG_IMR1_EXTI15IM: u32 = 2147483648;
pub const SYSCFG_IMR2_PVM1IM_Pos: u32 = 16;
pub const SYSCFG_IMR2_PVM1IM_Msk: u32 = 65536;
pub const SYSCFG_IMR2_PVM1IM: u32 = 65536;
pub const SYSCFG_IMR2_PVM3IM_Pos: u32 = 18;
pub const SYSCFG_IMR2_PVM3IM_Msk: u32 = 262144;
pub const SYSCFG_IMR2_PVM3IM: u32 = 262144;
pub const SYSCFG_IMR2_PVDIM_Pos: u32 = 20;
pub const SYSCFG_IMR2_PVDIM_Msk: u32 = 1048576;
pub const SYSCFG_IMR2_PVDIM: u32 = 1048576;
pub const SYSCFG_C2IMR1_RTCSTAMPTAMPLSECSSIM_Pos: u32 = 0;
pub const SYSCFG_C2IMR1_RTCSTAMPTAMPLSECSSIM_Msk: u32 = 1;
pub const SYSCFG_C2IMR1_RTCSTAMPTAMPLSECSSIM: u32 = 1;
pub const SYSCFG_C2IMR1_RTCWKUPIM_Pos: u32 = 3;
pub const SYSCFG_C2IMR1_RTCWKUPIM_Msk: u32 = 8;
pub const SYSCFG_C2IMR1_RTCWKUPIM: u32 = 8;
pub const SYSCFG_C2IMR1_RTCALARMIM_Pos: u32 = 4;
pub const SYSCFG_C2IMR1_RTCALARMIM_Msk: u32 = 16;
pub const SYSCFG_C2IMR1_RTCALARMIM: u32 = 16;
pub const SYSCFG_C2IMR1_RCCIM_Pos: u32 = 5;
pub const SYSCFG_C2IMR1_RCCIM_Msk: u32 = 32;
pub const SYSCFG_C2IMR1_RCCIM: u32 = 32;
pub const SYSCFG_C2IMR1_FLASHIM_Pos: u32 = 6;
pub const SYSCFG_C2IMR1_FLASHIM_Msk: u32 = 64;
pub const SYSCFG_C2IMR1_FLASHIM: u32 = 64;
pub const SYSCFG_C2IMR1_PKAIM_Pos: u32 = 8;
pub const SYSCFG_C2IMR1_PKAIM_Msk: u32 = 256;
pub const SYSCFG_C2IMR1_PKAIM: u32 = 256;
pub const SYSCFG_C2IMR1_RNGIM_Pos: u32 = 9;
pub const SYSCFG_C2IMR1_RNGIM_Msk: u32 = 512;
pub const SYSCFG_C2IMR1_RNGIM: u32 = 512;
pub const SYSCFG_C2IMR1_AES1IM_Pos: u32 = 10;
pub const SYSCFG_C2IMR1_AES1IM_Msk: u32 = 1024;
pub const SYSCFG_C2IMR1_AES1IM: u32 = 1024;
pub const SYSCFG_C2IMR1_COMPIM_Pos: u32 = 11;
pub const SYSCFG_C2IMR1_COMPIM_Msk: u32 = 2048;
pub const SYSCFG_C2IMR1_COMPIM: u32 = 2048;
pub const SYSCFG_C2IMR1_ADCIM_Pos: u32 = 12;
pub const SYSCFG_C2IMR1_ADCIM_Msk: u32 = 4096;
pub const SYSCFG_C2IMR1_ADCIM: u32 = 4096;
pub const SYSCFG_C2IMR1_EXTI0IM_Pos: u32 = 16;
pub const SYSCFG_C2IMR1_EXTI0IM_Msk: u32 = 65536;
pub const SYSCFG_C2IMR1_EXTI0IM: u32 = 65536;
pub const SYSCFG_C2IMR1_EXTI1IM_Pos: u32 = 17;
pub const SYSCFG_C2IMR1_EXTI1IM_Msk: u32 = 131072;
pub const SYSCFG_C2IMR1_EXTI1IM: u32 = 131072;
pub const SYSCFG_C2IMR1_EXTI2IM_Pos: u32 = 18;
pub const SYSCFG_C2IMR1_EXTI2IM_Msk: u32 = 262144;
pub const SYSCFG_C2IMR1_EXTI2IM: u32 = 262144;
pub const SYSCFG_C2IMR1_EXTI3IM_Pos: u32 = 19;
pub const SYSCFG_C2IMR1_EXTI3IM_Msk: u32 = 524288;
pub const SYSCFG_C2IMR1_EXTI3IM: u32 = 524288;
pub const SYSCFG_C2IMR1_EXTI4IM_Pos: u32 = 20;
pub const SYSCFG_C2IMR1_EXTI4IM_Msk: u32 = 1048576;
pub const SYSCFG_C2IMR1_EXTI4IM: u32 = 1048576;
pub const SYSCFG_C2IMR1_EXTI5IM_Pos: u32 = 21;
pub const SYSCFG_C2IMR1_EXTI5IM_Msk: u32 = 2097152;
pub const SYSCFG_C2IMR1_EXTI5IM: u32 = 2097152;
pub const SYSCFG_C2IMR1_EXTI6IM_Pos: u32 = 22;
pub const SYSCFG_C2IMR1_EXTI6IM_Msk: u32 = 4194304;
pub const SYSCFG_C2IMR1_EXTI6IM: u32 = 4194304;
pub const SYSCFG_C2IMR1_EXTI7IM_Pos: u32 = 23;
pub const SYSCFG_C2IMR1_EXTI7IM_Msk: u32 = 8388608;
pub const SYSCFG_C2IMR1_EXTI7IM: u32 = 8388608;
pub const SYSCFG_C2IMR1_EXTI8IM_Pos: u32 = 24;
pub const SYSCFG_C2IMR1_EXTI8IM_Msk: u32 = 16777216;
pub const SYSCFG_C2IMR1_EXTI8IM: u32 = 16777216;
pub const SYSCFG_C2IMR1_EXTI9IM_Pos: u32 = 25;
pub const SYSCFG_C2IMR1_EXTI9IM_Msk: u32 = 33554432;
pub const SYSCFG_C2IMR1_EXTI9IM: u32 = 33554432;
pub const SYSCFG_C2IMR1_EXTI10IM_Pos: u32 = 26;
pub const SYSCFG_C2IMR1_EXTI10IM_Msk: u32 = 67108864;
pub const SYSCFG_C2IMR1_EXTI10IM: u32 = 67108864;
pub const SYSCFG_C2IMR1_EXTI11IM_Pos: u32 = 27;
pub const SYSCFG_C2IMR1_EXTI11IM_Msk: u32 = 134217728;
pub const SYSCFG_C2IMR1_EXTI11IM: u32 = 134217728;
pub const SYSCFG_C2IMR1_EXTI12IM_Pos: u32 = 28;
pub const SYSCFG_C2IMR1_EXTI12IM_Msk: u32 = 268435456;
pub const SYSCFG_C2IMR1_EXTI12IM: u32 = 268435456;
pub const SYSCFG_C2IMR1_EXTI13IM_Pos: u32 = 29;
pub const SYSCFG_C2IMR1_EXTI13IM_Msk: u32 = 536870912;
pub const SYSCFG_C2IMR1_EXTI13IM: u32 = 536870912;
pub const SYSCFG_C2IMR1_EXTI14IM_Pos: u32 = 30;
pub const SYSCFG_C2IMR1_EXTI14IM_Msk: u32 = 1073741824;
pub const SYSCFG_C2IMR1_EXTI14IM: u32 = 1073741824;
pub const SYSCFG_C2IMR1_EXTI15IM_Pos: u32 = 31;
pub const SYSCFG_C2IMR1_EXTI15IM_Msk: u32 = 2147483648;
pub const SYSCFG_C2IMR1_EXTI15IM: u32 = 2147483648;
pub const SYSCFG_C2IMR2_DMA1CH1IM_Pos: u32 = 0;
pub const SYSCFG_C2IMR2_DMA1CH1IM_Msk: u32 = 1;
pub const SYSCFG_C2IMR2_DMA1CH1IM: u32 = 1;
pub const SYSCFG_C2IMR2_DMA1CH2IM_Pos: u32 = 1;
pub const SYSCFG_C2IMR2_DMA1CH2IM_Msk: u32 = 2;
pub const SYSCFG_C2IMR2_DMA1CH2IM: u32 = 2;
pub const SYSCFG_C2IMR2_DMA1CH3IM_Pos: u32 = 2;
pub const SYSCFG_C2IMR2_DMA1CH3IM_Msk: u32 = 4;
pub const SYSCFG_C2IMR2_DMA1CH3IM: u32 = 4;
pub const SYSCFG_C2IMR2_DMA1CH4IM_Pos: u32 = 3;
pub const SYSCFG_C2IMR2_DMA1CH4IM_Msk: u32 = 8;
pub const SYSCFG_C2IMR2_DMA1CH4IM: u32 = 8;
pub const SYSCFG_C2IMR2_DMA1CH5IM_Pos: u32 = 4;
pub const SYSCFG_C2IMR2_DMA1CH5IM_Msk: u32 = 16;
pub const SYSCFG_C2IMR2_DMA1CH5IM: u32 = 16;
pub const SYSCFG_C2IMR2_DMA1CH6IM_Pos: u32 = 5;
pub const SYSCFG_C2IMR2_DMA1CH6IM_Msk: u32 = 32;
pub const SYSCFG_C2IMR2_DMA1CH6IM: u32 = 32;
pub const SYSCFG_C2IMR2_DMA1CH7IM_Pos: u32 = 6;
pub const SYSCFG_C2IMR2_DMA1CH7IM_Msk: u32 = 64;
pub const SYSCFG_C2IMR2_DMA1CH7IM: u32 = 64;
pub const SYSCFG_C2IMR2_DMA2CH1IM_Pos: u32 = 8;
pub const SYSCFG_C2IMR2_DMA2CH1IM_Msk: u32 = 256;
pub const SYSCFG_C2IMR2_DMA2CH1IM: u32 = 256;
pub const SYSCFG_C2IMR2_DMA2CH2IM_Pos: u32 = 9;
pub const SYSCFG_C2IMR2_DMA2CH2IM_Msk: u32 = 512;
pub const SYSCFG_C2IMR2_DMA2CH2IM: u32 = 512;
pub const SYSCFG_C2IMR2_DMA2CH3IM_Pos: u32 = 10;
pub const SYSCFG_C2IMR2_DMA2CH3IM_Msk: u32 = 1024;
pub const SYSCFG_C2IMR2_DMA2CH3IM: u32 = 1024;
pub const SYSCFG_C2IMR2_DMA2CH4IM_Pos: u32 = 11;
pub const SYSCFG_C2IMR2_DMA2CH4IM_Msk: u32 = 2048;
pub const SYSCFG_C2IMR2_DMA2CH4IM: u32 = 2048;
pub const SYSCFG_C2IMR2_DMA2CH5IM_Pos: u32 = 12;
pub const SYSCFG_C2IMR2_DMA2CH5IM_Msk: u32 = 4096;
pub const SYSCFG_C2IMR2_DMA2CH5IM: u32 = 4096;
pub const SYSCFG_C2IMR2_DMA2CH6IM_Pos: u32 = 13;
pub const SYSCFG_C2IMR2_DMA2CH6IM_Msk: u32 = 8192;
pub const SYSCFG_C2IMR2_DMA2CH6IM: u32 = 8192;
pub const SYSCFG_C2IMR2_DMA2CH7IM_Pos: u32 = 14;
pub const SYSCFG_C2IMR2_DMA2CH7IM_Msk: u32 = 16384;
pub const SYSCFG_C2IMR2_DMA2CH7IM: u32 = 16384;
pub const SYSCFG_C2IMR2_DMAMUX1IM_Pos: u32 = 15;
pub const SYSCFG_C2IMR2_DMAMUX1IM_Msk: u32 = 32768;
pub const SYSCFG_C2IMR2_DMAMUX1IM: u32 = 32768;
pub const SYSCFG_C2IMR2_PVM1IM_Pos: u32 = 16;
pub const SYSCFG_C2IMR2_PVM1IM_Msk: u32 = 65536;
pub const SYSCFG_C2IMR2_PVM1IM: u32 = 65536;
pub const SYSCFG_C2IMR2_PVM3IM_Pos: u32 = 18;
pub const SYSCFG_C2IMR2_PVM3IM_Msk: u32 = 262144;
pub const SYSCFG_C2IMR2_PVM3IM: u32 = 262144;
pub const SYSCFG_C2IMR2_PVDIM_Pos: u32 = 20;
pub const SYSCFG_C2IMR2_PVDIM_Msk: u32 = 1048576;
pub const SYSCFG_C2IMR2_PVDIM: u32 = 1048576;
pub const SYSCFG_C2IMR2_TSCIM_Pos: u32 = 21;
pub const SYSCFG_C2IMR2_TSCIM_Msk: u32 = 2097152;
pub const SYSCFG_C2IMR2_TSCIM: u32 = 2097152;
pub const SYSCFG_C2IMR2_LCDIM_Pos: u32 = 22;
pub const SYSCFG_C2IMR2_LCDIM_Msk: u32 = 4194304;
pub const SYSCFG_C2IMR2_LCDIM: u32 = 4194304;
pub const SYSCFG_SIPCR_SAES1_Pos: u32 = 0;
pub const SYSCFG_SIPCR_SAES1_Msk: u32 = 1;
pub const SYSCFG_SIPCR_SAES1: u32 = 1;
pub const SYSCFG_SIPCR_SAES2_Pos: u32 = 1;
pub const SYSCFG_SIPCR_SAES2_Msk: u32 = 2;
pub const SYSCFG_SIPCR_SAES2: u32 = 2;
pub const SYSCFG_SIPCR_SPKA_Pos: u32 = 2;
pub const SYSCFG_SIPCR_SPKA_Msk: u32 = 4;
pub const SYSCFG_SIPCR_SPKA: u32 = 4;
pub const SYSCFG_SIPCR_SRNG_Pos: u32 = 3;
pub const SYSCFG_SIPCR_SRNG_Msk: u32 = 8;
pub const SYSCFG_SIPCR_SRNG: u32 = 8;
pub const TIM_CR1_CEN_Pos: u32 = 0;
pub const TIM_CR1_CEN_Msk: u32 = 1;
pub const TIM_CR1_CEN: u32 = 1;
pub const TIM_CR1_UDIS_Pos: u32 = 1;
pub const TIM_CR1_UDIS_Msk: u32 = 2;
pub const TIM_CR1_UDIS: u32 = 2;
pub const TIM_CR1_URS_Pos: u32 = 2;
pub const TIM_CR1_URS_Msk: u32 = 4;
pub const TIM_CR1_URS: u32 = 4;
pub const TIM_CR1_OPM_Pos: u32 = 3;
pub const TIM_CR1_OPM_Msk: u32 = 8;
pub const TIM_CR1_OPM: u32 = 8;
pub const TIM_CR1_DIR_Pos: u32 = 4;
pub const TIM_CR1_DIR_Msk: u32 = 16;
pub const TIM_CR1_DIR: u32 = 16;
pub const TIM_CR1_CMS_Pos: u32 = 5;
pub const TIM_CR1_CMS_Msk: u32 = 96;
pub const TIM_CR1_CMS: u32 = 96;
pub const TIM_CR1_CMS_0: u32 = 32;
pub const TIM_CR1_CMS_1: u32 = 64;
pub const TIM_CR1_ARPE_Pos: u32 = 7;
pub const TIM_CR1_ARPE_Msk: u32 = 128;
pub const TIM_CR1_ARPE: u32 = 128;
pub const TIM_CR1_CKD_Pos: u32 = 8;
pub const TIM_CR1_CKD_Msk: u32 = 768;
pub const TIM_CR1_CKD: u32 = 768;
pub const TIM_CR1_CKD_0: u32 = 256;
pub const TIM_CR1_CKD_1: u32 = 512;
pub const TIM_CR1_UIFREMAP_Pos: u32 = 11;
pub const TIM_CR1_UIFREMAP_Msk: u32 = 2048;
pub const TIM_CR1_UIFREMAP: u32 = 2048;
pub const TIM_CR2_CCPC_Pos: u32 = 0;
pub const TIM_CR2_CCPC_Msk: u32 = 1;
pub const TIM_CR2_CCPC: u32 = 1;
pub const TIM_CR2_CCUS_Pos: u32 = 2;
pub const TIM_CR2_CCUS_Msk: u32 = 4;
pub const TIM_CR2_CCUS: u32 = 4;
pub const TIM_CR2_CCDS_Pos: u32 = 3;
pub const TIM_CR2_CCDS_Msk: u32 = 8;
pub const TIM_CR2_CCDS: u32 = 8;
pub const TIM_CR2_MMS_Pos: u32 = 4;
pub const TIM_CR2_MMS_Msk: u32 = 112;
pub const TIM_CR2_MMS: u32 = 112;
pub const TIM_CR2_MMS_0: u32 = 16;
pub const TIM_CR2_MMS_1: u32 = 32;
pub const TIM_CR2_MMS_2: u32 = 64;
pub const TIM_CR2_TI1S_Pos: u32 = 7;
pub const TIM_CR2_TI1S_Msk: u32 = 128;
pub const TIM_CR2_TI1S: u32 = 128;
pub const TIM_CR2_OIS1_Pos: u32 = 8;
pub const TIM_CR2_OIS1_Msk: u32 = 256;
pub const TIM_CR2_OIS1: u32 = 256;
pub const TIM_CR2_OIS1N_Pos: u32 = 9;
pub const TIM_CR2_OIS1N_Msk: u32 = 512;
pub const TIM_CR2_OIS1N: u32 = 512;
pub const TIM_CR2_OIS2_Pos: u32 = 10;
pub const TIM_CR2_OIS2_Msk: u32 = 1024;
pub const TIM_CR2_OIS2: u32 = 1024;
pub const TIM_CR2_OIS2N_Pos: u32 = 11;
pub const TIM_CR2_OIS2N_Msk: u32 = 2048;
pub const TIM_CR2_OIS2N: u32 = 2048;
pub const TIM_CR2_OIS3_Pos: u32 = 12;
pub const TIM_CR2_OIS3_Msk: u32 = 4096;
pub const TIM_CR2_OIS3: u32 = 4096;
pub const TIM_CR2_OIS3N_Pos: u32 = 13;
pub const TIM_CR2_OIS3N_Msk: u32 = 8192;
pub const TIM_CR2_OIS3N: u32 = 8192;
pub const TIM_CR2_OIS4_Pos: u32 = 14;
pub const TIM_CR2_OIS4_Msk: u32 = 16384;
pub const TIM_CR2_OIS4: u32 = 16384;
pub const TIM_CR2_OIS5_Pos: u32 = 16;
pub const TIM_CR2_OIS5_Msk: u32 = 65536;
pub const TIM_CR2_OIS5: u32 = 65536;
pub const TIM_CR2_OIS6_Pos: u32 = 18;
pub const TIM_CR2_OIS6_Msk: u32 = 262144;
pub const TIM_CR2_OIS6: u32 = 262144;
pub const TIM_CR2_MMS2_Pos: u32 = 20;
pub const TIM_CR2_MMS2_Msk: u32 = 15728640;
pub const TIM_CR2_MMS2: u32 = 15728640;
pub const TIM_CR2_MMS2_0: u32 = 1048576;
pub const TIM_CR2_MMS2_1: u32 = 2097152;
pub const TIM_CR2_MMS2_2: u32 = 4194304;
pub const TIM_CR2_MMS2_3: u32 = 8388608;
pub const TIM_SMCR_SMS_Pos: u32 = 0;
pub const TIM_SMCR_SMS_Msk: u32 = 65543;
pub const TIM_SMCR_SMS: u32 = 65543;
pub const TIM_SMCR_SMS_0: u32 = 1;
pub const TIM_SMCR_SMS_1: u32 = 2;
pub const TIM_SMCR_SMS_2: u32 = 4;
pub const TIM_SMCR_SMS_3: u32 = 65536;
pub const TIM_SMCR_OCCS_Pos: u32 = 3;
pub const TIM_SMCR_OCCS_Msk: u32 = 8;
pub const TIM_SMCR_OCCS: u32 = 8;
pub const TIM_SMCR_TS_Pos: u32 = 4;
pub const TIM_SMCR_TS_Msk: u32 = 3145840;
pub const TIM_SMCR_TS: u32 = 3145840;
pub const TIM_SMCR_TS_0: u32 = 16;
pub const TIM_SMCR_TS_1: u32 = 32;
pub const TIM_SMCR_TS_2: u32 = 64;
pub const TIM_SMCR_TS_3: u32 = 1048576;
pub const TIM_SMCR_TS_4: u32 = 2097152;
pub const TIM_SMCR_MSM_Pos: u32 = 7;
pub const TIM_SMCR_MSM_Msk: u32 = 128;
pub const TIM_SMCR_MSM: u32 = 128;
pub const TIM_SMCR_ETF_Pos: u32 = 8;
pub const TIM_SMCR_ETF_Msk: u32 = 3840;
pub const TIM_SMCR_ETF: u32 = 3840;
pub const TIM_SMCR_ETF_0: u32 = 256;
pub const TIM_SMCR_ETF_1: u32 = 512;
pub const TIM_SMCR_ETF_2: u32 = 1024;
pub const TIM_SMCR_ETF_3: u32 = 2048;
pub const TIM_SMCR_ETPS_Pos: u32 = 12;
pub const TIM_SMCR_ETPS_Msk: u32 = 12288;
pub const TIM_SMCR_ETPS: u32 = 12288;
pub const TIM_SMCR_ETPS_0: u32 = 4096;
pub const TIM_SMCR_ETPS_1: u32 = 8192;
pub const TIM_SMCR_ECE_Pos: u32 = 14;
pub const TIM_SMCR_ECE_Msk: u32 = 16384;
pub const TIM_SMCR_ECE: u32 = 16384;
pub const TIM_SMCR_ETP_Pos: u32 = 15;
pub const TIM_SMCR_ETP_Msk: u32 = 32768;
pub const TIM_SMCR_ETP: u32 = 32768;
pub const TIM_DIER_UIE_Pos: u32 = 0;
pub const TIM_DIER_UIE_Msk: u32 = 1;
pub const TIM_DIER_UIE: u32 = 1;
pub const TIM_DIER_CC1IE_Pos: u32 = 1;
pub const TIM_DIER_CC1IE_Msk: u32 = 2;
pub const TIM_DIER_CC1IE: u32 = 2;
pub const TIM_DIER_CC2IE_Pos: u32 = 2;
pub const TIM_DIER_CC2IE_Msk: u32 = 4;
pub const TIM_DIER_CC2IE: u32 = 4;
pub const TIM_DIER_CC3IE_Pos: u32 = 3;
pub const TIM_DIER_CC3IE_Msk: u32 = 8;
pub const TIM_DIER_CC3IE: u32 = 8;
pub const TIM_DIER_CC4IE_Pos: u32 = 4;
pub const TIM_DIER_CC4IE_Msk: u32 = 16;
pub const TIM_DIER_CC4IE: u32 = 16;
pub const TIM_DIER_COMIE_Pos: u32 = 5;
pub const TIM_DIER_COMIE_Msk: u32 = 32;
pub const TIM_DIER_COMIE: u32 = 32;
pub const TIM_DIER_TIE_Pos: u32 = 6;
pub const TIM_DIER_TIE_Msk: u32 = 64;
pub const TIM_DIER_TIE: u32 = 64;
pub const TIM_DIER_BIE_Pos: u32 = 7;
pub const TIM_DIER_BIE_Msk: u32 = 128;
pub const TIM_DIER_BIE: u32 = 128;
pub const TIM_DIER_UDE_Pos: u32 = 8;
pub const TIM_DIER_UDE_Msk: u32 = 256;
pub const TIM_DIER_UDE: u32 = 256;
pub const TIM_DIER_CC1DE_Pos: u32 = 9;
pub const TIM_DIER_CC1DE_Msk: u32 = 512;
pub const TIM_DIER_CC1DE: u32 = 512;
pub const TIM_DIER_CC2DE_Pos: u32 = 10;
pub const TIM_DIER_CC2DE_Msk: u32 = 1024;
pub const TIM_DIER_CC2DE: u32 = 1024;
pub const TIM_DIER_CC3DE_Pos: u32 = 11;
pub const TIM_DIER_CC3DE_Msk: u32 = 2048;
pub const TIM_DIER_CC3DE: u32 = 2048;
pub const TIM_DIER_CC4DE_Pos: u32 = 12;
pub const TIM_DIER_CC4DE_Msk: u32 = 4096;
pub const TIM_DIER_CC4DE: u32 = 4096;
pub const TIM_DIER_COMDE_Pos: u32 = 13;
pub const TIM_DIER_COMDE_Msk: u32 = 8192;
pub const TIM_DIER_COMDE: u32 = 8192;
pub const TIM_DIER_TDE_Pos: u32 = 14;
pub const TIM_DIER_TDE_Msk: u32 = 16384;
pub const TIM_DIER_TDE: u32 = 16384;
pub const TIM_SR_UIF_Pos: u32 = 0;
pub const TIM_SR_UIF_Msk: u32 = 1;
pub const TIM_SR_UIF: u32 = 1;
pub const TIM_SR_CC1IF_Pos: u32 = 1;
pub const TIM_SR_CC1IF_Msk: u32 = 2;
pub const TIM_SR_CC1IF: u32 = 2;
pub const TIM_SR_CC2IF_Pos: u32 = 2;
pub const TIM_SR_CC2IF_Msk: u32 = 4;
pub const TIM_SR_CC2IF: u32 = 4;
pub const TIM_SR_CC3IF_Pos: u32 = 3;
pub const TIM_SR_CC3IF_Msk: u32 = 8;
pub const TIM_SR_CC3IF: u32 = 8;
pub const TIM_SR_CC4IF_Pos: u32 = 4;
pub const TIM_SR_CC4IF_Msk: u32 = 16;
pub const TIM_SR_CC4IF: u32 = 16;
pub const TIM_SR_COMIF_Pos: u32 = 5;
pub const TIM_SR_COMIF_Msk: u32 = 32;
pub const TIM_SR_COMIF: u32 = 32;
pub const TIM_SR_TIF_Pos: u32 = 6;
pub const TIM_SR_TIF_Msk: u32 = 64;
pub const TIM_SR_TIF: u32 = 64;
pub const TIM_SR_BIF_Pos: u32 = 7;
pub const TIM_SR_BIF_Msk: u32 = 128;
pub const TIM_SR_BIF: u32 = 128;
pub const TIM_SR_B2IF_Pos: u32 = 8;
pub const TIM_SR_B2IF_Msk: u32 = 256;
pub const TIM_SR_B2IF: u32 = 256;
pub const TIM_SR_CC1OF_Pos: u32 = 9;
pub const TIM_SR_CC1OF_Msk: u32 = 512;
pub const TIM_SR_CC1OF: u32 = 512;
pub const TIM_SR_CC2OF_Pos: u32 = 10;
pub const TIM_SR_CC2OF_Msk: u32 = 1024;
pub const TIM_SR_CC2OF: u32 = 1024;
pub const TIM_SR_CC3OF_Pos: u32 = 11;
pub const TIM_SR_CC3OF_Msk: u32 = 2048;
pub const TIM_SR_CC3OF: u32 = 2048;
pub const TIM_SR_CC4OF_Pos: u32 = 12;
pub const TIM_SR_CC4OF_Msk: u32 = 4096;
pub const TIM_SR_CC4OF: u32 = 4096;
pub const TIM_SR_SBIF_Pos: u32 = 13;
pub const TIM_SR_SBIF_Msk: u32 = 8192;
pub const TIM_SR_SBIF: u32 = 8192;
pub const TIM_SR_CC5IF_Pos: u32 = 16;
pub const TIM_SR_CC5IF_Msk: u32 = 65536;
pub const TIM_SR_CC5IF: u32 = 65536;
pub const TIM_SR_CC6IF_Pos: u32 = 17;
pub const TIM_SR_CC6IF_Msk: u32 = 131072;
pub const TIM_SR_CC6IF: u32 = 131072;
pub const TIM_EGR_UG_Pos: u32 = 0;
pub const TIM_EGR_UG_Msk: u32 = 1;
pub const TIM_EGR_UG: u32 = 1;
pub const TIM_EGR_CC1G_Pos: u32 = 1;
pub const TIM_EGR_CC1G_Msk: u32 = 2;
pub const TIM_EGR_CC1G: u32 = 2;
pub const TIM_EGR_CC2G_Pos: u32 = 2;
pub const TIM_EGR_CC2G_Msk: u32 = 4;
pub const TIM_EGR_CC2G: u32 = 4;
pub const TIM_EGR_CC3G_Pos: u32 = 3;
pub const TIM_EGR_CC3G_Msk: u32 = 8;
pub const TIM_EGR_CC3G: u32 = 8;
pub const TIM_EGR_CC4G_Pos: u32 = 4;
pub const TIM_EGR_CC4G_Msk: u32 = 16;
pub const TIM_EGR_CC4G: u32 = 16;
pub const TIM_EGR_COMG_Pos: u32 = 5;
pub const TIM_EGR_COMG_Msk: u32 = 32;
pub const TIM_EGR_COMG: u32 = 32;
pub const TIM_EGR_TG_Pos: u32 = 6;
pub const TIM_EGR_TG_Msk: u32 = 64;
pub const TIM_EGR_TG: u32 = 64;
pub const TIM_EGR_BG_Pos: u32 = 7;
pub const TIM_EGR_BG_Msk: u32 = 128;
pub const TIM_EGR_BG: u32 = 128;
pub const TIM_EGR_B2G_Pos: u32 = 8;
pub const TIM_EGR_B2G_Msk: u32 = 256;
pub const TIM_EGR_B2G: u32 = 256;
pub const TIM_CCMR1_CC1S_Pos: u32 = 0;
pub const TIM_CCMR1_CC1S_Msk: u32 = 3;
pub const TIM_CCMR1_CC1S: u32 = 3;
pub const TIM_CCMR1_CC1S_0: u32 = 1;
pub const TIM_CCMR1_CC1S_1: u32 = 2;
pub const TIM_CCMR1_OC1FE_Pos: u32 = 2;
pub const TIM_CCMR1_OC1FE_Msk: u32 = 4;
pub const TIM_CCMR1_OC1FE: u32 = 4;
pub const TIM_CCMR1_OC1PE_Pos: u32 = 3;
pub const TIM_CCMR1_OC1PE_Msk: u32 = 8;
pub const TIM_CCMR1_OC1PE: u32 = 8;
pub const TIM_CCMR1_OC1M_Pos: u32 = 4;
pub const TIM_CCMR1_OC1M_Msk: u32 = 65648;
pub const TIM_CCMR1_OC1M: u32 = 65648;
pub const TIM_CCMR1_OC1M_0: u32 = 16;
pub const TIM_CCMR1_OC1M_1: u32 = 32;
pub const TIM_CCMR1_OC1M_2: u32 = 64;
pub const TIM_CCMR1_OC1M_3: u32 = 65536;
pub const TIM_CCMR1_OC1CE_Pos: u32 = 7;
pub const TIM_CCMR1_OC1CE_Msk: u32 = 128;
pub const TIM_CCMR1_OC1CE: u32 = 128;
pub const TIM_CCMR1_CC2S_Pos: u32 = 8;
pub const TIM_CCMR1_CC2S_Msk: u32 = 768;
pub const TIM_CCMR1_CC2S: u32 = 768;
pub const TIM_CCMR1_CC2S_0: u32 = 256;
pub const TIM_CCMR1_CC2S_1: u32 = 512;
pub const TIM_CCMR1_OC2FE_Pos: u32 = 10;
pub const TIM_CCMR1_OC2FE_Msk: u32 = 1024;
pub const TIM_CCMR1_OC2FE: u32 = 1024;
pub const TIM_CCMR1_OC2PE_Pos: u32 = 11;
pub const TIM_CCMR1_OC2PE_Msk: u32 = 2048;
pub const TIM_CCMR1_OC2PE: u32 = 2048;
pub const TIM_CCMR1_OC2M_Pos: u32 = 12;
pub const TIM_CCMR1_OC2M_Msk: u32 = 16805888;
pub const TIM_CCMR1_OC2M: u32 = 16805888;
pub const TIM_CCMR1_OC2M_0: u32 = 4096;
pub const TIM_CCMR1_OC2M_1: u32 = 8192;
pub const TIM_CCMR1_OC2M_2: u32 = 16384;
pub const TIM_CCMR1_OC2M_3: u32 = 16777216;
pub const TIM_CCMR1_OC2CE_Pos: u32 = 15;
pub const TIM_CCMR1_OC2CE_Msk: u32 = 32768;
pub const TIM_CCMR1_OC2CE: u32 = 32768;
pub const TIM_CCMR1_IC1PSC_Pos: u32 = 2;
pub const TIM_CCMR1_IC1PSC_Msk: u32 = 12;
pub const TIM_CCMR1_IC1PSC: u32 = 12;
pub const TIM_CCMR1_IC1PSC_0: u32 = 4;
pub const TIM_CCMR1_IC1PSC_1: u32 = 8;
pub const TIM_CCMR1_IC1F_Pos: u32 = 4;
pub const TIM_CCMR1_IC1F_Msk: u32 = 240;
pub const TIM_CCMR1_IC1F: u32 = 240;
pub const TIM_CCMR1_IC1F_0: u32 = 16;
pub const TIM_CCMR1_IC1F_1: u32 = 32;
pub const TIM_CCMR1_IC1F_2: u32 = 64;
pub const TIM_CCMR1_IC1F_3: u32 = 128;
pub const TIM_CCMR1_IC2PSC_Pos: u32 = 10;
pub const TIM_CCMR1_IC2PSC_Msk: u32 = 3072;
pub const TIM_CCMR1_IC2PSC: u32 = 3072;
pub const TIM_CCMR1_IC2PSC_0: u32 = 1024;
pub const TIM_CCMR1_IC2PSC_1: u32 = 2048;
pub const TIM_CCMR1_IC2F_Pos: u32 = 12;
pub const TIM_CCMR1_IC2F_Msk: u32 = 61440;
pub const TIM_CCMR1_IC2F: u32 = 61440;
pub const TIM_CCMR1_IC2F_0: u32 = 4096;
pub const TIM_CCMR1_IC2F_1: u32 = 8192;
pub const TIM_CCMR1_IC2F_2: u32 = 16384;
pub const TIM_CCMR1_IC2F_3: u32 = 32768;
pub const TIM_CCMR2_CC3S_Pos: u32 = 0;
pub const TIM_CCMR2_CC3S_Msk: u32 = 3;
pub const TIM_CCMR2_CC3S: u32 = 3;
pub const TIM_CCMR2_CC3S_0: u32 = 1;
pub const TIM_CCMR2_CC3S_1: u32 = 2;
pub const TIM_CCMR2_OC3FE_Pos: u32 = 2;
pub const TIM_CCMR2_OC3FE_Msk: u32 = 4;
pub const TIM_CCMR2_OC3FE: u32 = 4;
pub const TIM_CCMR2_OC3PE_Pos: u32 = 3;
pub const TIM_CCMR2_OC3PE_Msk: u32 = 8;
pub const TIM_CCMR2_OC3PE: u32 = 8;
pub const TIM_CCMR2_OC3M_Pos: u32 = 4;
pub const TIM_CCMR2_OC3M_Msk: u32 = 65648;
pub const TIM_CCMR2_OC3M: u32 = 65648;
pub const TIM_CCMR2_OC3M_0: u32 = 16;
pub const TIM_CCMR2_OC3M_1: u32 = 32;
pub const TIM_CCMR2_OC3M_2: u32 = 64;
pub const TIM_CCMR2_OC3M_3: u32 = 65536;
pub const TIM_CCMR2_OC3CE_Pos: u32 = 7;
pub const TIM_CCMR2_OC3CE_Msk: u32 = 128;
pub const TIM_CCMR2_OC3CE: u32 = 128;
pub const TIM_CCMR2_CC4S_Pos: u32 = 8;
pub const TIM_CCMR2_CC4S_Msk: u32 = 768;
pub const TIM_CCMR2_CC4S: u32 = 768;
pub const TIM_CCMR2_CC4S_0: u32 = 256;
pub const TIM_CCMR2_CC4S_1: u32 = 512;
pub const TIM_CCMR2_OC4FE_Pos: u32 = 10;
pub const TIM_CCMR2_OC4FE_Msk: u32 = 1024;
pub const TIM_CCMR2_OC4FE: u32 = 1024;
pub const TIM_CCMR2_OC4PE_Pos: u32 = 11;
pub const TIM_CCMR2_OC4PE_Msk: u32 = 2048;
pub const TIM_CCMR2_OC4PE: u32 = 2048;
pub const TIM_CCMR2_OC4M_Pos: u32 = 12;
pub const TIM_CCMR2_OC4M_Msk: u32 = 16805888;
pub const TIM_CCMR2_OC4M: u32 = 16805888;
pub const TIM_CCMR2_OC4M_0: u32 = 4096;
pub const TIM_CCMR2_OC4M_1: u32 = 8192;
pub const TIM_CCMR2_OC4M_2: u32 = 16384;
pub const TIM_CCMR2_OC4M_3: u32 = 16777216;
pub const TIM_CCMR2_OC4CE_Pos: u32 = 15;
pub const TIM_CCMR2_OC4CE_Msk: u32 = 32768;
pub const TIM_CCMR2_OC4CE: u32 = 32768;
pub const TIM_CCMR2_IC3PSC_Pos: u32 = 2;
pub const TIM_CCMR2_IC3PSC_Msk: u32 = 12;
pub const TIM_CCMR2_IC3PSC: u32 = 12;
pub const TIM_CCMR2_IC3PSC_0: u32 = 4;
pub const TIM_CCMR2_IC3PSC_1: u32 = 8;
pub const TIM_CCMR2_IC3F_Pos: u32 = 4;
pub const TIM_CCMR2_IC3F_Msk: u32 = 240;
pub const TIM_CCMR2_IC3F: u32 = 240;
pub const TIM_CCMR2_IC3F_0: u32 = 16;
pub const TIM_CCMR2_IC3F_1: u32 = 32;
pub const TIM_CCMR2_IC3F_2: u32 = 64;
pub const TIM_CCMR2_IC3F_3: u32 = 128;
pub const TIM_CCMR2_IC4PSC_Pos: u32 = 10;
pub const TIM_CCMR2_IC4PSC_Msk: u32 = 3072;
pub const TIM_CCMR2_IC4PSC: u32 = 3072;
pub const TIM_CCMR2_IC4PSC_0: u32 = 1024;
pub const TIM_CCMR2_IC4PSC_1: u32 = 2048;
pub const TIM_CCMR2_IC4F_Pos: u32 = 12;
pub const TIM_CCMR2_IC4F_Msk: u32 = 61440;
pub const TIM_CCMR2_IC4F: u32 = 61440;
pub const TIM_CCMR2_IC4F_0: u32 = 4096;
pub const TIM_CCMR2_IC4F_1: u32 = 8192;
pub const TIM_CCMR2_IC4F_2: u32 = 16384;
pub const TIM_CCMR2_IC4F_3: u32 = 32768;
pub const TIM_CCMR3_OC5FE_Pos: u32 = 2;
pub const TIM_CCMR3_OC5FE_Msk: u32 = 4;
pub const TIM_CCMR3_OC5FE: u32 = 4;
pub const TIM_CCMR3_OC5PE_Pos: u32 = 3;
pub const TIM_CCMR3_OC5PE_Msk: u32 = 8;
pub const TIM_CCMR3_OC5PE: u32 = 8;
pub const TIM_CCMR3_OC5M_Pos: u32 = 4;
pub const TIM_CCMR3_OC5M_Msk: u32 = 65648;
pub const TIM_CCMR3_OC5M: u32 = 65648;
pub const TIM_CCMR3_OC5M_0: u32 = 16;
pub const TIM_CCMR3_OC5M_1: u32 = 32;
pub const TIM_CCMR3_OC5M_2: u32 = 64;
pub const TIM_CCMR3_OC5M_3: u32 = 65536;
pub const TIM_CCMR3_OC5CE_Pos: u32 = 7;
pub const TIM_CCMR3_OC5CE_Msk: u32 = 128;
pub const TIM_CCMR3_OC5CE: u32 = 128;
pub const TIM_CCMR3_OC6FE_Pos: u32 = 10;
pub const TIM_CCMR3_OC6FE_Msk: u32 = 1024;
pub const TIM_CCMR3_OC6FE: u32 = 1024;
pub const TIM_CCMR3_OC6PE_Pos: u32 = 11;
pub const TIM_CCMR3_OC6PE_Msk: u32 = 2048;
pub const TIM_CCMR3_OC6PE: u32 = 2048;
pub const TIM_CCMR3_OC6M_Pos: u32 = 12;
pub const TIM_CCMR3_OC6M_Msk: u32 = 16805888;
pub const TIM_CCMR3_OC6M: u32 = 16805888;
pub const TIM_CCMR3_OC6M_0: u32 = 4096;
pub const TIM_CCMR3_OC6M_1: u32 = 8192;
pub const TIM_CCMR3_OC6M_2: u32 = 16384;
pub const TIM_CCMR3_OC6M_3: u32 = 16777216;
pub const TIM_CCMR3_OC6CE_Pos: u32 = 15;
pub const TIM_CCMR3_OC6CE_Msk: u32 = 32768;
pub const TIM_CCMR3_OC6CE: u32 = 32768;
pub const TIM_CCER_CC1E_Pos: u32 = 0;
pub const TIM_CCER_CC1E_Msk: u32 = 1;
pub const TIM_CCER_CC1E: u32 = 1;
pub const TIM_CCER_CC1P_Pos: u32 = 1;
pub const TIM_CCER_CC1P_Msk: u32 = 2;
pub const TIM_CCER_CC1P: u32 = 2;
pub const TIM_CCER_CC1NE_Pos: u32 = 2;
pub const TIM_CCER_CC1NE_Msk: u32 = 4;
pub const TIM_CCER_CC1NE: u32 = 4;
pub const TIM_CCER_CC1NP_Pos: u32 = 3;
pub const TIM_CCER_CC1NP_Msk: u32 = 8;
pub const TIM_CCER_CC1NP: u32 = 8;
pub const TIM_CCER_CC2E_Pos: u32 = 4;
pub const TIM_CCER_CC2E_Msk: u32 = 16;
pub const TIM_CCER_CC2E: u32 = 16;
pub const TIM_CCER_CC2P_Pos: u32 = 5;
pub const TIM_CCER_CC2P_Msk: u32 = 32;
pub const TIM_CCER_CC2P: u32 = 32;
pub const TIM_CCER_CC2NE_Pos: u32 = 6;
pub const TIM_CCER_CC2NE_Msk: u32 = 64;
pub const TIM_CCER_CC2NE: u32 = 64;
pub const TIM_CCER_CC2NP_Pos: u32 = 7;
pub const TIM_CCER_CC2NP_Msk: u32 = 128;
pub const TIM_CCER_CC2NP: u32 = 128;
pub const TIM_CCER_CC3E_Pos: u32 = 8;
pub const TIM_CCER_CC3E_Msk: u32 = 256;
pub const TIM_CCER_CC3E: u32 = 256;
pub const TIM_CCER_CC3P_Pos: u32 = 9;
pub const TIM_CCER_CC3P_Msk: u32 = 512;
pub const TIM_CCER_CC3P: u32 = 512;
pub const TIM_CCER_CC3NE_Pos: u32 = 10;
pub const TIM_CCER_CC3NE_Msk: u32 = 1024;
pub const TIM_CCER_CC3NE: u32 = 1024;
pub const TIM_CCER_CC3NP_Pos: u32 = 11;
pub const TIM_CCER_CC3NP_Msk: u32 = 2048;
pub const TIM_CCER_CC3NP: u32 = 2048;
pub const TIM_CCER_CC4E_Pos: u32 = 12;
pub const TIM_CCER_CC4E_Msk: u32 = 4096;
pub const TIM_CCER_CC4E: u32 = 4096;
pub const TIM_CCER_CC4P_Pos: u32 = 13;
pub const TIM_CCER_CC4P_Msk: u32 = 8192;
pub const TIM_CCER_CC4P: u32 = 8192;
pub const TIM_CCER_CC4NP_Pos: u32 = 15;
pub const TIM_CCER_CC4NP_Msk: u32 = 32768;
pub const TIM_CCER_CC4NP: u32 = 32768;
pub const TIM_CCER_CC5E_Pos: u32 = 16;
pub const TIM_CCER_CC5E_Msk: u32 = 65536;
pub const TIM_CCER_CC5E: u32 = 65536;
pub const TIM_CCER_CC5P_Pos: u32 = 17;
pub const TIM_CCER_CC5P_Msk: u32 = 131072;
pub const TIM_CCER_CC5P: u32 = 131072;
pub const TIM_CCER_CC6E_Pos: u32 = 20;
pub const TIM_CCER_CC6E_Msk: u32 = 1048576;
pub const TIM_CCER_CC6E: u32 = 1048576;
pub const TIM_CCER_CC6P_Pos: u32 = 21;
pub const TIM_CCER_CC6P_Msk: u32 = 2097152;
pub const TIM_CCER_CC6P: u32 = 2097152;
pub const TIM_CNT_CNT_Pos: u32 = 0;
pub const TIM_CNT_CNT_Msk: u32 = 4294967295;
pub const TIM_CNT_CNT: u32 = 4294967295;
pub const TIM_CNT_UIFCPY_Pos: u32 = 31;
pub const TIM_CNT_UIFCPY_Msk: u32 = 2147483648;
pub const TIM_CNT_UIFCPY: u32 = 2147483648;
pub const TIM_PSC_PSC_Pos: u32 = 0;
pub const TIM_PSC_PSC_Msk: u32 = 65535;
pub const TIM_PSC_PSC: u32 = 65535;
pub const TIM_ARR_ARR_Pos: u32 = 0;
pub const TIM_ARR_ARR_Msk: u32 = 4294967295;
pub const TIM_ARR_ARR: u32 = 4294967295;
pub const TIM_RCR_REP_Pos: u32 = 0;
pub const TIM_RCR_REP_Msk: u32 = 65535;
pub const TIM_RCR_REP: u32 = 65535;
pub const TIM_CCR1_CCR1_Pos: u32 = 0;
pub const TIM_CCR1_CCR1_Msk: u32 = 65535;
pub const TIM_CCR1_CCR1: u32 = 65535;
pub const TIM_CCR2_CCR2_Pos: u32 = 0;
pub const TIM_CCR2_CCR2_Msk: u32 = 65535;
pub const TIM_CCR2_CCR2: u32 = 65535;
pub const TIM_CCR3_CCR3_Pos: u32 = 0;
pub const TIM_CCR3_CCR3_Msk: u32 = 65535;
pub const TIM_CCR3_CCR3: u32 = 65535;
pub const TIM_CCR4_CCR4_Pos: u32 = 0;
pub const TIM_CCR4_CCR4_Msk: u32 = 65535;
pub const TIM_CCR4_CCR4: u32 = 65535;
pub const TIM_CCR5_CCR5_Pos: u32 = 0;
pub const TIM_CCR5_CCR5_Msk: u32 = 4294967295;
pub const TIM_CCR5_CCR5: u32 = 4294967295;
pub const TIM_CCR5_GC5C1_Pos: u32 = 29;
pub const TIM_CCR5_GC5C1_Msk: u32 = 536870912;
pub const TIM_CCR5_GC5C1: u32 = 536870912;
pub const TIM_CCR5_GC5C2_Pos: u32 = 30;
pub const TIM_CCR5_GC5C2_Msk: u32 = 1073741824;
pub const TIM_CCR5_GC5C2: u32 = 1073741824;
pub const TIM_CCR5_GC5C3_Pos: u32 = 31;
pub const TIM_CCR5_GC5C3_Msk: u32 = 2147483648;
pub const TIM_CCR5_GC5C3: u32 = 2147483648;
pub const TIM_CCR6_CCR6_Pos: u32 = 0;
pub const TIM_CCR6_CCR6_Msk: u32 = 65535;
pub const TIM_CCR6_CCR6: u32 = 65535;
pub const TIM_BDTR_DTG_Pos: u32 = 0;
pub const TIM_BDTR_DTG_Msk: u32 = 255;
pub const TIM_BDTR_DTG: u32 = 255;
pub const TIM_BDTR_DTG_0: u32 = 1;
pub const TIM_BDTR_DTG_1: u32 = 2;
pub const TIM_BDTR_DTG_2: u32 = 4;
pub const TIM_BDTR_DTG_3: u32 = 8;
pub const TIM_BDTR_DTG_4: u32 = 16;
pub const TIM_BDTR_DTG_5: u32 = 32;
pub const TIM_BDTR_DTG_6: u32 = 64;
pub const TIM_BDTR_DTG_7: u32 = 128;
pub const TIM_BDTR_LOCK_Pos: u32 = 8;
pub const TIM_BDTR_LOCK_Msk: u32 = 768;
pub const TIM_BDTR_LOCK: u32 = 768;
pub const TIM_BDTR_LOCK_0: u32 = 256;
pub const TIM_BDTR_LOCK_1: u32 = 512;
pub const TIM_BDTR_OSSI_Pos: u32 = 10;
pub const TIM_BDTR_OSSI_Msk: u32 = 1024;
pub const TIM_BDTR_OSSI: u32 = 1024;
pub const TIM_BDTR_OSSR_Pos: u32 = 11;
pub const TIM_BDTR_OSSR_Msk: u32 = 2048;
pub const TIM_BDTR_OSSR: u32 = 2048;
pub const TIM_BDTR_BKE_Pos: u32 = 12;
pub const TIM_BDTR_BKE_Msk: u32 = 4096;
pub const TIM_BDTR_BKE: u32 = 4096;
pub const TIM_BDTR_BKP_Pos: u32 = 13;
pub const TIM_BDTR_BKP_Msk: u32 = 8192;
pub const TIM_BDTR_BKP: u32 = 8192;
pub const TIM_BDTR_AOE_Pos: u32 = 14;
pub const TIM_BDTR_AOE_Msk: u32 = 16384;
pub const TIM_BDTR_AOE: u32 = 16384;
pub const TIM_BDTR_MOE_Pos: u32 = 15;
pub const TIM_BDTR_MOE_Msk: u32 = 32768;
pub const TIM_BDTR_MOE: u32 = 32768;
pub const TIM_BDTR_BKF_Pos: u32 = 16;
pub const TIM_BDTR_BKF_Msk: u32 = 983040;
pub const TIM_BDTR_BKF: u32 = 983040;
pub const TIM_BDTR_BK2F_Pos: u32 = 20;
pub const TIM_BDTR_BK2F_Msk: u32 = 15728640;
pub const TIM_BDTR_BK2F: u32 = 15728640;
pub const TIM_BDTR_BK2E_Pos: u32 = 24;
pub const TIM_BDTR_BK2E_Msk: u32 = 16777216;
pub const TIM_BDTR_BK2E: u32 = 16777216;
pub const TIM_BDTR_BK2P_Pos: u32 = 25;
pub const TIM_BDTR_BK2P_Msk: u32 = 33554432;
pub const TIM_BDTR_BK2P: u32 = 33554432;
pub const TIM_BDTR_BKDSRM_Pos: u32 = 26;
pub const TIM_BDTR_BKDSRM_Msk: u32 = 67108864;
pub const TIM_BDTR_BKDSRM: u32 = 67108864;
pub const TIM_BDTR_BK2DSRM_Pos: u32 = 27;
pub const TIM_BDTR_BK2DSRM_Msk: u32 = 134217728;
pub const TIM_BDTR_BK2DSRM: u32 = 134217728;
pub const TIM_BDTR_BKBID_Pos: u32 = 28;
pub const TIM_BDTR_BKBID_Msk: u32 = 268435456;
pub const TIM_BDTR_BKBID: u32 = 268435456;
pub const TIM_BDTR_BK2BID_Pos: u32 = 29;
pub const TIM_BDTR_BK2BID_Msk: u32 = 536870912;
pub const TIM_BDTR_BK2BID: u32 = 536870912;
pub const TIM_DCR_DBA_Pos: u32 = 0;
pub const TIM_DCR_DBA_Msk: u32 = 31;
pub const TIM_DCR_DBA: u32 = 31;
pub const TIM_DCR_DBA_0: u32 = 1;
pub const TIM_DCR_DBA_1: u32 = 2;
pub const TIM_DCR_DBA_2: u32 = 4;
pub const TIM_DCR_DBA_3: u32 = 8;
pub const TIM_DCR_DBA_4: u32 = 16;
pub const TIM_DCR_DBL_Pos: u32 = 8;
pub const TIM_DCR_DBL_Msk: u32 = 7936;
pub const TIM_DCR_DBL: u32 = 7936;
pub const TIM_DCR_DBL_0: u32 = 256;
pub const TIM_DCR_DBL_1: u32 = 512;
pub const TIM_DCR_DBL_2: u32 = 1024;
pub const TIM_DCR_DBL_3: u32 = 2048;
pub const TIM_DCR_DBL_4: u32 = 4096;
pub const TIM_DMAR_DMAB_Pos: u32 = 0;
pub const TIM_DMAR_DMAB_Msk: u32 = 65535;
pub const TIM_DMAR_DMAB: u32 = 65535;
pub const TIM1_OR_ETR_ADC1_RMP_Pos: u32 = 0;
pub const TIM1_OR_ETR_ADC1_RMP_Msk: u32 = 3;
pub const TIM1_OR_ETR_ADC1_RMP: u32 = 3;
pub const TIM1_OR_ETR_ADC1_RMP_0: u32 = 1;
pub const TIM1_OR_ETR_ADC1_RMP_1: u32 = 2;
pub const TIM1_OR_TI1_RMP_Pos: u32 = 4;
pub const TIM1_OR_TI1_RMP_Msk: u32 = 16;
pub const TIM1_OR_TI1_RMP: u32 = 16;
pub const TIM2_OR_TI4_RMP_Pos: u32 = 2;
pub const TIM2_OR_TI4_RMP_Msk: u32 = 12;
pub const TIM2_OR_TI4_RMP: u32 = 12;
pub const TIM2_OR_TI4_RMP_0: u32 = 4;
pub const TIM2_OR_TI4_RMP_1: u32 = 8;
pub const TIM2_OR_ETR_RMP_Pos: u32 = 1;
pub const TIM2_OR_ETR_RMP_Msk: u32 = 2;
pub const TIM2_OR_ETR_RMP: u32 = 2;
pub const TIM2_OR_ITR1_RMP_Pos: u32 = 0;
pub const TIM2_OR_ITR1_RMP_Msk: u32 = 1;
pub const TIM2_OR_ITR1_RMP: u32 = 1;
pub const TIM16_OR_TI1_RMP_Pos: u32 = 0;
pub const TIM16_OR_TI1_RMP_Msk: u32 = 3;
pub const TIM16_OR_TI1_RMP: u32 = 3;
pub const TIM16_OR_TI1_RMP_0: u32 = 1;
pub const TIM16_OR_TI1_RMP_1: u32 = 2;
pub const TIM17_OR_TI1_RMP_Pos: u32 = 0;
pub const TIM17_OR_TI1_RMP_Msk: u32 = 3;
pub const TIM17_OR_TI1_RMP: u32 = 3;
pub const TIM17_OR_TI1_RMP_0: u32 = 1;
pub const TIM17_OR_TI1_RMP_1: u32 = 2;
pub const TIM1_AF1_BKINE_Pos: u32 = 0;
pub const TIM1_AF1_BKINE_Msk: u32 = 1;
pub const TIM1_AF1_BKINE: u32 = 1;
pub const TIM1_AF1_BKCMP1E_Pos: u32 = 1;
pub const TIM1_AF1_BKCMP1E_Msk: u32 = 2;
pub const TIM1_AF1_BKCMP1E: u32 = 2;
pub const TIM1_AF1_BKCMP2E_Pos: u32 = 2;
pub const TIM1_AF1_BKCMP2E_Msk: u32 = 4;
pub const TIM1_AF1_BKCMP2E: u32 = 4;
pub const TIM1_AF1_BKINP_Pos: u32 = 9;
pub const TIM1_AF1_BKINP_Msk: u32 = 512;
pub const TIM1_AF1_BKINP: u32 = 512;
pub const TIM1_AF1_BKCMP1P_Pos: u32 = 10;
pub const TIM1_AF1_BKCMP1P_Msk: u32 = 1024;
pub const TIM1_AF1_BKCMP1P: u32 = 1024;
pub const TIM1_AF1_BKCMP2P_Pos: u32 = 11;
pub const TIM1_AF1_BKCMP2P_Msk: u32 = 2048;
pub const TIM1_AF1_BKCMP2P: u32 = 2048;
pub const TIM1_AF1_ETRSEL_Pos: u32 = 14;
pub const TIM1_AF1_ETRSEL_Msk: u32 = 114688;
pub const TIM1_AF1_ETRSEL: u32 = 114688;
pub const TIM1_AF1_ETRSEL_0: u32 = 16384;
pub const TIM1_AF1_ETRSEL_1: u32 = 32768;
pub const TIM1_AF1_ETRSEL_2: u32 = 65536;
pub const TIM2_AF1_ETRSEL_Pos: u32 = 14;
pub const TIM2_AF1_ETRSEL_Msk: u32 = 114688;
pub const TIM2_AF1_ETRSEL: u32 = 114688;
pub const TIM2_AF1_ETRSEL_0: u32 = 16384;
pub const TIM2_AF1_ETRSEL_1: u32 = 32768;
pub const TIM2_AF1_ETRSEL_2: u32 = 65536;
pub const TIM16_AF1_BKINE_Pos: u32 = 0;
pub const TIM16_AF1_BKINE_Msk: u32 = 1;
pub const TIM16_AF1_BKINE: u32 = 1;
pub const TIM16_AF1_BKCMP1E_Pos: u32 = 1;
pub const TIM16_AF1_BKCMP1E_Msk: u32 = 2;
pub const TIM16_AF1_BKCMP1E: u32 = 2;
pub const TIM16_AF1_BKCMP2E_Pos: u32 = 2;
pub const TIM16_AF1_BKCMP2E_Msk: u32 = 4;
pub const TIM16_AF1_BKCMP2E: u32 = 4;
pub const TIM16_AF1_BKINP_Pos: u32 = 9;
pub const TIM16_AF1_BKINP_Msk: u32 = 512;
pub const TIM16_AF1_BKINP: u32 = 512;
pub const TIM16_AF1_BKCMP1P_Pos: u32 = 10;
pub const TIM16_AF1_BKCMP1P_Msk: u32 = 1024;
pub const TIM16_AF1_BKCMP1P: u32 = 1024;
pub const TIM16_AF1_BKCMP2P_Pos: u32 = 11;
pub const TIM16_AF1_BKCMP2P_Msk: u32 = 2048;
pub const TIM16_AF1_BKCMP2P: u32 = 2048;
pub const TIM17_AF1_BKINE_Pos: u32 = 0;
pub const TIM17_AF1_BKINE_Msk: u32 = 1;
pub const TIM17_AF1_BKINE: u32 = 1;
pub const TIM17_AF1_BKCMP1E_Pos: u32 = 1;
pub const TIM17_AF1_BKCMP1E_Msk: u32 = 2;
pub const TIM17_AF1_BKCMP1E: u32 = 2;
pub const TIM17_AF1_BKCMP2E_Pos: u32 = 2;
pub const TIM17_AF1_BKCMP2E_Msk: u32 = 4;
pub const TIM17_AF1_BKCMP2E: u32 = 4;
pub const TIM17_AF1_BKINP_Pos: u32 = 9;
pub const TIM17_AF1_BKINP_Msk: u32 = 512;
pub const TIM17_AF1_BKINP: u32 = 512;
pub const TIM17_AF1_BKCMP1P_Pos: u32 = 10;
pub const TIM17_AF1_BKCMP1P_Msk: u32 = 1024;
pub const TIM17_AF1_BKCMP1P: u32 = 1024;
pub const TIM17_AF1_BKCMP2P_Pos: u32 = 11;
pub const TIM17_AF1_BKCMP2P_Msk: u32 = 2048;
pub const TIM17_AF1_BKCMP2P: u32 = 2048;
pub const TIM1_AF2_BK2INE_Pos: u32 = 0;
pub const TIM1_AF2_BK2INE_Msk: u32 = 1;
pub const TIM1_AF2_BK2INE: u32 = 1;
pub const TIM1_AF2_BK2CMP1E_Pos: u32 = 1;
pub const TIM1_AF2_BK2CMP1E_Msk: u32 = 2;
pub const TIM1_AF2_BK2CMP1E: u32 = 2;
pub const TIM1_AF2_BK2CMP2E_Pos: u32 = 2;
pub const TIM1_AF2_BK2CMP2E_Msk: u32 = 4;
pub const TIM1_AF2_BK2CMP2E: u32 = 4;
pub const TIM1_AF2_BK2INP_Pos: u32 = 9;
pub const TIM1_AF2_BK2INP_Msk: u32 = 512;
pub const TIM1_AF2_BK2INP: u32 = 512;
pub const TIM1_AF2_BK2CMP1P_Pos: u32 = 10;
pub const TIM1_AF2_BK2CMP1P_Msk: u32 = 1024;
pub const TIM1_AF2_BK2CMP1P: u32 = 1024;
pub const TIM1_AF2_BK2CMP2P_Pos: u32 = 11;
pub const TIM1_AF2_BK2CMP2P_Msk: u32 = 2048;
pub const TIM1_AF2_BK2CMP2P: u32 = 2048;
pub const LPTIM_ISR_CMPM_Pos: u32 = 0;
pub const LPTIM_ISR_CMPM_Msk: u32 = 1;
pub const LPTIM_ISR_CMPM: u32 = 1;
pub const LPTIM_ISR_ARRM_Pos: u32 = 1;
pub const LPTIM_ISR_ARRM_Msk: u32 = 2;
pub const LPTIM_ISR_ARRM: u32 = 2;
pub const LPTIM_ISR_EXTTRIG_Pos: u32 = 2;
pub const LPTIM_ISR_EXTTRIG_Msk: u32 = 4;
pub const LPTIM_ISR_EXTTRIG: u32 = 4;
pub const LPTIM_ISR_CMPOK_Pos: u32 = 3;
pub const LPTIM_ISR_CMPOK_Msk: u32 = 8;
pub const LPTIM_ISR_CMPOK: u32 = 8;
pub const LPTIM_ISR_ARROK_Pos: u32 = 4;
pub const LPTIM_ISR_ARROK_Msk: u32 = 16;
pub const LPTIM_ISR_ARROK: u32 = 16;
pub const LPTIM_ISR_UP_Pos: u32 = 5;
pub const LPTIM_ISR_UP_Msk: u32 = 32;
pub const LPTIM_ISR_UP: u32 = 32;
pub const LPTIM_ISR_DOWN_Pos: u32 = 6;
pub const LPTIM_ISR_DOWN_Msk: u32 = 64;
pub const LPTIM_ISR_DOWN: u32 = 64;
pub const LPTIM_ICR_CMPMCF_Pos: u32 = 0;
pub const LPTIM_ICR_CMPMCF_Msk: u32 = 1;
pub const LPTIM_ICR_CMPMCF: u32 = 1;
pub const LPTIM_ICR_ARRMCF_Pos: u32 = 1;
pub const LPTIM_ICR_ARRMCF_Msk: u32 = 2;
pub const LPTIM_ICR_ARRMCF: u32 = 2;
pub const LPTIM_ICR_EXTTRIGCF_Pos: u32 = 2;
pub const LPTIM_ICR_EXTTRIGCF_Msk: u32 = 4;
pub const LPTIM_ICR_EXTTRIGCF: u32 = 4;
pub const LPTIM_ICR_CMPOKCF_Pos: u32 = 3;
pub const LPTIM_ICR_CMPOKCF_Msk: u32 = 8;
pub const LPTIM_ICR_CMPOKCF: u32 = 8;
pub const LPTIM_ICR_ARROKCF_Pos: u32 = 4;
pub const LPTIM_ICR_ARROKCF_Msk: u32 = 16;
pub const LPTIM_ICR_ARROKCF: u32 = 16;
pub const LPTIM_ICR_UPCF_Pos: u32 = 5;
pub const LPTIM_ICR_UPCF_Msk: u32 = 32;
pub const LPTIM_ICR_UPCF: u32 = 32;
pub const LPTIM_ICR_DOWNCF_Pos: u32 = 6;
pub const LPTIM_ICR_DOWNCF_Msk: u32 = 64;
pub const LPTIM_ICR_DOWNCF: u32 = 64;
pub const LPTIM_IER_CMPMIE_Pos: u32 = 0;
pub const LPTIM_IER_CMPMIE_Msk: u32 = 1;
pub const LPTIM_IER_CMPMIE: u32 = 1;
pub const LPTIM_IER_ARRMIE_Pos: u32 = 1;
pub const LPTIM_IER_ARRMIE_Msk: u32 = 2;
pub const LPTIM_IER_ARRMIE: u32 = 2;
pub const LPTIM_IER_EXTTRIGIE_Pos: u32 = 2;
pub const LPTIM_IER_EXTTRIGIE_Msk: u32 = 4;
pub const LPTIM_IER_EXTTRIGIE: u32 = 4;
pub const LPTIM_IER_CMPOKIE_Pos: u32 = 3;
pub const LPTIM_IER_CMPOKIE_Msk: u32 = 8;
pub const LPTIM_IER_CMPOKIE: u32 = 8;
pub const LPTIM_IER_ARROKIE_Pos: u32 = 4;
pub const LPTIM_IER_ARROKIE_Msk: u32 = 16;
pub const LPTIM_IER_ARROKIE: u32 = 16;
pub const LPTIM_IER_UPIE_Pos: u32 = 5;
pub const LPTIM_IER_UPIE_Msk: u32 = 32;
pub const LPTIM_IER_UPIE: u32 = 32;
pub const LPTIM_IER_DOWNIE_Pos: u32 = 6;
pub const LPTIM_IER_DOWNIE_Msk: u32 = 64;
pub const LPTIM_IER_DOWNIE: u32 = 64;
pub const LPTIM_CFGR_CKSEL_Pos: u32 = 0;
pub const LPTIM_CFGR_CKSEL_Msk: u32 = 1;
pub const LPTIM_CFGR_CKSEL: u32 = 1;
pub const LPTIM_CFGR_CKPOL_Pos: u32 = 1;
pub const LPTIM_CFGR_CKPOL_Msk: u32 = 6;
pub const LPTIM_CFGR_CKPOL: u32 = 6;
pub const LPTIM_CFGR_CKPOL_0: u32 = 2;
pub const LPTIM_CFGR_CKPOL_1: u32 = 4;
pub const LPTIM_CFGR_CKFLT_Pos: u32 = 3;
pub const LPTIM_CFGR_CKFLT_Msk: u32 = 24;
pub const LPTIM_CFGR_CKFLT: u32 = 24;
pub const LPTIM_CFGR_CKFLT_0: u32 = 8;
pub const LPTIM_CFGR_CKFLT_1: u32 = 16;
pub const LPTIM_CFGR_TRGFLT_Pos: u32 = 6;
pub const LPTIM_CFGR_TRGFLT_Msk: u32 = 192;
pub const LPTIM_CFGR_TRGFLT: u32 = 192;
pub const LPTIM_CFGR_TRGFLT_0: u32 = 64;
pub const LPTIM_CFGR_TRGFLT_1: u32 = 128;
pub const LPTIM_CFGR_PRESC_Pos: u32 = 9;
pub const LPTIM_CFGR_PRESC_Msk: u32 = 3584;
pub const LPTIM_CFGR_PRESC: u32 = 3584;
pub const LPTIM_CFGR_PRESC_0: u32 = 512;
pub const LPTIM_CFGR_PRESC_1: u32 = 1024;
pub const LPTIM_CFGR_PRESC_2: u32 = 2048;
pub const LPTIM_CFGR_TRIGSEL_Pos: u32 = 13;
pub const LPTIM_CFGR_TRIGSEL_Msk: u32 = 57344;
pub const LPTIM_CFGR_TRIGSEL: u32 = 57344;
pub const LPTIM_CFGR_TRIGSEL_0: u32 = 8192;
pub const LPTIM_CFGR_TRIGSEL_1: u32 = 16384;
pub const LPTIM_CFGR_TRIGSEL_2: u32 = 32768;
pub const LPTIM_CFGR_TRIGEN_Pos: u32 = 17;
pub const LPTIM_CFGR_TRIGEN_Msk: u32 = 393216;
pub const LPTIM_CFGR_TRIGEN: u32 = 393216;
pub const LPTIM_CFGR_TRIGEN_0: u32 = 131072;
pub const LPTIM_CFGR_TRIGEN_1: u32 = 262144;
pub const LPTIM_CFGR_TIMOUT_Pos: u32 = 19;
pub const LPTIM_CFGR_TIMOUT_Msk: u32 = 524288;
pub const LPTIM_CFGR_TIMOUT: u32 = 524288;
pub const LPTIM_CFGR_WAVE_Pos: u32 = 20;
pub const LPTIM_CFGR_WAVE_Msk: u32 = 1048576;
pub const LPTIM_CFGR_WAVE: u32 = 1048576;
pub const LPTIM_CFGR_WAVPOL_Pos: u32 = 21;
pub const LPTIM_CFGR_WAVPOL_Msk: u32 = 2097152;
pub const LPTIM_CFGR_WAVPOL: u32 = 2097152;
pub const LPTIM_CFGR_PRELOAD_Pos: u32 = 22;
pub const LPTIM_CFGR_PRELOAD_Msk: u32 = 4194304;
pub const LPTIM_CFGR_PRELOAD: u32 = 4194304;
pub const LPTIM_CFGR_COUNTMODE_Pos: u32 = 23;
pub const LPTIM_CFGR_COUNTMODE_Msk: u32 = 8388608;
pub const LPTIM_CFGR_COUNTMODE: u32 = 8388608;
pub const LPTIM_CFGR_ENC_Pos: u32 = 24;
pub const LPTIM_CFGR_ENC_Msk: u32 = 16777216;
pub const LPTIM_CFGR_ENC: u32 = 16777216;
pub const LPTIM_CR_ENABLE_Pos: u32 = 0;
pub const LPTIM_CR_ENABLE_Msk: u32 = 1;
pub const LPTIM_CR_ENABLE: u32 = 1;
pub const LPTIM_CR_SNGSTRT_Pos: u32 = 1;
pub const LPTIM_CR_SNGSTRT_Msk: u32 = 2;
pub const LPTIM_CR_SNGSTRT: u32 = 2;
pub const LPTIM_CR_CNTSTRT_Pos: u32 = 2;
pub const LPTIM_CR_CNTSTRT_Msk: u32 = 4;
pub const LPTIM_CR_CNTSTRT: u32 = 4;
pub const LPTIM_CR_COUNTRST_Pos: u32 = 3;
pub const LPTIM_CR_COUNTRST_Msk: u32 = 8;
pub const LPTIM_CR_COUNTRST: u32 = 8;
pub const LPTIM_CR_RSTARE_Pos: u32 = 4;
pub const LPTIM_CR_RSTARE_Msk: u32 = 16;
pub const LPTIM_CR_RSTARE: u32 = 16;
pub const LPTIM_CMP_CMP_Pos: u32 = 0;
pub const LPTIM_CMP_CMP_Msk: u32 = 65535;
pub const LPTIM_CMP_CMP: u32 = 65535;
pub const LPTIM_ARR_ARR_Pos: u32 = 0;
pub const LPTIM_ARR_ARR_Msk: u32 = 65535;
pub const LPTIM_ARR_ARR: u32 = 65535;
pub const LPTIM_CNT_CNT_Pos: u32 = 0;
pub const LPTIM_CNT_CNT_Msk: u32 = 65535;
pub const LPTIM_CNT_CNT: u32 = 65535;
pub const LPTIM_OR_OR_Pos: u32 = 0;
pub const LPTIM_OR_OR_Msk: u32 = 3;
pub const LPTIM_OR_OR: u32 = 3;
pub const LPTIM_OR_OR_0: u32 = 1;
pub const LPTIM_OR_OR_1: u32 = 2;
pub const IPCC_C1CR_RXOIE_Pos: u32 = 0;
pub const IPCC_C1CR_RXOIE_Msk: u32 = 1;
pub const IPCC_C1CR_RXOIE: u32 = 1;
pub const IPCC_C1CR_TXFIE_Pos: u32 = 16;
pub const IPCC_C1CR_TXFIE_Msk: u32 = 65536;
pub const IPCC_C1CR_TXFIE: u32 = 65536;
pub const IPCC_C1MR_CH1OM_Pos: u32 = 0;
pub const IPCC_C1MR_CH1OM_Msk: u32 = 1;
pub const IPCC_C1MR_CH1OM: u32 = 1;
pub const IPCC_C1MR_CH2OM_Pos: u32 = 1;
pub const IPCC_C1MR_CH2OM_Msk: u32 = 2;
pub const IPCC_C1MR_CH2OM: u32 = 2;
pub const IPCC_C1MR_CH3OM_Pos: u32 = 2;
pub const IPCC_C1MR_CH3OM_Msk: u32 = 4;
pub const IPCC_C1MR_CH3OM: u32 = 4;
pub const IPCC_C1MR_CH4OM_Pos: u32 = 3;
pub const IPCC_C1MR_CH4OM_Msk: u32 = 8;
pub const IPCC_C1MR_CH4OM: u32 = 8;
pub const IPCC_C1MR_CH5OM_Pos: u32 = 4;
pub const IPCC_C1MR_CH5OM_Msk: u32 = 16;
pub const IPCC_C1MR_CH5OM: u32 = 16;
pub const IPCC_C1MR_CH6OM_Pos: u32 = 5;
pub const IPCC_C1MR_CH6OM_Msk: u32 = 32;
pub const IPCC_C1MR_CH6OM: u32 = 32;
pub const IPCC_C1MR_CH1FM_Pos: u32 = 16;
pub const IPCC_C1MR_CH1FM_Msk: u32 = 65536;
pub const IPCC_C1MR_CH1FM: u32 = 65536;
pub const IPCC_C1MR_CH2FM_Pos: u32 = 17;
pub const IPCC_C1MR_CH2FM_Msk: u32 = 131072;
pub const IPCC_C1MR_CH2FM: u32 = 131072;
pub const IPCC_C1MR_CH3FM_Pos: u32 = 18;
pub const IPCC_C1MR_CH3FM_Msk: u32 = 262144;
pub const IPCC_C1MR_CH3FM: u32 = 262144;
pub const IPCC_C1MR_CH4FM_Pos: u32 = 19;
pub const IPCC_C1MR_CH4FM_Msk: u32 = 524288;
pub const IPCC_C1MR_CH4FM: u32 = 524288;
pub const IPCC_C1MR_CH5FM_Pos: u32 = 20;
pub const IPCC_C1MR_CH5FM_Msk: u32 = 1048576;
pub const IPCC_C1MR_CH5FM: u32 = 1048576;
pub const IPCC_C1MR_CH6FM_Pos: u32 = 21;
pub const IPCC_C1MR_CH6FM_Msk: u32 = 2097152;
pub const IPCC_C1MR_CH6FM: u32 = 2097152;
pub const IPCC_C1SCR_CH1C_Pos: u32 = 0;
pub const IPCC_C1SCR_CH1C_Msk: u32 = 1;
pub const IPCC_C1SCR_CH1C: u32 = 1;
pub const IPCC_C1SCR_CH2C_Pos: u32 = 1;
pub const IPCC_C1SCR_CH2C_Msk: u32 = 2;
pub const IPCC_C1SCR_CH2C: u32 = 2;
pub const IPCC_C1SCR_CH3C_Pos: u32 = 2;
pub const IPCC_C1SCR_CH3C_Msk: u32 = 4;
pub const IPCC_C1SCR_CH3C: u32 = 4;
pub const IPCC_C1SCR_CH4C_Pos: u32 = 3;
pub const IPCC_C1SCR_CH4C_Msk: u32 = 8;
pub const IPCC_C1SCR_CH4C: u32 = 8;
pub const IPCC_C1SCR_CH5C_Pos: u32 = 4;
pub const IPCC_C1SCR_CH5C_Msk: u32 = 16;
pub const IPCC_C1SCR_CH5C: u32 = 16;
pub const IPCC_C1SCR_CH6C_Pos: u32 = 5;
pub const IPCC_C1SCR_CH6C_Msk: u32 = 32;
pub const IPCC_C1SCR_CH6C: u32 = 32;
pub const IPCC_C1SCR_CH1S_Pos: u32 = 16;
pub const IPCC_C1SCR_CH1S_Msk: u32 = 65536;
pub const IPCC_C1SCR_CH1S: u32 = 65536;
pub const IPCC_C1SCR_CH2S_Pos: u32 = 17;
pub const IPCC_C1SCR_CH2S_Msk: u32 = 131072;
pub const IPCC_C1SCR_CH2S: u32 = 131072;
pub const IPCC_C1SCR_CH3S_Pos: u32 = 18;
pub const IPCC_C1SCR_CH3S_Msk: u32 = 262144;
pub const IPCC_C1SCR_CH3S: u32 = 262144;
pub const IPCC_C1SCR_CH4S_Pos: u32 = 19;
pub const IPCC_C1SCR_CH4S_Msk: u32 = 524288;
pub const IPCC_C1SCR_CH4S: u32 = 524288;
pub const IPCC_C1SCR_CH5S_Pos: u32 = 20;
pub const IPCC_C1SCR_CH5S_Msk: u32 = 1048576;
pub const IPCC_C1SCR_CH5S: u32 = 1048576;
pub const IPCC_C1SCR_CH6S_Pos: u32 = 21;
pub const IPCC_C1SCR_CH6S_Msk: u32 = 2097152;
pub const IPCC_C1SCR_CH6S: u32 = 2097152;
pub const IPCC_C1TOC2SR_CH1F_Pos: u32 = 0;
pub const IPCC_C1TOC2SR_CH1F_Msk: u32 = 1;
pub const IPCC_C1TOC2SR_CH1F: u32 = 1;
pub const IPCC_C1TOC2SR_CH2F_Pos: u32 = 1;
pub const IPCC_C1TOC2SR_CH2F_Msk: u32 = 2;
pub const IPCC_C1TOC2SR_CH2F: u32 = 2;
pub const IPCC_C1TOC2SR_CH3F_Pos: u32 = 2;
pub const IPCC_C1TOC2SR_CH3F_Msk: u32 = 4;
pub const IPCC_C1TOC2SR_CH3F: u32 = 4;
pub const IPCC_C1TOC2SR_CH4F_Pos: u32 = 3;
pub const IPCC_C1TOC2SR_CH4F_Msk: u32 = 8;
pub const IPCC_C1TOC2SR_CH4F: u32 = 8;
pub const IPCC_C1TOC2SR_CH5F_Pos: u32 = 4;
pub const IPCC_C1TOC2SR_CH5F_Msk: u32 = 16;
pub const IPCC_C1TOC2SR_CH5F: u32 = 16;
pub const IPCC_C1TOC2SR_CH6F_Pos: u32 = 5;
pub const IPCC_C1TOC2SR_CH6F_Msk: u32 = 32;
pub const IPCC_C1TOC2SR_CH6F: u32 = 32;
pub const IPCC_C2CR_RXOIE_Pos: u32 = 0;
pub const IPCC_C2CR_RXOIE_Msk: u32 = 1;
pub const IPCC_C2CR_RXOIE: u32 = 1;
pub const IPCC_C2CR_TXFIE_Pos: u32 = 16;
pub const IPCC_C2CR_TXFIE_Msk: u32 = 65536;
pub const IPCC_C2CR_TXFIE: u32 = 65536;
pub const IPCC_C2MR_CH1OM_Pos: u32 = 0;
pub const IPCC_C2MR_CH1OM_Msk: u32 = 1;
pub const IPCC_C2MR_CH1OM: u32 = 1;
pub const IPCC_C2MR_CH2OM_Pos: u32 = 1;
pub const IPCC_C2MR_CH2OM_Msk: u32 = 2;
pub const IPCC_C2MR_CH2OM: u32 = 2;
pub const IPCC_C2MR_CH3OM_Pos: u32 = 2;
pub const IPCC_C2MR_CH3OM_Msk: u32 = 4;
pub const IPCC_C2MR_CH3OM: u32 = 4;
pub const IPCC_C2MR_CH4OM_Pos: u32 = 3;
pub const IPCC_C2MR_CH4OM_Msk: u32 = 8;
pub const IPCC_C2MR_CH4OM: u32 = 8;
pub const IPCC_C2MR_CH5OM_Pos: u32 = 4;
pub const IPCC_C2MR_CH5OM_Msk: u32 = 16;
pub const IPCC_C2MR_CH5OM: u32 = 16;
pub const IPCC_C2MR_CH6OM_Pos: u32 = 5;
pub const IPCC_C2MR_CH6OM_Msk: u32 = 32;
pub const IPCC_C2MR_CH6OM: u32 = 32;
pub const IPCC_C2MR_CH1FM_Pos: u32 = 16;
pub const IPCC_C2MR_CH1FM_Msk: u32 = 65536;
pub const IPCC_C2MR_CH1FM: u32 = 65536;
pub const IPCC_C2MR_CH2FM_Pos: u32 = 17;
pub const IPCC_C2MR_CH2FM_Msk: u32 = 131072;
pub const IPCC_C2MR_CH2FM: u32 = 131072;
pub const IPCC_C2MR_CH3FM_Pos: u32 = 18;
pub const IPCC_C2MR_CH3FM_Msk: u32 = 262144;
pub const IPCC_C2MR_CH3FM: u32 = 262144;
pub const IPCC_C2MR_CH4FM_Pos: u32 = 19;
pub const IPCC_C2MR_CH4FM_Msk: u32 = 524288;
pub const IPCC_C2MR_CH4FM: u32 = 524288;
pub const IPCC_C2MR_CH5FM_Pos: u32 = 20;
pub const IPCC_C2MR_CH5FM_Msk: u32 = 1048576;
pub const IPCC_C2MR_CH5FM: u32 = 1048576;
pub const IPCC_C2MR_CH6FM_Pos: u32 = 21;
pub const IPCC_C2MR_CH6FM_Msk: u32 = 2097152;
pub const IPCC_C2MR_CH6FM: u32 = 2097152;
pub const IPCC_C2SCR_CH1C_Pos: u32 = 0;
pub const IPCC_C2SCR_CH1C_Msk: u32 = 1;
pub const IPCC_C2SCR_CH1C: u32 = 1;
pub const IPCC_C2SCR_CH2C_Pos: u32 = 1;
pub const IPCC_C2SCR_CH2C_Msk: u32 = 2;
pub const IPCC_C2SCR_CH2C: u32 = 2;
pub const IPCC_C2SCR_CH3C_Pos: u32 = 2;
pub const IPCC_C2SCR_CH3C_Msk: u32 = 4;
pub const IPCC_C2SCR_CH3C: u32 = 4;
pub const IPCC_C2SCR_CH4C_Pos: u32 = 3;
pub const IPCC_C2SCR_CH4C_Msk: u32 = 8;
pub const IPCC_C2SCR_CH4C: u32 = 8;
pub const IPCC_C2SCR_CH5C_Pos: u32 = 4;
pub const IPCC_C2SCR_CH5C_Msk: u32 = 16;
pub const IPCC_C2SCR_CH5C: u32 = 16;
pub const IPCC_C2SCR_CH6C_Pos: u32 = 5;
pub const IPCC_C2SCR_CH6C_Msk: u32 = 32;
pub const IPCC_C2SCR_CH6C: u32 = 32;
pub const IPCC_C2SCR_CH1S_Pos: u32 = 16;
pub const IPCC_C2SCR_CH1S_Msk: u32 = 65536;
pub const IPCC_C2SCR_CH1S: u32 = 65536;
pub const IPCC_C2SCR_CH2S_Pos: u32 = 17;
pub const IPCC_C2SCR_CH2S_Msk: u32 = 131072;
pub const IPCC_C2SCR_CH2S: u32 = 131072;
pub const IPCC_C2SCR_CH3S_Pos: u32 = 18;
pub const IPCC_C2SCR_CH3S_Msk: u32 = 262144;
pub const IPCC_C2SCR_CH3S: u32 = 262144;
pub const IPCC_C2SCR_CH4S_Pos: u32 = 19;
pub const IPCC_C2SCR_CH4S_Msk: u32 = 524288;
pub const IPCC_C2SCR_CH4S: u32 = 524288;
pub const IPCC_C2SCR_CH5S_Pos: u32 = 20;
pub const IPCC_C2SCR_CH5S_Msk: u32 = 1048576;
pub const IPCC_C2SCR_CH5S: u32 = 1048576;
pub const IPCC_C2SCR_CH6S_Pos: u32 = 21;
pub const IPCC_C2SCR_CH6S_Msk: u32 = 2097152;
pub const IPCC_C2SCR_CH6S: u32 = 2097152;
pub const IPCC_C2TOC1SR_CH1F_Pos: u32 = 0;
pub const IPCC_C2TOC1SR_CH1F_Msk: u32 = 1;
pub const IPCC_C2TOC1SR_CH1F: u32 = 1;
pub const IPCC_C2TOC1SR_CH2F_Pos: u32 = 1;
pub const IPCC_C2TOC1SR_CH2F_Msk: u32 = 2;
pub const IPCC_C2TOC1SR_CH2F: u32 = 2;
pub const IPCC_C2TOC1SR_CH3F_Pos: u32 = 2;
pub const IPCC_C2TOC1SR_CH3F_Msk: u32 = 4;
pub const IPCC_C2TOC1SR_CH3F: u32 = 4;
pub const IPCC_C2TOC1SR_CH4F_Pos: u32 = 3;
pub const IPCC_C2TOC1SR_CH4F_Msk: u32 = 8;
pub const IPCC_C2TOC1SR_CH4F: u32 = 8;
pub const IPCC_C2TOC1SR_CH5F_Pos: u32 = 4;
pub const IPCC_C2TOC1SR_CH5F_Msk: u32 = 16;
pub const IPCC_C2TOC1SR_CH5F: u32 = 16;
pub const IPCC_C2TOC1SR_CH6F_Pos: u32 = 5;
pub const IPCC_C2TOC1SR_CH6F_Msk: u32 = 32;
pub const IPCC_C2TOC1SR_CH6F: u32 = 32;
pub const IPCC_CR_RXOIE_Pos: u32 = 0;
pub const IPCC_CR_RXOIE_Msk: u32 = 1;
pub const IPCC_CR_RXOIE: u32 = 1;
pub const IPCC_CR_TXFIE_Pos: u32 = 16;
pub const IPCC_CR_TXFIE_Msk: u32 = 65536;
pub const IPCC_CR_TXFIE: u32 = 65536;
pub const IPCC_MR_CH1OM_Pos: u32 = 0;
pub const IPCC_MR_CH1OM_Msk: u32 = 1;
pub const IPCC_MR_CH1OM: u32 = 1;
pub const IPCC_MR_CH2OM_Pos: u32 = 1;
pub const IPCC_MR_CH2OM_Msk: u32 = 2;
pub const IPCC_MR_CH2OM: u32 = 2;
pub const IPCC_MR_CH3OM_Pos: u32 = 2;
pub const IPCC_MR_CH3OM_Msk: u32 = 4;
pub const IPCC_MR_CH3OM: u32 = 4;
pub const IPCC_MR_CH4OM_Pos: u32 = 3;
pub const IPCC_MR_CH4OM_Msk: u32 = 8;
pub const IPCC_MR_CH4OM: u32 = 8;
pub const IPCC_MR_CH5OM_Pos: u32 = 4;
pub const IPCC_MR_CH5OM_Msk: u32 = 16;
pub const IPCC_MR_CH5OM: u32 = 16;
pub const IPCC_MR_CH6OM_Pos: u32 = 5;
pub const IPCC_MR_CH6OM_Msk: u32 = 32;
pub const IPCC_MR_CH6OM: u32 = 32;
pub const IPCC_MR_CH1FM_Pos: u32 = 16;
pub const IPCC_MR_CH1FM_Msk: u32 = 65536;
pub const IPCC_MR_CH1FM: u32 = 65536;
pub const IPCC_MR_CH2FM_Pos: u32 = 17;
pub const IPCC_MR_CH2FM_Msk: u32 = 131072;
pub const IPCC_MR_CH2FM: u32 = 131072;
pub const IPCC_MR_CH3FM_Pos: u32 = 18;
pub const IPCC_MR_CH3FM_Msk: u32 = 262144;
pub const IPCC_MR_CH3FM: u32 = 262144;
pub const IPCC_MR_CH4FM_Pos: u32 = 19;
pub const IPCC_MR_CH4FM_Msk: u32 = 524288;
pub const IPCC_MR_CH4FM: u32 = 524288;
pub const IPCC_MR_CH5FM_Pos: u32 = 20;
pub const IPCC_MR_CH5FM_Msk: u32 = 1048576;
pub const IPCC_MR_CH5FM: u32 = 1048576;
pub const IPCC_MR_CH6FM_Pos: u32 = 21;
pub const IPCC_MR_CH6FM_Msk: u32 = 2097152;
pub const IPCC_MR_CH6FM: u32 = 2097152;
pub const IPCC_SCR_CH1C_Pos: u32 = 0;
pub const IPCC_SCR_CH1C_Msk: u32 = 1;
pub const IPCC_SCR_CH1C: u32 = 1;
pub const IPCC_SCR_CH2C_Pos: u32 = 1;
pub const IPCC_SCR_CH2C_Msk: u32 = 2;
pub const IPCC_SCR_CH2C: u32 = 2;
pub const IPCC_SCR_CH3C_Pos: u32 = 2;
pub const IPCC_SCR_CH3C_Msk: u32 = 4;
pub const IPCC_SCR_CH3C: u32 = 4;
pub const IPCC_SCR_CH4C_Pos: u32 = 3;
pub const IPCC_SCR_CH4C_Msk: u32 = 8;
pub const IPCC_SCR_CH4C: u32 = 8;
pub const IPCC_SCR_CH5C_Pos: u32 = 4;
pub const IPCC_SCR_CH5C_Msk: u32 = 16;
pub const IPCC_SCR_CH5C: u32 = 16;
pub const IPCC_SCR_CH6C_Pos: u32 = 5;
pub const IPCC_SCR_CH6C_Msk: u32 = 32;
pub const IPCC_SCR_CH6C: u32 = 32;
pub const IPCC_SCR_CH1S_Pos: u32 = 16;
pub const IPCC_SCR_CH1S_Msk: u32 = 65536;
pub const IPCC_SCR_CH1S: u32 = 65536;
pub const IPCC_SCR_CH2S_Pos: u32 = 17;
pub const IPCC_SCR_CH2S_Msk: u32 = 131072;
pub const IPCC_SCR_CH2S: u32 = 131072;
pub const IPCC_SCR_CH3S_Pos: u32 = 18;
pub const IPCC_SCR_CH3S_Msk: u32 = 262144;
pub const IPCC_SCR_CH3S: u32 = 262144;
pub const IPCC_SCR_CH4S_Pos: u32 = 19;
pub const IPCC_SCR_CH4S_Msk: u32 = 524288;
pub const IPCC_SCR_CH4S: u32 = 524288;
pub const IPCC_SCR_CH5S_Pos: u32 = 20;
pub const IPCC_SCR_CH5S_Msk: u32 = 1048576;
pub const IPCC_SCR_CH5S: u32 = 1048576;
pub const IPCC_SCR_CH6S_Pos: u32 = 21;
pub const IPCC_SCR_CH6S_Msk: u32 = 2097152;
pub const IPCC_SCR_CH6S: u32 = 2097152;
pub const IPCC_SR_CH1F_Pos: u32 = 0;
pub const IPCC_SR_CH1F_Msk: u32 = 1;
pub const IPCC_SR_CH1F: u32 = 1;
pub const IPCC_SR_CH2F_Pos: u32 = 1;
pub const IPCC_SR_CH2F_Msk: u32 = 2;
pub const IPCC_SR_CH2F: u32 = 2;
pub const IPCC_SR_CH3F_Pos: u32 = 2;
pub const IPCC_SR_CH3F_Msk: u32 = 4;
pub const IPCC_SR_CH3F: u32 = 4;
pub const IPCC_SR_CH4F_Pos: u32 = 3;
pub const IPCC_SR_CH4F_Msk: u32 = 8;
pub const IPCC_SR_CH4F: u32 = 8;
pub const IPCC_SR_CH5F_Pos: u32 = 4;
pub const IPCC_SR_CH5F_Msk: u32 = 16;
pub const IPCC_SR_CH5F: u32 = 16;
pub const IPCC_SR_CH6F_Pos: u32 = 5;
pub const IPCC_SR_CH6F_Msk: u32 = 32;
pub const IPCC_SR_CH6F: u32 = 32;
pub const IPCC_CHANNEL_NUMBER: u32 = 6;
pub const USART_CR1_UE_Pos: u32 = 0;
pub const USART_CR1_UE_Msk: u32 = 1;
pub const USART_CR1_UE: u32 = 1;
pub const USART_CR1_UESM_Pos: u32 = 1;
pub const USART_CR1_UESM_Msk: u32 = 2;
pub const USART_CR1_UESM: u32 = 2;
pub const USART_CR1_RE_Pos: u32 = 2;
pub const USART_CR1_RE_Msk: u32 = 4;
pub const USART_CR1_RE: u32 = 4;
pub const USART_CR1_TE_Pos: u32 = 3;
pub const USART_CR1_TE_Msk: u32 = 8;
pub const USART_CR1_TE: u32 = 8;
pub const USART_CR1_IDLEIE_Pos: u32 = 4;
pub const USART_CR1_IDLEIE_Msk: u32 = 16;
pub const USART_CR1_IDLEIE: u32 = 16;
pub const USART_CR1_RXNEIE_Pos: u32 = 5;
pub const USART_CR1_RXNEIE_Msk: u32 = 32;
pub const USART_CR1_RXNEIE: u32 = 32;
pub const USART_CR1_RXNEIE_RXFNEIE_Pos: u32 = 5;
pub const USART_CR1_RXNEIE_RXFNEIE_Msk: u32 = 32;
pub const USART_CR1_RXNEIE_RXFNEIE: u32 = 32;
pub const USART_CR1_TCIE_Pos: u32 = 6;
pub const USART_CR1_TCIE_Msk: u32 = 64;
pub const USART_CR1_TCIE: u32 = 64;
pub const USART_CR1_TXEIE_Pos: u32 = 7;
pub const USART_CR1_TXEIE_Msk: u32 = 128;
pub const USART_CR1_TXEIE: u32 = 128;
pub const USART_CR1_TXEIE_TXFNFIE_Pos: u32 = 7;
pub const USART_CR1_TXEIE_TXFNFIE_Msk: u32 = 128;
pub const USART_CR1_TXEIE_TXFNFIE: u32 = 128;
pub const USART_CR1_PEIE_Pos: u32 = 8;
pub const USART_CR1_PEIE_Msk: u32 = 256;
pub const USART_CR1_PEIE: u32 = 256;
pub const USART_CR1_PS_Pos: u32 = 9;
pub const USART_CR1_PS_Msk: u32 = 512;
pub const USART_CR1_PS: u32 = 512;
pub const USART_CR1_PCE_Pos: u32 = 10;
pub const USART_CR1_PCE_Msk: u32 = 1024;
pub const USART_CR1_PCE: u32 = 1024;
pub const USART_CR1_WAKE_Pos: u32 = 11;
pub const USART_CR1_WAKE_Msk: u32 = 2048;
pub const USART_CR1_WAKE: u32 = 2048;
pub const USART_CR1_M0_Pos: u32 = 12;
pub const USART_CR1_M0_Msk: u32 = 4096;
pub const USART_CR1_M0: u32 = 4096;
pub const USART_CR1_MME_Pos: u32 = 13;
pub const USART_CR1_MME_Msk: u32 = 8192;
pub const USART_CR1_MME: u32 = 8192;
pub const USART_CR1_CMIE_Pos: u32 = 14;
pub const USART_CR1_CMIE_Msk: u32 = 16384;
pub const USART_CR1_CMIE: u32 = 16384;
pub const USART_CR1_OVER8_Pos: u32 = 15;
pub const USART_CR1_OVER8_Msk: u32 = 32768;
pub const USART_CR1_OVER8: u32 = 32768;
pub const USART_CR1_DEDT_Pos: u32 = 16;
pub const USART_CR1_DEDT_Msk: u32 = 2031616;
pub const USART_CR1_DEDT: u32 = 2031616;
pub const USART_CR1_DEDT_0: u32 = 65536;
pub const USART_CR1_DEDT_1: u32 = 131072;
pub const USART_CR1_DEDT_2: u32 = 262144;
pub const USART_CR1_DEDT_3: u32 = 524288;
pub const USART_CR1_DEDT_4: u32 = 1048576;
pub const USART_CR1_DEAT_Pos: u32 = 21;
pub const USART_CR1_DEAT_Msk: u32 = 65011712;
pub const USART_CR1_DEAT: u32 = 65011712;
pub const USART_CR1_DEAT_0: u32 = 2097152;
pub const USART_CR1_DEAT_1: u32 = 4194304;
pub const USART_CR1_DEAT_2: u32 = 8388608;
pub const USART_CR1_DEAT_3: u32 = 16777216;
pub const USART_CR1_DEAT_4: u32 = 33554432;
pub const USART_CR1_RTOIE_Pos: u32 = 26;
pub const USART_CR1_RTOIE_Msk: u32 = 67108864;
pub const USART_CR1_RTOIE: u32 = 67108864;
pub const USART_CR1_EOBIE_Pos: u32 = 27;
pub const USART_CR1_EOBIE_Msk: u32 = 134217728;
pub const USART_CR1_EOBIE: u32 = 134217728;
pub const USART_CR1_M1_Pos: u32 = 28;
pub const USART_CR1_M1_Msk: u32 = 268435456;
pub const USART_CR1_M1: u32 = 268435456;
pub const USART_CR1_FIFOEN_Pos: u32 = 29;
pub const USART_CR1_FIFOEN_Msk: u32 = 536870912;
pub const USART_CR1_FIFOEN: u32 = 536870912;
pub const USART_CR1_TXFEIE_Pos: u32 = 30;
pub const USART_CR1_TXFEIE_Msk: u32 = 1073741824;
pub const USART_CR1_TXFEIE: u32 = 1073741824;
pub const USART_CR1_RXFFIE_Pos: u32 = 31;
pub const USART_CR1_RXFFIE_Msk: u32 = 2147483648;
pub const USART_CR1_RXFFIE: u32 = 2147483648;
pub const USART_CR2_SLVEN_Pos: u32 = 0;
pub const USART_CR2_SLVEN_Msk: u32 = 1;
pub const USART_CR2_SLVEN: u32 = 1;
pub const USART_CR2_DIS_NSS_Pos: u32 = 3;
pub const USART_CR2_DIS_NSS_Msk: u32 = 8;
pub const USART_CR2_DIS_NSS: u32 = 8;
pub const USART_CR2_ADDM7_Pos: u32 = 4;
pub const USART_CR2_ADDM7_Msk: u32 = 16;
pub const USART_CR2_ADDM7: u32 = 16;
pub const USART_CR2_LBDL_Pos: u32 = 5;
pub const USART_CR2_LBDL_Msk: u32 = 32;
pub const USART_CR2_LBDL: u32 = 32;
pub const USART_CR2_LBDIE_Pos: u32 = 6;
pub const USART_CR2_LBDIE_Msk: u32 = 64;
pub const USART_CR2_LBDIE: u32 = 64;
pub const USART_CR2_LBCL_Pos: u32 = 8;
pub const USART_CR2_LBCL_Msk: u32 = 256;
pub const USART_CR2_LBCL: u32 = 256;
pub const USART_CR2_CPHA_Pos: u32 = 9;
pub const USART_CR2_CPHA_Msk: u32 = 512;
pub const USART_CR2_CPHA: u32 = 512;
pub const USART_CR2_CPOL_Pos: u32 = 10;
pub const USART_CR2_CPOL_Msk: u32 = 1024;
pub const USART_CR2_CPOL: u32 = 1024;
pub const USART_CR2_CLKEN_Pos: u32 = 11;
pub const USART_CR2_CLKEN_Msk: u32 = 2048;
pub const USART_CR2_CLKEN: u32 = 2048;
pub const USART_CR2_STOP_Pos: u32 = 12;
pub const USART_CR2_STOP_Msk: u32 = 12288;
pub const USART_CR2_STOP: u32 = 12288;
pub const USART_CR2_STOP_0: u32 = 4096;
pub const USART_CR2_STOP_1: u32 = 8192;
pub const USART_CR2_LINEN_Pos: u32 = 14;
pub const USART_CR2_LINEN_Msk: u32 = 16384;
pub const USART_CR2_LINEN: u32 = 16384;
pub const USART_CR2_SWAP_Pos: u32 = 15;
pub const USART_CR2_SWAP_Msk: u32 = 32768;
pub const USART_CR2_SWAP: u32 = 32768;
pub const USART_CR2_RXINV_Pos: u32 = 16;
pub const USART_CR2_RXINV_Msk: u32 = 65536;
pub const USART_CR2_RXINV: u32 = 65536;
pub const USART_CR2_TXINV_Pos: u32 = 17;
pub const USART_CR2_TXINV_Msk: u32 = 131072;
pub const USART_CR2_TXINV: u32 = 131072;
pub const USART_CR2_DATAINV_Pos: u32 = 18;
pub const USART_CR2_DATAINV_Msk: u32 = 262144;
pub const USART_CR2_DATAINV: u32 = 262144;
pub const USART_CR2_MSBFIRST_Pos: u32 = 19;
pub const USART_CR2_MSBFIRST_Msk: u32 = 524288;
pub const USART_CR2_MSBFIRST: u32 = 524288;
pub const USART_CR2_ABREN_Pos: u32 = 20;
pub const USART_CR2_ABREN_Msk: u32 = 1048576;
pub const USART_CR2_ABREN: u32 = 1048576;
pub const USART_CR2_ABRMODE_Pos: u32 = 21;
pub const USART_CR2_ABRMODE_Msk: u32 = 6291456;
pub const USART_CR2_ABRMODE: u32 = 6291456;
pub const USART_CR2_ABRMODE_0: u32 = 2097152;
pub const USART_CR2_ABRMODE_1: u32 = 4194304;
pub const USART_CR2_RTOEN_Pos: u32 = 23;
pub const USART_CR2_RTOEN_Msk: u32 = 8388608;
pub const USART_CR2_RTOEN: u32 = 8388608;
pub const USART_CR2_ADD_Pos: u32 = 24;
pub const USART_CR2_ADD_Msk: u32 = 4278190080;
pub const USART_CR2_ADD: u32 = 4278190080;
pub const USART_CR3_EIE_Pos: u32 = 0;
pub const USART_CR3_EIE_Msk: u32 = 1;
pub const USART_CR3_EIE: u32 = 1;
pub const USART_CR3_IREN_Pos: u32 = 1;
pub const USART_CR3_IREN_Msk: u32 = 2;
pub const USART_CR3_IREN: u32 = 2;
pub const USART_CR3_IRLP_Pos: u32 = 2;
pub const USART_CR3_IRLP_Msk: u32 = 4;
pub const USART_CR3_IRLP: u32 = 4;
pub const USART_CR3_HDSEL_Pos: u32 = 3;
pub const USART_CR3_HDSEL_Msk: u32 = 8;
pub const USART_CR3_HDSEL: u32 = 8;
pub const USART_CR3_NACK_Pos: u32 = 4;
pub const USART_CR3_NACK_Msk: u32 = 16;
pub const USART_CR3_NACK: u32 = 16;
pub const USART_CR3_SCEN_Pos: u32 = 5;
pub const USART_CR3_SCEN_Msk: u32 = 32;
pub const USART_CR3_SCEN: u32 = 32;
pub const USART_CR3_DMAR_Pos: u32 = 6;
pub const USART_CR3_DMAR_Msk: u32 = 64;
pub const USART_CR3_DMAR: u32 = 64;
pub const USART_CR3_DMAT_Pos: u32 = 7;
pub const USART_CR3_DMAT_Msk: u32 = 128;
pub const USART_CR3_DMAT: u32 = 128;
pub const USART_CR3_RTSE_Pos: u32 = 8;
pub const USART_CR3_RTSE_Msk: u32 = 256;
pub const USART_CR3_RTSE: u32 = 256;
pub const USART_CR3_CTSE_Pos: u32 = 9;
pub const USART_CR3_CTSE_Msk: u32 = 512;
pub const USART_CR3_CTSE: u32 = 512;
pub const USART_CR3_CTSIE_Pos: u32 = 10;
pub const USART_CR3_CTSIE_Msk: u32 = 1024;
pub const USART_CR3_CTSIE: u32 = 1024;
pub const USART_CR3_ONEBIT_Pos: u32 = 11;
pub const USART_CR3_ONEBIT_Msk: u32 = 2048;
pub const USART_CR3_ONEBIT: u32 = 2048;
pub const USART_CR3_OVRDIS_Pos: u32 = 12;
pub const USART_CR3_OVRDIS_Msk: u32 = 4096;
pub const USART_CR3_OVRDIS: u32 = 4096;
pub const USART_CR3_DDRE_Pos: u32 = 13;
pub const USART_CR3_DDRE_Msk: u32 = 8192;
pub const USART_CR3_DDRE: u32 = 8192;
pub const USART_CR3_DEM_Pos: u32 = 14;
pub const USART_CR3_DEM_Msk: u32 = 16384;
pub const USART_CR3_DEM: u32 = 16384;
pub const USART_CR3_DEP_Pos: u32 = 15;
pub const USART_CR3_DEP_Msk: u32 = 32768;
pub const USART_CR3_DEP: u32 = 32768;
pub const USART_CR3_SCARCNT_Pos: u32 = 17;
pub const USART_CR3_SCARCNT_Msk: u32 = 917504;
pub const USART_CR3_SCARCNT: u32 = 917504;
pub const USART_CR3_SCARCNT_0: u32 = 131072;
pub const USART_CR3_SCARCNT_1: u32 = 262144;
pub const USART_CR3_SCARCNT_2: u32 = 524288;
pub const USART_CR3_WUS_Pos: u32 = 20;
pub const USART_CR3_WUS_Msk: u32 = 3145728;
pub const USART_CR3_WUS: u32 = 3145728;
pub const USART_CR3_WUS_0: u32 = 1048576;
pub const USART_CR3_WUS_1: u32 = 2097152;
pub const USART_CR3_WUFIE_Pos: u32 = 22;
pub const USART_CR3_WUFIE_Msk: u32 = 4194304;
pub const USART_CR3_WUFIE: u32 = 4194304;
pub const USART_CR3_TXFTIE_Pos: u32 = 23;
pub const USART_CR3_TXFTIE_Msk: u32 = 8388608;
pub const USART_CR3_TXFTIE: u32 = 8388608;
pub const USART_CR3_TCBGTIE_Pos: u32 = 24;
pub const USART_CR3_TCBGTIE_Msk: u32 = 16777216;
pub const USART_CR3_TCBGTIE: u32 = 16777216;
pub const USART_CR3_RXFTCFG_Pos: u32 = 25;
pub const USART_CR3_RXFTCFG_Msk: u32 = 234881024;
pub const USART_CR3_RXFTCFG: u32 = 234881024;
pub const USART_CR3_RXFTCFG_0: u32 = 33554432;
pub const USART_CR3_RXFTCFG_1: u32 = 67108864;
pub const USART_CR3_RXFTCFG_2: u32 = 134217728;
pub const USART_CR3_RXFTIE_Pos: u32 = 28;
pub const USART_CR3_RXFTIE_Msk: u32 = 268435456;
pub const USART_CR3_RXFTIE: u32 = 268435456;
pub const USART_CR3_TXFTCFG_Pos: u32 = 29;
pub const USART_CR3_TXFTCFG_Msk: u32 = 3758096384;
pub const USART_CR3_TXFTCFG: u32 = 3758096384;
pub const USART_CR3_TXFTCFG_0: u32 = 536870912;
pub const USART_CR3_TXFTCFG_1: u32 = 1073741824;
pub const USART_CR3_TXFTCFG_2: u32 = 2147483648;
pub const USART_GTPR_PSC_Pos: u32 = 0;
pub const USART_GTPR_PSC_Msk: u32 = 255;
pub const USART_GTPR_PSC: u32 = 255;
pub const USART_GTPR_GT_Pos: u32 = 8;
pub const USART_GTPR_GT_Msk: u32 = 65280;
pub const USART_GTPR_GT: u32 = 65280;
pub const USART_RTOR_RTO_Pos: u32 = 0;
pub const USART_RTOR_RTO_Msk: u32 = 16777215;
pub const USART_RTOR_RTO: u32 = 16777215;
pub const USART_RTOR_BLEN_Pos: u32 = 24;
pub const USART_RTOR_BLEN_Msk: u32 = 4278190080;
pub const USART_RTOR_BLEN: u32 = 4278190080;
pub const USART_RQR_ABRRQ_Pos: u32 = 0;
pub const USART_RQR_ABRRQ_Msk: u32 = 1;
pub const USART_RQR_ABRRQ: u32 = 1;
pub const USART_RQR_SBKRQ_Pos: u32 = 1;
pub const USART_RQR_SBKRQ_Msk: u32 = 2;
pub const USART_RQR_SBKRQ: u32 = 2;
pub const USART_RQR_MMRQ_Pos: u32 = 2;
pub const USART_RQR_MMRQ_Msk: u32 = 4;
pub const USART_RQR_MMRQ: u32 = 4;
pub const USART_RQR_RXFRQ_Pos: u32 = 3;
pub const USART_RQR_RXFRQ_Msk: u32 = 8;
pub const USART_RQR_RXFRQ: u32 = 8;
pub const USART_RQR_TXFRQ_Pos: u32 = 4;
pub const USART_RQR_TXFRQ_Msk: u32 = 16;
pub const USART_RQR_TXFRQ: u32 = 16;
pub const USART_ISR_PE_Pos: u32 = 0;
pub const USART_ISR_PE_Msk: u32 = 1;
pub const USART_ISR_PE: u32 = 1;
pub const USART_ISR_FE_Pos: u32 = 1;
pub const USART_ISR_FE_Msk: u32 = 2;
pub const USART_ISR_FE: u32 = 2;
pub const USART_ISR_NE_Pos: u32 = 2;
pub const USART_ISR_NE_Msk: u32 = 4;
pub const USART_ISR_NE: u32 = 4;
pub const USART_ISR_ORE_Pos: u32 = 3;
pub const USART_ISR_ORE_Msk: u32 = 8;
pub const USART_ISR_ORE: u32 = 8;
pub const USART_ISR_IDLE_Pos: u32 = 4;
pub const USART_ISR_IDLE_Msk: u32 = 16;
pub const USART_ISR_IDLE: u32 = 16;
pub const USART_ISR_RXNE_Pos: u32 = 5;
pub const USART_ISR_RXNE_Msk: u32 = 32;
pub const USART_ISR_RXNE: u32 = 32;
pub const USART_ISR_RXNE_RXFNE_Pos: u32 = 5;
pub const USART_ISR_RXNE_RXFNE_Msk: u32 = 32;
pub const USART_ISR_RXNE_RXFNE: u32 = 32;
pub const USART_ISR_TC_Pos: u32 = 6;
pub const USART_ISR_TC_Msk: u32 = 64;
pub const USART_ISR_TC: u32 = 64;
pub const USART_ISR_TXE_Pos: u32 = 7;
pub const USART_ISR_TXE_Msk: u32 = 128;
pub const USART_ISR_TXE: u32 = 128;
pub const USART_ISR_TXE_TXFNF_Pos: u32 = 7;
pub const USART_ISR_TXE_TXFNF_Msk: u32 = 128;
pub const USART_ISR_TXE_TXFNF: u32 = 128;
pub const USART_ISR_LBDF_Pos: u32 = 8;
pub const USART_ISR_LBDF_Msk: u32 = 256;
pub const USART_ISR_LBDF: u32 = 256;
pub const USART_ISR_CTSIF_Pos: u32 = 9;
pub const USART_ISR_CTSIF_Msk: u32 = 512;
pub const USART_ISR_CTSIF: u32 = 512;
pub const USART_ISR_CTS_Pos: u32 = 10;
pub const USART_ISR_CTS_Msk: u32 = 1024;
pub const USART_ISR_CTS: u32 = 1024;
pub const USART_ISR_RTOF_Pos: u32 = 11;
pub const USART_ISR_RTOF_Msk: u32 = 2048;
pub const USART_ISR_RTOF: u32 = 2048;
pub const USART_ISR_EOBF_Pos: u32 = 12;
pub const USART_ISR_EOBF_Msk: u32 = 4096;
pub const USART_ISR_EOBF: u32 = 4096;
pub const USART_ISR_UDR_Pos: u32 = 13;
pub const USART_ISR_UDR_Msk: u32 = 8192;
pub const USART_ISR_UDR: u32 = 8192;
pub const USART_ISR_ABRE_Pos: u32 = 14;
pub const USART_ISR_ABRE_Msk: u32 = 16384;
pub const USART_ISR_ABRE: u32 = 16384;
pub const USART_ISR_ABRF_Pos: u32 = 15;
pub const USART_ISR_ABRF_Msk: u32 = 32768;
pub const USART_ISR_ABRF: u32 = 32768;
pub const USART_ISR_BUSY_Pos: u32 = 16;
pub const USART_ISR_BUSY_Msk: u32 = 65536;
pub const USART_ISR_BUSY: u32 = 65536;
pub const USART_ISR_CMF_Pos: u32 = 17;
pub const USART_ISR_CMF_Msk: u32 = 131072;
pub const USART_ISR_CMF: u32 = 131072;
pub const USART_ISR_SBKF_Pos: u32 = 18;
pub const USART_ISR_SBKF_Msk: u32 = 262144;
pub const USART_ISR_SBKF: u32 = 262144;
pub const USART_ISR_RWU_Pos: u32 = 19;
pub const USART_ISR_RWU_Msk: u32 = 524288;
pub const USART_ISR_RWU: u32 = 524288;
pub const USART_ISR_WUF_Pos: u32 = 20;
pub const USART_ISR_WUF_Msk: u32 = 1048576;
pub const USART_ISR_WUF: u32 = 1048576;
pub const USART_ISR_TEACK_Pos: u32 = 21;
pub const USART_ISR_TEACK_Msk: u32 = 2097152;
pub const USART_ISR_TEACK: u32 = 2097152;
pub const USART_ISR_REACK_Pos: u32 = 22;
pub const USART_ISR_REACK_Msk: u32 = 4194304;
pub const USART_ISR_REACK: u32 = 4194304;
pub const USART_ISR_TXFE_Pos: u32 = 23;
pub const USART_ISR_TXFE_Msk: u32 = 8388608;
pub const USART_ISR_TXFE: u32 = 8388608;
pub const USART_ISR_RXFF_Pos: u32 = 24;
pub const USART_ISR_RXFF_Msk: u32 = 16777216;
pub const USART_ISR_RXFF: u32 = 16777216;
pub const USART_ISR_TCBGT_Pos: u32 = 25;
pub const USART_ISR_TCBGT_Msk: u32 = 33554432;
pub const USART_ISR_TCBGT: u32 = 33554432;
pub const USART_ISR_RXFT_Pos: u32 = 26;
pub const USART_ISR_RXFT_Msk: u32 = 67108864;
pub const USART_ISR_RXFT: u32 = 67108864;
pub const USART_ISR_TXFT_Pos: u32 = 27;
pub const USART_ISR_TXFT_Msk: u32 = 134217728;
pub const USART_ISR_TXFT: u32 = 134217728;
pub const USART_ICR_PECF_Pos: u32 = 0;
pub const USART_ICR_PECF_Msk: u32 = 1;
pub const USART_ICR_PECF: u32 = 1;
pub const USART_ICR_FECF_Pos: u32 = 1;
pub const USART_ICR_FECF_Msk: u32 = 2;
pub const USART_ICR_FECF: u32 = 2;
pub const USART_ICR_NECF_Pos: u32 = 2;
pub const USART_ICR_NECF_Msk: u32 = 4;
pub const USART_ICR_NECF: u32 = 4;
pub const USART_ICR_ORECF_Pos: u32 = 3;
pub const USART_ICR_ORECF_Msk: u32 = 8;
pub const USART_ICR_ORECF: u32 = 8;
pub const USART_ICR_IDLECF_Pos: u32 = 4;
pub const USART_ICR_IDLECF_Msk: u32 = 16;
pub const USART_ICR_IDLECF: u32 = 16;
pub const USART_ICR_TXFECF_Pos: u32 = 5;
pub const USART_ICR_TXFECF_Msk: u32 = 32;
pub const USART_ICR_TXFECF: u32 = 32;
pub const USART_ICR_TCCF_Pos: u32 = 6;
pub const USART_ICR_TCCF_Msk: u32 = 64;
pub const USART_ICR_TCCF: u32 = 64;
pub const USART_ICR_TCBGTCF_Pos: u32 = 7;
pub const USART_ICR_TCBGTCF_Msk: u32 = 128;
pub const USART_ICR_TCBGTCF: u32 = 128;
pub const USART_ICR_LBDCF_Pos: u32 = 8;
pub const USART_ICR_LBDCF_Msk: u32 = 256;
pub const USART_ICR_LBDCF: u32 = 256;
pub const USART_ICR_CTSCF_Pos: u32 = 9;
pub const USART_ICR_CTSCF_Msk: u32 = 512;
pub const USART_ICR_CTSCF: u32 = 512;
pub const USART_ICR_RTOCF_Pos: u32 = 11;
pub const USART_ICR_RTOCF_Msk: u32 = 2048;
pub const USART_ICR_RTOCF: u32 = 2048;
pub const USART_ICR_EOBCF_Pos: u32 = 12;
pub const USART_ICR_EOBCF_Msk: u32 = 4096;
pub const USART_ICR_EOBCF: u32 = 4096;
pub const USART_ICR_UDRCF_Pos: u32 = 13;
pub const USART_ICR_UDRCF_Msk: u32 = 8192;
pub const USART_ICR_UDRCF: u32 = 8192;
pub const USART_ICR_CMCF_Pos: u32 = 17;
pub const USART_ICR_CMCF_Msk: u32 = 131072;
pub const USART_ICR_CMCF: u32 = 131072;
pub const USART_ICR_WUCF_Pos: u32 = 20;
pub const USART_ICR_WUCF_Msk: u32 = 1048576;
pub const USART_ICR_WUCF: u32 = 1048576;
pub const USART_RDR_RDR_Pos: u32 = 0;
pub const USART_RDR_RDR_Msk: u32 = 511;
pub const USART_RDR_RDR: u32 = 511;
pub const USART_TDR_TDR_Pos: u32 = 0;
pub const USART_TDR_TDR_Msk: u32 = 511;
pub const USART_TDR_TDR: u32 = 511;
pub const USART_PRESC_PRESCALER_Pos: u32 = 0;
pub const USART_PRESC_PRESCALER_Msk: u32 = 15;
pub const USART_PRESC_PRESCALER: u32 = 15;
pub const USART_PRESC_PRESCALER_0: u32 = 1;
pub const USART_PRESC_PRESCALER_1: u32 = 2;
pub const USART_PRESC_PRESCALER_2: u32 = 4;
pub const USART_PRESC_PRESCALER_3: u32 = 8;
pub const VREFBUF_CSR_ENVR_Pos: u32 = 0;
pub const VREFBUF_CSR_ENVR_Msk: u32 = 1;
pub const VREFBUF_CSR_ENVR: u32 = 1;
pub const VREFBUF_CSR_HIZ_Pos: u32 = 1;
pub const VREFBUF_CSR_HIZ_Msk: u32 = 2;
pub const VREFBUF_CSR_HIZ: u32 = 2;
pub const VREFBUF_CSR_VRS_Pos: u32 = 2;
pub const VREFBUF_CSR_VRS_Msk: u32 = 4;
pub const VREFBUF_CSR_VRS: u32 = 4;
pub const VREFBUF_CSR_VRR_Pos: u32 = 3;
pub const VREFBUF_CSR_VRR_Msk: u32 = 8;
pub const VREFBUF_CSR_VRR: u32 = 8;
pub const VREFBUF_CCR_TRIM_Pos: u32 = 0;
pub const VREFBUF_CCR_TRIM_Msk: u32 = 63;
pub const VREFBUF_CCR_TRIM: u32 = 63;
pub const WWDG_CR_T_Pos: u32 = 0;
pub const WWDG_CR_T_Msk: u32 = 127;
pub const WWDG_CR_T: u32 = 127;
pub const WWDG_CR_T_0: u32 = 1;
pub const WWDG_CR_T_1: u32 = 2;
pub const WWDG_CR_T_2: u32 = 4;
pub const WWDG_CR_T_3: u32 = 8;
pub const WWDG_CR_T_4: u32 = 16;
pub const WWDG_CR_T_5: u32 = 32;
pub const WWDG_CR_T_6: u32 = 64;
pub const WWDG_CR_WDGA_Pos: u32 = 7;
pub const WWDG_CR_WDGA_Msk: u32 = 128;
pub const WWDG_CR_WDGA: u32 = 128;
pub const WWDG_CFR_W_Pos: u32 = 0;
pub const WWDG_CFR_W_Msk: u32 = 127;
pub const WWDG_CFR_W: u32 = 127;
pub const WWDG_CFR_W_0: u32 = 1;
pub const WWDG_CFR_W_1: u32 = 2;
pub const WWDG_CFR_W_2: u32 = 4;
pub const WWDG_CFR_W_3: u32 = 8;
pub const WWDG_CFR_W_4: u32 = 16;
pub const WWDG_CFR_W_5: u32 = 32;
pub const WWDG_CFR_W_6: u32 = 64;
pub const WWDG_CFR_WDGTB_Pos: u32 = 11;
pub const WWDG_CFR_WDGTB_Msk: u32 = 14336;
pub const WWDG_CFR_WDGTB: u32 = 14336;
pub const WWDG_CFR_WDGTB_0: u32 = 2048;
pub const WWDG_CFR_WDGTB_1: u32 = 4096;
pub const WWDG_CFR_WDGTB_2: u32 = 8192;
pub const WWDG_CFR_EWI_Pos: u32 = 9;
pub const WWDG_CFR_EWI_Msk: u32 = 512;
pub const WWDG_CFR_EWI: u32 = 512;
pub const WWDG_SR_EWIF_Pos: u32 = 0;
pub const WWDG_SR_EWIF_Msk: u32 = 1;
pub const WWDG_SR_EWIF: u32 = 1;
pub const DBGMCU_IDCODE_DEV_ID_Pos: u32 = 0;
pub const DBGMCU_IDCODE_DEV_ID_Msk: u32 = 4095;
pub const DBGMCU_IDCODE_DEV_ID: u32 = 4095;
pub const DBGMCU_IDCODE_REV_ID_Pos: u32 = 16;
pub const DBGMCU_IDCODE_REV_ID_Msk: u32 = 4294901760;
pub const DBGMCU_IDCODE_REV_ID: u32 = 4294901760;
pub const DBGMCU_CR_DBG_SLEEP_Pos: u32 = 0;
pub const DBGMCU_CR_DBG_SLEEP_Msk: u32 = 1;
pub const DBGMCU_CR_DBG_SLEEP: u32 = 1;
pub const DBGMCU_CR_DBG_STOP_Pos: u32 = 1;
pub const DBGMCU_CR_DBG_STOP_Msk: u32 = 2;
pub const DBGMCU_CR_DBG_STOP: u32 = 2;
pub const DBGMCU_CR_DBG_STANDBY_Pos: u32 = 2;
pub const DBGMCU_CR_DBG_STANDBY_Msk: u32 = 4;
pub const DBGMCU_CR_DBG_STANDBY: u32 = 4;
pub const DBGMCU_CR_TRACE_IOEN_Pos: u32 = 5;
pub const DBGMCU_CR_TRACE_IOEN_Msk: u32 = 32;
pub const DBGMCU_CR_TRACE_IOEN: u32 = 32;
pub const DBGMCU_CR_TRGOEN_Pos: u32 = 28;
pub const DBGMCU_CR_TRGOEN_Msk: u32 = 268435456;
pub const DBGMCU_CR_TRGOEN: u32 = 268435456;
pub const DBGMCU_APB1FZR1_DBG_TIM2_STOP_Pos: u32 = 0;
pub const DBGMCU_APB1FZR1_DBG_TIM2_STOP_Msk: u32 = 1;
pub const DBGMCU_APB1FZR1_DBG_TIM2_STOP: u32 = 1;
pub const DBGMCU_APB1FZR1_DBG_RTC_STOP_Pos: u32 = 10;
pub const DBGMCU_APB1FZR1_DBG_RTC_STOP_Msk: u32 = 1024;
pub const DBGMCU_APB1FZR1_DBG_RTC_STOP: u32 = 1024;
pub const DBGMCU_APB1FZR1_DBG_WWDG_STOP_Pos: u32 = 11;
pub const DBGMCU_APB1FZR1_DBG_WWDG_STOP_Msk: u32 = 2048;
pub const DBGMCU_APB1FZR1_DBG_WWDG_STOP: u32 = 2048;
pub const DBGMCU_APB1FZR1_DBG_IWDG_STOP_Pos: u32 = 12;
pub const DBGMCU_APB1FZR1_DBG_IWDG_STOP_Msk: u32 = 4096;
pub const DBGMCU_APB1FZR1_DBG_IWDG_STOP: u32 = 4096;
pub const DBGMCU_APB1FZR1_DBG_I2C1_STOP_Pos: u32 = 21;
pub const DBGMCU_APB1FZR1_DBG_I2C1_STOP_Msk: u32 = 2097152;
pub const DBGMCU_APB1FZR1_DBG_I2C1_STOP: u32 = 2097152;
pub const DBGMCU_APB1FZR1_DBG_I2C3_STOP_Pos: u32 = 23;
pub const DBGMCU_APB1FZR1_DBG_I2C3_STOP_Msk: u32 = 8388608;
pub const DBGMCU_APB1FZR1_DBG_I2C3_STOP: u32 = 8388608;
pub const DBGMCU_APB1FZR1_DBG_LPTIM1_STOP_Pos: u32 = 31;
pub const DBGMCU_APB1FZR1_DBG_LPTIM1_STOP_Msk: u32 = 2147483648;
pub const DBGMCU_APB1FZR1_DBG_LPTIM1_STOP: u32 = 2147483648;
pub const DBGMCU_C2APB1FZR1_DBG_TIM2_STOP_Pos: u32 = 0;
pub const DBGMCU_C2APB1FZR1_DBG_TIM2_STOP_Msk: u32 = 1;
pub const DBGMCU_C2APB1FZR1_DBG_TIM2_STOP: u32 = 1;
pub const DBGMCU_C2APB1FZR1_DBG_RTC_STOP_Pos: u32 = 10;
pub const DBGMCU_C2APB1FZR1_DBG_RTC_STOP_Msk: u32 = 1024;
pub const DBGMCU_C2APB1FZR1_DBG_RTC_STOP: u32 = 1024;
pub const DBGMCU_C2APB1FZR1_DBG_IWDG_STOP_Pos: u32 = 12;
pub const DBGMCU_C2APB1FZR1_DBG_IWDG_STOP_Msk: u32 = 4096;
pub const DBGMCU_C2APB1FZR1_DBG_IWDG_STOP: u32 = 4096;
pub const DBGMCU_C2APB1FZR1_DBG_I2C1_STOP_Pos: u32 = 21;
pub const DBGMCU_C2APB1FZR1_DBG_I2C1_STOP_Msk: u32 = 2097152;
pub const DBGMCU_C2APB1FZR1_DBG_I2C1_STOP: u32 = 2097152;
pub const DBGMCU_C2APB1FZR1_DBG_I2C3_STOP_Pos: u32 = 23;
pub const DBGMCU_C2APB1FZR1_DBG_I2C3_STOP_Msk: u32 = 8388608;
pub const DBGMCU_C2APB1FZR1_DBG_I2C3_STOP: u32 = 8388608;
pub const DBGMCU_C2APB1FZR1_DBG_LPTIM1_STOP_Pos: u32 = 31;
pub const DBGMCU_C2APB1FZR1_DBG_LPTIM1_STOP_Msk: u32 = 2147483648;
pub const DBGMCU_C2APB1FZR1_DBG_LPTIM1_STOP: u32 = 2147483648;
pub const DBGMCU_APB1FZR2_DBG_LPTIM2_STOP_Pos: u32 = 5;
pub const DBGMCU_APB1FZR2_DBG_LPTIM2_STOP_Msk: u32 = 32;
pub const DBGMCU_APB1FZR2_DBG_LPTIM2_STOP: u32 = 32;
pub const DBGMCU_C2APB1FZR2_DBG_LPTIM2_STOP_Pos: u32 = 5;
pub const DBGMCU_C2APB1FZR2_DBG_LPTIM2_STOP_Msk: u32 = 32;
pub const DBGMCU_C2APB1FZR2_DBG_LPTIM2_STOP: u32 = 32;
pub const DBGMCU_APB2FZR_DBG_TIM1_STOP_Pos: u32 = 11;
pub const DBGMCU_APB2FZR_DBG_TIM1_STOP_Msk: u32 = 2048;
pub const DBGMCU_APB2FZR_DBG_TIM1_STOP: u32 = 2048;
pub const DBGMCU_APB2FZR_DBG_TIM16_STOP_Pos: u32 = 17;
pub const DBGMCU_APB2FZR_DBG_TIM16_STOP_Msk: u32 = 131072;
pub const DBGMCU_APB2FZR_DBG_TIM16_STOP: u32 = 131072;
pub const DBGMCU_APB2FZR_DBG_TIM17_STOP_Pos: u32 = 18;
pub const DBGMCU_APB2FZR_DBG_TIM17_STOP_Msk: u32 = 262144;
pub const DBGMCU_APB2FZR_DBG_TIM17_STOP: u32 = 262144;
pub const DBGMCU_C2APB2FZR_DBG_TIM1_STOP_Pos: u32 = 11;
pub const DBGMCU_C2APB2FZR_DBG_TIM1_STOP_Msk: u32 = 2048;
pub const DBGMCU_C2APB2FZR_DBG_TIM1_STOP: u32 = 2048;
pub const DBGMCU_C2APB2FZR_DBG_TIM16_STOP_Pos: u32 = 17;
pub const DBGMCU_C2APB2FZR_DBG_TIM16_STOP_Msk: u32 = 131072;
pub const DBGMCU_C2APB2FZR_DBG_TIM16_STOP: u32 = 131072;
pub const DBGMCU_C2APB2FZR_DBG_TIM17_STOP_Pos: u32 = 18;
pub const DBGMCU_C2APB2FZR_DBG_TIM17_STOP_Msk: u32 = 262144;
pub const DBGMCU_C2APB2FZR_DBG_TIM17_STOP: u32 = 262144;
pub const USB_BASE: u32 = 1073765376;
pub const USB_PMAADDR_Pos: u32 = 13;
pub const USB_PMAADDR_Msk: u32 = 1073766400;
pub const USB_PMAADDR: u32 = 1073766400;
pub const USB_CNTR: u32 = 1073765440;
pub const USB_ISTR: u32 = 1073765444;
pub const USB_FNR: u32 = 1073765448;
pub const USB_DADDR: u32 = 1073765452;
pub const USB_BTABLE: u32 = 1073765456;
pub const USB_LPMCSR: u32 = 1073765460;
pub const USB_BCDR: u32 = 1073765464;
pub const USB_EP0R: u32 = 1073765376;
pub const USB_EP1R: u32 = 1073765380;
pub const USB_EP2R: u32 = 1073765384;
pub const USB_EP3R: u32 = 1073765388;
pub const USB_EP4R: u32 = 1073765392;
pub const USB_EP5R: u32 = 1073765396;
pub const USB_EP6R: u32 = 1073765400;
pub const USB_EP7R: u32 = 1073765404;
pub const CRS_CR_SYNCOKIE_Pos: u32 = 0;
pub const CRS_CR_SYNCOKIE_Msk: u32 = 1;
pub const CRS_CR_SYNCOKIE: u32 = 1;
pub const CRS_CR_SYNCWARNIE_Pos: u32 = 1;
pub const CRS_CR_SYNCWARNIE_Msk: u32 = 2;
pub const CRS_CR_SYNCWARNIE: u32 = 2;
pub const CRS_CR_ERRIE_Pos: u32 = 2;
pub const CRS_CR_ERRIE_Msk: u32 = 4;
pub const CRS_CR_ERRIE: u32 = 4;
pub const CRS_CR_ESYNCIE_Pos: u32 = 3;
pub const CRS_CR_ESYNCIE_Msk: u32 = 8;
pub const CRS_CR_ESYNCIE: u32 = 8;
pub const CRS_CR_CEN_Pos: u32 = 5;
pub const CRS_CR_CEN_Msk: u32 = 32;
pub const CRS_CR_CEN: u32 = 32;
pub const CRS_CR_AUTOTRIMEN_Pos: u32 = 6;
pub const CRS_CR_AUTOTRIMEN_Msk: u32 = 64;
pub const CRS_CR_AUTOTRIMEN: u32 = 64;
pub const CRS_CR_SWSYNC_Pos: u32 = 7;
pub const CRS_CR_SWSYNC_Msk: u32 = 128;
pub const CRS_CR_SWSYNC: u32 = 128;
pub const CRS_CR_TRIM_Pos: u32 = 8;
pub const CRS_CR_TRIM_Msk: u32 = 16128;
pub const CRS_CR_TRIM: u32 = 16128;
pub const CRS_CFGR_RELOAD_Pos: u32 = 0;
pub const CRS_CFGR_RELOAD_Msk: u32 = 65535;
pub const CRS_CFGR_RELOAD: u32 = 65535;
pub const CRS_CFGR_FELIM_Pos: u32 = 16;
pub const CRS_CFGR_FELIM_Msk: u32 = 16711680;
pub const CRS_CFGR_FELIM: u32 = 16711680;
pub const CRS_CFGR_SYNCDIV_Pos: u32 = 24;
pub const CRS_CFGR_SYNCDIV_Msk: u32 = 117440512;
pub const CRS_CFGR_SYNCDIV: u32 = 117440512;
pub const CRS_CFGR_SYNCDIV_0: u32 = 16777216;
pub const CRS_CFGR_SYNCDIV_1: u32 = 33554432;
pub const CRS_CFGR_SYNCDIV_2: u32 = 67108864;
pub const CRS_CFGR_SYNCSRC_Pos: u32 = 28;
pub const CRS_CFGR_SYNCSRC_Msk: u32 = 805306368;
pub const CRS_CFGR_SYNCSRC: u32 = 805306368;
pub const CRS_CFGR_SYNCSRC_0: u32 = 268435456;
pub const CRS_CFGR_SYNCSRC_1: u32 = 536870912;
pub const CRS_CFGR_SYNCPOL_Pos: u32 = 31;
pub const CRS_CFGR_SYNCPOL_Msk: u32 = 2147483648;
pub const CRS_CFGR_SYNCPOL: u32 = 2147483648;
pub const CRS_ISR_SYNCOKF_Pos: u32 = 0;
pub const CRS_ISR_SYNCOKF_Msk: u32 = 1;
pub const CRS_ISR_SYNCOKF: u32 = 1;
pub const CRS_ISR_SYNCWARNF_Pos: u32 = 1;
pub const CRS_ISR_SYNCWARNF_Msk: u32 = 2;
pub const CRS_ISR_SYNCWARNF: u32 = 2;
pub const CRS_ISR_ERRF_Pos: u32 = 2;
pub const CRS_ISR_ERRF_Msk: u32 = 4;
pub const CRS_ISR_ERRF: u32 = 4;
pub const CRS_ISR_ESYNCF_Pos: u32 = 3;
pub const CRS_ISR_ESYNCF_Msk: u32 = 8;
pub const CRS_ISR_ESYNCF: u32 = 8;
pub const CRS_ISR_SYNCERR_Pos: u32 = 8;
pub const CRS_ISR_SYNCERR_Msk: u32 = 256;
pub const CRS_ISR_SYNCERR: u32 = 256;
pub const CRS_ISR_SYNCMISS_Pos: u32 = 9;
pub const CRS_ISR_SYNCMISS_Msk: u32 = 512;
pub const CRS_ISR_SYNCMISS: u32 = 512;
pub const CRS_ISR_TRIMOVF_Pos: u32 = 10;
pub const CRS_ISR_TRIMOVF_Msk: u32 = 1024;
pub const CRS_ISR_TRIMOVF: u32 = 1024;
pub const CRS_ISR_FEDIR_Pos: u32 = 15;
pub const CRS_ISR_FEDIR_Msk: u32 = 32768;
pub const CRS_ISR_FEDIR: u32 = 32768;
pub const CRS_ISR_FECAP_Pos: u32 = 16;
pub const CRS_ISR_FECAP_Msk: u32 = 4294901760;
pub const CRS_ISR_FECAP: u32 = 4294901760;
pub const CRS_ICR_SYNCOKC_Pos: u32 = 0;
pub const CRS_ICR_SYNCOKC_Msk: u32 = 1;
pub const CRS_ICR_SYNCOKC: u32 = 1;
pub const CRS_ICR_SYNCWARNC_Pos: u32 = 1;
pub const CRS_ICR_SYNCWARNC_Msk: u32 = 2;
pub const CRS_ICR_SYNCWARNC: u32 = 2;
pub const CRS_ICR_ERRC_Pos: u32 = 2;
pub const CRS_ICR_ERRC_Msk: u32 = 4;
pub const CRS_ICR_ERRC: u32 = 4;
pub const CRS_ICR_ESYNCC_Pos: u32 = 3;
pub const CRS_ICR_ESYNCC_Msk: u32 = 8;
pub const CRS_ICR_ESYNCC: u32 = 8;
pub const HSEM_CPU1_COREID: u32 = 4;
pub const HSEM_CPU2_COREID: u32 = 8;
pub const HSEM_SEMID_MIN: u32 = 0;
pub const HSEM_SEMID_MAX: u32 = 31;
pub const HSEM_PROCESSID_MIN: u32 = 0;
pub const HSEM_PROCESSID_MAX: u32 = 255;
pub const HSEM_CLEAR_KEY_MIN: u32 = 0;
pub const HSEM_CLEAR_KEY_MAX: u32 = 65535;
pub const LL_GPIO_PIN_0: u32 = 1;
pub const LL_GPIO_PIN_1: u32 = 2;
pub const LL_GPIO_PIN_2: u32 = 4;
pub const LL_GPIO_PIN_3: u32 = 8;
pub const LL_GPIO_PIN_4: u32 = 16;
pub const LL_GPIO_PIN_5: u32 = 32;
pub const LL_GPIO_PIN_6: u32 = 64;
pub const LL_GPIO_PIN_7: u32 = 128;
pub const LL_GPIO_PIN_8: u32 = 256;
pub const LL_GPIO_PIN_9: u32 = 512;
pub const LL_GPIO_PIN_10: u32 = 1024;
pub const LL_GPIO_PIN_11: u32 = 2048;
pub const LL_GPIO_PIN_12: u32 = 4096;
pub const LL_GPIO_PIN_13: u32 = 8192;
pub const LL_GPIO_PIN_14: u32 = 16384;
pub const LL_GPIO_PIN_15: u32 = 32768;
pub const LL_GPIO_PIN_ALL: u32 = 65535;
pub const LL_GPIO_MODE_INPUT: u32 = 0;
pub const LL_GPIO_MODE_OUTPUT: u32 = 1;
pub const LL_GPIO_MODE_ALTERNATE: u32 = 2;
pub const LL_GPIO_MODE_ANALOG: u32 = 3;
pub const LL_GPIO_OUTPUT_PUSHPULL: u32 = 0;
pub const LL_GPIO_OUTPUT_OPENDRAIN: u32 = 1;
pub const LL_GPIO_SPEED_FREQ_LOW: u32 = 0;
pub const LL_GPIO_SPEED_FREQ_MEDIUM: u32 = 1;
pub const LL_GPIO_SPEED_FREQ_HIGH: u32 = 2;
pub const LL_GPIO_SPEED_FREQ_VERY_HIGH: u32 = 3;
pub const LL_GPIO_PULL_NO: u32 = 0;
pub const LL_GPIO_PULL_UP: u32 = 1;
pub const LL_GPIO_PULL_DOWN: u32 = 2;
pub const LL_GPIO_AF_0: u32 = 0;
pub const LL_GPIO_AF_1: u32 = 1;
pub const LL_GPIO_AF_2: u32 = 2;
pub const LL_GPIO_AF_3: u32 = 3;
pub const LL_GPIO_AF_4: u32 = 4;
pub const LL_GPIO_AF_5: u32 = 5;
pub const LL_GPIO_AF_6: u32 = 6;
pub const LL_GPIO_AF_7: u32 = 7;
pub const LL_GPIO_AF_8: u32 = 8;
pub const LL_GPIO_AF_9: u32 = 9;
pub const LL_GPIO_AF_10: u32 = 10;
pub const LL_GPIO_AF_11: u32 = 11;
pub const LL_GPIO_AF_12: u32 = 12;
pub const LL_GPIO_AF_13: u32 = 13;
pub const LL_GPIO_AF_14: u32 = 14;
pub const LL_GPIO_AF_15: u32 = 15;
pub const LL_SYSCFG_REMAP_FLASH: u32 = 0;
pub const LL_SYSCFG_REMAP_SYSTEMFLASH: u32 = 1;
pub const LL_SYSCFG_REMAP_SRAM: u32 = 3;
pub const LL_SYSCFG_REMAP_QUADSPI: u32 = 6;
pub const LL_SYSCFG_I2C_FASTMODEPLUS_PB6: u32 = 65536;
pub const LL_SYSCFG_I2C_FASTMODEPLUS_PB7: u32 = 131072;
pub const LL_SYSCFG_I2C_FASTMODEPLUS_PB8: u32 = 262144;
pub const LL_SYSCFG_I2C_FASTMODEPLUS_PB9: u32 = 524288;
pub const LL_SYSCFG_I2C_FASTMODEPLUS_I2C1: u32 = 1048576;
pub const LL_SYSCFG_I2C_FASTMODEPLUS_I2C3: u32 = 4194304;
pub const LL_SYSCFG_EXTI_PORTA: u32 = 0;
pub const LL_SYSCFG_EXTI_PORTB: u32 = 1;
pub const LL_SYSCFG_EXTI_PORTC: u32 = 2;
pub const LL_SYSCFG_EXTI_PORTD: u32 = 3;
pub const LL_SYSCFG_EXTI_PORTE: u32 = 4;
pub const LL_SYSCFG_EXTI_PORTH: u32 = 7;
pub const LL_SYSCFG_TIMBREAK_ECC: u32 = 8;
pub const LL_SYSCFG_TIMBREAK_PVD: u32 = 4;
pub const LL_SYSCFG_TIMBREAK_SRAM2_PARITY: u32 = 2;
pub const LL_SYSCFG_TIMBREAK_LOCKUP: u32 = 1;
pub const LL_SYSCFG_SRAM2WRP_PAGE0: u32 = 1;
pub const LL_SYSCFG_SRAM2WRP_PAGE1: u32 = 2;
pub const LL_SYSCFG_SRAM2WRP_PAGE2: u32 = 4;
pub const LL_SYSCFG_SRAM2WRP_PAGE3: u32 = 8;
pub const LL_SYSCFG_SRAM2WRP_PAGE4: u32 = 16;
pub const LL_SYSCFG_SRAM2WRP_PAGE5: u32 = 32;
pub const LL_SYSCFG_SRAM2WRP_PAGE6: u32 = 64;
pub const LL_SYSCFG_SRAM2WRP_PAGE7: u32 = 128;
pub const LL_SYSCFG_SRAM2WRP_PAGE8: u32 = 256;
pub const LL_SYSCFG_SRAM2WRP_PAGE9: u32 = 512;
pub const LL_SYSCFG_SRAM2WRP_PAGE10: u32 = 1024;
pub const LL_SYSCFG_SRAM2WRP_PAGE11: u32 = 2048;
pub const LL_SYSCFG_SRAM2WRP_PAGE12: u32 = 4096;
pub const LL_SYSCFG_SRAM2WRP_PAGE13: u32 = 8192;
pub const LL_SYSCFG_SRAM2WRP_PAGE14: u32 = 16384;
pub const LL_SYSCFG_SRAM2WRP_PAGE15: u32 = 32768;
pub const LL_SYSCFG_SRAM2WRP_PAGE16: u32 = 65536;
pub const LL_SYSCFG_SRAM2WRP_PAGE17: u32 = 131072;
pub const LL_SYSCFG_SRAM2WRP_PAGE18: u32 = 262144;
pub const LL_SYSCFG_SRAM2WRP_PAGE19: u32 = 524288;
pub const LL_SYSCFG_SRAM2WRP_PAGE20: u32 = 1048576;
pub const LL_SYSCFG_SRAM2WRP_PAGE21: u32 = 2097152;
pub const LL_SYSCFG_SRAM2WRP_PAGE22: u32 = 4194304;
pub const LL_SYSCFG_SRAM2WRP_PAGE23: u32 = 8388608;
pub const LL_SYSCFG_SRAM2WRP_PAGE24: u32 = 16777216;
pub const LL_SYSCFG_SRAM2WRP_PAGE25: u32 = 33554432;
pub const LL_SYSCFG_SRAM2WRP_PAGE26: u32 = 67108864;
pub const LL_SYSCFG_SRAM2WRP_PAGE27: u32 = 134217728;
pub const LL_SYSCFG_SRAM2WRP_PAGE28: u32 = 268435456;
pub const LL_SYSCFG_SRAM2WRP_PAGE29: u32 = 536870912;
pub const LL_SYSCFG_SRAM2WRP_PAGE30: u32 = 1073741824;
pub const LL_SYSCFG_SRAM2WRP_PAGE31: u32 = 2147483648;
pub const LL_SYSCFG_SRAM2WRP_PAGE32: u32 = 1;
pub const LL_SYSCFG_SRAM2WRP_PAGE33: u32 = 2;
pub const LL_SYSCFG_SRAM2WRP_PAGE34: u32 = 4;
pub const LL_SYSCFG_SRAM2WRP_PAGE35: u32 = 8;
pub const LL_SYSCFG_SRAM2WRP_PAGE36: u32 = 16;
pub const LL_SYSCFG_SRAM2WRP_PAGE37: u32 = 32;
pub const LL_SYSCFG_SRAM2WRP_PAGE38: u32 = 64;
pub const LL_SYSCFG_SRAM2WRP_PAGE39: u32 = 128;
pub const LL_SYSCFG_SRAM2WRP_PAGE40: u32 = 256;
pub const LL_SYSCFG_SRAM2WRP_PAGE41: u32 = 512;
pub const LL_SYSCFG_SRAM2WRP_PAGE42: u32 = 1024;
pub const LL_SYSCFG_SRAM2WRP_PAGE43: u32 = 2048;
pub const LL_SYSCFG_SRAM2WRP_PAGE44: u32 = 4096;
pub const LL_SYSCFG_SRAM2WRP_PAGE45: u32 = 8192;
pub const LL_SYSCFG_SRAM2WRP_PAGE46: u32 = 16384;
pub const LL_SYSCFG_SRAM2WRP_PAGE47: u32 = 32768;
pub const LL_SYSCFG_SRAM2WRP_PAGE48: u32 = 65536;
pub const LL_SYSCFG_SRAM2WRP_PAGE49: u32 = 131072;
pub const LL_SYSCFG_SRAM2WRP_PAGE50: u32 = 262144;
pub const LL_SYSCFG_SRAM2WRP_PAGE51: u32 = 524288;
pub const LL_SYSCFG_SRAM2WRP_PAGE52: u32 = 1048576;
pub const LL_SYSCFG_SRAM2WRP_PAGE53: u32 = 2097152;
pub const LL_SYSCFG_SRAM2WRP_PAGE54: u32 = 4194304;
pub const LL_SYSCFG_SRAM2WRP_PAGE55: u32 = 8388608;
pub const LL_SYSCFG_SRAM2WRP_PAGE56: u32 = 16777216;
pub const LL_SYSCFG_SRAM2WRP_PAGE57: u32 = 33554432;
pub const LL_SYSCFG_SRAM2WRP_PAGE58: u32 = 67108864;
pub const LL_SYSCFG_SRAM2WRP_PAGE59: u32 = 134217728;
pub const LL_SYSCFG_SRAM2WRP_PAGE60: u32 = 268435456;
pub const LL_SYSCFG_SRAM2WRP_PAGE61: u32 = 536870912;
pub const LL_SYSCFG_SRAM2WRP_PAGE62: u32 = 1073741824;
pub const LL_SYSCFG_SRAM2WRP_PAGE63: u32 = 2147483648;
pub const LL_SYSCFG_GRP1_TIM1: u32 = 8192;
pub const LL_SYSCFG_GRP1_TIM16: u32 = 16384;
pub const LL_SYSCFG_GRP1_TIM17: u32 = 32768;
pub const LL_SYSCFG_GRP1_EXTI5: u32 = 2097152;
pub const LL_SYSCFG_GRP1_EXTI6: u32 = 4194304;
pub const LL_SYSCFG_GRP1_EXTI7: u32 = 8388608;
pub const LL_SYSCFG_GRP1_EXTI8: u32 = 16777216;
pub const LL_SYSCFG_GRP1_EXTI9: u32 = 33554432;
pub const LL_SYSCFG_GRP1_EXTI10: u32 = 67108864;
pub const LL_SYSCFG_GRP1_EXTI11: u32 = 134217728;
pub const LL_SYSCFG_GRP1_EXTI12: u32 = 268435456;
pub const LL_SYSCFG_GRP1_EXTI13: u32 = 536870912;
pub const LL_SYSCFG_GRP1_EXTI14: u32 = 1073741824;
pub const LL_SYSCFG_GRP1_EXTI15: u32 = 2147483648;
pub const LL_SYSCFG_GRP2_PVM1: u32 = 65536;
pub const LL_SYSCFG_GRP2_PVM3: u32 = 262144;
pub const LL_SYSCFG_GRP2_PVD: u32 = 1048576;
pub const LL_C2_SYSCFG_GRP1_RTCSTAMP_RTCTAMP_LSECSS: u32 = 1;
pub const LL_C2_SYSCFG_GRP1_RTCWKUP: u32 = 8;
pub const LL_C2_SYSCFG_GRP1_RTCALARM: u32 = 16;
pub const LL_C2_SYSCFG_GRP1_RCC: u32 = 32;
pub const LL_C2_SYSCFG_GRP1_FLASH: u32 = 64;
pub const LL_C2_SYSCFG_GRP1_PKA: u32 = 256;
pub const LL_C2_SYSCFG_GRP1_RNG: u32 = 512;
pub const LL_C2_SYSCFG_GRP1_AES1: u32 = 1024;
pub const LL_C2_SYSCFG_GRP1_COMP: u32 = 2048;
pub const LL_C2_SYSCFG_GRP1_ADC: u32 = 4096;
pub const LL_C2_SYSCFG_GRP1_EXTI0: u32 = 65536;
pub const LL_C2_SYSCFG_GRP1_EXTI1: u32 = 131072;
pub const LL_C2_SYSCFG_GRP1_EXTI2: u32 = 262144;
pub const LL_C2_SYSCFG_GRP1_EXTI3: u32 = 524288;
pub const LL_C2_SYSCFG_GRP1_EXTI4: u32 = 1048576;
pub const LL_C2_SYSCFG_GRP1_EXTI5: u32 = 2097152;
pub const LL_C2_SYSCFG_GRP1_EXTI6: u32 = 4194304;
pub const LL_C2_SYSCFG_GRP1_EXTI7: u32 = 8388608;
pub const LL_C2_SYSCFG_GRP1_EXTI8: u32 = 16777216;
pub const LL_C2_SYSCFG_GRP1_EXTI9: u32 = 33554432;
pub const LL_C2_SYSCFG_GRP1_EXTI10: u32 = 67108864;
pub const LL_C2_SYSCFG_GRP1_EXTI11: u32 = 134217728;
pub const LL_C2_SYSCFG_GRP1_EXTI12: u32 = 268435456;
pub const LL_C2_SYSCFG_GRP1_EXTI13: u32 = 536870912;
pub const LL_C2_SYSCFG_GRP1_EXTI14: u32 = 1073741824;
pub const LL_C2_SYSCFG_GRP1_EXTI15: u32 = 2147483648;
pub const LL_C2_SYSCFG_GRP2_DMA1CH1: u32 = 1;
pub const LL_C2_SYSCFG_GRP2_DMA1CH2: u32 = 2;
pub const LL_C2_SYSCFG_GRP2_DMA1CH3: u32 = 4;
pub const LL_C2_SYSCFG_GRP2_DMA1CH4: u32 = 8;
pub const LL_C2_SYSCFG_GRP2_DMA1CH5: u32 = 16;
pub const LL_C2_SYSCFG_GRP2_DMA1CH6: u32 = 32;
pub const LL_C2_SYSCFG_GRP2_DMA1CH7: u32 = 64;
pub const LL_C2_SYSCFG_GRP2_DMA2CH1: u32 = 256;
pub const LL_C2_SYSCFG_GRP2_DMA2CH2: u32 = 512;
pub const LL_C2_SYSCFG_GRP2_DMA2CH3: u32 = 1024;
pub const LL_C2_SYSCFG_GRP2_DMA2CH4: u32 = 2048;
pub const LL_C2_SYSCFG_GRP2_DMA2CH5: u32 = 4096;
pub const LL_C2_SYSCFG_GRP2_DMA2CH6: u32 = 8192;
pub const LL_C2_SYSCFG_GRP2_DMA2CH7: u32 = 16384;
pub const LL_C2_SYSCFG_GRP2_DMAMUX1: u32 = 32768;
pub const LL_C2_SYSCFG_GRP2_PVM1: u32 = 65536;
pub const LL_C2_SYSCFG_GRP2_PVM3: u32 = 262144;
pub const LL_C2_SYSCFG_GRP2_PVD: u32 = 1048576;
pub const LL_C2_SYSCFG_GRP2_TSC: u32 = 2097152;
pub const LL_C2_SYSCFG_GRP2_LCD: u32 = 4194304;
pub const LL_SYSCFG_SECURE_ACCESS_AES1: u32 = 1;
pub const LL_SYSCFG_SECURE_ACCESS_AES2: u32 = 2;
pub const LL_SYSCFG_SECURE_ACCESS_PKA: u32 = 4;
pub const LL_SYSCFG_SECURE_ACCESS_RNG: u32 = 8;
pub const LL_DBGMCU_APB1_GRP1_TIM2_STOP: u32 = 1;
pub const LL_DBGMCU_APB1_GRP1_RTC_STOP: u32 = 1024;
pub const LL_DBGMCU_APB1_GRP1_WWDG_STOP: u32 = 2048;
pub const LL_DBGMCU_APB1_GRP1_IWDG_STOP: u32 = 4096;
pub const LL_DBGMCU_APB1_GRP1_I2C1_STOP: u32 = 2097152;
pub const LL_DBGMCU_APB1_GRP1_I2C3_STOP: u32 = 8388608;
pub const LL_DBGMCU_APB1_GRP1_LPTIM1_STOP: u32 = 2147483648;
pub const LL_C2_DBGMCU_APB1_GRP1_TIM2_STOP: u32 = 1;
pub const LL_C2_DBGMCU_APB1_GRP1_RTC_STOP: u32 = 1024;
pub const LL_C2_DBGMCU_APB1_GRP1_IWDG_STOP: u32 = 4096;
pub const LL_C2_DBGMCU_APB1_GRP1_I2C1_STOP: u32 = 2097152;
pub const LL_C2_DBGMCU_APB1_GRP1_I2C3_STOP: u32 = 8388608;
pub const LL_C2_DBGMCU_APB1_GRP1_LPTIM1_STOP: u32 = 2147483648;
pub const LL_DBGMCU_APB1_GRP2_LPTIM2_STOP: u32 = 32;
pub const LL_C2_DBGMCU_APB1_GRP2_LPTIM2_STOP: u32 = 32;
pub const LL_DBGMCU_APB2_GRP1_TIM1_STOP: u32 = 2048;
pub const LL_DBGMCU_APB2_GRP1_TIM16_STOP: u32 = 131072;
pub const LL_DBGMCU_APB2_GRP1_TIM17_STOP: u32 = 262144;
pub const LL_C2_DBGMCU_APB2_GRP1_TIM1_STOP: u32 = 2048;
pub const LL_C2_DBGMCU_APB2_GRP1_TIM16_STOP: u32 = 131072;
pub const LL_C2_DBGMCU_APB2_GRP1_TIM17_STOP: u32 = 262144;
pub const LL_VREFBUF_VOLTAGE_SCALE0: u32 = 0;
pub const LL_VREFBUF_VOLTAGE_SCALE1: u32 = 4;
pub const LL_FLASH_LATENCY_0: u32 = 0;
pub const LL_FLASH_LATENCY_1: u32 = 1;
pub const LL_FLASH_LATENCY_2: u32 = 2;
pub const LL_FLASH_LATENCY_3: u32 = 3;
pub const LL_EXTI_LINE_0: u32 = 1;
pub const LL_EXTI_LINE_1: u32 = 2;
pub const LL_EXTI_LINE_2: u32 = 4;
pub const LL_EXTI_LINE_3: u32 = 8;
pub const LL_EXTI_LINE_4: u32 = 16;
pub const LL_EXTI_LINE_5: u32 = 32;
pub const LL_EXTI_LINE_6: u32 = 64;
pub const LL_EXTI_LINE_7: u32 = 128;
pub const LL_EXTI_LINE_8: u32 = 256;
pub const LL_EXTI_LINE_9: u32 = 512;
pub const LL_EXTI_LINE_10: u32 = 1024;
pub const LL_EXTI_LINE_11: u32 = 2048;
pub const LL_EXTI_LINE_12: u32 = 4096;
pub const LL_EXTI_LINE_13: u32 = 8192;
pub const LL_EXTI_LINE_14: u32 = 16384;
pub const LL_EXTI_LINE_15: u32 = 32768;
pub const LL_EXTI_LINE_16: u32 = 65536;
pub const LL_EXTI_LINE_17: u32 = 131072;
pub const LL_EXTI_LINE_18: u32 = 262144;
pub const LL_EXTI_LINE_19: u32 = 524288;
pub const LL_EXTI_LINE_20: u32 = 1048576;
pub const LL_EXTI_LINE_21: u32 = 2097152;
pub const LL_EXTI_LINE_22: u32 = 4194304;
pub const LL_EXTI_LINE_23: u32 = 8388608;
pub const LL_EXTI_LINE_24: u32 = 16777216;
pub const LL_EXTI_LINE_25: u32 = 33554432;
pub const LL_EXTI_LINE_28: u32 = 268435456;
pub const LL_EXTI_LINE_29: u32 = 536870912;
pub const LL_EXTI_LINE_30: u32 = 1073741824;
pub const LL_EXTI_LINE_31: u32 = 2147483648;
pub const LL_EXTI_LINE_ALL_0_31: u32 = 4093640703;
pub const LL_EXTI_LINE_33: u32 = 2;
pub const LL_EXTI_LINE_36: u32 = 16;
pub const LL_EXTI_LINE_37: u32 = 32;
pub const LL_EXTI_LINE_38: u32 = 64;
pub const LL_EXTI_LINE_39: u32 = 128;
pub const LL_EXTI_LINE_40: u32 = 256;
pub const LL_EXTI_LINE_41: u32 = 512;
pub const LL_EXTI_LINE_42: u32 = 1024;
pub const LL_EXTI_LINE_43: u32 = 2048;
pub const LL_EXTI_LINE_44: u32 = 4096;
pub const LL_EXTI_LINE_45: u32 = 8192;
pub const LL_EXTI_LINE_46: u32 = 16384;
pub const LL_EXTI_LINE_48: u32 = 65536;
pub const LL_EXTI_LINE_ALL_32_63: u32 = 98290;
pub const LL_EXTI_LINE_ALL: u32 = 4294967295;
pub const LL_EXTI_LINE_NONE: u32 = 0;
pub const GPIO_NUMBER: u32 = 16;
pub const INPUT_DEBOUNCE_TICKS: u32 = 30;
pub const BUTTON_BACK_Pin: u32 = 8192;
pub const BUTTON_DOWN_Pin: u32 = 64;
pub const BUTTON_LEFT_Pin: u32 = 2048;
pub const BUTTON_OK_Pin: u32 = 8;
pub const BUTTON_RIGHT_Pin: u32 = 4096;
pub const BUTTON_UP_Pin: u32 = 1024;
pub const CC1101_CS_Pin: u32 = 1;
pub const CC1101_G0_Pin: u32 = 2;
pub const DISPLAY_CS_Pin: u32 = 2048;
pub const DISPLAY_DI_Pin: u32 = 2;
pub const DISPLAY_RST_Pin: u32 = 1;
pub const IR_RX_Pin: u32 = 1;
pub const IR_TX_Pin: u32 = 512;
pub const NFC_CS_Pin: u32 = 16;
pub const PA4_Pin: u32 = 16;
pub const PA6_Pin: u32 = 64;
pub const PA7_Pin: u32 = 128;
pub const PB2_Pin: u32 = 4;
pub const PB3_Pin: u32 = 8;
pub const PC0_Pin: u32 = 1;
pub const PC1_Pin: u32 = 2;
pub const PC3_Pin: u32 = 8;
pub const QUARTZ_32MHZ_IN_Pin: u32 = 16384;
pub const QUARTZ_32MHZ_OUT_Pin: u32 = 32768;
pub const RFID_OUT_Pin: u32 = 8192;
pub const RFID_PULL_Pin: u32 = 4;
pub const RFID_RF_IN_Pin: u32 = 32;
pub const RFID_CARRIER_Pin: u32 = 32768;
pub const RF_SW_0_Pin: u32 = 16;
pub const SD_CD_Pin: u32 = 1024;
pub const SD_CS_Pin: u32 = 4096;
pub const SPEAKER_Pin: u32 = 256;
pub const VIBRO_Pin: u32 = 256;
pub const iBTN_Pin: u32 = 16384;
pub const USART1_TX_Pin: u32 = 64;
pub const USART1_RX_Pin: u32 = 128;
pub const SPI_D_MISO_Pin: u32 = 4;
pub const SPI_D_MOSI_Pin: u32 = 32768;
pub const SPI_D_SCK_Pin: u32 = 2;
pub const SPI_R_MISO_Pin: u32 = 16;
pub const SPI_R_MOSI_Pin: u32 = 32;
pub const SPI_R_SCK_Pin: u32 = 32;
pub const NFC_IRQ_Pin: u32 = 4;
pub const RECORD_INPUT_EVENTS: &[u8; 13usize] = b"input_events\0";
pub const VIEW_NONE: u32 = 4294967295;
pub const VIEW_IGNORE: u32 = 4294967294;
pub const RECORD_DIALOGS: &[u8; 8usize] = b"dialogs\0";
pub const RECORD_DOLPHIN: &[u8; 8usize] = b"dolphin\0";
pub const ELEMENTS_MAX_LINES_NUM: u32 = 7;
pub const ELEMENTS_BOLD_MARKER: u8 = 35u8;
pub const ELEMENTS_MONO_MARKER: u8 = 42u8;
pub const ELEMENTS_INVERSED_MARKER: u8 = 33u8;
pub const RECORD_GUI: &[u8; 4usize] = b"gui\0";
pub const RECORD_LOADER: &[u8; 7usize] = b"loader\0";
pub const RECORD_NOTIFICATION: &[u8; 13usize] = b"notification\0";
pub const RECORD_POWER: &[u8; 6usize] = b"power\0";
pub const RPC_BUFFER_SIZE: u32 = 1024;
pub const RPC_MAX_MESSAGE_SIZE: u32 = 1536;
pub const RECORD_RPC: &[u8; 4usize] = b"rpc\0";
pub const SD_LABEL_LENGTH: u32 = 34;
pub const STORAGE_INT_PATH_PREFIX: &[u8; 5usize] = b"/int\0";
pub const STORAGE_EXT_PATH_PREFIX: &[u8; 5usize] = b"/ext\0";
pub const STORAGE_ANY_PATH_PREFIX: &[u8; 5usize] = b"/any\0";
pub const RECORD_STORAGE: &[u8; 8usize] = b"storage\0";
pub const HSE_CONTROL_UNLOCK_KEY: u32 = 3405695742;
pub const HSE_VALUE: u32 = 32000000;
pub const HSI_VALUE: u32 = 16000000;
pub const LSE_VALUE: u32 = 32768;
pub const LSI_VALUE: u32 = 32000;
pub const HSI48_VALUE: u32 = 48000000;
pub const LL_RCC_CICR_LSI1RDYC: u32 = 1;
pub const LL_RCC_CICR_LSI2RDYC: u32 = 2048;
pub const LL_RCC_CICR_LSERDYC: u32 = 2;
pub const LL_RCC_CICR_MSIRDYC: u32 = 4;
pub const LL_RCC_CICR_HSIRDYC: u32 = 8;
pub const LL_RCC_CICR_HSERDYC: u32 = 16;
pub const LL_RCC_CICR_PLLRDYC: u32 = 32;
pub const LL_RCC_CICR_HSI48RDYC: u32 = 1024;
pub const LL_RCC_CICR_PLLSAI1RDYC: u32 = 64;
pub const LL_RCC_CICR_LSECSSC: u32 = 512;
pub const LL_RCC_CICR_CSSC: u32 = 256;
pub const LL_RCC_CIFR_LSI1RDYF: u32 = 1;
pub const LL_RCC_CIFR_LSI2RDYF: u32 = 2048;
pub const LL_RCC_CIFR_LSERDYF: u32 = 2;
pub const LL_RCC_CIFR_MSIRDYF: u32 = 4;
pub const LL_RCC_CIFR_HSIRDYF: u32 = 8;
pub const LL_RCC_CIFR_HSERDYF: u32 = 16;
pub const LL_RCC_CIFR_PLLRDYF: u32 = 32;
pub const LL_RCC_CIFR_HSI48RDYF: u32 = 1024;
pub const LL_RCC_CIFR_PLLSAI1RDYF: u32 = 64;
pub const LL_RCC_CIFR_LSECSSF: u32 = 512;
pub const LL_RCC_CIFR_CSSF: u32 = 256;
pub const LL_RCC_CSR_LPWRRSTF: u32 = 2147483648;
pub const LL_RCC_CSR_OBLRSTF: u32 = 33554432;
pub const LL_RCC_CSR_PINRSTF: u32 = 67108864;
pub const LL_RCC_CSR_SFTRSTF: u32 = 268435456;
pub const LL_RCC_CSR_IWDGRSTF: u32 = 536870912;
pub const LL_RCC_CSR_WWDGRSTF: u32 = 1073741824;
pub const LL_RCC_CSR_BORRSTF: u32 = 134217728;
pub const LL_RCC_CIER_LSI1RDYIE: u32 = 1;
pub const LL_RCC_CIER_LSI2RDYIE: u32 = 2048;
pub const LL_RCC_CIER_LSERDYIE: u32 = 2;
pub const LL_RCC_CIER_MSIRDYIE: u32 = 4;
pub const LL_RCC_CIER_HSIRDYIE: u32 = 8;
pub const LL_RCC_CIER_HSERDYIE: u32 = 16;
pub const LL_RCC_CIER_PLLRDYIE: u32 = 32;
pub const LL_RCC_CIER_HSI48RDYIE: u32 = 1024;
pub const LL_RCC_CIER_PLLSAI1RDYIE: u32 = 64;
pub const LL_RCC_CIER_LSECSSIE: u32 = 512;
pub const LL_RCC_LSEDRIVE_LOW: u32 = 0;
pub const LL_RCC_LSEDRIVE_MEDIUMLOW: u32 = 8;
pub const LL_RCC_LSEDRIVE_MEDIUMHIGH: u32 = 16;
pub const LL_RCC_LSEDRIVE_HIGH: u32 = 24;
pub const LL_RCC_MSIRANGE_0: u32 = 0;
pub const LL_RCC_MSIRANGE_1: u32 = 16;
pub const LL_RCC_MSIRANGE_2: u32 = 32;
pub const LL_RCC_MSIRANGE_3: u32 = 48;
pub const LL_RCC_MSIRANGE_4: u32 = 64;
pub const LL_RCC_MSIRANGE_5: u32 = 80;
pub const LL_RCC_MSIRANGE_6: u32 = 96;
pub const LL_RCC_MSIRANGE_7: u32 = 112;
pub const LL_RCC_MSIRANGE_8: u32 = 128;
pub const LL_RCC_MSIRANGE_9: u32 = 144;
pub const LL_RCC_MSIRANGE_10: u32 = 160;
pub const LL_RCC_MSIRANGE_11: u32 = 176;
pub const LL_RCC_HSE_CURRENTMAX_0: u32 = 0;
pub const LL_RCC_HSE_CURRENTMAX_1: u32 = 16;
pub const LL_RCC_HSE_CURRENTMAX_2: u32 = 32;
pub const LL_RCC_HSE_CURRENTMAX_3: u32 = 48;
pub const LL_RCC_HSE_CURRENTMAX_4: u32 = 64;
pub const LL_RCC_HSE_CURRENTMAX_5: u32 = 80;
pub const LL_RCC_HSE_CURRENTMAX_6: u32 = 96;
pub const LL_RCC_HSE_CURRENTMAX_7: u32 = 112;
pub const LL_RCC_HSEAMPTHRESHOLD_1_2: u32 = 0;
pub const LL_RCC_HSEAMPTHRESHOLD_3_4: u32 = 8;
pub const LL_RCC_LSCO_CLKSOURCE_LSI: u32 = 0;
pub const LL_RCC_LSCO_CLKSOURCE_LSE: u32 = 33554432;
pub const LL_RCC_SYS_CLKSOURCE_MSI: u32 = 0;
pub const LL_RCC_SYS_CLKSOURCE_HSI: u32 = 1;
pub const LL_RCC_SYS_CLKSOURCE_HSE: u32 = 2;
pub const LL_RCC_SYS_CLKSOURCE_PLL: u32 = 3;
pub const LL_RCC_SYS_CLKSOURCE_STATUS_MSI: u32 = 0;
pub const LL_RCC_SYS_CLKSOURCE_STATUS_HSI: u32 = 4;
pub const LL_RCC_SYS_CLKSOURCE_STATUS_HSE: u32 = 8;
pub const LL_RCC_SYS_CLKSOURCE_STATUS_PLL: u32 = 12;
pub const LL_RCC_RF_CLKSOURCE_HSI: u32 = 0;
pub const LL_RCC_RF_CLKSOURCE_HSE_DIV2: u32 = 1048576;
pub const LL_RCC_SYSCLK_DIV_1: u32 = 0;
pub const LL_RCC_SYSCLK_DIV_2: u32 = 128;
pub const LL_RCC_SYSCLK_DIV_3: u32 = 16;
pub const LL_RCC_SYSCLK_DIV_4: u32 = 144;
pub const LL_RCC_SYSCLK_DIV_5: u32 = 32;
pub const LL_RCC_SYSCLK_DIV_6: u32 = 80;
pub const LL_RCC_SYSCLK_DIV_8: u32 = 160;
pub const LL_RCC_SYSCLK_DIV_10: u32 = 96;
pub const LL_RCC_SYSCLK_DIV_16: u32 = 176;
pub const LL_RCC_SYSCLK_DIV_32: u32 = 112;
pub const LL_RCC_SYSCLK_DIV_64: u32 = 192;
pub const LL_RCC_SYSCLK_DIV_128: u32 = 208;
pub const LL_RCC_SYSCLK_DIV_256: u32 = 224;
pub const LL_RCC_SYSCLK_DIV_512: u32 = 240;
pub const LL_RCC_APB1_DIV_1: u32 = 0;
pub const LL_RCC_APB1_DIV_2: u32 = 1024;
pub const LL_RCC_APB1_DIV_4: u32 = 1280;
pub const LL_RCC_APB1_DIV_8: u32 = 1536;
pub const LL_RCC_APB1_DIV_16: u32 = 1792;
pub const LL_RCC_APB2_DIV_1: u32 = 0;
pub const LL_RCC_APB2_DIV_2: u32 = 8192;
pub const LL_RCC_APB2_DIV_4: u32 = 10240;
pub const LL_RCC_APB2_DIV_8: u32 = 12288;
pub const LL_RCC_APB2_DIV_16: u32 = 14336;
pub const LL_RCC_STOP_WAKEUPCLOCK_MSI: u32 = 0;
pub const LL_RCC_STOP_WAKEUPCLOCK_HSI: u32 = 32768;
pub const LL_RCC_MCO1SOURCE_NOCLOCK: u32 = 0;
pub const LL_RCC_MCO1SOURCE_SYSCLK: u32 = 16777216;
pub const LL_RCC_MCO1SOURCE_MSI: u32 = 33554432;
pub const LL_RCC_MCO1SOURCE_HSI: u32 = 50331648;
pub const LL_RCC_MCO1SOURCE_HSE: u32 = 67108864;
pub const LL_RCC_MCO1SOURCE_PLLCLK: u32 = 83886080;
pub const LL_RCC_MCO1SOURCE_LSI1: u32 = 100663296;
pub const LL_RCC_MCO1SOURCE_LSI2: u32 = 117440512;
pub const LL_RCC_MCO1SOURCE_LSE: u32 = 134217728;
pub const LL_RCC_MCO1SOURCE_HSI48: u32 = 150994944;
pub const LL_RCC_MCO1SOURCE_HSE_BEFORE_STAB: u32 = 201326592;
pub const LL_RCC_MCO1_DIV_1: u32 = 0;
pub const LL_RCC_MCO1_DIV_2: u32 = 268435456;
pub const LL_RCC_MCO1_DIV_4: u32 = 536870912;
pub const LL_RCC_MCO1_DIV_8: u32 = 805306368;
pub const LL_RCC_MCO1_DIV_16: u32 = 1073741824;
pub const LL_RCC_SMPS_CLKSOURCE_HSI: u32 = 0;
pub const LL_RCC_SMPS_CLKSOURCE_MSI: u32 = 1;
pub const LL_RCC_SMPS_CLKSOURCE_HSE: u32 = 2;
pub const LL_RCC_SMPS_CLKSOURCE_STATUS_HSI: u32 = 0;
pub const LL_RCC_SMPS_CLKSOURCE_STATUS_MSI: u32 = 256;
pub const LL_RCC_SMPS_CLKSOURCE_STATUS_HSE: u32 = 512;
pub const LL_RCC_SMPS_CLKSOURCE_STATUS_NO_CLOCK: u32 = 768;
pub const LL_RCC_SMPS_DIV_0: u32 = 0;
pub const LL_RCC_SMPS_DIV_1: u32 = 16;
pub const LL_RCC_SMPS_DIV_2: u32 = 32;
pub const LL_RCC_SMPS_DIV_3: u32 = 48;
pub const LL_RCC_PERIPH_FREQUENCY_NO: u32 = 0;
pub const LL_RCC_PERIPH_FREQUENCY_NA: u32 = 4294967295;
pub const LL_RCC_USART1_CLKSOURCE_PCLK2: u32 = 0;
pub const LL_RCC_USART1_CLKSOURCE_SYSCLK: u32 = 1;
pub const LL_RCC_USART1_CLKSOURCE_HSI: u32 = 2;
pub const LL_RCC_USART1_CLKSOURCE_LSE: u32 = 3;
pub const LL_RCC_LPUART1_CLKSOURCE_PCLK1: u32 = 0;
pub const LL_RCC_LPUART1_CLKSOURCE_SYSCLK: u32 = 1024;
pub const LL_RCC_LPUART1_CLKSOURCE_HSI: u32 = 2048;
pub const LL_RCC_LPUART1_CLKSOURCE_LSE: u32 = 3072;
pub const LL_RCC_SAI1_CLKSOURCE_PLLSAI1: u32 = 0;
pub const LL_RCC_SAI1_CLKSOURCE_PLL: u32 = 4194304;
pub const LL_RCC_SAI1_CLKSOURCE_HSI: u32 = 8388608;
pub const LL_RCC_SAI1_CLKSOURCE_PIN: u32 = 12582912;
pub const LL_RCC_CLK48_CLKSOURCE_HSI48: u32 = 0;
pub const LL_RCC_CLK48_CLKSOURCE_PLLSAI1: u32 = 67108864;
pub const LL_RCC_CLK48_CLKSOURCE_PLL: u32 = 134217728;
pub const LL_RCC_CLK48_CLKSOURCE_MSI: u32 = 201326592;
pub const LL_RCC_USB_CLKSOURCE_HSI48: u32 = 0;
pub const LL_RCC_USB_CLKSOURCE_PLLSAI1: u32 = 67108864;
pub const LL_RCC_USB_CLKSOURCE_PLL: u32 = 134217728;
pub const LL_RCC_USB_CLKSOURCE_MSI: u32 = 201326592;
pub const LL_RCC_ADC_CLKSOURCE_NONE: u32 = 0;
pub const LL_RCC_ADC_CLKSOURCE_PLLSAI1: u32 = 268435456;
pub const LL_RCC_ADC_CLKSOURCE_PLL: u32 = 536870912;
pub const LL_RCC_ADC_CLKSOURCE_SYSCLK: u32 = 805306368;
pub const LL_RCC_RNG_CLKSOURCE_CLK48: u32 = 0;
pub const LL_RCC_RNG_CLKSOURCE_LSI: u32 = 1073741824;
pub const LL_RCC_RNG_CLKSOURCE_LSE: u32 = 2147483648;
pub const LL_RCC_USART1_CLKSOURCE: u32 = 3;
pub const LL_RCC_LPUART1_CLKSOURCE: u32 = 3072;
pub const LL_RCC_I2C1_CLKSOURCE: u32 = 12288;
pub const LL_RCC_I2C3_CLKSOURCE: u32 = 196608;
pub const LL_RCC_LPTIM1_CLKSOURCE: u32 = 786432;
pub const LL_RCC_LPTIM2_CLKSOURCE: u32 = 3145728;
pub const LL_RCC_SAI1_CLKSOURCE: u32 = 12582912;
pub const LL_RCC_CLK48_CLKSOURCE: u32 = 201326592;
pub const LL_RCC_USB_CLKSOURCE: u32 = 201326592;
pub const LL_RCC_RNG_CLKSOURCE: u32 = 3221225472;
pub const LL_RCC_ADC_CLKSOURCE: u32 = 805306368;
pub const LL_RCC_RTC_CLKSOURCE_NONE: u32 = 0;
pub const LL_RCC_RTC_CLKSOURCE_LSE: u32 = 256;
pub const LL_RCC_RTC_CLKSOURCE_LSI: u32 = 512;
pub const LL_RCC_RTC_CLKSOURCE_HSE_DIV32: u32 = 768;
pub const LL_RCC_RFWKP_CLKSOURCE_NONE: u32 = 0;
pub const LL_RCC_RFWKP_CLKSOURCE_LSE: u32 = 16384;
pub const LL_RCC_RFWKP_CLKSOURCE_HSE_DIV1024: u32 = 49152;
pub const LL_RCC_PLLSOURCE_NONE: u32 = 0;
pub const LL_RCC_PLLSOURCE_MSI: u32 = 1;
pub const LL_RCC_PLLSOURCE_HSI: u32 = 2;
pub const LL_RCC_PLLSOURCE_HSE: u32 = 3;
pub const LL_RCC_PLLM_DIV_1: u32 = 0;
pub const LL_RCC_PLLM_DIV_2: u32 = 16;
pub const LL_RCC_PLLM_DIV_3: u32 = 32;
pub const LL_RCC_PLLM_DIV_4: u32 = 48;
pub const LL_RCC_PLLM_DIV_5: u32 = 64;
pub const LL_RCC_PLLM_DIV_6: u32 = 80;
pub const LL_RCC_PLLM_DIV_7: u32 = 96;
pub const LL_RCC_PLLM_DIV_8: u32 = 112;
pub const LL_RCC_PLLR_DIV_2: u32 = 536870912;
pub const LL_RCC_PLLR_DIV_3: u32 = 1073741824;
pub const LL_RCC_PLLR_DIV_4: u32 = 1610612736;
pub const LL_RCC_PLLR_DIV_5: u32 = 2147483648;
pub const LL_RCC_PLLR_DIV_6: u32 = 2684354560;
pub const LL_RCC_PLLR_DIV_7: u32 = 3221225472;
pub const LL_RCC_PLLR_DIV_8: u32 = 3758096384;
pub const LL_RCC_PLLP_DIV_2: u32 = 131072;
pub const LL_RCC_PLLP_DIV_3: u32 = 262144;
pub const LL_RCC_PLLP_DIV_4: u32 = 393216;
pub const LL_RCC_PLLP_DIV_5: u32 = 524288;
pub const LL_RCC_PLLP_DIV_6: u32 = 655360;
pub const LL_RCC_PLLP_DIV_7: u32 = 786432;
pub const LL_RCC_PLLP_DIV_8: u32 = 917504;
pub const LL_RCC_PLLP_DIV_9: u32 = 1048576;
pub const LL_RCC_PLLP_DIV_10: u32 = 1179648;
pub const LL_RCC_PLLP_DIV_11: u32 = 1310720;
pub const LL_RCC_PLLP_DIV_12: u32 = 1441792;
pub const LL_RCC_PLLP_DIV_13: u32 = 1572864;
pub const LL_RCC_PLLP_DIV_14: u32 = 1703936;
pub const LL_RCC_PLLP_DIV_15: u32 = 1835008;
pub const LL_RCC_PLLP_DIV_16: u32 = 1966080;
pub const LL_RCC_PLLP_DIV_17: u32 = 2097152;
pub const LL_RCC_PLLP_DIV_18: u32 = 2228224;
pub const LL_RCC_PLLP_DIV_19: u32 = 2359296;
pub const LL_RCC_PLLP_DIV_20: u32 = 2490368;
pub const LL_RCC_PLLP_DIV_21: u32 = 2621440;
pub const LL_RCC_PLLP_DIV_22: u32 = 2752512;
pub const LL_RCC_PLLP_DIV_23: u32 = 2883584;
pub const LL_RCC_PLLP_DIV_24: u32 = 3014656;
pub const LL_RCC_PLLP_DIV_25: u32 = 3145728;
pub const LL_RCC_PLLP_DIV_26: u32 = 3276800;
pub const LL_RCC_PLLP_DIV_27: u32 = 3407872;
pub const LL_RCC_PLLP_DIV_28: u32 = 3538944;
pub const LL_RCC_PLLP_DIV_29: u32 = 3670016;
pub const LL_RCC_PLLP_DIV_30: u32 = 3801088;
pub const LL_RCC_PLLP_DIV_31: u32 = 3932160;
pub const LL_RCC_PLLP_DIV_32: u32 = 4063232;
pub const LL_RCC_PLLQ_DIV_2: u32 = 33554432;
pub const LL_RCC_PLLQ_DIV_3: u32 = 67108864;
pub const LL_RCC_PLLQ_DIV_4: u32 = 100663296;
pub const LL_RCC_PLLQ_DIV_5: u32 = 134217728;
pub const LL_RCC_PLLQ_DIV_6: u32 = 167772160;
pub const LL_RCC_PLLQ_DIV_7: u32 = 201326592;
pub const LL_RCC_PLLQ_DIV_8: u32 = 234881024;
pub const LL_RCC_PLLSAI1Q_DIV_2: u32 = 33554432;
pub const LL_RCC_PLLSAI1Q_DIV_3: u32 = 67108864;
pub const LL_RCC_PLLSAI1Q_DIV_4: u32 = 100663296;
pub const LL_RCC_PLLSAI1Q_DIV_5: u32 = 134217728;
pub const LL_RCC_PLLSAI1Q_DIV_6: u32 = 167772160;
pub const LL_RCC_PLLSAI1Q_DIV_7: u32 = 201326592;
pub const LL_RCC_PLLSAI1Q_DIV_8: u32 = 234881024;
pub const LL_RCC_PLLSAI1P_DIV_2: u32 = 131072;
pub const LL_RCC_PLLSAI1P_DIV_3: u32 = 262144;
pub const LL_RCC_PLLSAI1P_DIV_4: u32 = 393216;
pub const LL_RCC_PLLSAI1P_DIV_5: u32 = 524288;
pub const LL_RCC_PLLSAI1P_DIV_6: u32 = 655360;
pub const LL_RCC_PLLSAI1P_DIV_7: u32 = 786432;
pub const LL_RCC_PLLSAI1P_DIV_8: u32 = 917504;
pub const LL_RCC_PLLSAI1P_DIV_9: u32 = 1048576;
pub const LL_RCC_PLLSAI1P_DIV_10: u32 = 1179648;
pub const LL_RCC_PLLSAI1P_DIV_11: u32 = 1310720;
pub const LL_RCC_PLLSAI1P_DIV_12: u32 = 1441792;
pub const LL_RCC_PLLSAI1P_DIV_13: u32 = 1572864;
pub const LL_RCC_PLLSAI1P_DIV_14: u32 = 1703936;
pub const LL_RCC_PLLSAI1P_DIV_15: u32 = 1835008;
pub const LL_RCC_PLLSAI1P_DIV_16: u32 = 1966080;
pub const LL_RCC_PLLSAI1P_DIV_17: u32 = 2097152;
pub const LL_RCC_PLLSAI1P_DIV_18: u32 = 2228224;
pub const LL_RCC_PLLSAI1P_DIV_19: u32 = 2359296;
pub const LL_RCC_PLLSAI1P_DIV_20: u32 = 2490368;
pub const LL_RCC_PLLSAI1P_DIV_21: u32 = 2621440;
pub const LL_RCC_PLLSAI1P_DIV_22: u32 = 2752512;
pub const LL_RCC_PLLSAI1P_DIV_23: u32 = 2883584;
pub const LL_RCC_PLLSAI1P_DIV_24: u32 = 3014656;
pub const LL_RCC_PLLSAI1P_DIV_25: u32 = 3145728;
pub const LL_RCC_PLLSAI1P_DIV_26: u32 = 3276800;
pub const LL_RCC_PLLSAI1P_DIV_27: u32 = 3407872;
pub const LL_RCC_PLLSAI1P_DIV_28: u32 = 3538944;
pub const LL_RCC_PLLSAI1P_DIV_29: u32 = 3670016;
pub const LL_RCC_PLLSAI1P_DIV_30: u32 = 3801088;
pub const LL_RCC_PLLSAI1P_DIV_31: u32 = 3932160;
pub const LL_RCC_PLLSAI1P_DIV_32: u32 = 4063232;
pub const LL_RCC_PLLSAI1R_DIV_2: u32 = 536870912;
pub const LL_RCC_PLLSAI1R_DIV_3: u32 = 1073741824;
pub const LL_RCC_PLLSAI1R_DIV_4: u32 = 1610612736;
pub const LL_RCC_PLLSAI1R_DIV_5: u32 = 2147483648;
pub const LL_RCC_PLLSAI1R_DIV_6: u32 = 2684354560;
pub const LL_RCC_PLLSAI1R_DIV_7: u32 = 3221225472;
pub const LL_RCC_PLLSAI1R_DIV_8: u32 = 3758096384;
pub const FURI_HAL_FLASH_OB_RAW_SIZE_BYTES: u32 = 128;
pub const LL_I2C_ICR_ADDRCF: u32 = 8;
pub const LL_I2C_ICR_NACKCF: u32 = 16;
pub const LL_I2C_ICR_STOPCF: u32 = 32;
pub const LL_I2C_ICR_BERRCF: u32 = 256;
pub const LL_I2C_ICR_ARLOCF: u32 = 512;
pub const LL_I2C_ICR_OVRCF: u32 = 1024;
pub const LL_I2C_ICR_PECCF: u32 = 2048;
pub const LL_I2C_ICR_TIMOUTCF: u32 = 4096;
pub const LL_I2C_ICR_ALERTCF: u32 = 8192;
pub const LL_I2C_ISR_TXE: u32 = 1;
pub const LL_I2C_ISR_TXIS: u32 = 2;
pub const LL_I2C_ISR_RXNE: u32 = 4;
pub const LL_I2C_ISR_ADDR: u32 = 8;
pub const LL_I2C_ISR_NACKF: u32 = 16;
pub const LL_I2C_ISR_STOPF: u32 = 32;
pub const LL_I2C_ISR_TC: u32 = 64;
pub const LL_I2C_ISR_TCR: u32 = 128;
pub const LL_I2C_ISR_BERR: u32 = 256;
pub const LL_I2C_ISR_ARLO: u32 = 512;
pub const LL_I2C_ISR_OVR: u32 = 1024;
pub const LL_I2C_ISR_PECERR: u32 = 2048;
pub const LL_I2C_ISR_TIMEOUT: u32 = 4096;
pub const LL_I2C_ISR_ALERT: u32 = 8192;
pub const LL_I2C_ISR_BUSY: u32 = 32768;
pub const LL_I2C_CR1_TXIE: u32 = 2;
pub const LL_I2C_CR1_RXIE: u32 = 4;
pub const LL_I2C_CR1_ADDRIE: u32 = 8;
pub const LL_I2C_CR1_NACKIE: u32 = 16;
pub const LL_I2C_CR1_STOPIE: u32 = 32;
pub const LL_I2C_CR1_TCIE: u32 = 64;
pub const LL_I2C_CR1_ERRIE: u32 = 128;
pub const LL_I2C_MODE_I2C: u32 = 0;
pub const LL_I2C_MODE_SMBUS_HOST: u32 = 1048576;
pub const LL_I2C_MODE_SMBUS_DEVICE: u32 = 0;
pub const LL_I2C_MODE_SMBUS_DEVICE_ARP: u32 = 2097152;
pub const LL_I2C_ANALOGFILTER_ENABLE: u32 = 0;
pub const LL_I2C_ANALOGFILTER_DISABLE: u32 = 4096;
pub const LL_I2C_ADDRESSING_MODE_7BIT: u32 = 0;
pub const LL_I2C_ADDRESSING_MODE_10BIT: u32 = 2048;
pub const LL_I2C_OWNADDRESS1_7BIT: u32 = 0;
pub const LL_I2C_OWNADDRESS1_10BIT: u32 = 1024;
pub const LL_I2C_OWNADDRESS2_NOMASK: u32 = 0;
pub const LL_I2C_OWNADDRESS2_MASK01: u32 = 256;
pub const LL_I2C_OWNADDRESS2_MASK02: u32 = 512;
pub const LL_I2C_OWNADDRESS2_MASK03: u32 = 768;
pub const LL_I2C_OWNADDRESS2_MASK04: u32 = 1024;
pub const LL_I2C_OWNADDRESS2_MASK05: u32 = 1280;
pub const LL_I2C_OWNADDRESS2_MASK06: u32 = 1536;
pub const LL_I2C_OWNADDRESS2_MASK07: u32 = 1792;
pub const LL_I2C_ACK: u32 = 0;
pub const LL_I2C_NACK: u32 = 32768;
pub const LL_I2C_ADDRSLAVE_7BIT: u32 = 0;
pub const LL_I2C_ADDRSLAVE_10BIT: u32 = 2048;
pub const LL_I2C_REQUEST_WRITE: u32 = 0;
pub const LL_I2C_REQUEST_READ: u32 = 1024;
pub const LL_I2C_MODE_RELOAD: u32 = 16777216;
pub const LL_I2C_MODE_AUTOEND: u32 = 33554432;
pub const LL_I2C_MODE_SOFTEND: u32 = 0;
pub const LL_I2C_MODE_SMBUS_RELOAD: u32 = 16777216;
pub const LL_I2C_MODE_SMBUS_AUTOEND_NO_PEC: u32 = 33554432;
pub const LL_I2C_MODE_SMBUS_SOFTEND_NO_PEC: u32 = 0;
pub const LL_I2C_GENERATE_NOSTARTSTOP: u32 = 0;
pub const LL_I2C_DIRECTION_WRITE: u32 = 0;
pub const LL_I2C_DIRECTION_READ: u32 = 65536;
pub const LL_I2C_DMA_REG_DATA_TRANSMIT: u32 = 0;
pub const LL_I2C_DMA_REG_DATA_RECEIVE: u32 = 1;
pub const LL_I2C_SMBUS_TIMEOUTA_MODE_SCL_LOW: u32 = 0;
pub const LL_I2C_SMBUS_TIMEOUTA_MODE_SDA_SCL_HIGH: u32 = 4096;
pub const LL_I2C_SMBUS_TIMEOUTA: u32 = 32768;
pub const LL_I2C_SMBUS_TIMEOUTB: u32 = 2147483648;
pub const LL_LPTIM_ISR_CMPM: u32 = 1;
pub const LL_LPTIM_ISR_CMPOK: u32 = 8;
pub const LL_LPTIM_ISR_ARRM: u32 = 2;
pub const LL_LPTIM_ISR_EXTTRIG: u32 = 4;
pub const LL_LPTIM_ISR_ARROK: u32 = 16;
pub const LL_LPTIM_ISR_UP: u32 = 32;
pub const LL_LPTIM_ISR_DOWN: u32 = 64;
pub const LL_LPTIM_IER_CMPMIE: u32 = 1;
pub const LL_LPTIM_IER_CMPOKIE: u32 = 8;
pub const LL_LPTIM_IER_ARRMIE: u32 = 2;
pub const LL_LPTIM_IER_EXTTRIGIE: u32 = 4;
pub const LL_LPTIM_IER_ARROKIE: u32 = 16;
pub const LL_LPTIM_IER_UPIE: u32 = 32;
pub const LL_LPTIM_IER_DOWNIE: u32 = 64;
pub const LL_LPTIM_OPERATING_MODE_CONTINUOUS: u32 = 4;
pub const LL_LPTIM_OPERATING_MODE_ONESHOT: u32 = 2;
pub const LL_LPTIM_UPDATE_MODE_IMMEDIATE: u32 = 0;
pub const LL_LPTIM_UPDATE_MODE_ENDOFPERIOD: u32 = 4194304;
pub const LL_LPTIM_COUNTER_MODE_INTERNAL: u32 = 0;
pub const LL_LPTIM_COUNTER_MODE_EXTERNAL: u32 = 8388608;
pub const LL_LPTIM_OUTPUT_WAVEFORM_PWM: u32 = 0;
pub const LL_LPTIM_OUTPUT_WAVEFORM_SETONCE: u32 = 1048576;
pub const LL_LPTIM_OUTPUT_POLARITY_REGULAR: u32 = 0;
pub const LL_LPTIM_OUTPUT_POLARITY_INVERSE: u32 = 2097152;
pub const LL_LPTIM_PRESCALER_DIV1: u32 = 0;
pub const LL_LPTIM_PRESCALER_DIV2: u32 = 512;
pub const LL_LPTIM_PRESCALER_DIV4: u32 = 1024;
pub const LL_LPTIM_PRESCALER_DIV8: u32 = 1536;
pub const LL_LPTIM_PRESCALER_DIV16: u32 = 2048;
pub const LL_LPTIM_PRESCALER_DIV32: u32 = 2560;
pub const LL_LPTIM_PRESCALER_DIV64: u32 = 3072;
pub const LL_LPTIM_PRESCALER_DIV128: u32 = 3584;
pub const LL_LPTIM_TRIG_SOURCE_GPIO: u32 = 0;
pub const LL_LPTIM_TRIG_SOURCE_RTCALARMA: u32 = 8192;
pub const LL_LPTIM_TRIG_SOURCE_RTCALARMB: u32 = 16384;
pub const LL_LPTIM_TRIG_SOURCE_RTCTAMP1: u32 = 24576;
pub const LL_LPTIM_TRIG_SOURCE_RTCTAMP2: u32 = 32768;
pub const LL_LPTIM_TRIG_SOURCE_RTCTAMP3: u32 = 40960;
pub const LL_LPTIM_TRIG_SOURCE_COMP1: u32 = 49152;
pub const LL_LPTIM_TRIG_SOURCE_COMP2: u32 = 57344;
pub const LL_LPTIM_TRIG_FILTER_NONE: u32 = 0;
pub const LL_LPTIM_TRIG_FILTER_2: u32 = 64;
pub const LL_LPTIM_TRIG_FILTER_4: u32 = 128;
pub const LL_LPTIM_TRIG_FILTER_8: u32 = 192;
pub const LL_LPTIM_TRIG_POLARITY_RISING: u32 = 131072;
pub const LL_LPTIM_TRIG_POLARITY_FALLING: u32 = 262144;
pub const LL_LPTIM_TRIG_POLARITY_RISING_FALLING: u32 = 393216;
pub const LL_LPTIM_CLK_SOURCE_INTERNAL: u32 = 0;
pub const LL_LPTIM_CLK_SOURCE_EXTERNAL: u32 = 1;
pub const LL_LPTIM_CLK_FILTER_NONE: u32 = 0;
pub const LL_LPTIM_CLK_FILTER_2: u32 = 8;
pub const LL_LPTIM_CLK_FILTER_4: u32 = 16;
pub const LL_LPTIM_CLK_FILTER_8: u32 = 24;
pub const LL_LPTIM_CLK_POLARITY_RISING: u32 = 0;
pub const LL_LPTIM_CLK_POLARITY_FALLING: u32 = 2;
pub const LL_LPTIM_CLK_POLARITY_RISING_FALLING: u32 = 4;
pub const LL_LPTIM_ENCODER_MODE_RISING: u32 = 0;
pub const LL_LPTIM_ENCODER_MODE_FALLING: u32 = 2;
pub const LL_LPTIM_ENCODER_MODE_RISING_FALLING: u32 = 4;
pub const LL_LPTIM_INPUT1_SRC_GPIO: u32 = 0;
pub const LL_LPTIM_INPUT1_SRC_COMP1: u32 = 1;
pub const LL_LPTIM_INPUT1_SRC_COMP2: u32 = 2;
pub const LL_LPTIM_INPUT1_SRC_COMP1_COMP2: u32 = 3;
pub const LL_LPTIM_INPUT2_SRC_GPIO: u32 = 0;
pub const LL_LPTIM_INPUT2_SRC_COMP2: u32 = 2;
pub const LL_AHB1_GRP1_PERIPH_ALL: u32 = 4294967295;
pub const LL_AHB1_GRP1_PERIPH_DMA1: u32 = 1;
pub const LL_AHB1_GRP1_PERIPH_DMA2: u32 = 2;
pub const LL_AHB1_GRP1_PERIPH_DMAMUX1: u32 = 4;
pub const LL_AHB1_GRP1_PERIPH_SRAM1: u32 = 512;
pub const LL_AHB1_GRP1_PERIPH_CRC: u32 = 4096;
pub const LL_AHB1_GRP1_PERIPH_TSC: u32 = 65536;
pub const LL_AHB2_GRP1_PERIPH_ALL: u32 = 4294967295;
pub const LL_AHB2_GRP1_PERIPH_GPIOA: u32 = 1;
pub const LL_AHB2_GRP1_PERIPH_GPIOB: u32 = 2;
pub const LL_AHB2_GRP1_PERIPH_GPIOC: u32 = 4;
pub const LL_AHB2_GRP1_PERIPH_GPIOD: u32 = 8;
pub const LL_AHB2_GRP1_PERIPH_GPIOE: u32 = 16;
pub const LL_AHB2_GRP1_PERIPH_GPIOH: u32 = 128;
pub const LL_AHB2_GRP1_PERIPH_ADC: u32 = 8192;
pub const LL_AHB2_GRP1_PERIPH_AES1: u32 = 65536;
pub const LL_AHB3_GRP1_PERIPH_ALL: u32 = 4294967295;
pub const LL_AHB3_GRP1_PERIPH_QUADSPI: u32 = 256;
pub const LL_AHB3_GRP1_PERIPH_PKA: u32 = 65536;
pub const LL_AHB3_GRP1_PERIPH_AES2: u32 = 131072;
pub const LL_AHB3_GRP1_PERIPH_RNG: u32 = 262144;
pub const LL_AHB3_GRP1_PERIPH_HSEM: u32 = 524288;
pub const LL_AHB3_GRP1_PERIPH_IPCC: u32 = 1048576;
pub const LL_AHB3_GRP1_PERIPH_SRAM2: u32 = 16777216;
pub const LL_AHB3_GRP1_PERIPH_FLASH: u32 = 33554432;
pub const LL_APB1_GRP1_PERIPH_ALL: u32 = 4294967295;
pub const LL_APB1_GRP1_PERIPH_TIM2: u32 = 1;
pub const LL_APB1_GRP1_PERIPH_LCD: u32 = 512;
pub const LL_APB1_GRP1_PERIPH_RTCAPB: u32 = 1024;
pub const LL_APB1_GRP1_PERIPH_WWDG: u32 = 2048;
pub const LL_APB1_GRP1_PERIPH_SPI2: u32 = 16384;
pub const LL_APB1_GRP1_PERIPH_I2C1: u32 = 2097152;
pub const LL_APB1_GRP1_PERIPH_I2C3: u32 = 8388608;
pub const LL_APB1_GRP1_PERIPH_CRS: u32 = 16777216;
pub const LL_APB1_GRP1_PERIPH_USB: u32 = 67108864;
pub const LL_APB1_GRP1_PERIPH_LPTIM1: u32 = 2147483648;
pub const LL_APB1_GRP2_PERIPH_ALL: u32 = 4294967295;
pub const LL_APB1_GRP2_PERIPH_LPUART1: u32 = 1;
pub const LL_APB1_GRP2_PERIPH_LPTIM2: u32 = 32;
pub const LL_APB2_GRP1_PERIPH_ALL: u32 = 4294967295;
pub const LL_APB2_GRP1_PERIPH_TIM1: u32 = 2048;
pub const LL_APB2_GRP1_PERIPH_SPI1: u32 = 4096;
pub const LL_APB2_GRP1_PERIPH_USART1: u32 = 16384;
pub const LL_APB2_GRP1_PERIPH_TIM16: u32 = 131072;
pub const LL_APB2_GRP1_PERIPH_TIM17: u32 = 262144;
pub const LL_APB2_GRP1_PERIPH_SAI1: u32 = 2097152;
pub const LL_APB3_GRP1_PERIPH_ALL: u32 = 4294967295;
pub const LL_APB3_GRP1_PERIPH_RF: u32 = 1;
pub const LL_C2_AHB1_GRP1_PERIPH_DMA1: u32 = 1;
pub const LL_C2_AHB1_GRP1_PERIPH_DMA2: u32 = 2;
pub const LL_C2_AHB1_GRP1_PERIPH_DMAMUX1: u32 = 4;
pub const LL_C2_AHB1_GRP1_PERIPH_SRAM1: u32 = 512;
pub const LL_C2_AHB1_GRP1_PERIPH_CRC: u32 = 4096;
pub const LL_C2_AHB1_GRP1_PERIPH_TSC: u32 = 65536;
pub const LL_C2_AHB2_GRP1_PERIPH_GPIOA: u32 = 1;
pub const LL_C2_AHB2_GRP1_PERIPH_GPIOB: u32 = 2;
pub const LL_C2_AHB2_GRP1_PERIPH_GPIOC: u32 = 4;
pub const LL_C2_AHB2_GRP1_PERIPH_GPIOD: u32 = 8;
pub const LL_C2_AHB2_GRP1_PERIPH_GPIOE: u32 = 16;
pub const LL_C2_AHB2_GRP1_PERIPH_GPIOH: u32 = 128;
pub const LL_C2_AHB2_GRP1_PERIPH_ADC: u32 = 8192;
pub const LL_C2_AHB2_GRP1_PERIPH_AES1: u32 = 65536;
pub const LL_C2_AHB3_GRP1_PERIPH_PKA: u32 = 65536;
pub const LL_C2_AHB3_GRP1_PERIPH_AES2: u32 = 131072;
pub const LL_C2_AHB3_GRP1_PERIPH_RNG: u32 = 262144;
pub const LL_C2_AHB3_GRP1_PERIPH_HSEM: u32 = 524288;
pub const LL_C2_AHB3_GRP1_PERIPH_IPCC: u32 = 1048576;
pub const LL_C2_AHB3_GRP1_PERIPH_FLASH: u32 = 33554432;
pub const LL_C2_AHB3_GRP1_PERIPH_SRAM2: u32 = 16777216;
pub const LL_C2_APB1_GRP1_PERIPH_TIM2: u32 = 1;
pub const LL_C2_APB1_GRP1_PERIPH_LCD: u32 = 512;
pub const LL_C2_APB1_GRP1_PERIPH_RTCAPB: u32 = 1024;
pub const LL_C2_APB1_GRP1_PERIPH_SPI2: u32 = 16384;
pub const LL_C2_APB1_GRP1_PERIPH_I2C1: u32 = 2097152;
pub const LL_C2_APB1_GRP1_PERIPH_I2C3: u32 = 8388608;
pub const LL_C2_APB1_GRP1_PERIPH_CRS: u32 = 16777216;
pub const LL_C2_APB1_GRP1_PERIPH_USB: u32 = 67108864;
pub const LL_C2_APB1_GRP1_PERIPH_LPTIM1: u32 = 2147483648;
pub const LL_C2_APB1_GRP2_PERIPH_LPUART1: u32 = 1;
pub const LL_C2_APB1_GRP2_PERIPH_LPTIM2: u32 = 32;
pub const LL_C2_APB2_GRP1_PERIPH_TIM1: u32 = 2048;
pub const LL_C2_APB2_GRP1_PERIPH_SPI1: u32 = 4096;
pub const LL_C2_APB2_GRP1_PERIPH_USART1: u32 = 16384;
pub const LL_C2_APB2_GRP1_PERIPH_TIM16: u32 = 131072;
pub const LL_C2_APB2_GRP1_PERIPH_TIM17: u32 = 262144;
pub const LL_C2_APB2_GRP1_PERIPH_SAI1: u32 = 2097152;
pub const LL_C2_APB3_GRP1_PERIPH_BLE: u32 = 1;
pub const LL_C2_APB3_GRP1_PERIPH_802: u32 = 2;
pub const FURI_HAL_IDLE_TIMER_MAX: u32 = 65535;
pub const TIMx_AF1_BKINP: u32 = 512;
pub const TIMx_AF1_ETRSEL: u32 = 114688;
pub const TIMx_OR_RMP_SHIFT: u32 = 16;
pub const TIMx_OR_RMP_MASK: u32 = 65535;
pub const TIM1_OR_RMP_MASK: u32 = 1245184;
pub const TIM2_OR_RMP_MASK: u32 = 983040;
pub const TIM16_OR_RMP_MASK: u32 = 196608;
pub const TIM17_OR_RMP_MASK: u32 = 196608;
pub const LL_TIM_SR_UIF: u32 = 1;
pub const LL_TIM_SR_CC1IF: u32 = 2;
pub const LL_TIM_SR_CC2IF: u32 = 4;
pub const LL_TIM_SR_CC3IF: u32 = 8;
pub const LL_TIM_SR_CC4IF: u32 = 16;
pub const LL_TIM_SR_CC5IF: u32 = 65536;
pub const LL_TIM_SR_CC6IF: u32 = 131072;
pub const LL_TIM_SR_COMIF: u32 = 32;
pub const LL_TIM_SR_TIF: u32 = 64;
pub const LL_TIM_SR_BIF: u32 = 128;
pub const LL_TIM_SR_B2IF: u32 = 256;
pub const LL_TIM_SR_CC1OF: u32 = 512;
pub const LL_TIM_SR_CC2OF: u32 = 1024;
pub const LL_TIM_SR_CC3OF: u32 = 2048;
pub const LL_TIM_SR_CC4OF: u32 = 4096;
pub const LL_TIM_SR_SBIF: u32 = 8192;
pub const LL_TIM_BREAK_DISABLE: u32 = 0;
pub const LL_TIM_BREAK_ENABLE: u32 = 4096;
pub const LL_TIM_BREAK2_DISABLE: u32 = 0;
pub const LL_TIM_BREAK2_ENABLE: u32 = 16777216;
pub const LL_TIM_AUTOMATICOUTPUT_DISABLE: u32 = 0;
pub const LL_TIM_AUTOMATICOUTPUT_ENABLE: u32 = 16384;
pub const LL_TIM_DIER_UIE: u32 = 1;
pub const LL_TIM_DIER_CC1IE: u32 = 2;
pub const LL_TIM_DIER_CC2IE: u32 = 4;
pub const LL_TIM_DIER_CC3IE: u32 = 8;
pub const LL_TIM_DIER_CC4IE: u32 = 16;
pub const LL_TIM_DIER_COMIE: u32 = 32;
pub const LL_TIM_DIER_TIE: u32 = 64;
pub const LL_TIM_DIER_BIE: u32 = 128;
pub const LL_TIM_UPDATESOURCE_REGULAR: u32 = 0;
pub const LL_TIM_UPDATESOURCE_COUNTER: u32 = 4;
pub const LL_TIM_ONEPULSEMODE_SINGLE: u32 = 8;
pub const LL_TIM_ONEPULSEMODE_REPETITIVE: u32 = 0;
pub const LL_TIM_COUNTERMODE_UP: u32 = 0;
pub const LL_TIM_COUNTERMODE_DOWN: u32 = 16;
pub const LL_TIM_COUNTERMODE_CENTER_DOWN: u32 = 32;
pub const LL_TIM_COUNTERMODE_CENTER_UP: u32 = 64;
pub const LL_TIM_COUNTERMODE_CENTER_UP_DOWN: u32 = 96;
pub const LL_TIM_CLOCKDIVISION_DIV1: u32 = 0;
pub const LL_TIM_CLOCKDIVISION_DIV2: u32 = 256;
pub const LL_TIM_CLOCKDIVISION_DIV4: u32 = 512;
pub const LL_TIM_COUNTERDIRECTION_UP: u32 = 0;
pub const LL_TIM_COUNTERDIRECTION_DOWN: u32 = 16;
pub const LL_TIM_CCUPDATESOURCE_COMG_ONLY: u32 = 0;
pub const LL_TIM_CCUPDATESOURCE_COMG_AND_TRGI: u32 = 4;
pub const LL_TIM_CCDMAREQUEST_CC: u32 = 0;
pub const LL_TIM_CCDMAREQUEST_UPDATE: u32 = 8;
pub const LL_TIM_LOCKLEVEL_OFF: u32 = 0;
pub const LL_TIM_LOCKLEVEL_1: u32 = 256;
pub const LL_TIM_LOCKLEVEL_2: u32 = 512;
pub const LL_TIM_LOCKLEVEL_3: u32 = 768;
pub const LL_TIM_CHANNEL_CH1: u32 = 1;
pub const LL_TIM_CHANNEL_CH1N: u32 = 4;
pub const LL_TIM_CHANNEL_CH2: u32 = 16;
pub const LL_TIM_CHANNEL_CH2N: u32 = 64;
pub const LL_TIM_CHANNEL_CH3: u32 = 256;
pub const LL_TIM_CHANNEL_CH3N: u32 = 1024;
pub const LL_TIM_CHANNEL_CH4: u32 = 4096;
pub const LL_TIM_CHANNEL_CH5: u32 = 65536;
pub const LL_TIM_CHANNEL_CH6: u32 = 1048576;
pub const LL_TIM_OCSTATE_DISABLE: u32 = 0;
pub const LL_TIM_OCSTATE_ENABLE: u32 = 1;
pub const LL_TIM_OCMODE_FROZEN: u32 = 0;
pub const LL_TIM_OCMODE_ACTIVE: u32 = 16;
pub const LL_TIM_OCMODE_INACTIVE: u32 = 32;
pub const LL_TIM_OCMODE_TOGGLE: u32 = 48;
pub const LL_TIM_OCMODE_FORCED_INACTIVE: u32 = 64;
pub const LL_TIM_OCMODE_FORCED_ACTIVE: u32 = 80;
pub const LL_TIM_OCMODE_PWM1: u32 = 96;
pub const LL_TIM_OCMODE_PWM2: u32 = 112;
pub const LL_TIM_OCMODE_RETRIG_OPM1: u32 = 65536;
pub const LL_TIM_OCMODE_RETRIG_OPM2: u32 = 65552;
pub const LL_TIM_OCMODE_COMBINED_PWM1: u32 = 65600;
pub const LL_TIM_OCMODE_COMBINED_PWM2: u32 = 65616;
pub const LL_TIM_OCMODE_ASSYMETRIC_PWM1: u32 = 65632;
pub const LL_TIM_OCMODE_ASSYMETRIC_PWM2: u32 = 65648;
pub const LL_TIM_OCPOLARITY_HIGH: u32 = 0;
pub const LL_TIM_OCPOLARITY_LOW: u32 = 2;
pub const LL_TIM_OCIDLESTATE_LOW: u32 = 0;
pub const LL_TIM_OCIDLESTATE_HIGH: u32 = 256;
pub const LL_TIM_GROUPCH5_NONE: u32 = 0;
pub const LL_TIM_GROUPCH5_OC1REFC: u32 = 536870912;
pub const LL_TIM_GROUPCH5_OC2REFC: u32 = 1073741824;
pub const LL_TIM_GROUPCH5_OC3REFC: u32 = 2147483648;
pub const LL_TIM_ACTIVEINPUT_DIRECTTI: u32 = 65536;
pub const LL_TIM_ACTIVEINPUT_INDIRECTTI: u32 = 131072;
pub const LL_TIM_ACTIVEINPUT_TRC: u32 = 196608;
pub const LL_TIM_ICPSC_DIV1: u32 = 0;
pub const LL_TIM_ICPSC_DIV2: u32 = 262144;
pub const LL_TIM_ICPSC_DIV4: u32 = 524288;
pub const LL_TIM_ICPSC_DIV8: u32 = 786432;
pub const LL_TIM_IC_FILTER_FDIV1: u32 = 0;
pub const LL_TIM_IC_FILTER_FDIV1_N2: u32 = 1048576;
pub const LL_TIM_IC_FILTER_FDIV1_N4: u32 = 2097152;
pub const LL_TIM_IC_FILTER_FDIV1_N8: u32 = 3145728;
pub const LL_TIM_IC_FILTER_FDIV2_N6: u32 = 4194304;
pub const LL_TIM_IC_FILTER_FDIV2_N8: u32 = 5242880;
pub const LL_TIM_IC_FILTER_FDIV4_N6: u32 = 6291456;
pub const LL_TIM_IC_FILTER_FDIV4_N8: u32 = 7340032;
pub const LL_TIM_IC_FILTER_FDIV8_N6: u32 = 8388608;
pub const LL_TIM_IC_FILTER_FDIV8_N8: u32 = 9437184;
pub const LL_TIM_IC_FILTER_FDIV16_N5: u32 = 10485760;
pub const LL_TIM_IC_FILTER_FDIV16_N6: u32 = 11534336;
pub const LL_TIM_IC_FILTER_FDIV16_N8: u32 = 12582912;
pub const LL_TIM_IC_FILTER_FDIV32_N5: u32 = 13631488;
pub const LL_TIM_IC_FILTER_FDIV32_N6: u32 = 14680064;
pub const LL_TIM_IC_FILTER_FDIV32_N8: u32 = 15728640;
pub const LL_TIM_IC_POLARITY_RISING: u32 = 0;
pub const LL_TIM_IC_POLARITY_FALLING: u32 = 2;
pub const LL_TIM_IC_POLARITY_BOTHEDGE: u32 = 10;
pub const LL_TIM_CLOCKSOURCE_INTERNAL: u32 = 0;
pub const LL_TIM_CLOCKSOURCE_EXT_MODE1: u32 = 7;
pub const LL_TIM_CLOCKSOURCE_EXT_MODE2: u32 = 16384;
pub const LL_TIM_ENCODERMODE_X2_TI1: u32 = 1;
pub const LL_TIM_ENCODERMODE_X2_TI2: u32 = 2;
pub const LL_TIM_ENCODERMODE_X4_TI12: u32 = 3;
pub const LL_TIM_TRGO_RESET: u32 = 0;
pub const LL_TIM_TRGO_ENABLE: u32 = 16;
pub const LL_TIM_TRGO_UPDATE: u32 = 32;
pub const LL_TIM_TRGO_CC1IF: u32 = 48;
pub const LL_TIM_TRGO_OC1REF: u32 = 64;
pub const LL_TIM_TRGO_OC2REF: u32 = 80;
pub const LL_TIM_TRGO_OC3REF: u32 = 96;
pub const LL_TIM_TRGO_OC4REF: u32 = 112;
pub const LL_TIM_TRGO2_RESET: u32 = 0;
pub const LL_TIM_TRGO2_ENABLE: u32 = 1048576;
pub const LL_TIM_TRGO2_UPDATE: u32 = 2097152;
pub const LL_TIM_TRGO2_CC1F: u32 = 3145728;
pub const LL_TIM_TRGO2_OC1: u32 = 4194304;
pub const LL_TIM_TRGO2_OC2: u32 = 5242880;
pub const LL_TIM_TRGO2_OC3: u32 = 6291456;
pub const LL_TIM_TRGO2_OC4: u32 = 7340032;
pub const LL_TIM_TRGO2_OC5: u32 = 8388608;
pub const LL_TIM_TRGO2_OC6: u32 = 9437184;
pub const LL_TIM_TRGO2_OC4_RISINGFALLING: u32 = 10485760;
pub const LL_TIM_TRGO2_OC6_RISINGFALLING: u32 = 11534336;
pub const LL_TIM_TRGO2_OC4_RISING_OC6_RISING: u32 = 12582912;
pub const LL_TIM_TRGO2_OC4_RISING_OC6_FALLING: u32 = 13631488;
pub const LL_TIM_TRGO2_OC5_RISING_OC6_RISING: u32 = 14680064;
pub const LL_TIM_TRGO2_OC5_RISING_OC6_FALLING: u32 = 15728640;
pub const LL_TIM_SLAVEMODE_DISABLED: u32 = 0;
pub const LL_TIM_SLAVEMODE_RESET: u32 = 4;
pub const LL_TIM_SLAVEMODE_GATED: u32 = 5;
pub const LL_TIM_SLAVEMODE_TRIGGER: u32 = 6;
pub const LL_TIM_SLAVEMODE_COMBINED_RESETTRIGGER: u32 = 65536;
pub const LL_TIM_TS_ITR0: u32 = 0;
pub const LL_TIM_TS_ITR1: u32 = 16;
pub const LL_TIM_TS_ITR2: u32 = 32;
pub const LL_TIM_TS_ITR3: u32 = 48;
pub const LL_TIM_TS_TI1F_ED: u32 = 64;
pub const LL_TIM_TS_TI1FP1: u32 = 80;
pub const LL_TIM_TS_TI2FP2: u32 = 96;
pub const LL_TIM_TS_ETRF: u32 = 112;
pub const LL_TIM_ETR_POLARITY_NONINVERTED: u32 = 0;
pub const LL_TIM_ETR_POLARITY_INVERTED: u32 = 32768;
pub const LL_TIM_ETR_PRESCALER_DIV1: u32 = 0;
pub const LL_TIM_ETR_PRESCALER_DIV2: u32 = 4096;
pub const LL_TIM_ETR_PRESCALER_DIV4: u32 = 8192;
pub const LL_TIM_ETR_PRESCALER_DIV8: u32 = 12288;
pub const LL_TIM_ETR_FILTER_FDIV1: u32 = 0;
pub const LL_TIM_ETR_FILTER_FDIV1_N2: u32 = 256;
pub const LL_TIM_ETR_FILTER_FDIV1_N4: u32 = 512;
pub const LL_TIM_ETR_FILTER_FDIV1_N8: u32 = 768;
pub const LL_TIM_ETR_FILTER_FDIV2_N6: u32 = 1024;
pub const LL_TIM_ETR_FILTER_FDIV2_N8: u32 = 1280;
pub const LL_TIM_ETR_FILTER_FDIV4_N6: u32 = 1536;
pub const LL_TIM_ETR_FILTER_FDIV4_N8: u32 = 1792;
pub const LL_TIM_ETR_FILTER_FDIV8_N6: u32 = 2048;
pub const LL_TIM_ETR_FILTER_FDIV8_N8: u32 = 2304;
pub const LL_TIM_ETR_FILTER_FDIV16_N5: u32 = 2560;
pub const LL_TIM_ETR_FILTER_FDIV16_N6: u32 = 2816;
pub const LL_TIM_ETR_FILTER_FDIV16_N8: u32 = 3072;
pub const LL_TIM_ETR_FILTER_FDIV32_N5: u32 = 3328;
pub const LL_TIM_ETR_FILTER_FDIV32_N6: u32 = 3584;
pub const LL_TIM_ETR_FILTER_FDIV32_N8: u32 = 3840;
pub const LL_TIM_ETRSOURCE_LEGACY: u32 = 0;
pub const LL_TIM_ETRSOURCE_COMP1: u32 = 16384;
pub const LL_TIM_ETRSOURCE_COMP2: u32 = 32768;
pub const LL_TIM_ETRSOURCE_GPIO: u32 = 0;
pub const LL_TIM_ETRSOURCE_ADC1_AWD1: u32 = 0;
pub const LL_TIM_ETRSOURCE_ADC1_AWD2: u32 = 0;
pub const LL_TIM_ETRSOURCE_ADC1_AWD3: u32 = 0;
pub const LL_TIM_BREAK_POLARITY_LOW: u32 = 0;
pub const LL_TIM_BREAK_POLARITY_HIGH: u32 = 8192;
pub const LL_TIM_BREAK_FILTER_FDIV1: u32 = 0;
pub const LL_TIM_BREAK_FILTER_FDIV1_N2: u32 = 65536;
pub const LL_TIM_BREAK_FILTER_FDIV1_N4: u32 = 131072;
pub const LL_TIM_BREAK_FILTER_FDIV1_N8: u32 = 196608;
pub const LL_TIM_BREAK_FILTER_FDIV2_N6: u32 = 262144;
pub const LL_TIM_BREAK_FILTER_FDIV2_N8: u32 = 327680;
pub const LL_TIM_BREAK_FILTER_FDIV4_N6: u32 = 393216;
pub const LL_TIM_BREAK_FILTER_FDIV4_N8: u32 = 458752;
pub const LL_TIM_BREAK_FILTER_FDIV8_N6: u32 = 524288;
pub const LL_TIM_BREAK_FILTER_FDIV8_N8: u32 = 589824;
pub const LL_TIM_BREAK_FILTER_FDIV16_N5: u32 = 655360;
pub const LL_TIM_BREAK_FILTER_FDIV16_N6: u32 = 720896;
pub const LL_TIM_BREAK_FILTER_FDIV16_N8: u32 = 786432;
pub const LL_TIM_BREAK_FILTER_FDIV32_N5: u32 = 851968;
pub const LL_TIM_BREAK_FILTER_FDIV32_N6: u32 = 917504;
pub const LL_TIM_BREAK_FILTER_FDIV32_N8: u32 = 983040;
pub const LL_TIM_BREAK2_POLARITY_LOW: u32 = 0;
pub const LL_TIM_BREAK2_POLARITY_HIGH: u32 = 33554432;
pub const LL_TIM_BREAK2_FILTER_FDIV1: u32 = 0;
pub const LL_TIM_BREAK2_FILTER_FDIV1_N2: u32 = 1048576;
pub const LL_TIM_BREAK2_FILTER_FDIV1_N4: u32 = 2097152;
pub const LL_TIM_BREAK2_FILTER_FDIV1_N8: u32 = 3145728;
pub const LL_TIM_BREAK2_FILTER_FDIV2_N6: u32 = 4194304;
pub const LL_TIM_BREAK2_FILTER_FDIV2_N8: u32 = 5242880;
pub const LL_TIM_BREAK2_FILTER_FDIV4_N6: u32 = 6291456;
pub const LL_TIM_BREAK2_FILTER_FDIV4_N8: u32 = 7340032;
pub const LL_TIM_BREAK2_FILTER_FDIV8_N6: u32 = 8388608;
pub const LL_TIM_BREAK2_FILTER_FDIV8_N8: u32 = 9437184;
pub const LL_TIM_BREAK2_FILTER_FDIV16_N5: u32 = 10485760;
pub const LL_TIM_BREAK2_FILTER_FDIV16_N6: u32 = 11534336;
pub const LL_TIM_BREAK2_FILTER_FDIV16_N8: u32 = 12582912;
pub const LL_TIM_BREAK2_FILTER_FDIV32_N5: u32 = 13631488;
pub const LL_TIM_BREAK2_FILTER_FDIV32_N6: u32 = 14680064;
pub const LL_TIM_BREAK2_FILTER_FDIV32_N8: u32 = 15728640;
pub const LL_TIM_OSSI_DISABLE: u32 = 0;
pub const LL_TIM_OSSI_ENABLE: u32 = 1024;
pub const LL_TIM_OSSR_DISABLE: u32 = 0;
pub const LL_TIM_OSSR_ENABLE: u32 = 2048;
pub const LL_TIM_BREAK_INPUT_BKIN: u32 = 0;
pub const LL_TIM_BREAK_INPUT_BKIN2: u32 = 4;
pub const LL_TIM_BKIN_SOURCE_BKIN: u32 = 1;
pub const LL_TIM_BKIN_SOURCE_BKCOMP1: u32 = 2;
pub const LL_TIM_BKIN_SOURCE_BKCOMP2: u32 = 4;
pub const LL_TIM_BKIN_POLARITY_LOW: u32 = 512;
pub const LL_TIM_BKIN_POLARITY_HIGH: u32 = 0;
pub const LL_TIM_BREAK_AFMODE_INPUT: u32 = 0;
pub const LL_TIM_BREAK_AFMODE_BIDIRECTIONAL: u32 = 268435456;
pub const LL_TIM_BREAK2_AFMODE_INPUT: u32 = 0;
pub const LL_TIM_BREAK2_AFMODE_BIDIRECTIONAL: u32 = 536870912;
pub const LL_TIM_DMABURST_BASEADDR_CR1: u32 = 0;
pub const LL_TIM_DMABURST_BASEADDR_CR2: u32 = 1;
pub const LL_TIM_DMABURST_BASEADDR_SMCR: u32 = 2;
pub const LL_TIM_DMABURST_BASEADDR_DIER: u32 = 3;
pub const LL_TIM_DMABURST_BASEADDR_SR: u32 = 4;
pub const LL_TIM_DMABURST_BASEADDR_EGR: u32 = 5;
pub const LL_TIM_DMABURST_BASEADDR_CCMR1: u32 = 6;
pub const LL_TIM_DMABURST_BASEADDR_CCMR2: u32 = 7;
pub const LL_TIM_DMABURST_BASEADDR_CCER: u32 = 8;
pub const LL_TIM_DMABURST_BASEADDR_CNT: u32 = 9;
pub const LL_TIM_DMABURST_BASEADDR_PSC: u32 = 10;
pub const LL_TIM_DMABURST_BASEADDR_ARR: u32 = 11;
pub const LL_TIM_DMABURST_BASEADDR_RCR: u32 = 12;
pub const LL_TIM_DMABURST_BASEADDR_CCR1: u32 = 13;
pub const LL_TIM_DMABURST_BASEADDR_CCR2: u32 = 14;
pub const LL_TIM_DMABURST_BASEADDR_CCR3: u32 = 15;
pub const LL_TIM_DMABURST_BASEADDR_CCR4: u32 = 16;
pub const LL_TIM_DMABURST_BASEADDR_BDTR: u32 = 17;
pub const LL_TIM_DMABURST_BASEADDR_OR: u32 = 20;
pub const LL_TIM_DMABURST_BASEADDR_CCMR3: u32 = 21;
pub const LL_TIM_DMABURST_BASEADDR_CCR5: u32 = 22;
pub const LL_TIM_DMABURST_BASEADDR_CCR6: u32 = 23;
pub const LL_TIM_DMABURST_BASEADDR_AF1: u32 = 24;
pub const LL_TIM_DMABURST_BASEADDR_AF2: u32 = 25;
pub const LL_TIM_DMABURST_LENGTH_1TRANSFER: u32 = 0;
pub const LL_TIM_DMABURST_LENGTH_2TRANSFERS: u32 = 256;
pub const LL_TIM_DMABURST_LENGTH_3TRANSFERS: u32 = 512;
pub const LL_TIM_DMABURST_LENGTH_4TRANSFERS: u32 = 768;
pub const LL_TIM_DMABURST_LENGTH_5TRANSFERS: u32 = 1024;
pub const LL_TIM_DMABURST_LENGTH_6TRANSFERS: u32 = 1280;
pub const LL_TIM_DMABURST_LENGTH_7TRANSFERS: u32 = 1536;
pub const LL_TIM_DMABURST_LENGTH_8TRANSFERS: u32 = 1792;
pub const LL_TIM_DMABURST_LENGTH_9TRANSFERS: u32 = 2048;
pub const LL_TIM_DMABURST_LENGTH_10TRANSFERS: u32 = 2304;
pub const LL_TIM_DMABURST_LENGTH_11TRANSFERS: u32 = 2560;
pub const LL_TIM_DMABURST_LENGTH_12TRANSFERS: u32 = 2816;
pub const LL_TIM_DMABURST_LENGTH_13TRANSFERS: u32 = 3072;
pub const LL_TIM_DMABURST_LENGTH_14TRANSFERS: u32 = 3328;
pub const LL_TIM_DMABURST_LENGTH_15TRANSFERS: u32 = 3584;
pub const LL_TIM_DMABURST_LENGTH_16TRANSFERS: u32 = 3840;
pub const LL_TIM_DMABURST_LENGTH_17TRANSFERS: u32 = 4096;
pub const LL_TIM_DMABURST_LENGTH_18TRANSFERS: u32 = 4352;
pub const LL_TIM_TIM1_ETR_ADC1_RMP_NC: u32 = 1245184;
pub const LL_TIM_TIM1_ETR_ADC1_RMP_AWD1: u32 = 1245185;
pub const LL_TIM_TIM1_ETR_ADC1_RMP_AWD2: u32 = 1245186;
pub const LL_TIM_TIM1_ETR_ADC1_RMP_AWD3: u32 = 1245187;
pub const LL_TIM_TIM1_TI1_RMP_GPIO: u32 = 1245184;
pub const LL_TIM_TIM1_TI1_RMP_COMP1: u32 = 1245200;
pub const LL_TIM_TIM2_ITR1_RMP_NONE: u32 = 983040;
pub const LL_TIM_TIM2_ITR1_RMP_USB_SOF: u32 = 1;
pub const LL_TIM_TIM2_ETR_RMP_GPIO: u32 = 983040;
pub const LL_TIM_TIM2_ETR_RMP_LSE: u32 = 983042;
pub const LL_TIM_TIM2_TI4_RMP_GPIO: u32 = 983040;
pub const LL_TIM_TIM2_TI4_RMP_COMP1: u32 = 983044;
pub const LL_TIM_TIM2_TI4_RMP_COMP2: u32 = 983048;
pub const LL_TIM_TIM2_TI4_RMP_COMP1_COMP2: u32 = 983052;
pub const LL_TIM_TIM16_TI1_RMP_GPIO: u32 = 196608;
pub const LL_TIM_TIM16_TI1_RMP_LSI: u32 = 196609;
pub const LL_TIM_TIM16_TI1_RMP_LSE: u32 = 196610;
pub const LL_TIM_TIM16_TI1_RMP_RTC: u32 = 196611;
pub const LL_TIM_TIM17_TI1_RMP_GPIO: u32 = 196608;
pub const LL_TIM_TIM17_TI1_RMP_MSI: u32 = 196609;
pub const LL_TIM_TIM17_TI1_RMP_HSE_32: u32 = 196610;
pub const LL_TIM_TIM17_TI1_RMP_MCO: u32 = 196611;
pub const LL_TIM_OCREF_CLR_INT_OCREF_CLR: u32 = 0;
pub const LL_TIM_OCREF_CLR_INT_ETR: u32 = 8;
pub const LL_SPI_SR_RXNE: u32 = 1;
pub const LL_SPI_SR_TXE: u32 = 2;
pub const LL_SPI_SR_BSY: u32 = 128;
pub const LL_SPI_SR_CRCERR: u32 = 16;
pub const LL_SPI_SR_MODF: u32 = 32;
pub const LL_SPI_SR_OVR: u32 = 64;
pub const LL_SPI_SR_FRE: u32 = 256;
pub const LL_SPI_CR2_RXNEIE: u32 = 64;
pub const LL_SPI_CR2_TXEIE: u32 = 128;
pub const LL_SPI_CR2_ERRIE: u32 = 32;
pub const LL_SPI_MODE_MASTER: u32 = 260;
pub const LL_SPI_MODE_SLAVE: u32 = 0;
pub const LL_SPI_PROTOCOL_MOTOROLA: u32 = 0;
pub const LL_SPI_PROTOCOL_TI: u32 = 16;
pub const LL_SPI_PHASE_1EDGE: u32 = 0;
pub const LL_SPI_PHASE_2EDGE: u32 = 1;
pub const LL_SPI_POLARITY_LOW: u32 = 0;
pub const LL_SPI_POLARITY_HIGH: u32 = 2;
pub const LL_SPI_BAUDRATEPRESCALER_DIV2: u32 = 0;
pub const LL_SPI_BAUDRATEPRESCALER_DIV4: u32 = 8;
pub const LL_SPI_BAUDRATEPRESCALER_DIV8: u32 = 16;
pub const LL_SPI_BAUDRATEPRESCALER_DIV16: u32 = 24;
pub const LL_SPI_BAUDRATEPRESCALER_DIV32: u32 = 32;
pub const LL_SPI_BAUDRATEPRESCALER_DIV64: u32 = 40;
pub const LL_SPI_BAUDRATEPRESCALER_DIV128: u32 = 48;
pub const LL_SPI_BAUDRATEPRESCALER_DIV256: u32 = 56;
pub const LL_SPI_LSB_FIRST: u32 = 128;
pub const LL_SPI_MSB_FIRST: u32 = 0;
pub const LL_SPI_FULL_DUPLEX: u32 = 0;
pub const LL_SPI_SIMPLEX_RX: u32 = 1024;
pub const LL_SPI_HALF_DUPLEX_RX: u32 = 32768;
pub const LL_SPI_HALF_DUPLEX_TX: u32 = 49152;
pub const LL_SPI_NSS_SOFT: u32 = 512;
pub const LL_SPI_NSS_HARD_INPUT: u32 = 0;
pub const LL_SPI_DATAWIDTH_4BIT: u32 = 768;
pub const LL_SPI_DATAWIDTH_5BIT: u32 = 1024;
pub const LL_SPI_DATAWIDTH_6BIT: u32 = 1280;
pub const LL_SPI_DATAWIDTH_7BIT: u32 = 1536;
pub const LL_SPI_DATAWIDTH_8BIT: u32 = 1792;
pub const LL_SPI_DATAWIDTH_9BIT: u32 = 2048;
pub const LL_SPI_DATAWIDTH_10BIT: u32 = 2304;
pub const LL_SPI_DATAWIDTH_11BIT: u32 = 2560;
pub const LL_SPI_DATAWIDTH_12BIT: u32 = 2816;
pub const LL_SPI_DATAWIDTH_13BIT: u32 = 3072;
pub const LL_SPI_DATAWIDTH_14BIT: u32 = 3328;
pub const LL_SPI_DATAWIDTH_15BIT: u32 = 3584;
pub const LL_SPI_DATAWIDTH_16BIT: u32 = 3840;
pub const LL_SPI_CRCCALCULATION_DISABLE: u32 = 0;
pub const LL_SPI_CRCCALCULATION_ENABLE: u32 = 8192;
pub const LL_SPI_CRC_8BIT: u32 = 0;
pub const LL_SPI_CRC_16BIT: u32 = 2048;
pub const LL_SPI_RX_FIFO_TH_HALF: u32 = 0;
pub const LL_SPI_RX_FIFO_TH_QUARTER: u32 = 4096;
pub const LL_SPI_RX_FIFO_EMPTY: u32 = 0;
pub const LL_SPI_RX_FIFO_QUARTER_FULL: u32 = 512;
pub const LL_SPI_RX_FIFO_HALF_FULL: u32 = 1024;
pub const LL_SPI_RX_FIFO_FULL: u32 = 1536;
pub const LL_SPI_TX_FIFO_EMPTY: u32 = 0;
pub const LL_SPI_TX_FIFO_QUARTER_FULL: u32 = 2048;
pub const LL_SPI_TX_FIFO_HALF_FULL: u32 = 4096;
pub const LL_SPI_TX_FIFO_FULL: u32 = 6144;
pub const LL_SPI_DMA_PARITY_EVEN: u32 = 0;
pub const LL_SPI_DMA_PARITY_ODD: u32 = 1;
pub const CC1101_QUARTZ: u32 = 26000000;
pub const CC1101_FMASK: u32 = 16777215;
pub const CC1101_FDIV: u32 = 65536;
pub const CC1101_IFDIV: u32 = 1024;
pub const CC1101_TIMEOUT: u32 = 500;
pub const CC1101_READ: u32 = 128;
pub const CC1101_BURST: u32 = 64;
pub const CC1101_IOCFG2: u32 = 0;
pub const CC1101_IOCFG1: u32 = 1;
pub const CC1101_IOCFG0: u32 = 2;
pub const CC1101_FIFOTHR: u32 = 3;
pub const CC1101_SYNC1: u32 = 4;
pub const CC1101_SYNC0: u32 = 5;
pub const CC1101_PKTLEN: u32 = 6;
pub const CC1101_PKTCTRL1: u32 = 7;
pub const CC1101_PKTCTRL0: u32 = 8;
pub const CC1101_ADDR: u32 = 9;
pub const CC1101_CHANNR: u32 = 10;
pub const CC1101_FSCTRL1: u32 = 11;
pub const CC1101_FSCTRL0: u32 = 12;
pub const CC1101_FREQ2: u32 = 13;
pub const CC1101_FREQ1: u32 = 14;
pub const CC1101_FREQ0: u32 = 15;
pub const CC1101_MDMCFG4: u32 = 16;
pub const CC1101_MDMCFG3: u32 = 17;
pub const CC1101_MDMCFG2: u32 = 18;
pub const CC1101_MDMCFG1: u32 = 19;
pub const CC1101_MDMCFG0: u32 = 20;
pub const CC1101_DEVIATN: u32 = 21;
pub const CC1101_MCSM2: u32 = 22;
pub const CC1101_MCSM1: u32 = 23;
pub const CC1101_MCSM0: u32 = 24;
pub const CC1101_FOCCFG: u32 = 25;
pub const CC1101_BSCFG: u32 = 26;
pub const CC1101_AGCCTRL2: u32 = 27;
pub const CC1101_AGCCTRL1: u32 = 28;
pub const CC1101_AGCCTRL0: u32 = 29;
pub const CC1101_WOREVT1: u32 = 30;
pub const CC1101_WOREVT0: u32 = 31;
pub const CC1101_WORCTRL: u32 = 32;
pub const CC1101_FREND1: u32 = 33;
pub const CC1101_FREND0: u32 = 34;
pub const CC1101_FSCAL3: u32 = 35;
pub const CC1101_FSCAL2: u32 = 36;
pub const CC1101_FSCAL1: u32 = 37;
pub const CC1101_FSCAL0: u32 = 38;
pub const CC1101_RCCTRL1: u32 = 39;
pub const CC1101_RCCTRL0: u32 = 40;
pub const CC1101_FSTEST: u32 = 41;
pub const CC1101_PTEST: u32 = 42;
pub const CC1101_AGCTEST: u32 = 43;
pub const CC1101_TEST2: u32 = 44;
pub const CC1101_TEST1: u32 = 45;
pub const CC1101_TEST0: u32 = 46;
pub const CC1101_STROBE_SRES: u32 = 48;
pub const CC1101_STROBE_SFSTXON: u32 = 49;
pub const CC1101_STROBE_SXOFF: u32 = 50;
pub const CC1101_STROBE_SCAL: u32 = 51;
pub const CC1101_STROBE_SRX: u32 = 52;
pub const CC1101_STROBE_STX: u32 = 53;
pub const CC1101_STROBE_SIDLE: u32 = 54;
pub const CC1101_STROBE_SWOR: u32 = 56;
pub const CC1101_STROBE_SPWD: u32 = 57;
pub const CC1101_STROBE_SFRX: u32 = 58;
pub const CC1101_STROBE_SFTX: u32 = 59;
pub const CC1101_STROBE_SWORRST: u32 = 60;
pub const CC1101_STROBE_SNOP: u32 = 61;
pub const CC1101_STATUS_PARTNUM: u32 = 48;
pub const CC1101_STATUS_VERSION: u32 = 49;
pub const CC1101_STATUS_FREQEST: u32 = 50;
pub const CC1101_STATUS_LQI: u32 = 51;
pub const CC1101_STATUS_RSSI: u32 = 52;
pub const CC1101_STATUS_MARCSTATE: u32 = 53;
pub const CC1101_STATUS_WORTIME1: u32 = 54;
pub const CC1101_STATUS_WORTIME0: u32 = 55;
pub const CC1101_STATUS_PKTSTATUS: u32 = 56;
pub const CC1101_STATUS_VCO_VC_DAC: u32 = 57;
pub const CC1101_STATUS_TXBYTES: u32 = 58;
pub const CC1101_STATUS_RXBYTES: u32 = 59;
pub const CC1101_STATUS_RCCTRL1_STATUS: u32 = 60;
pub const CC1101_STATUS_RCCTRL0_STATUS: u32 = 61;
pub const CC1101_PATABLE: u32 = 62;
pub const CC1101_FIFO: u32 = 63;
pub const CC1101_IOCFG_INV: u32 = 64;
pub const USB_CLASS_CDC: u32 = 2;
pub const USB_CLASS_CDC_DATA: u32 = 10;
pub const USB_CDC_SUBCLASS_ACM: u32 = 2;
pub const USB_CDC_PROTO_NONE: u32 = 0;
pub const USB_CDC_PROTO_V25TER: u32 = 1;
pub const USB_CDC_PROTO_NTB: u32 = 1;
pub const USB_CDC_PROTO_HOST: u32 = 253;
pub const USB_CDC_PROTO_CDCSPEC: u32 = 254;
pub const USB_DTYPE_CDC_HEADER: u32 = 0;
pub const USB_DTYPE_CDC_CALL_MANAGEMENT: u32 = 1;
pub const USB_DTYPE_CDC_ACM: u32 = 2;
pub const USB_DTYPE_CDC_UNION: u32 = 6;
pub const USB_DTYPE_CDC_COUNTRY: u32 = 7;
pub const USB_CDC_SEND_ENCAPSULATED_CMD: u32 = 0;
pub const USB_CDC_GET_ENCAPSULATED_RESP: u32 = 1;
pub const USB_CDC_SET_COMM_FEATURE: u32 = 2;
pub const USB_CDC_GET_COMM_FEATURE: u32 = 3;
pub const USB_CDC_CLEAR_COMM_FEATURE: u32 = 4;
pub const USB_CDC_SET_LINE_CODING: u32 = 32;
pub const USB_CDC_GET_LINE_CODING: u32 = 33;
pub const USB_CDC_SET_CONTROL_LINE_STATE: u32 = 34;
pub const USB_CDC_SEND_BREAK: u32 = 35;
pub const USB_CDC_NTF_NETWORK_CONNECTION: u32 = 0;
pub const USB_CDC_NTF_RESPONSE_AVAILABLE: u32 = 1;
pub const USB_CDC_NTF_SERIAL_STATE: u32 = 32;
pub const USB_CDC_NTF_SPEED_CHANGE: u32 = 42;
pub const USB_CDC_COMM_FEATURE: u32 = 1;
pub const USB_CDC_CAP_LINE: u32 = 2;
pub const USB_CDC_CAP_BRK: u32 = 4;
pub const USB_CDC_CAP_NOTIFY: u32 = 8;
pub const USB_CDC_CALL_MGMT_CAP_CALL_MGMT: u32 = 1;
pub const USB_CDC_CALL_MGMT_CAP_DATA_INTF: u32 = 2;
pub const USB_CDC_1_STOP_BITS: u32 = 0;
pub const USB_CDC_1_5_STOP_BITS: u32 = 1;
pub const USB_CDC_2_STOP_BITS: u32 = 2;
pub const USB_CDC_NO_PARITY: u32 = 0;
pub const USB_CDC_ODD_PARITY: u32 = 1;
pub const USB_CDC_EVEN_PARITY: u32 = 2;
pub const USB_CDC_MARK_PARITY: u32 = 3;
pub const USB_CDC_SPACE_PARITY: u32 = 4;
pub const USB_CDC_STATE_RX_CARRIER: u32 = 1;
pub const USB_CDC_STATE_TX_CARRIER: u32 = 2;
pub const USB_CDC_STATE_BREAK: u32 = 4;
pub const USB_CDC_STATE_RING: u32 = 8;
pub const USB_CDC_STATE_FRAMING: u32 = 16;
pub const USB_CDC_STATE_PARITY: u32 = 32;
pub const USB_CDC_STATE_OVERRUN: u32 = 64;
pub const CDC_DATA_SZ: u32 = 64;
pub const __error_t_defined: u32 = 1;
pub const EPERM: u32 = 1;
pub const ENOENT: u32 = 2;
pub const ESRCH: u32 = 3;
pub const EINTR: u32 = 4;
pub const EIO: u32 = 5;
pub const ENXIO: u32 = 6;
pub const E2BIG: u32 = 7;
pub const ENOEXEC: u32 = 8;
pub const EBADF: u32 = 9;
pub const ECHILD: u32 = 10;
pub const EAGAIN: u32 = 11;
pub const ENOMEM: u32 = 12;
pub const EACCES: u32 = 13;
pub const EFAULT: u32 = 14;
pub const EBUSY: u32 = 16;
pub const EEXIST: u32 = 17;
pub const EXDEV: u32 = 18;
pub const ENODEV: u32 = 19;
pub const ENOTDIR: u32 = 20;
pub const EISDIR: u32 = 21;
pub const EINVAL: u32 = 22;
pub const ENFILE: u32 = 23;
pub const EMFILE: u32 = 24;
pub const ENOTTY: u32 = 25;
pub const ETXTBSY: u32 = 26;
pub const EFBIG: u32 = 27;
pub const ENOSPC: u32 = 28;
pub const ESPIPE: u32 = 29;
pub const EROFS: u32 = 30;
pub const EMLINK: u32 = 31;
pub const EPIPE: u32 = 32;
pub const EDOM: u32 = 33;
pub const ERANGE: u32 = 34;
pub const ENOMSG: u32 = 35;
pub const EIDRM: u32 = 36;
pub const EDEADLK: u32 = 45;
pub const ENOLCK: u32 = 46;
pub const ENOSTR: u32 = 60;
pub const ENODATA: u32 = 61;
pub const ETIME: u32 = 62;
pub const ENOSR: u32 = 63;
pub const ENOLINK: u32 = 67;
pub const EPROTO: u32 = 71;
pub const EMULTIHOP: u32 = 74;
pub const EBADMSG: u32 = 77;
pub const EFTYPE: u32 = 79;
pub const ENOSYS: u32 = 88;
pub const ENOTEMPTY: u32 = 90;
pub const ENAMETOOLONG: u32 = 91;
pub const ELOOP: u32 = 92;
pub const EOPNOTSUPP: u32 = 95;
pub const EPFNOSUPPORT: u32 = 96;
pub const ECONNRESET: u32 = 104;
pub const ENOBUFS: u32 = 105;
pub const EAFNOSUPPORT: u32 = 106;
pub const EPROTOTYPE: u32 = 107;
pub const ENOTSOCK: u32 = 108;
pub const ENOPROTOOPT: u32 = 109;
pub const ECONNREFUSED: u32 = 111;
pub const EADDRINUSE: u32 = 112;
pub const ECONNABORTED: u32 = 113;
pub const ENETUNREACH: u32 = 114;
pub const ENETDOWN: u32 = 115;
pub const ETIMEDOUT: u32 = 116;
pub const EHOSTDOWN: u32 = 117;
pub const EHOSTUNREACH: u32 = 118;
pub const EINPROGRESS: u32 = 119;
pub const EALREADY: u32 = 120;
pub const EDESTADDRREQ: u32 = 121;
pub const EMSGSIZE: u32 = 122;
pub const EPROTONOSUPPORT: u32 = 123;
pub const EADDRNOTAVAIL: u32 = 125;
pub const ENETRESET: u32 = 126;
pub const EISCONN: u32 = 127;
pub const ENOTCONN: u32 = 128;
pub const ETOOMANYREFS: u32 = 129;
pub const EDQUOT: u32 = 132;
pub const ESTALE: u32 = 133;
pub const ENOTSUP: u32 = 134;
pub const EILSEQ: u32 = 138;
pub const EOVERFLOW: u32 = 139;
pub const ECANCELED: u32 = 140;
pub const ENOTRECOVERABLE: u32 = 141;
pub const EOWNERDEAD: u32 = 142;
pub const EWOULDBLOCK: u32 = 11;
pub const __ELASTERROR: u32 = 2000;
pub const FURI_HAL_VERSION_NAME_LENGTH: u32 = 8;
pub const FURI_HAL_VERSION_ARRAY_NAME_LENGTH: u32 = 9;
pub const FURI_HAL_VERSION_DEVICE_NAME_LENGTH: u32 = 18;
pub const GAP_MAC_ADDR_SIZE: u32 = 6;
pub const SERIAL_SVC_DATA_LEN_MAX: u32 = 486;
pub const SERIAL_SVC_CHAR_VALUE_LEN_MAX: u32 = 243;
pub const BLE_GLUE_MAX_VERSION_STRING_LEN: u32 = 20;
pub const FURI_HAL_BT_SERIAL_PACKET_SIZE_MAX: u32 = 486;
pub const FURI_HAL_BT_STACK_VERSION_MAJOR: u32 = 1;
pub const FURI_HAL_BT_STACK_VERSION_MINOR: u32 = 12;
pub const FURI_HAL_BT_C2_START_TIMEOUT: u32 = 1000;
pub const LEVEL_DURATION_RESET: u32 = 0;
pub const LEVEL_DURATION_LEVEL_LOW: u32 = 1;
pub const LEVEL_DURATION_LEVEL_HIGH: u32 = 2;
pub const LEVEL_DURATION_WAIT: u32 = 3;
pub const LEVEL_DURATION_RESERVED: u32 = 8388608;
pub const ERR_GENERIC_GRP: u32 = 0;
pub const ERR_WARN_GRP: u32 = 256;
pub const ERR_PROCESS_GRP: u32 = 512;
pub const ERR_SIO_GRP: u32 = 2048;
pub const ERR_RINGBUF_GRP: u32 = 2304;
pub const ERR_MQ_GRP: u32 = 2560;
pub const ERR_TIMER_GRP: u32 = 2816;
pub const ERR_RFAL_GRP: u32 = 3072;
pub const ERR_UART_GRP: u32 = 3328;
pub const ERR_SPI_GRP: u32 = 3584;
pub const ERR_I2C_GRP: u32 = 3840;
pub const _M_LN2: core::ffi::c_double = 0.6931471805599453;
pub const FP_NAN: u32 = 0;
pub const FP_INFINITE: u32 = 1;
pub const FP_ZERO: u32 = 2;
pub const FP_SUBNORMAL: u32 = 3;
pub const FP_NORMAL: u32 = 4;
pub const MATH_ERRNO: u32 = 1;
pub const MATH_ERREXCEPT: u32 = 2;
pub const _MATH_ERRHANDLING_ERRNO: u32 = 1;
pub const _MATH_ERRHANDLING_ERREXCEPT: u32 = 2;
pub const math_errhandling: u32 = 3;
pub const M_E: core::ffi::c_double = 2.718281828459045;
pub const M_LOG2E: core::ffi::c_double = 1.4426950408889634;
pub const M_LOG10E: core::ffi::c_double = 0.4342944819032518;
pub const M_LN2: core::ffi::c_double = 0.6931471805599453;
pub const M_LN10: core::ffi::c_double = 2.302585092994046;
pub const M_PI: core::ffi::c_double = 3.141592653589793;
pub const M_PI_2: core::ffi::c_double = 1.5707963267948966;
pub const M_PI_4: core::ffi::c_double = 0.7853981633974483;
pub const M_1_PI: core::ffi::c_double = 0.3183098861837907;
pub const M_2_PI: core::ffi::c_double = 0.6366197723675814;
pub const M_2_SQRTPI: core::ffi::c_double = 1.1283791670955126;
pub const M_SQRT2: core::ffi::c_double = 1.4142135623730951;
pub const M_SQRT1_2: core::ffi::c_double = 0.7071067811865476;
pub const M_TWOPI: core::ffi::c_double = 6.283185307179586;
pub const M_SQRTPI: core::ffi::c_double = 1.772453850905516;
pub const M_SQRT3: core::ffi::c_double = 1.7320508075688772;
pub const M_IVLN10: core::ffi::c_double = 0.4342944819032518;
pub const M_LOG2_E: core::ffi::c_double = 0.6931471805599453;
pub const ST25R_SS_PIN: u32 = 16;
pub const ST25R_INT_PIN: u32 = 4;
pub const RFAL_ANALOG_CONFIG_CUSTOM: u32 = 1;
pub const RFAL_FEATURE_LISTEN_MODE: u32 = 1;
pub const RFAL_FEATURE_WAKEUP_MODE: u32 = 1;
pub const RFAL_FEATURE_LOWPOWER_MODE: u32 = 1;
pub const RFAL_FEATURE_NFCA: u32 = 1;
pub const RFAL_FEATURE_NFCB: u32 = 1;
pub const RFAL_FEATURE_NFCF: u32 = 1;
pub const RFAL_FEATURE_NFCV: u32 = 1;
pub const RFAL_FEATURE_T1T: u32 = 1;
pub const RFAL_FEATURE_T2T: u32 = 1;
pub const RFAL_FEATURE_T4T: u32 = 1;
pub const RFAL_FEATURE_ST25TB: u32 = 1;
pub const RFAL_FEATURE_ST25xV: u32 = 1;
pub const RFAL_FEATURE_DYNAMIC_ANALOG_CONFIG: u32 = 0;
pub const RFAL_FEATURE_DPO: u32 = 0;
pub const RFAL_FEATURE_ISO_DEP: u32 = 1;
pub const RFAL_FEATURE_ISO_DEP_POLL: u32 = 1;
pub const RFAL_FEATURE_ISO_DEP_LISTEN: u32 = 1;
pub const RFAL_FEATURE_NFC_DEP: u32 = 1;
pub const RFAL_FEATURE_ISO_DEP_IBLOCK_MAX_LEN: u32 = 256;
pub const RFAL_FEATURE_NFC_DEP_BLOCK_MAX_LEN: u32 = 254;
pub const RFAL_FEATURE_NFC_RF_BUF_LEN: u32 = 256;
pub const RFAL_FEATURE_ISO_DEP_APDU_MAX_LEN: u32 = 512;
pub const RFAL_FEATURE_NFC_DEP_PDU_MAX_LEN: u32 = 512;
pub const RFAL_SUPPORT_MODE_POLL_NFCA: u32 = 1;
pub const RFAL_SUPPORT_MODE_POLL_NFCB: u32 = 1;
pub const RFAL_SUPPORT_MODE_POLL_NFCF: u32 = 1;
pub const RFAL_SUPPORT_MODE_POLL_NFCV: u32 = 1;
pub const RFAL_SUPPORT_MODE_POLL_ACTIVE_P2P: u32 = 1;
pub const RFAL_SUPPORT_MODE_LISTEN_NFCA: u32 = 1;
pub const RFAL_SUPPORT_MODE_LISTEN_NFCB: u32 = 0;
pub const RFAL_SUPPORT_MODE_LISTEN_NFCF: u32 = 1;
pub const RFAL_SUPPORT_MODE_LISTEN_ACTIVE_P2P: u32 = 1;
pub const RFAL_SUPPORT_BR_RW_106: u32 = 1;
pub const RFAL_SUPPORT_BR_RW_212: u32 = 1;
pub const RFAL_SUPPORT_BR_RW_424: u32 = 1;
pub const RFAL_SUPPORT_BR_RW_848: u32 = 1;
pub const RFAL_SUPPORT_BR_RW_1695: u32 = 0;
pub const RFAL_SUPPORT_BR_RW_3390: u32 = 0;
pub const RFAL_SUPPORT_BR_RW_6780: u32 = 0;
pub const RFAL_SUPPORT_BR_RW_13560: u32 = 0;
pub const RFAL_SUPPORT_BR_AP2P_106: u32 = 1;
pub const RFAL_SUPPORT_BR_AP2P_212: u32 = 1;
pub const RFAL_SUPPORT_BR_AP2P_424: u32 = 1;
pub const RFAL_SUPPORT_BR_AP2P_848: u32 = 0;
pub const RFAL_SUPPORT_BR_CE_A_106: u32 = 1;
pub const RFAL_SUPPORT_BR_CE_A_212: u32 = 0;
pub const RFAL_SUPPORT_BR_CE_A_424: u32 = 0;
pub const RFAL_SUPPORT_BR_CE_A_848: u32 = 0;
pub const RFAL_SUPPORT_BR_CE_B_106: u32 = 0;
pub const RFAL_SUPPORT_BR_CE_B_212: u32 = 0;
pub const RFAL_SUPPORT_BR_CE_B_424: u32 = 0;
pub const RFAL_SUPPORT_BR_CE_B_848: u32 = 0;
pub const RFAL_SUPPORT_BR_CE_F_212: u32 = 1;
pub const RFAL_SUPPORT_BR_CE_F_424: u32 = 1;
pub const RFAL_VERSION: u32 = 131584;
pub const RFAL_FWT_NONE: u32 = 4294967295;
pub const RFAL_TIMING_NONE: u32 = 0;
pub const RFAL_CRC_LEN: u32 = 2;
pub const RFAL_LM_SENS_RES_LEN: u32 = 2;
pub const RFAL_LM_SENSB_RES_LEN: u32 = 13;
pub const RFAL_LM_SENSF_RES_LEN: u32 = 19;
pub const RFAL_LM_SENSF_SC_LEN: u32 = 2;
pub const RFAL_NFCID3_LEN: u32 = 10;
pub const RFAL_NFCID2_LEN: u32 = 8;
pub const RFAL_NFCID1_TRIPLE_LEN: u32 = 10;
pub const RFAL_NFCID1_DOUBLE_LEN: u32 = 7;
pub const RFAL_NFCID1_SINGLE_LEN: u32 = 4;
pub const RFAL_FDT_LISTEN_NFCA_POLLER: u32 = 1172;
pub const RFAL_FDT_LISTEN_NFCB_POLLER: u32 = 1008;
pub const RFAL_FDT_LISTEN_NFCF_POLLER: u32 = 2672;
pub const RFAL_FDT_LISTEN_NFCV_POLLER: u32 = 4310;
pub const RFAL_FDT_LISTEN_PICOPASS_POLLER: u32 = 3400;
pub const RFAL_FDT_LISTEN_AP2P_POLLER: u32 = 64;
pub const RFAL_FDT_LISTEN_NFCA_LISTENER: u32 = 1172;
pub const RFAL_FDT_LISTEN_NFCB_LISTENER: u32 = 1024;
pub const RFAL_FDT_LISTEN_NFCF_LISTENER: u32 = 2688;
pub const RFAL_FDT_LISTEN_AP2P_LISTENER: u32 = 64;
pub const RFAL_FDT_POLL_NFCA_POLLER: u32 = 6780;
pub const RFAL_FDT_POLL_NFCA_T1T_POLLER: u32 = 384;
pub const RFAL_FDT_POLL_NFCB_POLLER: u32 = 6780;
pub const RFAL_FDT_POLL_NFCF_POLLER: u32 = 6800;
pub const RFAL_FDT_POLL_NFCV_POLLER: u32 = 4192;
pub const RFAL_FDT_POLL_PICOPASS_POLLER: u32 = 1790;
pub const RFAL_FDT_POLL_AP2P_POLLER: u32 = 0;
pub const RFAL_FELICA_LEN_LEN: u32 = 1;
pub const RFAL_FELICA_POLL_REQ_LEN: u32 = 6;
pub const RFAL_FELICA_POLL_RES_LEN: u32 = 20;
pub const RFAL_FELICA_POLL_MAX_SLOTS: u32 = 16;
pub const RFAL_WUM_REFERENCE_AUTO: u32 = 255;
pub const RFAL_T1T_UID_LEN: u32 = 4;
pub const RFAL_T1T_HR_LENGTH: u32 = 2;
pub const RFAL_T1T_HR0_NDEF_MASK: u32 = 240;
pub const RFAL_T1T_HR0_NDEF_SUPPORT: u32 = 16;
pub const RFAL_NFCA_CASCADE_1_UID_LEN: u32 = 4;
pub const RFAL_NFCA_CASCADE_2_UID_LEN: u32 = 7;
pub const RFAL_NFCA_CASCADE_3_UID_LEN: u32 = 10;
pub const RFAL_NFCA_SENS_RES_PLATFORM_MASK: u32 = 15;
pub const RFAL_NFCA_SENS_RES_PLATFORM_T1T: u32 = 12;
pub const RFAL_NFCA_SEL_RES_CONF_MASK: u32 = 96;
pub const RFAL_NFCA_SEL_RES_CONF_T2T: u32 = 0;
pub const RFAL_NFCA_SEL_RES_CONF_T4T: u32 = 32;
pub const RFAL_NFCA_SEL_RES_CONF_NFCDEP: u32 = 64;
pub const RFAL_NFCA_SEL_RES_CONF_T4T_NFCDEP: u32 = 96;
pub const RFAL_NFCA_FDTMIN: u32 = 1620;
pub const RFAL_NFCB_FWTSENSB: u32 = 7680;
pub const RFAL_NFCB_DFWT: u32 = 49152;
pub const RFAL_NFCB_AFI: u32 = 0;
pub const RFAL_NFCB_PARAM: u32 = 0;
pub const RFAL_NFCB_CRC_LEN: u32 = 2;
pub const RFAL_NFCB_NFCID0_LEN: u32 = 4;
pub const RFAL_NFCB_CMD_LEN: u32 = 1;
pub const RFAL_NFCB_SENSB_RES_LEN: u32 = 12;
pub const RFAL_NFCB_SENSB_RES_EXT_LEN: u32 = 13;
pub const RFAL_NFCB_SENSB_REQ_ADV_FEATURE: u32 = 32;
pub const RFAL_NFCB_SENSB_RES_FSCI_MASK: u32 = 15;
pub const RFAL_NFCB_SENSB_RES_FSCI_SHIFT: u32 = 4;
pub const RFAL_NFCB_SENSB_RES_PROTO_RFU_MASK: u32 = 8;
pub const RFAL_NFCB_SENSB_RES_PROTO_TR2_MASK: u32 = 3;
pub const RFAL_NFCB_SENSB_RES_PROTO_TR2_SHIFT: u32 = 1;
pub const RFAL_NFCB_SENSB_RES_PROTO_ISO_MASK: u32 = 1;
pub const RFAL_NFCB_SENSB_RES_FWI_MASK: u32 = 15;
pub const RFAL_NFCB_SENSB_RES_FWI_SHIFT: u32 = 4;
pub const RFAL_NFCB_SENSB_RES_ADC_MASK: u32 = 12;
pub const RFAL_NFCB_SENSB_RES_ADC_ADV_FEATURE_MASK: u32 = 8;
pub const RFAL_NFCB_SENSB_RES_ADC_PROPRIETARY_MASK: u32 = 4;
pub const RFAL_NFCB_SENSB_RES_FO_DID_MASK: u32 = 1;
pub const RFAL_NFCB_SENSB_RES_FO_NAD_MASK: u32 = 2;
pub const RFAL_NFCB_SENSB_RES_FO_MASK: u32 = 3;
pub const RFAL_NFCB_SENSB_RES_SFGI_MASK: u32 = 15;
pub const RFAL_NFCB_SENSB_RES_SFGI_SHIFT: u32 = 4;
pub const RFAL_NFCF_NFCID2_LEN: u32 = 8;
pub const RFAL_NFCF_SENSF_RES_LEN_MIN: u32 = 16;
pub const RFAL_NFCF_SENSF_RES_LEN_MAX: u32 = 18;
pub const RFAL_NFCF_SENSF_RES_PAD0_LEN: u32 = 2;
pub const RFAL_NFCF_SENSF_RES_PAD1_LEN: u32 = 2;
pub const RFAL_NFCF_SENSF_RES_RD_LEN: u32 = 2;
pub const RFAL_NFCF_SENSF_RES_BYTE1: u32 = 1;
pub const RFAL_NFCF_SENSF_SC_LEN: u32 = 2;
pub const RFAL_NFCF_SENSF_PARAMS_SC1_POS: u32 = 0;
pub const RFAL_NFCF_SENSF_PARAMS_SC2_POS: u32 = 1;
pub const RFAL_NFCF_SENSF_PARAMS_RC_POS: u32 = 2;
pub const RFAL_NFCF_SENSF_PARAMS_TSN_POS: u32 = 3;
pub const RFAL_NFCF_POLL_MAXCARDS: u32 = 16;
pub const RFAL_NFCF_CMD_POS: u32 = 0;
pub const RFAL_NFCF_CMD_LEN: u32 = 1;
pub const RFAL_NFCF_LENGTH_LEN: u32 = 1;
pub const RFAL_NFCF_HEADER_LEN: u32 = 2;
pub const RFAL_NFCF_SENSF_NFCID2_BYTE1_POS: u32 = 0;
pub const RFAL_NFCF_SENSF_NFCID2_BYTE2_POS: u32 = 1;
pub const RFAL_NFCF_SENSF_NFCID2_PROT_TYPE_LEN: u32 = 2;
pub const RFAL_NFCF_SENSF_NFCID2_BYTE1_NFCDEP: u32 = 1;
pub const RFAL_NFCF_SENSF_NFCID2_BYTE2_NFCDEP: u32 = 254;
pub const RFAL_NFCF_SYSTEMCODE: u32 = 65535;
pub const RFAL_NFCF_BLOCK_LEN: u32 = 16;
pub const RFAL_NFCF_CHECKUPDATE_RES_ST1_POS: u32 = 9;
pub const RFAL_NFCF_CHECKUPDATE_RES_ST2_POS: u32 = 10;
pub const RFAL_NFCF_CHECKUPDATE_RES_NOB_POS: u32 = 11;
pub const RFAL_NFCF_STATUS_FLAG_SUCCESS: u32 = 0;
pub const RFAL_NFCF_STATUS_FLAG_ERROR: u32 = 255;
pub const RFAL_NFCF_BLOCKLISTELEM_LEN: u32 = 128;
pub const RFAL_NFCF_SERVICECODE_RDONLY: u32 = 11;
pub const RFAL_NFCF_SERVICECODE_RDWR: u32 = 9;
pub const RFAL_NFCV_UID_LEN: u32 = 8;
pub const RFAL_NFCV_MAX_BLOCK_LEN: u32 = 32;
pub const RFAL_NFCV_BNO_LEN: u32 = 1;
pub const RFAL_NFCV_CRC_LEN: u32 = 2;
pub const RFAL_NFCV_MAX_GEN_DATA_LEN: u32 = 41;
pub const RFAL_NFCV_BLOCKNUM_LEN: u32 = 1;
pub const RFAL_NFCV_BLOCKNUM_EXTENDED_LEN: u32 = 2;
pub const RFAL_NFCV_PARAM_SKIP: u32 = 0;
pub const RFAL_ST25TB_CHIP_ID_LEN: u32 = 1;
pub const RFAL_ST25TB_CRC_LEN: u32 = 2;
pub const RFAL_ST25TB_UID_LEN: u32 = 8;
pub const RFAL_ST25TB_BLOCK_LEN: u32 = 4;
pub const RFAL_NFCDEP_FRAME_SIZE_MAX_LEN: u32 = 254;
pub const RFAL_NFCDEP_DEPREQ_HEADER_LEN: u32 = 5;
pub const RFAL_NFCDEP_SB_LEN: u32 = 1;
pub const RFAL_NFCDEP_LEN_LEN: u32 = 1;
pub const RFAL_NFCDEP_CMDTYPE_LEN: u32 = 1;
pub const RFAL_NFCDEP_CMD_LEN: u32 = 1;
pub const RFAL_NFCDEP_DID_LEN: u32 = 1;
pub const RFAL_NFCDEP_DEP_PFB_LEN: u32 = 1;
pub const RFAL_NFCDEP_DSL_RLS_LEN_NO_DID: u32 = 3;
pub const RFAL_NFCDEP_DSL_RLS_LEN_DID: u32 = 4;
pub const RFAL_NFCDEP_FS_VAL_MIN: u32 = 64;
pub const RFAL_NFCDEP_LR_VAL_MASK: u32 = 3;
pub const RFAL_NFCDEP_PP_LR_MASK: u32 = 48;
pub const RFAL_NFCDEP_PP_LR_SHIFT: u32 = 4;
pub const RFAL_NFCDEP_DID_MAX: u32 = 14;
pub const RFAL_NFCDEP_DID_KEEP: u32 = 255;
pub const RFAL_NFCDEP_DID_NO: u32 = 0;
pub const RFAL_NFCDEP_NAD_NO: u32 = 0;
pub const RFAL_NFCDEP_OPER_RTOX_REQ_DIS: u32 = 1;
pub const RFAL_NFCDEP_OPER_RTOX_REQ_EN: u32 = 0;
pub const RFAL_NFCDEP_OPER_ATN_DIS: u32 = 0;
pub const RFAL_NFCDEP_OPER_ATN_EN: u32 = 2;
pub const RFAL_NFCDEP_OPER_EMPTY_DEP_DIS: u32 = 4;
pub const RFAL_NFCDEP_OPER_EMPTY_DEP_EN: u32 = 0;
pub const RFAL_NFCDEP_OPER_FULL_MI_DIS: u32 = 0;
pub const RFAL_NFCDEP_OPER_FULL_MI_EN: u32 = 8;
pub const RFAL_NFCDEP_BRS_MAINTAIN: u32 = 192;
pub const RFAL_NFCDEP_BRS_Dx_MASK: u32 = 7;
pub const RFAL_NFCDEP_BRS_DSI_POS: u32 = 3;
pub const RFAL_NFCDEP_WT_DELTA_ADJUST: u32 = 4;
pub const RFAL_NFCDEP_ATR_REQ_NFCID3_POS: u32 = 2;
pub const RFAL_NFCDEP_NFCID3_LEN: u32 = 10;
pub const RFAL_NFCDEP_LEN_MIN: u32 = 3;
pub const RFAL_NFCDEP_LEN_MAX: u32 = 255;
pub const RFAL_NFCDEP_ATRRES_HEADER_LEN: u32 = 2;
pub const RFAL_NFCDEP_ATRRES_MIN_LEN: u32 = 17;
pub const RFAL_NFCDEP_ATRRES_MAX_LEN: u32 = 64;
pub const RFAL_NFCDEP_ATRREQ_MIN_LEN: u32 = 16;
pub const RFAL_NFCDEP_ATRREQ_MAX_LEN: u32 = 64;
pub const RFAL_NFCDEP_GB_MAX_LEN: u32 = 48;
pub const RFAL_NFCDEP_WT_INI_MIN: u32 = 0;
pub const RFAL_NFCDEP_WT_INI_MAX: u32 = 14;
pub const RFAL_NFCDEP_WT_TRG_MAX_D10: u32 = 8;
pub const RFAL_NFCDEP_WT_TRG_MAX_D11: u32 = 14;
pub const RFAL_NFCDEP_WT_TRG_MAX_L13: u32 = 10;
pub const RFAL_NFCDEP_WT_TRG_MAX: u32 = 14;
pub const RFAL_NFCDEP_WT_MASK: u32 = 15;
pub const RFAL_NFCDEP_BR_MASK_106: u32 = 1;
pub const RFAL_NFCDEP_BR_MASK_212: u32 = 2;
pub const RFAL_NFCDEP_BR_MASK_424: u32 = 4;
pub const RFAL_ISODEP_PROLOGUE_SIZE: u32 = 3;
pub const RFAL_ISODEP_PCB_LEN: u32 = 1;
pub const RFAL_ISODEP_DID_LEN: u32 = 1;
pub const RFAL_ISODEP_NAD_LEN: u32 = 1;
pub const RFAL_ISODEP_NO_DID: u32 = 0;
pub const RFAL_ISODEP_NO_NAD: u32 = 255;
pub const RFAL_ISODEP_FWI_MASK: u32 = 240;
pub const RFAL_ISODEP_FWI_SHIFT: u32 = 4;
pub const RFAL_ISODEP_FWI_DEFAULT: u32 = 4;
pub const RFAL_ISODEP_ADV_FEATURE: u32 = 15;
pub const RFAL_ISODEP_DID_MAX: u32 = 14;
pub const RFAL_ISODEP_BRI_MASK: u32 = 7;
pub const RFAL_ISODEP_BSI_MASK: u32 = 112;
pub const RFAL_ISODEP_SAME_BITRATE_MASK: u32 = 128;
pub const RFAL_ISODEP_BITRATE_RFU_MASK: u32 = 8;
pub const RFAL_ISODEP_FSX_KEEP: u32 = 255;
pub const RFAL_ISODEP_DEFAULT_SFGI: u32 = 0;
pub const RFAL_ISODEP_DEFAULT_FWI: u32 = 8;
pub const RFAL_ISODEP_ATTRIB_RES_MBLI_NO_INFO: u32 = 0;
pub const RFAL_ISODEP_ATTRIB_REQ_PARAM1_DEFAULT: u32 = 0;
pub const RFAL_ISODEP_ATTRIB_HLINFO_LEN: u32 = 32;
pub const RFAL_ISODEP_ATS_HB_MAX_LEN: u32 = 15;
pub const RFAL_ISODEP_ATTRIB_REQ_MIN_LEN: u32 = 9;
pub const RFAL_ISODEP_ATTRIB_RES_MIN_LEN: u32 = 1;
pub const RFAL_ISODEP_SPARAM_VALUES_MAX_LEN: u32 = 16;
pub const RFAL_ISODEP_SPARAM_TAG_BLOCKINFO: u32 = 160;
pub const RFAL_ISODEP_SPARAM_TAG_BRREQ: u32 = 161;
pub const RFAL_ISODEP_SPARAM_TAG_BRIND: u32 = 162;
pub const RFAL_ISODEP_SPARAM_TAG_BRACT: u32 = 163;
pub const RFAL_ISODEP_SPARAM_TAG_BRACK: u32 = 164;
pub const RFAL_ISODEP_SPARAM_TAG_SUP_PCD2PICC: u32 = 128;
pub const RFAL_ISODEP_SPARAM_TAG_SUP_PICC2PCD: u32 = 129;
pub const RFAL_ISODEP_SPARAM_TAG_SUP_FRAME: u32 = 130;
pub const RFAL_ISODEP_SPARAM_TAG_SEL_PCD2PICC: u32 = 131;
pub const RFAL_ISODEP_SPARAM_TAG_SEL_PICC2PCD: u32 = 132;
pub const RFAL_ISODEP_SPARAM_TAG_SEL_FRAME: u32 = 133;
pub const RFAL_ISODEP_SPARAM_TAG_LEN: u32 = 1;
pub const RFAL_ISODEP_SPARAM_TAG_BRREQ_LEN: u32 = 0;
pub const RFAL_ISODEP_SPARAM_TAG_PICC2PCD_LEN: u32 = 2;
pub const RFAL_ISODEP_SPARAM_TAG_PCD2PICC_LEN: u32 = 2;
pub const RFAL_ISODEP_SPARAM_TAG_BRACK_LEN: u32 = 0;
pub const RFAL_ISODEP_ATS_TA_DPL_212: u32 = 1;
pub const RFAL_ISODEP_ATS_TA_DPL_424: u32 = 2;
pub const RFAL_ISODEP_ATS_TA_DPL_848: u32 = 4;
pub const RFAL_ISODEP_ATS_TA_DLP_212: u32 = 16;
pub const RFAL_ISODEP_ATS_TA_DLP_424: u32 = 32;
pub const RFAL_ISODEP_ATS_TA_DLP_848: u32 = 64;
pub const RFAL_ISODEP_ATS_TA_SAME_D: u32 = 128;
pub const RFAL_ISODEP_ATS_TB_FWI_MASK: u32 = 240;
pub const RFAL_ISODEP_ATS_TB_SFGI_MASK: u32 = 15;
pub const RFAL_ISODEP_ATS_T0_TA_PRESENCE_MASK: u32 = 16;
pub const RFAL_ISODEP_ATS_T0_TB_PRESENCE_MASK: u32 = 32;
pub const RFAL_ISODEP_ATS_T0_TC_PRESENCE_MASK: u32 = 64;
pub const RFAL_ISODEP_ATS_T0_FSCI_MASK: u32 = 15;
pub const RFAL_ISODEP_ATS_T0_OFFSET: u32 = 1;
pub const RFAL_ISODEP_MAX_I_RETRYS: u32 = 2;
pub const RFAL_ISODEP_MAX_R_RETRYS: u32 = 3;
pub const RFAL_ISODEP_MAX_WTX_NACK_RETRYS: u32 = 3;
pub const RFAL_ISODEP_MAX_WTX_RETRYS: u32 = 20;
pub const RFAL_ISODEP_MAX_WTX_RETRYS_ULTD: u32 = 255;
pub const RFAL_ISODEP_MAX_DSL_RETRYS: u32 = 0;
pub const RFAL_ISODEP_RATS_RETRIES: u32 = 1;
pub const RFAL_NFC_TECH_NONE: u32 = 0;
pub const RFAL_NFC_POLL_TECH_A: u32 = 1;
pub const RFAL_NFC_POLL_TECH_B: u32 = 2;
pub const RFAL_NFC_POLL_TECH_F: u32 = 4;
pub const RFAL_NFC_POLL_TECH_V: u32 = 8;
pub const RFAL_NFC_POLL_TECH_AP2P: u32 = 16;
pub const RFAL_NFC_POLL_TECH_ST25TB: u32 = 32;
pub const RFAL_NFC_LISTEN_TECH_A: u32 = 4096;
pub const RFAL_NFC_LISTEN_TECH_B: u32 = 8192;
pub const RFAL_NFC_LISTEN_TECH_F: u32 = 16384;
pub const RFAL_NFC_LISTEN_TECH_AP2P: u32 = 32768;
pub const FURI_HAL_NFC_UID_MAX_LEN: u32 = 10;
pub const FURI_HAL_NFC_DATA_BUFF_SIZE: u32 = 512;
pub const FURI_HAL_NFC_PARITY_BUFF_SIZE: u32 = 64;
pub const FURI_HAL_NFC_LL_FDT_LISTEN_NFCA_POLLER: u32 = 1172;
pub const FURI_HAL_NFC_LL_FDT_LISTEN_NFCB_POLLER: u32 = 1008;
pub const FURI_HAL_NFC_LL_FDT_LISTEN_NFCF_POLLER: u32 = 2672;
pub const FURI_HAL_NFC_LL_FDT_LISTEN_NFCV_POLLER: u32 = 4310;
pub const FURI_HAL_NFC_LL_FDT_LISTEN_PICOPASS_POLLER: u32 = 3400;
pub const FURI_HAL_NFC_LL_FDT_LISTEN_AP2P_POLLER: u32 = 64;
pub const FURI_HAL_NFC_LL_FDT_LISTEN_NFCA_LISTENER: u32 = 1172;
pub const FURI_HAL_NFC_LL_FDT_LISTEN_NFCB_LISTENER: u32 = 1024;
pub const FURI_HAL_NFC_LL_FDT_LISTEN_NFCF_LISTENER: u32 = 2688;
pub const FURI_HAL_NFC_LL_FDT_LISTEN_AP2P_LISTENER: u32 = 64;
pub const FURI_HAL_NFC_LL_FDT_POLL_NFCA_POLLER: u32 = 6780;
pub const FURI_HAL_NFC_LL_FDT_POLL_NFCA_T1T_POLLER: u32 = 384;
pub const FURI_HAL_NFC_LL_FDT_POLL_NFCB_POLLER: u32 = 6780;
pub const FURI_HAL_NFC_LL_FDT_POLL_NFCF_POLLER: u32 = 6800;
pub const FURI_HAL_NFC_LL_FDT_POLL_NFCV_POLLER: u32 = 4192;
pub const FURI_HAL_NFC_LL_FDT_POLL_PICOPASS_POLLER: u32 = 1790;
pub const FURI_HAL_NFC_LL_FDT_POLL_AP2P_POLLER: u32 = 0;
pub const usbd_evt_reset: u32 = 0;
pub const usbd_evt_sof: u32 = 1;
pub const usbd_evt_susp: u32 = 2;
pub const usbd_evt_wkup: u32 = 3;
pub const usbd_evt_eptx: u32 = 4;
pub const usbd_evt_eprx: u32 = 5;
pub const usbd_evt_epsetup: u32 = 6;
pub const usbd_evt_error: u32 = 7;
pub const usbd_evt_count: u32 = 8;
pub const usbd_lane_unk: u32 = 0;
pub const usbd_lane_dsc: u32 = 1;
pub const usbd_lane_sdp: u32 = 2;
pub const usbd_lane_cdp: u32 = 3;
pub const usbd_lane_dcp: u32 = 4;
pub const USBD_HW_ADDRFST: u32 = 1;
pub const USBD_HW_BC: u32 = 2;
pub const USND_HW_HS: u32 = 4;
pub const USBD_HW_ENABLED: u32 = 8;
pub const USBD_HW_ENUMSPEED: u32 = 48;
pub const USBD_HW_SPEED_NC: u32 = 0;
pub const USBD_HW_SPEED_LS: u32 = 16;
pub const USBD_HW_SPEED_FS: u32 = 32;
pub const USBD_HW_SPEED_HS: u32 = 48;
pub const USB_EPTYPE_DBLBUF: u32 = 4;
pub const USB_REQ_DIRECTION: u32 = 128;
pub const USB_REQ_HOSTTODEV: u32 = 0;
pub const USB_REQ_DEVTOHOST: u32 = 128;
pub const USB_REQ_TYPE: u32 = 96;
pub const USB_REQ_STANDARD: u32 = 0;
pub const USB_REQ_CLASS: u32 = 32;
pub const USB_REQ_VENDOR: u32 = 64;
pub const USB_REQ_RECIPIENT: u32 = 3;
pub const USB_REQ_DEVICE: u32 = 0;
pub const USB_REQ_INTERFACE: u32 = 1;
pub const USB_REQ_ENDPOINT: u32 = 2;
pub const USB_REQ_OTHER: u32 = 3;
pub const USB_CFG_ATTR_RESERVED: u32 = 128;
pub const USB_CFG_ATTR_SELFPOWERED: u32 = 64;
pub const USB_EPDIR_IN: u32 = 0;
pub const USB_EPDIR_OUT: u32 = 128;
pub const USB_EPTYPE_CONTROL: u32 = 0;
pub const USB_EPTYPE_ISOCHRONUS: u32 = 1;
pub const USB_EPTYPE_BULK: u32 = 2;
pub const USB_EPTYPE_INTERRUPT: u32 = 3;
pub const USB_EPATTR_NO_SYNC: u32 = 0;
pub const USB_EPATTR_ASYNC: u32 = 4;
pub const USB_EPATTR_ADAPTIVE: u32 = 8;
pub const USB_EPATTR_SYNC: u32 = 12;
pub const USB_EPUSAGE_DATA: u32 = 0;
pub const USB_EPUSAGE_FEEDBACK: u32 = 16;
pub const USB_EPUSAGE_IMP_FEEDBACK: u32 = 32;
pub const NO_DESCRIPTOR: u32 = 0;
pub const INTSERIALNO_DESCRIPTOR: u32 = 254;
pub const USB_CLASS_PER_INTERFACE: u32 = 0;
pub const USB_SUBCLASS_NONE: u32 = 0;
pub const USB_PROTO_NONE: u32 = 0;
pub const USB_CLASS_AUDIO: u32 = 1;
pub const USB_CLASS_PHYSICAL: u32 = 5;
pub const USB_CLASS_STILL_IMAGE: u32 = 6;
pub const USB_CLASS_PRINTER: u32 = 7;
pub const USB_CLASS_MASS_STORAGE: u32 = 8;
pub const USB_CLASS_HUB: u32 = 9;
pub const USB_CLASS_CSCID: u32 = 11;
pub const USB_CLASS_CONTENT_SEC: u32 = 13;
pub const USB_CLASS_VIDEO: u32 = 14;
pub const USB_CLASS_HEALTHCARE: u32 = 15;
pub const USB_CLASS_AV: u32 = 16;
pub const USB_CLASS_BILLBOARD: u32 = 17;
pub const USB_CLASS_CBRIDGE: u32 = 18;
pub const USB_CLASS_DIAGNOSTIC: u32 = 220;
pub const USB_CLASS_WIRELESS: u32 = 224;
pub const USB_CLASS_MISC: u32 = 239;
pub const USB_CLASS_APP_SPEC: u32 = 254;
pub const USB_CLASS_VENDOR: u32 = 255;
pub const USB_SUBCLASS_VENDOR: u32 = 255;
pub const USB_PROTO_VENDOR: u32 = 255;
pub const USB_CLASS_IAD: u32 = 239;
pub const USB_SUBCLASS_IAD: u32 = 2;
pub const USB_PROTO_IAD: u32 = 1;
pub const USB_DTYPE_DEVICE: u32 = 1;
pub const USB_DTYPE_CONFIGURATION: u32 = 2;
pub const USB_DTYPE_STRING: u32 = 3;
pub const USB_DTYPE_INTERFACE: u32 = 4;
pub const USB_DTYPE_ENDPOINT: u32 = 5;
pub const USB_DTYPE_QUALIFIER: u32 = 6;
pub const USB_DTYPE_OTHER: u32 = 7;
pub const USB_DTYPE_INTERFACEPOWER: u32 = 8;
pub const USB_DTYPE_OTG: u32 = 9;
pub const USB_DTYPE_DEBUG: u32 = 10;
pub const USB_DTYPE_INTERFASEASSOC: u32 = 11;
pub const USB_DTYPE_CS_INTERFACE: u32 = 36;
pub const USB_DTYPE_CS_ENDPOINT: u32 = 37;
pub const USB_STD_GET_STATUS: u32 = 0;
pub const USB_STD_CLEAR_FEATURE: u32 = 1;
pub const USB_STD_SET_FEATURE: u32 = 3;
pub const USB_STD_SET_ADDRESS: u32 = 5;
pub const USB_STD_GET_DESCRIPTOR: u32 = 6;
pub const USB_STD_SET_DESCRIPTOR: u32 = 7;
pub const USB_STD_GET_CONFIG: u32 = 8;
pub const USB_STD_SET_CONFIG: u32 = 9;
pub const USB_STD_GET_INTERFACE: u32 = 10;
pub const USB_STD_SET_INTERFACE: u32 = 11;
pub const USB_STD_SYNCH_FRAME: u32 = 12;
pub const USB_FEAT_ENDPOINT_HALT: u32 = 0;
pub const USB_FEAT_REMOTE_WKUP: u32 = 1;
pub const USB_FEAT_TEST_MODE: u32 = 2;
pub const USB_FEAT_DEBUG_MODE: u32 = 6;
pub const USB_TEST_J: u32 = 1;
pub const USB_TEST_K: u32 = 2;
pub const USB_TEST_SE0_NAK: u32 = 3;
pub const USB_TEST_PACKET: u32 = 4;
pub const USB_TEST_FORCE_ENABLE: u32 = 5;
pub const USB_LANGID_AFR: u32 = 1078;
pub const USB_LANGID_SQI: u32 = 1052;
pub const USB_LANGID_ARA_SA: u32 = 1025;
pub const USB_LANGID_ARA_IQ: u32 = 2049;
pub const USB_LANGID_ARA_EG: u32 = 3073;
pub const USB_LANGID_ARA_LY: u32 = 4097;
pub const USB_LANGID_ARA_DZ: u32 = 5121;
pub const USB_LANGID_ARA_MA: u32 = 6145;
pub const USB_LANGID_ARA_TN: u32 = 7169;
pub const USB_LANGID_ARA_OM: u32 = 8193;
pub const USB_LANGID_ARA_YE: u32 = 9217;
pub const USB_LANGID_ARA_SY: u32 = 10241;
pub const USB_LANGID_ARA_JO: u32 = 11265;
pub const USB_LANGID_ARA_LB: u32 = 12289;
pub const USB_LANGID_ARA_KW: u32 = 13313;
pub const USB_LANGID_ARA_AE: u32 = 14337;
pub const USB_LANGID_ARA_BH: u32 = 15361;
pub const USB_LANGID_ARA_QA: u32 = 16385;
pub const USB_LANGID_HYE: u32 = 1067;
pub const USB_LANGID_ASM: u32 = 1101;
pub const USB_LANGID_AZE_LAT: u32 = 1068;
pub const USB_LANGID_AZE_CYR: u32 = 2092;
pub const USB_LANGID_EUS: u32 = 1069;
pub const USB_LANGID_BEL: u32 = 1059;
pub const USB_LANGID_BEN: u32 = 1093;
pub const USB_LANGID_BUL: u32 = 1026;
pub const USB_LANGID_MYA: u32 = 1109;
pub const USB_LANGID_CAT: u32 = 1027;
pub const USB_LANGID_ZHO_TW: u32 = 1028;
pub const USB_LANGID_ZHO_CN: u32 = 2052;
pub const USB_LANGID_ZHO_HK: u32 = 3076;
pub const USB_LANGID_ZHO_SG: u32 = 4100;
pub const USB_LANGID_ZHO_MO: u32 = 5124;
pub const USB_LANGID_HRV: u32 = 1050;
pub const USB_LANGID_CZE: u32 = 1029;
pub const USB_LANGID_DAN: u32 = 1030;
pub const USB_LANGID_NLD_NL: u32 = 1043;
pub const USB_LANGID_NLD_BE: u32 = 2067;
pub const USB_LANGID_ENG_US: u32 = 1033;
pub const USB_LANGID_ENG_UK: u32 = 2057;
pub const USB_LANGID_ENG_AU: u32 = 3081;
pub const USB_LANGID_ENG_CA: u32 = 4105;
pub const USB_LANGID_ENG_NZ: u32 = 5129;
pub const USB_LANGID_ENG_IE: u32 = 6153;
pub const USB_LANGID_ENG_ZA: u32 = 7177;
pub const USB_LANGID_ENG_JM: u32 = 8201;
pub const USB_LANGID_ENG_CAR: u32 = 9225;
pub const USB_LANGID_ENG_BZ: u32 = 10249;
pub const USB_LANGID_ENG_TH: u32 = 11273;
pub const USB_LANGID_ENG_ZW: u32 = 12297;
pub const USB_LANGID_ENG_PH: u32 = 13321;
pub const USB_LANGID_EST: u32 = 1061;
pub const USB_LANGID_FAO: u32 = 1080;
pub const USB_LANGID_FAS: u32 = 1065;
pub const USB_LANGID_FIN: u32 = 1035;
pub const USB_LANGID_FRA: u32 = 1036;
pub const USB_LANGID_FRA_BE: u32 = 2060;
pub const USB_LANGID_FRA_CA: u32 = 3084;
pub const USB_LANGID_FRA_SZ: u32 = 4108;
pub const USB_LANGID_FRA_LU: u32 = 5132;
pub const USB_LANGID_FRA_MC: u32 = 6156;
pub const USB_LANGID_KAT: u32 = 1079;
pub const USB_LANGID_DEU: u32 = 1031;
pub const USB_LANGID_DEU_SZ: u32 = 2055;
pub const USB_LANGID_DEU_AT: u32 = 3079;
pub const USB_LANGID_DEU_LU: u32 = 4103;
pub const USB_LANGID_DEU_LI: u32 = 5127;
pub const USB_LANGID_ELL: u32 = 1032;
pub const USB_LANGID_GUJ: u32 = 1095;
pub const USB_LANGID_HEB: u32 = 1037;
pub const USB_LANGID_HIN: u32 = 1081;
pub const USB_LANGID_HUN: u32 = 1038;
pub const USB_LANGID_ISL: u32 = 1039;
pub const USB_LANGID_IND: u32 = 1057;
pub const USB_LANGID_ITA: u32 = 1040;
pub const USB_LANGID_ITA_SZ: u32 = 2064;
pub const USB_LANGID_JPN: u32 = 1041;
pub const USB_LANGID_KAN: u32 = 1099;
pub const USB_LANGID_KAS: u32 = 2144;
pub const USB_LANGID_KAZ: u32 = 1087;
pub const USB_LANGID_KOK: u32 = 1111;
pub const USB_LANGID_KOR: u32 = 1042;
pub const USB_LANGID_KOR_JOH: u32 = 2066;
pub const USB_LANGID_LAV: u32 = 1062;
pub const USB_LANGID_LIT: u32 = 1063;
pub const USB_LANGID_LIT_CLS: u32 = 2087;
pub const USB_LANGID_MKD: u32 = 1071;
pub const USB_LANGID_MSA: u32 = 1086;
pub const USB_LANGID_MSA_BN: u32 = 2110;
pub const USB_LANGID_MAL: u32 = 1100;
pub const USB_LANGID_MNI: u32 = 1112;
pub const USB_LANGID_MAR: u32 = 1102;
pub const USB_LANGID_NEP: u32 = 2145;
pub const USB_LANGID_NOB: u32 = 1044;
pub const USB_LANGID_NNO: u32 = 2068;
pub const USB_LANGID_ORI: u32 = 1096;
pub const USB_LANGID_POL: u32 = 1045;
pub const USB_LANGID_POR_BR: u32 = 1046;
pub const USB_LANGID_POR: u32 = 2070;
pub const USB_LANGID_PAN: u32 = 1094;
pub const USB_LANGID_RON: u32 = 1048;
pub const USB_LANGID_RUS: u32 = 1049;
pub const USB_LANGID_SAN: u32 = 1103;
pub const USB_LANGID_SRB_CYR: u32 = 3098;
pub const USB_LANGID_SRB_LAT: u32 = 2074;
pub const USB_LANGID_SND: u32 = 1113;
pub const USB_LANGID_SLK: u32 = 1051;
pub const USB_LANGID_SLV: u32 = 1060;
pub const USB_LANGID_SPA: u32 = 1034;
pub const USB_LANGID_SPA_MX: u32 = 2058;
pub const USB_LANGID_SPA_MDN: u32 = 3082;
pub const USB_LANGID_SPA_GT: u32 = 4106;
pub const USB_LANGID_SPA_CR: u32 = 5130;
pub const USB_LANGID_SPA_PA: u32 = 6154;
pub const USB_LANGID_SPA_DO: u32 = 7178;
pub const USB_LANGID_SPA_VE: u32 = 8202;
pub const USB_LANGID_SPA_CO: u32 = 9226;
pub const USB_LANGID_SPA_PE: u32 = 10250;
pub const USB_LANGID_SPA_AR: u32 = 11274;
pub const USB_LANGID_SPA_EC: u32 = 12298;
pub const USB_LANGID_SPA_CL: u32 = 13322;
pub const USB_LANGID_SPA_UY: u32 = 14346;
pub const USB_LANGID_SPA_PY: u32 = 15370;
pub const USB_LANGID_SPA_BO: u32 = 16394;
pub const USB_LANGID_SPA_SV: u32 = 17418;
pub const USB_LANGID_SPA_HN: u32 = 18442;
pub const USB_LANGID_SPA_NI: u32 = 19466;
pub const USB_LANGID_SPA_PR: u32 = 20490;
pub const USB_LANGID_NSO: u32 = 1072;
pub const USB_LANGID_SWA: u32 = 1089;
pub const USB_LANGID_SWE: u32 = 1053;
pub const USB_LANGID_SWE_FI: u32 = 2077;
pub const USB_LANGID_TAM: u32 = 1097;
pub const USB_LANGID_TAT: u32 = 1092;
pub const USB_LANGID_TEL: u32 = 1098;
pub const USB_LANGID_THA: u32 = 1054;
pub const USB_LANGID_TUR: u32 = 1055;
pub const USB_LANGIG_UKR: u32 = 1058;
pub const USB_LANGID_URD_PK: u32 = 1056;
pub const USB_LANGID_URD_IN: u32 = 2080;
pub const USB_LANGID_UZB_LAT: u32 = 1091;
pub const USB_LANGID_UZB_CYR: u32 = 2115;
pub const USB_LANGID_VIE: u32 = 1066;
pub const HID_PAGE_DESKTOP: u32 = 1;
pub const HID_DESKTOP_POINTER: u32 = 1;
pub const HID_DESKTOP_MOUSE: u32 = 2;
pub const HID_DESKTOP_JOYSTICK: u32 = 4;
pub const HID_DESKTOP_GAMEPAD: u32 = 5;
pub const HID_DESKTOP_KEYBOARD: u32 = 6;
pub const HID_DESKTOP_KEYPAD: u32 = 7;
pub const HID_DESKTOP_MULTIAXIS: u32 = 8;
pub const HID_DESKTOP_TABLET: u32 = 9;
pub const HID_DESKTOP_X: u32 = 48;
pub const HID_DESKTOP_Y: u32 = 49;
pub const HID_DESKTOP_Z: u32 = 50;
pub const HID_DESKTOP_RX: u32 = 51;
pub const HID_DESKTOP_RY: u32 = 52;
pub const HID_DESKTOP_RZ: u32 = 53;
pub const HID_DESKTOP_SLIDER: u32 = 54;
pub const HID_DESKTOP_DIAL: u32 = 55;
pub const HID_DESKTOP_WHEEL: u32 = 56;
pub const HID_DESKTOP_HAT_SWITCH: u32 = 57;
pub const HID_DESKTOP_MOTION_WAKEUP: u32 = 60;
pub const HID_DESKTOP_START: u32 = 61;
pub const HID_DESKTOP_SELECT: u32 = 62;
pub const HID_DESKTOP_RESOLUTION_MULT: u32 = 72;
pub const HID_DESKTOP_VX: u32 = 64;
pub const HID_DESKTOP_VY: u32 = 65;
pub const HID_DESKTOP_VZ: u32 = 66;
pub const HID_DESKTOP_VBRX: u32 = 67;
pub const HID_DESKTOP_VBRY: u32 = 68;
pub const HID_DESKTOP_VBRZ: u32 = 69;
pub const HID_DESKTOP_VNO: u32 = 70;
pub const HID_DESKTOP_SYS_CONTROL: u32 = 128;
pub const HID_DESKTOP_SYS_CONTEXT_MNU: u32 = 132;
pub const HID_DESKTOP_SYS_MAIN_MNU: u32 = 133;
pub const HID_DESKTOP_SYS_APP_MNU: u32 = 134;
pub const HID_DESKTOP_SYS_MENU_HELP: u32 = 135;
pub const HID_DESKTOP_SYS_MENU_EXIT: u32 = 136;
pub const HID_DESKTOP_SYS_MENU_SELECT: u32 = 137;
pub const HID_DESKTOP_SYS_MENU_RIGHT: u32 = 138;
pub const HID_DESKTOP_SYS_MENU_LEFT: u32 = 139;
pub const HID_DESKTOP_SYS_MENU_UP: u32 = 140;
pub const HID_DESKTOP_SYS_MENU_DOWN: u32 = 141;
pub const HID_DESKTOP_SYS_PWR_DOWN: u32 = 129;
pub const HID_DESKTOP_SYS_SLEEP: u32 = 130;
pub const HID_DESKTOP_SYS_WAKEUP: u32 = 131;
pub const HID_DESKTOP_SYS_RST_COLD: u32 = 142;
pub const HID_DESKTOP_SYS_RST_WARM: u32 = 143;
pub const HID_DESKTOP_SYS_DOCK: u32 = 160;
pub const HID_DESKTOP_SYS_UNDOCK: u32 = 161;
pub const HID_DESKTOP_SYS_SETUP: u32 = 162;
pub const HID_DESKTOP_SYS_SPKR_MUTE: u32 = 167;
pub const HID_DESKTOP_SYS_HIBERNATE: u32 = 168;
pub const HID_DESKTOP_COUNTEDBUF: u32 = 58;
pub const HID_DESKTOP_BYTECOUNT: u32 = 59;
pub const HID_DESKTOP_DPAD_UP: u32 = 144;
pub const HID_DESKTOP_DPAD_DOWN: u32 = 145;
pub const HID_DESKTOP_DPAD_RIGHT: u32 = 146;
pub const HID_DESKTOP_DPAD_LEFT: u32 = 147;
pub const HID_DESKTOP_FEATURE_NOTIFY: u32 = 71;
pub const HID_DESKTOP_SYS_BREAK: u32 = 163;
pub const HID_DESKTOP_SYS_DBG_BREAK: u32 = 164;
pub const HID_DESKTOP_APP_BREAK: u32 = 165;
pub const HID_DESKTOP_APP_DBG_BREAK: u32 = 166;
pub const HID_DESKTOP_SYS_DISP_INVERT: u32 = 176;
pub const HID_DESKTOP_SYS_DISP_INT: u32 = 177;
pub const HID_DESKTOP_SYS_DISP_EXT: u32 = 178;
pub const HID_DESKTOP_SYS_DISP_BOTH: u32 = 179;
pub const HID_DESKTOP_SYS_DISP_DUAL: u32 = 180;
pub const HID_DESKTOP_SYS_DISP_TGL: u32 = 181;
pub const HID_DESKTOP_SYS_DISP_SWAP: u32 = 182;
pub const HID_DESKTOP_SYS_DISP_AUTO: u32 = 183;
pub const HID_PAGE_BUTTON: u32 = 9;
pub const HID_BUTTON_NO_PRESSED: u32 = 0;
pub const HID_BUTTON_1: u32 = 1;
pub const HID_BUTTON_2: u32 = 2;
pub const HID_BUTTON_3: u32 = 3;
pub const HID_BUTTON_4: u32 = 4;
pub const HID_BUTTON_5: u32 = 5;
pub const HID_PAGE_KEYBOARD: u32 = 7;
pub const HID_KEYBOARD_ERR_ROLL_OVER: u32 = 1;
pub const HID_KEYBOARD_POST_FAIL: u32 = 2;
pub const HID_KEYBOARD_ERR_UNDEFINED: u32 = 3;
pub const HID_KEYBOARD_A: u32 = 4;
pub const HID_KEYBOARD_B: u32 = 5;
pub const HID_KEYBOARD_C: u32 = 6;
pub const HID_KEYBOARD_D: u32 = 7;
pub const HID_KEYBOARD_E: u32 = 8;
pub const HID_KEYBOARD_F: u32 = 9;
pub const HID_KEYBOARD_G: u32 = 10;
pub const HID_KEYBOARD_H: u32 = 11;
pub const HID_KEYBOARD_I: u32 = 12;
pub const HID_KEYBOARD_J: u32 = 13;
pub const HID_KEYBOARD_K: u32 = 14;
pub const HID_KEYBOARD_L: u32 = 15;
pub const HID_KEYBOARD_M: u32 = 16;
pub const HID_KEYBOARD_N: u32 = 17;
pub const HID_KEYBOARD_O: u32 = 18;
pub const HID_KEYBOARD_P: u32 = 19;
pub const HID_KEYBOARD_Q: u32 = 20;
pub const HID_KEYBOARD_R: u32 = 21;
pub const HID_KEYBOARD_S: u32 = 22;
pub const HID_KEYBOARD_T: u32 = 23;
pub const HID_KEYBOARD_U: u32 = 24;
pub const HID_KEYBOARD_V: u32 = 25;
pub const HID_KEYBOARD_W: u32 = 26;
pub const HID_KEYBOARD_X: u32 = 27;
pub const HID_KEYBOARD_Y: u32 = 28;
pub const HID_KEYBOARD_Z: u32 = 29;
pub const HID_KEYBOARD_1: u32 = 30;
pub const HID_KEYBOARD_2: u32 = 31;
pub const HID_KEYBOARD_3: u32 = 32;
pub const HID_KEYBOARD_4: u32 = 33;
pub const HID_KEYBOARD_5: u32 = 34;
pub const HID_KEYBOARD_6: u32 = 35;
pub const HID_KEYBOARD_7: u32 = 36;
pub const HID_KEYBOARD_8: u32 = 37;
pub const HID_KEYBOARD_9: u32 = 38;
pub const HID_KEYBOARD_0: u32 = 39;
pub const HID_KEYBOARD_RETURN: u32 = 40;
pub const HID_KEYBOARD_ESCAPE: u32 = 41;
pub const HID_KEYBOARD_DELETE: u32 = 42;
pub const HID_KEYBOARD_TAB: u32 = 43;
pub const HID_KEYBOARD_SPACEBAR: u32 = 44;
pub const HID_KEYBOARD_MINUS: u32 = 45;
pub const HID_KEYBOARD_EQUAL_SIGN: u32 = 46;
pub const HID_KEYBOARD_OPEN_BRACKET: u32 = 47;
pub const HID_KEYBOARD_CLOSE_BRACKET: u32 = 48;
pub const HID_KEYBOARD_BACKSLASH: u32 = 49;
pub const HID_KEYBOARD_NONUS_HASH: u32 = 50;
pub const HID_KEYBOARD_SEMICOLON: u32 = 51;
pub const HID_KEYBOARD_APOSTROPHE: u32 = 52;
pub const HID_KEYBOARD_GRAVE_ACCENT: u32 = 53;
pub const HID_KEYBOARD_COLON: u32 = 54;
pub const HID_KEYBOARD_DOT: u32 = 55;
pub const HID_KEYBOARD_SLASH: u32 = 56;
pub const HID_KEYBOARD_CAPS_LOCK: u32 = 57;
pub const HID_KEYBOARD_F1: u32 = 58;
pub const HID_KEYBOARD_F2: u32 = 59;
pub const HID_KEYBOARD_F3: u32 = 60;
pub const HID_KEYBOARD_F4: u32 = 61;
pub const HID_KEYBOARD_F5: u32 = 62;
pub const HID_KEYBOARD_F6: u32 = 63;
pub const HID_KEYBOARD_F7: u32 = 64;
pub const HID_KEYBOARD_F8: u32 = 65;
pub const HID_KEYBOARD_F9: u32 = 66;
pub const HID_KEYBOARD_F10: u32 = 67;
pub const HID_KEYBOARD_F11: u32 = 68;
pub const HID_KEYBOARD_F12: u32 = 69;
pub const HID_KEYBOARD_PRINT_SCREEN: u32 = 70;
pub const HID_KEYBOARD_SCROLL_LOCK: u32 = 71;
pub const HID_KEYBOARD_PAUSE: u32 = 72;
pub const HID_KEYBOARD_INSERT: u32 = 73;
pub const HID_KEYBOARD_HOME: u32 = 74;
pub const HID_KEYBOARD_PAGE_UP: u32 = 75;
pub const HID_KEYBOARD_DELETE_FORWARD: u32 = 76;
pub const HID_KEYBOARD_END: u32 = 77;
pub const HID_KEYBOARD_PAGE_DOWN: u32 = 78;
pub const HID_KEYBOARD_RIGHT_ARROW: u32 = 79;
pub const HID_KEYBOARD_LEFT_ARROW: u32 = 80;
pub const HID_KEYBOARD_DOWN_ARROW: u32 = 81;
pub const HID_KEYBOARD_UP_ARROW: u32 = 82;
pub const HID_KEYPAD_NUMLOCK: u32 = 83;
pub const HID_KEYPAD_SLASH: u32 = 84;
pub const HID_KEYPAD_ASTERISK: u32 = 85;
pub const HID_KEYPAD_MINUS: u32 = 86;
pub const HID_KEYPAD_PLUS: u32 = 87;
pub const HID_KEYPAD_ENTER: u32 = 88;
pub const HID_KEYPAD_1: u32 = 89;
pub const HID_KEYPAD_2: u32 = 90;
pub const HID_KEYPAD_3: u32 = 91;
pub const HID_KEYPAD_4: u32 = 92;
pub const HID_KEYPAD_5: u32 = 93;
pub const HID_KEYPAD_6: u32 = 94;
pub const HID_KEYPAD_7: u32 = 95;
pub const HID_KEYPAD_8: u32 = 96;
pub const HID_KEYPAD_9: u32 = 97;
pub const HID_KEYPAD_0: u32 = 98;
pub const HID_KEYPAD_DOT: u32 = 99;
pub const HID_KEYBOARD_NONUS_BACKSLASH: u32 = 100;
pub const HID_KEYBOARD_APPLICATION: u32 = 101;
pub const HID_KEYBOARD_POWER: u32 = 102;
pub const HID_KEYPAD_EQUAL: u32 = 103;
pub const HID_KEYBOARD_F13: u32 = 104;
pub const HID_KEYBOARD_F14: u32 = 105;
pub const HID_KEYBOARD_F15: u32 = 106;
pub const HID_KEYBOARD_F16: u32 = 107;
pub const HID_KEYBOARD_F17: u32 = 108;
pub const HID_KEYBOARD_F18: u32 = 109;
pub const HID_KEYBOARD_F19: u32 = 110;
pub const HID_KEYBOARD_F20: u32 = 111;
pub const HID_KEYBOARD_F21: u32 = 112;
pub const HID_KEYBOARD_F22: u32 = 113;
pub const HID_KEYBOARD_F23: u32 = 114;
pub const HID_KEYBOARD_F24: u32 = 115;
pub const HID_KEYBOARD_EXECUTE: u32 = 116;
pub const HID_KEYBOARD_HELP: u32 = 117;
pub const HID_KEYBOARD_MENU: u32 = 118;
pub const HID_KEYBOARD_SELECT: u32 = 119;
pub const HID_KEYBOARD_STOP: u32 = 120;
pub const HID_KEYBOARD_AGAIN: u32 = 121;
pub const HID_KEYBOARD_UNDO: u32 = 122;
pub const HID_KEYBOARD_CUT: u32 = 123;
pub const HID_KEYBOARD_COPY: u32 = 124;
pub const HID_KEYBOARD_PASTE: u32 = 125;
pub const HID_KEYBOARD_FIND: u32 = 126;
pub const HID_KEYBOARD_MUTE: u32 = 127;
pub const HID_KEYBOARD_VOLUME_UP: u32 = 128;
pub const HID_KEYBOARD_VOLUME_DOWN: u32 = 129;
pub const HID_KEYBOARD_LOCK_CAPS_LOCK: u32 = 130;
pub const HID_KEYBOARD_LOCK_NUM_LOCK: u32 = 131;
pub const HID_KEYBOARD_LOCK_SCROLL_LOCK: u32 = 132;
pub const HID_KEYPAD_COMMA: u32 = 133;
pub const HID_KEYPAD_EQUAL_SIGN: u32 = 134;
pub const HID_KEYBOARD_INTERNATIONAL_1: u32 = 135;
pub const HID_KEYBOARD_INTERNATIONAL_2: u32 = 136;
pub const HID_KEYBOARD_INTERNATIONAL_3: u32 = 137;
pub const HID_KEYBOARD_INTERNATIONAL_4: u32 = 138;
pub const HID_KEYBOARD_INTERNATIONAL_5: u32 = 139;
pub const HID_KEYBOARD_INTERNATIONAL_6: u32 = 140;
pub const HID_KEYBOARD_INTERNATIONAL_7: u32 = 141;
pub const HID_KEYBOARD_INTERNATIONAL_8: u32 = 142;
pub const HID_KEYBOARD_INTERNATIONAL_9: u32 = 143;
pub const HID_KEYBOARD_LANG_1: u32 = 144;
pub const HID_KEYBOARD_LANG_2: u32 = 145;
pub const HID_KEYBOARD_LANG_3: u32 = 146;
pub const HID_KEYBOARD_LANG_4: u32 = 147;
pub const HID_KEYBOARD_LANG_5: u32 = 148;
pub const HID_KEYBOARD_LANG_6: u32 = 149;
pub const HID_KEYBOARD_LANG_7: u32 = 150;
pub const HID_KEYBOARD_LANG_8: u32 = 151;
pub const HID_KEYBOARD_LANG_9: u32 = 152;
pub const HID_KEYBOARD_ALTERNATE_ERASE: u32 = 153;
pub const HID_KEYBOARD_SYSREQ: u32 = 154;
pub const HID_KEYBOARD_CANCEL: u32 = 155;
pub const HID_KEYBOARD_CLEAR: u32 = 156;
pub const HID_KEYBOARD_PRIOR: u32 = 157;
pub const HID_KEYBOARD_RETURN_1: u32 = 158;
pub const HID_KEYBOARD_SEPARATOR: u32 = 159;
pub const HID_KEYBOARD_OUT: u32 = 160;
pub const HID_KEYBOARD_OPER: u32 = 161;
pub const HID_KEYBOARD_CLEAR_AGAIN: u32 = 162;
pub const HID_KEYBOARD_CRSEL_PROPS: u32 = 163;
pub const HID_KEYBOARD_EXSEL: u32 = 164;
pub const HID_KEYPAD_00: u32 = 176;
pub const HID_KEYPAD_000: u32 = 177;
pub const HID_KEYPAD_OPEN_PARENTHESIS: u32 = 182;
pub const HID_KEYPAD_CLOSE_PARENTHESIS: u32 = 183;
pub const HID_KEYPAD_OPEN_BRACE: u32 = 184;
pub const HID_KEYPAD_CLOSE_BRACE: u32 = 185;
pub const HID_KEYPAD_TAB: u32 = 186;
pub const HID_KEYPAD_BACKSPACE: u32 = 187;
pub const HID_KEYPAD_A: u32 = 188;
pub const HID_KEYPAD_B: u32 = 189;
pub const HID_KEYPAD_C: u32 = 190;
pub const HID_KEYPAD_D: u32 = 191;
pub const HID_KEYPAD_E: u32 = 192;
pub const HID_KEYPAD_F: u32 = 193;
pub const HID_KEYPAD_XOR: u32 = 194;
pub const HID_KEYPAD_CARET: u32 = 195;
pub const HID_KEYPAD_PERCENT: u32 = 196;
pub const HID_KEYPAD_LESS_THEN: u32 = 197;
pub const HID_KEYPAD_GREATER_THEN: u32 = 198;
pub const HID_KEYPAD_AMPERSAND: u32 = 199;
pub const HID_KEYPAD_DOUBLE_AMPERSAND: u32 = 200;
pub const HID_KEYPAD_PIPE: u32 = 201;
pub const HID_KEYPAD_DOUBLE_PIPE: u32 = 202;
pub const HID_KEYPAD_COLON: u32 = 203;
pub const HID_KEYPAD_HASH: u32 = 204;
pub const HID_KEYPAD_SPACE: u32 = 205;
pub const HID_KEYPAD_AT: u32 = 206;
pub const HID_KEYPAD_BANG: u32 = 207;
pub const HID_KEYPAD_MEM_STORE: u32 = 208;
pub const HID_KEYPAD_MEM_RECALL: u32 = 209;
pub const HID_KEYPAD_MEM_CLEAR: u32 = 210;
pub const HID_KEYPAD_MEM_ADD: u32 = 211;
pub const HID_KEYPAD_MEM_SUBTRACT: u32 = 212;
pub const HID_KEYPAD_MEM_MULTIPLY: u32 = 213;
pub const HID_KEYPAD_MEM_DIVIDE: u32 = 214;
pub const HID_KEYPAD_PLUS_MINUS: u32 = 215;
pub const HID_KEYPAD_CLEAR: u32 = 216;
pub const HID_KEYPAD_CLEAR_ENTRY: u32 = 217;
pub const HID_KEYPAD_BINARY: u32 = 218;
pub const HID_KEYPAD_OCTAL: u32 = 219;
pub const HID_KEYPAD_DECIMAL: u32 = 220;
pub const HID_KEYPAD_HEXADECIMAL: u32 = 221;
pub const HID_KEYBOARD_L_CTRL: u32 = 224;
pub const HID_KEYBOARD_L_SHIFT: u32 = 225;
pub const HID_KEYBOARD_L_ALT: u32 = 226;
pub const HID_KEYBOARD_L_GUI: u32 = 227;
pub const HID_KEYBOARD_R_CTRL: u32 = 228;
pub const HID_KEYBOARD_R_SHIFT: u32 = 229;
pub const HID_KEYBOARD_R_ALT: u32 = 230;
pub const HID_KEYBOARD_R_GUI: u32 = 231;
pub const HID_PAGE_CONSUMER: u32 = 12;
pub const HID_CONSUMER_UNASSIGNED: u32 = 0;
pub const HID_CONSUMER_CONTROL: u32 = 1;
pub const HID_CONSUMER_NUMERIC_KEY_PAD: u32 = 2;
pub const HID_CONSUMER_PROGRAMMABLE_BUTTONS: u32 = 3;
pub const HID_CONSUMER_MICROPHONE: u32 = 4;
pub const HID_CONSUMER_HEADPHONE: u32 = 5;
pub const HID_CONSUMER_GRAPHIC_EQUALIZER: u32 = 6;
pub const HID_CONSUMER_PLUS_10: u32 = 32;
pub const HID_CONSUMER_PLUS_100: u32 = 33;
pub const HID_CONSUMER_AM_PM: u32 = 34;
pub const HID_CONSUMER_POWER: u32 = 48;
pub const HID_CONSUMER_RESET: u32 = 49;
pub const HID_CONSUMER_SLEEP: u32 = 50;
pub const HID_CONSUMER_SLEEP_AFTER: u32 = 51;
pub const HID_CONSUMER_SLEEP_MODE: u32 = 52;
pub const HID_CONSUMER_ILLUMINATION: u32 = 53;
pub const HID_CONSUMER_FUNCTION_BUTTONS: u32 = 54;
pub const HID_CONSUMER_MENU: u32 = 64;
pub const HID_CONSUMER_MENU_PICK: u32 = 65;
pub const HID_CONSUMER_MENU_UP: u32 = 66;
pub const HID_CONSUMER_MENU_DOWN: u32 = 67;
pub const HID_CONSUMER_MENU_LEFT: u32 = 68;
pub const HID_CONSUMER_MENU_RIGHT: u32 = 69;
pub const HID_CONSUMER_MENU_ESCAPE: u32 = 70;
pub const HID_CONSUMER_MENU_VALUE_INCREASE: u32 = 71;
pub const HID_CONSUMER_MENU_VALUE_DECREASE: u32 = 72;
pub const HID_CONSUMER_DATA_ON_SCREEN: u32 = 96;
pub const HID_CONSUMER_CLOSED_CAPTION: u32 = 97;
pub const HID_CONSUMER_CLOSED_CAPTION_SELECT: u32 = 98;
pub const HID_CONSUMER_VCR_TV: u32 = 99;
pub const HID_CONSUMER_BROADCAST_MODE: u32 = 100;
pub const HID_CONSUMER_SNAPSHOT: u32 = 101;
pub const HID_CONSUMER_STILL: u32 = 102;
pub const HID_CONSUMER_SELECTION: u32 = 128;
pub const HID_CONSUMER_ASSIGN_SELECTION: u32 = 129;
pub const HID_CONSUMER_MODE_STEP: u32 = 130;
pub const HID_CONSUMER_RECALL_LAST: u32 = 131;
pub const HID_CONSUMER_ENTER_CHANNEL: u32 = 132;
pub const HID_CONSUMER_ORDER_MOVIE: u32 = 133;
pub const HID_CONSUMER_CHANNEL: u32 = 134;
pub const HID_CONSUMER_MEDIA_SELECTION: u32 = 135;
pub const HID_CONSUMER_MEDIA_SELECT_COMPUTER: u32 = 136;
pub const HID_CONSUMER_MEDIA_SELECT_TV: u32 = 137;
pub const HID_CONSUMER_MEDIA_SELECT_WWW: u32 = 138;
pub const HID_CONSUMER_MEDIA_SELECT_DVD: u32 = 139;
pub const HID_CONSUMER_MEDIA_SELECT_TELEPHONE: u32 = 140;
pub const HID_CONSUMER_MEDIA_SELECT_PROGRAM_GUIDE: u32 = 141;
pub const HID_CONSUMER_MEDIA_SELECT_VIDEO_PHONE: u32 = 142;
pub const HID_CONSUMER_MEDIA_SELECT_GAMES: u32 = 143;
pub const HID_CONSUMER_MEDIA_SELECT_MESSAGES: u32 = 144;
pub const HID_CONSUMER_MEDIA_SELECT_CD: u32 = 145;
pub const HID_CONSUMER_MEDIA_SELECT_VCR: u32 = 146;
pub const HID_CONSUMER_MEDIA_SELECT_TUNER: u32 = 147;
pub const HID_CONSUMER_QUIT: u32 = 148;
pub const HID_CONSUMER_HELP: u32 = 149;
pub const HID_CONSUMER_MEDIA_SELECT_TAPE: u32 = 150;
pub const HID_CONSUMER_MEDIA_SELECT_CABLE: u32 = 151;
pub const HID_CONSUMER_MEDIA_SELECT_SATELLITE: u32 = 152;
pub const HID_CONSUMER_MEDIA_SELECT_SECURITY: u32 = 153;
pub const HID_CONSUMER_MEDIA_SELECT_HOME: u32 = 154;
pub const HID_CONSUMER_MEDIA_SELECT_CALL: u32 = 155;
pub const HID_CONSUMER_CHANNEL_INCREMENT: u32 = 156;
pub const HID_CONSUMER_CHANNEL_DECREMENT: u32 = 157;
pub const HID_CONSUMER_MEDIA_SELECT_SAP: u32 = 158;
pub const HID_CONSUMER_VCR_PLUS: u32 = 160;
pub const HID_CONSUMER_ONCE: u32 = 161;
pub const HID_CONSUMER_DAILY: u32 = 162;
pub const HID_CONSUMER_WEEKLY: u32 = 163;
pub const HID_CONSUMER_MONTHLY: u32 = 164;
pub const HID_CONSUMER_PLAY: u32 = 176;
pub const HID_CONSUMER_PAUSE: u32 = 177;
pub const HID_CONSUMER_RECORD: u32 = 178;
pub const HID_CONSUMER_FAST_FORWARD: u32 = 179;
pub const HID_CONSUMER_REWIND: u32 = 180;
pub const HID_CONSUMER_SCAN_NEXT_TRACK: u32 = 181;
pub const HID_CONSUMER_SCAN_PREVIOUS_TRACK: u32 = 182;
pub const HID_CONSUMER_STOP: u32 = 183;
pub const HID_CONSUMER_EJECT: u32 = 184;
pub const HID_CONSUMER_RANDOM_PLAY: u32 = 185;
pub const HID_CONSUMER_SELECT_DISC: u32 = 186;
pub const HID_CONSUMER_ENTER_DISC: u32 = 187;
pub const HID_CONSUMER_REPEAT: u32 = 188;
pub const HID_CONSUMER_TRACKING: u32 = 189;
pub const HID_CONSUMER_TRACK_NORMAL: u32 = 190;
pub const HID_CONSUMER_SLOW_TRACKING: u32 = 191;
pub const HID_CONSUMER_FRAME_FORWARD: u32 = 192;
pub const HID_CONSUMER_FRAME_BACK: u32 = 193;
pub const HID_CONSUMER_MARK: u32 = 194;
pub const HID_CONSUMER_CLEAR_MARK: u32 = 195;
pub const HID_CONSUMER_REPEAT_FROM_MARK: u32 = 196;
pub const HID_CONSUMER_RETURN_TO_MARK: u32 = 197;
pub const HID_CONSUMER_SEARCH_MARK_FORWARD: u32 = 198;
pub const HID_CONSUMER_SEARCH_MARK_BACKWARDS: u32 = 199;
pub const HID_CONSUMER_COUNTER_RESET: u32 = 200;
pub const HID_CONSUMER_SHOW_COUNTER: u32 = 201;
pub const HID_CONSUMER_TRACKING_INCREMENT: u32 = 202;
pub const HID_CONSUMER_TRACKING_DECREMENT: u32 = 203;
pub const HID_CONSUMER_STOP_EJECT: u32 = 204;
pub const HID_CONSUMER_PLAY_PAUSE: u32 = 205;
pub const HID_CONSUMER_PLAY_SKIP: u32 = 206;
pub const HID_CONSUMER_VOLUME: u32 = 224;
pub const HID_CONSUMER_BALANCE: u32 = 225;
pub const HID_CONSUMER_MUTE: u32 = 226;
pub const HID_CONSUMER_BASS: u32 = 227;
pub const HID_CONSUMER_TREBLE: u32 = 228;
pub const HID_CONSUMER_BASS_BOOST: u32 = 229;
pub const HID_CONSUMER_SURROUND_MODE: u32 = 230;
pub const HID_CONSUMER_LOUDNESS: u32 = 231;
pub const HID_CONSUMER_MPX: u32 = 232;
pub const HID_CONSUMER_VOLUME_INCREMENT: u32 = 233;
pub const HID_CONSUMER_VOLUME_DECREMENT: u32 = 234;
pub const HID_CONSUMER_SPEED_SELECT: u32 = 240;
pub const HID_CONSUMER_PLAYBACK_SPEED: u32 = 241;
pub const HID_CONSUMER_STANDARD_PLAY: u32 = 242;
pub const HID_CONSUMER_LONG_PLAY: u32 = 243;
pub const HID_CONSUMER_EXTENDED_PLAY: u32 = 244;
pub const HID_CONSUMER_SLOW: u32 = 245;
pub const HID_CONSUMER_FAN_ENABLE: u32 = 256;
pub const HID_CONSUMER_FAN_SPEED: u32 = 257;
pub const HID_CONSUMER_LIGHT_ENABLE: u32 = 258;
pub const HID_CONSUMER_LIGHT_ILLUMINATION_LEVEL: u32 = 259;
pub const HID_CONSUMER_CLIMATE_CONTROL_ENABLE: u32 = 260;
pub const HID_CONSUMER_ROOM_TEMPERATURE: u32 = 261;
pub const HID_CONSUMER_SECURITY_ENABLE: u32 = 262;
pub const HID_CONSUMER_FIRE_ALARM: u32 = 263;
pub const HID_CONSUMER_POLICE_ALARM: u32 = 264;
pub const HID_CONSUMER_PROXIMITY: u32 = 265;
pub const HID_CONSUMER_MOTION: u32 = 266;
pub const HID_CONSUMER_DURESS_ALARM: u32 = 267;
pub const HID_CONSUMER_HOLDUP_ALARM: u32 = 268;
pub const HID_CONSUMER_MEDICAL_ALARM: u32 = 269;
pub const HID_CONSUMER_BALANCE_RIGHT: u32 = 336;
pub const HID_CONSUMER_BALANCE_LEFT: u32 = 337;
pub const HID_CONSUMER_BASS_INCREMENT: u32 = 338;
pub const HID_CONSUMER_BASS_DECREMENT: u32 = 339;
pub const HID_CONSUMER_TREBLE_INCREMENT: u32 = 340;
pub const HID_CONSUMER_TREBLE_DECREMENT: u32 = 341;
pub const HID_CONSUMER_SPEAKER_SYSTEM: u32 = 352;
pub const HID_CONSUMER_CHANNEL_LEFT: u32 = 353;
pub const HID_CONSUMER_CHANNEL_RIGHT: u32 = 354;
pub const HID_CONSUMER_CHANNEL_CENTER: u32 = 355;
pub const HID_CONSUMER_CHANNEL_FRONT: u32 = 356;
pub const HID_CONSUMER_CHANNEL_CENTER_FRONT: u32 = 357;
pub const HID_CONSUMER_CHANNEL_SIDE: u32 = 358;
pub const HID_CONSUMER_CHANNEL_SURROUND: u32 = 359;
pub const HID_CONSUMER_CHANNEL_LOW_FREQUENCY_ENHANCEMENT: u32 = 360;
pub const HID_CONSUMER_CHANNEL_TOP: u32 = 361;
pub const HID_CONSUMER_CHANNEL_UNKNOWN: u32 = 362;
pub const HID_CONSUMER_SUB_CHANNEL: u32 = 368;
pub const HID_CONSUMER_SUB_CHANNEL_INCREMENT: u32 = 369;
pub const HID_CONSUMER_SUB_CHANNEL_DECREMENT: u32 = 370;
pub const HID_CONSUMER_ALTERNATE_AUDIO_INCREMENT: u32 = 371;
pub const HID_CONSUMER_ALTERNATE_AUDIO_DECREMENT: u32 = 372;
pub const HID_CONSUMER_APPLICATION_LAUNCH_BUTTONS: u32 = 384;
pub const HID_CONSUMER_AL_LAUNCH_BUTTON_CONFIGURATION_TOOL: u32 = 385;
pub const HID_CONSUMER_AL_PROGRAMMABLE_BUTTON_CONFIGURATION: u32 = 386;
pub const HID_CONSUMER_AL_CONSUMER_CONTROL_CONFIGURATION: u32 = 387;
pub const HID_CONSUMER_AL_WORD_PROCESSOR: u32 = 388;
pub const HID_CONSUMER_AL_TEXT_EDITOR: u32 = 389;
pub const HID_CONSUMER_AL_SPREADSHEET: u32 = 390;
pub const HID_CONSUMER_AL_GRAPHICS_EDITOR: u32 = 391;
pub const HID_CONSUMER_AL_PRESENTATION_APP: u32 = 392;
pub const HID_CONSUMER_AL_DATABASE_APP: u32 = 393;
pub const HID_CONSUMER_AL_EMAIL_READER: u32 = 394;
pub const HID_CONSUMER_AL_NEWSREADER: u32 = 395;
pub const HID_CONSUMER_AL_VOICEMAIL: u32 = 396;
pub const HID_CONSUMER_AL_CONTACTS_ADDRESS_BOOK: u32 = 397;
pub const HID_CONSUMER_AL_CALENDAR_SCHEDULE: u32 = 398;
pub const HID_CONSUMER_AL_TASK_PROJECT_MANAGER: u32 = 399;
pub const HID_CONSUMER_AL_LOG_JOURNAL_TIMECARD: u32 = 400;
pub const HID_CONSUMER_AL_CHECKBOOK_FINANCE: u32 = 401;
pub const HID_CONSUMER_AL_CALCULATOR: u32 = 402;
pub const HID_CONSUMER_AL_A_V_CAPTURE_PLAYBACK: u32 = 403;
pub const HID_CONSUMER_AL_LOCAL_MACHINE_BROWSER: u32 = 404;
pub const HID_CONSUMER_AL_LAN_WAN_BROWSER: u32 = 405;
pub const HID_CONSUMER_AL_INTERNET_BROWSER: u32 = 406;
pub const HID_CONSUMER_AL_REMOTE_NETWORKING_ISP_CONNECT: u32 = 407;
pub const HID_CONSUMER_AL_NETWORK_CONFERENCE: u32 = 408;
pub const HID_CONSUMER_AL_NETWORK_CHAT: u32 = 409;
pub const HID_CONSUMER_AL_TELEPHONY_DIALER: u32 = 410;
pub const HID_CONSUMER_AL_LOGON: u32 = 411;
pub const HID_CONSUMER_AL_LOGOFF: u32 = 412;
pub const HID_CONSUMER_AL_LOGON_LOGOFF: u32 = 413;
pub const HID_CONSUMER_AL_TERMINAL_LOCK_SCREENSAVER: u32 = 414;
pub const HID_CONSUMER_AL_CONTROL_PANEL: u32 = 415;
pub const HID_CONSUMER_AL_COMMAND_LINE_PROCESSOR_RUN: u32 = 416;
pub const HID_CONSUMER_AL_PROCESS_TASK_MANAGER: u32 = 417;
pub const HID_CONSUMER_AL_SELECT_TASK_APPLICATION: u32 = 418;
pub const HID_CONSUMER_AL_NEXT_TASK_APPLICATION: u32 = 419;
pub const HID_CONSUMER_AL_PREVIOUS_TASK_APPLICATION: u32 = 420;
pub const HID_CONSUMER_AL_PREEMPTIVE_HALT_TASK_APPLICATION: u32 = 421;
pub const HID_CONSUMER_AL_INTEGRATED_HELP_CENTER: u32 = 422;
pub const HID_CONSUMER_AL_DOCUMENTS: u32 = 423;
pub const HID_CONSUMER_AL_THESAURUS: u32 = 424;
pub const HID_CONSUMER_AL_DICTIONARY: u32 = 425;
pub const HID_CONSUMER_AL_DESKTOP: u32 = 426;
pub const HID_CONSUMER_AL_SPELL_CHECK: u32 = 427;
pub const HID_CONSUMER_AL_GRAMMAR_CHECK: u32 = 428;
pub const HID_CONSUMER_AL_WIRELESS_STATUS: u32 = 429;
pub const HID_CONSUMER_AL_KEYBOARD_LAYOUT: u32 = 430;
pub const HID_CONSUMER_AL_VIRUS_PROTECTION: u32 = 431;
pub const HID_CONSUMER_AL_ENCRYPTION: u32 = 432;
pub const HID_CONSUMER_AL_SCREEN_SAVER: u32 = 433;
pub const HID_CONSUMER_AL_ALARMS: u32 = 434;
pub const HID_CONSUMER_AL_CLOCK: u32 = 435;
pub const HID_CONSUMER_AL_FILE_BROWSER: u32 = 436;
pub const HID_CONSUMER_AL_POWER_STATUS: u32 = 437;
pub const HID_CONSUMER_AL_IMAGE_BROWSER: u32 = 438;
pub const HID_CONSUMER_AL_AUDIO_BROWSER: u32 = 439;
pub const HID_CONSUMER_AL_MOVIE_BROWSER: u32 = 440;
pub const HID_CONSUMER_AL_DIGITAL_RIGHTS_MANAGER: u32 = 441;
pub const HID_CONSUMER_AL_DIGITAL_WALLET: u32 = 442;
pub const HID_CONSUMER_AL_INSTANT_MESSAGING: u32 = 444;
pub const HID_CONSUMER_AL_OEM_FEATURES_TIPS_TUTORIAL_BROWSER: u32 = 445;
pub const HID_CONSUMER_AL_OEM_HELP: u32 = 446;
pub const HID_CONSUMER_AL_ONLINE_COMMUNITY: u32 = 447;
pub const HID_CONSUMER_AL_ENTERTAINMENT_CONTENT_BROWSER: u32 = 448;
pub const HID_CONSUMER_AL_ONLINE_SHOPPING_BROWSER: u32 = 449;
pub const HID_CONSUMER_AL_SMARTCARD_INFORMATION_HELP: u32 = 450;
pub const HID_CONSUMER_AL_MARKET_MONITOR_FINANCE_BROWSER: u32 = 451;
pub const HID_CONSUMER_AL_CUSTOMIZED_CORPORATE_NEWS_BROWSER: u32 = 452;
pub const HID_CONSUMER_AL_ONLINE_ACTIVITY_BROWSER: u32 = 453;
pub const HID_CONSUMER_AL_RESEARCH_SEARCH_BROWSER: u32 = 454;
pub const HID_CONSUMER_AL_AUDIO_PLAYER: u32 = 455;
pub const HID_CONSUMER_GENERIC_GUI_APPLICATION_CONTROLS: u32 = 512;
pub const HID_CONSUMER_AC_NEW: u32 = 513;
pub const HID_CONSUMER_AC_OPEN: u32 = 514;
pub const HID_CONSUMER_AC_CLOSE: u32 = 515;
pub const HID_CONSUMER_AC_EXIT: u32 = 516;
pub const HID_CONSUMER_AC_MAXIMIZE: u32 = 517;
pub const HID_CONSUMER_AC_MINIMIZE: u32 = 518;
pub const HID_CONSUMER_AC_SAVE: u32 = 519;
pub const HID_CONSUMER_AC_PRINT: u32 = 520;
pub const HID_CONSUMER_AC_PROPERTIES: u32 = 521;
pub const HID_CONSUMER_AC_UNDO: u32 = 538;
pub const HID_CONSUMER_AC_COPY: u32 = 539;
pub const HID_CONSUMER_AC_CUT: u32 = 540;
pub const HID_CONSUMER_AC_PASTE: u32 = 541;
pub const HID_CONSUMER_AC_SELECT_ALL: u32 = 542;
pub const HID_CONSUMER_AC_FIND: u32 = 543;
pub const HID_CONSUMER_AC_FIND_AND_REPLACE: u32 = 544;
pub const HID_CONSUMER_AC_SEARCH: u32 = 545;
pub const HID_CONSUMER_AC_GO_TO: u32 = 546;
pub const HID_CONSUMER_AC_HOME: u32 = 547;
pub const HID_CONSUMER_AC_BACK: u32 = 548;
pub const HID_CONSUMER_AC_FORWARD: u32 = 549;
pub const HID_CONSUMER_AC_STOP: u32 = 550;
pub const HID_CONSUMER_AC_REFRESH: u32 = 551;
pub const HID_CONSUMER_AC_PREVIOUS_LINK: u32 = 552;
pub const HID_CONSUMER_AC_NEXT_LINK: u32 = 553;
pub const HID_CONSUMER_AC_BOOKMARKS: u32 = 554;
pub const HID_CONSUMER_AC_HISTORY: u32 = 555;
pub const HID_CONSUMER_AC_SUBSCRIPTIONS: u32 = 556;
pub const HID_CONSUMER_AC_ZOOM_IN: u32 = 557;
pub const HID_CONSUMER_AC_ZOOM_OUT: u32 = 558;
pub const HID_CONSUMER_AC_ZOOM: u32 = 559;
pub const HID_CONSUMER_AC_FULL_SCREEN_VIEW: u32 = 560;
pub const HID_CONSUMER_AC_NORMAL_VIEW: u32 = 561;
pub const HID_CONSUMER_AC_VIEW_TOGGLE: u32 = 562;
pub const HID_CONSUMER_AC_SCROLL_UP: u32 = 563;
pub const HID_CONSUMER_AC_SCROLL_DOWN: u32 = 564;
pub const HID_CONSUMER_AC_SCROLL: u32 = 565;
pub const HID_CONSUMER_AC_PAN_LEFT: u32 = 566;
pub const HID_CONSUMER_AC_PAN_RIGHT: u32 = 567;
pub const HID_CONSUMER_AC_PAN: u32 = 568;
pub const HID_CONSUMER_AC_NEW_WINDOW: u32 = 569;
pub const HID_CONSUMER_AC_TILE_HORIZONTALLY: u32 = 570;
pub const HID_CONSUMER_AC_TILE_VERTICALLY: u32 = 571;
pub const HID_CONSUMER_AC_FORMAT: u32 = 572;
pub const HID_CONSUMER_AC_EDIT: u32 = 573;
pub const HID_CONSUMER_AC_BOLD: u32 = 574;
pub const HID_CONSUMER_AC_ITALICS: u32 = 575;
pub const HID_CONSUMER_AC_UNDERLINE: u32 = 576;
pub const HID_CONSUMER_AC_STRIKETHROUGH: u32 = 577;
pub const HID_CONSUMER_AC_SUBSCRIPT: u32 = 578;
pub const HID_CONSUMER_AC_SUPERSCRIPT: u32 = 579;
pub const HID_CONSUMER_AC_ALL_CAPS: u32 = 580;
pub const HID_CONSUMER_AC_ROTATE: u32 = 581;
pub const HID_CONSUMER_AC_RESIZE: u32 = 582;
pub const HID_CONSUMER_AC_FLIP_HORIZONTAL: u32 = 583;
pub const HID_CONSUMER_AC_FLIP_VERTICAL: u32 = 584;
pub const HID_CONSUMER_AC_MIRROR_HORIZONTAL: u32 = 585;
pub const HID_CONSUMER_AC_MIRROR_VERTICAL: u32 = 586;
pub const HID_CONSUMER_AC_FONT_SELECT: u32 = 587;
pub const HID_CONSUMER_AC_FONT_COLOR: u32 = 588;
pub const HID_CONSUMER_AC_FONT_SIZE: u32 = 589;
pub const HID_CONSUMER_AC_JUSTIFY_LEFT: u32 = 590;
pub const HID_CONSUMER_AC_JUSTIFY_CENTER_H: u32 = 591;
pub const HID_CONSUMER_AC_JUSTIFY_RIGHT: u32 = 592;
pub const HID_CONSUMER_AC_JUSTIFY_BLOCK_H: u32 = 593;
pub const HID_CONSUMER_AC_JUSTIFY_TOP: u32 = 594;
pub const HID_CONSUMER_AC_JUSTIFY_CENTER_V: u32 = 595;
pub const HID_CONSUMER_AC_JUSTIFY_BOTTOM: u32 = 596;
pub const HID_CONSUMER_AC_JUSTIFY_BLOCK_V: u32 = 597;
pub const HID_CONSUMER_AC_INDENT_DECREASE: u32 = 598;
pub const HID_CONSUMER_AC_INDENT_INCREASE: u32 = 599;
pub const HID_CONSUMER_AC_NUMBERED_LIST: u32 = 600;
pub const HID_CONSUMER_AC_RESTART_NUMBERING: u32 = 601;
pub const HID_CONSUMER_AC_BULLETED_LIST: u32 = 602;
pub const HID_CONSUMER_AC_PROMOTE: u32 = 603;
pub const HID_CONSUMER_AC_DEMOTE: u32 = 604;
pub const HID_CONSUMER_AC_YES: u32 = 605;
pub const HID_CONSUMER_AC_NO: u32 = 606;
pub const HID_CONSUMER_AC_CANCEL: u32 = 607;
pub const HID_CONSUMER_AC_CATALOG: u32 = 608;
pub const HID_CONSUMER_AC_BUY_CHECKOUT: u32 = 609;
pub const HID_CONSUMER_AC_ADD_TO_CART: u32 = 610;
pub const HID_CONSUMER_AC_EXPAND: u32 = 611;
pub const HID_CONSUMER_AC_EXPAND_ALL: u32 = 612;
pub const HID_CONSUMER_AC_COLLAPSE: u32 = 613;
pub const HID_CONSUMER_AC_COLLAPSE_ALL: u32 = 614;
pub const HID_CONSUMER_AC_PRINT_PREVIEW: u32 = 615;
pub const HID_CONSUMER_AC_PASTE_SPECIAL: u32 = 616;
pub const HID_CONSUMER_AC_INSERT_MODE: u32 = 617;
pub const HID_CONSUMER_AC_DELETE: u32 = 618;
pub const HID_CONSUMER_AC_LOCK: u32 = 619;
pub const HID_CONSUMER_AC_UNLOCK: u32 = 620;
pub const HID_CONSUMER_AC_PROTECT: u32 = 621;
pub const HID_CONSUMER_AC_UNPROTECT: u32 = 622;
pub const HID_CONSUMER_AC_ATTACH_COMMENT: u32 = 623;
pub const HID_CONSUMER_AC_DELETE_COMMENT: u32 = 624;
pub const HID_CONSUMER_AC_VIEW_COMMENT: u32 = 625;
pub const HID_CONSUMER_AC_SELECT_WORD: u32 = 626;
pub const HID_CONSUMER_AC_SELECT_SENTENCE: u32 = 627;
pub const HID_CONSUMER_AC_SELECT_PARAGRAPH: u32 = 628;
pub const HID_CONSUMER_AC_SELECT_COLUMN: u32 = 629;
pub const HID_CONSUMER_AC_SELECT_ROW: u32 = 630;
pub const HID_CONSUMER_AC_SELECT_TABLE: u32 = 631;
pub const HID_CONSUMER_AC_SELECT_OBJECT: u32 = 632;
pub const HID_CONSUMER_AC_REDO_REPEAT: u32 = 633;
pub const HID_CONSUMER_AC_SORT: u32 = 634;
pub const HID_CONSUMER_AC_SORT_ASCENDING: u32 = 635;
pub const HID_CONSUMER_AC_SORT_DESCENDING: u32 = 636;
pub const HID_CONSUMER_AC_FILTER: u32 = 637;
pub const HID_CONSUMER_AC_SET_CLOCK: u32 = 638;
pub const HID_CONSUMER_AC_VIEW_CLOCK: u32 = 639;
pub const HID_CONSUMER_AC_SELECT_TIME_ZONE: u32 = 640;
pub const HID_CONSUMER_AC_EDIT_TIME_ZONES: u32 = 641;
pub const HID_CONSUMER_AC_SET_ALARM: u32 = 642;
pub const HID_CONSUMER_AC_CLEAR_ALARM: u32 = 643;
pub const HID_CONSUMER_AC_SNOOZE_ALARM: u32 = 644;
pub const HID_CONSUMER_AC_RESET_ALARM: u32 = 645;
pub const HID_CONSUMER_AC_SYNCHRONIZE: u32 = 646;
pub const HID_CONSUMER_AC_SEND_RECEIVE: u32 = 647;
pub const HID_CONSUMER_AC_SEND_TO: u32 = 648;
pub const HID_CONSUMER_AC_REPLY: u32 = 649;
pub const HID_CONSUMER_AC_REPLY_ALL: u32 = 650;
pub const HID_CONSUMER_AC_FORWARD_MSG: u32 = 651;
pub const HID_CONSUMER_AC_SEND: u32 = 652;
pub const HID_CONSUMER_AC_ATTACH_FILE: u32 = 653;
pub const HID_CONSUMER_AC_UPLOAD: u32 = 654;
pub const HID_CONSUMER_AC_DOWNLOAD_SAVE_TARGET_AS: u32 = 655;
pub const HID_CONSUMER_AC_SET_BORDERS: u32 = 656;
pub const HID_CONSUMER_AC_INSERT_ROW: u32 = 657;
pub const HID_CONSUMER_AC_INSERT_COLUMN: u32 = 658;
pub const HID_CONSUMER_AC_INSERT_FILE: u32 = 659;
pub const HID_CONSUMER_AC_INSERT_PICTURE: u32 = 660;
pub const HID_CONSUMER_AC_INSERT_OBJECT: u32 = 661;
pub const HID_CONSUMER_AC_INSERT_SYMBOL: u32 = 662;
pub const HID_CONSUMER_AC_SAVE_AND_CLOSE: u32 = 663;
pub const HID_CONSUMER_AC_RENAME: u32 = 664;
pub const HID_CONSUMER_AC_MERGE: u32 = 665;
pub const HID_CONSUMER_AC_SPLIT: u32 = 666;
pub const HID_CONSUMER_AC_DISRIBUTE_HORIZONTALLY: u32 = 667;
pub const HID_CONSUMER_AC_DISTRIBUTE_VERTICALLY: u32 = 668;
pub const HID_PAGE_LED: u32 = 8;
pub const HID_LED_NUM_LOCK: u32 = 1;
pub const HID_LED_CAPS_LOCK: u32 = 2;
pub const HID_LED_SCROLL_LOCK: u32 = 3;
pub const HID_LED_COMPOSE: u32 = 4;
pub const HID_LED_KANA: u32 = 5;
pub const HID_LED_POWER: u32 = 6;
pub const HID_LED_SHIFT: u32 = 7;
pub const HID_LED_DO_NOT_DISTURB: u32 = 8;
pub const HID_LED_MUTE: u32 = 9;
pub const HID_LED_TONE_ENABLE: u32 = 10;
pub const HID_LED_HIGH_CUT_FILTER: u32 = 11;
pub const HID_LED_LOW_CUT_FILTER: u32 = 12;
pub const HID_LED_EQUALIZER_ENABLE: u32 = 13;
pub const HID_LED_SOUND_FIELD_ON: u32 = 14;
pub const HID_LED_SURROUND_ON: u32 = 15;
pub const HID_LED_REPEAT: u32 = 16;
pub const HID_LED_STEREO: u32 = 17;
pub const HID_LED_SAMPLING_RATE_DETECT: u32 = 18;
pub const HID_LED_SPINNING: u32 = 19;
pub const HID_LED_CAV: u32 = 20;
pub const HID_LED_CLV: u32 = 21;
pub const HID_LED_REC_FORMAT_DETECT: u32 = 22;
pub const HID_LED_OFF_HOOK: u32 = 23;
pub const HID_LED_RING: u32 = 24;
pub const HID_LED_MESSAGE_WAITING: u32 = 25;
pub const HID_LED_DATA_MODE: u32 = 26;
pub const HID_LED_BATTERY_OPERATION: u32 = 27;
pub const HID_LED_BATTERY_OK: u32 = 28;
pub const HID_LED_BATTERY_LOW: u32 = 29;
pub const HID_LED_SPEAKER: u32 = 30;
pub const HID_LED_HEADSET: u32 = 31;
pub const HID_LED_HOLD: u32 = 32;
pub const HID_LED_MICROPHONE: u32 = 33;
pub const HID_LED_COVERAGE: u32 = 34;
pub const HID_LED_NIGHT_MODE: u32 = 35;
pub const HID_LED_SEND_CALLS: u32 = 36;
pub const HID_LED_CALL_PICKUP: u32 = 37;
pub const HID_LED_CONFERENCE: u32 = 38;
pub const HID_LED_STANDBY: u32 = 39;
pub const HID_LED_CAMERA_ON: u32 = 40;
pub const HID_LED_CAMERA_OFF: u32 = 41;
pub const HID_LED_ONLINE: u32 = 42;
pub const HID_LED_OFFLINE: u32 = 43;
pub const HID_LED_BUSY: u32 = 44;
pub const HID_LED_READY: u32 = 45;
pub const HID_LED_PAPER_OUT: u32 = 46;
pub const HID_LED_PAPER_JAM: u32 = 47;
pub const HID_LED_REMOTE: u32 = 48;
pub const HID_LED_FORWARD: u32 = 49;
pub const HID_LED_REVERSE: u32 = 50;
pub const HID_LED_STOP: u32 = 51;
pub const HID_LED_REWIND: u32 = 52;
pub const HID_LED_FAST_FORWARD: u32 = 53;
pub const HID_LED_PLAY: u32 = 54;
pub const HID_LED_PAUSE: u32 = 55;
pub const HID_LED_RECORD: u32 = 56;
pub const HID_LED_ERROR: u32 = 57;
pub const HID_LED_USAGE_SELECTED_IND: u32 = 58;
pub const HID_LED_USAGE_INUSE_IND: u32 = 59;
pub const HID_LED_USAGE_MULTIMODE_IND: u32 = 60;
pub const HID_LED_INDICATOR_ON: u32 = 61;
pub const HID_LED_INDICATOR_FLASH: u32 = 62;
pub const HID_LED_INDICATOR_SLOW_BLINK: u32 = 63;
pub const HID_LED_INDICATOR_FAST_BLINK: u32 = 64;
pub const HID_LED_INDICATOR_OFF: u32 = 65;
pub const HID_LED_FLASH_ON_TIME: u32 = 66;
pub const HID_LED_SLOW_BLINK_ON_TIME: u32 = 67;
pub const HID_LED_SLOW_BLINK_OFF_TIME: u32 = 68;
pub const HID_LED_FAST_BLINK_ON_TIME: u32 = 69;
pub const HID_LED_FAST_BLINK_OFF_TIME: u32 = 70;
pub const HID_LED_USAGE_INDICATOR_COLOR: u32 = 71;
pub const HID_LED_INDICATOR_RED: u32 = 72;
pub const HID_LED_INDICATOR_GREEN: u32 = 73;
pub const HID_LED_INDICATOR_AMBER: u32 = 74;
pub const HID_LED_GENERIC_INDICATOR: u32 = 75;
pub const HID_LED_SYSTEM_SUSPEND: u32 = 76;
pub const HID_LED_EXT_POWER_CONNECTED: u32 = 77;
pub const HID_KEYBOARD_NONE: u32 = 0;
pub const HID_KEYBOARD_COMMA: u32 = 54;
pub const FURI_HAL_COMPRESS_EXP_BUFF_SIZE_LOG: u32 = 8;
pub const FURI_HAL_COMPRESS_LOOKAHEAD_BUFF_SIZE_LOG: u32 = 4;
pub const INFRARED_MAX_FREQUENCY: u32 = 56000;
pub const INFRARED_MIN_FREQUENCY: u32 = 10000;
pub const HID_U2F_PACKET_LEN: u32 = 64;
pub const ADC_SQR1_REGOFFSET: u32 = 0;
pub const ADC_SQR2_REGOFFSET: u32 = 256;
pub const ADC_SQR3_REGOFFSET: u32 = 512;
pub const ADC_SQR4_REGOFFSET: u32 = 768;
pub const ADC_REG_SQRX_REGOFFSET_MASK: u32 = 768;
pub const ADC_SQRX_REGOFFSET_POS: u32 = 8;
pub const ADC_REG_RANK_1_SQRX_BITOFFSET_POS: u32 = 6;
pub const ADC_REG_RANK_2_SQRX_BITOFFSET_POS: u32 = 12;
pub const ADC_REG_RANK_3_SQRX_BITOFFSET_POS: u32 = 18;
pub const ADC_REG_RANK_4_SQRX_BITOFFSET_POS: u32 = 24;
pub const ADC_REG_RANK_5_SQRX_BITOFFSET_POS: u32 = 0;
pub const ADC_REG_RANK_6_SQRX_BITOFFSET_POS: u32 = 6;
pub const ADC_REG_RANK_7_SQRX_BITOFFSET_POS: u32 = 12;
pub const ADC_REG_RANK_8_SQRX_BITOFFSET_POS: u32 = 18;
pub const ADC_REG_RANK_9_SQRX_BITOFFSET_POS: u32 = 24;
pub const ADC_REG_RANK_10_SQRX_BITOFFSET_POS: u32 = 0;
pub const ADC_REG_RANK_11_SQRX_BITOFFSET_POS: u32 = 6;
pub const ADC_REG_RANK_12_SQRX_BITOFFSET_POS: u32 = 12;
pub const ADC_REG_RANK_13_SQRX_BITOFFSET_POS: u32 = 18;
pub const ADC_REG_RANK_14_SQRX_BITOFFSET_POS: u32 = 24;
pub const ADC_REG_RANK_15_SQRX_BITOFFSET_POS: u32 = 0;
pub const ADC_REG_RANK_16_SQRX_BITOFFSET_POS: u32 = 6;
pub const ADC_JDR1_REGOFFSET: u32 = 0;
pub const ADC_JDR2_REGOFFSET: u32 = 256;
pub const ADC_JDR3_REGOFFSET: u32 = 512;
pub const ADC_JDR4_REGOFFSET: u32 = 768;
pub const ADC_INJ_JDRX_REGOFFSET_MASK: u32 = 768;
pub const ADC_JDRX_REGOFFSET_POS: u32 = 8;
pub const ADC_INJ_RANK_1_JSQR_BITOFFSET_POS: u32 = 8;
pub const ADC_INJ_RANK_2_JSQR_BITOFFSET_POS: u32 = 14;
pub const ADC_INJ_RANK_3_JSQR_BITOFFSET_POS: u32 = 20;
pub const ADC_INJ_RANK_4_JSQR_BITOFFSET_POS: u32 = 26;
pub const ADC_REG_TRIG_EXT_EDGE_DEFAULT: u32 = 1024;
pub const ADC_REG_TRIG_EXTSEL_BITOFFSET_POS: u32 = 6;
pub const ADC_REG_TRIG_EXTEN_BITOFFSET_POS: u32 = 10;
pub const ADC_INJ_TRIG_EXT_EDGE_DEFAULT: u32 = 64;
pub const ADC_INJ_TRIG_EXTSEL_BITOFFSET_POS: u32 = 2;
pub const ADC_INJ_TRIG_EXTEN_BITOFFSET_POS: u32 = 6;
pub const ADC_CHANNEL_ID_NUMBER_MASK: u32 = 2080374784;
pub const ADC_CHANNEL_ID_BITFIELD_MASK: u32 = 524287;
pub const ADC_CHANNEL_ID_NUMBER_BITOFFSET_POS: u32 = 26;
pub const ADC_CHANNEL_ID_NUMBER_MASK_POSBIT0: u32 = 31;
pub const ADC_CHANNEL_ID_INTERNAL_CH: u32 = 2147483648;
pub const ADC_CHANNEL_ID_INTERNAL_CH_2: u32 = 524288;
pub const ADC_CHANNEL_ID_INTERNAL_CH_MASK: u32 = 2148007936;
pub const ADC_SMPR1_REGOFFSET: u32 = 0;
pub const ADC_SMPR2_REGOFFSET: u32 = 33554432;
pub const ADC_CHANNEL_SMPRX_REGOFFSET_MASK: u32 = 33554432;
pub const ADC_SMPRX_REGOFFSET_POS: u32 = 25;
pub const ADC_CHANNEL_SMPx_BITOFFSET_MASK: u32 = 32505856;
pub const ADC_CHANNEL_SMPx_BITOFFSET_POS: u32 = 20;
pub const ADC_CHANNEL_0_NUMBER: u32 = 0;
pub const ADC_CHANNEL_1_NUMBER: u32 = 67108864;
pub const ADC_CHANNEL_2_NUMBER: u32 = 134217728;
pub const ADC_CHANNEL_3_NUMBER: u32 = 201326592;
pub const ADC_CHANNEL_4_NUMBER: u32 = 268435456;
pub const ADC_CHANNEL_5_NUMBER: u32 = 335544320;
pub const ADC_CHANNEL_6_NUMBER: u32 = 402653184;
pub const ADC_CHANNEL_7_NUMBER: u32 = 469762048;
pub const ADC_CHANNEL_8_NUMBER: u32 = 536870912;
pub const ADC_CHANNEL_9_NUMBER: u32 = 603979776;
pub const ADC_CHANNEL_10_NUMBER: u32 = 671088640;
pub const ADC_CHANNEL_11_NUMBER: u32 = 738197504;
pub const ADC_CHANNEL_12_NUMBER: u32 = 805306368;
pub const ADC_CHANNEL_13_NUMBER: u32 = 872415232;
pub const ADC_CHANNEL_14_NUMBER: u32 = 939524096;
pub const ADC_CHANNEL_15_NUMBER: u32 = 1006632960;
pub const ADC_CHANNEL_16_NUMBER: u32 = 1073741824;
pub const ADC_CHANNEL_17_NUMBER: u32 = 1140850688;
pub const ADC_CHANNEL_18_NUMBER: u32 = 1207959552;
pub const ADC_CHANNEL_0_BITFIELD: u32 = 1;
pub const ADC_CHANNEL_1_BITFIELD: u32 = 2;
pub const ADC_CHANNEL_2_BITFIELD: u32 = 4;
pub const ADC_CHANNEL_3_BITFIELD: u32 = 8;
pub const ADC_CHANNEL_4_BITFIELD: u32 = 16;
pub const ADC_CHANNEL_5_BITFIELD: u32 = 32;
pub const ADC_CHANNEL_6_BITFIELD: u32 = 64;
pub const ADC_CHANNEL_7_BITFIELD: u32 = 128;
pub const ADC_CHANNEL_8_BITFIELD: u32 = 256;
pub const ADC_CHANNEL_9_BITFIELD: u32 = 512;
pub const ADC_CHANNEL_10_BITFIELD: u32 = 1024;
pub const ADC_CHANNEL_11_BITFIELD: u32 = 2048;
pub const ADC_CHANNEL_12_BITFIELD: u32 = 4096;
pub const ADC_CHANNEL_13_BITFIELD: u32 = 8192;
pub const ADC_CHANNEL_14_BITFIELD: u32 = 16384;
pub const ADC_CHANNEL_15_BITFIELD: u32 = 32768;
pub const ADC_CHANNEL_16_BITFIELD: u32 = 65536;
pub const ADC_CHANNEL_17_BITFIELD: u32 = 131072;
pub const ADC_CHANNEL_18_BITFIELD: u32 = 262144;
pub const ADC_CHANNEL_0_SMP: u32 = 0;
pub const ADC_CHANNEL_1_SMP: u32 = 3145728;
pub const ADC_CHANNEL_2_SMP: u32 = 6291456;
pub const ADC_CHANNEL_3_SMP: u32 = 9437184;
pub const ADC_CHANNEL_4_SMP: u32 = 12582912;
pub const ADC_CHANNEL_5_SMP: u32 = 15728640;
pub const ADC_CHANNEL_6_SMP: u32 = 18874368;
pub const ADC_CHANNEL_7_SMP: u32 = 22020096;
pub const ADC_CHANNEL_8_SMP: u32 = 25165824;
pub const ADC_CHANNEL_9_SMP: u32 = 28311552;
pub const ADC_CHANNEL_10_SMP: u32 = 33554432;
pub const ADC_CHANNEL_11_SMP: u32 = 36700160;
pub const ADC_CHANNEL_12_SMP: u32 = 39845888;
pub const ADC_CHANNEL_13_SMP: u32 = 42991616;
pub const ADC_CHANNEL_14_SMP: u32 = 46137344;
pub const ADC_CHANNEL_15_SMP: u32 = 49283072;
pub const ADC_CHANNEL_16_SMP: u32 = 52428800;
pub const ADC_CHANNEL_17_SMP: u32 = 55574528;
pub const ADC_CHANNEL_18_SMP: u32 = 58720256;
pub const ADC_SINGLEDIFF_CALIB_START_MASK: u32 = 1073741824;
pub const ADC_SINGLEDIFF_CALIB_FACTOR_MASK: u32 = 8323199;
pub const ADC_SINGLEDIFF_CHANNEL_MASK: u32 = 524287;
pub const ADC_SINGLEDIFF_CHANNEL_SHIFT_MASK: u32 = 24;
pub const ADC_SINGLEDIFF_CALIB_F_BIT_D_MASK: u32 = 65536;
pub const ADC_SINGLEDIFF_CALIB_F_BIT_D_POS: u32 = 16;
pub const ADC_SINGLEDIFF_CALIB_F_BIT_D_SHIFT4: u32 = 12;
pub const ADC_AWD_CR1_REGOFFSET: u32 = 0;
pub const ADC_AWD_CR2_REGOFFSET: u32 = 1048576;
pub const ADC_AWD_CR3_REGOFFSET: u32 = 2097152;
pub const ADC_AWD_CR12_REGOFFSETGAP_MASK: u32 = 1;
pub const ADC_AWD_CR12_REGOFFSETGAP_VAL: u32 = 36;
pub const ADC_AWD_CRX_REGOFFSET_MASK: u32 = 3145728;
pub const ADC_AWD_CRX_REGOFFSET_BITOFFSET_POS: u32 = 20;
pub const ADC_AWD_CR1_CHANNEL_MASK: u32 = 2109734912;
pub const ADC_AWD_CR23_CHANNEL_MASK: u32 = 524287;
pub const ADC_AWD_CR_ALL_CHANNEL_MASK: u32 = 2110259199;
pub const ADC_AWD_CRX_REGOFFSET_POS: u32 = 20;
pub const ADC_AWD_TR1_REGOFFSET: u32 = 0;
pub const ADC_AWD_TR2_REGOFFSET: u32 = 1048576;
pub const ADC_AWD_TR3_REGOFFSET: u32 = 2097152;
pub const ADC_AWD_TRX_REGOFFSET_MASK: u32 = 3145728;
pub const ADC_AWD_TRX_REGOFFSET_POS: u32 = 20;
pub const ADC_AWD_TRX_BIT_HIGH_MASK: u32 = 65536;
pub const ADC_AWD_TRX_BIT_HIGH_POS: u32 = 16;
pub const ADC_AWD_TRX_BIT_HIGH_SHIFT4: u32 = 12;
pub const ADC_OFR1_REGOFFSET: u32 = 0;
pub const ADC_OFR2_REGOFFSET: u32 = 1;
pub const ADC_OFR3_REGOFFSET: u32 = 2;
pub const ADC_OFR4_REGOFFSET: u32 = 3;
pub const ADC_OFRx_REGOFFSET_MASK: u32 = 3;
pub const ADC_CFGR_RES_BITOFFSET_POS: u32 = 3;
pub const ADC_CFGR_AWD1SGL_BITOFFSET_POS: u32 = 22;
pub const ADC_CFGR_AWD1EN_BITOFFSET_POS: u32 = 23;
pub const ADC_CFGR_JAWD1EN_BITOFFSET_POS: u32 = 24;
pub const ADC_TR1_HT1_BITOFFSET_POS: u32 = 16;
pub const ADC_CR_BITS_PROPERTY_RS: u32 = 2147483711;
pub const VREFINT_CAL_VREF: u32 = 3600;
pub const TEMPSENSOR_CAL1_TEMP: u32 = 30;
pub const TEMPSENSOR_CAL2_TEMP: u32 = 130;
pub const TEMPSENSOR_CAL_VREFANALOG: u32 = 3000;
pub const LL_ADC_FLAG_ADRDY: u32 = 1;
pub const LL_ADC_FLAG_EOC: u32 = 4;
pub const LL_ADC_FLAG_EOS: u32 = 8;
pub const LL_ADC_FLAG_OVR: u32 = 16;
pub const LL_ADC_FLAG_EOSMP: u32 = 2;
pub const LL_ADC_FLAG_JEOC: u32 = 32;
pub const LL_ADC_FLAG_JEOS: u32 = 64;
pub const LL_ADC_FLAG_JQOVF: u32 = 1024;
pub const LL_ADC_FLAG_AWD1: u32 = 128;
pub const LL_ADC_FLAG_AWD2: u32 = 256;
pub const LL_ADC_FLAG_AWD3: u32 = 512;
pub const LL_ADC_IT_ADRDY: u32 = 1;
pub const LL_ADC_IT_EOC: u32 = 4;
pub const LL_ADC_IT_EOS: u32 = 8;
pub const LL_ADC_IT_OVR: u32 = 16;
pub const LL_ADC_IT_EOSMP: u32 = 2;
pub const LL_ADC_IT_JEOC: u32 = 32;
pub const LL_ADC_IT_JEOS: u32 = 64;
pub const LL_ADC_IT_JQOVF: u32 = 1024;
pub const LL_ADC_IT_AWD1: u32 = 128;
pub const LL_ADC_IT_AWD2: u32 = 256;
pub const LL_ADC_IT_AWD3: u32 = 512;
pub const LL_ADC_DMA_REG_REGULAR_DATA: u32 = 0;
pub const LL_ADC_CLOCK_SYNC_PCLK_DIV1: u32 = 65536;
pub const LL_ADC_CLOCK_SYNC_PCLK_DIV2: u32 = 131072;
pub const LL_ADC_CLOCK_SYNC_PCLK_DIV4: u32 = 196608;
pub const LL_ADC_CLOCK_ASYNC_DIV1: u32 = 0;
pub const LL_ADC_CLOCK_ASYNC_DIV2: u32 = 262144;
pub const LL_ADC_CLOCK_ASYNC_DIV4: u32 = 524288;
pub const LL_ADC_CLOCK_ASYNC_DIV6: u32 = 786432;
pub const LL_ADC_CLOCK_ASYNC_DIV8: u32 = 1048576;
pub const LL_ADC_CLOCK_ASYNC_DIV10: u32 = 1310720;
pub const LL_ADC_CLOCK_ASYNC_DIV12: u32 = 1572864;
pub const LL_ADC_CLOCK_ASYNC_DIV16: u32 = 1835008;
pub const LL_ADC_CLOCK_ASYNC_DIV32: u32 = 2097152;
pub const LL_ADC_CLOCK_ASYNC_DIV64: u32 = 2359296;
pub const LL_ADC_CLOCK_ASYNC_DIV128: u32 = 2621440;
pub const LL_ADC_CLOCK_ASYNC_DIV256: u32 = 2883584;
pub const LL_ADC_PATH_INTERNAL_NONE: u32 = 0;
pub const LL_ADC_PATH_INTERNAL_VREFINT: u32 = 4194304;
pub const LL_ADC_PATH_INTERNAL_TEMPSENSOR: u32 = 8388608;
pub const LL_ADC_PATH_INTERNAL_VBAT: u32 = 16777216;
pub const LL_ADC_RESOLUTION_12B: u32 = 0;
pub const LL_ADC_RESOLUTION_10B: u32 = 8;
pub const LL_ADC_RESOLUTION_8B: u32 = 16;
pub const LL_ADC_RESOLUTION_6B: u32 = 24;
pub const LL_ADC_DATA_ALIGN_RIGHT: u32 = 0;
pub const LL_ADC_DATA_ALIGN_LEFT: u32 = 32;
pub const LL_ADC_LP_MODE_NONE: u32 = 0;
pub const LL_ADC_LP_AUTOWAIT: u32 = 16384;
pub const LL_ADC_TRIGGER_FREQ_HIGH: u32 = 0;
pub const LL_ADC_OFFSET_1: u32 = 0;
pub const LL_ADC_OFFSET_2: u32 = 1;
pub const LL_ADC_OFFSET_3: u32 = 2;
pub const LL_ADC_OFFSET_4: u32 = 3;
pub const LL_ADC_OFFSET_DISABLE: u32 = 0;
pub const LL_ADC_OFFSET_ENABLE: u32 = 2147483648;
pub const LL_ADC_GROUP_REGULAR: u32 = 1;
pub const LL_ADC_GROUP_INJECTED: u32 = 2;
pub const LL_ADC_GROUP_REGULAR_INJECTED: u32 = 3;
pub const LL_ADC_CHANNEL_0: u32 = 1;
pub const LL_ADC_CHANNEL_1: u32 = 70254594;
pub const LL_ADC_CHANNEL_2: u32 = 140509188;
pub const LL_ADC_CHANNEL_3: u32 = 210763784;
pub const LL_ADC_CHANNEL_4: u32 = 281018384;
pub const LL_ADC_CHANNEL_5: u32 = 351272992;
pub const LL_ADC_CHANNEL_6: u32 = 421527616;
pub const LL_ADC_CHANNEL_7: u32 = 491782272;
pub const LL_ADC_CHANNEL_8: u32 = 562036992;
pub const LL_ADC_CHANNEL_9: u32 = 632291840;
pub const LL_ADC_CHANNEL_10: u32 = 704644096;
pub const LL_ADC_CHANNEL_11: u32 = 774899712;
pub const LL_ADC_CHANNEL_12: u32 = 845156352;
pub const LL_ADC_CHANNEL_13: u32 = 915415040;
pub const LL_ADC_CHANNEL_14: u32 = 985677824;
pub const LL_ADC_CHANNEL_15: u32 = 1055948800;
pub const LL_ADC_CHANNEL_16: u32 = 1126236160;
pub const LL_ADC_CHANNEL_17: u32 = 1196556288;
pub const LL_ADC_CHANNEL_18: u32 = 1266941952;
pub const LL_ADC_CHANNEL_VREFINT: u32 = 2147483649;
pub const LL_ADC_CHANNEL_TEMPSENSOR: u32 = 3344039936;
pub const LL_ADC_CHANNEL_VBAT: u32 = 3414425600;
pub const LL_ADC_REG_TRIG_SOFTWARE: u32 = 0;
pub const LL_ADC_REG_TRIG_EXT_TIM1_TRGO: u32 = 1600;
pub const LL_ADC_REG_TRIG_EXT_TIM1_TRGO2: u32 = 1664;
pub const LL_ADC_REG_TRIG_EXT_TIM1_CH1: u32 = 1024;
pub const LL_ADC_REG_TRIG_EXT_TIM1_CH2: u32 = 1088;
pub const LL_ADC_REG_TRIG_EXT_TIM1_CH3: u32 = 1152;
pub const LL_ADC_REG_TRIG_EXT_TIM2_TRGO: u32 = 1728;
pub const LL_ADC_REG_TRIG_EXT_TIM2_CH2: u32 = 1216;
pub const LL_ADC_REG_TRIG_EXT_EXTI_LINE11: u32 = 1408;
pub const LL_ADC_REG_TRIG_EXT_RISING: u32 = 1024;
pub const LL_ADC_REG_TRIG_EXT_FALLING: u32 = 2048;
pub const LL_ADC_REG_TRIG_EXT_RISINGFALLING: u32 = 3072;
pub const LL_ADC_REG_CONV_SINGLE: u32 = 0;
pub const LL_ADC_REG_CONV_CONTINUOUS: u32 = 8192;
pub const LL_ADC_REG_DMA_TRANSFER_NONE: u32 = 0;
pub const LL_ADC_REG_DMA_TRANSFER_LIMITED: u32 = 1;
pub const LL_ADC_REG_DMA_TRANSFER_UNLIMITED: u32 = 3;
pub const LL_ADC_REG_OVR_DATA_PRESERVED: u32 = 0;
pub const LL_ADC_REG_OVR_DATA_OVERWRITTEN: u32 = 4096;
pub const LL_ADC_REG_SEQ_SCAN_DISABLE: u32 = 0;
pub const LL_ADC_REG_SEQ_SCAN_ENABLE_2RANKS: u32 = 1;
pub const LL_ADC_REG_SEQ_SCAN_ENABLE_3RANKS: u32 = 2;
pub const LL_ADC_REG_SEQ_SCAN_ENABLE_4RANKS: u32 = 3;
pub const LL_ADC_REG_SEQ_SCAN_ENABLE_5RANKS: u32 = 4;
pub const LL_ADC_REG_SEQ_SCAN_ENABLE_6RANKS: u32 = 5;
pub const LL_ADC_REG_SEQ_SCAN_ENABLE_7RANKS: u32 = 6;
pub const LL_ADC_REG_SEQ_SCAN_ENABLE_8RANKS: u32 = 7;
pub const LL_ADC_REG_SEQ_SCAN_ENABLE_9RANKS: u32 = 8;
pub const LL_ADC_REG_SEQ_SCAN_ENABLE_10RANKS: u32 = 9;
pub const LL_ADC_REG_SEQ_SCAN_ENABLE_11RANKS: u32 = 10;
pub const LL_ADC_REG_SEQ_SCAN_ENABLE_12RANKS: u32 = 11;
pub const LL_ADC_REG_SEQ_SCAN_ENABLE_13RANKS: u32 = 12;
pub const LL_ADC_REG_SEQ_SCAN_ENABLE_14RANKS: u32 = 13;
pub const LL_ADC_REG_SEQ_SCAN_ENABLE_15RANKS: u32 = 14;
pub const LL_ADC_REG_SEQ_SCAN_ENABLE_16RANKS: u32 = 15;
pub const LL_ADC_REG_SEQ_DISCONT_DISABLE: u32 = 0;
pub const LL_ADC_REG_SEQ_DISCONT_1RANK: u32 = 65536;
pub const LL_ADC_REG_SEQ_DISCONT_2RANKS: u32 = 196608;
pub const LL_ADC_REG_SEQ_DISCONT_3RANKS: u32 = 327680;
pub const LL_ADC_REG_SEQ_DISCONT_4RANKS: u32 = 458752;
pub const LL_ADC_REG_SEQ_DISCONT_5RANKS: u32 = 589824;
pub const LL_ADC_REG_SEQ_DISCONT_6RANKS: u32 = 720896;
pub const LL_ADC_REG_SEQ_DISCONT_7RANKS: u32 = 851968;
pub const LL_ADC_REG_SEQ_DISCONT_8RANKS: u32 = 983040;
pub const LL_ADC_REG_RANK_1: u32 = 6;
pub const LL_ADC_REG_RANK_2: u32 = 12;
pub const LL_ADC_REG_RANK_3: u32 = 18;
pub const LL_ADC_REG_RANK_4: u32 = 24;
pub const LL_ADC_REG_RANK_5: u32 = 256;
pub const LL_ADC_REG_RANK_6: u32 = 262;
pub const LL_ADC_REG_RANK_7: u32 = 268;
pub const LL_ADC_REG_RANK_8: u32 = 274;
pub const LL_ADC_REG_RANK_9: u32 = 280;
pub const LL_ADC_REG_RANK_10: u32 = 512;
pub const LL_ADC_REG_RANK_11: u32 = 518;
pub const LL_ADC_REG_RANK_12: u32 = 524;
pub const LL_ADC_REG_RANK_13: u32 = 530;
pub const LL_ADC_REG_RANK_14: u32 = 536;
pub const LL_ADC_REG_RANK_15: u32 = 768;
pub const LL_ADC_REG_RANK_16: u32 = 774;
pub const LL_ADC_INJ_TRIG_SOFTWARE: u32 = 0;
pub const LL_ADC_INJ_TRIG_EXT_TIM1_TRGO: u32 = 64;
pub const LL_ADC_INJ_TRIG_EXT_TIM1_TRGO2: u32 = 96;
pub const LL_ADC_INJ_TRIG_EXT_TIM1_CH4: u32 = 68;
pub const LL_ADC_INJ_TRIG_EXT_TIM2_TRGO: u32 = 72;
pub const LL_ADC_INJ_TRIG_EXT_TIM2_CH1: u32 = 76;
pub const LL_ADC_INJ_TRIG_EXT_EXTI_LINE15: u32 = 88;
pub const LL_ADC_INJ_TRIG_EXT_RISING: u32 = 64;
pub const LL_ADC_INJ_TRIG_EXT_FALLING: u32 = 128;
pub const LL_ADC_INJ_TRIG_EXT_RISINGFALLING: u32 = 192;
pub const LL_ADC_INJ_TRIG_INDEPENDENT: u32 = 0;
pub const LL_ADC_INJ_TRIG_FROM_GRP_REGULAR: u32 = 33554432;
pub const LL_ADC_INJ_QUEUE_2CONTEXTS_LAST_ACTIVE: u32 = 0;
pub const LL_ADC_INJ_QUEUE_2CONTEXTS_END_EMPTY: u32 = 2097152;
pub const LL_ADC_INJ_QUEUE_DISABLE: u32 = 2147483648;
pub const LL_ADC_INJ_SEQ_SCAN_DISABLE: u32 = 0;
pub const LL_ADC_INJ_SEQ_SCAN_ENABLE_2RANKS: u32 = 1;
pub const LL_ADC_INJ_SEQ_SCAN_ENABLE_3RANKS: u32 = 2;
pub const LL_ADC_INJ_SEQ_SCAN_ENABLE_4RANKS: u32 = 3;
pub const LL_ADC_INJ_SEQ_DISCONT_DISABLE: u32 = 0;
pub const LL_ADC_INJ_SEQ_DISCONT_1RANK: u32 = 1048576;
pub const LL_ADC_INJ_RANK_1: u32 = 8;
pub const LL_ADC_INJ_RANK_2: u32 = 270;
pub const LL_ADC_INJ_RANK_3: u32 = 532;
pub const LL_ADC_INJ_RANK_4: u32 = 794;
pub const LL_ADC_SAMPLINGTIME_2CYCLES_5: u32 = 0;
pub const LL_ADC_SAMPLINGTIME_6CYCLES_5: u32 = 1;
pub const LL_ADC_SAMPLINGTIME_12CYCLES_5: u32 = 2;
pub const LL_ADC_SAMPLINGTIME_24CYCLES_5: u32 = 3;
pub const LL_ADC_SAMPLINGTIME_47CYCLES_5: u32 = 4;
pub const LL_ADC_SAMPLINGTIME_92CYCLES_5: u32 = 5;
pub const LL_ADC_SAMPLINGTIME_247CYCLES_5: u32 = 6;
pub const LL_ADC_SAMPLINGTIME_640CYCLES_5: u32 = 7;
pub const LL_ADC_SINGLE_ENDED: u32 = 127;
pub const LL_ADC_DIFFERENTIAL_ENDED: u32 = 1082064896;
pub const LL_ADC_BOTH_SINGLE_DIFF_ENDED: u32 = 1082065023;
pub const LL_ADC_AWD1: u32 = 2109734912;
pub const LL_ADC_AWD2: u32 = 1572863;
pub const LL_ADC_AWD3: u32 = 2621439;
pub const LL_ADC_AWD_DISABLE: u32 = 0;
pub const LL_ADC_AWD_ALL_CHANNELS_REG: u32 = 8912895;
pub const LL_ADC_AWD_ALL_CHANNELS_INJ: u32 = 17301503;
pub const LL_ADC_AWD_ALL_CHANNELS_REG_INJ: u32 = 25690111;
pub const LL_ADC_AWD_THRESHOLD_HIGH: u32 = 268369920;
pub const LL_ADC_AWD_THRESHOLD_LOW: u32 = 4095;
pub const LL_ADC_AWD_THRESHOLDS_HIGH_LOW: u32 = 268374015;
pub const LL_ADC_OVS_DISABLE: u32 = 0;
pub const LL_ADC_OVS_GRP_REGULAR_CONTINUED: u32 = 1;
pub const LL_ADC_OVS_GRP_REGULAR_RESUMED: u32 = 1025;
pub const LL_ADC_OVS_GRP_INJECTED: u32 = 2;
pub const LL_ADC_OVS_GRP_INJ_REG_RESUMED: u32 = 3;
pub const LL_ADC_OVS_REG_CONT: u32 = 0;
pub const LL_ADC_OVS_REG_DISCONT: u32 = 512;
pub const LL_ADC_OVS_RATIO_2: u32 = 0;
pub const LL_ADC_OVS_RATIO_4: u32 = 4;
pub const LL_ADC_OVS_RATIO_8: u32 = 8;
pub const LL_ADC_OVS_RATIO_16: u32 = 12;
pub const LL_ADC_OVS_RATIO_32: u32 = 16;
pub const LL_ADC_OVS_RATIO_64: u32 = 20;
pub const LL_ADC_OVS_RATIO_128: u32 = 24;
pub const LL_ADC_OVS_RATIO_256: u32 = 28;
pub const LL_ADC_OVS_SHIFT_NONE: u32 = 0;
pub const LL_ADC_OVS_SHIFT_RIGHT_1: u32 = 32;
pub const LL_ADC_OVS_SHIFT_RIGHT_2: u32 = 64;
pub const LL_ADC_OVS_SHIFT_RIGHT_3: u32 = 96;
pub const LL_ADC_OVS_SHIFT_RIGHT_4: u32 = 128;
pub const LL_ADC_OVS_SHIFT_RIGHT_5: u32 = 160;
pub const LL_ADC_OVS_SHIFT_RIGHT_6: u32 = 192;
pub const LL_ADC_OVS_SHIFT_RIGHT_7: u32 = 224;
pub const LL_ADC_OVS_SHIFT_RIGHT_8: u32 = 256;
pub const LL_ADC_DELAY_INTERNAL_REGUL_STAB_US: u32 = 20;
pub const LL_ADC_DELAY_VREFINT_STAB_US: u32 = 12;
pub const LL_ADC_DELAY_TEMPSENSOR_STAB_US: u32 = 120;
pub const LL_ADC_DELAY_TEMPSENSOR_BUFFER_STAB_US: u32 = 15;
pub const LL_ADC_DELAY_CALIB_ENABLE_ADC_CYCLES: u32 = 4;
pub const LL_COMP_OUTPUT_LEVEL_BITOFFSET_POS: u32 = 30;
pub const LL_COMP_WINDOWMODE_DISABLE: u32 = 0;
pub const LL_COMP_WINDOWMODE_COMP1_INPUT_PLUS_COMMON: u32 = 512;
pub const LL_COMP_POWERMODE_HIGHSPEED: u32 = 0;
pub const LL_COMP_POWERMODE_MEDIUMSPEED: u32 = 4;
pub const LL_COMP_POWERMODE_ULTRALOWPOWER: u32 = 12;
pub const LL_COMP_INPUT_PLUS_IO1: u32 = 0;
pub const LL_COMP_INPUT_PLUS_IO2: u32 = 128;
pub const LL_COMP_INPUT_PLUS_IO3: u32 = 256;
pub const LL_COMP_INPUT_MINUS_1_4VREFINT: u32 = 12582912;
pub const LL_COMP_INPUT_MINUS_1_2VREFINT: u32 = 12582928;
pub const LL_COMP_INPUT_MINUS_3_4VREFINT: u32 = 12582944;
pub const LL_COMP_INPUT_MINUS_VREFINT: u32 = 8388656;
pub const LL_COMP_INPUT_MINUS_IO1: u32 = 96;
pub const LL_COMP_INPUT_MINUS_IO2: u32 = 112;
pub const LL_COMP_INPUT_MINUS_IO3: u32 = 33554544;
pub const LL_COMP_INPUT_MINUS_IO4: u32 = 67108976;
pub const LL_COMP_INPUT_MINUS_IO5: u32 = 100663408;
pub const LL_COMP_HYSTERESIS_NONE: u32 = 0;
pub const LL_COMP_HYSTERESIS_LOW: u32 = 65536;
pub const LL_COMP_HYSTERESIS_MEDIUM: u32 = 131072;
pub const LL_COMP_HYSTERESIS_HIGH: u32 = 196608;
pub const LL_COMP_OUTPUTPOL_NONINVERTED: u32 = 0;
pub const LL_COMP_OUTPUTPOL_INVERTED: u32 = 32768;
pub const LL_COMP_BLANKINGSRC_NONE: u32 = 0;
pub const LL_COMP_BLANKINGSRC_TIM1_OC5: u32 = 262144;
pub const LL_COMP_BLANKINGSRC_TIM2_OC3: u32 = 524288;
pub const LL_COMP_OUTPUT_LEVEL_LOW: u32 = 0;
pub const LL_COMP_OUTPUT_LEVEL_HIGH: u32 = 1;
pub const LL_COMP_DELAY_STARTUP_US: u32 = 80;
pub const LL_COMP_DELAY_VOLTAGE_SCALER_STAB_US: u32 = 200;
pub const LL_SYSTICK_CLKSOURCE_HCLK_DIV8: u32 = 0;
pub const LL_SYSTICK_CLKSOURCE_HCLK: u32 = 4;
pub const LL_HANDLER_FAULT_USG: u32 = 262144;
pub const LL_HANDLER_FAULT_BUS: u32 = 131072;
pub const LL_HANDLER_FAULT_MEM: u32 = 65536;
pub const LL_MPU_CTRL_HFNMI_PRIVDEF_NONE: u32 = 0;
pub const LL_MPU_CTRL_HARDFAULT_NMI: u32 = 2;
pub const LL_MPU_CTRL_PRIVILEGED_DEFAULT: u32 = 4;
pub const LL_MPU_CTRL_HFNMI_PRIVDEF: u32 = 6;
pub const LL_MPU_REGION_NUMBER0: u32 = 0;
pub const LL_MPU_REGION_NUMBER1: u32 = 1;
pub const LL_MPU_REGION_NUMBER2: u32 = 2;
pub const LL_MPU_REGION_NUMBER3: u32 = 3;
pub const LL_MPU_REGION_NUMBER4: u32 = 4;
pub const LL_MPU_REGION_NUMBER5: u32 = 5;
pub const LL_MPU_REGION_NUMBER6: u32 = 6;
pub const LL_MPU_REGION_NUMBER7: u32 = 7;
pub const LL_MPU_REGION_SIZE_32B: u32 = 8;
pub const LL_MPU_REGION_SIZE_64B: u32 = 10;
pub const LL_MPU_REGION_SIZE_128B: u32 = 12;
pub const LL_MPU_REGION_SIZE_256B: u32 = 14;
pub const LL_MPU_REGION_SIZE_512B: u32 = 16;
pub const LL_MPU_REGION_SIZE_1KB: u32 = 18;
pub const LL_MPU_REGION_SIZE_2KB: u32 = 20;
pub const LL_MPU_REGION_SIZE_4KB: u32 = 22;
pub const LL_MPU_REGION_SIZE_8KB: u32 = 24;
pub const LL_MPU_REGION_SIZE_16KB: u32 = 26;
pub const LL_MPU_REGION_SIZE_32KB: u32 = 28;
pub const LL_MPU_REGION_SIZE_64KB: u32 = 30;
pub const LL_MPU_REGION_SIZE_128KB: u32 = 32;
pub const LL_MPU_REGION_SIZE_256KB: u32 = 34;
pub const LL_MPU_REGION_SIZE_512KB: u32 = 36;
pub const LL_MPU_REGION_SIZE_1MB: u32 = 38;
pub const LL_MPU_REGION_SIZE_2MB: u32 = 40;
pub const LL_MPU_REGION_SIZE_4MB: u32 = 42;
pub const LL_MPU_REGION_SIZE_8MB: u32 = 44;
pub const LL_MPU_REGION_SIZE_16MB: u32 = 46;
pub const LL_MPU_REGION_SIZE_32MB: u32 = 48;
pub const LL_MPU_REGION_SIZE_64MB: u32 = 50;
pub const LL_MPU_REGION_SIZE_128MB: u32 = 52;
pub const LL_MPU_REGION_SIZE_256MB: u32 = 54;
pub const LL_MPU_REGION_SIZE_512MB: u32 = 56;
pub const LL_MPU_REGION_SIZE_1GB: u32 = 58;
pub const LL_MPU_REGION_SIZE_2GB: u32 = 60;
pub const LL_MPU_REGION_SIZE_4GB: u32 = 62;
pub const LL_MPU_REGION_NO_ACCESS: u32 = 0;
pub const LL_MPU_REGION_PRIV_RW: u32 = 16777216;
pub const LL_MPU_REGION_PRIV_RW_URO: u32 = 33554432;
pub const LL_MPU_REGION_FULL_ACCESS: u32 = 50331648;
pub const LL_MPU_REGION_PRIV_RO: u32 = 83886080;
pub const LL_MPU_REGION_PRIV_RO_URO: u32 = 100663296;
pub const LL_MPU_TEX_LEVEL0: u32 = 0;
pub const LL_MPU_TEX_LEVEL1: u32 = 524288;
pub const LL_MPU_TEX_LEVEL2: u32 = 1048576;
pub const LL_MPU_TEX_LEVEL4: u32 = 2097152;
pub const LL_MPU_INSTRUCTION_ACCESS_ENABLE: u32 = 0;
pub const LL_MPU_INSTRUCTION_ACCESS_DISABLE: u32 = 268435456;
pub const LL_MPU_ACCESS_SHAREABLE: u32 = 262144;
pub const LL_MPU_ACCESS_NOT_SHAREABLE: u32 = 0;
pub const LL_MPU_ACCESS_CACHEABLE: u32 = 131072;
pub const LL_MPU_ACCESS_NOT_CACHEABLE: u32 = 0;
pub const LL_MPU_ACCESS_BUFFERABLE: u32 = 65536;
pub const LL_MPU_ACCESS_NOT_BUFFERABLE: u32 = 0;
pub const LL_CRC_POLYLENGTH_32B: u32 = 0;
pub const LL_CRC_POLYLENGTH_16B: u32 = 8;
pub const LL_CRC_POLYLENGTH_8B: u32 = 16;
pub const LL_CRC_POLYLENGTH_7B: u32 = 24;
pub const LL_CRC_INDATA_REVERSE_NONE: u32 = 0;
pub const LL_CRC_INDATA_REVERSE_BYTE: u32 = 32;
pub const LL_CRC_INDATA_REVERSE_HALFWORD: u32 = 64;
pub const LL_CRC_INDATA_REVERSE_WORD: u32 = 96;
pub const LL_CRC_OUTDATA_REVERSE_NONE: u32 = 0;
pub const LL_CRC_OUTDATA_REVERSE_BIT: u32 = 128;
pub const LL_CRC_DEFAULT_CRC32_POLY: u32 = 79764919;
pub const LL_CRC_DEFAULT_CRC_INITVALUE: u32 = 4294967295;
pub const CRS_POSITION_TRIM: u32 = 8;
pub const CRS_POSITION_FECAP: u32 = 16;
pub const CRS_POSITION_FELIM: u32 = 16;
pub const LL_CRS_ISR_SYNCOKF: u32 = 1;
pub const LL_CRS_ISR_SYNCWARNF: u32 = 2;
pub const LL_CRS_ISR_ERRF: u32 = 4;
pub const LL_CRS_ISR_ESYNCF: u32 = 8;
pub const LL_CRS_ISR_SYNCERR: u32 = 256;
pub const LL_CRS_ISR_SYNCMISS: u32 = 512;
pub const LL_CRS_ISR_TRIMOVF: u32 = 1024;
pub const LL_CRS_CR_SYNCOKIE: u32 = 1;
pub const LL_CRS_CR_SYNCWARNIE: u32 = 2;
pub const LL_CRS_CR_ERRIE: u32 = 4;
pub const LL_CRS_CR_ESYNCIE: u32 = 8;
pub const LL_CRS_SYNC_DIV_1: u32 = 0;
pub const LL_CRS_SYNC_DIV_2: u32 = 16777216;
pub const LL_CRS_SYNC_DIV_4: u32 = 33554432;
pub const LL_CRS_SYNC_DIV_8: u32 = 50331648;
pub const LL_CRS_SYNC_DIV_16: u32 = 67108864;
pub const LL_CRS_SYNC_DIV_32: u32 = 83886080;
pub const LL_CRS_SYNC_DIV_64: u32 = 100663296;
pub const LL_CRS_SYNC_DIV_128: u32 = 117440512;
pub const LL_CRS_SYNC_SOURCE_GPIO: u32 = 0;
pub const LL_CRS_SYNC_SOURCE_LSE: u32 = 268435456;
pub const LL_CRS_SYNC_SOURCE_USB: u32 = 536870912;
pub const LL_CRS_SYNC_POLARITY_RISING: u32 = 0;
pub const LL_CRS_SYNC_POLARITY_FALLING: u32 = 2147483648;
pub const LL_CRS_FREQ_ERROR_DIR_UP: u32 = 0;
pub const LL_CRS_FREQ_ERROR_DIR_DOWN: u32 = 32768;
pub const LL_CRS_RELOADVALUE_DEFAULT: u32 = 47999;
pub const LL_CRS_ERRORLIMIT_DEFAULT: u32 = 34;
pub const LL_CRS_HSI48CALIBRATION_DEFAULT: u32 = 32;
pub const DMAMUX_CCR_SIZE: u32 = 4;
pub const DMAMUX_RGCR_SIZE: u32 = 4;
pub const LL_DMAMUX_CFR_CSOF0: u32 = 1;
pub const LL_DMAMUX_CFR_CSOF1: u32 = 2;
pub const LL_DMAMUX_CFR_CSOF2: u32 = 4;
pub const LL_DMAMUX_CFR_CSOF3: u32 = 8;
pub const LL_DMAMUX_CFR_CSOF4: u32 = 16;
pub const LL_DMAMUX_CFR_CSOF5: u32 = 32;
pub const LL_DMAMUX_CFR_CSOF6: u32 = 64;
pub const LL_DMAMUX_CFR_CSOF7: u32 = 128;
pub const LL_DMAMUX_CFR_CSOF8: u32 = 256;
pub const LL_DMAMUX_CFR_CSOF9: u32 = 512;
pub const LL_DMAMUX_CFR_CSOF10: u32 = 1024;
pub const LL_DMAMUX_CFR_CSOF11: u32 = 2048;
pub const LL_DMAMUX_CFR_CSOF12: u32 = 4096;
pub const LL_DMAMUX_CFR_CSOF13: u32 = 8192;
pub const LL_DMAMUX_RGCFR_RGCOF0: u32 = 1;
pub const LL_DMAMUX_RGCFR_RGCOF1: u32 = 2;
pub const LL_DMAMUX_RGCFR_RGCOF2: u32 = 4;
pub const LL_DMAMUX_RGCFR_RGCOF3: u32 = 8;
pub const LL_DMAMUX_CSR_SOF0: u32 = 1;
pub const LL_DMAMUX_CSR_SOF1: u32 = 2;
pub const LL_DMAMUX_CSR_SOF2: u32 = 4;
pub const LL_DMAMUX_CSR_SOF3: u32 = 8;
pub const LL_DMAMUX_CSR_SOF4: u32 = 16;
pub const LL_DMAMUX_CSR_SOF5: u32 = 32;
pub const LL_DMAMUX_CSR_SOF6: u32 = 64;
pub const LL_DMAMUX_CSR_SOF7: u32 = 128;
pub const LL_DMAMUX_CSR_SOF8: u32 = 256;
pub const LL_DMAMUX_CSR_SOF9: u32 = 512;
pub const LL_DMAMUX_CSR_SOF10: u32 = 1024;
pub const LL_DMAMUX_CSR_SOF11: u32 = 2048;
pub const LL_DMAMUX_CSR_SOF12: u32 = 4096;
pub const LL_DMAMUX_CSR_SOF13: u32 = 8192;
pub const LL_DMAMUX_RGSR_RGOF0: u32 = 1;
pub const LL_DMAMUX_RGSR_RGOF1: u32 = 2;
pub const LL_DMAMUX_RGSR_RGOF2: u32 = 4;
pub const LL_DMAMUX_RGSR_RGOF3: u32 = 8;
pub const LL_DMAMUX_CCR_SOIE: u32 = 256;
pub const LL_DMAMUX_RGCR_RGOIE: u32 = 256;
pub const LL_DMAMUX_REQ_MEM2MEM: u32 = 0;
pub const LL_DMAMUX_REQ_GENERATOR0: u32 = 1;
pub const LL_DMAMUX_REQ_GENERATOR1: u32 = 2;
pub const LL_DMAMUX_REQ_GENERATOR2: u32 = 3;
pub const LL_DMAMUX_REQ_GENERATOR3: u32 = 4;
pub const LL_DMAMUX_REQ_ADC1: u32 = 5;
pub const LL_DMAMUX_REQ_SPI1_RX: u32 = 6;
pub const LL_DMAMUX_REQ_SPI1_TX: u32 = 7;
pub const LL_DMAMUX_REQ_SPI2_RX: u32 = 8;
pub const LL_DMAMUX_REQ_SPI2_TX: u32 = 9;
pub const LL_DMAMUX_REQ_I2C1_RX: u32 = 10;
pub const LL_DMAMUX_REQ_I2C1_TX: u32 = 11;
pub const LL_DMAMUX_REQ_I2C3_RX: u32 = 12;
pub const LL_DMAMUX_REQ_I2C3_TX: u32 = 13;
pub const LL_DMAMUX_REQ_USART1_RX: u32 = 14;
pub const LL_DMAMUX_REQ_USART1_TX: u32 = 15;
pub const LL_DMAMUX_REQ_LPUART1_RX: u32 = 16;
pub const LL_DMAMUX_REQ_LPUART1_TX: u32 = 17;
pub const LL_DMAMUX_REQ_SAI1_A: u32 = 18;
pub const LL_DMAMUX_REQ_SAI1_B: u32 = 19;
pub const LL_DMAMUX_REQ_QUADSPI: u32 = 20;
pub const LL_DMAMUX_REQ_TIM1_CH1: u32 = 21;
pub const LL_DMAMUX_REQ_TIM1_CH2: u32 = 22;
pub const LL_DMAMUX_REQ_TIM1_CH3: u32 = 23;
pub const LL_DMAMUX_REQ_TIM1_CH4: u32 = 24;
pub const LL_DMAMUX_REQ_TIM1_UP: u32 = 25;
pub const LL_DMAMUX_REQ_TIM1_TRIG: u32 = 26;
pub const LL_DMAMUX_REQ_TIM1_COM: u32 = 27;
pub const LL_DMAMUX_REQ_TIM2_CH1: u32 = 28;
pub const LL_DMAMUX_REQ_TIM2_CH2: u32 = 29;
pub const LL_DMAMUX_REQ_TIM2_CH3: u32 = 30;
pub const LL_DMAMUX_REQ_TIM2_CH4: u32 = 31;
pub const LL_DMAMUX_REQ_TIM2_UP: u32 = 32;
pub const LL_DMAMUX_REQ_TIM16_CH1: u32 = 33;
pub const LL_DMAMUX_REQ_TIM16_UP: u32 = 34;
pub const LL_DMAMUX_REQ_TIM17_CH1: u32 = 35;
pub const LL_DMAMUX_REQ_TIM17_UP: u32 = 36;
pub const LL_DMAMUX_REQ_AES1_IN: u32 = 37;
pub const LL_DMAMUX_REQ_AES1_OUT: u32 = 38;
pub const LL_DMAMUX_REQ_AES2_IN: u32 = 39;
pub const LL_DMAMUX_REQ_AES2_OUT: u32 = 40;
pub const LL_DMAMUX_CHANNEL_0: u32 = 0;
pub const LL_DMAMUX_CHANNEL_1: u32 = 1;
pub const LL_DMAMUX_CHANNEL_2: u32 = 2;
pub const LL_DMAMUX_CHANNEL_3: u32 = 3;
pub const LL_DMAMUX_CHANNEL_4: u32 = 4;
pub const LL_DMAMUX_CHANNEL_5: u32 = 5;
pub const LL_DMAMUX_CHANNEL_6: u32 = 6;
pub const LL_DMAMUX_CHANNEL_7: u32 = 7;
pub const LL_DMAMUX_CHANNEL_8: u32 = 8;
pub const LL_DMAMUX_CHANNEL_9: u32 = 9;
pub const LL_DMAMUX_CHANNEL_10: u32 = 10;
pub const LL_DMAMUX_CHANNEL_11: u32 = 11;
pub const LL_DMAMUX_CHANNEL_12: u32 = 12;
pub const LL_DMAMUX_CHANNEL_13: u32 = 13;
pub const LL_DMAMUX_SYNC_NO_EVENT: u32 = 0;
pub const LL_DMAMUX_SYNC_POL_RISING: u32 = 131072;
pub const LL_DMAMUX_SYNC_POL_FALLING: u32 = 262144;
pub const LL_DMAMUX_SYNC_POL_RISING_FALLING: u32 = 393216;
pub const LL_DMAMUX_SYNC_EXTI_LINE0: u32 = 0;
pub const LL_DMAMUX_SYNC_EXTI_LINE1: u32 = 16777216;
pub const LL_DMAMUX_SYNC_EXTI_LINE2: u32 = 33554432;
pub const LL_DMAMUX_SYNC_EXTI_LINE3: u32 = 50331648;
pub const LL_DMAMUX_SYNC_EXTI_LINE4: u32 = 67108864;
pub const LL_DMAMUX_SYNC_EXTI_LINE5: u32 = 83886080;
pub const LL_DMAMUX_SYNC_EXTI_LINE6: u32 = 100663296;
pub const LL_DMAMUX_SYNC_EXTI_LINE7: u32 = 117440512;
pub const LL_DMAMUX_SYNC_EXTI_LINE8: u32 = 134217728;
pub const LL_DMAMUX_SYNC_EXTI_LINE9: u32 = 150994944;
pub const LL_DMAMUX_SYNC_EXTI_LINE10: u32 = 167772160;
pub const LL_DMAMUX_SYNC_EXTI_LINE11: u32 = 184549376;
pub const LL_DMAMUX_SYNC_EXTI_LINE12: u32 = 201326592;
pub const LL_DMAMUX_SYNC_EXTI_LINE13: u32 = 218103808;
pub const LL_DMAMUX_SYNC_EXTI_LINE14: u32 = 234881024;
pub const LL_DMAMUX_SYNC_EXTI_LINE15: u32 = 251658240;
pub const LL_DMAMUX_SYNC_DMAMUX_CH0: u32 = 268435456;
pub const LL_DMAMUX_SYNC_DMAMUX_CH1: u32 = 285212672;
pub const LL_DMAMUX_SYNC_LPTIM1_OUT: u32 = 301989888;
pub const LL_DMAMUX_SYNC_LPTIM2_OUT: u32 = 318767104;
pub const LL_DMAMUX_REQ_GEN_0: u32 = 0;
pub const LL_DMAMUX_REQ_GEN_1: u32 = 1;
pub const LL_DMAMUX_REQ_GEN_2: u32 = 2;
pub const LL_DMAMUX_REQ_GEN_3: u32 = 3;
pub const LL_DMAMUX_REQ_GEN_NO_EVENT: u32 = 0;
pub const LL_DMAMUX_REQ_GEN_POL_RISING: u32 = 131072;
pub const LL_DMAMUX_REQ_GEN_POL_FALLING: u32 = 262144;
pub const LL_DMAMUX_REQ_GEN_POL_RISING_FALLING: u32 = 393216;
pub const LL_DMAMUX_REQ_GEN_EXTI_LINE0: u32 = 0;
pub const LL_DMAMUX_REQ_GEN_EXTI_LINE1: u32 = 1;
pub const LL_DMAMUX_REQ_GEN_EXTI_LINE2: u32 = 2;
pub const LL_DMAMUX_REQ_GEN_EXTI_LINE3: u32 = 3;
pub const LL_DMAMUX_REQ_GEN_EXTI_LINE4: u32 = 4;
pub const LL_DMAMUX_REQ_GEN_EXTI_LINE5: u32 = 5;
pub const LL_DMAMUX_REQ_GEN_EXTI_LINE6: u32 = 6;
pub const LL_DMAMUX_REQ_GEN_EXTI_LINE7: u32 = 7;
pub const LL_DMAMUX_REQ_GEN_EXTI_LINE8: u32 = 8;
pub const LL_DMAMUX_REQ_GEN_EXTI_LINE9: u32 = 9;
pub const LL_DMAMUX_REQ_GEN_EXTI_LINE10: u32 = 10;
pub const LL_DMAMUX_REQ_GEN_EXTI_LINE11: u32 = 11;
pub const LL_DMAMUX_REQ_GEN_EXTI_LINE12: u32 = 12;
pub const LL_DMAMUX_REQ_GEN_EXTI_LINE13: u32 = 13;
pub const LL_DMAMUX_REQ_GEN_EXTI_LINE14: u32 = 14;
pub const LL_DMAMUX_REQ_GEN_EXTI_LINE15: u32 = 15;
pub const LL_DMAMUX_REQ_GEN_DMAMUX_CH0: u32 = 16;
pub const LL_DMAMUX_REQ_GEN_DMAMUX_CH1: u32 = 17;
pub const LL_DMAMUX_REQ_GEN_LPTIM1_OUT: u32 = 18;
pub const LL_DMAMUX_REQ_GEN_LPTIM2_OUT: u32 = 19;
pub const LL_DMA_IFCR_CGIF1: u32 = 1;
pub const LL_DMA_IFCR_CTCIF1: u32 = 2;
pub const LL_DMA_IFCR_CHTIF1: u32 = 4;
pub const LL_DMA_IFCR_CTEIF1: u32 = 8;
pub const LL_DMA_IFCR_CGIF2: u32 = 16;
pub const LL_DMA_IFCR_CTCIF2: u32 = 32;
pub const LL_DMA_IFCR_CHTIF2: u32 = 64;
pub const LL_DMA_IFCR_CTEIF2: u32 = 128;
pub const LL_DMA_IFCR_CGIF3: u32 = 256;
pub const LL_DMA_IFCR_CTCIF3: u32 = 512;
pub const LL_DMA_IFCR_CHTIF3: u32 = 1024;
pub const LL_DMA_IFCR_CTEIF3: u32 = 2048;
pub const LL_DMA_IFCR_CGIF4: u32 = 4096;
pub const LL_DMA_IFCR_CTCIF4: u32 = 8192;
pub const LL_DMA_IFCR_CHTIF4: u32 = 16384;
pub const LL_DMA_IFCR_CTEIF4: u32 = 32768;
pub const LL_DMA_IFCR_CGIF5: u32 = 65536;
pub const LL_DMA_IFCR_CTCIF5: u32 = 131072;
pub const LL_DMA_IFCR_CHTIF5: u32 = 262144;
pub const LL_DMA_IFCR_CTEIF5: u32 = 524288;
pub const LL_DMA_IFCR_CGIF6: u32 = 1048576;
pub const LL_DMA_IFCR_CTCIF6: u32 = 2097152;
pub const LL_DMA_IFCR_CHTIF6: u32 = 4194304;
pub const LL_DMA_IFCR_CTEIF6: u32 = 8388608;
pub const LL_DMA_IFCR_CGIF7: u32 = 16777216;
pub const LL_DMA_IFCR_CTCIF7: u32 = 33554432;
pub const LL_DMA_IFCR_CHTIF7: u32 = 67108864;
pub const LL_DMA_IFCR_CTEIF7: u32 = 134217728;
pub const LL_DMA_ISR_GIF1: u32 = 1;
pub const LL_DMA_ISR_TCIF1: u32 = 2;
pub const LL_DMA_ISR_HTIF1: u32 = 4;
pub const LL_DMA_ISR_TEIF1: u32 = 8;
pub const LL_DMA_ISR_GIF2: u32 = 16;
pub const LL_DMA_ISR_TCIF2: u32 = 32;
pub const LL_DMA_ISR_HTIF2: u32 = 64;
pub const LL_DMA_ISR_TEIF2: u32 = 128;
pub const LL_DMA_ISR_GIF3: u32 = 256;
pub const LL_DMA_ISR_TCIF3: u32 = 512;
pub const LL_DMA_ISR_HTIF3: u32 = 1024;
pub const LL_DMA_ISR_TEIF3: u32 = 2048;
pub const LL_DMA_ISR_GIF4: u32 = 4096;
pub const LL_DMA_ISR_TCIF4: u32 = 8192;
pub const LL_DMA_ISR_HTIF4: u32 = 16384;
pub const LL_DMA_ISR_TEIF4: u32 = 32768;
pub const LL_DMA_ISR_GIF5: u32 = 65536;
pub const LL_DMA_ISR_TCIF5: u32 = 131072;
pub const LL_DMA_ISR_HTIF5: u32 = 262144;
pub const LL_DMA_ISR_TEIF5: u32 = 524288;
pub const LL_DMA_ISR_GIF6: u32 = 1048576;
pub const LL_DMA_ISR_TCIF6: u32 = 2097152;
pub const LL_DMA_ISR_HTIF6: u32 = 4194304;
pub const LL_DMA_ISR_TEIF6: u32 = 8388608;
pub const LL_DMA_ISR_GIF7: u32 = 16777216;
pub const LL_DMA_ISR_TCIF7: u32 = 33554432;
pub const LL_DMA_ISR_HTIF7: u32 = 67108864;
pub const LL_DMA_ISR_TEIF7: u32 = 134217728;
pub const LL_DMA_CCR_TCIE: u32 = 2;
pub const LL_DMA_CCR_HTIE: u32 = 4;
pub const LL_DMA_CCR_TEIE: u32 = 8;
pub const LL_DMA_CHANNEL_1: u32 = 1;
pub const LL_DMA_CHANNEL_2: u32 = 2;
pub const LL_DMA_CHANNEL_3: u32 = 3;
pub const LL_DMA_CHANNEL_4: u32 = 4;
pub const LL_DMA_CHANNEL_5: u32 = 5;
pub const LL_DMA_CHANNEL_6: u32 = 6;
pub const LL_DMA_CHANNEL_7: u32 = 7;
pub const LL_DMA_CHANNEL_ALL: u32 = 4294901760;
pub const LL_DMA_DIRECTION_PERIPH_TO_MEMORY: u32 = 0;
pub const LL_DMA_DIRECTION_MEMORY_TO_PERIPH: u32 = 16;
pub const LL_DMA_DIRECTION_MEMORY_TO_MEMORY: u32 = 16384;
pub const LL_DMA_MODE_NORMAL: u32 = 0;
pub const LL_DMA_MODE_CIRCULAR: u32 = 32;
pub const LL_DMA_PERIPH_INCREMENT: u32 = 64;
pub const LL_DMA_PERIPH_NOINCREMENT: u32 = 0;
pub const LL_DMA_MEMORY_INCREMENT: u32 = 128;
pub const LL_DMA_MEMORY_NOINCREMENT: u32 = 0;
pub const LL_DMA_PDATAALIGN_BYTE: u32 = 0;
pub const LL_DMA_PDATAALIGN_HALFWORD: u32 = 256;
pub const LL_DMA_PDATAALIGN_WORD: u32 = 512;
pub const LL_DMA_MDATAALIGN_BYTE: u32 = 0;
pub const LL_DMA_MDATAALIGN_HALFWORD: u32 = 1024;
pub const LL_DMA_MDATAALIGN_WORD: u32 = 2048;
pub const LL_DMA_PRIORITY_LOW: u32 = 0;
pub const LL_DMA_PRIORITY_MEDIUM: u32 = 4096;
pub const LL_DMA_PRIORITY_HIGH: u32 = 8192;
pub const LL_DMA_PRIORITY_VERYHIGH: u32 = 12288;
pub const LL_HSEM_COREID_NONE: u32 = 0;
pub const LL_HSEM_COREID_CPU1: u32 = 1024;
pub const LL_HSEM_COREID_CPU2: u32 = 2048;
pub const LL_HSEM_COREID: u32 = 1024;
pub const LL_HSEM_SEMAPHORE_0: u32 = 1;
pub const LL_HSEM_SEMAPHORE_1: u32 = 2;
pub const LL_HSEM_SEMAPHORE_2: u32 = 4;
pub const LL_HSEM_SEMAPHORE_3: u32 = 8;
pub const LL_HSEM_SEMAPHORE_4: u32 = 16;
pub const LL_HSEM_SEMAPHORE_5: u32 = 32;
pub const LL_HSEM_SEMAPHORE_6: u32 = 64;
pub const LL_HSEM_SEMAPHORE_7: u32 = 128;
pub const LL_HSEM_SEMAPHORE_8: u32 = 256;
pub const LL_HSEM_SEMAPHORE_9: u32 = 512;
pub const LL_HSEM_SEMAPHORE_10: u32 = 1024;
pub const LL_HSEM_SEMAPHORE_11: u32 = 2048;
pub const LL_HSEM_SEMAPHORE_12: u32 = 4096;
pub const LL_HSEM_SEMAPHORE_13: u32 = 8192;
pub const LL_HSEM_SEMAPHORE_14: u32 = 16384;
pub const LL_HSEM_SEMAPHORE_15: u32 = 32768;
pub const LL_HSEM_SEMAPHORE_16: u32 = 65536;
pub const LL_HSEM_SEMAPHORE_17: u32 = 131072;
pub const LL_HSEM_SEMAPHORE_18: u32 = 262144;
pub const LL_HSEM_SEMAPHORE_19: u32 = 524288;
pub const LL_HSEM_SEMAPHORE_20: u32 = 1048576;
pub const LL_HSEM_SEMAPHORE_21: u32 = 2097152;
pub const LL_HSEM_SEMAPHORE_22: u32 = 4194304;
pub const LL_HSEM_SEMAPHORE_23: u32 = 8388608;
pub const LL_HSEM_SEMAPHORE_24: u32 = 16777216;
pub const LL_HSEM_SEMAPHORE_25: u32 = 33554432;
pub const LL_HSEM_SEMAPHORE_26: u32 = 67108864;
pub const LL_HSEM_SEMAPHORE_27: u32 = 134217728;
pub const LL_HSEM_SEMAPHORE_28: u32 = 268435456;
pub const LL_HSEM_SEMAPHORE_29: u32 = 536870912;
pub const LL_HSEM_SEMAPHORE_30: u32 = 1073741824;
pub const LL_HSEM_SEMAPHORE_31: u32 = 2147483648;
pub const LL_HSEM_SEMAPHORE_ALL: u32 = 4294967295;
pub const LL_IPCC_C1TOC2SR_CH1F: u32 = 1;
pub const LL_IPCC_C1TOC2SR_CH2F: u32 = 2;
pub const LL_IPCC_C1TOC2SR_CH3F: u32 = 4;
pub const LL_IPCC_C1TOC2SR_CH4F: u32 = 8;
pub const LL_IPCC_C1TOC2SR_CH5F: u32 = 16;
pub const LL_IPCC_C1TOC2SR_CH6F: u32 = 32;
pub const LL_IPCC_C2TOC1SR_CH1F: u32 = 1;
pub const LL_IPCC_C2TOC1SR_CH2F: u32 = 2;
pub const LL_IPCC_C2TOC1SR_CH3F: u32 = 4;
pub const LL_IPCC_C2TOC1SR_CH4F: u32 = 8;
pub const LL_IPCC_C2TOC1SR_CH5F: u32 = 16;
pub const LL_IPCC_C2TOC1SR_CH6F: u32 = 32;
pub const LL_IPCC_CHANNEL_1: u32 = 1;
pub const LL_IPCC_CHANNEL_2: u32 = 2;
pub const LL_IPCC_CHANNEL_3: u32 = 4;
pub const LL_IPCC_CHANNEL_4: u32 = 8;
pub const LL_IPCC_CHANNEL_5: u32 = 16;
pub const LL_IPCC_CHANNEL_6: u32 = 32;
pub const LL_IWDG_KEY_RELOAD: u32 = 43690;
pub const LL_IWDG_KEY_ENABLE: u32 = 52428;
pub const LL_IWDG_KEY_WR_ACCESS_ENABLE: u32 = 21845;
pub const LL_IWDG_KEY_WR_ACCESS_DISABLE: u32 = 0;
pub const LL_IWDG_SR_PVU: u32 = 1;
pub const LL_IWDG_SR_RVU: u32 = 2;
pub const LL_IWDG_SR_WVU: u32 = 4;
pub const LL_IWDG_PRESCALER_4: u32 = 0;
pub const LL_IWDG_PRESCALER_8: u32 = 1;
pub const LL_IWDG_PRESCALER_16: u32 = 2;
pub const LL_IWDG_PRESCALER_32: u32 = 3;
pub const LL_IWDG_PRESCALER_64: u32 = 4;
pub const LL_IWDG_PRESCALER_128: u32 = 5;
pub const LL_IWDG_PRESCALER_256: u32 = 6;
pub const LPUART_LPUARTDIV_FREQ_MUL: u32 = 256;
pub const LPUART_BRR_MASK: u32 = 1048575;
pub const LPUART_BRR_MIN_VALUE: u32 = 768;
pub const LL_LPUART_ICR_PECF: u32 = 1;
pub const LL_LPUART_ICR_FECF: u32 = 2;
pub const LL_LPUART_ICR_NCF: u32 = 4;
pub const LL_LPUART_ICR_ORECF: u32 = 8;
pub const LL_LPUART_ICR_IDLECF: u32 = 16;
pub const LL_LPUART_ICR_TXFECF: u32 = 32;
pub const LL_LPUART_ICR_TCCF: u32 = 64;
pub const LL_LPUART_ICR_CTSCF: u32 = 512;
pub const LL_LPUART_ICR_CMCF: u32 = 131072;
pub const LL_LPUART_ICR_WUCF: u32 = 1048576;
pub const LL_LPUART_ISR_PE: u32 = 1;
pub const LL_LPUART_ISR_FE: u32 = 2;
pub const LL_LPUART_ISR_NE: u32 = 4;
pub const LL_LPUART_ISR_ORE: u32 = 8;
pub const LL_LPUART_ISR_IDLE: u32 = 16;
pub const LL_LPUART_ISR_RXNE_RXFNE: u32 = 32;
pub const LL_LPUART_ISR_TC: u32 = 64;
pub const LL_LPUART_ISR_TXE_TXFNF: u32 = 128;
pub const LL_LPUART_ISR_CTSIF: u32 = 512;
pub const LL_LPUART_ISR_CTS: u32 = 1024;
pub const LL_LPUART_ISR_BUSY: u32 = 65536;
pub const LL_LPUART_ISR_CMF: u32 = 131072;
pub const LL_LPUART_ISR_SBKF: u32 = 262144;
pub const LL_LPUART_ISR_RWU: u32 = 524288;
pub const LL_LPUART_ISR_WUF: u32 = 1048576;
pub const LL_LPUART_ISR_TEACK: u32 = 2097152;
pub const LL_LPUART_ISR_REACK: u32 = 4194304;
pub const LL_LPUART_ISR_TXFE: u32 = 8388608;
pub const LL_LPUART_ISR_RXFF: u32 = 16777216;
pub const LL_LPUART_ISR_RXFT: u32 = 67108864;
pub const LL_LPUART_ISR_TXFT: u32 = 134217728;
pub const LL_LPUART_CR1_IDLEIE: u32 = 16;
pub const LL_LPUART_CR1_RXNEIE_RXFNEIE: u32 = 32;
pub const LL_LPUART_CR1_TCIE: u32 = 64;
pub const LL_LPUART_CR1_TXEIE_TXFNFIE: u32 = 128;
pub const LL_LPUART_CR1_PEIE: u32 = 256;
pub const LL_LPUART_CR1_CMIE: u32 = 16384;
pub const LL_LPUART_CR1_TXFEIE: u32 = 1073741824;
pub const LL_LPUART_CR1_RXFFIE: u32 = 2147483648;
pub const LL_LPUART_CR3_EIE: u32 = 1;
pub const LL_LPUART_CR3_CTSIE: u32 = 1024;
pub const LL_LPUART_CR3_WUFIE: u32 = 4194304;
pub const LL_LPUART_CR3_TXFTIE: u32 = 8388608;
pub const LL_LPUART_CR3_RXFTIE: u32 = 268435456;
pub const LL_LPUART_FIFOTHRESHOLD_1_8: u32 = 0;
pub const LL_LPUART_FIFOTHRESHOLD_1_4: u32 = 1;
pub const LL_LPUART_FIFOTHRESHOLD_1_2: u32 = 2;
pub const LL_LPUART_FIFOTHRESHOLD_3_4: u32 = 3;
pub const LL_LPUART_FIFOTHRESHOLD_7_8: u32 = 4;
pub const LL_LPUART_FIFOTHRESHOLD_8_8: u32 = 5;
pub const LL_LPUART_DIRECTION_NONE: u32 = 0;
pub const LL_LPUART_DIRECTION_RX: u32 = 4;
pub const LL_LPUART_DIRECTION_TX: u32 = 8;
pub const LL_LPUART_DIRECTION_TX_RX: u32 = 12;
pub const LL_LPUART_PARITY_NONE: u32 = 0;
pub const LL_LPUART_PARITY_EVEN: u32 = 1024;
pub const LL_LPUART_PARITY_ODD: u32 = 1536;
pub const LL_LPUART_WAKEUP_IDLELINE: u32 = 0;
pub const LL_LPUART_WAKEUP_ADDRESSMARK: u32 = 2048;
pub const LL_LPUART_DATAWIDTH_7B: u32 = 268435456;
pub const LL_LPUART_DATAWIDTH_8B: u32 = 0;
pub const LL_LPUART_DATAWIDTH_9B: u32 = 4096;
pub const LL_LPUART_PRESCALER_DIV1: u32 = 0;
pub const LL_LPUART_PRESCALER_DIV2: u32 = 1;
pub const LL_LPUART_PRESCALER_DIV4: u32 = 2;
pub const LL_LPUART_PRESCALER_DIV6: u32 = 3;
pub const LL_LPUART_PRESCALER_DIV8: u32 = 4;
pub const LL_LPUART_PRESCALER_DIV10: u32 = 5;
pub const LL_LPUART_PRESCALER_DIV12: u32 = 6;
pub const LL_LPUART_PRESCALER_DIV16: u32 = 7;
pub const LL_LPUART_PRESCALER_DIV32: u32 = 8;
pub const LL_LPUART_PRESCALER_DIV64: u32 = 9;
pub const LL_LPUART_PRESCALER_DIV128: u32 = 10;
pub const LL_LPUART_PRESCALER_DIV256: u32 = 11;
pub const LL_LPUART_STOPBITS_1: u32 = 0;
pub const LL_LPUART_STOPBITS_2: u32 = 8192;
pub const LL_LPUART_TXRX_STANDARD: u32 = 0;
pub const LL_LPUART_TXRX_SWAPPED: u32 = 32768;
pub const LL_LPUART_RXPIN_LEVEL_STANDARD: u32 = 0;
pub const LL_LPUART_RXPIN_LEVEL_INVERTED: u32 = 65536;
pub const LL_LPUART_TXPIN_LEVEL_STANDARD: u32 = 0;
pub const LL_LPUART_TXPIN_LEVEL_INVERTED: u32 = 131072;
pub const LL_LPUART_BINARY_LOGIC_POSITIVE: u32 = 0;
pub const LL_LPUART_BINARY_LOGIC_NEGATIVE: u32 = 262144;
pub const LL_LPUART_BITORDER_LSBFIRST: u32 = 0;
pub const LL_LPUART_BITORDER_MSBFIRST: u32 = 524288;
pub const LL_LPUART_ADDRESS_DETECT_4B: u32 = 0;
pub const LL_LPUART_ADDRESS_DETECT_7B: u32 = 16;
pub const LL_LPUART_HWCONTROL_NONE: u32 = 0;
pub const LL_LPUART_HWCONTROL_RTS: u32 = 256;
pub const LL_LPUART_HWCONTROL_CTS: u32 = 512;
pub const LL_LPUART_HWCONTROL_RTS_CTS: u32 = 768;
pub const LL_LPUART_WAKEUP_ON_ADDRESS: u32 = 0;
pub const LL_LPUART_WAKEUP_ON_STARTBIT: u32 = 2097152;
pub const LL_LPUART_WAKEUP_ON_RXNE: u32 = 3145728;
pub const LL_LPUART_DE_POLARITY_HIGH: u32 = 0;
pub const LL_LPUART_DE_POLARITY_LOW: u32 = 32768;
pub const LL_LPUART_DMA_REG_DATA_TRANSMIT: u32 = 0;
pub const LL_LPUART_DMA_REG_DATA_RECEIVE: u32 = 1;
pub const LL_PKA_SR_ADDRERRF: u32 = 1048576;
pub const LL_PKA_SR_RAMERRF: u32 = 524288;
pub const LL_PKA_SR_PROCENDF: u32 = 131072;
pub const LL_PKA_SR_BUSY: u32 = 65536;
pub const LL_PKA_CR_ADDRERRIE: u32 = 1048576;
pub const LL_PKA_CR_RAMERRIE: u32 = 524288;
pub const LL_PKA_CR_PROCENDIE: u32 = 131072;
pub const LL_PKA_CLRFR_PROCENDFC: u32 = 131072;
pub const LL_PKA_CLRFR_RAMERRFC: u32 = 524288;
pub const LL_PKA_CLRFR_ADDRERRFC: u32 = 1048576;
pub const SMPS_VOLTAGE_CAL_POS: u32 = 8;
pub const SMPS_VOLTAGE_CAL: u32 = 3840;
pub const SMPS_VOLTAGE_CAL_VOLTAGE_MV: u32 = 1500;
pub const SMPS_VOLTAGE_BASE_MV: u32 = 1200;
pub const SMPS_VOLTAGE_STEP_MV: u32 = 50;
pub const LL_PWR_SCR_CWUF: u32 = 31;
pub const LL_PWR_SCR_CWUF5: u32 = 16;
pub const LL_PWR_SCR_CWUF4: u32 = 8;
pub const LL_PWR_SCR_CWUF3: u32 = 4;
pub const LL_PWR_SCR_CWUF2: u32 = 2;
pub const LL_PWR_SCR_CWUF1: u32 = 1;
pub const LL_PWR_SCR_CC2HF: u32 = 16384;
pub const LL_PWR_SCR_CBLEAF: u32 = 4096;
pub const LL_PWR_SCR_CCRPEF: u32 = 2048;
pub const LL_PWR_SCR_C802AF: u32 = 8192;
pub const LL_PWR_SCR_C802WUF: u32 = 1024;
pub const LL_PWR_SCR_CBLEWUF: u32 = 512;
pub const LL_PWR_SCR_CBORHF: u32 = 256;
pub const LL_PWR_SCR_CSMPSFBF: u32 = 128;
pub const LL_PWR_EXTSCR_CCRPF: u32 = 4;
pub const LL_PWR_EXTSCR_C2CSSF: u32 = 2;
pub const LL_PWR_EXTSCR_C1CSSF: u32 = 1;
pub const LL_PWR_SR1_WUFI: u32 = 32768;
pub const LL_PWR_SR1_WUF5: u32 = 16;
pub const LL_PWR_SR1_WUF4: u32 = 8;
pub const LL_PWR_SR1_WUF3: u32 = 4;
pub const LL_PWR_SR1_WUF2: u32 = 2;
pub const LL_PWR_SR1_WUF1: u32 = 1;
pub const LL_PWR_SR2_PVMO3: u32 = 16384;
pub const LL_PWR_SR2_PVMO1: u32 = 4096;
pub const LL_PWR_SR2_PVDO: u32 = 2048;
pub const LL_PWR_SR2_VOSF: u32 = 1024;
pub const LL_PWR_SR2_REGLPF: u32 = 512;
pub const LL_PWR_SR2_REGLPS: u32 = 256;
pub const LL_PWR_FLAG_BORH: u32 = 256;
pub const LL_PWR_FLAG_SMPS: u32 = 2;
pub const LL_PWR_FLAG_SMPSB: u32 = 1;
pub const LL_PWR_FLAG_BLEWU: u32 = 512;
pub const LL_PWR_FLAG_BLEA: u32 = 4096;
pub const LL_PWR_FLAG_802WU: u32 = 1024;
pub const LL_PWR_FLAG_802A: u32 = 8192;
pub const LL_PWR_FLAG_CRPE: u32 = 2048;
pub const LL_PWR_FLAG_CRP: u32 = 8192;
pub const LL_PWR_EXTSCR_C1SBF: u32 = 256;
pub const LL_PWR_EXTSCR_C1STOPF: u32 = 512;
pub const LL_PWR_EXTSCR_C1DS: u32 = 16384;
pub const LL_PWR_EXTSCR_C2SBF: u32 = 1024;
pub const LL_PWR_EXTSCR_C2STOPF: u32 = 2048;
pub const LL_PWR_EXTSCR_C2DS: u32 = 32768;
pub const LL_PWR_SR1_C2HF: u32 = 16384;
pub const LL_PWR_REGU_VOLTAGE_SCALE1: u32 = 512;
pub const LL_PWR_REGU_VOLTAGE_SCALE2: u32 = 1024;
pub const LL_PWR_MODE_STOP0: u32 = 0;
pub const LL_PWR_MODE_STOP1: u32 = 1;
pub const LL_PWR_MODE_STOP2: u32 = 2;
pub const LL_PWR_MODE_STANDBY: u32 = 3;
pub const LL_PWR_MODE_SHUTDOWN: u32 = 4;
pub const LL_PWR_FLASH_LPRUN_MODE_IDLE: u32 = 0;
pub const LL_PWR_FLASH_LPRUN_MODE_POWER_DOWN: u32 = 16;
pub const LL_PWR_FLASH_SLEEP_MODE_IDLE: u32 = 0;
pub const LL_PWR_FLASH_SLEEP_MODE_POWER_DOWN: u32 = 32;
pub const LL_PWR_PVM_VDDUSB_1_2V: u32 = 16;
pub const LL_PWR_PVM_VDDA_1_62V: u32 = 64;
pub const LL_PWR_PVDLEVEL_0: u32 = 0;
pub const LL_PWR_PVDLEVEL_1: u32 = 2;
pub const LL_PWR_PVDLEVEL_2: u32 = 4;
pub const LL_PWR_PVDLEVEL_3: u32 = 6;
pub const LL_PWR_PVDLEVEL_4: u32 = 8;
pub const LL_PWR_PVDLEVEL_5: u32 = 10;
pub const LL_PWR_PVDLEVEL_6: u32 = 12;
pub const LL_PWR_PVDLEVEL_7: u32 = 14;
pub const LL_PWR_WAKEUP_PIN1: u32 = 1;
pub const LL_PWR_WAKEUP_PIN2: u32 = 2;
pub const LL_PWR_WAKEUP_PIN3: u32 = 4;
pub const LL_PWR_WAKEUP_PIN4: u32 = 8;
pub const LL_PWR_WAKEUP_PIN5: u32 = 16;
pub const LL_PWR_BATT_CHARG_RESISTOR_5K: u32 = 0;
pub const LL_PWR_BATT_CHARGRESISTOR_1_5K: u32 = 512;
pub const LL_PWR_GPIO_BIT_0: u32 = 1;
pub const LL_PWR_GPIO_BIT_1: u32 = 2;
pub const LL_PWR_GPIO_BIT_2: u32 = 4;
pub const LL_PWR_GPIO_BIT_3: u32 = 8;
pub const LL_PWR_GPIO_BIT_4: u32 = 16;
pub const LL_PWR_GPIO_BIT_5: u32 = 32;
pub const LL_PWR_GPIO_BIT_6: u32 = 64;
pub const LL_PWR_GPIO_BIT_7: u32 = 128;
pub const LL_PWR_GPIO_BIT_8: u32 = 256;
pub const LL_PWR_GPIO_BIT_9: u32 = 512;
pub const LL_PWR_GPIO_BIT_10: u32 = 1024;
pub const LL_PWR_GPIO_BIT_11: u32 = 2048;
pub const LL_PWR_GPIO_BIT_12: u32 = 4096;
pub const LL_PWR_GPIO_BIT_13: u32 = 8192;
pub const LL_PWR_GPIO_BIT_14: u32 = 16384;
pub const LL_PWR_GPIO_BIT_15: u32 = 32768;
pub const LL_PWR_BOR_SYSTEM_RESET: u32 = 0;
pub const LL_PWR_BOR_SMPS_FORCE_BYPASS: u32 = 256;
pub const LL_PWR_SMPS_BYPASS: u32 = 1;
pub const LL_PWR_SMPS_STEP_DOWN: u32 = 2;
pub const LL_PWR_SMPS_STARTUP_CURRENT_80MA: u32 = 0;
pub const LL_PWR_SMPS_STARTUP_CURRENT_100MA: u32 = 16;
pub const LL_PWR_SMPS_STARTUP_CURRENT_120MA: u32 = 32;
pub const LL_PWR_SMPS_STARTUP_CURRENT_140MA: u32 = 48;
pub const LL_PWR_SMPS_STARTUP_CURRENT_160MA: u32 = 64;
pub const LL_PWR_SMPS_STARTUP_CURRENT_180MA: u32 = 80;
pub const LL_PWR_SMPS_STARTUP_CURRENT_200MA: u32 = 96;
pub const LL_PWR_SMPS_STARTUP_CURRENT_220MA: u32 = 112;
pub const LL_PWR_SMPS_OUTPUT_VOLTAGE_1V20: u32 = 0;
pub const LL_PWR_SMPS_OUTPUT_VOLTAGE_1V25: u32 = 1;
pub const LL_PWR_SMPS_OUTPUT_VOLTAGE_1V30: u32 = 2;
pub const LL_PWR_SMPS_OUTPUT_VOLTAGE_1V35: u32 = 3;
pub const LL_PWR_SMPS_OUTPUT_VOLTAGE_1V40: u32 = 4;
pub const LL_PWR_SMPS_OUTPUT_VOLTAGE_1V45: u32 = 5;
pub const LL_PWR_SMPS_OUTPUT_VOLTAGE_1V50: u32 = 6;
pub const LL_PWR_SMPS_OUTPUT_VOLTAGE_1V55: u32 = 7;
pub const LL_PWR_SMPS_OUTPUT_VOLTAGE_1V60: u32 = 8;
pub const LL_PWR_SMPS_OUTPUT_VOLTAGE_1V65: u32 = 9;
pub const LL_PWR_SMPS_OUTPUT_VOLTAGE_1V70: u32 = 10;
pub const LL_PWR_SMPS_OUTPUT_VOLTAGE_1V75: u32 = 11;
pub const LL_PWR_SMPS_OUTPUT_VOLTAGE_1V80: u32 = 12;
pub const LL_PWR_SMPS_OUTPUT_VOLTAGE_1V85: u32 = 13;
pub const LL_PWR_SMPS_OUTPUT_VOLTAGE_1V90: u32 = 14;
pub const LL_RNG_CED_ENABLE: u32 = 0;
pub const LL_RNG_CED_DISABLE: u32 = 32;
pub const LL_RNG_SR_DRDY: u32 = 1;
pub const LL_RNG_SR_CECS: u32 = 2;
pub const LL_RNG_SR_SECS: u32 = 4;
pub const LL_RNG_SR_CEIS: u32 = 32;
pub const LL_RNG_SR_SEIS: u32 = 64;
pub const LL_RNG_CR_IE: u32 = 8;
pub const LL_RTC_FORMAT_BIN: u32 = 0;
pub const LL_RTC_FORMAT_BCD: u32 = 1;
pub const LL_RTC_ALMA_DATEWEEKDAYSEL_DATE: u32 = 0;
pub const LL_RTC_ALMA_DATEWEEKDAYSEL_WEEKDAY: u32 = 1073741824;
pub const LL_RTC_ALMB_DATEWEEKDAYSEL_DATE: u32 = 0;
pub const LL_RTC_ALMB_DATEWEEKDAYSEL_WEEKDAY: u32 = 1073741824;
pub const LL_RTC_ISR_ITSF: u32 = 131072;
pub const LL_RTC_ISR_RECALPF: u32 = 65536;
pub const LL_RTC_ISR_TAMP3F: u32 = 32768;
pub const LL_RTC_ISR_TAMP2F: u32 = 16384;
pub const LL_RTC_ISR_TAMP1F: u32 = 8192;
pub const LL_RTC_ISR_TSOVF: u32 = 4096;
pub const LL_RTC_ISR_TSF: u32 = 2048;
pub const LL_RTC_ISR_WUTF: u32 = 1024;
pub const LL_RTC_ISR_ALRBF: u32 = 512;
pub const LL_RTC_ISR_ALRAF: u32 = 256;
pub const LL_RTC_ISR_INITF: u32 = 64;
pub const LL_RTC_ISR_RSF: u32 = 32;
pub const LL_RTC_ISR_INITS: u32 = 16;
pub const LL_RTC_ISR_SHPF: u32 = 8;
pub const LL_RTC_ISR_WUTWF: u32 = 4;
pub const LL_RTC_ISR_ALRBWF: u32 = 2;
pub const LL_RTC_ISR_ALRAWF: u32 = 1;
pub const LL_RTC_CR_TSIE: u32 = 32768;
pub const LL_RTC_CR_WUTIE: u32 = 16384;
pub const LL_RTC_CR_ALRBIE: u32 = 8192;
pub const LL_RTC_CR_ALRAIE: u32 = 4096;
pub const LL_RTC_TAMPCR_TAMP3IE: u32 = 4194304;
pub const LL_RTC_TAMPCR_TAMP2IE: u32 = 524288;
pub const LL_RTC_TAMPCR_TAMP1IE: u32 = 65536;
pub const LL_RTC_TAMPCR_TAMPIE: u32 = 4;
pub const LL_RTC_HOURFORMAT_24HOUR: u32 = 0;
pub const LL_RTC_HOURFORMAT_AMPM: u32 = 64;
pub const LL_RTC_ALARMOUT_DISABLE: u32 = 0;
pub const LL_RTC_ALARMOUT_ALMA: u32 = 2097152;
pub const LL_RTC_ALARMOUT_ALMB: u32 = 4194304;
pub const LL_RTC_ALARMOUT_WAKEUP: u32 = 6291456;
pub const LL_RTC_ALARM_OUTPUTTYPE_OPENDRAIN: u32 = 0;
pub const LL_RTC_ALARM_OUTPUTTYPE_PUSHPULL: u32 = 1;
pub const LL_RTC_OUTPUTPOLARITY_PIN_HIGH: u32 = 0;
pub const LL_RTC_OUTPUTPOLARITY_PIN_LOW: u32 = 1048576;
pub const LL_RTC_TIME_FORMAT_AM_OR_24: u32 = 0;
pub const LL_RTC_TIME_FORMAT_PM: u32 = 4194304;
pub const LL_RTC_SHIFT_SECOND_DELAY: u32 = 0;
pub const LL_RTC_SHIFT_SECOND_ADVANCE: u32 = 2147483648;
pub const LL_RTC_ALMA_MASK_NONE: u32 = 0;
pub const LL_RTC_ALMA_MASK_DATEWEEKDAY: u32 = 2147483648;
pub const LL_RTC_ALMA_MASK_HOURS: u32 = 8388608;
pub const LL_RTC_ALMA_MASK_MINUTES: u32 = 32768;
pub const LL_RTC_ALMA_MASK_SECONDS: u32 = 128;
pub const LL_RTC_ALMA_MASK_ALL: u32 = 2155905152;
pub const LL_RTC_ALMA_TIME_FORMAT_AM: u32 = 0;
pub const LL_RTC_ALMA_TIME_FORMAT_PM: u32 = 4194304;
pub const LL_RTC_ALMB_MASK_NONE: u32 = 0;
pub const LL_RTC_ALMB_MASK_DATEWEEKDAY: u32 = 2147483648;
pub const LL_RTC_ALMB_MASK_HOURS: u32 = 8388608;
pub const LL_RTC_ALMB_MASK_MINUTES: u32 = 32768;
pub const LL_RTC_ALMB_MASK_SECONDS: u32 = 128;
pub const LL_RTC_ALMB_MASK_ALL: u32 = 2155905152;
pub const LL_RTC_ALMB_TIME_FORMAT_AM: u32 = 0;
pub const LL_RTC_ALMB_TIME_FORMAT_PM: u32 = 4194304;
pub const LL_RTC_TIMESTAMP_EDGE_RISING: u32 = 0;
pub const LL_RTC_TIMESTAMP_EDGE_FALLING: u32 = 8;
pub const LL_RTC_TS_TIME_FORMAT_AM: u32 = 0;
pub const LL_RTC_TS_TIME_FORMAT_PM: u32 = 4194304;
pub const LL_RTC_TAMPER_1: u32 = 1;
pub const LL_RTC_TAMPER_2: u32 = 8;
pub const LL_RTC_TAMPER_3: u32 = 32;
pub const LL_RTC_TAMPER_MASK_TAMPER1: u32 = 262144;
pub const LL_RTC_TAMPER_MASK_TAMPER2: u32 = 2097152;
pub const LL_RTC_TAMPER_MASK_TAMPER3: u32 = 16777216;
pub const LL_RTC_TAMPER_NOERASE_TAMPER1: u32 = 131072;
pub const LL_RTC_TAMPER_NOERASE_TAMPER2: u32 = 1048576;
pub const LL_RTC_TAMPER_NOERASE_TAMPER3: u32 = 8388608;
pub const LL_RTC_TAMPER_DURATION_1RTCCLK: u32 = 0;
pub const LL_RTC_TAMPER_DURATION_2RTCCLK: u32 = 8192;
pub const LL_RTC_TAMPER_DURATION_4RTCCLK: u32 = 16384;
pub const LL_RTC_TAMPER_DURATION_8RTCCLK: u32 = 24576;
pub const LL_RTC_TAMPER_FILTER_DISABLE: u32 = 0;
pub const LL_RTC_TAMPER_FILTER_2SAMPLE: u32 = 2048;
pub const LL_RTC_TAMPER_FILTER_4SAMPLE: u32 = 4096;
pub const LL_RTC_TAMPER_FILTER_8SAMPLE: u32 = 6144;
pub const LL_RTC_TAMPER_SAMPLFREQDIV_32768: u32 = 0;
pub const LL_RTC_TAMPER_SAMPLFREQDIV_16384: u32 = 256;
pub const LL_RTC_TAMPER_SAMPLFREQDIV_8192: u32 = 512;
pub const LL_RTC_TAMPER_SAMPLFREQDIV_4096: u32 = 768;
pub const LL_RTC_TAMPER_SAMPLFREQDIV_2048: u32 = 1024;
pub const LL_RTC_TAMPER_SAMPLFREQDIV_1024: u32 = 1280;
pub const LL_RTC_TAMPER_SAMPLFREQDIV_512: u32 = 1536;
pub const LL_RTC_TAMPER_SAMPLFREQDIV_256: u32 = 1792;
pub const LL_RTC_TAMPER_ACTIVELEVEL_TAMP1: u32 = 2;
pub const LL_RTC_TAMPER_ACTIVELEVEL_TAMP2: u32 = 16;
pub const LL_RTC_TAMPER_ACTIVELEVEL_TAMP3: u32 = 64;
pub const LL_RTC_WAKEUPCLOCK_DIV_16: u32 = 0;
pub const LL_RTC_WAKEUPCLOCK_DIV_8: u32 = 1;
pub const LL_RTC_WAKEUPCLOCK_DIV_4: u32 = 2;
pub const LL_RTC_WAKEUPCLOCK_DIV_2: u32 = 3;
pub const LL_RTC_WAKEUPCLOCK_CKSPRE: u32 = 4;
pub const LL_RTC_WAKEUPCLOCK_CKSPRE_WUT: u32 = 6;
pub const LL_RTC_BKP_DR0: u32 = 0;
pub const LL_RTC_BKP_DR1: u32 = 1;
pub const LL_RTC_BKP_DR2: u32 = 2;
pub const LL_RTC_BKP_DR3: u32 = 3;
pub const LL_RTC_BKP_DR4: u32 = 4;
pub const LL_RTC_BKP_DR5: u32 = 5;
pub const LL_RTC_BKP_DR6: u32 = 6;
pub const LL_RTC_BKP_DR7: u32 = 7;
pub const LL_RTC_BKP_DR8: u32 = 8;
pub const LL_RTC_BKP_DR9: u32 = 9;
pub const LL_RTC_BKP_DR10: u32 = 10;
pub const LL_RTC_BKP_DR11: u32 = 11;
pub const LL_RTC_BKP_DR12: u32 = 12;
pub const LL_RTC_BKP_DR13: u32 = 13;
pub const LL_RTC_BKP_DR14: u32 = 14;
pub const LL_RTC_BKP_DR15: u32 = 15;
pub const LL_RTC_BKP_DR16: u32 = 16;
pub const LL_RTC_BKP_DR17: u32 = 17;
pub const LL_RTC_BKP_DR18: u32 = 18;
pub const LL_RTC_BKP_DR19: u32 = 19;
pub const LL_RTC_CALIB_OUTPUT_NONE: u32 = 0;
pub const LL_RTC_CALIB_OUTPUT_1HZ: u32 = 8912896;
pub const LL_RTC_CALIB_OUTPUT_512HZ: u32 = 8388608;
pub const LL_RTC_CALIB_INSERTPULSE_NONE: u32 = 0;
pub const LL_RTC_CALIB_INSERTPULSE_SET: u32 = 32768;
pub const LL_RTC_CALIB_PERIOD_32SEC: u32 = 0;
pub const LL_RTC_CALIB_PERIOD_16SEC: u32 = 8192;
pub const LL_RTC_CALIB_PERIOD_8SEC: u32 = 16384;
pub const LL_USART_ICR_PECF: u32 = 1;
pub const LL_USART_ICR_FECF: u32 = 2;
pub const LL_USART_ICR_NECF: u32 = 4;
pub const LL_USART_ICR_ORECF: u32 = 8;
pub const LL_USART_ICR_IDLECF: u32 = 16;
pub const LL_USART_ICR_TXFECF: u32 = 32;
pub const LL_USART_ICR_TCCF: u32 = 64;
pub const LL_USART_ICR_TCBGTCF: u32 = 128;
pub const LL_USART_ICR_LBDCF: u32 = 256;
pub const LL_USART_ICR_CTSCF: u32 = 512;
pub const LL_USART_ICR_RTOCF: u32 = 2048;
pub const LL_USART_ICR_EOBCF: u32 = 4096;
pub const LL_USART_ICR_UDRCF: u32 = 8192;
pub const LL_USART_ICR_CMCF: u32 = 131072;
pub const LL_USART_ICR_WUCF: u32 = 1048576;
pub const LL_USART_ISR_PE: u32 = 1;
pub const LL_USART_ISR_FE: u32 = 2;
pub const LL_USART_ISR_NE: u32 = 4;
pub const LL_USART_ISR_ORE: u32 = 8;
pub const LL_USART_ISR_IDLE: u32 = 16;
pub const LL_USART_ISR_RXNE_RXFNE: u32 = 32;
pub const LL_USART_ISR_TC: u32 = 64;
pub const LL_USART_ISR_TXE_TXFNF: u32 = 128;
pub const LL_USART_ISR_LBDF: u32 = 256;
pub const LL_USART_ISR_CTSIF: u32 = 512;
pub const LL_USART_ISR_CTS: u32 = 1024;
pub const LL_USART_ISR_RTOF: u32 = 2048;
pub const LL_USART_ISR_EOBF: u32 = 4096;
pub const LL_USART_ISR_UDR: u32 = 8192;
pub const LL_USART_ISR_ABRE: u32 = 16384;
pub const LL_USART_ISR_ABRF: u32 = 32768;
pub const LL_USART_ISR_BUSY: u32 = 65536;
pub const LL_USART_ISR_CMF: u32 = 131072;
pub const LL_USART_ISR_SBKF: u32 = 262144;
pub const LL_USART_ISR_RWU: u32 = 524288;
pub const LL_USART_ISR_WUF: u32 = 1048576;
pub const LL_USART_ISR_TEACK: u32 = 2097152;
pub const LL_USART_ISR_REACK: u32 = 4194304;
pub const LL_USART_ISR_TXFE: u32 = 8388608;
pub const LL_USART_ISR_RXFF: u32 = 16777216;
pub const LL_USART_ISR_TCBGT: u32 = 33554432;
pub const LL_USART_ISR_RXFT: u32 = 67108864;
pub const LL_USART_ISR_TXFT: u32 = 134217728;
pub const LL_USART_CR1_IDLEIE: u32 = 16;
pub const LL_USART_CR1_RXNEIE_RXFNEIE: u32 = 32;
pub const LL_USART_CR1_TCIE: u32 = 64;
pub const LL_USART_CR1_TXEIE_TXFNFIE: u32 = 128;
pub const LL_USART_CR1_PEIE: u32 = 256;
pub const LL_USART_CR1_CMIE: u32 = 16384;
pub const LL_USART_CR1_RTOIE: u32 = 67108864;
pub const LL_USART_CR1_EOBIE: u32 = 134217728;
pub const LL_USART_CR1_TXFEIE: u32 = 1073741824;
pub const LL_USART_CR1_RXFFIE: u32 = 2147483648;
pub const LL_USART_CR2_LBDIE: u32 = 64;
pub const LL_USART_CR3_EIE: u32 = 1;
pub const LL_USART_CR3_CTSIE: u32 = 1024;
pub const LL_USART_CR3_WUFIE: u32 = 4194304;
pub const LL_USART_CR3_TXFTIE: u32 = 8388608;
pub const LL_USART_CR3_TCBGTIE: u32 = 16777216;
pub const LL_USART_CR3_RXFTIE: u32 = 268435456;
pub const LL_USART_FIFOTHRESHOLD_1_8: u32 = 0;
pub const LL_USART_FIFOTHRESHOLD_1_4: u32 = 1;
pub const LL_USART_FIFOTHRESHOLD_1_2: u32 = 2;
pub const LL_USART_FIFOTHRESHOLD_3_4: u32 = 3;
pub const LL_USART_FIFOTHRESHOLD_7_8: u32 = 4;
pub const LL_USART_FIFOTHRESHOLD_8_8: u32 = 5;
pub const LL_USART_DIRECTION_NONE: u32 = 0;
pub const LL_USART_DIRECTION_RX: u32 = 4;
pub const LL_USART_DIRECTION_TX: u32 = 8;
pub const LL_USART_DIRECTION_TX_RX: u32 = 12;
pub const LL_USART_PARITY_NONE: u32 = 0;
pub const LL_USART_PARITY_EVEN: u32 = 1024;
pub const LL_USART_PARITY_ODD: u32 = 1536;
pub const LL_USART_WAKEUP_IDLELINE: u32 = 0;
pub const LL_USART_WAKEUP_ADDRESSMARK: u32 = 2048;
pub const LL_USART_DATAWIDTH_7B: u32 = 268435456;
pub const LL_USART_DATAWIDTH_8B: u32 = 0;
pub const LL_USART_DATAWIDTH_9B: u32 = 4096;
pub const LL_USART_OVERSAMPLING_16: u32 = 0;
pub const LL_USART_OVERSAMPLING_8: u32 = 32768;
pub const LL_USART_CLOCK_DISABLE: u32 = 0;
pub const LL_USART_CLOCK_ENABLE: u32 = 2048;
pub const LL_USART_LASTCLKPULSE_NO_OUTPUT: u32 = 0;
pub const LL_USART_LASTCLKPULSE_OUTPUT: u32 = 256;
pub const LL_USART_PHASE_1EDGE: u32 = 0;
pub const LL_USART_PHASE_2EDGE: u32 = 512;
pub const LL_USART_POLARITY_LOW: u32 = 0;
pub const LL_USART_POLARITY_HIGH: u32 = 1024;
pub const LL_USART_PRESCALER_DIV1: u32 = 0;
pub const LL_USART_PRESCALER_DIV2: u32 = 1;
pub const LL_USART_PRESCALER_DIV4: u32 = 2;
pub const LL_USART_PRESCALER_DIV6: u32 = 3;
pub const LL_USART_PRESCALER_DIV8: u32 = 4;
pub const LL_USART_PRESCALER_DIV10: u32 = 5;
pub const LL_USART_PRESCALER_DIV12: u32 = 6;
pub const LL_USART_PRESCALER_DIV16: u32 = 7;
pub const LL_USART_PRESCALER_DIV32: u32 = 8;
pub const LL_USART_PRESCALER_DIV64: u32 = 9;
pub const LL_USART_PRESCALER_DIV128: u32 = 10;
pub const LL_USART_PRESCALER_DIV256: u32 = 11;
pub const LL_USART_STOPBITS_0_5: u32 = 4096;
pub const LL_USART_STOPBITS_1: u32 = 0;
pub const LL_USART_STOPBITS_1_5: u32 = 12288;
pub const LL_USART_STOPBITS_2: u32 = 8192;
pub const LL_USART_TXRX_STANDARD: u32 = 0;
pub const LL_USART_TXRX_SWAPPED: u32 = 32768;
pub const LL_USART_RXPIN_LEVEL_STANDARD: u32 = 0;
pub const LL_USART_RXPIN_LEVEL_INVERTED: u32 = 65536;
pub const LL_USART_TXPIN_LEVEL_STANDARD: u32 = 0;
pub const LL_USART_TXPIN_LEVEL_INVERTED: u32 = 131072;
pub const LL_USART_BINARY_LOGIC_POSITIVE: u32 = 0;
pub const LL_USART_BINARY_LOGIC_NEGATIVE: u32 = 262144;
pub const LL_USART_BITORDER_LSBFIRST: u32 = 0;
pub const LL_USART_BITORDER_MSBFIRST: u32 = 524288;
pub const LL_USART_AUTOBAUD_DETECT_ON_STARTBIT: u32 = 0;
pub const LL_USART_AUTOBAUD_DETECT_ON_FALLINGEDGE: u32 = 2097152;
pub const LL_USART_AUTOBAUD_DETECT_ON_7F_FRAME: u32 = 4194304;
pub const LL_USART_AUTOBAUD_DETECT_ON_55_FRAME: u32 = 6291456;
pub const LL_USART_ADDRESS_DETECT_4B: u32 = 0;
pub const LL_USART_ADDRESS_DETECT_7B: u32 = 16;
pub const LL_USART_HWCONTROL_NONE: u32 = 0;
pub const LL_USART_HWCONTROL_RTS: u32 = 256;
pub const LL_USART_HWCONTROL_CTS: u32 = 512;
pub const LL_USART_HWCONTROL_RTS_CTS: u32 = 768;
pub const LL_USART_WAKEUP_ON_ADDRESS: u32 = 0;
pub const LL_USART_WAKEUP_ON_STARTBIT: u32 = 2097152;
pub const LL_USART_WAKEUP_ON_RXNE: u32 = 3145728;
pub const LL_USART_IRDA_POWER_NORMAL: u32 = 0;
pub const LL_USART_IRDA_POWER_LOW: u32 = 4;
pub const LL_USART_LINBREAK_DETECT_10B: u32 = 0;
pub const LL_USART_LINBREAK_DETECT_11B: u32 = 32;
pub const LL_USART_DE_POLARITY_HIGH: u32 = 0;
pub const LL_USART_DE_POLARITY_LOW: u32 = 32768;
pub const LL_USART_DMA_REG_DATA_TRANSMIT: u32 = 0;
pub const LL_USART_DMA_REG_DATA_RECEIVE: u32 = 1;
pub const LL_MAX_DELAY: u32 = 4294967295;
pub const LL_UTILS_HSEBYPASS_OFF: u32 = 0;
pub const LL_UTILS_HSEBYPASS_ON: u32 = 1;
pub const LL_UTILS_PACKAGETYPE_CSP100: u32 = 17;
pub const LL_UTILS_PACKAGETYPE_QFN68: u32 = 19;
pub const LL_UTILS_PACKAGETYPE_QFN48: u32 = 10;
pub const LL_WWDG_CFR_EWI: u32 = 512;
pub const LL_WWDG_PRESCALER_1: u32 = 0;
pub const LL_WWDG_PRESCALER_2: u32 = 2048;
pub const LL_WWDG_PRESCALER_4: u32 = 4096;
pub const LL_WWDG_PRESCALER_8: u32 = 6144;
pub const LL_WWDG_PRESCALER_16: u32 = 8192;
pub const LL_WWDG_PRESCALER_32: u32 = 10240;
pub const LL_WWDG_PRESCALER_64: u32 = 12288;
pub const LL_WWDG_PRESCALER_128: u32 = 14336;
pub const EI_NIDENT: u32 = 16;
pub const EI_MAG0: u32 = 0;
pub const ELFMAG0: u32 = 127;
pub const EI_MAG1: u32 = 1;
pub const ELFMAG1: u8 = 69u8;
pub const EI_MAG2: u32 = 2;
pub const ELFMAG2: u8 = 76u8;
pub const EI_MAG3: u32 = 3;
pub const ELFMAG3: u8 = 70u8;
pub const ELFMAG: &[u8; 5usize] = b"\x7FELF\0";
pub const SELFMAG: u32 = 4;
pub const EI_CLASS: u32 = 4;
pub const ELFCLASSNONE: u32 = 0;
pub const ELFCLASS32: u32 = 1;
pub const ELFCLASS64: u32 = 2;
pub const ELFCLASSNUM: u32 = 3;
pub const EI_DATA: u32 = 5;
pub const ELFDATANONE: u32 = 0;
pub const ELFDATA2LSB: u32 = 1;
pub const ELFDATA2MSB: u32 = 2;
pub const ELFDATANUM: u32 = 3;
pub const EI_VERSION: u32 = 6;
pub const EI_OSABI: u32 = 7;
pub const ELFOSABI_NONE: u32 = 0;
pub const ELFOSABI_SYSV: u32 = 0;
pub const ELFOSABI_HPUX: u32 = 1;
pub const ELFOSABI_NETBSD: u32 = 2;
pub const ELFOSABI_LINUX: u32 = 3;
pub const ELFOSABI_GNU: u32 = 3;
pub const ELFOSABI_SOLARIS: u32 = 6;
pub const ELFOSABI_AIX: u32 = 7;
pub const ELFOSABI_IRIX: u32 = 8;
pub const ELFOSABI_FREEBSD: u32 = 9;
pub const ELFOSABI_TRU64: u32 = 10;
pub const ELFOSABI_MODESTO: u32 = 11;
pub const ELFOSABI_OPENBSD: u32 = 12;
pub const ELFOSABI_ARM: u32 = 97;
pub const ELFOSABI_STANDALONE: u32 = 255;
pub const EI_ABIVERSION: u32 = 8;
pub const EI_PAD: u32 = 9;
pub const ET_NONE: u32 = 0;
pub const ET_REL: u32 = 1;
pub const ET_EXEC: u32 = 2;
pub const ET_DYN: u32 = 3;
pub const ET_CORE: u32 = 4;
pub const ET_NUM: u32 = 5;
pub const ET_LOOS: u32 = 65024;
pub const ET_HIOS: u32 = 65279;
pub const ET_LOPROC: u32 = 65280;
pub const ET_HIPROC: u32 = 65535;
pub const EM_NONE: u32 = 0;
pub const EM_M32: u32 = 1;
pub const EM_SPARC: u32 = 2;
pub const EM_386: u32 = 3;
pub const EM_68K: u32 = 4;
pub const EM_88K: u32 = 5;
pub const EM_860: u32 = 7;
pub const EM_MIPS: u32 = 8;
pub const EM_S370: u32 = 9;
pub const EM_MIPS_RS3_LE: u32 = 10;
pub const EM_PARISC: u32 = 15;
pub const EM_VPP500: u32 = 17;
pub const EM_SPARC32PLUS: u32 = 18;
pub const EM_960: u32 = 19;
pub const EM_PPC: u32 = 20;
pub const EM_PPC64: u32 = 21;
pub const EM_S390: u32 = 22;
pub const EM_V800: u32 = 36;
pub const EM_FR20: u32 = 37;
pub const EM_RH32: u32 = 38;
pub const EM_RCE: u32 = 39;
pub const EM_ARM: u32 = 40;
pub const EM_FAKE_ALPHA: u32 = 41;
pub const EM_SH: u32 = 42;
pub const EM_SPARCV9: u32 = 43;
pub const EM_TRICORE: u32 = 44;
pub const EM_ARC: u32 = 45;
pub const EM_H8_300: u32 = 46;
pub const EM_H8_300H: u32 = 47;
pub const EM_H8S: u32 = 48;
pub const EM_H8_500: u32 = 49;
pub const EM_IA_64: u32 = 50;
pub const EM_MIPS_X: u32 = 51;
pub const EM_COLDFIRE: u32 = 52;
pub const EM_68HC12: u32 = 53;
pub const EM_MMA: u32 = 54;
pub const EM_PCP: u32 = 55;
pub const EM_NCPU: u32 = 56;
pub const EM_NDR1: u32 = 57;
pub const EM_STARCORE: u32 = 58;
pub const EM_ME16: u32 = 59;
pub const EM_ST100: u32 = 60;
pub const EM_TINYJ: u32 = 61;
pub const EM_X86_64: u32 = 62;
pub const EM_PDSP: u32 = 63;
pub const EM_FX66: u32 = 66;
pub const EM_ST9PLUS: u32 = 67;
pub const EM_ST7: u32 = 68;
pub const EM_68HC16: u32 = 69;
pub const EM_68HC11: u32 = 70;
pub const EM_68HC08: u32 = 71;
pub const EM_68HC05: u32 = 72;
pub const EM_SVX: u32 = 73;
pub const EM_ST19: u32 = 74;
pub const EM_VAX: u32 = 75;
pub const EM_CRIS: u32 = 76;
pub const EM_JAVELIN: u32 = 77;
pub const EM_FIREPATH: u32 = 78;
pub const EM_ZSP: u32 = 79;
pub const EM_MMIX: u32 = 80;
pub const EM_HUANY: u32 = 81;
pub const EM_PRISM: u32 = 82;
pub const EM_AVR: u32 = 83;
pub const EM_FR30: u32 = 84;
pub const EM_D10V: u32 = 85;
pub const EM_D30V: u32 = 86;
pub const EM_V850: u32 = 87;
pub const EM_M32R: u32 = 88;
pub const EM_MN10300: u32 = 89;
pub const EM_MN10200: u32 = 90;
pub const EM_PJ: u32 = 91;
pub const EM_OR1K: u32 = 92;
pub const EM_OPENRISC: u32 = 92;
pub const EM_ARC_A5: u32 = 93;
pub const EM_ARC_COMPACT: u32 = 93;
pub const EM_XTENSA: u32 = 94;
pub const EM_VIDEOCORE: u32 = 95;
pub const EM_TMM_GPP: u32 = 96;
pub const EM_NS32K: u32 = 97;
pub const EM_TPC: u32 = 98;
pub const EM_SNP1K: u32 = 99;
pub const EM_ST200: u32 = 100;
pub const EM_IP2K: u32 = 101;
pub const EM_MAX: u32 = 102;
pub const EM_CR: u32 = 103;
pub const EM_F2MC16: u32 = 104;
pub const EM_MSP430: u32 = 105;
pub const EM_BLACKFIN: u32 = 106;
pub const EM_SE_C33: u32 = 107;
pub const EM_SEP: u32 = 108;
pub const EM_ARCA: u32 = 109;
pub const EM_UNICORE: u32 = 110;
pub const EM_EXCESS: u32 = 111;
pub const EM_DXP: u32 = 112;
pub const EM_ALTERA_NIOS2: u32 = 113;
pub const EM_CRX: u32 = 114;
pub const EM_XGATE: u32 = 115;
pub const EM_C166: u32 = 116;
pub const EM_M16C: u32 = 117;
pub const EM_DSPIC30F: u32 = 118;
pub const EM_CE: u32 = 119;
pub const EM_M32C: u32 = 120;
pub const EM_TSK3000: u32 = 131;
pub const EM_RS08: u32 = 132;
pub const EM_SHARC: u32 = 133;
pub const EM_ECOG2: u32 = 134;
pub const EM_SCORE7: u32 = 135;
pub const EM_DSP24: u32 = 136;
pub const EM_VIDEOCORE3: u32 = 137;
pub const EM_LATTICEMICO32: u32 = 138;
pub const EM_SE_C17: u32 = 139;
pub const EM_TI_C6000: u32 = 140;
pub const EM_TI_C2000: u32 = 141;
pub const EM_TI_C5500: u32 = 142;
pub const EM_TI_ARP32: u32 = 143;
pub const EM_TI_PRU: u32 = 144;
pub const EM_MMDSP_PLUS: u32 = 160;
pub const EM_CYPRESS_M8C: u32 = 161;
pub const EM_R32C: u32 = 162;
pub const EM_TRIMEDIA: u32 = 163;
pub const EM_QDSP6: u32 = 164;
pub const EM_8051: u32 = 165;
pub const EM_STXP7X: u32 = 166;
pub const EM_NDS32: u32 = 167;
pub const EM_ECOG1X: u32 = 168;
pub const EM_MAXQ30: u32 = 169;
pub const EM_XIMO16: u32 = 170;
pub const EM_MANIK: u32 = 171;
pub const EM_CRAYNV2: u32 = 172;
pub const EM_RX: u32 = 173;
pub const EM_METAG: u32 = 174;
pub const EM_MCST_ELBRUS: u32 = 175;
pub const EM_ECOG16: u32 = 176;
pub const EM_CR16: u32 = 177;
pub const EM_ETPU: u32 = 178;
pub const EM_SLE9X: u32 = 179;
pub const EM_L10M: u32 = 180;
pub const EM_K10M: u32 = 181;
pub const EM_AARCH64: u32 = 183;
pub const EM_AVR32: u32 = 185;
pub const EM_STM8: u32 = 186;
pub const EM_TILE64: u32 = 187;
pub const EM_TILEPRO: u32 = 188;
pub const EM_MICROBLAZE: u32 = 189;
pub const EM_CUDA: u32 = 190;
pub const EM_TILEGX: u32 = 191;
pub const EM_CLOUDSHIELD: u32 = 192;
pub const EM_COREA_1ST: u32 = 193;
pub const EM_COREA_2ND: u32 = 194;
pub const EM_ARC_COMPACT2: u32 = 195;
pub const EM_OPEN8: u32 = 196;
pub const EM_RL78: u32 = 197;
pub const EM_VIDEOCORE5: u32 = 198;
pub const EM_78KOR: u32 = 199;
pub const EM_56800EX: u32 = 200;
pub const EM_BA1: u32 = 201;
pub const EM_BA2: u32 = 202;
pub const EM_XCORE: u32 = 203;
pub const EM_MCHP_PIC: u32 = 204;
pub const EM_KM32: u32 = 210;
pub const EM_KMX32: u32 = 211;
pub const EM_EMX16: u32 = 212;
pub const EM_EMX8: u32 = 213;
pub const EM_KVARC: u32 = 214;
pub const EM_CDP: u32 = 215;
pub const EM_COGE: u32 = 216;
pub const EM_COOL: u32 = 217;
pub const EM_NORC: u32 = 218;
pub const EM_CSR_KALIMBA: u32 = 219;
pub const EM_Z80: u32 = 220;
pub const EM_VISIUM: u32 = 221;
pub const EM_FT32: u32 = 222;
pub const EM_MOXIE: u32 = 223;
pub const EM_AMDGPU: u32 = 224;
pub const EM_RISCV: u32 = 243;
pub const EM_BPF: u32 = 247;
pub const EM_NUM: u32 = 248;
pub const EM_ALPHA: u32 = 36902;
pub const EV_NONE: u32 = 0;
pub const EV_CURRENT: u32 = 1;
pub const EV_NUM: u32 = 2;
pub const SHN_UNDEF: u32 = 0;
pub const SHN_LORESERVE: u32 = 65280;
pub const SHN_LOPROC: u32 = 65280;
pub const SHN_BEFORE: u32 = 65280;
pub const SHN_AFTER: u32 = 65281;
pub const SHN_HIPROC: u32 = 65311;
pub const SHN_LOOS: u32 = 65312;
pub const SHN_HIOS: u32 = 65343;
pub const SHN_ABS: u32 = 65521;
pub const SHN_COMMON: u32 = 65522;
pub const SHN_XINDEX: u32 = 65535;
pub const SHN_HIRESERVE: u32 = 65535;
pub const SHT_NULL: u32 = 0;
pub const SHT_PROGBITS: u32 = 1;
pub const SHT_SYMTAB: u32 = 2;
pub const SHT_STRTAB: u32 = 3;
pub const SHT_RELA: u32 = 4;
pub const SHT_HASH: u32 = 5;
pub const SHT_DYNAMIC: u32 = 6;
pub const SHT_NOTE: u32 = 7;
pub const SHT_NOBITS: u32 = 8;
pub const SHT_REL: u32 = 9;
pub const SHT_SHLIB: u32 = 10;
pub const SHT_DYNSYM: u32 = 11;
pub const SHT_INIT_ARRAY: u32 = 14;
pub const SHT_FINI_ARRAY: u32 = 15;
pub const SHT_PREINIT_ARRAY: u32 = 16;
pub const SHT_GROUP: u32 = 17;
pub const SHT_SYMTAB_SHNDX: u32 = 18;
pub const SHT_NUM: u32 = 19;
pub const SHT_LOOS: u32 = 1610612736;
pub const SHT_GNU_ATTRIBUTES: u32 = 1879048181;
pub const SHT_GNU_HASH: u32 = 1879048182;
pub const SHT_GNU_LIBLIST: u32 = 1879048183;
pub const SHT_CHECKSUM: u32 = 1879048184;
pub const SHT_LOSUNW: u32 = 1879048186;
pub const SHT_SUNW_move: u32 = 1879048186;
pub const SHT_SUNW_COMDAT: u32 = 1879048187;
pub const SHT_SUNW_syminfo: u32 = 1879048188;
pub const SHT_GNU_verdef: u32 = 1879048189;
pub const SHT_GNU_verneed: u32 = 1879048190;
pub const SHT_GNU_versym: u32 = 1879048191;
pub const SHT_HISUNW: u32 = 1879048191;
pub const SHT_HIOS: u32 = 1879048191;
pub const SHT_LOPROC: u32 = 1879048192;
pub const SHT_HIPROC: u32 = 2147483647;
pub const SHT_LOUSER: u32 = 2147483648;
pub const SHT_HIUSER: u32 = 2415919103;
pub const SHF_WRITE: u32 = 1;
pub const SHF_ALLOC: u32 = 2;
pub const SHF_EXECINSTR: u32 = 4;
pub const SHF_MERGE: u32 = 16;
pub const SHF_STRINGS: u32 = 32;
pub const SHF_INFO_LINK: u32 = 64;
pub const SHF_LINK_ORDER: u32 = 128;
pub const SHF_OS_NONCONFORMING: u32 = 256;
pub const SHF_GROUP: u32 = 512;
pub const SHF_TLS: u32 = 1024;
pub const SHF_COMPRESSED: u32 = 2048;
pub const SHF_MASKOS: u32 = 267386880;
pub const SHF_MASKPROC: u32 = 4026531840;
pub const SHF_ORDERED: u32 = 1073741824;
pub const SHF_EXCLUDE: u32 = 2147483648;
pub const ELFCOMPRESS_ZLIB: u32 = 1;
pub const ELFCOMPRESS_LOOS: u32 = 1610612736;
pub const ELFCOMPRESS_HIOS: u32 = 1879048191;
pub const ELFCOMPRESS_LOPROC: u32 = 1879048192;
pub const ELFCOMPRESS_HIPROC: u32 = 2147483647;
pub const GRP_COMDAT: u32 = 1;
pub const SYMINFO_BT_SELF: u32 = 65535;
pub const SYMINFO_BT_PARENT: u32 = 65534;
pub const SYMINFO_BT_LOWRESERVE: u32 = 65280;
pub const SYMINFO_FLG_DIRECT: u32 = 1;
pub const SYMINFO_FLG_PASSTHRU: u32 = 2;
pub const SYMINFO_FLG_COPY: u32 = 4;
pub const SYMINFO_FLG_LAZYLOAD: u32 = 8;
pub const SYMINFO_NONE: u32 = 0;
pub const SYMINFO_CURRENT: u32 = 1;
pub const SYMINFO_NUM: u32 = 2;
pub const STB_LOCAL: u32 = 0;
pub const STB_GLOBAL: u32 = 1;
pub const STB_WEAK: u32 = 2;
pub const STB_NUM: u32 = 3;
pub const STB_LOOS: u32 = 10;
pub const STB_GNU_UNIQUE: u32 = 10;
pub const STB_HIOS: u32 = 12;
pub const STB_LOPROC: u32 = 13;
pub const STB_HIPROC: u32 = 15;
pub const STT_NOTYPE: u32 = 0;
pub const STT_OBJECT: u32 = 1;
pub const STT_FUNC: u32 = 2;
pub const STT_SECTION: u32 = 3;
pub const STT_FILE: u32 = 4;
pub const STT_COMMON: u32 = 5;
pub const STT_TLS: u32 = 6;
pub const STT_NUM: u32 = 7;
pub const STT_LOOS: u32 = 10;
pub const STT_GNU_IFUNC: u32 = 10;
pub const STT_HIOS: u32 = 12;
pub const STT_LOPROC: u32 = 13;
pub const STT_HIPROC: u32 = 15;
pub const STN_UNDEF: u32 = 0;
pub const STV_DEFAULT: u32 = 0;
pub const STV_INTERNAL: u32 = 1;
pub const STV_HIDDEN: u32 = 2;
pub const STV_PROTECTED: u32 = 3;
pub const PT_NULL: u32 = 0;
pub const PT_LOAD: u32 = 1;
pub const PT_DYNAMIC: u32 = 2;
pub const PT_INTERP: u32 = 3;
pub const PT_NOTE: u32 = 4;
pub const PT_SHLIB: u32 = 5;
pub const PT_PHDR: u32 = 6;
pub const PT_TLS: u32 = 7;
pub const PT_NUM: u32 = 8;
pub const PT_LOOS: u32 = 1610612736;
pub const PT_GNU_EH_FRAME: u32 = 1685382480;
pub const PT_GNU_STACK: u32 = 1685382481;
pub const PT_GNU_RELRO: u32 = 1685382482;
pub const PT_LOSUNW: u32 = 1879048186;
pub const PT_SUNWBSS: u32 = 1879048186;
pub const PT_SUNWSTACK: u32 = 1879048187;
pub const PT_HISUNW: u32 = 1879048191;
pub const PT_HIOS: u32 = 1879048191;
pub const PT_LOPROC: u32 = 1879048192;
pub const PT_HIPROC: u32 = 2147483647;
pub const PN_XNUM: u32 = 65535;
pub const PF_X: u32 = 1;
pub const PF_W: u32 = 2;
pub const PF_R: u32 = 4;
pub const PF_MASKOS: u32 = 267386880;
pub const PF_MASKPROC: u32 = 4026531840;
pub const NT_PRSTATUS: u32 = 1;
pub const NT_FPREGSET: u32 = 2;
pub const NT_PRPSINFO: u32 = 3;
pub const NT_PRXREG: u32 = 4;
pub const NT_TASKSTRUCT: u32 = 4;
pub const NT_PLATFORM: u32 = 5;
pub const NT_AUXV: u32 = 6;
pub const NT_GWINDOWS: u32 = 7;
pub const NT_ASRS: u32 = 8;
pub const NT_PSTATUS: u32 = 10;
pub const NT_PSINFO: u32 = 13;
pub const NT_PRCRED: u32 = 14;
pub const NT_UTSNAME: u32 = 15;
pub const NT_LWPSTATUS: u32 = 16;
pub const NT_LWPSINFO: u32 = 17;
pub const NT_PRFPXREG: u32 = 20;
pub const NT_SIGINFO: u32 = 1397311305;
pub const NT_FILE: u32 = 1179208773;
pub const NT_PRXFPREG: u32 = 1189489535;
pub const NT_PPC_VMX: u32 = 256;
pub const NT_PPC_SPE: u32 = 257;
pub const NT_PPC_VSX: u32 = 258;
pub const NT_386_TLS: u32 = 512;
pub const NT_386_IOPERM: u32 = 513;
pub const NT_X86_XSTATE: u32 = 514;
pub const NT_S390_HIGH_GPRS: u32 = 768;
pub const NT_S390_TIMER: u32 = 769;
pub const NT_S390_TODCMP: u32 = 770;
pub const NT_S390_TODPREG: u32 = 771;
pub const NT_S390_CTRS: u32 = 772;
pub const NT_S390_PREFIX: u32 = 773;
pub const NT_S390_LAST_BREAK: u32 = 774;
pub const NT_S390_SYSTEM_CALL: u32 = 775;
pub const NT_S390_TDB: u32 = 776;
pub const NT_ARM_VFP: u32 = 1024;
pub const NT_ARM_TLS: u32 = 1025;
pub const NT_ARM_HW_BREAK: u32 = 1026;
pub const NT_ARM_HW_WATCH: u32 = 1027;
pub const NT_ARM_SYSTEM_CALL: u32 = 1028;
pub const NT_ARM_SVE: u32 = 1029;
pub const NT_METAG_CBUF: u32 = 1280;
pub const NT_METAG_RPIPE: u32 = 1281;
pub const NT_METAG_TLS: u32 = 1282;
pub const NT_VERSION: u32 = 1;
pub const DT_NULL: u32 = 0;
pub const DT_NEEDED: u32 = 1;
pub const DT_PLTRELSZ: u32 = 2;
pub const DT_PLTGOT: u32 = 3;
pub const DT_HASH: u32 = 4;
pub const DT_STRTAB: u32 = 5;
pub const DT_SYMTAB: u32 = 6;
pub const DT_RELA: u32 = 7;
pub const DT_RELASZ: u32 = 8;
pub const DT_RELAENT: u32 = 9;
pub const DT_STRSZ: u32 = 10;
pub const DT_SYMENT: u32 = 11;
pub const DT_INIT: u32 = 12;
pub const DT_FINI: u32 = 13;
pub const DT_SONAME: u32 = 14;
pub const DT_RPATH: u32 = 15;
pub const DT_SYMBOLIC: u32 = 16;
pub const DT_REL: u32 = 17;
pub const DT_RELSZ: u32 = 18;
pub const DT_RELENT: u32 = 19;
pub const DT_PLTREL: u32 = 20;
pub const DT_DEBUG: u32 = 21;
pub const DT_TEXTREL: u32 = 22;
pub const DT_JMPREL: u32 = 23;
pub const DT_BIND_NOW: u32 = 24;
pub const DT_INIT_ARRAY: u32 = 25;
pub const DT_FINI_ARRAY: u32 = 26;
pub const DT_INIT_ARRAYSZ: u32 = 27;
pub const DT_FINI_ARRAYSZ: u32 = 28;
pub const DT_RUNPATH: u32 = 29;
pub const DT_FLAGS: u32 = 30;
pub const DT_ENCODING: u32 = 32;
pub const DT_PREINIT_ARRAY: u32 = 32;
pub const DT_PREINIT_ARRAYSZ: u32 = 33;
pub const DT_NUM: u32 = 34;
pub const DT_LOOS: u32 = 1610612749;
pub const DT_HIOS: u32 = 1879044096;
pub const DT_LOPROC: u32 = 1879048192;
pub const DT_HIPROC: u32 = 2147483647;
pub const DT_VALRNGLO: u32 = 1879047424;
pub const DT_GNU_PRELINKED: u32 = 1879047669;
pub const DT_GNU_CONFLICTSZ: u32 = 1879047670;
pub const DT_GNU_LIBLISTSZ: u32 = 1879047671;
pub const DT_CHECKSUM: u32 = 1879047672;
pub const DT_PLTPADSZ: u32 = 1879047673;
pub const DT_MOVEENT: u32 = 1879047674;
pub const DT_MOVESZ: u32 = 1879047675;
pub const DT_FEATURE_1: u32 = 1879047676;
pub const DT_POSFLAG_1: u32 = 1879047677;
pub const DT_SYMINSZ: u32 = 1879047678;
pub const DT_SYMINENT: u32 = 1879047679;
pub const DT_VALRNGHI: u32 = 1879047679;
pub const DT_VALNUM: u32 = 12;
pub const DT_ADDRRNGLO: u32 = 1879047680;
pub const DT_GNU_HASH: u32 = 1879047925;
pub const DT_TLSDESC_PLT: u32 = 1879047926;
pub const DT_TLSDESC_GOT: u32 = 1879047927;
pub const DT_GNU_CONFLICT: u32 = 1879047928;
pub const DT_GNU_LIBLIST: u32 = 1879047929;
pub const DT_CONFIG: u32 = 1879047930;
pub const DT_DEPAUDIT: u32 = 1879047931;
pub const DT_AUDIT: u32 = 1879047932;
pub const DT_PLTPAD: u32 = 1879047933;
pub const DT_MOVETAB: u32 = 1879047934;
pub const DT_SYMINFO: u32 = 1879047935;
pub const DT_ADDRRNGHI: u32 = 1879047935;
pub const DT_ADDRNUM: u32 = 11;
pub const DT_VERSYM: u32 = 1879048176;
pub const DT_RELACOUNT: u32 = 1879048185;
pub const DT_RELCOUNT: u32 = 1879048186;
pub const DT_FLAGS_1: u32 = 1879048187;
pub const DT_VERDEF: u32 = 1879048188;
pub const DT_VERDEFNUM: u32 = 1879048189;
pub const DT_VERNEED: u32 = 1879048190;
pub const DT_VERNEEDNUM: u32 = 1879048191;
pub const DT_VERSIONTAGNUM: u32 = 16;
pub const DT_AUXILIARY: u32 = 2147483645;
pub const DT_FILTER: u32 = 2147483647;
pub const DT_EXTRANUM: u32 = 3;
pub const DF_ORIGIN: u32 = 1;
pub const DF_SYMBOLIC: u32 = 2;
pub const DF_TEXTREL: u32 = 4;
pub const DF_BIND_NOW: u32 = 8;
pub const DF_STATIC_TLS: u32 = 16;
pub const DF_1_NOW: u32 = 1;
pub const DF_1_GLOBAL: u32 = 2;
pub const DF_1_GROUP: u32 = 4;
pub const DF_1_NODELETE: u32 = 8;
pub const DF_1_LOADFLTR: u32 = 16;
pub const DF_1_INITFIRST: u32 = 32;
pub const DF_1_NOOPEN: u32 = 64;
pub const DF_1_ORIGIN: u32 = 128;
pub const DF_1_DIRECT: u32 = 256;
pub const DF_1_TRANS: u32 = 512;
pub const DF_1_INTERPOSE: u32 = 1024;
pub const DF_1_NODEFLIB: u32 = 2048;
pub const DF_1_NODUMP: u32 = 4096;
pub const DF_1_CONFALT: u32 = 8192;
pub const DF_1_ENDFILTEE: u32 = 16384;
pub const DF_1_DISPRELDNE: u32 = 32768;
pub const DF_1_DISPRELPND: u32 = 65536;
pub const DF_1_NODIRECT: u32 = 131072;
pub const DF_1_IGNMULDEF: u32 = 262144;
pub const DF_1_NOKSYMS: u32 = 524288;
pub const DF_1_NOHDR: u32 = 1048576;
pub const DF_1_EDITED: u32 = 2097152;
pub const DF_1_NORELOC: u32 = 4194304;
pub const DF_1_SYMINTPOSE: u32 = 8388608;
pub const DF_1_GLOBAUDIT: u32 = 16777216;
pub const DF_1_SINGLETON: u32 = 33554432;
pub const DTF_1_PARINIT: u32 = 1;
pub const DTF_1_CONFEXP: u32 = 2;
pub const DF_P1_LAZYLOAD: u32 = 1;
pub const DF_P1_GROUPPERM: u32 = 2;
pub const VER_DEF_NONE: u32 = 0;
pub const VER_DEF_CURRENT: u32 = 1;
pub const VER_DEF_NUM: u32 = 2;
pub const VER_FLG_BASE: u32 = 1;
pub const VER_FLG_WEAK: u32 = 2;
pub const VER_NDX_LOCAL: u32 = 0;
pub const VER_NDX_GLOBAL: u32 = 1;
pub const VER_NDX_LORESERVE: u32 = 65280;
pub const VER_NDX_ELIMINATE: u32 = 65281;
pub const VER_NEED_NONE: u32 = 0;
pub const VER_NEED_CURRENT: u32 = 1;
pub const VER_NEED_NUM: u32 = 2;
pub const AT_NULL: u32 = 0;
pub const AT_IGNORE: u32 = 1;
pub const AT_EXECFD: u32 = 2;
pub const AT_PHDR: u32 = 3;
pub const AT_PHENT: u32 = 4;
pub const AT_PHNUM: u32 = 5;
pub const AT_PAGESZ: u32 = 6;
pub const AT_BASE: u32 = 7;
pub const AT_FLAGS: u32 = 8;
pub const AT_ENTRY: u32 = 9;
pub const AT_NOTELF: u32 = 10;
pub const AT_UID: u32 = 11;
pub const AT_EUID: u32 = 12;
pub const AT_GID: u32 = 13;
pub const AT_EGID: u32 = 14;
pub const AT_CLKTCK: u32 = 17;
pub const AT_PLATFORM: u32 = 15;
pub const AT_HWCAP: u32 = 16;
pub const AT_FPUCW: u32 = 18;
pub const AT_DCACHEBSIZE: u32 = 19;
pub const AT_ICACHEBSIZE: u32 = 20;
pub const AT_UCACHEBSIZE: u32 = 21;
pub const AT_IGNOREPPC: u32 = 22;
pub const AT_SECURE: u32 = 23;
pub const AT_BASE_PLATFORM: u32 = 24;
pub const AT_RANDOM: u32 = 25;
pub const AT_HWCAP2: u32 = 26;
pub const AT_EXECFN: u32 = 31;
pub const AT_SYSINFO: u32 = 32;
pub const AT_SYSINFO_EHDR: u32 = 33;
pub const AT_L1I_CACHESHAPE: u32 = 34;
pub const AT_L1D_CACHESHAPE: u32 = 35;
pub const AT_L2_CACHESHAPE: u32 = 36;
pub const AT_L3_CACHESHAPE: u32 = 37;
pub const ELF_NOTE_SOLARIS: &[u8; 13usize] = b"SUNW Solaris\0";
pub const ELF_NOTE_GNU: &[u8; 4usize] = b"GNU\0";
pub const ELF_NOTE_PAGESIZE_HINT: u32 = 1;
pub const NT_GNU_ABI_TAG: u32 = 1;
pub const ELF_NOTE_ABI: u32 = 1;
pub const ELF_NOTE_OS_LINUX: u32 = 0;
pub const ELF_NOTE_OS_GNU: u32 = 1;
pub const ELF_NOTE_OS_SOLARIS2: u32 = 2;
pub const ELF_NOTE_OS_FREEBSD: u32 = 3;
pub const NT_GNU_BUILD_ID: u32 = 3;
pub const NT_GNU_GOLD_VERSION: u32 = 4;
pub const EF_CPU32: u32 = 8454144;
pub const R_68K_NONE: u32 = 0;
pub const R_68K_32: u32 = 1;
pub const R_68K_16: u32 = 2;
pub const R_68K_8: u32 = 3;
pub const R_68K_PC32: u32 = 4;
pub const R_68K_PC16: u32 = 5;
pub const R_68K_PC8: u32 = 6;
pub const R_68K_GOT32: u32 = 7;
pub const R_68K_GOT16: u32 = 8;
pub const R_68K_GOT8: u32 = 9;
pub const R_68K_GOT32O: u32 = 10;
pub const R_68K_GOT16O: u32 = 11;
pub const R_68K_GOT8O: u32 = 12;
pub const R_68K_PLT32: u32 = 13;
pub const R_68K_PLT16: u32 = 14;
pub const R_68K_PLT8: u32 = 15;
pub const R_68K_PLT32O: u32 = 16;
pub const R_68K_PLT16O: u32 = 17;
pub const R_68K_PLT8O: u32 = 18;
pub const R_68K_COPY: u32 = 19;
pub const R_68K_GLOB_DAT: u32 = 20;
pub const R_68K_JMP_SLOT: u32 = 21;
pub const R_68K_RELATIVE: u32 = 22;
pub const R_68K_NUM: u32 = 23;
pub const R_386_NONE: u32 = 0;
pub const R_386_32: u32 = 1;
pub const R_386_PC32: u32 = 2;
pub const R_386_GOT32: u32 = 3;
pub const R_386_PLT32: u32 = 4;
pub const R_386_COPY: u32 = 5;
pub const R_386_GLOB_DAT: u32 = 6;
pub const R_386_JMP_SLOT: u32 = 7;
pub const R_386_RELATIVE: u32 = 8;
pub const R_386_GOTOFF: u32 = 9;
pub const R_386_GOTPC: u32 = 10;
pub const R_386_32PLT: u32 = 11;
pub const R_386_TLS_TPOFF: u32 = 14;
pub const R_386_TLS_IE: u32 = 15;
pub const R_386_TLS_GOTIE: u32 = 16;
pub const R_386_TLS_LE: u32 = 17;
pub const R_386_TLS_GD: u32 = 18;
pub const R_386_TLS_LDM: u32 = 19;
pub const R_386_16: u32 = 20;
pub const R_386_PC16: u32 = 21;
pub const R_386_8: u32 = 22;
pub const R_386_PC8: u32 = 23;
pub const R_386_TLS_GD_32: u32 = 24;
pub const R_386_TLS_GD_PUSH: u32 = 25;
pub const R_386_TLS_GD_CALL: u32 = 26;
pub const R_386_TLS_GD_POP: u32 = 27;
pub const R_386_TLS_LDM_32: u32 = 28;
pub const R_386_TLS_LDM_PUSH: u32 = 29;
pub const R_386_TLS_LDM_CALL: u32 = 30;
pub const R_386_TLS_LDM_POP: u32 = 31;
pub const R_386_TLS_LDO_32: u32 = 32;
pub const R_386_TLS_IE_32: u32 = 33;
pub const R_386_TLS_LE_32: u32 = 34;
pub const R_386_TLS_DTPMOD32: u32 = 35;
pub const R_386_TLS_DTPOFF32: u32 = 36;
pub const R_386_TLS_TPOFF32: u32 = 37;
pub const R_386_SIZE32: u32 = 38;
pub const R_386_TLS_GOTDESC: u32 = 39;
pub const R_386_TLS_DESC_CALL: u32 = 40;
pub const R_386_TLS_DESC: u32 = 41;
pub const R_386_IRELATIVE: u32 = 42;
pub const R_386_GOT32X: u32 = 43;
pub const R_386_NUM: u32 = 44;
pub const STT_SPARC_REGISTER: u32 = 13;
pub const EF_SPARCV9_MM: u32 = 3;
pub const EF_SPARCV9_TSO: u32 = 0;
pub const EF_SPARCV9_PSO: u32 = 1;
pub const EF_SPARCV9_RMO: u32 = 2;
pub const EF_SPARC_LEDATA: u32 = 8388608;
pub const EF_SPARC_EXT_MASK: u32 = 16776960;
pub const EF_SPARC_32PLUS: u32 = 256;
pub const EF_SPARC_SUN_US1: u32 = 512;
pub const EF_SPARC_HAL_R1: u32 = 1024;
pub const EF_SPARC_SUN_US3: u32 = 2048;
pub const R_SPARC_NONE: u32 = 0;
pub const R_SPARC_8: u32 = 1;
pub const R_SPARC_16: u32 = 2;
pub const R_SPARC_32: u32 = 3;
pub const R_SPARC_DISP8: u32 = 4;
pub const R_SPARC_DISP16: u32 = 5;
pub const R_SPARC_DISP32: u32 = 6;
pub const R_SPARC_WDISP30: u32 = 7;
pub const R_SPARC_WDISP22: u32 = 8;
pub const R_SPARC_HI22: u32 = 9;
pub const R_SPARC_22: u32 = 10;
pub const R_SPARC_13: u32 = 11;
pub const R_SPARC_LO10: u32 = 12;
pub const R_SPARC_GOT10: u32 = 13;
pub const R_SPARC_GOT13: u32 = 14;
pub const R_SPARC_GOT22: u32 = 15;
pub const R_SPARC_PC10: u32 = 16;
pub const R_SPARC_PC22: u32 = 17;
pub const R_SPARC_WPLT30: u32 = 18;
pub const R_SPARC_COPY: u32 = 19;
pub const R_SPARC_GLOB_DAT: u32 = 20;
pub const R_SPARC_JMP_SLOT: u32 = 21;
pub const R_SPARC_RELATIVE: u32 = 22;
pub const R_SPARC_UA32: u32 = 23;
pub const R_SPARC_PLT32: u32 = 24;
pub const R_SPARC_HIPLT22: u32 = 25;
pub const R_SPARC_LOPLT10: u32 = 26;
pub const R_SPARC_PCPLT32: u32 = 27;
pub const R_SPARC_PCPLT22: u32 = 28;
pub const R_SPARC_PCPLT10: u32 = 29;
pub const R_SPARC_10: u32 = 30;
pub const R_SPARC_11: u32 = 31;
pub const R_SPARC_64: u32 = 32;
pub const R_SPARC_OLO10: u32 = 33;
pub const R_SPARC_HH22: u32 = 34;
pub const R_SPARC_HM10: u32 = 35;
pub const R_SPARC_LM22: u32 = 36;
pub const R_SPARC_PC_HH22: u32 = 37;
pub const R_SPARC_PC_HM10: u32 = 38;
pub const R_SPARC_PC_LM22: u32 = 39;
pub const R_SPARC_WDISP16: u32 = 40;
pub const R_SPARC_WDISP19: u32 = 41;
pub const R_SPARC_GLOB_JMP: u32 = 42;
pub const R_SPARC_7: u32 = 43;
pub const R_SPARC_5: u32 = 44;
pub const R_SPARC_6: u32 = 45;
pub const R_SPARC_DISP64: u32 = 46;
pub const R_SPARC_PLT64: u32 = 47;
pub const R_SPARC_HIX22: u32 = 48;
pub const R_SPARC_LOX10: u32 = 49;
pub const R_SPARC_H44: u32 = 50;
pub const R_SPARC_M44: u32 = 51;
pub const R_SPARC_L44: u32 = 52;
pub const R_SPARC_REGISTER: u32 = 53;
pub const R_SPARC_UA64: u32 = 54;
pub const R_SPARC_UA16: u32 = 55;
pub const R_SPARC_TLS_GD_HI22: u32 = 56;
pub const R_SPARC_TLS_GD_LO10: u32 = 57;
pub const R_SPARC_TLS_GD_ADD: u32 = 58;
pub const R_SPARC_TLS_GD_CALL: u32 = 59;
pub const R_SPARC_TLS_LDM_HI22: u32 = 60;
pub const R_SPARC_TLS_LDM_LO10: u32 = 61;
pub const R_SPARC_TLS_LDM_ADD: u32 = 62;
pub const R_SPARC_TLS_LDM_CALL: u32 = 63;
pub const R_SPARC_TLS_LDO_HIX22: u32 = 64;
pub const R_SPARC_TLS_LDO_LOX10: u32 = 65;
pub const R_SPARC_TLS_LDO_ADD: u32 = 66;
pub const R_SPARC_TLS_IE_HI22: u32 = 67;
pub const R_SPARC_TLS_IE_LO10: u32 = 68;
pub const R_SPARC_TLS_IE_LD: u32 = 69;
pub const R_SPARC_TLS_IE_LDX: u32 = 70;
pub const R_SPARC_TLS_IE_ADD: u32 = 71;
pub const R_SPARC_TLS_LE_HIX22: u32 = 72;
pub const R_SPARC_TLS_LE_LOX10: u32 = 73;
pub const R_SPARC_TLS_DTPMOD32: u32 = 74;
pub const R_SPARC_TLS_DTPMOD64: u32 = 75;
pub const R_SPARC_TLS_DTPOFF32: u32 = 76;
pub const R_SPARC_TLS_DTPOFF64: u32 = 77;
pub const R_SPARC_TLS_TPOFF32: u32 = 78;
pub const R_SPARC_TLS_TPOFF64: u32 = 79;
pub const R_SPARC_GOTDATA_HIX22: u32 = 80;
pub const R_SPARC_GOTDATA_LOX10: u32 = 81;
pub const R_SPARC_GOTDATA_OP_HIX22: u32 = 82;
pub const R_SPARC_GOTDATA_OP_LOX10: u32 = 83;
pub const R_SPARC_GOTDATA_OP: u32 = 84;
pub const R_SPARC_H34: u32 = 85;
pub const R_SPARC_SIZE32: u32 = 86;
pub const R_SPARC_SIZE64: u32 = 87;
pub const R_SPARC_GNU_VTINHERIT: u32 = 250;
pub const R_SPARC_GNU_VTENTRY: u32 = 251;
pub const R_SPARC_REV32: u32 = 252;
pub const R_SPARC_NUM: u32 = 253;
pub const DT_SPARC_REGISTER: u32 = 1879048193;
pub const DT_SPARC_NUM: u32 = 2;
pub const EF_MIPS_NOREORDER: u32 = 1;
pub const EF_MIPS_PIC: u32 = 2;
pub const EF_MIPS_CPIC: u32 = 4;
pub const EF_MIPS_XGOT: u32 = 8;
pub const EF_MIPS_64BIT_WHIRL: u32 = 16;
pub const EF_MIPS_ABI2: u32 = 32;
pub const EF_MIPS_ABI_ON32: u32 = 64;
pub const EF_MIPS_FP64: u32 = 512;
pub const EF_MIPS_NAN2008: u32 = 1024;
pub const EF_MIPS_ARCH: u32 = 4026531840;
pub const EF_MIPS_ARCH_1: u32 = 0;
pub const EF_MIPS_ARCH_2: u32 = 268435456;
pub const EF_MIPS_ARCH_3: u32 = 536870912;
pub const EF_MIPS_ARCH_4: u32 = 805306368;
pub const EF_MIPS_ARCH_5: u32 = 1073741824;
pub const EF_MIPS_ARCH_32: u32 = 1342177280;
pub const EF_MIPS_ARCH_64: u32 = 1610612736;
pub const EF_MIPS_ARCH_32R2: u32 = 1879048192;
pub const EF_MIPS_ARCH_64R2: u32 = 2147483648;
pub const E_MIPS_ARCH_1: u32 = 0;
pub const E_MIPS_ARCH_2: u32 = 268435456;
pub const E_MIPS_ARCH_3: u32 = 536870912;
pub const E_MIPS_ARCH_4: u32 = 805306368;
pub const E_MIPS_ARCH_5: u32 = 1073741824;
pub const E_MIPS_ARCH_32: u32 = 1342177280;
pub const E_MIPS_ARCH_64: u32 = 1610612736;
pub const SHN_MIPS_ACOMMON: u32 = 65280;
pub const SHN_MIPS_TEXT: u32 = 65281;
pub const SHN_MIPS_DATA: u32 = 65282;
pub const SHN_MIPS_SCOMMON: u32 = 65283;
pub const SHN_MIPS_SUNDEFINED: u32 = 65284;
pub const SHT_MIPS_LIBLIST: u32 = 1879048192;
pub const SHT_MIPS_MSYM: u32 = 1879048193;
pub const SHT_MIPS_CONFLICT: u32 = 1879048194;
pub const SHT_MIPS_GPTAB: u32 = 1879048195;
pub const SHT_MIPS_UCODE: u32 = 1879048196;
pub const SHT_MIPS_DEBUG: u32 = 1879048197;
pub const SHT_MIPS_REGINFO: u32 = 1879048198;
pub const SHT_MIPS_PACKAGE: u32 = 1879048199;
pub const SHT_MIPS_PACKSYM: u32 = 1879048200;
pub const SHT_MIPS_RELD: u32 = 1879048201;
pub const SHT_MIPS_IFACE: u32 = 1879048203;
pub const SHT_MIPS_CONTENT: u32 = 1879048204;
pub const SHT_MIPS_OPTIONS: u32 = 1879048205;
pub const SHT_MIPS_SHDR: u32 = 1879048208;
pub const SHT_MIPS_FDESC: u32 = 1879048209;
pub const SHT_MIPS_EXTSYM: u32 = 1879048210;
pub const SHT_MIPS_DENSE: u32 = 1879048211;
pub const SHT_MIPS_PDESC: u32 = 1879048212;
pub const SHT_MIPS_LOCSYM: u32 = 1879048213;
pub const SHT_MIPS_AUXSYM: u32 = 1879048214;
pub const SHT_MIPS_OPTSYM: u32 = 1879048215;
pub const SHT_MIPS_LOCSTR: u32 = 1879048216;
pub const SHT_MIPS_LINE: u32 = 1879048217;
pub const SHT_MIPS_RFDESC: u32 = 1879048218;
pub const SHT_MIPS_DELTASYM: u32 = 1879048219;
pub const SHT_MIPS_DELTAINST: u32 = 1879048220;
pub const SHT_MIPS_DELTACLASS: u32 = 1879048221;
pub const SHT_MIPS_DWARF: u32 = 1879048222;
pub const SHT_MIPS_DELTADECL: u32 = 1879048223;
pub const SHT_MIPS_SYMBOL_LIB: u32 = 1879048224;
pub const SHT_MIPS_EVENTS: u32 = 1879048225;
pub const SHT_MIPS_TRANSLATE: u32 = 1879048226;
pub const SHT_MIPS_PIXIE: u32 = 1879048227;
pub const SHT_MIPS_XLATE: u32 = 1879048228;
pub const SHT_MIPS_XLATE_DEBUG: u32 = 1879048229;
pub const SHT_MIPS_WHIRL: u32 = 1879048230;
pub const SHT_MIPS_EH_REGION: u32 = 1879048231;
pub const SHT_MIPS_XLATE_OLD: u32 = 1879048232;
pub const SHT_MIPS_PDR_EXCEPTION: u32 = 1879048233;
pub const SHF_MIPS_GPREL: u32 = 268435456;
pub const SHF_MIPS_MERGE: u32 = 536870912;
pub const SHF_MIPS_ADDR: u32 = 1073741824;
pub const SHF_MIPS_STRINGS: u32 = 2147483648;
pub const SHF_MIPS_NOSTRIP: u32 = 134217728;
pub const SHF_MIPS_LOCAL: u32 = 67108864;
pub const SHF_MIPS_NAMES: u32 = 33554432;
pub const SHF_MIPS_NODUPE: u32 = 16777216;
pub const STO_MIPS_DEFAULT: u32 = 0;
pub const STO_MIPS_INTERNAL: u32 = 1;
pub const STO_MIPS_HIDDEN: u32 = 2;
pub const STO_MIPS_PROTECTED: u32 = 3;
pub const STO_MIPS_PLT: u32 = 8;
pub const STO_MIPS_SC_ALIGN_UNUSED: u32 = 255;
pub const STB_MIPS_SPLIT_COMMON: u32 = 13;
pub const ODK_NULL: u32 = 0;
pub const ODK_REGINFO: u32 = 1;
pub const ODK_EXCEPTIONS: u32 = 2;
pub const ODK_PAD: u32 = 3;
pub const ODK_HWPATCH: u32 = 4;
pub const ODK_FILL: u32 = 5;
pub const ODK_TAGS: u32 = 6;
pub const ODK_HWAND: u32 = 7;
pub const ODK_HWOR: u32 = 8;
pub const OEX_FPU_MIN: u32 = 31;
pub const OEX_FPU_MAX: u32 = 7936;
pub const OEX_PAGE0: u32 = 65536;
pub const OEX_SMM: u32 = 131072;
pub const OEX_FPDBUG: u32 = 262144;
pub const OEX_PRECISEFP: u32 = 262144;
pub const OEX_DISMISS: u32 = 524288;
pub const OEX_FPU_INVAL: u32 = 16;
pub const OEX_FPU_DIV0: u32 = 8;
pub const OEX_FPU_OFLO: u32 = 4;
pub const OEX_FPU_UFLO: u32 = 2;
pub const OEX_FPU_INEX: u32 = 1;
pub const OHW_R4KEOP: u32 = 1;
pub const OHW_R8KPFETCH: u32 = 2;
pub const OHW_R5KEOP: u32 = 4;
pub const OHW_R5KCVTL: u32 = 8;
pub const OPAD_PREFIX: u32 = 1;
pub const OPAD_POSTFIX: u32 = 2;
pub const OPAD_SYMBOL: u32 = 4;
pub const OHWA0_R4KEOP_CHECKED: u32 = 1;
pub const OHWA1_R4KEOP_CLEAN: u32 = 2;
pub const R_MIPS_NONE: u32 = 0;
pub const R_MIPS_16: u32 = 1;
pub const R_MIPS_32: u32 = 2;
pub const R_MIPS_REL32: u32 = 3;
pub const R_MIPS_26: u32 = 4;
pub const R_MIPS_HI16: u32 = 5;
pub const R_MIPS_LO16: u32 = 6;
pub const R_MIPS_GPREL16: u32 = 7;
pub const R_MIPS_LITERAL: u32 = 8;
pub const R_MIPS_GOT16: u32 = 9;
pub const R_MIPS_PC16: u32 = 10;
pub const R_MIPS_CALL16: u32 = 11;
pub const R_MIPS_GPREL32: u32 = 12;
pub const R_MIPS_SHIFT5: u32 = 16;
pub const R_MIPS_SHIFT6: u32 = 17;
pub const R_MIPS_64: u32 = 18;
pub const R_MIPS_GOT_DISP: u32 = 19;
pub const R_MIPS_GOT_PAGE: u32 = 20;
pub const R_MIPS_GOT_OFST: u32 = 21;
pub const R_MIPS_GOT_HI16: u32 = 22;
pub const R_MIPS_GOT_LO16: u32 = 23;
pub const R_MIPS_SUB: u32 = 24;
pub const R_MIPS_INSERT_A: u32 = 25;
pub const R_MIPS_INSERT_B: u32 = 26;
pub const R_MIPS_DELETE: u32 = 27;
pub const R_MIPS_HIGHER: u32 = 28;
pub const R_MIPS_HIGHEST: u32 = 29;
pub const R_MIPS_CALL_HI16: u32 = 30;
pub const R_MIPS_CALL_LO16: u32 = 31;
pub const R_MIPS_SCN_DISP: u32 = 32;
pub const R_MIPS_REL16: u32 = 33;
pub const R_MIPS_ADD_IMMEDIATE: u32 = 34;
pub const R_MIPS_PJUMP: u32 = 35;
pub const R_MIPS_RELGOT: u32 = 36;
pub const R_MIPS_JALR: u32 = 37;
pub const R_MIPS_TLS_DTPMOD32: u32 = 38;
pub const R_MIPS_TLS_DTPREL32: u32 = 39;
pub const R_MIPS_TLS_DTPMOD64: u32 = 40;
pub const R_MIPS_TLS_DTPREL64: u32 = 41;
pub const R_MIPS_TLS_GD: u32 = 42;
pub const R_MIPS_TLS_LDM: u32 = 43;
pub const R_MIPS_TLS_DTPREL_HI16: u32 = 44;
pub const R_MIPS_TLS_DTPREL_LO16: u32 = 45;
pub const R_MIPS_TLS_GOTTPREL: u32 = 46;
pub const R_MIPS_TLS_TPREL32: u32 = 47;
pub const R_MIPS_TLS_TPREL64: u32 = 48;
pub const R_MIPS_TLS_TPREL_HI16: u32 = 49;
pub const R_MIPS_TLS_TPREL_LO16: u32 = 50;
pub const R_MIPS_GLOB_DAT: u32 = 51;
pub const R_MIPS_COPY: u32 = 126;
pub const R_MIPS_JUMP_SLOT: u32 = 127;
pub const R_MIPS_NUM: u32 = 128;
pub const PT_MIPS_REGINFO: u32 = 1879048192;
pub const PT_MIPS_RTPROC: u32 = 1879048193;
pub const PT_MIPS_OPTIONS: u32 = 1879048194;
pub const PT_MIPS_ABIFLAGS: u32 = 1879048195;
pub const PF_MIPS_LOCAL: u32 = 268435456;
pub const DT_MIPS_RLD_VERSION: u32 = 1879048193;
pub const DT_MIPS_TIME_STAMP: u32 = 1879048194;
pub const DT_MIPS_ICHECKSUM: u32 = 1879048195;
pub const DT_MIPS_IVERSION: u32 = 1879048196;
pub const DT_MIPS_FLAGS: u32 = 1879048197;
pub const DT_MIPS_BASE_ADDRESS: u32 = 1879048198;
pub const DT_MIPS_MSYM: u32 = 1879048199;
pub const DT_MIPS_CONFLICT: u32 = 1879048200;
pub const DT_MIPS_LIBLIST: u32 = 1879048201;
pub const DT_MIPS_LOCAL_GOTNO: u32 = 1879048202;
pub const DT_MIPS_CONFLICTNO: u32 = 1879048203;
pub const DT_MIPS_LIBLISTNO: u32 = 1879048208;
pub const DT_MIPS_SYMTABNO: u32 = 1879048209;
pub const DT_MIPS_UNREFEXTNO: u32 = 1879048210;
pub const DT_MIPS_GOTSYM: u32 = 1879048211;
pub const DT_MIPS_HIPAGENO: u32 = 1879048212;
pub const DT_MIPS_RLD_MAP: u32 = 1879048214;
pub const DT_MIPS_DELTA_CLASS: u32 = 1879048215;
pub const DT_MIPS_DELTA_CLASS_NO: u32 = 1879048216;
pub const DT_MIPS_DELTA_INSTANCE: u32 = 1879048217;
pub const DT_MIPS_DELTA_INSTANCE_NO: u32 = 1879048218;
pub const DT_MIPS_DELTA_RELOC: u32 = 1879048219;
pub const DT_MIPS_DELTA_RELOC_NO: u32 = 1879048220;
pub const DT_MIPS_DELTA_SYM: u32 = 1879048221;
pub const DT_MIPS_DELTA_SYM_NO: u32 = 1879048222;
pub const DT_MIPS_DELTA_CLASSSYM: u32 = 1879048224;
pub const DT_MIPS_DELTA_CLASSSYM_NO: u32 = 1879048225;
pub const DT_MIPS_CXX_FLAGS: u32 = 1879048226;
pub const DT_MIPS_PIXIE_INIT: u32 = 1879048227;
pub const DT_MIPS_SYMBOL_LIB: u32 = 1879048228;
pub const DT_MIPS_LOCALPAGE_GOTIDX: u32 = 1879048229;
pub const DT_MIPS_LOCAL_GOTIDX: u32 = 1879048230;
pub const DT_MIPS_HIDDEN_GOTIDX: u32 = 1879048231;
pub const DT_MIPS_PROTECTED_GOTIDX: u32 = 1879048232;
pub const DT_MIPS_OPTIONS: u32 = 1879048233;
pub const DT_MIPS_INTERFACE: u32 = 1879048234;
pub const DT_MIPS_DYNSTR_ALIGN: u32 = 1879048235;
pub const DT_MIPS_INTERFACE_SIZE: u32 = 1879048236;
pub const DT_MIPS_RLD_TEXT_RESOLVE_ADDR: u32 = 1879048237;
pub const DT_MIPS_PERF_SUFFIX: u32 = 1879048238;
pub const DT_MIPS_COMPACT_SIZE: u32 = 1879048239;
pub const DT_MIPS_GP_VALUE: u32 = 1879048240;
pub const DT_MIPS_AUX_DYNAMIC: u32 = 1879048241;
pub const DT_MIPS_PLTGOT: u32 = 1879048242;
pub const DT_MIPS_RWPLT: u32 = 1879048244;
pub const DT_MIPS_RLD_MAP_REL: u32 = 1879048245;
pub const DT_MIPS_NUM: u32 = 54;
pub const RHF_NONE: u32 = 0;
pub const RHF_QUICKSTART: u32 = 1;
pub const RHF_NOTPOT: u32 = 2;
pub const RHF_NO_LIBRARY_REPLACEMENT: u32 = 4;
pub const RHF_NO_MOVE: u32 = 8;
pub const RHF_SGI_ONLY: u32 = 16;
pub const RHF_GUARANTEE_INIT: u32 = 32;
pub const RHF_DELTA_C_PLUS_PLUS: u32 = 64;
pub const RHF_GUARANTEE_START_INIT: u32 = 128;
pub const RHF_PIXIE: u32 = 256;
pub const RHF_DEFAULT_DELAY_LOAD: u32 = 512;
pub const RHF_REQUICKSTART: u32 = 1024;
pub const RHF_REQUICKSTARTED: u32 = 2048;
pub const RHF_CORD: u32 = 4096;
pub const RHF_NO_UNRES_UNDEF: u32 = 8192;
pub const RHF_RLD_ORDER_SAFE: u32 = 16384;
pub const LL_NONE: u32 = 0;
pub const LL_EXACT_MATCH: u32 = 1;
pub const LL_IGNORE_INT_VER: u32 = 2;
pub const LL_REQUIRE_MINOR: u32 = 4;
pub const LL_EXPORTS: u32 = 8;
pub const LL_DELAY_LOAD: u32 = 16;
pub const LL_DELTA: u32 = 32;
pub const MIPS_AFL_REG_NONE: u32 = 0;
pub const MIPS_AFL_REG_32: u32 = 1;
pub const MIPS_AFL_REG_64: u32 = 2;
pub const MIPS_AFL_REG_128: u32 = 3;
pub const MIPS_AFL_ASE_DSP: u32 = 1;
pub const MIPS_AFL_ASE_DSPR2: u32 = 2;
pub const MIPS_AFL_ASE_EVA: u32 = 4;
pub const MIPS_AFL_ASE_MCU: u32 = 8;
pub const MIPS_AFL_ASE_MDMX: u32 = 16;
pub const MIPS_AFL_ASE_MIPS3D: u32 = 32;
pub const MIPS_AFL_ASE_MT: u32 = 64;
pub const MIPS_AFL_ASE_SMARTMIPS: u32 = 128;
pub const MIPS_AFL_ASE_VIRT: u32 = 256;
pub const MIPS_AFL_ASE_MSA: u32 = 512;
pub const MIPS_AFL_ASE_MIPS16: u32 = 1024;
pub const MIPS_AFL_ASE_MICROMIPS: u32 = 2048;
pub const MIPS_AFL_ASE_XPA: u32 = 4096;
pub const MIPS_AFL_ASE_MASK: u32 = 8191;
pub const MIPS_AFL_EXT_XLR: u32 = 1;
pub const MIPS_AFL_EXT_OCTEON2: u32 = 2;
pub const MIPS_AFL_EXT_OCTEONP: u32 = 3;
pub const MIPS_AFL_EXT_LOONGSON_3A: u32 = 4;
pub const MIPS_AFL_EXT_OCTEON: u32 = 5;
pub const MIPS_AFL_EXT_5900: u32 = 6;
pub const MIPS_AFL_EXT_4650: u32 = 7;
pub const MIPS_AFL_EXT_4010: u32 = 8;
pub const MIPS_AFL_EXT_4100: u32 = 9;
pub const MIPS_AFL_EXT_3900: u32 = 10;
pub const MIPS_AFL_EXT_10000: u32 = 11;
pub const MIPS_AFL_EXT_SB1: u32 = 12;
pub const MIPS_AFL_EXT_4111: u32 = 13;
pub const MIPS_AFL_EXT_4120: u32 = 14;
pub const MIPS_AFL_EXT_5400: u32 = 15;
pub const MIPS_AFL_EXT_5500: u32 = 16;
pub const MIPS_AFL_EXT_LOONGSON_2E: u32 = 17;
pub const MIPS_AFL_EXT_LOONGSON_2F: u32 = 18;
pub const MIPS_AFL_FLAGS1_ODDSPREG: u32 = 1;
pub const EF_PARISC_TRAPNIL: u32 = 65536;
pub const EF_PARISC_EXT: u32 = 131072;
pub const EF_PARISC_LSB: u32 = 262144;
pub const EF_PARISC_WIDE: u32 = 524288;
pub const EF_PARISC_NO_KABP: u32 = 1048576;
pub const EF_PARISC_LAZYSWAP: u32 = 4194304;
pub const EF_PARISC_ARCH: u32 = 65535;
pub const EFA_PARISC_1_0: u32 = 523;
pub const EFA_PARISC_1_1: u32 = 528;
pub const EFA_PARISC_2_0: u32 = 532;
pub const SHN_PARISC_ANSI_COMMON: u32 = 65280;
pub const SHN_PARISC_HUGE_COMMON: u32 = 65281;
pub const SHT_PARISC_EXT: u32 = 1879048192;
pub const SHT_PARISC_UNWIND: u32 = 1879048193;
pub const SHT_PARISC_DOC: u32 = 1879048194;
pub const SHF_PARISC_SHORT: u32 = 536870912;
pub const SHF_PARISC_HUGE: u32 = 1073741824;
pub const SHF_PARISC_SBP: u32 = 2147483648;
pub const STT_PARISC_MILLICODE: u32 = 13;
pub const STT_HP_OPAQUE: u32 = 11;
pub const STT_HP_STUB: u32 = 12;
pub const R_PARISC_NONE: u32 = 0;
pub const R_PARISC_DIR32: u32 = 1;
pub const R_PARISC_DIR21L: u32 = 2;
pub const R_PARISC_DIR17R: u32 = 3;
pub const R_PARISC_DIR17F: u32 = 4;
pub const R_PARISC_DIR14R: u32 = 6;
pub const R_PARISC_PCREL32: u32 = 9;
pub const R_PARISC_PCREL21L: u32 = 10;
pub const R_PARISC_PCREL17R: u32 = 11;
pub const R_PARISC_PCREL17F: u32 = 12;
pub const R_PARISC_PCREL14R: u32 = 14;
pub const R_PARISC_DPREL21L: u32 = 18;
pub const R_PARISC_DPREL14R: u32 = 22;
pub const R_PARISC_GPREL21L: u32 = 26;
pub const R_PARISC_GPREL14R: u32 = 30;
pub const R_PARISC_LTOFF21L: u32 = 34;
pub const R_PARISC_LTOFF14R: u32 = 38;
pub const R_PARISC_SECREL32: u32 = 41;
pub const R_PARISC_SEGBASE: u32 = 48;
pub const R_PARISC_SEGREL32: u32 = 49;
pub const R_PARISC_PLTOFF21L: u32 = 50;
pub const R_PARISC_PLTOFF14R: u32 = 54;
pub const R_PARISC_LTOFF_FPTR32: u32 = 57;
pub const R_PARISC_LTOFF_FPTR21L: u32 = 58;
pub const R_PARISC_LTOFF_FPTR14R: u32 = 62;
pub const R_PARISC_FPTR64: u32 = 64;
pub const R_PARISC_PLABEL32: u32 = 65;
pub const R_PARISC_PLABEL21L: u32 = 66;
pub const R_PARISC_PLABEL14R: u32 = 70;
pub const R_PARISC_PCREL64: u32 = 72;
pub const R_PARISC_PCREL22F: u32 = 74;
pub const R_PARISC_PCREL14WR: u32 = 75;
pub const R_PARISC_PCREL14DR: u32 = 76;
pub const R_PARISC_PCREL16F: u32 = 77;
pub const R_PARISC_PCREL16WF: u32 = 78;
pub const R_PARISC_PCREL16DF: u32 = 79;
pub const R_PARISC_DIR64: u32 = 80;
pub const R_PARISC_DIR14WR: u32 = 83;
pub const R_PARISC_DIR14DR: u32 = 84;
pub const R_PARISC_DIR16F: u32 = 85;
pub const R_PARISC_DIR16WF: u32 = 86;
pub const R_PARISC_DIR16DF: u32 = 87;
pub const R_PARISC_GPREL64: u32 = 88;
pub const R_PARISC_GPREL14WR: u32 = 91;
pub const R_PARISC_GPREL14DR: u32 = 92;
pub const R_PARISC_GPREL16F: u32 = 93;
pub const R_PARISC_GPREL16WF: u32 = 94;
pub const R_PARISC_GPREL16DF: u32 = 95;
pub const R_PARISC_LTOFF64: u32 = 96;
pub const R_PARISC_LTOFF14WR: u32 = 99;
pub const R_PARISC_LTOFF14DR: u32 = 100;
pub const R_PARISC_LTOFF16F: u32 = 101;
pub const R_PARISC_LTOFF16WF: u32 = 102;
pub const R_PARISC_LTOFF16DF: u32 = 103;
pub const R_PARISC_SECREL64: u32 = 104;
pub const R_PARISC_SEGREL64: u32 = 112;
pub const R_PARISC_PLTOFF14WR: u32 = 115;
pub const R_PARISC_PLTOFF14DR: u32 = 116;
pub const R_PARISC_PLTOFF16F: u32 = 117;
pub const R_PARISC_PLTOFF16WF: u32 = 118;
pub const R_PARISC_PLTOFF16DF: u32 = 119;
pub const R_PARISC_LTOFF_FPTR64: u32 = 120;
pub const R_PARISC_LTOFF_FPTR14WR: u32 = 123;
pub const R_PARISC_LTOFF_FPTR14DR: u32 = 124;
pub const R_PARISC_LTOFF_FPTR16F: u32 = 125;
pub const R_PARISC_LTOFF_FPTR16WF: u32 = 126;
pub const R_PARISC_LTOFF_FPTR16DF: u32 = 127;
pub const R_PARISC_LORESERVE: u32 = 128;
pub const R_PARISC_COPY: u32 = 128;
pub const R_PARISC_IPLT: u32 = 129;
pub const R_PARISC_EPLT: u32 = 130;
pub const R_PARISC_TPREL32: u32 = 153;
pub const R_PARISC_TPREL21L: u32 = 154;
pub const R_PARISC_TPREL14R: u32 = 158;
pub const R_PARISC_LTOFF_TP21L: u32 = 162;
pub const R_PARISC_LTOFF_TP14R: u32 = 166;
pub const R_PARISC_LTOFF_TP14F: u32 = 167;
pub const R_PARISC_TPREL64: u32 = 216;
pub const R_PARISC_TPREL14WR: u32 = 219;
pub const R_PARISC_TPREL14DR: u32 = 220;
pub const R_PARISC_TPREL16F: u32 = 221;
pub const R_PARISC_TPREL16WF: u32 = 222;
pub const R_PARISC_TPREL16DF: u32 = 223;
pub const R_PARISC_LTOFF_TP64: u32 = 224;
pub const R_PARISC_LTOFF_TP14WR: u32 = 227;
pub const R_PARISC_LTOFF_TP14DR: u32 = 228;
pub const R_PARISC_LTOFF_TP16F: u32 = 229;
pub const R_PARISC_LTOFF_TP16WF: u32 = 230;
pub const R_PARISC_LTOFF_TP16DF: u32 = 231;
pub const R_PARISC_GNU_VTENTRY: u32 = 232;
pub const R_PARISC_GNU_VTINHERIT: u32 = 233;
pub const R_PARISC_TLS_GD21L: u32 = 234;
pub const R_PARISC_TLS_GD14R: u32 = 235;
pub const R_PARISC_TLS_GDCALL: u32 = 236;
pub const R_PARISC_TLS_LDM21L: u32 = 237;
pub const R_PARISC_TLS_LDM14R: u32 = 238;
pub const R_PARISC_TLS_LDMCALL: u32 = 239;
pub const R_PARISC_TLS_LDO21L: u32 = 240;
pub const R_PARISC_TLS_LDO14R: u32 = 241;
pub const R_PARISC_TLS_DTPMOD32: u32 = 242;
pub const R_PARISC_TLS_DTPMOD64: u32 = 243;
pub const R_PARISC_TLS_DTPOFF32: u32 = 244;
pub const R_PARISC_TLS_DTPOFF64: u32 = 245;
pub const R_PARISC_TLS_LE21L: u32 = 154;
pub const R_PARISC_TLS_LE14R: u32 = 158;
pub const R_PARISC_TLS_IE21L: u32 = 162;
pub const R_PARISC_TLS_IE14R: u32 = 166;
pub const R_PARISC_TLS_TPREL32: u32 = 153;
pub const R_PARISC_TLS_TPREL64: u32 = 216;
pub const R_PARISC_HIRESERVE: u32 = 255;
pub const PT_HP_TLS: u32 = 1610612736;
pub const PT_HP_CORE_NONE: u32 = 1610612737;
pub const PT_HP_CORE_VERSION: u32 = 1610612738;
pub const PT_HP_CORE_KERNEL: u32 = 1610612739;
pub const PT_HP_CORE_COMM: u32 = 1610612740;
pub const PT_HP_CORE_PROC: u32 = 1610612741;
pub const PT_HP_CORE_LOADABLE: u32 = 1610612742;
pub const PT_HP_CORE_STACK: u32 = 1610612743;
pub const PT_HP_CORE_SHM: u32 = 1610612744;
pub const PT_HP_CORE_MMF: u32 = 1610612745;
pub const PT_HP_PARALLEL: u32 = 1610612752;
pub const PT_HP_FASTBIND: u32 = 1610612753;
pub const PT_HP_OPT_ANNOT: u32 = 1610612754;
pub const PT_HP_HSL_ANNOT: u32 = 1610612755;
pub const PT_HP_STACK: u32 = 1610612756;
pub const PT_PARISC_ARCHEXT: u32 = 1879048192;
pub const PT_PARISC_UNWIND: u32 = 1879048193;
pub const PF_PARISC_SBP: u32 = 134217728;
pub const PF_HP_PAGE_SIZE: u32 = 1048576;
pub const PF_HP_FAR_SHARED: u32 = 2097152;
pub const PF_HP_NEAR_SHARED: u32 = 4194304;
pub const PF_HP_CODE: u32 = 16777216;
pub const PF_HP_MODIFY: u32 = 33554432;
pub const PF_HP_LAZYSWAP: u32 = 67108864;
pub const PF_HP_SBP: u32 = 134217728;
pub const EF_ALPHA_32BIT: u32 = 1;
pub const EF_ALPHA_CANRELAX: u32 = 2;
pub const SHT_ALPHA_DEBUG: u32 = 1879048193;
pub const SHT_ALPHA_REGINFO: u32 = 1879048194;
pub const SHF_ALPHA_GPREL: u32 = 268435456;
pub const STO_ALPHA_NOPV: u32 = 128;
pub const STO_ALPHA_STD_GPLOAD: u32 = 136;
pub const R_ALPHA_NONE: u32 = 0;
pub const R_ALPHA_REFLONG: u32 = 1;
pub const R_ALPHA_REFQUAD: u32 = 2;
pub const R_ALPHA_GPREL32: u32 = 3;
pub const R_ALPHA_LITERAL: u32 = 4;
pub const R_ALPHA_LITUSE: u32 = 5;
pub const R_ALPHA_GPDISP: u32 = 6;
pub const R_ALPHA_BRADDR: u32 = 7;
pub const R_ALPHA_HINT: u32 = 8;
pub const R_ALPHA_SREL16: u32 = 9;
pub const R_ALPHA_SREL32: u32 = 10;
pub const R_ALPHA_SREL64: u32 = 11;
pub const R_ALPHA_GPRELHIGH: u32 = 17;
pub const R_ALPHA_GPRELLOW: u32 = 18;
pub const R_ALPHA_GPREL16: u32 = 19;
pub const R_ALPHA_COPY: u32 = 24;
pub const R_ALPHA_GLOB_DAT: u32 = 25;
pub const R_ALPHA_JMP_SLOT: u32 = 26;
pub const R_ALPHA_RELATIVE: u32 = 27;
pub const R_ALPHA_TLS_GD_HI: u32 = 28;
pub const R_ALPHA_TLSGD: u32 = 29;
pub const R_ALPHA_TLS_LDM: u32 = 30;
pub const R_ALPHA_DTPMOD64: u32 = 31;
pub const R_ALPHA_GOTDTPREL: u32 = 32;
pub const R_ALPHA_DTPREL64: u32 = 33;
pub const R_ALPHA_DTPRELHI: u32 = 34;
pub const R_ALPHA_DTPRELLO: u32 = 35;
pub const R_ALPHA_DTPREL16: u32 = 36;
pub const R_ALPHA_GOTTPREL: u32 = 37;
pub const R_ALPHA_TPREL64: u32 = 38;
pub const R_ALPHA_TPRELHI: u32 = 39;
pub const R_ALPHA_TPRELLO: u32 = 40;
pub const R_ALPHA_TPREL16: u32 = 41;
pub const R_ALPHA_NUM: u32 = 46;
pub const LITUSE_ALPHA_ADDR: u32 = 0;
pub const LITUSE_ALPHA_BASE: u32 = 1;
pub const LITUSE_ALPHA_BYTOFF: u32 = 2;
pub const LITUSE_ALPHA_JSR: u32 = 3;
pub const LITUSE_ALPHA_TLS_GD: u32 = 4;
pub const LITUSE_ALPHA_TLS_LDM: u32 = 5;
pub const DT_ALPHA_PLTRO: u32 = 1879048192;
pub const DT_ALPHA_NUM: u32 = 1;
pub const EF_PPC_EMB: u32 = 2147483648;
pub const EF_PPC_RELOCATABLE: u32 = 65536;
pub const EF_PPC_RELOCATABLE_LIB: u32 = 32768;
pub const R_PPC_NONE: u32 = 0;
pub const R_PPC_ADDR32: u32 = 1;
pub const R_PPC_ADDR24: u32 = 2;
pub const R_PPC_ADDR16: u32 = 3;
pub const R_PPC_ADDR16_LO: u32 = 4;
pub const R_PPC_ADDR16_HI: u32 = 5;
pub const R_PPC_ADDR16_HA: u32 = 6;
pub const R_PPC_ADDR14: u32 = 7;
pub const R_PPC_ADDR14_BRTAKEN: u32 = 8;
pub const R_PPC_ADDR14_BRNTAKEN: u32 = 9;
pub const R_PPC_REL24: u32 = 10;
pub const R_PPC_REL14: u32 = 11;
pub const R_PPC_REL14_BRTAKEN: u32 = 12;
pub const R_PPC_REL14_BRNTAKEN: u32 = 13;
pub const R_PPC_GOT16: u32 = 14;
pub const R_PPC_GOT16_LO: u32 = 15;
pub const R_PPC_GOT16_HI: u32 = 16;
pub const R_PPC_GOT16_HA: u32 = 17;
pub const R_PPC_PLTREL24: u32 = 18;
pub const R_PPC_COPY: u32 = 19;
pub const R_PPC_GLOB_DAT: u32 = 20;
pub const R_PPC_JMP_SLOT: u32 = 21;
pub const R_PPC_RELATIVE: u32 = 22;
pub const R_PPC_LOCAL24PC: u32 = 23;
pub const R_PPC_UADDR32: u32 = 24;
pub const R_PPC_UADDR16: u32 = 25;
pub const R_PPC_REL32: u32 = 26;
pub const R_PPC_PLT32: u32 = 27;
pub const R_PPC_PLTREL32: u32 = 28;
pub const R_PPC_PLT16_LO: u32 = 29;
pub const R_PPC_PLT16_HI: u32 = 30;
pub const R_PPC_PLT16_HA: u32 = 31;
pub const R_PPC_SDAREL16: u32 = 32;
pub const R_PPC_SECTOFF: u32 = 33;
pub const R_PPC_SECTOFF_LO: u32 = 34;
pub const R_PPC_SECTOFF_HI: u32 = 35;
pub const R_PPC_SECTOFF_HA: u32 = 36;
pub const R_PPC_TLS: u32 = 67;
pub const R_PPC_DTPMOD32: u32 = 68;
pub const R_PPC_TPREL16: u32 = 69;
pub const R_PPC_TPREL16_LO: u32 = 70;
pub const R_PPC_TPREL16_HI: u32 = 71;
pub const R_PPC_TPREL16_HA: u32 = 72;
pub const R_PPC_TPREL32: u32 = 73;
pub const R_PPC_DTPREL16: u32 = 74;
pub const R_PPC_DTPREL16_LO: u32 = 75;
pub const R_PPC_DTPREL16_HI: u32 = 76;
pub const R_PPC_DTPREL16_HA: u32 = 77;
pub const R_PPC_DTPREL32: u32 = 78;
pub const R_PPC_GOT_TLSGD16: u32 = 79;
pub const R_PPC_GOT_TLSGD16_LO: u32 = 80;
pub const R_PPC_GOT_TLSGD16_HI: u32 = 81;
pub const R_PPC_GOT_TLSGD16_HA: u32 = 82;
pub const R_PPC_GOT_TLSLD16: u32 = 83;
pub const R_PPC_GOT_TLSLD16_LO: u32 = 84;
pub const R_PPC_GOT_TLSLD16_HI: u32 = 85;
pub const R_PPC_GOT_TLSLD16_HA: u32 = 86;
pub const R_PPC_GOT_TPREL16: u32 = 87;
pub const R_PPC_GOT_TPREL16_LO: u32 = 88;
pub const R_PPC_GOT_TPREL16_HI: u32 = 89;
pub const R_PPC_GOT_TPREL16_HA: u32 = 90;
pub const R_PPC_GOT_DTPREL16: u32 = 91;
pub const R_PPC_GOT_DTPREL16_LO: u32 = 92;
pub const R_PPC_GOT_DTPREL16_HI: u32 = 93;
pub const R_PPC_GOT_DTPREL16_HA: u32 = 94;
pub const R_PPC_TLSGD: u32 = 95;
pub const R_PPC_TLSLD: u32 = 96;
pub const R_PPC_EMB_NADDR32: u32 = 101;
pub const R_PPC_EMB_NADDR16: u32 = 102;
pub const R_PPC_EMB_NADDR16_LO: u32 = 103;
pub const R_PPC_EMB_NADDR16_HI: u32 = 104;
pub const R_PPC_EMB_NADDR16_HA: u32 = 105;
pub const R_PPC_EMB_SDAI16: u32 = 106;
pub const R_PPC_EMB_SDA2I16: u32 = 107;
pub const R_PPC_EMB_SDA2REL: u32 = 108;
pub const R_PPC_EMB_SDA21: u32 = 109;
pub const R_PPC_EMB_MRKREF: u32 = 110;
pub const R_PPC_EMB_RELSEC16: u32 = 111;
pub const R_PPC_EMB_RELST_LO: u32 = 112;
pub const R_PPC_EMB_RELST_HI: u32 = 113;
pub const R_PPC_EMB_RELST_HA: u32 = 114;
pub const R_PPC_EMB_BIT_FLD: u32 = 115;
pub const R_PPC_EMB_RELSDA: u32 = 116;
pub const R_PPC_DIAB_SDA21_LO: u32 = 180;
pub const R_PPC_DIAB_SDA21_HI: u32 = 181;
pub const R_PPC_DIAB_SDA21_HA: u32 = 182;
pub const R_PPC_DIAB_RELSDA_LO: u32 = 183;
pub const R_PPC_DIAB_RELSDA_HI: u32 = 184;
pub const R_PPC_DIAB_RELSDA_HA: u32 = 185;
pub const R_PPC_IRELATIVE: u32 = 248;
pub const R_PPC_REL16: u32 = 249;
pub const R_PPC_REL16_LO: u32 = 250;
pub const R_PPC_REL16_HI: u32 = 251;
pub const R_PPC_REL16_HA: u32 = 252;
pub const R_PPC_TOC16: u32 = 255;
pub const DT_PPC_GOT: u32 = 1879048192;
pub const DT_PPC_OPT: u32 = 1879048193;
pub const DT_PPC_NUM: u32 = 2;
pub const PPC_OPT_TLS: u32 = 1;
pub const R_PPC64_NONE: u32 = 0;
pub const R_PPC64_ADDR32: u32 = 1;
pub const R_PPC64_ADDR24: u32 = 2;
pub const R_PPC64_ADDR16: u32 = 3;
pub const R_PPC64_ADDR16_LO: u32 = 4;
pub const R_PPC64_ADDR16_HI: u32 = 5;
pub const R_PPC64_ADDR16_HA: u32 = 6;
pub const R_PPC64_ADDR14: u32 = 7;
pub const R_PPC64_ADDR14_BRTAKEN: u32 = 8;
pub const R_PPC64_ADDR14_BRNTAKEN: u32 = 9;
pub const R_PPC64_REL24: u32 = 10;
pub const R_PPC64_REL14: u32 = 11;
pub const R_PPC64_REL14_BRTAKEN: u32 = 12;
pub const R_PPC64_REL14_BRNTAKEN: u32 = 13;
pub const R_PPC64_GOT16: u32 = 14;
pub const R_PPC64_GOT16_LO: u32 = 15;
pub const R_PPC64_GOT16_HI: u32 = 16;
pub const R_PPC64_GOT16_HA: u32 = 17;
pub const R_PPC64_COPY: u32 = 19;
pub const R_PPC64_GLOB_DAT: u32 = 20;
pub const R_PPC64_JMP_SLOT: u32 = 21;
pub const R_PPC64_RELATIVE: u32 = 22;
pub const R_PPC64_UADDR32: u32 = 24;
pub const R_PPC64_UADDR16: u32 = 25;
pub const R_PPC64_REL32: u32 = 26;
pub const R_PPC64_PLT32: u32 = 27;
pub const R_PPC64_PLTREL32: u32 = 28;
pub const R_PPC64_PLT16_LO: u32 = 29;
pub const R_PPC64_PLT16_HI: u32 = 30;
pub const R_PPC64_PLT16_HA: u32 = 31;
pub const R_PPC64_SECTOFF: u32 = 33;
pub const R_PPC64_SECTOFF_LO: u32 = 34;
pub const R_PPC64_SECTOFF_HI: u32 = 35;
pub const R_PPC64_SECTOFF_HA: u32 = 36;
pub const R_PPC64_ADDR30: u32 = 37;
pub const R_PPC64_ADDR64: u32 = 38;
pub const R_PPC64_ADDR16_HIGHER: u32 = 39;
pub const R_PPC64_ADDR16_HIGHERA: u32 = 40;
pub const R_PPC64_ADDR16_HIGHEST: u32 = 41;
pub const R_PPC64_ADDR16_HIGHESTA: u32 = 42;
pub const R_PPC64_UADDR64: u32 = 43;
pub const R_PPC64_REL64: u32 = 44;
pub const R_PPC64_PLT64: u32 = 45;
pub const R_PPC64_PLTREL64: u32 = 46;
pub const R_PPC64_TOC16: u32 = 47;
pub const R_PPC64_TOC16_LO: u32 = 48;
pub const R_PPC64_TOC16_HI: u32 = 49;
pub const R_PPC64_TOC16_HA: u32 = 50;
pub const R_PPC64_TOC: u32 = 51;
pub const R_PPC64_PLTGOT16: u32 = 52;
pub const R_PPC64_PLTGOT16_LO: u32 = 53;
pub const R_PPC64_PLTGOT16_HI: u32 = 54;
pub const R_PPC64_PLTGOT16_HA: u32 = 55;
pub const R_PPC64_ADDR16_DS: u32 = 56;
pub const R_PPC64_ADDR16_LO_DS: u32 = 57;
pub const R_PPC64_GOT16_DS: u32 = 58;
pub const R_PPC64_GOT16_LO_DS: u32 = 59;
pub const R_PPC64_PLT16_LO_DS: u32 = 60;
pub const R_PPC64_SECTOFF_DS: u32 = 61;
pub const R_PPC64_SECTOFF_LO_DS: u32 = 62;
pub const R_PPC64_TOC16_DS: u32 = 63;
pub const R_PPC64_TOC16_LO_DS: u32 = 64;
pub const R_PPC64_PLTGOT16_DS: u32 = 65;
pub const R_PPC64_PLTGOT16_LO_DS: u32 = 66;
pub const R_PPC64_TLS: u32 = 67;
pub const R_PPC64_DTPMOD64: u32 = 68;
pub const R_PPC64_TPREL16: u32 = 69;
pub const R_PPC64_TPREL16_LO: u32 = 70;
pub const R_PPC64_TPREL16_HI: u32 = 71;
pub const R_PPC64_TPREL16_HA: u32 = 72;
pub const R_PPC64_TPREL64: u32 = 73;
pub const R_PPC64_DTPREL16: u32 = 74;
pub const R_PPC64_DTPREL16_LO: u32 = 75;
pub const R_PPC64_DTPREL16_HI: u32 = 76;
pub const R_PPC64_DTPREL16_HA: u32 = 77;
pub const R_PPC64_DTPREL64: u32 = 78;
pub const R_PPC64_GOT_TLSGD16: u32 = 79;
pub const R_PPC64_GOT_TLSGD16_LO: u32 = 80;
pub const R_PPC64_GOT_TLSGD16_HI: u32 = 81;
pub const R_PPC64_GOT_TLSGD16_HA: u32 = 82;
pub const R_PPC64_GOT_TLSLD16: u32 = 83;
pub const R_PPC64_GOT_TLSLD16_LO: u32 = 84;
pub const R_PPC64_GOT_TLSLD16_HI: u32 = 85;
pub const R_PPC64_GOT_TLSLD16_HA: u32 = 86;
pub const R_PPC64_GOT_TPREL16_DS: u32 = 87;
pub const R_PPC64_GOT_TPREL16_LO_DS: u32 = 88;
pub const R_PPC64_GOT_TPREL16_HI: u32 = 89;
pub const R_PPC64_GOT_TPREL16_HA: u32 = 90;
pub const R_PPC64_GOT_DTPREL16_DS: u32 = 91;
pub const R_PPC64_GOT_DTPREL16_LO_DS: u32 = 92;
pub const R_PPC64_GOT_DTPREL16_HI: u32 = 93;
pub const R_PPC64_GOT_DTPREL16_HA: u32 = 94;
pub const R_PPC64_TPREL16_DS: u32 = 95;
pub const R_PPC64_TPREL16_LO_DS: u32 = 96;
pub const R_PPC64_TPREL16_HIGHER: u32 = 97;
pub const R_PPC64_TPREL16_HIGHERA: u32 = 98;
pub const R_PPC64_TPREL16_HIGHEST: u32 = 99;
pub const R_PPC64_TPREL16_HIGHESTA: u32 = 100;
pub const R_PPC64_DTPREL16_DS: u32 = 101;
pub const R_PPC64_DTPREL16_LO_DS: u32 = 102;
pub const R_PPC64_DTPREL16_HIGHER: u32 = 103;
pub const R_PPC64_DTPREL16_HIGHERA: u32 = 104;
pub const R_PPC64_DTPREL16_HIGHEST: u32 = 105;
pub const R_PPC64_DTPREL16_HIGHESTA: u32 = 106;
pub const R_PPC64_TLSGD: u32 = 107;
pub const R_PPC64_TLSLD: u32 = 108;
pub const R_PPC64_TOCSAVE: u32 = 109;
pub const R_PPC64_ADDR16_HIGH: u32 = 110;
pub const R_PPC64_ADDR16_HIGHA: u32 = 111;
pub const R_PPC64_TPREL16_HIGH: u32 = 112;
pub const R_PPC64_TPREL16_HIGHA: u32 = 113;
pub const R_PPC64_DTPREL16_HIGH: u32 = 114;
pub const R_PPC64_DTPREL16_HIGHA: u32 = 115;
pub const R_PPC64_JMP_IREL: u32 = 247;
pub const R_PPC64_IRELATIVE: u32 = 248;
pub const R_PPC64_REL16: u32 = 249;
pub const R_PPC64_REL16_LO: u32 = 250;
pub const R_PPC64_REL16_HI: u32 = 251;
pub const R_PPC64_REL16_HA: u32 = 252;
pub const EF_PPC64_ABI: u32 = 3;
pub const DT_PPC64_GLINK: u32 = 1879048192;
pub const DT_PPC64_OPD: u32 = 1879048193;
pub const DT_PPC64_OPDSZ: u32 = 1879048194;
pub const DT_PPC64_OPT: u32 = 1879048195;
pub const DT_PPC64_NUM: u32 = 4;
pub const PPC64_OPT_TLS: u32 = 1;
pub const PPC64_OPT_MULTI_TOC: u32 = 2;
pub const STO_PPC64_LOCAL_BIT: u32 = 5;
pub const STO_PPC64_LOCAL_MASK: u32 = 224;
pub const EF_ARM_RELEXEC: u32 = 1;
pub const EF_ARM_HASENTRY: u32 = 2;
pub const EF_ARM_INTERWORK: u32 = 4;
pub const EF_ARM_APCS_26: u32 = 8;
pub const EF_ARM_APCS_FLOAT: u32 = 16;
pub const EF_ARM_PIC: u32 = 32;
pub const EF_ARM_ALIGN8: u32 = 64;
pub const EF_ARM_NEW_ABI: u32 = 128;
pub const EF_ARM_OLD_ABI: u32 = 256;
pub const EF_ARM_SOFT_FLOAT: u32 = 512;
pub const EF_ARM_VFP_FLOAT: u32 = 1024;
pub const EF_ARM_MAVERICK_FLOAT: u32 = 2048;
pub const EF_ARM_ABI_FLOAT_SOFT: u32 = 512;
pub const EF_ARM_ABI_FLOAT_HARD: u32 = 1024;
pub const EF_ARM_SYMSARESORTED: u32 = 4;
pub const EF_ARM_DYNSYMSUSESEGIDX: u32 = 8;
pub const EF_ARM_MAPSYMSFIRST: u32 = 16;
pub const EF_ARM_EABIMASK: u32 = 4278190080;
pub const EF_ARM_BE8: u32 = 8388608;
pub const EF_ARM_LE8: u32 = 4194304;
pub const EF_ARM_EABI_UNKNOWN: u32 = 0;
pub const EF_ARM_EABI_VER1: u32 = 16777216;
pub const EF_ARM_EABI_VER2: u32 = 33554432;
pub const EF_ARM_EABI_VER3: u32 = 50331648;
pub const EF_ARM_EABI_VER4: u32 = 67108864;
pub const EF_ARM_EABI_VER5: u32 = 83886080;
pub const STT_ARM_TFUNC: u32 = 13;
pub const STT_ARM_16BIT: u32 = 15;
pub const SHF_ARM_ENTRYSECT: u32 = 268435456;
pub const SHF_ARM_COMDEF: u32 = 2147483648;
pub const PF_ARM_SB: u32 = 268435456;
pub const PF_ARM_PI: u32 = 536870912;
pub const PF_ARM_ABS: u32 = 1073741824;
pub const PT_ARM_EXIDX: u32 = 1879048193;
pub const SHT_ARM_EXIDX: u32 = 1879048193;
pub const SHT_ARM_PREEMPTMAP: u32 = 1879048194;
pub const SHT_ARM_ATTRIBUTES: u32 = 1879048195;
pub const R_AARCH64_NONE: u32 = 0;
pub const R_AARCH64_P32_ABS32: u32 = 1;
pub const R_AARCH64_P32_COPY: u32 = 180;
pub const R_AARCH64_P32_GLOB_DAT: u32 = 181;
pub const R_AARCH64_P32_JUMP_SLOT: u32 = 182;
pub const R_AARCH64_P32_RELATIVE: u32 = 183;
pub const R_AARCH64_P32_TLS_DTPMOD: u32 = 184;
pub const R_AARCH64_P32_TLS_DTPREL: u32 = 185;
pub const R_AARCH64_P32_TLS_TPREL: u32 = 186;
pub const R_AARCH64_P32_TLSDESC: u32 = 187;
pub const R_AARCH64_P32_IRELATIVE: u32 = 188;
pub const R_AARCH64_ABS64: u32 = 257;
pub const R_AARCH64_ABS32: u32 = 258;
pub const R_AARCH64_ABS16: u32 = 259;
pub const R_AARCH64_PREL64: u32 = 260;
pub const R_AARCH64_PREL32: u32 = 261;
pub const R_AARCH64_PREL16: u32 = 262;
pub const R_AARCH64_MOVW_UABS_G0: u32 = 263;
pub const R_AARCH64_MOVW_UABS_G0_NC: u32 = 264;
pub const R_AARCH64_MOVW_UABS_G1: u32 = 265;
pub const R_AARCH64_MOVW_UABS_G1_NC: u32 = 266;
pub const R_AARCH64_MOVW_UABS_G2: u32 = 267;
pub const R_AARCH64_MOVW_UABS_G2_NC: u32 = 268;
pub const R_AARCH64_MOVW_UABS_G3: u32 = 269;
pub const R_AARCH64_MOVW_SABS_G0: u32 = 270;
pub const R_AARCH64_MOVW_SABS_G1: u32 = 271;
pub const R_AARCH64_MOVW_SABS_G2: u32 = 272;
pub const R_AARCH64_LD_PREL_LO19: u32 = 273;
pub const R_AARCH64_ADR_PREL_LO21: u32 = 274;
pub const R_AARCH64_ADR_PREL_PG_HI21: u32 = 275;
pub const R_AARCH64_ADR_PREL_PG_HI21_NC: u32 = 276;
pub const R_AARCH64_ADD_ABS_LO12_NC: u32 = 277;
pub const R_AARCH64_LDST8_ABS_LO12_NC: u32 = 278;
pub const R_AARCH64_TSTBR14: u32 = 279;
pub const R_AARCH64_CONDBR19: u32 = 280;
pub const R_AARCH64_JUMP26: u32 = 282;
pub const R_AARCH64_CALL26: u32 = 283;
pub const R_AARCH64_LDST16_ABS_LO12_NC: u32 = 284;
pub const R_AARCH64_LDST32_ABS_LO12_NC: u32 = 285;
pub const R_AARCH64_LDST64_ABS_LO12_NC: u32 = 286;
pub const R_AARCH64_MOVW_PREL_G0: u32 = 287;
pub const R_AARCH64_MOVW_PREL_G0_NC: u32 = 288;
pub const R_AARCH64_MOVW_PREL_G1: u32 = 289;
pub const R_AARCH64_MOVW_PREL_G1_NC: u32 = 290;
pub const R_AARCH64_MOVW_PREL_G2: u32 = 291;
pub const R_AARCH64_MOVW_PREL_G2_NC: u32 = 292;
pub const R_AARCH64_MOVW_PREL_G3: u32 = 293;
pub const R_AARCH64_LDST128_ABS_LO12_NC: u32 = 299;
pub const R_AARCH64_MOVW_GOTOFF_G0: u32 = 300;
pub const R_AARCH64_MOVW_GOTOFF_G0_NC: u32 = 301;
pub const R_AARCH64_MOVW_GOTOFF_G1: u32 = 302;
pub const R_AARCH64_MOVW_GOTOFF_G1_NC: u32 = 303;
pub const R_AARCH64_MOVW_GOTOFF_G2: u32 = 304;
pub const R_AARCH64_MOVW_GOTOFF_G2_NC: u32 = 305;
pub const R_AARCH64_MOVW_GOTOFF_G3: u32 = 306;
pub const R_AARCH64_GOTREL64: u32 = 307;
pub const R_AARCH64_GOTREL32: u32 = 308;
pub const R_AARCH64_GOT_LD_PREL19: u32 = 309;
pub const R_AARCH64_LD64_GOTOFF_LO15: u32 = 310;
pub const R_AARCH64_ADR_GOT_PAGE: u32 = 311;
pub const R_AARCH64_LD64_GOT_LO12_NC: u32 = 312;
pub const R_AARCH64_LD64_GOTPAGE_LO15: u32 = 313;
pub const R_AARCH64_TLSGD_ADR_PREL21: u32 = 512;
pub const R_AARCH64_TLSGD_ADR_PAGE21: u32 = 513;
pub const R_AARCH64_TLSGD_ADD_LO12_NC: u32 = 514;
pub const R_AARCH64_TLSGD_MOVW_G1: u32 = 515;
pub const R_AARCH64_TLSGD_MOVW_G0_NC: u32 = 516;
pub const R_AARCH64_TLSLD_ADR_PREL21: u32 = 517;
pub const R_AARCH64_TLSLD_ADR_PAGE21: u32 = 518;
pub const R_AARCH64_TLSLD_ADD_LO12_NC: u32 = 519;
pub const R_AARCH64_TLSLD_MOVW_G1: u32 = 520;
pub const R_AARCH64_TLSLD_MOVW_G0_NC: u32 = 521;
pub const R_AARCH64_TLSLD_LD_PREL19: u32 = 522;
pub const R_AARCH64_TLSLD_MOVW_DTPREL_G2: u32 = 523;
pub const R_AARCH64_TLSLD_MOVW_DTPREL_G1: u32 = 524;
pub const R_AARCH64_TLSLD_MOVW_DTPREL_G1_NC: u32 = 525;
pub const R_AARCH64_TLSLD_MOVW_DTPREL_G0: u32 = 526;
pub const R_AARCH64_TLSLD_MOVW_DTPREL_G0_NC: u32 = 527;
pub const R_AARCH64_TLSLD_ADD_DTPREL_HI12: u32 = 528;
pub const R_AARCH64_TLSLD_ADD_DTPREL_LO12: u32 = 529;
pub const R_AARCH64_TLSLD_ADD_DTPREL_LO12_NC: u32 = 530;
pub const R_AARCH64_TLSLD_LDST8_DTPREL_LO12: u32 = 531;
pub const R_AARCH64_TLSLD_LDST8_DTPREL_LO12_NC: u32 = 532;
pub const R_AARCH64_TLSLD_LDST16_DTPREL_LO12: u32 = 533;
pub const R_AARCH64_TLSLD_LDST16_DTPREL_LO12_NC: u32 = 534;
pub const R_AARCH64_TLSLD_LDST32_DTPREL_LO12: u32 = 535;
pub const R_AARCH64_TLSLD_LDST32_DTPREL_LO12_NC: u32 = 536;
pub const R_AARCH64_TLSLD_LDST64_DTPREL_LO12: u32 = 537;
pub const R_AARCH64_TLSLD_LDST64_DTPREL_LO12_NC: u32 = 538;
pub const R_AARCH64_TLSIE_MOVW_GOTTPREL_G1: u32 = 539;
pub const R_AARCH64_TLSIE_MOVW_GOTTPREL_G0_NC: u32 = 540;
pub const R_AARCH64_TLSIE_ADR_GOTTPREL_PAGE21: u32 = 541;
pub const R_AARCH64_TLSIE_LD64_GOTTPREL_LO12_NC: u32 = 542;
pub const R_AARCH64_TLSIE_LD_GOTTPREL_PREL19: u32 = 543;
pub const R_AARCH64_TLSLE_MOVW_TPREL_G2: u32 = 544;
pub const R_AARCH64_TLSLE_MOVW_TPREL_G1: u32 = 545;
pub const R_AARCH64_TLSLE_MOVW_TPREL_G1_NC: u32 = 546;
pub const R_AARCH64_TLSLE_MOVW_TPREL_G0: u32 = 547;
pub const R_AARCH64_TLSLE_MOVW_TPREL_G0_NC: u32 = 548;
pub const R_AARCH64_TLSLE_ADD_TPREL_HI12: u32 = 549;
pub const R_AARCH64_TLSLE_ADD_TPREL_LO12: u32 = 550;
pub const R_AARCH64_TLSLE_ADD_TPREL_LO12_NC: u32 = 551;
pub const R_AARCH64_TLSLE_LDST8_TPREL_LO12: u32 = 552;
pub const R_AARCH64_TLSLE_LDST8_TPREL_LO12_NC: u32 = 553;
pub const R_AARCH64_TLSLE_LDST16_TPREL_LO12: u32 = 554;
pub const R_AARCH64_TLSLE_LDST16_TPREL_LO12_NC: u32 = 555;
pub const R_AARCH64_TLSLE_LDST32_TPREL_LO12: u32 = 556;
pub const R_AARCH64_TLSLE_LDST32_TPREL_LO12_NC: u32 = 557;
pub const R_AARCH64_TLSLE_LDST64_TPREL_LO12: u32 = 558;
pub const R_AARCH64_TLSLE_LDST64_TPREL_LO12_NC: u32 = 559;
pub const R_AARCH64_TLSDESC_LD_PREL19: u32 = 560;
pub const R_AARCH64_TLSDESC_ADR_PREL21: u32 = 561;
pub const R_AARCH64_TLSDESC_ADR_PAGE21: u32 = 562;
pub const R_AARCH64_TLSDESC_LD64_LO12: u32 = 563;
pub const R_AARCH64_TLSDESC_ADD_LO12: u32 = 564;
pub const R_AARCH64_TLSDESC_OFF_G1: u32 = 565;
pub const R_AARCH64_TLSDESC_OFF_G0_NC: u32 = 566;
pub const R_AARCH64_TLSDESC_LDR: u32 = 567;
pub const R_AARCH64_TLSDESC_ADD: u32 = 568;
pub const R_AARCH64_TLSDESC_CALL: u32 = 569;
pub const R_AARCH64_TLSLE_LDST128_TPREL_LO12: u32 = 570;
pub const R_AARCH64_TLSLE_LDST128_TPREL_LO12_NC: u32 = 571;
pub const R_AARCH64_TLSLD_LDST128_DTPREL_LO12: u32 = 572;
pub const R_AARCH64_TLSLD_LDST128_DTPREL_LO12_NC: u32 = 573;
pub const R_AARCH64_COPY: u32 = 1024;
pub const R_AARCH64_GLOB_DAT: u32 = 1025;
pub const R_AARCH64_JUMP_SLOT: u32 = 1026;
pub const R_AARCH64_RELATIVE: u32 = 1027;
pub const R_AARCH64_TLS_DTPMOD: u32 = 1028;
pub const R_AARCH64_TLS_DTPMOD64: u32 = 1028;
pub const R_AARCH64_TLS_DTPREL: u32 = 1029;
pub const R_AARCH64_TLS_DTPREL64: u32 = 1029;
pub const R_AARCH64_TLS_TPREL: u32 = 1030;
pub const R_AARCH64_TLS_TPREL64: u32 = 1030;
pub const R_AARCH64_TLSDESC: u32 = 1031;
pub const R_ARM_NONE: u32 = 0;
pub const R_ARM_PC24: u32 = 1;
pub const R_ARM_ABS32: u32 = 2;
pub const R_ARM_REL32: u32 = 3;
pub const R_ARM_PC13: u32 = 4;
pub const R_ARM_ABS16: u32 = 5;
pub const R_ARM_ABS12: u32 = 6;
pub const R_ARM_THM_ABS5: u32 = 7;
pub const R_ARM_ABS8: u32 = 8;
pub const R_ARM_SBREL32: u32 = 9;
pub const R_ARM_THM_PC22: u32 = 10;
pub const R_ARM_THM_PC8: u32 = 11;
pub const R_ARM_AMP_VCALL9: u32 = 12;
pub const R_ARM_TLS_DESC: u32 = 13;
pub const R_ARM_THM_SWI8: u32 = 14;
pub const R_ARM_XPC25: u32 = 15;
pub const R_ARM_THM_XPC22: u32 = 16;
pub const R_ARM_TLS_DTPMOD32: u32 = 17;
pub const R_ARM_TLS_DTPOFF32: u32 = 18;
pub const R_ARM_TLS_TPOFF32: u32 = 19;
pub const R_ARM_COPY: u32 = 20;
pub const R_ARM_GLOB_DAT: u32 = 21;
pub const R_ARM_JUMP_SLOT: u32 = 22;
pub const R_ARM_RELATIVE: u32 = 23;
pub const R_ARM_GOTOFF: u32 = 24;
pub const R_ARM_GOTPC: u32 = 25;
pub const R_ARM_GOT32: u32 = 26;
pub const R_ARM_PLT32: u32 = 27;
pub const R_ARM_CALL: u32 = 28;
pub const R_ARM_JUMP24: u32 = 29;
pub const R_ARM_THM_JUMP24: u32 = 30;
pub const R_ARM_BASE_ABS: u32 = 31;
pub const R_ARM_ALU_PCREL_7_0: u32 = 32;
pub const R_ARM_ALU_PCREL_15_8: u32 = 33;
pub const R_ARM_ALU_PCREL_23_15: u32 = 34;
pub const R_ARM_LDR_SBREL_11_0: u32 = 35;
pub const R_ARM_ALU_SBREL_19_12: u32 = 36;
pub const R_ARM_ALU_SBREL_27_20: u32 = 37;
pub const R_ARM_TARGET1: u32 = 38;
pub const R_ARM_SBREL31: u32 = 39;
pub const R_ARM_V4BX: u32 = 40;
pub const R_ARM_TARGET2: u32 = 41;
pub const R_ARM_PREL31: u32 = 42;
pub const R_ARM_MOVW_ABS_NC: u32 = 43;
pub const R_ARM_MOVT_ABS: u32 = 44;
pub const R_ARM_MOVW_PREL_NC: u32 = 45;
pub const R_ARM_MOVT_PREL: u32 = 46;
pub const R_ARM_THM_MOVW_ABS_NC: u32 = 47;
pub const R_ARM_THM_MOVT_ABS: u32 = 48;
pub const R_ARM_THM_MOVW_PREL_NC: u32 = 49;
pub const R_ARM_THM_MOVT_PREL: u32 = 50;
pub const R_ARM_THM_JUMP19: u32 = 51;
pub const R_ARM_THM_JUMP6: u32 = 52;
pub const R_ARM_THM_ALU_PREL_11_0: u32 = 53;
pub const R_ARM_THM_PC12: u32 = 54;
pub const R_ARM_ABS32_NOI: u32 = 55;
pub const R_ARM_REL32_NOI: u32 = 56;
pub const R_ARM_ALU_PC_G0_NC: u32 = 57;
pub const R_ARM_ALU_PC_G0: u32 = 58;
pub const R_ARM_ALU_PC_G1_NC: u32 = 59;
pub const R_ARM_ALU_PC_G1: u32 = 60;
pub const R_ARM_ALU_PC_G2: u32 = 61;
pub const R_ARM_LDR_PC_G1: u32 = 62;
pub const R_ARM_LDR_PC_G2: u32 = 63;
pub const R_ARM_LDRS_PC_G0: u32 = 64;
pub const R_ARM_LDRS_PC_G1: u32 = 65;
pub const R_ARM_LDRS_PC_G2: u32 = 66;
pub const R_ARM_LDC_PC_G0: u32 = 67;
pub const R_ARM_LDC_PC_G1: u32 = 68;
pub const R_ARM_LDC_PC_G2: u32 = 69;
pub const R_ARM_ALU_SB_G0_NC: u32 = 70;
pub const R_ARM_ALU_SB_G0: u32 = 71;
pub const R_ARM_ALU_SB_G1_NC: u32 = 72;
pub const R_ARM_ALU_SB_G1: u32 = 73;
pub const R_ARM_ALU_SB_G2: u32 = 74;
pub const R_ARM_LDR_SB_G0: u32 = 75;
pub const R_ARM_LDR_SB_G1: u32 = 76;
pub const R_ARM_LDR_SB_G2: u32 = 77;
pub const R_ARM_LDRS_SB_G0: u32 = 78;
pub const R_ARM_LDRS_SB_G1: u32 = 79;
pub const R_ARM_LDRS_SB_G2: u32 = 80;
pub const R_ARM_LDC_SB_G0: u32 = 81;
pub const R_ARM_LDC_SB_G1: u32 = 82;
pub const R_ARM_LDC_SB_G2: u32 = 83;
pub const R_ARM_MOVW_BREL_NC: u32 = 84;
pub const R_ARM_MOVT_BREL: u32 = 85;
pub const R_ARM_MOVW_BREL: u32 = 86;
pub const R_ARM_THM_MOVW_BREL_NC: u32 = 87;
pub const R_ARM_THM_MOVT_BREL: u32 = 88;
pub const R_ARM_THM_MOVW_BREL: u32 = 89;
pub const R_ARM_TLS_GOTDESC: u32 = 90;
pub const R_ARM_TLS_CALL: u32 = 91;
pub const R_ARM_TLS_DESCSEQ: u32 = 92;
pub const R_ARM_THM_TLS_CALL: u32 = 93;
pub const R_ARM_PLT32_ABS: u32 = 94;
pub const R_ARM_GOT_ABS: u32 = 95;
pub const R_ARM_GOT_PREL: u32 = 96;
pub const R_ARM_GOT_BREL12: u32 = 97;
pub const R_ARM_GOTOFF12: u32 = 98;
pub const R_ARM_GOTRELAX: u32 = 99;
pub const R_ARM_GNU_VTENTRY: u32 = 100;
pub const R_ARM_GNU_VTINHERIT: u32 = 101;
pub const R_ARM_THM_PC11: u32 = 102;
pub const R_ARM_THM_PC9: u32 = 103;
pub const R_ARM_TLS_GD32: u32 = 104;
pub const R_ARM_TLS_LDM32: u32 = 105;
pub const R_ARM_TLS_LDO32: u32 = 106;
pub const R_ARM_TLS_IE32: u32 = 107;
pub const R_ARM_TLS_LE32: u32 = 108;
pub const R_ARM_TLS_LDO12: u32 = 109;
pub const R_ARM_TLS_LE12: u32 = 110;
pub const R_ARM_TLS_IE12GP: u32 = 111;
pub const R_ARM_ME_TOO: u32 = 128;
pub const R_ARM_THM_TLS_DESCSEQ: u32 = 129;
pub const R_ARM_THM_TLS_DESCSEQ16: u32 = 129;
pub const R_ARM_THM_TLS_DESCSEQ32: u32 = 130;
pub const R_ARM_THM_GOT_BREL12: u32 = 131;
pub const R_ARM_IRELATIVE: u32 = 160;
pub const R_ARM_RXPC25: u32 = 249;
pub const R_ARM_RSBREL32: u32 = 250;
pub const R_ARM_THM_RPC22: u32 = 251;
pub const R_ARM_RREL32: u32 = 252;
pub const R_ARM_RABS22: u32 = 253;
pub const R_ARM_RPC24: u32 = 254;
pub const R_ARM_RBASE: u32 = 255;
pub const R_ARM_NUM: u32 = 256;
pub const EF_IA_64_MASKOS: u32 = 15;
pub const EF_IA_64_ABI64: u32 = 16;
pub const EF_IA_64_ARCH: u32 = 4278190080;
pub const PT_IA_64_ARCHEXT: u32 = 1879048192;
pub const PT_IA_64_UNWIND: u32 = 1879048193;
pub const PT_IA_64_HP_OPT_ANOT: u32 = 1610612754;
pub const PT_IA_64_HP_HSL_ANOT: u32 = 1610612755;
pub const PT_IA_64_HP_STACK: u32 = 1610612756;
pub const PF_IA_64_NORECOV: u32 = 2147483648;
pub const SHT_IA_64_EXT: u32 = 1879048192;
pub const SHT_IA_64_UNWIND: u32 = 1879048193;
pub const SHF_IA_64_SHORT: u32 = 268435456;
pub const SHF_IA_64_NORECOV: u32 = 536870912;
pub const DT_IA_64_PLT_RESERVE: u32 = 1879048192;
pub const DT_IA_64_NUM: u32 = 1;
pub const R_IA64_NONE: u32 = 0;
pub const R_IA64_IMM14: u32 = 33;
pub const R_IA64_IMM22: u32 = 34;
pub const R_IA64_IMM64: u32 = 35;
pub const R_IA64_DIR32MSB: u32 = 36;
pub const R_IA64_DIR32LSB: u32 = 37;
pub const R_IA64_DIR64MSB: u32 = 38;
pub const R_IA64_DIR64LSB: u32 = 39;
pub const R_IA64_GPREL22: u32 = 42;
pub const R_IA64_GPREL64I: u32 = 43;
pub const R_IA64_GPREL32MSB: u32 = 44;
pub const R_IA64_GPREL32LSB: u32 = 45;
pub const R_IA64_GPREL64MSB: u32 = 46;
pub const R_IA64_GPREL64LSB: u32 = 47;
pub const R_IA64_LTOFF22: u32 = 50;
pub const R_IA64_LTOFF64I: u32 = 51;
pub const R_IA64_PLTOFF22: u32 = 58;
pub const R_IA64_PLTOFF64I: u32 = 59;
pub const R_IA64_PLTOFF64MSB: u32 = 62;
pub const R_IA64_PLTOFF64LSB: u32 = 63;
pub const R_IA64_FPTR64I: u32 = 67;
pub const R_IA64_FPTR32MSB: u32 = 68;
pub const R_IA64_FPTR32LSB: u32 = 69;
pub const R_IA64_FPTR64MSB: u32 = 70;
pub const R_IA64_FPTR64LSB: u32 = 71;
pub const R_IA64_PCREL60B: u32 = 72;
pub const R_IA64_PCREL21B: u32 = 73;
pub const R_IA64_PCREL21M: u32 = 74;
pub const R_IA64_PCREL21F: u32 = 75;
pub const R_IA64_PCREL32MSB: u32 = 76;
pub const R_IA64_PCREL32LSB: u32 = 77;
pub const R_IA64_PCREL64MSB: u32 = 78;
pub const R_IA64_PCREL64LSB: u32 = 79;
pub const R_IA64_LTOFF_FPTR22: u32 = 82;
pub const R_IA64_LTOFF_FPTR64I: u32 = 83;
pub const R_IA64_LTOFF_FPTR32MSB: u32 = 84;
pub const R_IA64_LTOFF_FPTR32LSB: u32 = 85;
pub const R_IA64_LTOFF_FPTR64MSB: u32 = 86;
pub const R_IA64_LTOFF_FPTR64LSB: u32 = 87;
pub const R_IA64_SEGREL32MSB: u32 = 92;
pub const R_IA64_SEGREL32LSB: u32 = 93;
pub const R_IA64_SEGREL64MSB: u32 = 94;
pub const R_IA64_SEGREL64LSB: u32 = 95;
pub const R_IA64_SECREL32MSB: u32 = 100;
pub const R_IA64_SECREL32LSB: u32 = 101;
pub const R_IA64_SECREL64MSB: u32 = 102;
pub const R_IA64_SECREL64LSB: u32 = 103;
pub const R_IA64_REL32MSB: u32 = 108;
pub const R_IA64_REL32LSB: u32 = 109;
pub const R_IA64_REL64MSB: u32 = 110;
pub const R_IA64_REL64LSB: u32 = 111;
pub const R_IA64_LTV32MSB: u32 = 116;
pub const R_IA64_LTV32LSB: u32 = 117;
pub const R_IA64_LTV64MSB: u32 = 118;
pub const R_IA64_LTV64LSB: u32 = 119;
pub const R_IA64_PCREL21BI: u32 = 121;
pub const R_IA64_PCREL22: u32 = 122;
pub const R_IA64_PCREL64I: u32 = 123;
pub const R_IA64_IPLTMSB: u32 = 128;
pub const R_IA64_IPLTLSB: u32 = 129;
pub const R_IA64_COPY: u32 = 132;
pub const R_IA64_SUB: u32 = 133;
pub const R_IA64_LTOFF22X: u32 = 134;
pub const R_IA64_LDXMOV: u32 = 135;
pub const R_IA64_TPREL14: u32 = 145;
pub const R_IA64_TPREL22: u32 = 146;
pub const R_IA64_TPREL64I: u32 = 147;
pub const R_IA64_TPREL64MSB: u32 = 150;
pub const R_IA64_TPREL64LSB: u32 = 151;
pub const R_IA64_LTOFF_TPREL22: u32 = 154;
pub const R_IA64_DTPMOD64MSB: u32 = 166;
pub const R_IA64_DTPMOD64LSB: u32 = 167;
pub const R_IA64_LTOFF_DTPMOD22: u32 = 170;
pub const R_IA64_DTPREL14: u32 = 177;
pub const R_IA64_DTPREL22: u32 = 178;
pub const R_IA64_DTPREL64I: u32 = 179;
pub const R_IA64_DTPREL32MSB: u32 = 180;
pub const R_IA64_DTPREL32LSB: u32 = 181;
pub const R_IA64_DTPREL64MSB: u32 = 182;
pub const R_IA64_DTPREL64LSB: u32 = 183;
pub const R_IA64_LTOFF_DTPREL22: u32 = 186;
pub const EF_SH_MACH_MASK: u32 = 31;
pub const EF_SH_UNKNOWN: u32 = 0;
pub const EF_SH1: u32 = 1;
pub const EF_SH2: u32 = 2;
pub const EF_SH3: u32 = 3;
pub const EF_SH_DSP: u32 = 4;
pub const EF_SH3_DSP: u32 = 5;
pub const EF_SH4AL_DSP: u32 = 6;
pub const EF_SH3E: u32 = 8;
pub const EF_SH4: u32 = 9;
pub const EF_SH2E: u32 = 11;
pub const EF_SH4A: u32 = 12;
pub const EF_SH2A: u32 = 13;
pub const EF_SH4_NOFPU: u32 = 16;
pub const EF_SH4A_NOFPU: u32 = 17;
pub const EF_SH4_NOMMU_NOFPU: u32 = 18;
pub const EF_SH2A_NOFPU: u32 = 19;
pub const EF_SH3_NOMMU: u32 = 20;
pub const EF_SH2A_SH4_NOFPU: u32 = 21;
pub const EF_SH2A_SH3_NOFPU: u32 = 22;
pub const EF_SH2A_SH4: u32 = 23;
pub const EF_SH2A_SH3E: u32 = 24;
pub const R_SH_NONE: u32 = 0;
pub const R_SH_DIR32: u32 = 1;
pub const R_SH_REL32: u32 = 2;
pub const R_SH_DIR8WPN: u32 = 3;
pub const R_SH_IND12W: u32 = 4;
pub const R_SH_DIR8WPL: u32 = 5;
pub const R_SH_DIR8WPZ: u32 = 6;
pub const R_SH_DIR8BP: u32 = 7;
pub const R_SH_DIR8W: u32 = 8;
pub const R_SH_DIR8L: u32 = 9;
pub const R_SH_SWITCH16: u32 = 25;
pub const R_SH_SWITCH32: u32 = 26;
pub const R_SH_USES: u32 = 27;
pub const R_SH_COUNT: u32 = 28;
pub const R_SH_ALIGN: u32 = 29;
pub const R_SH_CODE: u32 = 30;
pub const R_SH_DATA: u32 = 31;
pub const R_SH_LABEL: u32 = 32;
pub const R_SH_SWITCH8: u32 = 33;
pub const R_SH_GNU_VTINHERIT: u32 = 34;
pub const R_SH_GNU_VTENTRY: u32 = 35;
pub const R_SH_TLS_GD_32: u32 = 144;
pub const R_SH_TLS_LD_32: u32 = 145;
pub const R_SH_TLS_LDO_32: u32 = 146;
pub const R_SH_TLS_IE_32: u32 = 147;
pub const R_SH_TLS_LE_32: u32 = 148;
pub const R_SH_TLS_DTPMOD32: u32 = 149;
pub const R_SH_TLS_DTPOFF32: u32 = 150;
pub const R_SH_TLS_TPOFF32: u32 = 151;
pub const R_SH_GOT32: u32 = 160;
pub const R_SH_PLT32: u32 = 161;
pub const R_SH_COPY: u32 = 162;
pub const R_SH_GLOB_DAT: u32 = 163;
pub const R_SH_JMP_SLOT: u32 = 164;
pub const R_SH_RELATIVE: u32 = 165;
pub const R_SH_GOTOFF: u32 = 166;
pub const R_SH_GOTPC: u32 = 167;
pub const R_SH_GOT20: u32 = 201;
pub const R_SH_GOTOFF20: u32 = 202;
pub const R_SH_GOTFUNCDESC: u32 = 203;
pub const R_SH_GOTFUNCDEST20: u32 = 204;
pub const R_SH_GOTOFFFUNCDESC: u32 = 205;
pub const R_SH_GOTOFFFUNCDEST20: u32 = 206;
pub const R_SH_FUNCDESC: u32 = 207;
pub const R_SH_FUNCDESC_VALUE: u32 = 208;
pub const R_SH_NUM: u32 = 256;
pub const R_390_NONE: u32 = 0;
pub const R_390_8: u32 = 1;
pub const R_390_12: u32 = 2;
pub const R_390_16: u32 = 3;
pub const R_390_32: u32 = 4;
pub const R_390_PC32: u32 = 5;
pub const R_390_GOT12: u32 = 6;
pub const R_390_GOT32: u32 = 7;
pub const R_390_PLT32: u32 = 8;
pub const R_390_COPY: u32 = 9;
pub const R_390_GLOB_DAT: u32 = 10;
pub const R_390_JMP_SLOT: u32 = 11;
pub const R_390_RELATIVE: u32 = 12;
pub const R_390_GOTOFF32: u32 = 13;
pub const R_390_GOTPC: u32 = 14;
pub const R_390_GOT16: u32 = 15;
pub const R_390_PC16: u32 = 16;
pub const R_390_PC16DBL: u32 = 17;
pub const R_390_PLT16DBL: u32 = 18;
pub const R_390_PC32DBL: u32 = 19;
pub const R_390_PLT32DBL: u32 = 20;
pub const R_390_GOTPCDBL: u32 = 21;
pub const R_390_64: u32 = 22;
pub const R_390_PC64: u32 = 23;
pub const R_390_GOT64: u32 = 24;
pub const R_390_PLT64: u32 = 25;
pub const R_390_GOTENT: u32 = 26;
pub const R_390_GOTOFF16: u32 = 27;
pub const R_390_GOTOFF64: u32 = 28;
pub const R_390_GOTPLT12: u32 = 29;
pub const R_390_GOTPLT16: u32 = 30;
pub const R_390_GOTPLT32: u32 = 31;
pub const R_390_GOTPLT64: u32 = 32;
pub const R_390_GOTPLTENT: u32 = 33;
pub const R_390_PLTOFF16: u32 = 34;
pub const R_390_PLTOFF32: u32 = 35;
pub const R_390_PLTOFF64: u32 = 36;
pub const R_390_TLS_LOAD: u32 = 37;
pub const R_390_TLS_GDCALL: u32 = 38;
pub const R_390_TLS_LDCALL: u32 = 39;
pub const R_390_TLS_GD32: u32 = 40;
pub const R_390_TLS_GD64: u32 = 41;
pub const R_390_TLS_GOTIE12: u32 = 42;
pub const R_390_TLS_GOTIE32: u32 = 43;
pub const R_390_TLS_GOTIE64: u32 = 44;
pub const R_390_TLS_LDM32: u32 = 45;
pub const R_390_TLS_LDM64: u32 = 46;
pub const R_390_TLS_IE32: u32 = 47;
pub const R_390_TLS_IE64: u32 = 48;
pub const R_390_TLS_IEENT: u32 = 49;
pub const R_390_TLS_LE32: u32 = 50;
pub const R_390_TLS_LE64: u32 = 51;
pub const R_390_TLS_LDO32: u32 = 52;
pub const R_390_TLS_LDO64: u32 = 53;
pub const R_390_TLS_DTPMOD: u32 = 54;
pub const R_390_TLS_DTPOFF: u32 = 55;
pub const R_390_TLS_TPOFF: u32 = 56;
pub const R_390_20: u32 = 57;
pub const R_390_GOT20: u32 = 58;
pub const R_390_GOTPLT20: u32 = 59;
pub const R_390_TLS_GOTIE20: u32 = 60;
pub const R_390_NUM: u32 = 61;
pub const R_CRIS_NONE: u32 = 0;
pub const R_CRIS_8: u32 = 1;
pub const R_CRIS_16: u32 = 2;
pub const R_CRIS_32: u32 = 3;
pub const R_CRIS_8_PCREL: u32 = 4;
pub const R_CRIS_16_PCREL: u32 = 5;
pub const R_CRIS_32_PCREL: u32 = 6;
pub const R_CRIS_GNU_VTINHERIT: u32 = 7;
pub const R_CRIS_GNU_VTENTRY: u32 = 8;
pub const R_CRIS_COPY: u32 = 9;
pub const R_CRIS_GLOB_DAT: u32 = 10;
pub const R_CRIS_JUMP_SLOT: u32 = 11;
pub const R_CRIS_RELATIVE: u32 = 12;
pub const R_CRIS_16_GOT: u32 = 13;
pub const R_CRIS_32_GOT: u32 = 14;
pub const R_CRIS_16_GOTPLT: u32 = 15;
pub const R_CRIS_32_GOTPLT: u32 = 16;
pub const R_CRIS_32_GOTREL: u32 = 17;
pub const R_CRIS_32_PLT_GOTREL: u32 = 18;
pub const R_CRIS_32_PLT_PCREL: u32 = 19;
pub const R_CRIS_NUM: u32 = 20;
pub const R_X86_64_NONE: u32 = 0;
pub const R_X86_64_64: u32 = 1;
pub const R_X86_64_PC32: u32 = 2;
pub const R_X86_64_GOT32: u32 = 3;
pub const R_X86_64_PLT32: u32 = 4;
pub const R_X86_64_COPY: u32 = 5;
pub const R_X86_64_GLOB_DAT: u32 = 6;
pub const R_X86_64_JUMP_SLOT: u32 = 7;
pub const R_X86_64_RELATIVE: u32 = 8;
pub const R_X86_64_GOTPCREL: u32 = 9;
pub const R_X86_64_32: u32 = 10;
pub const R_X86_64_32S: u32 = 11;
pub const R_X86_64_16: u32 = 12;
pub const R_X86_64_PC16: u32 = 13;
pub const R_X86_64_8: u32 = 14;
pub const R_X86_64_PC8: u32 = 15;
pub const R_X86_64_DTPMOD64: u32 = 16;
pub const R_X86_64_DTPOFF64: u32 = 17;
pub const R_X86_64_TPOFF64: u32 = 18;
pub const R_X86_64_TLSGD: u32 = 19;
pub const R_X86_64_TLSLD: u32 = 20;
pub const R_X86_64_DTPOFF32: u32 = 21;
pub const R_X86_64_GOTTPOFF: u32 = 22;
pub const R_X86_64_TPOFF32: u32 = 23;
pub const R_X86_64_PC64: u32 = 24;
pub const R_X86_64_GOTOFF64: u32 = 25;
pub const R_X86_64_GOTPC32: u32 = 26;
pub const R_X86_64_GOT64: u32 = 27;
pub const R_X86_64_GOTPCREL64: u32 = 28;
pub const R_X86_64_GOTPC64: u32 = 29;
pub const R_X86_64_GOTPLT64: u32 = 30;
pub const R_X86_64_PLTOFF64: u32 = 31;
pub const R_X86_64_SIZE32: u32 = 32;
pub const R_X86_64_SIZE64: u32 = 33;
pub const R_X86_64_GOTPC32_TLSDESC: u32 = 34;
pub const R_X86_64_TLSDESC_CALL: u32 = 35;
pub const R_X86_64_TLSDESC: u32 = 36;
pub const R_X86_64_IRELATIVE: u32 = 37;
pub const R_X86_64_RELATIVE64: u32 = 38;
pub const R_X86_64_GOTPCRELX: u32 = 41;
pub const R_X86_64_REX_GOTPCRELX: u32 = 42;
pub const R_X86_64_NUM: u32 = 43;
pub const R_MN10300_NONE: u32 = 0;
pub const R_MN10300_32: u32 = 1;
pub const R_MN10300_16: u32 = 2;
pub const R_MN10300_8: u32 = 3;
pub const R_MN10300_PCREL32: u32 = 4;
pub const R_MN10300_PCREL16: u32 = 5;
pub const R_MN10300_PCREL8: u32 = 6;
pub const R_MN10300_GNU_VTINHERIT: u32 = 7;
pub const R_MN10300_GNU_VTENTRY: u32 = 8;
pub const R_MN10300_24: u32 = 9;
pub const R_MN10300_GOTPC32: u32 = 10;
pub const R_MN10300_GOTPC16: u32 = 11;
pub const R_MN10300_GOTOFF32: u32 = 12;
pub const R_MN10300_GOTOFF24: u32 = 13;
pub const R_MN10300_GOTOFF16: u32 = 14;
pub const R_MN10300_PLT32: u32 = 15;
pub const R_MN10300_PLT16: u32 = 16;
pub const R_MN10300_GOT32: u32 = 17;
pub const R_MN10300_GOT24: u32 = 18;
pub const R_MN10300_GOT16: u32 = 19;
pub const R_MN10300_COPY: u32 = 20;
pub const R_MN10300_GLOB_DAT: u32 = 21;
pub const R_MN10300_JMP_SLOT: u32 = 22;
pub const R_MN10300_RELATIVE: u32 = 23;
pub const R_MN10300_NUM: u32 = 24;
pub const R_M32R_NONE: u32 = 0;
pub const R_M32R_16: u32 = 1;
pub const R_M32R_32: u32 = 2;
pub const R_M32R_24: u32 = 3;
pub const R_M32R_10_PCREL: u32 = 4;
pub const R_M32R_18_PCREL: u32 = 5;
pub const R_M32R_26_PCREL: u32 = 6;
pub const R_M32R_HI16_ULO: u32 = 7;
pub const R_M32R_HI16_SLO: u32 = 8;
pub const R_M32R_LO16: u32 = 9;
pub const R_M32R_SDA16: u32 = 10;
pub const R_M32R_GNU_VTINHERIT: u32 = 11;
pub const R_M32R_GNU_VTENTRY: u32 = 12;
pub const R_M32R_16_RELA: u32 = 33;
pub const R_M32R_32_RELA: u32 = 34;
pub const R_M32R_24_RELA: u32 = 35;
pub const R_M32R_10_PCREL_RELA: u32 = 36;
pub const R_M32R_18_PCREL_RELA: u32 = 37;
pub const R_M32R_26_PCREL_RELA: u32 = 38;
pub const R_M32R_HI16_ULO_RELA: u32 = 39;
pub const R_M32R_HI16_SLO_RELA: u32 = 40;
pub const R_M32R_LO16_RELA: u32 = 41;
pub const R_M32R_SDA16_RELA: u32 = 42;
pub const R_M32R_RELA_GNU_VTINHERIT: u32 = 43;
pub const R_M32R_RELA_GNU_VTENTRY: u32 = 44;
pub const R_M32R_REL32: u32 = 45;
pub const R_M32R_GOT24: u32 = 48;
pub const R_M32R_26_PLTREL: u32 = 49;
pub const R_M32R_COPY: u32 = 50;
pub const R_M32R_GLOB_DAT: u32 = 51;
pub const R_M32R_JMP_SLOT: u32 = 52;
pub const R_M32R_RELATIVE: u32 = 53;
pub const R_M32R_GOTOFF: u32 = 54;
pub const R_M32R_GOTPC24: u32 = 55;
pub const R_M32R_GOT16_HI_ULO: u32 = 56;
pub const R_M32R_GOT16_HI_SLO: u32 = 57;
pub const R_M32R_GOT16_LO: u32 = 58;
pub const R_M32R_GOTPC_HI_ULO: u32 = 59;
pub const R_M32R_GOTPC_HI_SLO: u32 = 60;
pub const R_M32R_GOTPC_LO: u32 = 61;
pub const R_M32R_GOTOFF_HI_ULO: u32 = 62;
pub const R_M32R_GOTOFF_HI_SLO: u32 = 63;
pub const R_M32R_GOTOFF_LO: u32 = 64;
pub const R_M32R_NUM: u32 = 256;
pub const R_MICROBLAZE_NONE: u32 = 0;
pub const R_MICROBLAZE_32: u32 = 1;
pub const R_MICROBLAZE_32_PCREL: u32 = 2;
pub const R_MICROBLAZE_64_PCREL: u32 = 3;
pub const R_MICROBLAZE_32_PCREL_LO: u32 = 4;
pub const R_MICROBLAZE_64: u32 = 5;
pub const R_MICROBLAZE_32_LO: u32 = 6;
pub const R_MICROBLAZE_SRO32: u32 = 7;
pub const R_MICROBLAZE_SRW32: u32 = 8;
pub const R_MICROBLAZE_64_NONE: u32 = 9;
pub const R_MICROBLAZE_32_SYM_OP_SYM: u32 = 10;
pub const R_MICROBLAZE_GNU_VTINHERIT: u32 = 11;
pub const R_MICROBLAZE_GNU_VTENTRY: u32 = 12;
pub const R_MICROBLAZE_GOTPC_64: u32 = 13;
pub const R_MICROBLAZE_GOT_64: u32 = 14;
pub const R_MICROBLAZE_PLT_64: u32 = 15;
pub const R_MICROBLAZE_REL: u32 = 16;
pub const R_MICROBLAZE_JUMP_SLOT: u32 = 17;
pub const R_MICROBLAZE_GLOB_DAT: u32 = 18;
pub const R_MICROBLAZE_GOTOFF_64: u32 = 19;
pub const R_MICROBLAZE_GOTOFF_32: u32 = 20;
pub const R_MICROBLAZE_COPY: u32 = 21;
pub const R_MICROBLAZE_TLS: u32 = 22;
pub const R_MICROBLAZE_TLSGD: u32 = 23;
pub const R_MICROBLAZE_TLSLD: u32 = 24;
pub const R_MICROBLAZE_TLSDTPMOD32: u32 = 25;
pub const R_MICROBLAZE_TLSDTPREL32: u32 = 26;
pub const R_MICROBLAZE_TLSDTPREL64: u32 = 27;
pub const R_MICROBLAZE_TLSGOTTPREL32: u32 = 28;
pub const R_MICROBLAZE_TLSTPREL32: u32 = 29;
pub const DT_NIOS2_GP: u32 = 1879048194;
pub const R_NIOS2_NONE: u32 = 0;
pub const R_NIOS2_S16: u32 = 1;
pub const R_NIOS2_U16: u32 = 2;
pub const R_NIOS2_PCREL16: u32 = 3;
pub const R_NIOS2_CALL26: u32 = 4;
pub const R_NIOS2_IMM5: u32 = 5;
pub const R_NIOS2_CACHE_OPX: u32 = 6;
pub const R_NIOS2_IMM6: u32 = 7;
pub const R_NIOS2_IMM8: u32 = 8;
pub const R_NIOS2_HI16: u32 = 9;
pub const R_NIOS2_LO16: u32 = 10;
pub const R_NIOS2_HIADJ16: u32 = 11;
pub const R_NIOS2_BFD_RELOC_32: u32 = 12;
pub const R_NIOS2_BFD_RELOC_16: u32 = 13;
pub const R_NIOS2_BFD_RELOC_8: u32 = 14;
pub const R_NIOS2_GPREL: u32 = 15;
pub const R_NIOS2_GNU_VTINHERIT: u32 = 16;
pub const R_NIOS2_GNU_VTENTRY: u32 = 17;
pub const R_NIOS2_UJMP: u32 = 18;
pub const R_NIOS2_CJMP: u32 = 19;
pub const R_NIOS2_CALLR: u32 = 20;
pub const R_NIOS2_ALIGN: u32 = 21;
pub const R_NIOS2_GOT16: u32 = 22;
pub const R_NIOS2_CALL16: u32 = 23;
pub const R_NIOS2_GOTOFF_LO: u32 = 24;
pub const R_NIOS2_GOTOFF_HA: u32 = 25;
pub const R_NIOS2_PCREL_LO: u32 = 26;
pub const R_NIOS2_PCREL_HA: u32 = 27;
pub const R_NIOS2_TLS_GD16: u32 = 28;
pub const R_NIOS2_TLS_LDM16: u32 = 29;
pub const R_NIOS2_TLS_LDO16: u32 = 30;
pub const R_NIOS2_TLS_IE16: u32 = 31;
pub const R_NIOS2_TLS_LE16: u32 = 32;
pub const R_NIOS2_TLS_DTPMOD: u32 = 33;
pub const R_NIOS2_TLS_DTPREL: u32 = 34;
pub const R_NIOS2_TLS_TPREL: u32 = 35;
pub const R_NIOS2_COPY: u32 = 36;
pub const R_NIOS2_GLOB_DAT: u32 = 37;
pub const R_NIOS2_JUMP_SLOT: u32 = 38;
pub const R_NIOS2_RELATIVE: u32 = 39;
pub const R_NIOS2_GOTOFF: u32 = 40;
pub const R_NIOS2_CALL26_NOAT: u32 = 41;
pub const R_NIOS2_GOT_LO: u32 = 42;
pub const R_NIOS2_GOT_HA: u32 = 43;
pub const R_NIOS2_CALL_LO: u32 = 44;
pub const R_NIOS2_CALL_HA: u32 = 45;
pub const R_OR1K_NONE: u32 = 0;
pub const R_OR1K_32: u32 = 1;
pub const R_OR1K_16: u32 = 2;
pub const R_OR1K_8: u32 = 3;
pub const R_OR1K_LO_16_IN_INSN: u32 = 4;
pub const R_OR1K_HI_16_IN_INSN: u32 = 5;
pub const R_OR1K_INSN_REL_26: u32 = 6;
pub const R_OR1K_GNU_VTENTRY: u32 = 7;
pub const R_OR1K_GNU_VTINHERIT: u32 = 8;
pub const R_OR1K_32_PCREL: u32 = 9;
pub const R_OR1K_16_PCREL: u32 = 10;
pub const R_OR1K_8_PCREL: u32 = 11;
pub const R_OR1K_GOTPC_HI16: u32 = 12;
pub const R_OR1K_GOTPC_LO16: u32 = 13;
pub const R_OR1K_GOT16: u32 = 14;
pub const R_OR1K_PLT26: u32 = 15;
pub const R_OR1K_GOTOFF_HI16: u32 = 16;
pub const R_OR1K_GOTOFF_LO16: u32 = 17;
pub const R_OR1K_COPY: u32 = 18;
pub const R_OR1K_GLOB_DAT: u32 = 19;
pub const R_OR1K_JMP_SLOT: u32 = 20;
pub const R_OR1K_RELATIVE: u32 = 21;
pub const R_OR1K_TLS_GD_HI16: u32 = 22;
pub const R_OR1K_TLS_GD_LO16: u32 = 23;
pub const R_OR1K_TLS_LDM_HI16: u32 = 24;
pub const R_OR1K_TLS_LDM_LO16: u32 = 25;
pub const R_OR1K_TLS_LDO_HI16: u32 = 26;
pub const R_OR1K_TLS_LDO_LO16: u32 = 27;
pub const R_OR1K_TLS_IE_HI16: u32 = 28;
pub const R_OR1K_TLS_IE_LO16: u32 = 29;
pub const R_OR1K_TLS_LE_HI16: u32 = 30;
pub const R_OR1K_TLS_LE_LO16: u32 = 31;
pub const R_OR1K_TLS_TPOFF: u32 = 32;
pub const R_OR1K_TLS_DTPOFF: u32 = 33;
pub const R_OR1K_TLS_DTPMOD: u32 = 34;
pub const R_BPF_NONE: u32 = 0;
pub const R_BPF_MAP_FD: u32 = 1;
pub const ELF_INVALID_ADDRESS: u32 = 4294967295;
pub const FAP_MANIFEST_MAGIC: u32 = 1380402248;
pub const FAP_MANIFEST_SUPPORTED_VERSION: u32 = 1;
pub const FAP_MANIFEST_MAX_APP_NAME_LENGTH: u32 = 32;
pub const FAP_MANIFEST_MAX_ICON_SIZE: u32 = 32;
pub const PROTOCOL_NO: i32 = -1;
pub const PROTOCOL_ALL_FEATURES: u32 = 4294967295;
pub const LFRFID_T5577_BLOCK_COUNT: u32 = 8;
pub const LFRFID_T5577_POR_DELAY: u32 = 1;
pub const LFRFID_T5577_ST_TERMINATOR: u32 = 8;
pub const LFRFID_T5577_PWD: u32 = 16;
pub const LFRFID_T5577_MAXBLOCK_SHIFT: u32 = 5;
pub const LFRFID_T5577_AOR: u32 = 512;
pub const LFRFID_T5577_PSKCF_RF_2: u32 = 0;
pub const LFRFID_T5577_PSKCF_RF_4: u32 = 1024;
pub const LFRFID_T5577_PSKCF_RF_8: u32 = 2048;
pub const LFRFID_T5577_MODULATION_DIRECT: u32 = 0;
pub const LFRFID_T5577_MODULATION_PSK1: u32 = 4096;
pub const LFRFID_T5577_MODULATION_PSK2: u32 = 8192;
pub const LFRFID_T5577_MODULATION_PSK3: u32 = 12288;
pub const LFRFID_T5577_MODULATION_FSK1: u32 = 16384;
pub const LFRFID_T5577_MODULATION_FSK2: u32 = 20480;
pub const LFRFID_T5577_MODULATION_FSK1a: u32 = 24576;
pub const LFRFID_T5577_MODULATION_FSK2a: u32 = 28672;
pub const LFRFID_T5577_MODULATION_MANCHESTER: u32 = 32768;
pub const LFRFID_T5577_MODULATION_BIPHASE: u32 = 65536;
pub const LFRFID_T5577_MODULATION_DIPHASE: u32 = 98304;
pub const LFRFID_T5577_X_MODE: u32 = 131072;
pub const LFRFID_T5577_BITRATE_RF_8: u32 = 0;
pub const LFRFID_T5577_BITRATE_RF_16: u32 = 262144;
pub const LFRFID_T5577_BITRATE_RF_32: u32 = 524288;
pub const LFRFID_T5577_BITRATE_RF_40: u32 = 786432;
pub const LFRFID_T5577_BITRATE_RF_50: u32 = 1048576;
pub const LFRFID_T5577_BITRATE_RF_64: u32 = 1310720;
pub const LFRFID_T5577_BITRATE_RF_100: u32 = 1572864;
pub const LFRFID_T5577_BITRATE_RF_128: u32 = 1835008;
pub const LFRFID_T5577_TESTMODE_DISABLED: u32 = 1610612736;
pub const uECC_arch_other: u32 = 0;
pub const uECC_x86: u32 = 1;
pub const uECC_x86_64: u32 = 2;
pub const uECC_arm: u32 = 3;
pub const uECC_arm_thumb: u32 = 4;
pub const uECC_arm_thumb2: u32 = 5;
pub const uECC_arm64: u32 = 6;
pub const uECC_avr: u32 = 7;
pub const uECC_OPTIMIZATION_LEVEL: u32 = 2;
pub const uECC_SQUARE_FUNC: u32 = 0;
pub const uECC_VLI_NATIVE_LITTLE_ENDIAN: u32 = 0;
pub const uECC_SUPPORTS_secp160r1: u32 = 1;
pub const uECC_SUPPORTS_secp192r1: u32 = 1;
pub const uECC_SUPPORTS_secp224r1: u32 = 1;
pub const uECC_SUPPORTS_secp256r1: u32 = 1;
pub const uECC_SUPPORTS_secp256k1: u32 = 1;
pub const uECC_SUPPORT_COMPRESSED_POINT: u32 = 1;
pub const IBUTTON_KEY_DATA_SIZE: u32 = 8;
pub const IBUTTON_KEY_NAME_SIZE: u32 = 22;
pub const MAXIM_CRC8_INIT: u32 = 0;
pub const OWH_TIMING_A: u32 = 9;
pub const OWH_TIMING_B: u32 = 64;
pub const OWH_TIMING_C: u32 = 64;
pub const OWH_TIMING_D: u32 = 14;
pub const OWH_TIMING_E: u32 = 9;
pub const OWH_TIMING_F: u32 = 55;
pub const OWH_TIMING_G: u32 = 0;
pub const OWH_TIMING_H: u32 = 480;
pub const OWH_TIMING_I: u32 = 70;
pub const OWH_TIMING_J: u32 = 410;
pub const OWH_WRITE_1_DRIVE: u32 = 9;
pub const OWH_WRITE_1_RELEASE: u32 = 64;
pub const OWH_WRITE_0_DRIVE: u32 = 64;
pub const OWH_WRITE_0_RELEASE: u32 = 14;
pub const OWH_READ_DRIVE: u32 = 3;
pub const OWH_READ_RELEASE: u32 = 9;
pub const OWH_READ_DELAY_POST: u32 = 55;
pub const OWH_RESET_DELAY_PRE: u32 = 0;
pub const OWH_RESET_DRIVE: u32 = 480;
pub const OWH_RESET_RELEASE: u32 = 70;
pub const OWH_RESET_DELAY_POST: u32 = 410;
pub const SUBGHZ_APP_EXTENSION: &[u8; 5usize] = b".sub\0";
pub const SUBGHZ_KEY_FILE_VERSION: u32 = 1;
pub const SUBGHZ_KEY_FILE_TYPE: &[u8; 24usize] = b"Flipper SubGhz Key File\0";
pub const SUBGHZ_RAW_FILE_VERSION: u32 = 1;
pub const SUBGHZ_RAW_FILE_TYPE: &[u8; 24usize] = b"Flipper SubGhz RAW File\0";
pub const SUBGHZ_PROTOCOL_RAW_NAME: &[u8; 4usize] = b"RAW\0";
pub const SHA256_DIGEST_SIZE: u32 = 32;
pub const SHA256_BLOCK_SIZE: u32 = 64;
pub type __int8_t = core::ffi::c_schar;
pub type __uint8_t = core::ffi::c_uchar;
pub type __int16_t = core::ffi::c_short;
pub type __uint16_t = core::ffi::c_ushort;
pub type __int32_t = core::ffi::c_int;
pub type __uint32_t = core::ffi::c_uint;
pub type __int64_t = core::ffi::c_longlong;
pub type __uint64_t = core::ffi::c_ulonglong;
pub type __int_least8_t = core::ffi::c_schar;
pub type __uint_least8_t = core::ffi::c_uchar;
pub type __int_least16_t = core::ffi::c_short;
pub type __uint_least16_t = core::ffi::c_ushort;
pub type __int_least32_t = core::ffi::c_int;
pub type __uint_least32_t = core::ffi::c_uint;
pub type __int_least64_t = core::ffi::c_longlong;
pub type __uint_least64_t = core::ffi::c_ulonglong;
pub type __intmax_t = core::ffi::c_longlong;
pub type __uintmax_t = core::ffi::c_ulonglong;
pub type __intptr_t = core::ffi::c_int;
pub type __uintptr_t = core::ffi::c_uint;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
pub type int_least8_t = __int_least8_t;
pub type uint_least8_t = __uint_least8_t;
pub type int_least16_t = __int_least16_t;
pub type uint_least16_t = __uint_least16_t;
pub type int_least32_t = __int_least32_t;
pub type uint_least32_t = __uint_least32_t;
pub type int_least64_t = __int_least64_t;
pub type uint_least64_t = __uint_least64_t;
pub type int_fast8_t = core::ffi::c_schar;
pub type uint_fast8_t = core::ffi::c_uchar;
pub type int_fast16_t = core::ffi::c_short;
pub type uint_fast16_t = core::ffi::c_ushort;
pub type int_fast32_t = core::ffi::c_int;
pub type uint_fast32_t = core::ffi::c_uint;
pub type int_fast64_t = core::ffi::c_longlong;
pub type uint_fast64_t = core::ffi::c_ulonglong;
#[repr(C)]
pub struct Bt {
	_unused: [u8; 0],
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum BtStatus {
	BtStatusUnavailable = 0,
	BtStatusOff = 1,
	BtStatusAdvertising = 2,
	BtStatusConnected = 3,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum BtProfile {
	BtProfileSerial = 0,
	BtProfileHidKeyboard = 1,
}
pub type BtStatusChangedCallback = ::core::option::Option<unsafe extern "C" fn(status: BtStatus, context: *mut core::ffi::c_void)>;
extern "C" {
	#[doc = " Change BLE Profile"]
	#[doc = " @note Call of this function leads to 2nd core restart"]
	#[doc = ""]
	#[doc = " @param bt        Bt instance"]
	#[doc = " @param profile   BtProfile"]
	#[doc = ""]
	#[doc = " @return          true on success"]
	pub fn bt_set_profile(bt: *mut Bt, profile: BtProfile) -> bool;
}
extern "C" {
	#[doc = " Disconnect from Central"]
	#[doc = ""]
	#[doc = " @param bt        Bt instance"]
	pub fn bt_disconnect(bt: *mut Bt);
}
extern "C" {
	#[doc = " Set callback for Bluetooth status change notification"]
	#[doc = ""]
	#[doc = " @param bt        Bt instance"]
	#[doc = " @param callback  BtStatusChangedCallback instance"]
	#[doc = " @param context   pointer to context"]
	pub fn bt_set_status_changed_callback(bt: *mut Bt, callback: BtStatusChangedCallback, context: *mut core::ffi::c_void);
}
extern "C" {
	#[doc = " Forget bonded devices"]
	#[doc = " @note Leads to wipe ble key storage and deleting bt.keys"]
	#[doc = ""]
	#[doc = " @param bt        Bt instance"]
	pub fn bt_forget_bonded_devices(bt: *mut Bt);
}
pub type wchar_t = core::ffi::c_uint;
#[repr(C)]
pub struct max_align_t {
	pub __clang_max_align_nonce1: core::ffi::c_longlong,
	pub __clang_max_align_nonce2: f64,
}
#[test]
fn bindgen_test_layout_max_align_t() {
	assert_eq!(
	           ::core::mem::size_of::<max_align_t>(),
	           16usize,
	           concat!("Size of: ", stringify!(max_align_t))
	);
	assert_eq!(
	           ::core::mem::align_of::<max_align_t>(),
	           8usize,
	           concat!("Alignment of ", stringify!(max_align_t))
	);
	fn test_field___clang_max_align_nonce1() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<max_align_t>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).__clang_max_align_nonce1) as usize - ptr as usize
		           },
		           0usize,
		           concat!(
			"Offset of field: ",
			stringify!(max_align_t),
			"::",
			stringify!(__clang_max_align_nonce1)
		)
		);
	}
	test_field___clang_max_align_nonce1();
	fn test_field___clang_max_align_nonce2() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<max_align_t>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).__clang_max_align_nonce2) as usize - ptr as usize
		           },
		           8usize,
		           concat!(
			"Offset of field: ",
			stringify!(max_align_t),
			"::",
			stringify!(__clang_max_align_nonce2)
		)
		);
	}
	test_field___clang_max_align_nonce2();
}
pub type wint_t = core::ffi::c_int;
pub type __blkcnt_t = core::ffi::c_long;
pub type __blksize_t = core::ffi::c_long;
pub type __fsblkcnt_t = __uint64_t;
pub type __fsfilcnt_t = __uint32_t;
pub type _off_t = core::ffi::c_long;
pub type __pid_t = core::ffi::c_int;
pub type __dev_t = core::ffi::c_short;
pub type __uid_t = core::ffi::c_ushort;
pub type __gid_t = core::ffi::c_ushort;
pub type __id_t = __uint32_t;
pub type __ino_t = core::ffi::c_ushort;
pub type __mode_t = __uint32_t;
pub type _off64_t = core::ffi::c_longlong;
pub type __off_t = _off_t;
pub type __loff_t = _off64_t;
pub type __key_t = core::ffi::c_long;
pub type _fpos_t = core::ffi::c_long;
pub type __size_t = core::ffi::c_uint;
pub type _ssize_t = core::ffi::c_int;
pub type __ssize_t = _ssize_t;
#[repr(C)]
pub struct _mbstate_t {
	pub __count: core::ffi::c_int,
	pub __value: _mbstate_t__bindgen_ty_1,
}
#[repr(C)]
pub struct _mbstate_t__bindgen_ty_1 {
	pub __wch: __BindgenUnionField<wint_t>,
	pub __wchb: __BindgenUnionField<[core::ffi::c_uchar; 4usize]>,
	pub bindgen_union_field: u32,
}
#[test]
fn bindgen_test_layout__mbstate_t__bindgen_ty_1() {
	assert_eq!(
	           ::core::mem::size_of::<_mbstate_t__bindgen_ty_1>(),
	           4usize,
	           concat!("Size of: ", stringify!(_mbstate_t__bindgen_ty_1))
	);
	assert_eq!(
	           ::core::mem::align_of::<_mbstate_t__bindgen_ty_1>(),
	           4usize,
	           concat!("Alignment of ", stringify!(_mbstate_t__bindgen_ty_1))
	);
	fn test_field___wch() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<_mbstate_t__bindgen_ty_1>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).__wch) as usize - ptr as usize
		           },
		           0usize,
		           concat!(
			"Offset of field: ",
			stringify!(_mbstate_t__bindgen_ty_1),
			"::",
			stringify!(__wch)
		)
		);
	}
	test_field___wch();
	fn test_field___wchb() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<_mbstate_t__bindgen_ty_1>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).__wchb) as usize - ptr as usize
		           },
		           0usize,
		           concat!(
			"Offset of field: ",
			stringify!(_mbstate_t__bindgen_ty_1),
			"::",
			stringify!(__wchb)
		)
		);
	}
	test_field___wchb();
}
#[test]
fn bindgen_test_layout__mbstate_t() {
	assert_eq!(
	           ::core::mem::size_of::<_mbstate_t>(),
	           8usize,
	           concat!("Size of: ", stringify!(_mbstate_t))
	);
	assert_eq!(
	           ::core::mem::align_of::<_mbstate_t>(),
	           4usize,
	           concat!("Alignment of ", stringify!(_mbstate_t))
	);
	fn test_field___count() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<_mbstate_t>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).__count) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(_mbstate_t), "::", stringify!(__count))
		);
	}
	test_field___count();
	fn test_field___value() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<_mbstate_t>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).__value) as usize - ptr as usize
		           },
		           4usize,
		           concat!("Offset of field: ", stringify!(_mbstate_t), "::", stringify!(__value))
		);
	}
	test_field___value();
}
pub type _iconv_t = *mut core::ffi::c_void;
pub type __clock_t = core::ffi::c_ulong;
pub type __time_t = __int_least64_t;
pub type __clockid_t = core::ffi::c_ulong;
pub type __timer_t = core::ffi::c_ulong;
pub type __sa_family_t = __uint8_t;
pub type __socklen_t = __uint32_t;
pub type __nl_item = core::ffi::c_int;
pub type __nlink_t = core::ffi::c_ushort;
pub type __suseconds_t = core::ffi::c_long;
pub type __useconds_t = core::ffi::c_ulong;
pub type __va_list = u32;
pub type __ULong = core::ffi::c_ulong;
#[repr(C)]
pub struct __lock {
	_unused: [u8; 0],
}
pub type _LOCK_T = *mut __lock;
extern "C" {
	pub fn __retarget_lock_init(lock: *mut _LOCK_T);
}
extern "C" {
	pub fn __retarget_lock_init_recursive(lock: *mut _LOCK_T);
}
extern "C" {
	pub fn __retarget_lock_close(lock: _LOCK_T);
}
extern "C" {
	pub fn __retarget_lock_close_recursive(lock: _LOCK_T);
}
extern "C" {
	pub fn __retarget_lock_acquire(lock: _LOCK_T);
}
extern "C" {
	pub fn __retarget_lock_acquire_recursive(lock: _LOCK_T);
}
extern "C" {
	pub fn __retarget_lock_try_acquire(lock: _LOCK_T) -> core::ffi::c_int;
}
extern "C" {
	pub fn __retarget_lock_try_acquire_recursive(lock: _LOCK_T) -> core::ffi::c_int;
}
extern "C" {
	pub fn __retarget_lock_release(lock: _LOCK_T);
}
extern "C" {
	pub fn __retarget_lock_release_recursive(lock: _LOCK_T);
}
pub type _flock_t = _LOCK_T;
#[repr(C)]
pub struct __locale_t {
	_unused: [u8; 0],
}
#[repr(C)]
pub struct _Bigint {
	pub _next: *mut _Bigint,
	pub _k: core::ffi::c_int,
	pub _maxwds: core::ffi::c_int,
	pub _sign: core::ffi::c_int,
	pub _wds: core::ffi::c_int,
	pub _x: [__ULong; 1usize],
}
#[test]
fn bindgen_test_layout__Bigint() {
	assert_eq!(
	           ::core::mem::size_of::<_Bigint>(),
	           24usize,
	           concat!("Size of: ", stringify!(_Bigint))
	);
	assert_eq!(
	           ::core::mem::align_of::<_Bigint>(),
	           4usize,
	           concat!("Alignment of ", stringify!(_Bigint))
	);
	fn test_field__next() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<_Bigint>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr)._next) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(_Bigint), "::", stringify!(_next))
		);
	}
	test_field__next();
	fn test_field__k() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<_Bigint>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr)._k) as usize - ptr as usize
		           },
		           4usize,
		           concat!("Offset of field: ", stringify!(_Bigint), "::", stringify!(_k))
		);
	}
	test_field__k();
	fn test_field__maxwds() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<_Bigint>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr)._maxwds) as usize - ptr as usize
		           },
		           8usize,
		           concat!("Offset of field: ", stringify!(_Bigint), "::", stringify!(_maxwds))
		);
	}
	test_field__maxwds();
	fn test_field__sign() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<_Bigint>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr)._sign) as usize - ptr as usize
		           },
		           12usize,
		           concat!("Offset of field: ", stringify!(_Bigint), "::", stringify!(_sign))
		);
	}
	test_field__sign();
	fn test_field__wds() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<_Bigint>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr)._wds) as usize - ptr as usize
		           },
		           16usize,
		           concat!("Offset of field: ", stringify!(_Bigint), "::", stringify!(_wds))
		);
	}
	test_field__wds();
	fn test_field__x() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<_Bigint>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr)._x) as usize - ptr as usize
		           },
		           20usize,
		           concat!("Offset of field: ", stringify!(_Bigint), "::", stringify!(_x))
		);
	}
	test_field__x();
}
#[repr(C)]
pub struct __tm {
	pub __tm_sec: core::ffi::c_int,
	pub __tm_min: core::ffi::c_int,
	pub __tm_hour: core::ffi::c_int,
	pub __tm_mday: core::ffi::c_int,
	pub __tm_mon: core::ffi::c_int,
	pub __tm_year: core::ffi::c_int,
	pub __tm_wday: core::ffi::c_int,
	pub __tm_yday: core::ffi::c_int,
	pub __tm_isdst: core::ffi::c_int,
}
#[test]
fn bindgen_test_layout___tm() {
	assert_eq!(
	           ::core::mem::size_of::<__tm>(),
	           36usize,
	           concat!("Size of: ", stringify!(__tm))
	);
	assert_eq!(
	           ::core::mem::align_of::<__tm>(),
	           4usize,
	           concat!("Alignment of ", stringify!(__tm))
	);
	fn test_field___tm_sec() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<__tm>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).__tm_sec) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(__tm), "::", stringify!(__tm_sec))
		);
	}
	test_field___tm_sec();
	fn test_field___tm_min() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<__tm>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).__tm_min) as usize - ptr as usize
		           },
		           4usize,
		           concat!("Offset of field: ", stringify!(__tm), "::", stringify!(__tm_min))
		);
	}
	test_field___tm_min();
	fn test_field___tm_hour() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<__tm>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).__tm_hour) as usize - ptr as usize
		           },
		           8usize,
		           concat!("Offset of field: ", stringify!(__tm), "::", stringify!(__tm_hour))
		);
	}
	test_field___tm_hour();
	fn test_field___tm_mday() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<__tm>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).__tm_mday) as usize - ptr as usize
		           },
		           12usize,
		           concat!("Offset of field: ", stringify!(__tm), "::", stringify!(__tm_mday))
		);
	}
	test_field___tm_mday();
	fn test_field___tm_mon() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<__tm>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).__tm_mon) as usize - ptr as usize
		           },
		           16usize,
		           concat!("Offset of field: ", stringify!(__tm), "::", stringify!(__tm_mon))
		);
	}
	test_field___tm_mon();
	fn test_field___tm_year() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<__tm>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).__tm_year) as usize - ptr as usize
		           },
		           20usize,
		           concat!("Offset of field: ", stringify!(__tm), "::", stringify!(__tm_year))
		);
	}
	test_field___tm_year();
	fn test_field___tm_wday() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<__tm>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).__tm_wday) as usize - ptr as usize
		           },
		           24usize,
		           concat!("Offset of field: ", stringify!(__tm), "::", stringify!(__tm_wday))
		);
	}
	test_field___tm_wday();
	fn test_field___tm_yday() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<__tm>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).__tm_yday) as usize - ptr as usize
		           },
		           28usize,
		           concat!("Offset of field: ", stringify!(__tm), "::", stringify!(__tm_yday))
		);
	}
	test_field___tm_yday();
	fn test_field___tm_isdst() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<__tm>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).__tm_isdst) as usize - ptr as usize
		           },
		           32usize,
		           concat!("Offset of field: ", stringify!(__tm), "::", stringify!(__tm_isdst))
		);
	}
	test_field___tm_isdst();
}
#[repr(C)]
pub struct _on_exit_args {
	pub _fnargs: [*mut core::ffi::c_void; 32usize],
	pub _dso_handle: [*mut core::ffi::c_void; 32usize],
	pub _fntypes: __ULong,
	pub _is_cxa: __ULong,
}
#[test]
fn bindgen_test_layout__on_exit_args() {
	assert_eq!(
	           ::core::mem::size_of::<_on_exit_args>(),
	           264usize,
	           concat!("Size of: ", stringify!(_on_exit_args))
	);
	assert_eq!(
	           ::core::mem::align_of::<_on_exit_args>(),
	           4usize,
	           concat!("Alignment of ", stringify!(_on_exit_args))
	);
	fn test_field__fnargs() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<_on_exit_args>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr)._fnargs) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(_on_exit_args), "::", stringify!(_fnargs))
		);
	}
	test_field__fnargs();
	fn test_field__dso_handle() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<_on_exit_args>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr)._dso_handle) as usize - ptr as usize
		           },
		           128usize,
		           concat!("Offset of field: ", stringify!(_on_exit_args), "::", stringify!(_dso_handle))
		);
	}
	test_field__dso_handle();
	fn test_field__fntypes() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<_on_exit_args>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr)._fntypes) as usize - ptr as usize
		           },
		           256usize,
		           concat!("Offset of field: ", stringify!(_on_exit_args), "::", stringify!(_fntypes))
		);
	}
	test_field__fntypes();
	fn test_field__is_cxa() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<_on_exit_args>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr)._is_cxa) as usize - ptr as usize
		           },
		           260usize,
		           concat!("Offset of field: ", stringify!(_on_exit_args), "::", stringify!(_is_cxa))
		);
	}
	test_field__is_cxa();
}
#[repr(C)]
pub struct _atexit {
	pub _next: *mut _atexit,
	pub _ind: core::ffi::c_int,
	pub _fns: [::core::option::Option<unsafe extern "C" fn()>; 32usize],
	pub _on_exit_args: _on_exit_args,
}
#[test]
fn bindgen_test_layout__atexit() {
	assert_eq!(
	           ::core::mem::size_of::<_atexit>(),
	           400usize,
	           concat!("Size of: ", stringify!(_atexit))
	);
	assert_eq!(
	           ::core::mem::align_of::<_atexit>(),
	           4usize,
	           concat!("Alignment of ", stringify!(_atexit))
	);
	fn test_field__next() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<_atexit>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr)._next) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(_atexit), "::", stringify!(_next))
		);
	}
	test_field__next();
	fn test_field__ind() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<_atexit>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr)._ind) as usize - ptr as usize
		           },
		           4usize,
		           concat!("Offset of field: ", stringify!(_atexit), "::", stringify!(_ind))
		);
	}
	test_field__ind();
	fn test_field__fns() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<_atexit>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr)._fns) as usize - ptr as usize
		           },
		           8usize,
		           concat!("Offset of field: ", stringify!(_atexit), "::", stringify!(_fns))
		);
	}
	test_field__fns();
	fn test_field__on_exit_args() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<_atexit>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr)._on_exit_args) as usize - ptr as usize
		           },
		           136usize,
		           concat!("Offset of field: ", stringify!(_atexit), "::", stringify!(_on_exit_args))
		);
	}
	test_field__on_exit_args();
}
#[repr(C)]
pub struct __sbuf {
	pub _base: *mut core::ffi::c_uchar,
	pub _size: core::ffi::c_int,
}
#[test]
fn bindgen_test_layout___sbuf() {
	assert_eq!(
	           ::core::mem::size_of::<__sbuf>(),
	           8usize,
	           concat!("Size of: ", stringify!(__sbuf))
	);
	assert_eq!(
	           ::core::mem::align_of::<__sbuf>(),
	           4usize,
	           concat!("Alignment of ", stringify!(__sbuf))
	);
	fn test_field__base() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<__sbuf>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr)._base) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(__sbuf), "::", stringify!(_base))
		);
	}
	test_field__base();
	fn test_field__size() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<__sbuf>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr)._size) as usize - ptr as usize
		           },
		           4usize,
		           concat!("Offset of field: ", stringify!(__sbuf), "::", stringify!(_size))
		);
	}
	test_field__size();
}
#[repr(C)]
pub struct __sFILE {
	pub _p: *mut core::ffi::c_uchar,
	pub _r: core::ffi::c_int,
	pub _w: core::ffi::c_int,
	pub _flags: core::ffi::c_short,
	pub _file: core::ffi::c_short,
	pub _bf: __sbuf,
	pub _lbfsize: core::ffi::c_int,
	pub _cookie: *mut core::ffi::c_void,
	pub _read: ::core::option::Option<unsafe extern "C" fn(arg1: *mut _reent,
	                                                       arg2: *mut core::ffi::c_void,
	                                                       arg3: *mut core::ffi::c_char,
	                                                       arg4: core::ffi::c_int)
	                                                       -> core::ffi::c_int>,
	pub _write: ::core::option::Option<unsafe extern "C" fn(arg1: *mut _reent,
	                                                        arg2: *mut core::ffi::c_void,
	                                                        arg3: *const core::ffi::c_char,
	                                                        arg4: core::ffi::c_int)
	                                                        -> core::ffi::c_int>,
	pub _seek: ::core::option::Option<unsafe extern "C" fn(arg1: *mut _reent,
	                                                       arg2: *mut core::ffi::c_void,
	                                                       arg3: _fpos_t,
	                                                       arg4: core::ffi::c_int)
	                                                       -> _fpos_t>,
	pub _close: ::core::option::Option<unsafe extern "C" fn(arg1: *mut _reent, arg2: *mut core::ffi::c_void) -> core::ffi::c_int>,
	pub _ub: __sbuf,
	pub _up: *mut core::ffi::c_uchar,
	pub _ur: core::ffi::c_int,
	pub _ubuf: [core::ffi::c_uchar; 3usize],
	pub _nbuf: [core::ffi::c_uchar; 1usize],
	pub _lb: __sbuf,
	pub _blksize: core::ffi::c_int,
	pub _offset: _off_t,
	pub _data: *mut _reent,
	pub _lock: _flock_t,
	pub _mbstate: _mbstate_t,
	pub _flags2: core::ffi::c_int,
}
#[test]
fn bindgen_test_layout___sFILE() {
	assert_eq!(
	           ::core::mem::size_of::<__sFILE>(),
	           104usize,
	           concat!("Size of: ", stringify!(__sFILE))
	);
	assert_eq!(
	           ::core::mem::align_of::<__sFILE>(),
	           4usize,
	           concat!("Alignment of ", stringify!(__sFILE))
	);
	fn test_field__p() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<__sFILE>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr)._p) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(__sFILE), "::", stringify!(_p))
		);
	}
	test_field__p();
	fn test_field__r() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<__sFILE>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr)._r) as usize - ptr as usize
		           },
		           4usize,
		           concat!("Offset of field: ", stringify!(__sFILE), "::", stringify!(_r))
		);
	}
	test_field__r();
	fn test_field__w() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<__sFILE>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr)._w) as usize - ptr as usize
		           },
		           8usize,
		           concat!("Offset of field: ", stringify!(__sFILE), "::", stringify!(_w))
		);
	}
	test_field__w();
	fn test_field__flags() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<__sFILE>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr)._flags) as usize - ptr as usize
		           },
		           12usize,
		           concat!("Offset of field: ", stringify!(__sFILE), "::", stringify!(_flags))
		);
	}
	test_field__flags();
	fn test_field__file() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<__sFILE>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr)._file) as usize - ptr as usize
		           },
		           14usize,
		           concat!("Offset of field: ", stringify!(__sFILE), "::", stringify!(_file))
		);
	}
	test_field__file();
	fn test_field__bf() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<__sFILE>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr)._bf) as usize - ptr as usize
		           },
		           16usize,
		           concat!("Offset of field: ", stringify!(__sFILE), "::", stringify!(_bf))
		);
	}
	test_field__bf();
	fn test_field__lbfsize() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<__sFILE>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr)._lbfsize) as usize - ptr as usize
		           },
		           24usize,
		           concat!("Offset of field: ", stringify!(__sFILE), "::", stringify!(_lbfsize))
		);
	}
	test_field__lbfsize();
	fn test_field__cookie() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<__sFILE>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr)._cookie) as usize - ptr as usize
		           },
		           28usize,
		           concat!("Offset of field: ", stringify!(__sFILE), "::", stringify!(_cookie))
		);
	}
	test_field__cookie();
	fn test_field__read() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<__sFILE>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr)._read) as usize - ptr as usize
		           },
		           32usize,
		           concat!("Offset of field: ", stringify!(__sFILE), "::", stringify!(_read))
		);
	}
	test_field__read();
	fn test_field__write() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<__sFILE>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr)._write) as usize - ptr as usize
		           },
		           36usize,
		           concat!("Offset of field: ", stringify!(__sFILE), "::", stringify!(_write))
		);
	}
	test_field__write();
	fn test_field__seek() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<__sFILE>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr)._seek) as usize - ptr as usize
		           },
		           40usize,
		           concat!("Offset of field: ", stringify!(__sFILE), "::", stringify!(_seek))
		);
	}
	test_field__seek();
	fn test_field__close() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<__sFILE>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr)._close) as usize - ptr as usize
		           },
		           44usize,
		           concat!("Offset of field: ", stringify!(__sFILE), "::", stringify!(_close))
		);
	}
	test_field__close();
	fn test_field__ub() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<__sFILE>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr)._ub) as usize - ptr as usize
		           },
		           48usize,
		           concat!("Offset of field: ", stringify!(__sFILE), "::", stringify!(_ub))
		);
	}
	test_field__ub();
	fn test_field__up() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<__sFILE>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr)._up) as usize - ptr as usize
		           },
		           56usize,
		           concat!("Offset of field: ", stringify!(__sFILE), "::", stringify!(_up))
		);
	}
	test_field__up();
	fn test_field__ur() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<__sFILE>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr)._ur) as usize - ptr as usize
		           },
		           60usize,
		           concat!("Offset of field: ", stringify!(__sFILE), "::", stringify!(_ur))
		);
	}
	test_field__ur();
	fn test_field__ubuf() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<__sFILE>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr)._ubuf) as usize - ptr as usize
		           },
		           64usize,
		           concat!("Offset of field: ", stringify!(__sFILE), "::", stringify!(_ubuf))
		);
	}
	test_field__ubuf();
	fn test_field__nbuf() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<__sFILE>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr)._nbuf) as usize - ptr as usize
		           },
		           67usize,
		           concat!("Offset of field: ", stringify!(__sFILE), "::", stringify!(_nbuf))
		);
	}
	test_field__nbuf();
	fn test_field__lb() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<__sFILE>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr)._lb) as usize - ptr as usize
		           },
		           68usize,
		           concat!("Offset of field: ", stringify!(__sFILE), "::", stringify!(_lb))
		);
	}
	test_field__lb();
	fn test_field__blksize() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<__sFILE>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr)._blksize) as usize - ptr as usize
		           },
		           76usize,
		           concat!("Offset of field: ", stringify!(__sFILE), "::", stringify!(_blksize))
		);
	}
	test_field__blksize();
	fn test_field__offset() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<__sFILE>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr)._offset) as usize - ptr as usize
		           },
		           80usize,
		           concat!("Offset of field: ", stringify!(__sFILE), "::", stringify!(_offset))
		);
	}
	test_field__offset();
	fn test_field__data() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<__sFILE>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr)._data) as usize - ptr as usize
		           },
		           84usize,
		           concat!("Offset of field: ", stringify!(__sFILE), "::", stringify!(_data))
		);
	}
	test_field__data();
	fn test_field__lock() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<__sFILE>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr)._lock) as usize - ptr as usize
		           },
		           88usize,
		           concat!("Offset of field: ", stringify!(__sFILE), "::", stringify!(_lock))
		);
	}
	test_field__lock();
	fn test_field__mbstate() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<__sFILE>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr)._mbstate) as usize - ptr as usize
		           },
		           92usize,
		           concat!("Offset of field: ", stringify!(__sFILE), "::", stringify!(_mbstate))
		);
	}
	test_field__mbstate();
	fn test_field__flags2() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<__sFILE>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr)._flags2) as usize - ptr as usize
		           },
		           100usize,
		           concat!("Offset of field: ", stringify!(__sFILE), "::", stringify!(_flags2))
		);
	}
	test_field__flags2();
}
pub type __FILE = __sFILE;
#[repr(C)]
pub struct _glue {
	pub _next: *mut _glue,
	pub _niobs: core::ffi::c_int,
	pub _iobs: *mut __FILE,
}
#[test]
fn bindgen_test_layout__glue() {
	assert_eq!(
	           ::core::mem::size_of::<_glue>(),
	           12usize,
	           concat!("Size of: ", stringify!(_glue))
	);
	assert_eq!(
	           ::core::mem::align_of::<_glue>(),
	           4usize,
	           concat!("Alignment of ", stringify!(_glue))
	);
	fn test_field__next() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<_glue>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr)._next) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(_glue), "::", stringify!(_next))
		);
	}
	test_field__next();
	fn test_field__niobs() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<_glue>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr)._niobs) as usize - ptr as usize
		           },
		           4usize,
		           concat!("Offset of field: ", stringify!(_glue), "::", stringify!(_niobs))
		);
	}
	test_field__niobs();
	fn test_field__iobs() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<_glue>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr)._iobs) as usize - ptr as usize
		           },
		           8usize,
		           concat!("Offset of field: ", stringify!(_glue), "::", stringify!(_iobs))
		);
	}
	test_field__iobs();
}
#[repr(C)]
pub struct _rand48 {
	pub _seed: [core::ffi::c_ushort; 3usize],
	pub _mult: [core::ffi::c_ushort; 3usize],
	pub _add: core::ffi::c_ushort,
}
#[test]
fn bindgen_test_layout__rand48() {
	assert_eq!(
	           ::core::mem::size_of::<_rand48>(),
	           14usize,
	           concat!("Size of: ", stringify!(_rand48))
	);
	assert_eq!(
	           ::core::mem::align_of::<_rand48>(),
	           2usize,
	           concat!("Alignment of ", stringify!(_rand48))
	);
	fn test_field__seed() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<_rand48>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr)._seed) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(_rand48), "::", stringify!(_seed))
		);
	}
	test_field__seed();
	fn test_field__mult() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<_rand48>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr)._mult) as usize - ptr as usize
		           },
		           6usize,
		           concat!("Offset of field: ", stringify!(_rand48), "::", stringify!(_mult))
		);
	}
	test_field__mult();
	fn test_field__add() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<_rand48>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr)._add) as usize - ptr as usize
		           },
		           12usize,
		           concat!("Offset of field: ", stringify!(_rand48), "::", stringify!(_add))
		);
	}
	test_field__add();
}
#[repr(C)]
pub struct _reent {
	pub _errno: core::ffi::c_int,
	pub _stdin: *mut __FILE,
	pub _stdout: *mut __FILE,
	pub _stderr: *mut __FILE,
	pub _inc: core::ffi::c_int,
	pub _emergency: [core::ffi::c_char; 25usize],
	pub _unspecified_locale_info: core::ffi::c_int,
	pub _locale: *mut __locale_t,
	pub __sdidinit: core::ffi::c_int,
	pub __cleanup: ::core::option::Option<unsafe extern "C" fn(arg1: *mut _reent)>,
	pub _result: *mut _Bigint,
	pub _result_k: core::ffi::c_int,
	pub _p5s: *mut _Bigint,
	pub _freelist: *mut *mut _Bigint,
	pub _cvtlen: core::ffi::c_int,
	pub _cvtbuf: *mut core::ffi::c_char,
	pub _new: _reent__bindgen_ty_1,
	pub _atexit: *mut _atexit,
	pub _atexit0: _atexit,
	pub _sig_func: *mut ::core::option::Option<unsafe extern "C" fn(arg1: core::ffi::c_int)>,
	pub __sglue: _glue,
	pub __sf: [__FILE; 3usize],
}
#[repr(C)]
pub struct _reent__bindgen_ty_1 {
	pub _reent: __BindgenUnionField<_reent__bindgen_ty_1__bindgen_ty_1>,
	pub _unused: __BindgenUnionField<_reent__bindgen_ty_1__bindgen_ty_2>,
	pub bindgen_union_field: [u64; 30usize],
}
#[repr(C)]
pub struct _reent__bindgen_ty_1__bindgen_ty_1 {
	pub _unused_rand: core::ffi::c_uint,
	pub _strtok_last: *mut core::ffi::c_char,
	pub _asctime_buf: [core::ffi::c_char; 26usize],
	pub _localtime_buf: __tm,
	pub _gamma_signgam: core::ffi::c_int,
	pub _rand_next: core::ffi::c_ulonglong,
	pub _r48: _rand48,
	pub _mblen_state: _mbstate_t,
	pub _mbtowc_state: _mbstate_t,
	pub _wctomb_state: _mbstate_t,
	pub _l64a_buf: [core::ffi::c_char; 8usize],
	pub _signal_buf: [core::ffi::c_char; 24usize],
	pub _getdate_err: core::ffi::c_int,
	pub _mbrlen_state: _mbstate_t,
	pub _mbrtowc_state: _mbstate_t,
	pub _mbsrtowcs_state: _mbstate_t,
	pub _wcrtomb_state: _mbstate_t,
	pub _wcsrtombs_state: _mbstate_t,
	pub _h_errno: core::ffi::c_int,
}
#[test]
fn bindgen_test_layout__reent__bindgen_ty_1__bindgen_ty_1() {
	assert_eq!(
	           ::core::mem::size_of::<_reent__bindgen_ty_1__bindgen_ty_1>(),
	           208usize,
	           concat!("Size of: ", stringify!(_reent__bindgen_ty_1__bindgen_ty_1))
	);
	assert_eq!(
	           ::core::mem::align_of::<_reent__bindgen_ty_1__bindgen_ty_1>(),
	           8usize,
	           concat!("Alignment of ", stringify!(_reent__bindgen_ty_1__bindgen_ty_1))
	);
	fn test_field__unused_rand() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<_reent__bindgen_ty_1__bindgen_ty_1>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr)._unused_rand) as usize - ptr as usize
		           },
		           0usize,
		           concat!(
			"Offset of field: ",
			stringify!(_reent__bindgen_ty_1__bindgen_ty_1),
			"::",
			stringify!(_unused_rand)
		)
		);
	}
	test_field__unused_rand();
	fn test_field__strtok_last() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<_reent__bindgen_ty_1__bindgen_ty_1>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr)._strtok_last) as usize - ptr as usize
		           },
		           4usize,
		           concat!(
			"Offset of field: ",
			stringify!(_reent__bindgen_ty_1__bindgen_ty_1),
			"::",
			stringify!(_strtok_last)
		)
		);
	}
	test_field__strtok_last();
	fn test_field__asctime_buf() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<_reent__bindgen_ty_1__bindgen_ty_1>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr)._asctime_buf) as usize - ptr as usize
		           },
		           8usize,
		           concat!(
			"Offset of field: ",
			stringify!(_reent__bindgen_ty_1__bindgen_ty_1),
			"::",
			stringify!(_asctime_buf)
		)
		);
	}
	test_field__asctime_buf();
	fn test_field__localtime_buf() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<_reent__bindgen_ty_1__bindgen_ty_1>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr)._localtime_buf) as usize - ptr as usize
		           },
		           36usize,
		           concat!(
			"Offset of field: ",
			stringify!(_reent__bindgen_ty_1__bindgen_ty_1),
			"::",
			stringify!(_localtime_buf)
		)
		);
	}
	test_field__localtime_buf();
	fn test_field__gamma_signgam() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<_reent__bindgen_ty_1__bindgen_ty_1>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr)._gamma_signgam) as usize - ptr as usize
		           },
		           72usize,
		           concat!(
			"Offset of field: ",
			stringify!(_reent__bindgen_ty_1__bindgen_ty_1),
			"::",
			stringify!(_gamma_signgam)
		)
		);
	}
	test_field__gamma_signgam();
	fn test_field__rand_next() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<_reent__bindgen_ty_1__bindgen_ty_1>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr)._rand_next) as usize - ptr as usize
		           },
		           80usize,
		           concat!(
			"Offset of field: ",
			stringify!(_reent__bindgen_ty_1__bindgen_ty_1),
			"::",
			stringify!(_rand_next)
		)
		);
	}
	test_field__rand_next();
	fn test_field__r48() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<_reent__bindgen_ty_1__bindgen_ty_1>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr)._r48) as usize - ptr as usize
		           },
		           88usize,
		           concat!(
			"Offset of field: ",
			stringify!(_reent__bindgen_ty_1__bindgen_ty_1),
			"::",
			stringify!(_r48)
		)
		);
	}
	test_field__r48();
	fn test_field__mblen_state() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<_reent__bindgen_ty_1__bindgen_ty_1>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr)._mblen_state) as usize - ptr as usize
		           },
		           104usize,
		           concat!(
			"Offset of field: ",
			stringify!(_reent__bindgen_ty_1__bindgen_ty_1),
			"::",
			stringify!(_mblen_state)
		)
		);
	}
	test_field__mblen_state();
	fn test_field__mbtowc_state() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<_reent__bindgen_ty_1__bindgen_ty_1>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr)._mbtowc_state) as usize - ptr as usize
		           },
		           112usize,
		           concat!(
			"Offset of field: ",
			stringify!(_reent__bindgen_ty_1__bindgen_ty_1),
			"::",
			stringify!(_mbtowc_state)
		)
		);
	}
	test_field__mbtowc_state();
	fn test_field__wctomb_state() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<_reent__bindgen_ty_1__bindgen_ty_1>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr)._wctomb_state) as usize - ptr as usize
		           },
		           120usize,
		           concat!(
			"Offset of field: ",
			stringify!(_reent__bindgen_ty_1__bindgen_ty_1),
			"::",
			stringify!(_wctomb_state)
		)
		);
	}
	test_field__wctomb_state();
	fn test_field__l64a_buf() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<_reent__bindgen_ty_1__bindgen_ty_1>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr)._l64a_buf) as usize - ptr as usize
		           },
		           128usize,
		           concat!(
			"Offset of field: ",
			stringify!(_reent__bindgen_ty_1__bindgen_ty_1),
			"::",
			stringify!(_l64a_buf)
		)
		);
	}
	test_field__l64a_buf();
	fn test_field__signal_buf() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<_reent__bindgen_ty_1__bindgen_ty_1>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr)._signal_buf) as usize - ptr as usize
		           },
		           136usize,
		           concat!(
			"Offset of field: ",
			stringify!(_reent__bindgen_ty_1__bindgen_ty_1),
			"::",
			stringify!(_signal_buf)
		)
		);
	}
	test_field__signal_buf();
	fn test_field__getdate_err() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<_reent__bindgen_ty_1__bindgen_ty_1>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr)._getdate_err) as usize - ptr as usize
		           },
		           160usize,
		           concat!(
			"Offset of field: ",
			stringify!(_reent__bindgen_ty_1__bindgen_ty_1),
			"::",
			stringify!(_getdate_err)
		)
		);
	}
	test_field__getdate_err();
	fn test_field__mbrlen_state() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<_reent__bindgen_ty_1__bindgen_ty_1>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr)._mbrlen_state) as usize - ptr as usize
		           },
		           164usize,
		           concat!(
			"Offset of field: ",
			stringify!(_reent__bindgen_ty_1__bindgen_ty_1),
			"::",
			stringify!(_mbrlen_state)
		)
		);
	}
	test_field__mbrlen_state();
	fn test_field__mbrtowc_state() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<_reent__bindgen_ty_1__bindgen_ty_1>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr)._mbrtowc_state) as usize - ptr as usize
		           },
		           172usize,
		           concat!(
			"Offset of field: ",
			stringify!(_reent__bindgen_ty_1__bindgen_ty_1),
			"::",
			stringify!(_mbrtowc_state)
		)
		);
	}
	test_field__mbrtowc_state();
	fn test_field__mbsrtowcs_state() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<_reent__bindgen_ty_1__bindgen_ty_1>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr)._mbsrtowcs_state) as usize - ptr as usize
		           },
		           180usize,
		           concat!(
			"Offset of field: ",
			stringify!(_reent__bindgen_ty_1__bindgen_ty_1),
			"::",
			stringify!(_mbsrtowcs_state)
		)
		);
	}
	test_field__mbsrtowcs_state();
	fn test_field__wcrtomb_state() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<_reent__bindgen_ty_1__bindgen_ty_1>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr)._wcrtomb_state) as usize - ptr as usize
		           },
		           188usize,
		           concat!(
			"Offset of field: ",
			stringify!(_reent__bindgen_ty_1__bindgen_ty_1),
			"::",
			stringify!(_wcrtomb_state)
		)
		);
	}
	test_field__wcrtomb_state();
	fn test_field__wcsrtombs_state() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<_reent__bindgen_ty_1__bindgen_ty_1>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr)._wcsrtombs_state) as usize - ptr as usize
		           },
		           196usize,
		           concat!(
			"Offset of field: ",
			stringify!(_reent__bindgen_ty_1__bindgen_ty_1),
			"::",
			stringify!(_wcsrtombs_state)
		)
		);
	}
	test_field__wcsrtombs_state();
	fn test_field__h_errno() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<_reent__bindgen_ty_1__bindgen_ty_1>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr)._h_errno) as usize - ptr as usize
		           },
		           204usize,
		           concat!(
			"Offset of field: ",
			stringify!(_reent__bindgen_ty_1__bindgen_ty_1),
			"::",
			stringify!(_h_errno)
		)
		);
	}
	test_field__h_errno();
}
#[repr(C)]
pub struct _reent__bindgen_ty_1__bindgen_ty_2 {
	pub _nextf: [*mut core::ffi::c_uchar; 30usize],
	pub _nmalloc: [core::ffi::c_uint; 30usize],
}
#[test]
fn bindgen_test_layout__reent__bindgen_ty_1__bindgen_ty_2() {
	assert_eq!(
	           ::core::mem::size_of::<_reent__bindgen_ty_1__bindgen_ty_2>(),
	           240usize,
	           concat!("Size of: ", stringify!(_reent__bindgen_ty_1__bindgen_ty_2))
	);
	assert_eq!(
	           ::core::mem::align_of::<_reent__bindgen_ty_1__bindgen_ty_2>(),
	           4usize,
	           concat!("Alignment of ", stringify!(_reent__bindgen_ty_1__bindgen_ty_2))
	);
	fn test_field__nextf() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<_reent__bindgen_ty_1__bindgen_ty_2>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr)._nextf) as usize - ptr as usize
		           },
		           0usize,
		           concat!(
			"Offset of field: ",
			stringify!(_reent__bindgen_ty_1__bindgen_ty_2),
			"::",
			stringify!(_nextf)
		)
		);
	}
	test_field__nextf();
	fn test_field__nmalloc() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<_reent__bindgen_ty_1__bindgen_ty_2>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr)._nmalloc) as usize - ptr as usize
		           },
		           120usize,
		           concat!(
			"Offset of field: ",
			stringify!(_reent__bindgen_ty_1__bindgen_ty_2),
			"::",
			stringify!(_nmalloc)
		)
		);
	}
	test_field__nmalloc();
}
#[test]
fn bindgen_test_layout__reent__bindgen_ty_1() {
	assert_eq!(
	           ::core::mem::size_of::<_reent__bindgen_ty_1>(),
	           240usize,
	           concat!("Size of: ", stringify!(_reent__bindgen_ty_1))
	);
	assert_eq!(
	           ::core::mem::align_of::<_reent__bindgen_ty_1>(),
	           8usize,
	           concat!("Alignment of ", stringify!(_reent__bindgen_ty_1))
	);
	fn test_field__reent() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<_reent__bindgen_ty_1>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr)._reent) as usize - ptr as usize
		           },
		           0usize,
		           concat!(
			"Offset of field: ",
			stringify!(_reent__bindgen_ty_1),
			"::",
			stringify!(_reent)
		)
		);
	}
	test_field__reent();
	fn test_field__unused() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<_reent__bindgen_ty_1>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr)._unused) as usize - ptr as usize
		           },
		           0usize,
		           concat!(
			"Offset of field: ",
			stringify!(_reent__bindgen_ty_1),
			"::",
			stringify!(_unused)
		)
		);
	}
	test_field__unused();
}
#[test]
fn bindgen_test_layout__reent() {
	assert_eq!(
	           ::core::mem::size_of::<_reent>(),
	           1064usize,
	           concat!("Size of: ", stringify!(_reent))
	);
	assert_eq!(
	           ::core::mem::align_of::<_reent>(),
	           8usize,
	           concat!("Alignment of ", stringify!(_reent))
	);
	fn test_field__errno() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<_reent>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr)._errno) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(_reent), "::", stringify!(_errno))
		);
	}
	test_field__errno();
	fn test_field__stdin() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<_reent>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr)._stdin) as usize - ptr as usize
		           },
		           4usize,
		           concat!("Offset of field: ", stringify!(_reent), "::", stringify!(_stdin))
		);
	}
	test_field__stdin();
	fn test_field__stdout() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<_reent>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr)._stdout) as usize - ptr as usize
		           },
		           8usize,
		           concat!("Offset of field: ", stringify!(_reent), "::", stringify!(_stdout))
		);
	}
	test_field__stdout();
	fn test_field__stderr() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<_reent>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr)._stderr) as usize - ptr as usize
		           },
		           12usize,
		           concat!("Offset of field: ", stringify!(_reent), "::", stringify!(_stderr))
		);
	}
	test_field__stderr();
	fn test_field__inc() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<_reent>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr)._inc) as usize - ptr as usize
		           },
		           16usize,
		           concat!("Offset of field: ", stringify!(_reent), "::", stringify!(_inc))
		);
	}
	test_field__inc();
	fn test_field__emergency() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<_reent>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr)._emergency) as usize - ptr as usize
		           },
		           20usize,
		           concat!("Offset of field: ", stringify!(_reent), "::", stringify!(_emergency))
		);
	}
	test_field__emergency();
	fn test_field__unspecified_locale_info() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<_reent>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr)._unspecified_locale_info) as usize - ptr as usize
		           },
		           48usize,
		           concat!(
			"Offset of field: ",
			stringify!(_reent),
			"::",
			stringify!(_unspecified_locale_info)
		)
		);
	}
	test_field__unspecified_locale_info();
	fn test_field__locale() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<_reent>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr)._locale) as usize - ptr as usize
		           },
		           52usize,
		           concat!("Offset of field: ", stringify!(_reent), "::", stringify!(_locale))
		);
	}
	test_field__locale();
	fn test_field___sdidinit() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<_reent>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).__sdidinit) as usize - ptr as usize
		           },
		           56usize,
		           concat!("Offset of field: ", stringify!(_reent), "::", stringify!(__sdidinit))
		);
	}
	test_field___sdidinit();
	fn test_field___cleanup() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<_reent>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).__cleanup) as usize - ptr as usize
		           },
		           60usize,
		           concat!("Offset of field: ", stringify!(_reent), "::", stringify!(__cleanup))
		);
	}
	test_field___cleanup();
	fn test_field__result() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<_reent>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr)._result) as usize - ptr as usize
		           },
		           64usize,
		           concat!("Offset of field: ", stringify!(_reent), "::", stringify!(_result))
		);
	}
	test_field__result();
	fn test_field__result_k() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<_reent>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr)._result_k) as usize - ptr as usize
		           },
		           68usize,
		           concat!("Offset of field: ", stringify!(_reent), "::", stringify!(_result_k))
		);
	}
	test_field__result_k();
	fn test_field__p5s() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<_reent>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr)._p5s) as usize - ptr as usize
		           },
		           72usize,
		           concat!("Offset of field: ", stringify!(_reent), "::", stringify!(_p5s))
		);
	}
	test_field__p5s();
	fn test_field__freelist() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<_reent>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr)._freelist) as usize - ptr as usize
		           },
		           76usize,
		           concat!("Offset of field: ", stringify!(_reent), "::", stringify!(_freelist))
		);
	}
	test_field__freelist();
	fn test_field__cvtlen() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<_reent>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr)._cvtlen) as usize - ptr as usize
		           },
		           80usize,
		           concat!("Offset of field: ", stringify!(_reent), "::", stringify!(_cvtlen))
		);
	}
	test_field__cvtlen();
	fn test_field__cvtbuf() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<_reent>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr)._cvtbuf) as usize - ptr as usize
		           },
		           84usize,
		           concat!("Offset of field: ", stringify!(_reent), "::", stringify!(_cvtbuf))
		);
	}
	test_field__cvtbuf();
	fn test_field__new() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<_reent>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr)._new) as usize - ptr as usize
		           },
		           88usize,
		           concat!("Offset of field: ", stringify!(_reent), "::", stringify!(_new))
		);
	}
	test_field__new();
	fn test_field__atexit() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<_reent>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr)._atexit) as usize - ptr as usize
		           },
		           328usize,
		           concat!("Offset of field: ", stringify!(_reent), "::", stringify!(_atexit))
		);
	}
	test_field__atexit();
	fn test_field__atexit0() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<_reent>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr)._atexit0) as usize - ptr as usize
		           },
		           332usize,
		           concat!("Offset of field: ", stringify!(_reent), "::", stringify!(_atexit0))
		);
	}
	test_field__atexit0();
	fn test_field__sig_func() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<_reent>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr)._sig_func) as usize - ptr as usize
		           },
		           732usize,
		           concat!("Offset of field: ", stringify!(_reent), "::", stringify!(_sig_func))
		);
	}
	test_field__sig_func();
	fn test_field___sglue() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<_reent>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).__sglue) as usize - ptr as usize
		           },
		           736usize,
		           concat!("Offset of field: ", stringify!(_reent), "::", stringify!(__sglue))
		);
	}
	test_field___sglue();
	fn test_field___sf() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<_reent>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).__sf) as usize - ptr as usize
		           },
		           748usize,
		           concat!("Offset of field: ", stringify!(_reent), "::", stringify!(__sf))
		);
	}
	test_field___sf();
}
extern "C" {
	pub static mut _impure_ptr: *mut _reent;
}
extern "C" {
	pub static _global_impure_ptr: *mut _reent;
}
extern "C" {
	pub fn _reclaim_reent(arg1: *mut _reent);
}
pub type locale_t = *mut __locale_t;
extern "C" {
	pub fn bcmp(arg1: *const core::ffi::c_void, arg2: *const core::ffi::c_void, arg3: core::ffi::c_uint) -> core::ffi::c_int;
}
extern "C" {
	pub fn bcopy(arg1: *const core::ffi::c_void, arg2: *mut core::ffi::c_void, arg3: usize);
}
extern "C" {
	pub fn bzero(arg1: *mut core::ffi::c_void, arg2: core::ffi::c_uint);
}
extern "C" {
	pub fn explicit_bzero(arg1: *mut core::ffi::c_void, arg2: usize);
}
extern "C" {
	pub fn ffs(arg1: core::ffi::c_int) -> core::ffi::c_int;
}
extern "C" {
	pub fn ffsl(arg1: core::ffi::c_long) -> core::ffi::c_int;
}
extern "C" {
	pub fn ffsll(arg1: core::ffi::c_longlong) -> core::ffi::c_int;
}
extern "C" {
	pub fn fls(arg1: core::ffi::c_int) -> core::ffi::c_int;
}
extern "C" {
	pub fn flsl(arg1: core::ffi::c_long) -> core::ffi::c_int;
}
extern "C" {
	pub fn flsll(arg1: core::ffi::c_longlong) -> core::ffi::c_int;
}
extern "C" {
	pub fn index(arg1: *const core::ffi::c_char, arg2: core::ffi::c_int) -> *mut core::ffi::c_char;
}
extern "C" {
	pub fn rindex(arg1: *const core::ffi::c_char, arg2: core::ffi::c_int) -> *mut core::ffi::c_char;
}
extern "C" {
	pub fn strcasecmp(arg1: *const core::ffi::c_char, arg2: *const core::ffi::c_char) -> core::ffi::c_int;
}
extern "C" {
	pub fn strncasecmp(arg1: *const core::ffi::c_char, arg2: *const core::ffi::c_char, arg3: core::ffi::c_uint) -> core::ffi::c_int;
}
extern "C" {
	pub fn strcasecmp_l(arg1: *const core::ffi::c_char, arg2: *const core::ffi::c_char, arg3: locale_t) -> core::ffi::c_int;
}
extern "C" {
	pub fn strncasecmp_l(arg1: *const core::ffi::c_char,
	                     arg2: *const core::ffi::c_char,
	                     arg3: usize,
	                     arg4: locale_t)
	                     -> core::ffi::c_int;
}
extern "C" {
	pub fn memchr(arg1: *const core::ffi::c_void, arg2: core::ffi::c_int, arg3: core::ffi::c_uint) -> *mut core::ffi::c_void;
}
extern "C" {
	pub fn memcmp(arg1: *const core::ffi::c_void, arg2: *const core::ffi::c_void, arg3: core::ffi::c_uint) -> core::ffi::c_int;
}
extern "C" {
	pub fn memcpy(arg1: *mut core::ffi::c_void, arg2: *const core::ffi::c_void, arg3: core::ffi::c_uint) -> *mut core::ffi::c_void;
}
extern "C" {
	pub fn memmove(arg1: *mut core::ffi::c_void, arg2: *const core::ffi::c_void, arg3: core::ffi::c_uint) -> *mut core::ffi::c_void;
}
extern "C" {
	pub fn memset(arg1: *mut core::ffi::c_void, arg2: core::ffi::c_int, arg3: core::ffi::c_uint) -> *mut core::ffi::c_void;
}
extern "C" {
	pub fn strcat(arg1: *mut core::ffi::c_char, arg2: *const core::ffi::c_char) -> *mut core::ffi::c_char;
}
extern "C" {
	pub fn strchr(arg1: *const core::ffi::c_char, arg2: core::ffi::c_int) -> *mut core::ffi::c_char;
}
extern "C" {
	pub fn strcmp(arg1: *const core::ffi::c_char, arg2: *const core::ffi::c_char) -> core::ffi::c_int;
}
extern "C" {
	pub fn strcoll(arg1: *const core::ffi::c_char, arg2: *const core::ffi::c_char) -> core::ffi::c_int;
}
extern "C" {
	pub fn strcpy(arg1: *mut core::ffi::c_char, arg2: *const core::ffi::c_char) -> *mut core::ffi::c_char;
}
extern "C" {
	pub fn strcspn(arg1: *const core::ffi::c_char, arg2: *const core::ffi::c_char) -> core::ffi::c_uint;
}
extern "C" {
	pub fn strerror(arg1: core::ffi::c_int) -> *mut core::ffi::c_char;
}
extern "C" {
	pub fn strlen(arg1: *const core::ffi::c_char) -> core::ffi::c_uint;
}
extern "C" {
	pub fn strncat(arg1: *mut core::ffi::c_char, arg2: *const core::ffi::c_char, arg3: core::ffi::c_uint) -> *mut core::ffi::c_char;
}
extern "C" {
	pub fn strncmp(arg1: *const core::ffi::c_char, arg2: *const core::ffi::c_char, arg3: core::ffi::c_uint) -> core::ffi::c_int;
}
extern "C" {
	pub fn strncpy(arg1: *mut core::ffi::c_char, arg2: *const core::ffi::c_char, arg3: core::ffi::c_uint) -> *mut core::ffi::c_char;
}
extern "C" {
	pub fn strpbrk(arg1: *const core::ffi::c_char, arg2: *const core::ffi::c_char) -> *mut core::ffi::c_char;
}
extern "C" {
	pub fn strrchr(arg1: *const core::ffi::c_char, arg2: core::ffi::c_int) -> *mut core::ffi::c_char;
}
extern "C" {
	pub fn strspn(arg1: *const core::ffi::c_char, arg2: *const core::ffi::c_char) -> core::ffi::c_uint;
}
extern "C" {
	pub fn strstr(arg1: *const core::ffi::c_char, arg2: *const core::ffi::c_char) -> *mut core::ffi::c_char;
}
extern "C" {
	pub fn strtok(arg1: *mut core::ffi::c_char, arg2: *const core::ffi::c_char) -> *mut core::ffi::c_char;
}
extern "C" {
	pub fn strxfrm(arg1: *mut core::ffi::c_char, arg2: *const core::ffi::c_char, arg3: core::ffi::c_uint) -> core::ffi::c_uint;
}
extern "C" {
	pub fn strcoll_l(arg1: *const core::ffi::c_char, arg2: *const core::ffi::c_char, arg3: locale_t) -> core::ffi::c_int;
}
extern "C" {
	pub fn strerror_l(arg1: core::ffi::c_int, arg2: locale_t) -> *mut core::ffi::c_char;
}
extern "C" {
	pub fn strxfrm_l(arg1: *mut core::ffi::c_char, arg2: *const core::ffi::c_char, arg3: usize, arg4: locale_t) -> usize;
}
extern "C" {
	pub fn strtok_r(arg1: *mut core::ffi::c_char,
	                arg2: *const core::ffi::c_char,
	                arg3: *mut *mut core::ffi::c_char)
	                -> *mut core::ffi::c_char;
}
extern "C" {
	pub fn timingsafe_bcmp(arg1: *const core::ffi::c_void, arg2: *const core::ffi::c_void, arg3: usize) -> core::ffi::c_int;
}
extern "C" {
	pub fn timingsafe_memcmp(arg1: *const core::ffi::c_void, arg2: *const core::ffi::c_void, arg3: usize) -> core::ffi::c_int;
}
extern "C" {
	pub fn memccpy(arg1: *mut core::ffi::c_void,
	               arg2: *const core::ffi::c_void,
	               arg3: core::ffi::c_int,
	               arg4: core::ffi::c_uint)
	               -> *mut core::ffi::c_void;
}
extern "C" {
	pub fn stpcpy(arg1: *mut core::ffi::c_char, arg2: *const core::ffi::c_char) -> *mut core::ffi::c_char;
}
extern "C" {
	pub fn stpncpy(arg1: *mut core::ffi::c_char, arg2: *const core::ffi::c_char, arg3: core::ffi::c_uint) -> *mut core::ffi::c_char;
}
extern "C" {
	#[must_use]
	pub fn strdup(arg1: *const core::ffi::c_char) -> *mut core::ffi::c_char;
}
extern "C" {
	pub fn _strdup_r(arg1: *mut _reent, arg2: *const core::ffi::c_char) -> *mut core::ffi::c_char;
}
extern "C" {
	#[must_use]
	pub fn strndup(arg1: *const core::ffi::c_char, arg2: core::ffi::c_uint) -> *mut core::ffi::c_char;
}
extern "C" {
	pub fn _strndup_r(arg1: *mut _reent, arg2: *const core::ffi::c_char, arg3: usize) -> *mut core::ffi::c_char;
}
extern "C" {
	#[link_name = "\u{1}__xpg_strerror_r"]
	pub fn strerror_r(arg1: core::ffi::c_int, arg2: *mut core::ffi::c_char, arg3: usize) -> core::ffi::c_int;
}
extern "C" {
	pub fn _strerror_r(arg1: *mut _reent,
	                   arg2: core::ffi::c_int,
	                   arg3: core::ffi::c_int,
	                   arg4: *mut core::ffi::c_int)
	                   -> *mut core::ffi::c_char;
}
extern "C" {
	pub fn strlcat(arg1: *mut core::ffi::c_char, arg2: *const core::ffi::c_char, arg3: core::ffi::c_uint) -> core::ffi::c_uint;
}
extern "C" {
	pub fn strlcpy(arg1: *mut core::ffi::c_char, arg2: *const core::ffi::c_char, arg3: core::ffi::c_uint) -> core::ffi::c_uint;
}
extern "C" {
	pub fn strnlen(arg1: *const core::ffi::c_char, arg2: usize) -> usize;
}
extern "C" {
	pub fn strsep(arg1: *mut *mut core::ffi::c_char, arg2: *const core::ffi::c_char) -> *mut core::ffi::c_char;
}
extern "C" {
	pub fn strnstr(arg1: *const core::ffi::c_char, arg2: *const core::ffi::c_char, arg3: usize) -> *mut core::ffi::c_char;
}
extern "C" {
	pub fn strlwr(arg1: *mut core::ffi::c_char) -> *mut core::ffi::c_char;
}
extern "C" {
	pub fn strupr(arg1: *mut core::ffi::c_char) -> *mut core::ffi::c_char;
}
extern "C" {
	pub fn strsignal(__signo: core::ffi::c_int) -> *mut core::ffi::c_char;
}
extern "C" {
	pub fn isalnum(__c: core::ffi::c_int) -> core::ffi::c_int;
}
extern "C" {
	pub fn isalpha(__c: core::ffi::c_int) -> core::ffi::c_int;
}
extern "C" {
	pub fn iscntrl(__c: core::ffi::c_int) -> core::ffi::c_int;
}
extern "C" {
	pub fn isdigit(__c: core::ffi::c_int) -> core::ffi::c_int;
}
extern "C" {
	pub fn isgraph(__c: core::ffi::c_int) -> core::ffi::c_int;
}
extern "C" {
	pub fn islower(__c: core::ffi::c_int) -> core::ffi::c_int;
}
extern "C" {
	pub fn isprint(__c: core::ffi::c_int) -> core::ffi::c_int;
}
extern "C" {
	pub fn ispunct(__c: core::ffi::c_int) -> core::ffi::c_int;
}
extern "C" {
	pub fn isspace(__c: core::ffi::c_int) -> core::ffi::c_int;
}
extern "C" {
	pub fn isupper(__c: core::ffi::c_int) -> core::ffi::c_int;
}
extern "C" {
	pub fn isxdigit(__c: core::ffi::c_int) -> core::ffi::c_int;
}
extern "C" {
	pub fn tolower(__c: core::ffi::c_int) -> core::ffi::c_int;
}
extern "C" {
	pub fn toupper(__c: core::ffi::c_int) -> core::ffi::c_int;
}
extern "C" {
	pub fn isblank(__c: core::ffi::c_int) -> core::ffi::c_int;
}
extern "C" {
	pub fn isascii(__c: core::ffi::c_int) -> core::ffi::c_int;
}
extern "C" {
	pub fn toascii(__c: core::ffi::c_int) -> core::ffi::c_int;
}
extern "C" {
	pub fn isalnum_l(__c: core::ffi::c_int, __l: locale_t) -> core::ffi::c_int;
}
extern "C" {
	pub fn isalpha_l(__c: core::ffi::c_int, __l: locale_t) -> core::ffi::c_int;
}
extern "C" {
	pub fn isblank_l(__c: core::ffi::c_int, __l: locale_t) -> core::ffi::c_int;
}
extern "C" {
	pub fn iscntrl_l(__c: core::ffi::c_int, __l: locale_t) -> core::ffi::c_int;
}
extern "C" {
	pub fn isdigit_l(__c: core::ffi::c_int, __l: locale_t) -> core::ffi::c_int;
}
extern "C" {
	pub fn isgraph_l(__c: core::ffi::c_int, __l: locale_t) -> core::ffi::c_int;
}
extern "C" {
	pub fn islower_l(__c: core::ffi::c_int, __l: locale_t) -> core::ffi::c_int;
}
extern "C" {
	pub fn isprint_l(__c: core::ffi::c_int, __l: locale_t) -> core::ffi::c_int;
}
extern "C" {
	pub fn ispunct_l(__c: core::ffi::c_int, __l: locale_t) -> core::ffi::c_int;
}
extern "C" {
	pub fn isspace_l(__c: core::ffi::c_int, __l: locale_t) -> core::ffi::c_int;
}
extern "C" {
	pub fn isupper_l(__c: core::ffi::c_int, __l: locale_t) -> core::ffi::c_int;
}
extern "C" {
	pub fn isxdigit_l(__c: core::ffi::c_int, __l: locale_t) -> core::ffi::c_int;
}
extern "C" {
	pub fn tolower_l(__c: core::ffi::c_int, __l: locale_t) -> core::ffi::c_int;
}
extern "C" {
	pub fn toupper_l(__c: core::ffi::c_int, __l: locale_t) -> core::ffi::c_int;
}
extern "C" {
	pub fn isascii_l(__c: core::ffi::c_int, __l: locale_t) -> core::ffi::c_int;
}
extern "C" {
	pub fn toascii_l(__c: core::ffi::c_int, __l: locale_t) -> core::ffi::c_int;
}
extern "C" {
	pub static mut _ctype_: [core::ffi::c_char; 0usize];
}
#[repr(C)]
pub struct div_t {
	pub quot: core::ffi::c_int,
	pub rem: core::ffi::c_int,
}
#[test]
fn bindgen_test_layout_div_t() {
	assert_eq!(
	           ::core::mem::size_of::<div_t>(),
	           8usize,
	           concat!("Size of: ", stringify!(div_t))
	);
	assert_eq!(
	           ::core::mem::align_of::<div_t>(),
	           4usize,
	           concat!("Alignment of ", stringify!(div_t))
	);
	fn test_field_quot() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<div_t>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).quot) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(div_t), "::", stringify!(quot))
		);
	}
	test_field_quot();
	fn test_field_rem() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<div_t>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).rem) as usize - ptr as usize
		           },
		           4usize,
		           concat!("Offset of field: ", stringify!(div_t), "::", stringify!(rem))
		);
	}
	test_field_rem();
}
#[repr(C)]
pub struct ldiv_t {
	pub quot: core::ffi::c_long,
	pub rem: core::ffi::c_long,
}
#[test]
fn bindgen_test_layout_ldiv_t() {
	assert_eq!(
	           ::core::mem::size_of::<ldiv_t>(),
	           8usize,
	           concat!("Size of: ", stringify!(ldiv_t))
	);
	assert_eq!(
	           ::core::mem::align_of::<ldiv_t>(),
	           4usize,
	           concat!("Alignment of ", stringify!(ldiv_t))
	);
	fn test_field_quot() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<ldiv_t>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).quot) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(ldiv_t), "::", stringify!(quot))
		);
	}
	test_field_quot();
	fn test_field_rem() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<ldiv_t>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).rem) as usize - ptr as usize
		           },
		           4usize,
		           concat!("Offset of field: ", stringify!(ldiv_t), "::", stringify!(rem))
		);
	}
	test_field_rem();
}
#[repr(C)]
pub struct lldiv_t {
	pub quot: core::ffi::c_longlong,
	pub rem: core::ffi::c_longlong,
}
#[test]
fn bindgen_test_layout_lldiv_t() {
	assert_eq!(
	           ::core::mem::size_of::<lldiv_t>(),
	           16usize,
	           concat!("Size of: ", stringify!(lldiv_t))
	);
	assert_eq!(
	           ::core::mem::align_of::<lldiv_t>(),
	           8usize,
	           concat!("Alignment of ", stringify!(lldiv_t))
	);
	fn test_field_quot() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<lldiv_t>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).quot) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(lldiv_t), "::", stringify!(quot))
		);
	}
	test_field_quot();
	fn test_field_rem() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<lldiv_t>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).rem) as usize - ptr as usize
		           },
		           8usize,
		           concat!("Offset of field: ", stringify!(lldiv_t), "::", stringify!(rem))
		);
	}
	test_field_rem();
}
pub type __compar_fn_t =
	::core::option::Option<unsafe extern "C" fn(arg1: *const core::ffi::c_void, arg2: *const core::ffi::c_void) -> core::ffi::c_int>;
extern "C" {
	pub fn __locale_mb_cur_max() -> core::ffi::c_int;
}
extern "C" {
	pub fn abort();
}
extern "C" {
	pub fn abs(arg1: core::ffi::c_int) -> core::ffi::c_int;
}
extern "C" {
	pub fn arc4random() -> __uint32_t;
}
extern "C" {
	pub fn arc4random_uniform(arg1: __uint32_t) -> __uint32_t;
}
extern "C" {
	pub fn arc4random_buf(arg1: *mut core::ffi::c_void, arg2: usize);
}
extern "C" {
	pub fn atexit(__func: ::core::option::Option<unsafe extern "C" fn()>) -> core::ffi::c_int;
}
extern "C" {
	pub fn atof(__nptr: *const core::ffi::c_char) -> core::ffi::c_double;
}
extern "C" {
	pub fn atoff(__nptr: *const core::ffi::c_char) -> core::ffi::c_float;
}
extern "C" {
	pub fn atoi(__nptr: *const core::ffi::c_char) -> core::ffi::c_int;
}
extern "C" {
	pub fn _atoi_r(arg1: *mut _reent, __nptr: *const core::ffi::c_char) -> core::ffi::c_int;
}
extern "C" {
	pub fn atol(__nptr: *const core::ffi::c_char) -> core::ffi::c_long;
}
extern "C" {
	pub fn _atol_r(arg1: *mut _reent, __nptr: *const core::ffi::c_char) -> core::ffi::c_long;
}
extern "C" {
	pub fn bsearch(__key: *const core::ffi::c_void,
	               __base: *const core::ffi::c_void,
	               __nmemb: usize,
	               __size: usize,
	               _compar: __compar_fn_t)
	               -> *mut core::ffi::c_void;
}
extern "C" {
	#[must_use]
	pub fn calloc(arg1: core::ffi::c_uint, arg2: core::ffi::c_uint) -> *mut core::ffi::c_void;
}
extern "C" {
	pub fn div(__numer: core::ffi::c_int, __denom: core::ffi::c_int) -> div_t;
}
extern "C" {
	pub fn exit(__status: core::ffi::c_int);
}
extern "C" {
	pub fn free(arg1: *mut core::ffi::c_void);
}
extern "C" {
	pub fn getenv(__string: *const core::ffi::c_char) -> *mut core::ffi::c_char;
}
extern "C" {
	pub fn _getenv_r(arg1: *mut _reent, __string: *const core::ffi::c_char) -> *mut core::ffi::c_char;
}
extern "C" {
	pub fn _findenv(arg1: *const core::ffi::c_char, arg2: *mut core::ffi::c_int) -> *mut core::ffi::c_char;
}
extern "C" {
	pub fn _findenv_r(arg1: *mut _reent, arg2: *const core::ffi::c_char, arg3: *mut core::ffi::c_int) -> *mut core::ffi::c_char;
}
extern "C" {
	pub static mut suboptarg: *mut core::ffi::c_char;
}
extern "C" {
	pub fn getsubopt(arg1: *mut *mut core::ffi::c_char,
	                 arg2: *const *mut core::ffi::c_char,
	                 arg3: *mut *mut core::ffi::c_char)
	                 -> core::ffi::c_int;
}
extern "C" {
	pub fn labs(arg1: core::ffi::c_long) -> core::ffi::c_long;
}
extern "C" {
	pub fn ldiv(__numer: core::ffi::c_long, __denom: core::ffi::c_long) -> ldiv_t;
}
extern "C" {
	#[must_use]
	pub fn malloc(arg1: core::ffi::c_uint) -> *mut core::ffi::c_void;
}
extern "C" {
	pub fn mblen(arg1: *const core::ffi::c_char, arg2: usize) -> core::ffi::c_int;
}
extern "C" {
	pub fn _mblen_r(arg1: *mut _reent, arg2: *const core::ffi::c_char, arg3: usize, arg4: *mut _mbstate_t) -> core::ffi::c_int;
}
extern "C" {
	pub fn mbtowc(arg1: *mut wchar_t, arg2: *const core::ffi::c_char, arg3: usize) -> core::ffi::c_int;
}
extern "C" {
	pub fn _mbtowc_r(arg1: *mut _reent,
	                 arg2: *mut wchar_t,
	                 arg3: *const core::ffi::c_char,
	                 arg4: usize,
	                 arg5: *mut _mbstate_t)
	                 -> core::ffi::c_int;
}
extern "C" {
	pub fn wctomb(arg1: *mut core::ffi::c_char, arg2: wchar_t) -> core::ffi::c_int;
}
extern "C" {
	pub fn _wctomb_r(arg1: *mut _reent, arg2: *mut core::ffi::c_char, arg3: wchar_t, arg4: *mut _mbstate_t) -> core::ffi::c_int;
}
extern "C" {
	pub fn mbstowcs(arg1: *mut wchar_t, arg2: *const core::ffi::c_char, arg3: usize) -> usize;
}
extern "C" {
	pub fn _mbstowcs_r(arg1: *mut _reent,
	                   arg2: *mut wchar_t,
	                   arg3: *const core::ffi::c_char,
	                   arg4: usize,
	                   arg5: *mut _mbstate_t)
	                   -> usize;
}
extern "C" {
	pub fn wcstombs(arg1: *mut core::ffi::c_char, arg2: *const wchar_t, arg3: usize) -> usize;
}
extern "C" {
	pub fn _wcstombs_r(arg1: *mut _reent,
	                   arg2: *mut core::ffi::c_char,
	                   arg3: *const wchar_t,
	                   arg4: usize,
	                   arg5: *mut _mbstate_t)
	                   -> usize;
}
extern "C" {
	pub fn mkdtemp(arg1: *mut core::ffi::c_char) -> *mut core::ffi::c_char;
}
extern "C" {
	pub fn mkstemp(arg1: *mut core::ffi::c_char) -> core::ffi::c_int;
}
extern "C" {
	pub fn mkstemps(arg1: *mut core::ffi::c_char, arg2: core::ffi::c_int) -> core::ffi::c_int;
}
extern "C" {
	pub fn mktemp(arg1: *mut core::ffi::c_char) -> *mut core::ffi::c_char;
}
extern "C" {
	pub fn _mkdtemp_r(arg1: *mut _reent, arg2: *mut core::ffi::c_char) -> *mut core::ffi::c_char;
}
extern "C" {
	pub fn _mkostemp_r(arg1: *mut _reent, arg2: *mut core::ffi::c_char, arg3: core::ffi::c_int) -> core::ffi::c_int;
}
extern "C" {
	pub fn _mkostemps_r(arg1: *mut _reent,
	                    arg2: *mut core::ffi::c_char,
	                    arg3: core::ffi::c_int,
	                    arg4: core::ffi::c_int)
	                    -> core::ffi::c_int;
}
extern "C" {
	pub fn _mkstemp_r(arg1: *mut _reent, arg2: *mut core::ffi::c_char) -> core::ffi::c_int;
}
extern "C" {
	pub fn _mkstemps_r(arg1: *mut _reent, arg2: *mut core::ffi::c_char, arg3: core::ffi::c_int) -> core::ffi::c_int;
}
extern "C" {
	pub fn _mktemp_r(arg1: *mut _reent, arg2: *mut core::ffi::c_char) -> *mut core::ffi::c_char;
}
extern "C" {
	pub fn qsort(__base: *mut core::ffi::c_void, __nmemb: usize, __size: usize, _compar: __compar_fn_t);
}
extern "C" {
	pub fn rand() -> core::ffi::c_int;
}
extern "C" {
	#[must_use]
	pub fn realloc(arg1: *mut core::ffi::c_void, arg2: core::ffi::c_uint) -> *mut core::ffi::c_void;
}
extern "C" {
	#[must_use]
	pub fn reallocarray(arg1: *mut core::ffi::c_void, arg2: usize, arg3: usize) -> *mut core::ffi::c_void;
}
extern "C" {
	#[must_use]
	pub fn reallocf(arg1: *mut core::ffi::c_void, arg2: usize) -> *mut core::ffi::c_void;
}
extern "C" {
	pub fn realpath(path: *const core::ffi::c_char, resolved_path: *mut core::ffi::c_char) -> *mut core::ffi::c_char;
}
extern "C" {
	pub fn rpmatch(response: *const core::ffi::c_char) -> core::ffi::c_int;
}
extern "C" {
	pub fn srand(__seed: core::ffi::c_uint);
}
extern "C" {
	pub fn strtod(__n: *const core::ffi::c_char, __end_PTR: *mut *mut core::ffi::c_char) -> core::ffi::c_double;
}
extern "C" {
	pub fn _strtod_r(arg1: *mut _reent, __n: *const core::ffi::c_char, __end_PTR: *mut *mut core::ffi::c_char) -> core::ffi::c_double;
}
extern "C" {
	pub fn strtof(__n: *const core::ffi::c_char, __end_PTR: *mut *mut core::ffi::c_char) -> core::ffi::c_float;
}
extern "C" {
	pub fn strtol(__n: *const core::ffi::c_char,
	              __end_PTR: *mut *mut core::ffi::c_char,
	              __base: core::ffi::c_int)
	              -> core::ffi::c_long;
}
extern "C" {
	pub fn _strtol_r(arg1: *mut _reent,
	                 __n: *const core::ffi::c_char,
	                 __end_PTR: *mut *mut core::ffi::c_char,
	                 __base: core::ffi::c_int)
	                 -> core::ffi::c_long;
}
extern "C" {
	pub fn strtoul(__n: *const core::ffi::c_char,
	               __end_PTR: *mut *mut core::ffi::c_char,
	               __base: core::ffi::c_int)
	               -> core::ffi::c_ulong;
}
extern "C" {
	pub fn _strtoul_r(arg1: *mut _reent,
	                  __n: *const core::ffi::c_char,
	                  __end_PTR: *mut *mut core::ffi::c_char,
	                  __base: core::ffi::c_int)
	                  -> core::ffi::c_ulong;
}
extern "C" {
	pub fn system(__string: *const core::ffi::c_char) -> core::ffi::c_int;
}
extern "C" {
	pub fn a64l(__input: *const core::ffi::c_char) -> core::ffi::c_long;
}
extern "C" {
	pub fn l64a(__input: core::ffi::c_long) -> *mut core::ffi::c_char;
}
extern "C" {
	pub fn _l64a_r(arg1: *mut _reent, __input: core::ffi::c_long) -> *mut core::ffi::c_char;
}
extern "C" {
	pub fn on_exit(__func: ::core::option::Option<unsafe extern "C" fn(arg1: core::ffi::c_int, arg2: *mut core::ffi::c_void)>,
	               __arg: *mut core::ffi::c_void)
	               -> core::ffi::c_int;
}
extern "C" {
	pub fn _Exit(__status: core::ffi::c_int);
}
extern "C" {
	pub fn putenv(__string: *mut core::ffi::c_char) -> core::ffi::c_int;
}
extern "C" {
	pub fn _putenv_r(arg1: *mut _reent, __string: *mut core::ffi::c_char) -> core::ffi::c_int;
}
extern "C" {
	pub fn _reallocf_r(arg1: *mut _reent, arg2: *mut core::ffi::c_void, arg3: usize) -> *mut core::ffi::c_void;
}
extern "C" {
	pub fn setenv(__string: *const core::ffi::c_char,
	              __value: *const core::ffi::c_char,
	              __overwrite: core::ffi::c_int)
	              -> core::ffi::c_int;
}
extern "C" {
	pub fn _setenv_r(arg1: *mut _reent,
	                 __string: *const core::ffi::c_char,
	                 __value: *const core::ffi::c_char,
	                 __overwrite: core::ffi::c_int)
	                 -> core::ffi::c_int;
}
extern "C" {
	pub fn __itoa(arg1: core::ffi::c_int, arg2: *mut core::ffi::c_char, arg3: core::ffi::c_int) -> *mut core::ffi::c_char;
}
extern "C" {
	pub fn __utoa(arg1: core::ffi::c_uint, arg2: *mut core::ffi::c_char, arg3: core::ffi::c_int) -> *mut core::ffi::c_char;
}
extern "C" {
	pub fn itoa(arg1: core::ffi::c_int, arg2: *mut core::ffi::c_char, arg3: core::ffi::c_int) -> *mut core::ffi::c_char;
}
extern "C" {
	pub fn utoa(arg1: core::ffi::c_uint, arg2: *mut core::ffi::c_char, arg3: core::ffi::c_int) -> *mut core::ffi::c_char;
}
extern "C" {
	pub fn rand_r(__seed: *mut core::ffi::c_uint) -> core::ffi::c_int;
}
extern "C" {
	pub fn drand48() -> core::ffi::c_double;
}
extern "C" {
	pub fn _drand48_r(arg1: *mut _reent) -> core::ffi::c_double;
}
extern "C" {
	pub fn erand48(arg1: *mut [core::ffi::c_ushort; 3usize]) -> core::ffi::c_double;
}
extern "C" {
	pub fn _erand48_r(arg1: *mut _reent, arg2: *mut [core::ffi::c_ushort; 3usize]) -> core::ffi::c_double;
}
extern "C" {
	pub fn jrand48(arg1: *mut [core::ffi::c_ushort; 3usize]) -> core::ffi::c_long;
}
extern "C" {
	pub fn _jrand48_r(arg1: *mut _reent, arg2: *mut [core::ffi::c_ushort; 3usize]) -> core::ffi::c_long;
}
extern "C" {
	pub fn lcong48(arg1: *mut [core::ffi::c_ushort; 7usize]);
}
extern "C" {
	pub fn _lcong48_r(arg1: *mut _reent, arg2: *mut [core::ffi::c_ushort; 7usize]);
}
extern "C" {
	pub fn lrand48() -> core::ffi::c_long;
}
extern "C" {
	pub fn _lrand48_r(arg1: *mut _reent) -> core::ffi::c_long;
}
extern "C" {
	pub fn mrand48() -> core::ffi::c_long;
}
extern "C" {
	pub fn _mrand48_r(arg1: *mut _reent) -> core::ffi::c_long;
}
extern "C" {
	pub fn nrand48(arg1: *mut [core::ffi::c_ushort; 3usize]) -> core::ffi::c_long;
}
extern "C" {
	pub fn _nrand48_r(arg1: *mut _reent, arg2: *mut [core::ffi::c_ushort; 3usize]) -> core::ffi::c_long;
}
extern "C" {
	pub fn seed48(arg1: *mut [core::ffi::c_ushort; 3usize]) -> *mut core::ffi::c_ushort;
}
extern "C" {
	pub fn _seed48_r(arg1: *mut _reent, arg2: *mut [core::ffi::c_ushort; 3usize]) -> *mut core::ffi::c_ushort;
}
extern "C" {
	pub fn srand48(arg1: core::ffi::c_long);
}
extern "C" {
	pub fn _srand48_r(arg1: *mut _reent, arg2: core::ffi::c_long);
}
extern "C" {
	pub fn initstate(arg1: core::ffi::c_uint, arg2: *mut core::ffi::c_char, arg3: usize) -> *mut core::ffi::c_char;
}
extern "C" {
	pub fn random() -> core::ffi::c_long;
}
extern "C" {
	pub fn setstate(arg1: *mut core::ffi::c_char) -> *mut core::ffi::c_char;
}
extern "C" {
	pub fn srandom(arg1: core::ffi::c_uint);
}
extern "C" {
	pub fn atoll(__nptr: *const core::ffi::c_char) -> core::ffi::c_longlong;
}
extern "C" {
	pub fn _atoll_r(arg1: *mut _reent, __nptr: *const core::ffi::c_char) -> core::ffi::c_longlong;
}
extern "C" {
	pub fn llabs(arg1: core::ffi::c_longlong) -> core::ffi::c_longlong;
}
extern "C" {
	pub fn lldiv(__numer: core::ffi::c_longlong, __denom: core::ffi::c_longlong) -> lldiv_t;
}
extern "C" {
	pub fn strtoll(__n: *const core::ffi::c_char,
	               __end_PTR: *mut *mut core::ffi::c_char,
	               __base: core::ffi::c_int)
	               -> core::ffi::c_longlong;
}
extern "C" {
	pub fn _strtoll_r(arg1: *mut _reent,
	                  __n: *const core::ffi::c_char,
	                  __end_PTR: *mut *mut core::ffi::c_char,
	                  __base: core::ffi::c_int)
	                  -> core::ffi::c_longlong;
}
extern "C" {
	pub fn strtoull(__n: *const core::ffi::c_char,
	                __end_PTR: *mut *mut core::ffi::c_char,
	                __base: core::ffi::c_int)
	                -> core::ffi::c_ulonglong;
}
extern "C" {
	pub fn _strtoull_r(arg1: *mut _reent,
	                   __n: *const core::ffi::c_char,
	                   __end_PTR: *mut *mut core::ffi::c_char,
	                   __base: core::ffi::c_int)
	                   -> core::ffi::c_ulonglong;
}
extern "C" {
	pub fn cfree(arg1: *mut core::ffi::c_void);
}
extern "C" {
	pub fn unsetenv(__string: *const core::ffi::c_char) -> core::ffi::c_int;
}
extern "C" {
	pub fn _unsetenv_r(arg1: *mut _reent, __string: *const core::ffi::c_char) -> core::ffi::c_int;
}
extern "C" {
	#[must_use]
	pub fn posix_memalign(arg1: *mut *mut core::ffi::c_void, arg2: usize, arg3: usize) -> core::ffi::c_int;
}
extern "C" {
	pub fn _dtoa_r(arg1: *mut _reent,
	               arg2: core::ffi::c_double,
	               arg3: core::ffi::c_int,
	               arg4: core::ffi::c_int,
	               arg5: *mut core::ffi::c_int,
	               arg6: *mut core::ffi::c_int,
	               arg7: *mut *mut core::ffi::c_char)
	               -> *mut core::ffi::c_char;
}
extern "C" {
	pub fn _malloc_r(arg1: *mut _reent, arg2: usize) -> *mut core::ffi::c_void;
}
extern "C" {
	pub fn _calloc_r(arg1: *mut _reent, arg2: usize, arg3: usize) -> *mut core::ffi::c_void;
}
extern "C" {
	pub fn _free_r(arg1: *mut _reent, arg2: *mut core::ffi::c_void);
}
extern "C" {
	pub fn _realloc_r(arg1: *mut _reent, arg2: *mut core::ffi::c_void, arg3: usize) -> *mut core::ffi::c_void;
}
extern "C" {
	pub fn _mstats_r(arg1: *mut _reent, arg2: *mut core::ffi::c_char);
}
extern "C" {
	pub fn _system_r(arg1: *mut _reent, arg2: *const core::ffi::c_char) -> core::ffi::c_int;
}
extern "C" {
	pub fn __eprintf(arg1: *const core::ffi::c_char,
	                 arg2: *const core::ffi::c_char,
	                 arg3: core::ffi::c_uint,
	                 arg4: *const core::ffi::c_char);
}
extern "C" {
	#[link_name = "\u{1}__bsd_qsort_r"]
	pub fn qsort_r(__base: *mut core::ffi::c_void,
	               __nmemb: usize,
	               __size: usize,
	               __thunk: *mut core::ffi::c_void,
	               _compar: ::core::option::Option<unsafe extern "C" fn(arg1: *mut core::ffi::c_void,
	                                                           arg2: *const core::ffi::c_void,
	                                                           arg3: *const core::ffi::c_void)
	                                                           -> core::ffi::c_int>);
}
extern "C" {
	pub fn _strtold_r(arg1: *mut _reent, arg2: *const core::ffi::c_char, arg3: *mut *mut core::ffi::c_char) -> f64;
}
extern "C" {
	pub fn strtold(arg1: *const core::ffi::c_char, arg2: *mut *mut core::ffi::c_char) -> f64;
}
extern "C" {
	#[must_use]
	pub fn aligned_alloc(arg1: core::ffi::c_uint, arg2: core::ffi::c_uint) -> *mut core::ffi::c_void;
}
extern "C" {
	pub fn at_quick_exit(arg1: ::core::option::Option<unsafe extern "C" fn()>) -> core::ffi::c_int;
}
extern "C" {
	pub fn quick_exit(arg1: core::ffi::c_int);
}
extern "C" {
	pub fn __assert(arg1: *const core::ffi::c_char, arg2: core::ffi::c_int, arg3: *const core::ffi::c_char);
}
extern "C" {
	pub fn __assert_func(arg1: *const core::ffi::c_char,
	                     arg2: core::ffi::c_int,
	                     arg3: *const core::ffi::c_char,
	                     arg4: *const core::ffi::c_char);
}
pub type va_list = u32;
pub type __gnuc_va_list = u32;
pub type u_int8_t = __uint8_t;
pub type u_int16_t = __uint16_t;
pub type u_int32_t = __uint32_t;
pub type u_int64_t = __uint64_t;
pub type register_t = __intptr_t;
pub type __sigset_t = core::ffi::c_ulong;
pub type suseconds_t = __suseconds_t;
pub type time_t = __int_least64_t;
#[repr(C)]
pub struct timeval {
	pub tv_sec: time_t,
	pub tv_usec: suseconds_t,
}
#[test]
fn bindgen_test_layout_timeval() {
	assert_eq!(
	           ::core::mem::size_of::<timeval>(),
	           16usize,
	           concat!("Size of: ", stringify!(timeval))
	);
	assert_eq!(
	           ::core::mem::align_of::<timeval>(),
	           8usize,
	           concat!("Alignment of ", stringify!(timeval))
	);
	fn test_field_tv_sec() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<timeval>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).tv_sec) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(timeval), "::", stringify!(tv_sec))
		);
	}
	test_field_tv_sec();
	fn test_field_tv_usec() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<timeval>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).tv_usec) as usize - ptr as usize
		           },
		           8usize,
		           concat!("Offset of field: ", stringify!(timeval), "::", stringify!(tv_usec))
		);
	}
	test_field_tv_usec();
}
#[repr(C)]
pub struct timespec {
	pub tv_sec: time_t,
	pub tv_nsec: core::ffi::c_long,
}
#[test]
fn bindgen_test_layout_timespec() {
	assert_eq!(
	           ::core::mem::size_of::<timespec>(),
	           16usize,
	           concat!("Size of: ", stringify!(timespec))
	);
	assert_eq!(
	           ::core::mem::align_of::<timespec>(),
	           8usize,
	           concat!("Alignment of ", stringify!(timespec))
	);
	fn test_field_tv_sec() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<timespec>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).tv_sec) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(timespec), "::", stringify!(tv_sec))
		);
	}
	test_field_tv_sec();
	fn test_field_tv_nsec() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<timespec>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).tv_nsec) as usize - ptr as usize
		           },
		           8usize,
		           concat!("Offset of field: ", stringify!(timespec), "::", stringify!(tv_nsec))
		);
	}
	test_field_tv_nsec();
}
#[repr(C)]
pub struct itimerspec {
	pub it_interval: timespec,
	pub it_value: timespec,
}
#[test]
fn bindgen_test_layout_itimerspec() {
	assert_eq!(
	           ::core::mem::size_of::<itimerspec>(),
	           32usize,
	           concat!("Size of: ", stringify!(itimerspec))
	);
	assert_eq!(
	           ::core::mem::align_of::<itimerspec>(),
	           8usize,
	           concat!("Alignment of ", stringify!(itimerspec))
	);
	fn test_field_it_interval() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<itimerspec>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).it_interval) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(itimerspec), "::", stringify!(it_interval))
		);
	}
	test_field_it_interval();
	fn test_field_it_value() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<itimerspec>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).it_value) as usize - ptr as usize
		           },
		           16usize,
		           concat!("Offset of field: ", stringify!(itimerspec), "::", stringify!(it_value))
		);
	}
	test_field_it_value();
}
pub type sigset_t = __sigset_t;
pub type __fd_mask = core::ffi::c_ulong;
pub type fd_mask = __fd_mask;
#[repr(C)]
pub struct fd_set {
	pub __fds_bits: [__fd_mask; 2usize],
}
#[test]
fn bindgen_test_layout_fd_set() {
	assert_eq!(
	           ::core::mem::size_of::<fd_set>(),
	           8usize,
	           concat!("Size of: ", stringify!(fd_set))
	);
	assert_eq!(
	           ::core::mem::align_of::<fd_set>(),
	           4usize,
	           concat!("Alignment of ", stringify!(fd_set))
	);
	fn test_field___fds_bits() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<fd_set>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).__fds_bits) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(fd_set), "::", stringify!(__fds_bits))
		);
	}
	test_field___fds_bits();
}
extern "C" {
	pub fn select(__n: core::ffi::c_int,
	              __readfds: *mut fd_set,
	              __writefds: *mut fd_set,
	              __exceptfds: *mut fd_set,
	              __timeout: *mut timeval)
	              -> core::ffi::c_int;
}
extern "C" {
	pub fn pselect(__n: core::ffi::c_int,
	               __readfds: *mut fd_set,
	               __writefds: *mut fd_set,
	               __exceptfds: *mut fd_set,
	               __timeout: *const timespec,
	               __set: *const sigset_t)
	               -> core::ffi::c_int;
}
pub type in_addr_t = __uint32_t;
pub type in_port_t = __uint16_t;
pub type u_register_t = __uintptr_t;
pub type u_char = core::ffi::c_uchar;
pub type u_short = core::ffi::c_ushort;
pub type u_int = core::ffi::c_uint;
pub type u_long = core::ffi::c_ulong;
pub type ushort = core::ffi::c_ushort;
pub type uint = core::ffi::c_uint;
pub type ulong = core::ffi::c_ulong;
pub type blkcnt_t = __blkcnt_t;
pub type blksize_t = __blksize_t;
pub type clock_t = core::ffi::c_ulong;
pub type daddr_t = core::ffi::c_long;
pub type caddr_t = *mut core::ffi::c_char;
pub type fsblkcnt_t = __fsblkcnt_t;
pub type fsfilcnt_t = __fsfilcnt_t;
pub type id_t = __id_t;
pub type ino_t = __ino_t;
pub type off_t = __off_t;
pub type dev_t = __dev_t;
pub type uid_t = __uid_t;
pub type gid_t = __gid_t;
pub type pid_t = __pid_t;
pub type key_t = __key_t;
pub type mode_t = __mode_t;
pub type nlink_t = __nlink_t;
pub type clockid_t = __clockid_t;
pub type timer_t = __timer_t;
pub type useconds_t = __useconds_t;
pub type sbintime_t = __int64_t;
#[repr(C)]
pub struct sched_param {
	pub sched_priority: core::ffi::c_int,
}
#[test]
fn bindgen_test_layout_sched_param() {
	assert_eq!(
	           ::core::mem::size_of::<sched_param>(),
	           4usize,
	           concat!("Size of: ", stringify!(sched_param))
	);
	assert_eq!(
	           ::core::mem::align_of::<sched_param>(),
	           4usize,
	           concat!("Alignment of ", stringify!(sched_param))
	);
	fn test_field_sched_priority() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<sched_param>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).sched_priority) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(sched_param), "::", stringify!(sched_priority))
		);
	}
	test_field_sched_priority();
}
pub type pthread_t = __uint32_t;
#[repr(C)]
pub struct pthread_attr_t {
	pub is_initialized: core::ffi::c_int,
	pub stackaddr: *mut core::ffi::c_void,
	pub stacksize: core::ffi::c_int,
	pub contentionscope: core::ffi::c_int,
	pub inheritsched: core::ffi::c_int,
	pub schedpolicy: core::ffi::c_int,
	pub schedparam: sched_param,
	pub detachstate: core::ffi::c_int,
}
#[test]
fn bindgen_test_layout_pthread_attr_t() {
	assert_eq!(
	           ::core::mem::size_of::<pthread_attr_t>(),
	           32usize,
	           concat!("Size of: ", stringify!(pthread_attr_t))
	);
	assert_eq!(
	           ::core::mem::align_of::<pthread_attr_t>(),
	           4usize,
	           concat!("Alignment of ", stringify!(pthread_attr_t))
	);
	fn test_field_is_initialized() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<pthread_attr_t>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).is_initialized) as usize - ptr as usize
		           },
		           0usize,
		           concat!(
			"Offset of field: ",
			stringify!(pthread_attr_t),
			"::",
			stringify!(is_initialized)
		)
		);
	}
	test_field_is_initialized();
	fn test_field_stackaddr() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<pthread_attr_t>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).stackaddr) as usize - ptr as usize
		           },
		           4usize,
		           concat!("Offset of field: ", stringify!(pthread_attr_t), "::", stringify!(stackaddr))
		);
	}
	test_field_stackaddr();
	fn test_field_stacksize() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<pthread_attr_t>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).stacksize) as usize - ptr as usize
		           },
		           8usize,
		           concat!("Offset of field: ", stringify!(pthread_attr_t), "::", stringify!(stacksize))
		);
	}
	test_field_stacksize();
	fn test_field_contentionscope() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<pthread_attr_t>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).contentionscope) as usize - ptr as usize
		           },
		           12usize,
		           concat!(
			"Offset of field: ",
			stringify!(pthread_attr_t),
			"::",
			stringify!(contentionscope)
		)
		);
	}
	test_field_contentionscope();
	fn test_field_inheritsched() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<pthread_attr_t>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).inheritsched) as usize - ptr as usize
		           },
		           16usize,
		           concat!(
			"Offset of field: ",
			stringify!(pthread_attr_t),
			"::",
			stringify!(inheritsched)
		)
		);
	}
	test_field_inheritsched();
	fn test_field_schedpolicy() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<pthread_attr_t>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).schedpolicy) as usize - ptr as usize
		           },
		           20usize,
		           concat!("Offset of field: ", stringify!(pthread_attr_t), "::", stringify!(schedpolicy))
		);
	}
	test_field_schedpolicy();
	fn test_field_schedparam() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<pthread_attr_t>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).schedparam) as usize - ptr as usize
		           },
		           24usize,
		           concat!("Offset of field: ", stringify!(pthread_attr_t), "::", stringify!(schedparam))
		);
	}
	test_field_schedparam();
	fn test_field_detachstate() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<pthread_attr_t>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).detachstate) as usize - ptr as usize
		           },
		           28usize,
		           concat!("Offset of field: ", stringify!(pthread_attr_t), "::", stringify!(detachstate))
		);
	}
	test_field_detachstate();
}
pub type pthread_mutex_t = __uint32_t;
#[repr(C)]
pub struct pthread_mutexattr_t {
	pub is_initialized: core::ffi::c_int,
	pub recursive: core::ffi::c_int,
}
#[test]
fn bindgen_test_layout_pthread_mutexattr_t() {
	assert_eq!(
	           ::core::mem::size_of::<pthread_mutexattr_t>(),
	           8usize,
	           concat!("Size of: ", stringify!(pthread_mutexattr_t))
	);
	assert_eq!(
	           ::core::mem::align_of::<pthread_mutexattr_t>(),
	           4usize,
	           concat!("Alignment of ", stringify!(pthread_mutexattr_t))
	);
	fn test_field_is_initialized() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<pthread_mutexattr_t>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).is_initialized) as usize - ptr as usize
		           },
		           0usize,
		           concat!(
			"Offset of field: ",
			stringify!(pthread_mutexattr_t),
			"::",
			stringify!(is_initialized)
		)
		);
	}
	test_field_is_initialized();
	fn test_field_recursive() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<pthread_mutexattr_t>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).recursive) as usize - ptr as usize
		           },
		           4usize,
		           concat!(
			"Offset of field: ",
			stringify!(pthread_mutexattr_t),
			"::",
			stringify!(recursive)
		)
		);
	}
	test_field_recursive();
}
pub type pthread_cond_t = __uint32_t;
#[repr(C)]
pub struct pthread_condattr_t {
	pub is_initialized: core::ffi::c_int,
	pub clock: clock_t,
}
#[test]
fn bindgen_test_layout_pthread_condattr_t() {
	assert_eq!(
	           ::core::mem::size_of::<pthread_condattr_t>(),
	           8usize,
	           concat!("Size of: ", stringify!(pthread_condattr_t))
	);
	assert_eq!(
	           ::core::mem::align_of::<pthread_condattr_t>(),
	           4usize,
	           concat!("Alignment of ", stringify!(pthread_condattr_t))
	);
	fn test_field_is_initialized() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<pthread_condattr_t>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).is_initialized) as usize - ptr as usize
		           },
		           0usize,
		           concat!(
			"Offset of field: ",
			stringify!(pthread_condattr_t),
			"::",
			stringify!(is_initialized)
		)
		);
	}
	test_field_is_initialized();
	fn test_field_clock() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<pthread_condattr_t>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).clock) as usize - ptr as usize
		           },
		           4usize,
		           concat!("Offset of field: ", stringify!(pthread_condattr_t), "::", stringify!(clock))
		);
	}
	test_field_clock();
}
pub type pthread_key_t = __uint32_t;
#[repr(C)]
pub struct pthread_once_t {
	pub is_initialized: core::ffi::c_int,
	pub init_executed: core::ffi::c_int,
}
#[test]
fn bindgen_test_layout_pthread_once_t() {
	assert_eq!(
	           ::core::mem::size_of::<pthread_once_t>(),
	           8usize,
	           concat!("Size of: ", stringify!(pthread_once_t))
	);
	assert_eq!(
	           ::core::mem::align_of::<pthread_once_t>(),
	           4usize,
	           concat!("Alignment of ", stringify!(pthread_once_t))
	);
	fn test_field_is_initialized() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<pthread_once_t>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).is_initialized) as usize - ptr as usize
		           },
		           0usize,
		           concat!(
			"Offset of field: ",
			stringify!(pthread_once_t),
			"::",
			stringify!(is_initialized)
		)
		);
	}
	test_field_is_initialized();
	fn test_field_init_executed() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<pthread_once_t>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).init_executed) as usize - ptr as usize
		           },
		           4usize,
		           concat!(
			"Offset of field: ",
			stringify!(pthread_once_t),
			"::",
			stringify!(init_executed)
		)
		);
	}
	test_field_init_executed();
}
pub type FILE = __FILE;
pub type fpos_t = _fpos_t;
extern "C" {
	pub fn ctermid(arg1: *mut core::ffi::c_char) -> *mut core::ffi::c_char;
}
extern "C" {
	pub fn tmpfile() -> *mut FILE;
}
extern "C" {
	pub fn tmpnam(arg1: *mut core::ffi::c_char) -> *mut core::ffi::c_char;
}
extern "C" {
	#[must_use]
	pub fn tempnam(arg1: *const core::ffi::c_char, arg2: *const core::ffi::c_char) -> *mut core::ffi::c_char;
}
extern "C" {
	pub fn fclose(arg1: *mut FILE) -> core::ffi::c_int;
}
extern "C" {
	pub fn fflush(arg1: *mut FILE) -> core::ffi::c_int;
}
extern "C" {
	pub fn freopen(arg1: *const core::ffi::c_char, arg2: *const core::ffi::c_char, arg3: *mut FILE) -> *mut FILE;
}
extern "C" {
	pub fn setbuf(arg1: *mut FILE, arg2: *mut core::ffi::c_char);
}
extern "C" {
	pub fn setvbuf(arg1: *mut FILE, arg2: *mut core::ffi::c_char, arg3: core::ffi::c_int, arg4: usize) -> core::ffi::c_int;
}
extern "C" {
	pub fn fprintf(arg1: *mut FILE, arg2: *const core::ffi::c_char, ...) -> core::ffi::c_int;
}
extern "C" {
	pub fn fscanf(arg1: *mut FILE, arg2: *const core::ffi::c_char, ...) -> core::ffi::c_int;
}
extern "C" {
	pub fn printf(arg1: *const core::ffi::c_char, ...) -> core::ffi::c_int;
}
extern "C" {
	pub fn scanf(arg1: *const core::ffi::c_char, ...) -> core::ffi::c_int;
}
extern "C" {
	pub fn sscanf(arg1: *const core::ffi::c_char, arg2: *const core::ffi::c_char, ...) -> core::ffi::c_int;
}
extern "C" {
	pub fn vfprintf(arg1: *mut FILE, arg2: *const core::ffi::c_char, arg3: u32) -> core::ffi::c_int;
}
extern "C" {
	pub fn vprintf(arg1: *const core::ffi::c_char, arg2: u32) -> core::ffi::c_int;
}
extern "C" {
	pub fn vsprintf(arg1: *mut core::ffi::c_char, arg2: *const core::ffi::c_char, arg3: u32) -> core::ffi::c_int;
}
extern "C" {
	pub fn fgetc(arg1: *mut FILE) -> core::ffi::c_int;
}
extern "C" {
	pub fn fgets(arg1: *mut core::ffi::c_char, arg2: core::ffi::c_int, arg3: *mut FILE) -> *mut core::ffi::c_char;
}
extern "C" {
	pub fn fputc(arg1: core::ffi::c_int, arg2: *mut FILE) -> core::ffi::c_int;
}
extern "C" {
	pub fn fputs(arg1: *const core::ffi::c_char, arg2: *mut FILE) -> core::ffi::c_int;
}
extern "C" {
	pub fn getc(arg1: *mut FILE) -> core::ffi::c_int;
}
extern "C" {
	pub fn getchar() -> core::ffi::c_int;
}
extern "C" {
	pub fn gets(arg1: *mut core::ffi::c_char) -> *mut core::ffi::c_char;
}
extern "C" {
	pub fn putc(arg1: core::ffi::c_int, arg2: *mut FILE) -> core::ffi::c_int;
}
extern "C" {
	pub fn putchar(arg1: core::ffi::c_int) -> core::ffi::c_int;
}
extern "C" {
	pub fn puts(arg1: *const core::ffi::c_char) -> core::ffi::c_int;
}
extern "C" {
	pub fn ungetc(arg1: core::ffi::c_int, arg2: *mut FILE) -> core::ffi::c_int;
}
extern "C" {
	pub fn fread(arg1: *mut core::ffi::c_void, _size: core::ffi::c_uint, _n: core::ffi::c_uint, arg2: *mut FILE) -> core::ffi::c_uint;
}
extern "C" {
	pub fn fwrite(arg1: *const core::ffi::c_void,
	              _size: core::ffi::c_uint,
	              _n: core::ffi::c_uint,
	              arg2: *mut FILE)
	              -> core::ffi::c_uint;
}
extern "C" {
	pub fn fgetpos(arg1: *mut FILE, arg2: *mut fpos_t) -> core::ffi::c_int;
}
extern "C" {
	pub fn fseek(arg1: *mut FILE, arg2: core::ffi::c_long, arg3: core::ffi::c_int) -> core::ffi::c_int;
}
extern "C" {
	pub fn fsetpos(arg1: *mut FILE, arg2: *const fpos_t) -> core::ffi::c_int;
}
extern "C" {
	pub fn ftell(arg1: *mut FILE) -> core::ffi::c_long;
}
extern "C" {
	pub fn rewind(arg1: *mut FILE);
}
extern "C" {
	pub fn clearerr(arg1: *mut FILE);
}
extern "C" {
	pub fn feof(arg1: *mut FILE) -> core::ffi::c_int;
}
extern "C" {
	pub fn ferror(arg1: *mut FILE) -> core::ffi::c_int;
}
extern "C" {
	pub fn perror(arg1: *const core::ffi::c_char);
}
extern "C" {
	pub fn fopen(_name: *const core::ffi::c_char, _type: *const core::ffi::c_char) -> *mut FILE;
}
extern "C" {
	pub fn sprintf(arg1: *mut core::ffi::c_char, arg2: *const core::ffi::c_char, ...) -> core::ffi::c_int;
}
extern "C" {
	pub fn remove(arg1: *const core::ffi::c_char) -> core::ffi::c_int;
}
extern "C" {
	pub fn rename(arg1: *const core::ffi::c_char, arg2: *const core::ffi::c_char) -> core::ffi::c_int;
}
extern "C" {
	pub fn fseeko(arg1: *mut FILE, arg2: off_t, arg3: core::ffi::c_int) -> core::ffi::c_int;
}
extern "C" {
	pub fn ftello(arg1: *mut FILE) -> off_t;
}
extern "C" {
	pub fn snprintf(arg1: *mut core::ffi::c_char, arg2: core::ffi::c_uint, arg3: *const core::ffi::c_char, ...) -> core::ffi::c_int;
}
extern "C" {
	pub fn vsnprintf(arg1: *mut core::ffi::c_char,
	                 arg2: core::ffi::c_uint,
	                 arg3: *const core::ffi::c_char,
	                 arg4: u32)
	                 -> core::ffi::c_int;
}
extern "C" {
	pub fn vfscanf(arg1: *mut FILE, arg2: *const core::ffi::c_char, arg3: u32) -> core::ffi::c_int;
}
extern "C" {
	pub fn vscanf(arg1: *const core::ffi::c_char, arg2: u32) -> core::ffi::c_int;
}
extern "C" {
	pub fn vsscanf(arg1: *const core::ffi::c_char, arg2: *const core::ffi::c_char, arg3: u32) -> core::ffi::c_int;
}
extern "C" {
	pub fn asiprintf(arg1: *mut *mut core::ffi::c_char, arg2: *const core::ffi::c_char, ...) -> core::ffi::c_int;
}
extern "C" {
	pub fn asniprintf(arg1: *mut core::ffi::c_char, arg2: *mut usize, arg3: *const core::ffi::c_char, ...) -> *mut core::ffi::c_char;
}
extern "C" {
	pub fn asnprintf(arg1: *mut core::ffi::c_char, arg2: *mut usize, arg3: *const core::ffi::c_char, ...) -> *mut core::ffi::c_char;
}
extern "C" {
	pub fn diprintf(arg1: core::ffi::c_int, arg2: *const core::ffi::c_char, ...) -> core::ffi::c_int;
}
extern "C" {
	pub fn fiprintf(arg1: *mut FILE, arg2: *const core::ffi::c_char, ...) -> core::ffi::c_int;
}
extern "C" {
	pub fn fiscanf(arg1: *mut FILE, arg2: *const core::ffi::c_char, ...) -> core::ffi::c_int;
}
extern "C" {
	pub fn iprintf(arg1: *const core::ffi::c_char, ...) -> core::ffi::c_int;
}
extern "C" {
	pub fn iscanf(arg1: *const core::ffi::c_char, ...) -> core::ffi::c_int;
}
extern "C" {
	pub fn siprintf(arg1: *mut core::ffi::c_char, arg2: *const core::ffi::c_char, ...) -> core::ffi::c_int;
}
extern "C" {
	pub fn siscanf(arg1: *const core::ffi::c_char, arg2: *const core::ffi::c_char, ...) -> core::ffi::c_int;
}
extern "C" {
	pub fn sniprintf(arg1: *mut core::ffi::c_char, arg2: usize, arg3: *const core::ffi::c_char, ...) -> core::ffi::c_int;
}
extern "C" {
	pub fn vasiprintf(arg1: *mut *mut core::ffi::c_char, arg2: *const core::ffi::c_char, arg3: __gnuc_va_list) -> core::ffi::c_int;
}
extern "C" {
	pub fn vasniprintf(arg1: *mut core::ffi::c_char,
	                   arg2: *mut usize,
	                   arg3: *const core::ffi::c_char,
	                   arg4: __gnuc_va_list)
	                   -> *mut core::ffi::c_char;
}
extern "C" {
	pub fn vasnprintf(arg1: *mut core::ffi::c_char,
	                  arg2: *mut usize,
	                  arg3: *const core::ffi::c_char,
	                  arg4: __gnuc_va_list)
	                  -> *mut core::ffi::c_char;
}
extern "C" {
	pub fn vdiprintf(arg1: core::ffi::c_int, arg2: *const core::ffi::c_char, arg3: __gnuc_va_list) -> core::ffi::c_int;
}
extern "C" {
	pub fn vfiprintf(arg1: *mut FILE, arg2: *const core::ffi::c_char, arg3: __gnuc_va_list) -> core::ffi::c_int;
}
extern "C" {
	pub fn vfiscanf(arg1: *mut FILE, arg2: *const core::ffi::c_char, arg3: __gnuc_va_list) -> core::ffi::c_int;
}
extern "C" {
	pub fn viprintf(arg1: *const core::ffi::c_char, arg2: __gnuc_va_list) -> core::ffi::c_int;
}
extern "C" {
	pub fn viscanf(arg1: *const core::ffi::c_char, arg2: __gnuc_va_list) -> core::ffi::c_int;
}
extern "C" {
	pub fn vsiprintf(arg1: *mut core::ffi::c_char, arg2: *const core::ffi::c_char, arg3: __gnuc_va_list) -> core::ffi::c_int;
}
extern "C" {
	pub fn vsiscanf(arg1: *const core::ffi::c_char, arg2: *const core::ffi::c_char, arg3: __gnuc_va_list) -> core::ffi::c_int;
}
extern "C" {
	pub fn vsniprintf(arg1: *mut core::ffi::c_char,
	                  arg2: usize,
	                  arg3: *const core::ffi::c_char,
	                  arg4: __gnuc_va_list)
	                  -> core::ffi::c_int;
}
extern "C" {
	pub fn fdopen(arg1: core::ffi::c_int, arg2: *const core::ffi::c_char) -> *mut FILE;
}
extern "C" {
	pub fn fileno(arg1: *mut FILE) -> core::ffi::c_int;
}
extern "C" {
	pub fn pclose(arg1: *mut FILE) -> core::ffi::c_int;
}
extern "C" {
	pub fn popen(arg1: *const core::ffi::c_char, arg2: *const core::ffi::c_char) -> *mut FILE;
}
extern "C" {
	pub fn setbuffer(arg1: *mut FILE, arg2: *mut core::ffi::c_char, arg3: core::ffi::c_int);
}
extern "C" {
	pub fn setlinebuf(arg1: *mut FILE) -> core::ffi::c_int;
}
extern "C" {
	pub fn getw(arg1: *mut FILE) -> core::ffi::c_int;
}
extern "C" {
	pub fn putw(arg1: core::ffi::c_int, arg2: *mut FILE) -> core::ffi::c_int;
}
extern "C" {
	pub fn getc_unlocked(arg1: *mut FILE) -> core::ffi::c_int;
}
extern "C" {
	pub fn getchar_unlocked() -> core::ffi::c_int;
}
extern "C" {
	pub fn flockfile(arg1: *mut FILE);
}
extern "C" {
	pub fn ftrylockfile(arg1: *mut FILE) -> core::ffi::c_int;
}
extern "C" {
	pub fn funlockfile(arg1: *mut FILE);
}
extern "C" {
	pub fn putc_unlocked(arg1: core::ffi::c_int, arg2: *mut FILE) -> core::ffi::c_int;
}
extern "C" {
	pub fn putchar_unlocked(arg1: core::ffi::c_int) -> core::ffi::c_int;
}
extern "C" {
	pub fn dprintf(arg1: core::ffi::c_int, arg2: *const core::ffi::c_char, ...) -> core::ffi::c_int;
}
extern "C" {
	pub fn fmemopen(arg1: *mut core::ffi::c_void, arg2: usize, arg3: *const core::ffi::c_char) -> *mut FILE;
}
extern "C" {
	pub fn open_memstream(arg1: *mut *mut core::ffi::c_char, arg2: *mut usize) -> *mut FILE;
}
extern "C" {
	pub fn vdprintf(arg1: core::ffi::c_int, arg2: *const core::ffi::c_char, arg3: __gnuc_va_list) -> core::ffi::c_int;
}
extern "C" {
	pub fn renameat(arg1: core::ffi::c_int,
	                arg2: *const core::ffi::c_char,
	                arg3: core::ffi::c_int,
	                arg4: *const core::ffi::c_char)
	                -> core::ffi::c_int;
}
extern "C" {
	pub fn _asiprintf_r(arg1: *mut _reent, arg2: *mut *mut core::ffi::c_char, arg3: *const core::ffi::c_char, ...)
	                    -> core::ffi::c_int;
}
extern "C" {
	pub fn _asniprintf_r(arg1: *mut _reent,
	                     arg2: *mut core::ffi::c_char,
	                     arg3: *mut usize,
	                     arg4: *const core::ffi::c_char,
	                     ...)
	                     -> *mut core::ffi::c_char;
}
extern "C" {
	pub fn _asnprintf_r(arg1: *mut _reent,
	                    arg2: *mut core::ffi::c_char,
	                    arg3: *mut usize,
	                    arg4: *const core::ffi::c_char,
	                    ...)
	                    -> *mut core::ffi::c_char;
}
extern "C" {
	pub fn _asprintf_r(arg1: *mut _reent, arg2: *mut *mut core::ffi::c_char, arg3: *const core::ffi::c_char, ...) -> core::ffi::c_int;
}
extern "C" {
	pub fn _diprintf_r(arg1: *mut _reent, arg2: core::ffi::c_int, arg3: *const core::ffi::c_char, ...) -> core::ffi::c_int;
}
extern "C" {
	pub fn _dprintf_r(arg1: *mut _reent, arg2: core::ffi::c_int, arg3: *const core::ffi::c_char, ...) -> core::ffi::c_int;
}
extern "C" {
	pub fn _fclose_r(arg1: *mut _reent, arg2: *mut FILE) -> core::ffi::c_int;
}
extern "C" {
	pub fn _fcloseall_r(arg1: *mut _reent) -> core::ffi::c_int;
}
extern "C" {
	pub fn _fdopen_r(arg1: *mut _reent, arg2: core::ffi::c_int, arg3: *const core::ffi::c_char) -> *mut FILE;
}
extern "C" {
	pub fn _fflush_r(arg1: *mut _reent, arg2: *mut FILE) -> core::ffi::c_int;
}
extern "C" {
	pub fn _fgetc_r(arg1: *mut _reent, arg2: *mut FILE) -> core::ffi::c_int;
}
extern "C" {
	pub fn _fgetc_unlocked_r(arg1: *mut _reent, arg2: *mut FILE) -> core::ffi::c_int;
}
extern "C" {
	pub fn _fgets_r(arg1: *mut _reent,
	                arg2: *mut core::ffi::c_char,
	                arg3: core::ffi::c_int,
	                arg4: *mut FILE)
	                -> *mut core::ffi::c_char;
}
extern "C" {
	pub fn _fgets_unlocked_r(arg1: *mut _reent,
	                         arg2: *mut core::ffi::c_char,
	                         arg3: core::ffi::c_int,
	                         arg4: *mut FILE)
	                         -> *mut core::ffi::c_char;
}
extern "C" {
	pub fn _fgetpos_r(arg1: *mut _reent, arg2: *mut FILE, arg3: *mut fpos_t) -> core::ffi::c_int;
}
extern "C" {
	pub fn _fsetpos_r(arg1: *mut _reent, arg2: *mut FILE, arg3: *const fpos_t) -> core::ffi::c_int;
}
extern "C" {
	pub fn _fiprintf_r(arg1: *mut _reent, arg2: *mut FILE, arg3: *const core::ffi::c_char, ...) -> core::ffi::c_int;
}
extern "C" {
	pub fn _fiscanf_r(arg1: *mut _reent, arg2: *mut FILE, arg3: *const core::ffi::c_char, ...) -> core::ffi::c_int;
}
extern "C" {
	pub fn _fmemopen_r(arg1: *mut _reent, arg2: *mut core::ffi::c_void, arg3: usize, arg4: *const core::ffi::c_char) -> *mut FILE;
}
extern "C" {
	pub fn _fopen_r(arg1: *mut _reent, arg2: *const core::ffi::c_char, arg3: *const core::ffi::c_char) -> *mut FILE;
}
extern "C" {
	pub fn _freopen_r(arg1: *mut _reent, arg2: *const core::ffi::c_char, arg3: *const core::ffi::c_char, arg4: *mut FILE)
	                  -> *mut FILE;
}
extern "C" {
	pub fn _fprintf_r(arg1: *mut _reent, arg2: *mut FILE, arg3: *const core::ffi::c_char, ...) -> core::ffi::c_int;
}
extern "C" {
	pub fn _fpurge_r(arg1: *mut _reent, arg2: *mut FILE) -> core::ffi::c_int;
}
extern "C" {
	pub fn _fputc_r(arg1: *mut _reent, arg2: core::ffi::c_int, arg3: *mut FILE) -> core::ffi::c_int;
}
extern "C" {
	pub fn _fputc_unlocked_r(arg1: *mut _reent, arg2: core::ffi::c_int, arg3: *mut FILE) -> core::ffi::c_int;
}
extern "C" {
	pub fn _fputs_r(arg1: *mut _reent, arg2: *const core::ffi::c_char, arg3: *mut FILE) -> core::ffi::c_int;
}
extern "C" {
	pub fn _fputs_unlocked_r(arg1: *mut _reent, arg2: *const core::ffi::c_char, arg3: *mut FILE) -> core::ffi::c_int;
}
extern "C" {
	pub fn _fread_r(arg1: *mut _reent, arg2: *mut core::ffi::c_void, _size: usize, _n: usize, arg3: *mut FILE) -> usize;
}
extern "C" {
	pub fn _fread_unlocked_r(arg1: *mut _reent, arg2: *mut core::ffi::c_void, _size: usize, _n: usize, arg3: *mut FILE) -> usize;
}
extern "C" {
	pub fn _fscanf_r(arg1: *mut _reent, arg2: *mut FILE, arg3: *const core::ffi::c_char, ...) -> core::ffi::c_int;
}
extern "C" {
	pub fn _fseek_r(arg1: *mut _reent, arg2: *mut FILE, arg3: core::ffi::c_long, arg4: core::ffi::c_int) -> core::ffi::c_int;
}
extern "C" {
	pub fn _fseeko_r(arg1: *mut _reent, arg2: *mut FILE, arg3: _off_t, arg4: core::ffi::c_int) -> core::ffi::c_int;
}
extern "C" {
	pub fn _ftell_r(arg1: *mut _reent, arg2: *mut FILE) -> core::ffi::c_long;
}
extern "C" {
	pub fn _ftello_r(arg1: *mut _reent, arg2: *mut FILE) -> _off_t;
}
extern "C" {
	pub fn _rewind_r(arg1: *mut _reent, arg2: *mut FILE);
}
extern "C" {
	pub fn _fwrite_r(arg1: *mut _reent, arg2: *const core::ffi::c_void, _size: usize, _n: usize, arg3: *mut FILE) -> usize;
}
extern "C" {
	pub fn _fwrite_unlocked_r(arg1: *mut _reent, arg2: *const core::ffi::c_void, _size: usize, _n: usize, arg3: *mut FILE) -> usize;
}
extern "C" {
	pub fn _getc_r(arg1: *mut _reent, arg2: *mut FILE) -> core::ffi::c_int;
}
extern "C" {
	pub fn _getc_unlocked_r(arg1: *mut _reent, arg2: *mut FILE) -> core::ffi::c_int;
}
extern "C" {
	pub fn _getchar_r(arg1: *mut _reent) -> core::ffi::c_int;
}
extern "C" {
	pub fn _getchar_unlocked_r(arg1: *mut _reent) -> core::ffi::c_int;
}
extern "C" {
	pub fn _gets_r(arg1: *mut _reent, arg2: *mut core::ffi::c_char) -> *mut core::ffi::c_char;
}
extern "C" {
	pub fn _iprintf_r(arg1: *mut _reent, arg2: *const core::ffi::c_char, ...) -> core::ffi::c_int;
}
extern "C" {
	pub fn _iscanf_r(arg1: *mut _reent, arg2: *const core::ffi::c_char, ...) -> core::ffi::c_int;
}
extern "C" {
	pub fn _open_memstream_r(arg1: *mut _reent, arg2: *mut *mut core::ffi::c_char, arg3: *mut usize) -> *mut FILE;
}
extern "C" {
	pub fn _perror_r(arg1: *mut _reent, arg2: *const core::ffi::c_char);
}
extern "C" {
	pub fn _printf_r(arg1: *mut _reent, arg2: *const core::ffi::c_char, ...) -> core::ffi::c_int;
}
extern "C" {
	pub fn _putc_r(arg1: *mut _reent, arg2: core::ffi::c_int, arg3: *mut FILE) -> core::ffi::c_int;
}
extern "C" {
	pub fn _putc_unlocked_r(arg1: *mut _reent, arg2: core::ffi::c_int, arg3: *mut FILE) -> core::ffi::c_int;
}
extern "C" {
	pub fn _putchar_unlocked_r(arg1: *mut _reent, arg2: core::ffi::c_int) -> core::ffi::c_int;
}
extern "C" {
	pub fn _putchar_r(arg1: *mut _reent, arg2: core::ffi::c_int) -> core::ffi::c_int;
}
extern "C" {
	pub fn _puts_r(arg1: *mut _reent, arg2: *const core::ffi::c_char) -> core::ffi::c_int;
}
extern "C" {
	pub fn _remove_r(arg1: *mut _reent, arg2: *const core::ffi::c_char) -> core::ffi::c_int;
}
extern "C" {
	pub fn _rename_r(arg1: *mut _reent, _old: *const core::ffi::c_char, _new: *const core::ffi::c_char) -> core::ffi::c_int;
}
extern "C" {
	pub fn _scanf_r(arg1: *mut _reent, arg2: *const core::ffi::c_char, ...) -> core::ffi::c_int;
}
extern "C" {
	pub fn _siprintf_r(arg1: *mut _reent, arg2: *mut core::ffi::c_char, arg3: *const core::ffi::c_char, ...) -> core::ffi::c_int;
}
extern "C" {
	pub fn _siscanf_r(arg1: *mut _reent, arg2: *const core::ffi::c_char, arg3: *const core::ffi::c_char, ...) -> core::ffi::c_int;
}
extern "C" {
	pub fn _sniprintf_r(arg1: *mut _reent,
	                    arg2: *mut core::ffi::c_char,
	                    arg3: usize,
	                    arg4: *const core::ffi::c_char,
	                    ...)
	                    -> core::ffi::c_int;
}
extern "C" {
	pub fn _snprintf_r(arg1: *mut _reent,
	                   arg2: *mut core::ffi::c_char,
	                   arg3: usize,
	                   arg4: *const core::ffi::c_char,
	                   ...)
	                   -> core::ffi::c_int;
}
extern "C" {
	pub fn _sprintf_r(arg1: *mut _reent, arg2: *mut core::ffi::c_char, arg3: *const core::ffi::c_char, ...) -> core::ffi::c_int;
}
extern "C" {
	pub fn _sscanf_r(arg1: *mut _reent, arg2: *const core::ffi::c_char, arg3: *const core::ffi::c_char, ...) -> core::ffi::c_int;
}
extern "C" {
	pub fn _tempnam_r(arg1: *mut _reent, arg2: *const core::ffi::c_char, arg3: *const core::ffi::c_char) -> *mut core::ffi::c_char;
}
extern "C" {
	pub fn _tmpfile_r(arg1: *mut _reent) -> *mut FILE;
}
extern "C" {
	pub fn _tmpnam_r(arg1: *mut _reent, arg2: *mut core::ffi::c_char) -> *mut core::ffi::c_char;
}
extern "C" {
	pub fn _ungetc_r(arg1: *mut _reent, arg2: core::ffi::c_int, arg3: *mut FILE) -> core::ffi::c_int;
}
extern "C" {
	pub fn _vasiprintf_r(arg1: *mut _reent,
	                     arg2: *mut *mut core::ffi::c_char,
	                     arg3: *const core::ffi::c_char,
	                     arg4: __gnuc_va_list)
	                     -> core::ffi::c_int;
}
extern "C" {
	pub fn _vasniprintf_r(arg1: *mut _reent,
	                      arg2: *mut core::ffi::c_char,
	                      arg3: *mut usize,
	                      arg4: *const core::ffi::c_char,
	                      arg5: __gnuc_va_list)
	                      -> *mut core::ffi::c_char;
}
extern "C" {
	pub fn _vasnprintf_r(arg1: *mut _reent,
	                     arg2: *mut core::ffi::c_char,
	                     arg3: *mut usize,
	                     arg4: *const core::ffi::c_char,
	                     arg5: __gnuc_va_list)
	                     -> *mut core::ffi::c_char;
}
extern "C" {
	pub fn _vasprintf_r(arg1: *mut _reent,
	                    arg2: *mut *mut core::ffi::c_char,
	                    arg3: *const core::ffi::c_char,
	                    arg4: __gnuc_va_list)
	                    -> core::ffi::c_int;
}
extern "C" {
	pub fn _vdiprintf_r(arg1: *mut _reent,
	                    arg2: core::ffi::c_int,
	                    arg3: *const core::ffi::c_char,
	                    arg4: __gnuc_va_list)
	                    -> core::ffi::c_int;
}
extern "C" {
	pub fn _vdprintf_r(arg1: *mut _reent,
	                   arg2: core::ffi::c_int,
	                   arg3: *const core::ffi::c_char,
	                   arg4: __gnuc_va_list)
	                   -> core::ffi::c_int;
}
extern "C" {
	pub fn _vfiprintf_r(arg1: *mut _reent, arg2: *mut FILE, arg3: *const core::ffi::c_char, arg4: __gnuc_va_list) -> core::ffi::c_int;
}
extern "C" {
	pub fn _vfiscanf_r(arg1: *mut _reent, arg2: *mut FILE, arg3: *const core::ffi::c_char, arg4: __gnuc_va_list) -> core::ffi::c_int;
}
extern "C" {
	pub fn _vfprintf_r(arg1: *mut _reent, arg2: *mut FILE, arg3: *const core::ffi::c_char, arg4: __gnuc_va_list) -> core::ffi::c_int;
}
extern "C" {
	pub fn _vfscanf_r(arg1: *mut _reent, arg2: *mut FILE, arg3: *const core::ffi::c_char, arg4: __gnuc_va_list) -> core::ffi::c_int;
}
extern "C" {
	pub fn _viprintf_r(arg1: *mut _reent, arg2: *const core::ffi::c_char, arg3: __gnuc_va_list) -> core::ffi::c_int;
}
extern "C" {
	pub fn _viscanf_r(arg1: *mut _reent, arg2: *const core::ffi::c_char, arg3: __gnuc_va_list) -> core::ffi::c_int;
}
extern "C" {
	pub fn _vprintf_r(arg1: *mut _reent, arg2: *const core::ffi::c_char, arg3: __gnuc_va_list) -> core::ffi::c_int;
}
extern "C" {
	pub fn _vscanf_r(arg1: *mut _reent, arg2: *const core::ffi::c_char, arg3: __gnuc_va_list) -> core::ffi::c_int;
}
extern "C" {
	pub fn _vsiprintf_r(arg1: *mut _reent,
	                    arg2: *mut core::ffi::c_char,
	                    arg3: *const core::ffi::c_char,
	                    arg4: __gnuc_va_list)
	                    -> core::ffi::c_int;
}
extern "C" {
	pub fn _vsiscanf_r(arg1: *mut _reent,
	                   arg2: *const core::ffi::c_char,
	                   arg3: *const core::ffi::c_char,
	                   arg4: __gnuc_va_list)
	                   -> core::ffi::c_int;
}
extern "C" {
	pub fn _vsniprintf_r(arg1: *mut _reent,
	                     arg2: *mut core::ffi::c_char,
	                     arg3: usize,
	                     arg4: *const core::ffi::c_char,
	                     arg5: __gnuc_va_list)
	                     -> core::ffi::c_int;
}
extern "C" {
	pub fn _vsnprintf_r(arg1: *mut _reent,
	                    arg2: *mut core::ffi::c_char,
	                    arg3: usize,
	                    arg4: *const core::ffi::c_char,
	                    arg5: __gnuc_va_list)
	                    -> core::ffi::c_int;
}
extern "C" {
	pub fn _vsprintf_r(arg1: *mut _reent,
	                   arg2: *mut core::ffi::c_char,
	                   arg3: *const core::ffi::c_char,
	                   arg4: __gnuc_va_list)
	                   -> core::ffi::c_int;
}
extern "C" {
	pub fn _vsscanf_r(arg1: *mut _reent,
	                  arg2: *const core::ffi::c_char,
	                  arg3: *const core::ffi::c_char,
	                  arg4: __gnuc_va_list)
	                  -> core::ffi::c_int;
}
extern "C" {
	pub fn fpurge(arg1: *mut FILE) -> core::ffi::c_int;
}
extern "C" {
	pub fn __getdelim(arg1: *mut *mut core::ffi::c_char, arg2: *mut usize, arg3: core::ffi::c_int, arg4: *mut FILE) -> isize;
}
extern "C" {
	pub fn __getline(arg1: *mut *mut core::ffi::c_char, arg2: *mut usize, arg3: *mut FILE) -> isize;
}
extern "C" {
	pub fn clearerr_unlocked(arg1: *mut FILE);
}
extern "C" {
	pub fn feof_unlocked(arg1: *mut FILE) -> core::ffi::c_int;
}
extern "C" {
	pub fn ferror_unlocked(arg1: *mut FILE) -> core::ffi::c_int;
}
extern "C" {
	pub fn fileno_unlocked(arg1: *mut FILE) -> core::ffi::c_int;
}
extern "C" {
	pub fn fflush_unlocked(arg1: *mut FILE) -> core::ffi::c_int;
}
extern "C" {
	pub fn fgetc_unlocked(arg1: *mut FILE) -> core::ffi::c_int;
}
extern "C" {
	pub fn fputc_unlocked(arg1: core::ffi::c_int, arg2: *mut FILE) -> core::ffi::c_int;
}
extern "C" {
	pub fn fread_unlocked(arg1: *mut core::ffi::c_void, _size: usize, _n: usize, arg2: *mut FILE) -> usize;
}
extern "C" {
	pub fn fwrite_unlocked(arg1: *const core::ffi::c_void, _size: usize, _n: usize, arg2: *mut FILE) -> usize;
}
extern "C" {
	pub fn __srget_r(arg1: *mut _reent, arg2: *mut FILE) -> core::ffi::c_int;
}
extern "C" {
	pub fn __swbuf_r(arg1: *mut _reent, arg2: core::ffi::c_int, arg3: *mut FILE) -> core::ffi::c_int;
}
extern "C" {
	pub fn funopen(__cookie: *const core::ffi::c_void,
	               __readfn: ::core::option::Option<unsafe extern "C" fn(__cookie: *mut core::ffi::c_void,
	                                                           __buf: *mut core::ffi::c_char,
	                                                           __n: core::ffi::c_int)
	                                                           -> core::ffi::c_int>,
	               __writefn: ::core::option::Option<unsafe extern "C" fn(__cookie: *mut core::ffi::c_void,
	                                                           __buf: *const core::ffi::c_char,
	                                                           __n: core::ffi::c_int)
	                                                           -> core::ffi::c_int>,
	               __seekfn: ::core::option::Option<unsafe extern "C" fn(__cookie: *mut core::ffi::c_void,
	                                                           __off: fpos_t,
	                                                           __whence: core::ffi::c_int)
	                                                           -> fpos_t>,
	               __closefn: ::core::option::Option<unsafe extern "C" fn(__cookie: *mut core::ffi::c_void) -> core::ffi::c_int>)
	               -> *mut FILE;
}
extern "C" {
	pub fn _funopen_r(arg1: *mut _reent,
	                  __cookie: *const core::ffi::c_void,
	                  __readfn: ::core::option::Option<unsafe extern "C" fn(__cookie: *mut core::ffi::c_void,
	                                                              __buf: *mut core::ffi::c_char,
	                                                              __n: core::ffi::c_int)
	                                                              -> core::ffi::c_int>,
	                  __writefn: ::core::option::Option<unsafe extern "C" fn(__cookie: *mut core::ffi::c_void,
	                                                              __buf: *const core::ffi::c_char,
	                                                              __n: core::ffi::c_int)
	                                                              -> core::ffi::c_int>,
	                  __seekfn: ::core::option::Option<unsafe extern "C" fn(__cookie: *mut core::ffi::c_void,
	                                                              __off: fpos_t,
	                                                              __whence: core::ffi::c_int)
	                                                              -> fpos_t>,
	                  __closefn: ::core::option::Option<unsafe extern "C" fn(__cookie: *mut core::ffi::c_void) -> core::ffi::c_int>)
	                  -> *mut FILE;
}
#[repr(C)]
pub struct m_core_backoff_s {
	pub count: core::ffi::c_uint,
	pub seed: core::ffi::c_uint,
}
#[test]
fn bindgen_test_layout_m_core_backoff_s() {
	assert_eq!(
	           ::core::mem::size_of::<m_core_backoff_s>(),
	           8usize,
	           concat!("Size of: ", stringify!(m_core_backoff_s))
	);
	assert_eq!(
	           ::core::mem::align_of::<m_core_backoff_s>(),
	           4usize,
	           concat!("Alignment of ", stringify!(m_core_backoff_s))
	);
	fn test_field_count() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<m_core_backoff_s>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).count) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(m_core_backoff_s), "::", stringify!(count))
		);
	}
	test_field_count();
	fn test_field_seed() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<m_core_backoff_s>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).seed) as usize - ptr as usize
		           },
		           4usize,
		           concat!("Offset of field: ", stringify!(m_core_backoff_s), "::", stringify!(seed))
		);
	}
	test_field_seed();
}
pub type m_core_backoff_ct = [m_core_backoff_s; 1usize];
#[repr(u32)]
#[non_exhaustive]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum m_serial_return_code_e {
	M_SERIAL_OK_DONE = 0,
	M_SERIAL_OK_CONTINUE = 1,
	M_SERIAL_FAIL = 2,
}
pub use self::m_serial_return_code_e as m_serial_return_code_t;
#[repr(C)]
pub struct m_serial_ll_u {
	pub b: __BindgenUnionField<bool>,
	pub c: __BindgenUnionField<core::ffi::c_char>,
	pub i: __BindgenUnionField<core::ffi::c_int>,
	pub l: __BindgenUnionField<core::ffi::c_long>,
	pub ll: __BindgenUnionField<core::ffi::c_longlong>,
	pub f: __BindgenUnionField<core::ffi::c_float>,
	pub d: __BindgenUnionField<core::ffi::c_double>,
	pub e: __BindgenUnionField<f64>,
	pub s: __BindgenUnionField<usize>,
	pub u: __BindgenUnionField<usize>,
	pub p: __BindgenUnionField<*mut core::ffi::c_void>,
	pub cstr: __BindgenUnionField<*const core::ffi::c_char>,
	pub r: __BindgenUnionField<m_serial_return_code_t>,
	pub bindgen_union_field: u64,
}
#[test]
fn bindgen_test_layout_m_serial_ll_u() {
	assert_eq!(
	           ::core::mem::size_of::<m_serial_ll_u>(),
	           8usize,
	           concat!("Size of: ", stringify!(m_serial_ll_u))
	);
	assert_eq!(
	           ::core::mem::align_of::<m_serial_ll_u>(),
	           8usize,
	           concat!("Alignment of ", stringify!(m_serial_ll_u))
	);
	fn test_field_b() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<m_serial_ll_u>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).b) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(m_serial_ll_u), "::", stringify!(b))
		);
	}
	test_field_b();
	fn test_field_c() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<m_serial_ll_u>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).c) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(m_serial_ll_u), "::", stringify!(c))
		);
	}
	test_field_c();
	fn test_field_i() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<m_serial_ll_u>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).i) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(m_serial_ll_u), "::", stringify!(i))
		);
	}
	test_field_i();
	fn test_field_l() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<m_serial_ll_u>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).l) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(m_serial_ll_u), "::", stringify!(l))
		);
	}
	test_field_l();
	fn test_field_ll() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<m_serial_ll_u>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).ll) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(m_serial_ll_u), "::", stringify!(ll))
		);
	}
	test_field_ll();
	fn test_field_f() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<m_serial_ll_u>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).f) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(m_serial_ll_u), "::", stringify!(f))
		);
	}
	test_field_f();
	fn test_field_d() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<m_serial_ll_u>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).d) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(m_serial_ll_u), "::", stringify!(d))
		);
	}
	test_field_d();
	fn test_field_e() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<m_serial_ll_u>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).e) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(m_serial_ll_u), "::", stringify!(e))
		);
	}
	test_field_e();
	fn test_field_s() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<m_serial_ll_u>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).s) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(m_serial_ll_u), "::", stringify!(s))
		);
	}
	test_field_s();
	fn test_field_u() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<m_serial_ll_u>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).u) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(m_serial_ll_u), "::", stringify!(u))
		);
	}
	test_field_u();
	fn test_field_p() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<m_serial_ll_u>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).p) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(m_serial_ll_u), "::", stringify!(p))
		);
	}
	test_field_p();
	fn test_field_cstr() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<m_serial_ll_u>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).cstr) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(m_serial_ll_u), "::", stringify!(cstr))
		);
	}
	test_field_cstr();
	fn test_field_r() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<m_serial_ll_u>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).r) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(m_serial_ll_u), "::", stringify!(r))
		);
	}
	test_field_r();
}
pub type m_serial_ll_ct = m_serial_ll_u;
#[repr(C)]
pub struct m_serial_local_s {
	pub data: [m_serial_ll_ct; 4usize],
}
#[test]
fn bindgen_test_layout_m_serial_local_s() {
	assert_eq!(
	           ::core::mem::size_of::<m_serial_local_s>(),
	           32usize,
	           concat!("Size of: ", stringify!(m_serial_local_s))
	);
	assert_eq!(
	           ::core::mem::align_of::<m_serial_local_s>(),
	           8usize,
	           concat!("Alignment of ", stringify!(m_serial_local_s))
	);
	fn test_field_data() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<m_serial_local_s>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).data) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(m_serial_local_s), "::", stringify!(data))
		);
	}
	test_field_data();
}
pub type m_serial_local_t = [m_serial_local_s; 1usize];
#[repr(C)]
pub struct m_serial_read_s {
	pub m_interface: *const m_serial_read_interface_s,
	pub tmp: m_serial_ll_ct,
	pub data: [m_serial_ll_ct; 4usize],
}
#[test]
fn bindgen_test_layout_m_serial_read_s() {
	assert_eq!(
	           ::core::mem::size_of::<m_serial_read_s>(),
	           48usize,
	           concat!("Size of: ", stringify!(m_serial_read_s))
	);
	assert_eq!(
	           ::core::mem::align_of::<m_serial_read_s>(),
	           8usize,
	           concat!("Alignment of ", stringify!(m_serial_read_s))
	);
	fn test_field_m_interface() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<m_serial_read_s>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).m_interface) as usize - ptr as usize
		           },
		           0usize,
		           concat!(
			"Offset of field: ",
			stringify!(m_serial_read_s),
			"::",
			stringify!(m_interface)
		)
		);
	}
	test_field_m_interface();
	fn test_field_tmp() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<m_serial_read_s>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).tmp) as usize - ptr as usize
		           },
		           8usize,
		           concat!("Offset of field: ", stringify!(m_serial_read_s), "::", stringify!(tmp))
		);
	}
	test_field_tmp();
	fn test_field_data() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<m_serial_read_s>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).data) as usize - ptr as usize
		           },
		           16usize,
		           concat!("Offset of field: ", stringify!(m_serial_read_s), "::", stringify!(data))
		);
	}
	test_field_data();
}
pub type m_serial_read_t = [m_serial_read_s; 1usize];
#[repr(C)]
pub struct m_serial_read_interface_s {
	pub read_boolean:
		::core::option::Option<unsafe extern "C" fn(arg1: *mut m_serial_read_t, arg2: *mut bool) -> m_serial_return_code_t>,
	pub read_integer: ::core::option::Option<unsafe extern "C" fn(arg1: *mut m_serial_read_t,
	                                                              arg2: *mut core::ffi::c_longlong,
	                                                              size_of_type: usize)
	                                                              -> m_serial_return_code_t>,
	pub read_float: ::core::option::Option<unsafe extern "C" fn(arg1: *mut m_serial_read_t,
	                                                            arg2: *mut f64,
	                                                            size_of_type: usize)
	                                                            -> m_serial_return_code_t>,
	pub read_string:
		::core::option::Option<unsafe extern "C" fn(arg1: *mut m_serial_read_t, arg2: *mut string_s) -> m_serial_return_code_t>,
	pub read_array_start: ::core::option::Option<unsafe extern "C" fn(arg1: *mut m_serial_local_t,
	                                                                  arg2: *mut m_serial_read_t,
	                                                                  arg3: *mut usize)
	                                                                  -> m_serial_return_code_t>,
	pub read_array_next:
		::core::option::Option<unsafe extern "C" fn(arg1: *mut m_serial_local_t, arg2: *mut m_serial_read_t) -> m_serial_return_code_t>,
	pub read_map_start: ::core::option::Option<unsafe extern "C" fn(arg1: *mut m_serial_local_t,
	                                                                arg2: *mut m_serial_read_t,
	                                                                arg3: *mut usize)
	                                                                -> m_serial_return_code_t>,
	pub read_map_value:
		::core::option::Option<unsafe extern "C" fn(arg1: *mut m_serial_local_t, arg2: *mut m_serial_read_t) -> m_serial_return_code_t>,
	pub read_map_next:
		::core::option::Option<unsafe extern "C" fn(arg1: *mut m_serial_local_t, arg2: *mut m_serial_read_t) -> m_serial_return_code_t>,
	pub read_tuple_start:
		::core::option::Option<unsafe extern "C" fn(arg1: *mut m_serial_local_t, arg2: *mut m_serial_read_t) -> m_serial_return_code_t>,
	pub read_tuple_id: ::core::option::Option<unsafe extern "C" fn(arg1: *mut m_serial_local_t,
	                                                               arg2: *mut m_serial_read_t,
	                                                               field_name: *const [*const core::ffi::c_char; 0usize],
	                                                               max: core::ffi::c_int,
	                                                               arg3: *mut core::ffi::c_int)
	                                                               -> m_serial_return_code_t>,
	pub read_variant_start: ::core::option::Option<unsafe extern "C" fn(arg1: *mut m_serial_local_t,
	                                                                    arg2: *mut m_serial_read_t,
	                                                                    field_name: *const [*const core::ffi::c_char; 0usize],
	                                                                    max: core::ffi::c_int,
	                                                                    arg3: *mut core::ffi::c_int)
	                                                                    -> m_serial_return_code_t>,
	pub read_variant_end:
		::core::option::Option<unsafe extern "C" fn(arg1: *mut m_serial_local_t, arg2: *mut m_serial_read_t) -> m_serial_return_code_t>,
}
#[test]
fn bindgen_test_layout_m_serial_read_interface_s() {
	assert_eq!(
	           ::core::mem::size_of::<m_serial_read_interface_s>(),
	           52usize,
	           concat!("Size of: ", stringify!(m_serial_read_interface_s))
	);
	assert_eq!(
	           ::core::mem::align_of::<m_serial_read_interface_s>(),
	           4usize,
	           concat!("Alignment of ", stringify!(m_serial_read_interface_s))
	);
	fn test_field_read_boolean() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<m_serial_read_interface_s>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).read_boolean) as usize - ptr as usize
		           },
		           0usize,
		           concat!(
			"Offset of field: ",
			stringify!(m_serial_read_interface_s),
			"::",
			stringify!(read_boolean)
		)
		);
	}
	test_field_read_boolean();
	fn test_field_read_integer() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<m_serial_read_interface_s>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).read_integer) as usize - ptr as usize
		           },
		           4usize,
		           concat!(
			"Offset of field: ",
			stringify!(m_serial_read_interface_s),
			"::",
			stringify!(read_integer)
		)
		);
	}
	test_field_read_integer();
	fn test_field_read_float() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<m_serial_read_interface_s>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).read_float) as usize - ptr as usize
		           },
		           8usize,
		           concat!(
			"Offset of field: ",
			stringify!(m_serial_read_interface_s),
			"::",
			stringify!(read_float)
		)
		);
	}
	test_field_read_float();
	fn test_field_read_string() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<m_serial_read_interface_s>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).read_string) as usize - ptr as usize
		           },
		           12usize,
		           concat!(
			"Offset of field: ",
			stringify!(m_serial_read_interface_s),
			"::",
			stringify!(read_string)
		)
		);
	}
	test_field_read_string();
	fn test_field_read_array_start() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<m_serial_read_interface_s>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).read_array_start) as usize - ptr as usize
		           },
		           16usize,
		           concat!(
			"Offset of field: ",
			stringify!(m_serial_read_interface_s),
			"::",
			stringify!(read_array_start)
		)
		);
	}
	test_field_read_array_start();
	fn test_field_read_array_next() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<m_serial_read_interface_s>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).read_array_next) as usize - ptr as usize
		           },
		           20usize,
		           concat!(
			"Offset of field: ",
			stringify!(m_serial_read_interface_s),
			"::",
			stringify!(read_array_next)
		)
		);
	}
	test_field_read_array_next();
	fn test_field_read_map_start() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<m_serial_read_interface_s>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).read_map_start) as usize - ptr as usize
		           },
		           24usize,
		           concat!(
			"Offset of field: ",
			stringify!(m_serial_read_interface_s),
			"::",
			stringify!(read_map_start)
		)
		);
	}
	test_field_read_map_start();
	fn test_field_read_map_value() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<m_serial_read_interface_s>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).read_map_value) as usize - ptr as usize
		           },
		           28usize,
		           concat!(
			"Offset of field: ",
			stringify!(m_serial_read_interface_s),
			"::",
			stringify!(read_map_value)
		)
		);
	}
	test_field_read_map_value();
	fn test_field_read_map_next() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<m_serial_read_interface_s>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).read_map_next) as usize - ptr as usize
		           },
		           32usize,
		           concat!(
			"Offset of field: ",
			stringify!(m_serial_read_interface_s),
			"::",
			stringify!(read_map_next)
		)
		);
	}
	test_field_read_map_next();
	fn test_field_read_tuple_start() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<m_serial_read_interface_s>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).read_tuple_start) as usize - ptr as usize
		           },
		           36usize,
		           concat!(
			"Offset of field: ",
			stringify!(m_serial_read_interface_s),
			"::",
			stringify!(read_tuple_start)
		)
		);
	}
	test_field_read_tuple_start();
	fn test_field_read_tuple_id() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<m_serial_read_interface_s>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).read_tuple_id) as usize - ptr as usize
		           },
		           40usize,
		           concat!(
			"Offset of field: ",
			stringify!(m_serial_read_interface_s),
			"::",
			stringify!(read_tuple_id)
		)
		);
	}
	test_field_read_tuple_id();
	fn test_field_read_variant_start() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<m_serial_read_interface_s>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).read_variant_start) as usize - ptr as usize
		           },
		           44usize,
		           concat!(
			"Offset of field: ",
			stringify!(m_serial_read_interface_s),
			"::",
			stringify!(read_variant_start)
		)
		);
	}
	test_field_read_variant_start();
	fn test_field_read_variant_end() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<m_serial_read_interface_s>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).read_variant_end) as usize - ptr as usize
		           },
		           48usize,
		           concat!(
			"Offset of field: ",
			stringify!(m_serial_read_interface_s),
			"::",
			stringify!(read_variant_end)
		)
		);
	}
	test_field_read_variant_end();
}
pub type m_serial_read_interface_t = m_serial_read_interface_s;
#[repr(C)]
pub struct m_serial_write_s {
	pub m_interface: *const m_serial_write_interface_s,
	pub tmp: m_serial_ll_ct,
	pub data: [m_serial_ll_ct; 4usize],
}
#[test]
fn bindgen_test_layout_m_serial_write_s() {
	assert_eq!(
	           ::core::mem::size_of::<m_serial_write_s>(),
	           48usize,
	           concat!("Size of: ", stringify!(m_serial_write_s))
	);
	assert_eq!(
	           ::core::mem::align_of::<m_serial_write_s>(),
	           8usize,
	           concat!("Alignment of ", stringify!(m_serial_write_s))
	);
	fn test_field_m_interface() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<m_serial_write_s>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).m_interface) as usize - ptr as usize
		           },
		           0usize,
		           concat!(
			"Offset of field: ",
			stringify!(m_serial_write_s),
			"::",
			stringify!(m_interface)
		)
		);
	}
	test_field_m_interface();
	fn test_field_tmp() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<m_serial_write_s>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).tmp) as usize - ptr as usize
		           },
		           8usize,
		           concat!("Offset of field: ", stringify!(m_serial_write_s), "::", stringify!(tmp))
		);
	}
	test_field_tmp();
	fn test_field_data() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<m_serial_write_s>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).data) as usize - ptr as usize
		           },
		           16usize,
		           concat!("Offset of field: ", stringify!(m_serial_write_s), "::", stringify!(data))
		);
	}
	test_field_data();
}
pub type m_serial_write_t = [m_serial_write_s; 1usize];
#[repr(C)]
pub struct m_serial_write_interface_s {
	pub write_boolean: ::core::option::Option<unsafe extern "C" fn(arg1: *mut m_serial_write_t, data: bool) -> m_serial_return_code_t>,
	pub write_integer: ::core::option::Option<unsafe extern "C" fn(arg1: *mut m_serial_write_t,
	                                                               data: core::ffi::c_longlong,
	                                                               size_of_type: usize)
	                                                               -> m_serial_return_code_t>,
	pub write_float: ::core::option::Option<unsafe extern "C" fn(arg1: *mut m_serial_write_t,
	                                                             data: f64,
	                                                             size_of_type: usize)
	                                                             -> m_serial_return_code_t>,
	pub write_string: ::core::option::Option<unsafe extern "C" fn(arg1: *mut m_serial_write_t,
	                                                              data: *const [core::ffi::c_char; 0usize],
	                                                              len: usize)
	                                                              -> m_serial_return_code_t>,
	pub write_array_start: ::core::option::Option<unsafe extern "C" fn(arg1: *mut m_serial_local_t,
	                                                                   arg2: *mut m_serial_write_t,
	                                                                   number_of_elements: usize)
	                                                                   -> m_serial_return_code_t>,
	pub write_array_next: ::core::option::Option<unsafe extern "C" fn(arg1: *mut m_serial_local_t,
	                                                                  arg2: *mut m_serial_write_t)
	                                                                  -> m_serial_return_code_t>,
	pub write_array_end: ::core::option::Option<unsafe extern "C" fn(arg1: *mut m_serial_local_t,
	                                                                 arg2: *mut m_serial_write_t)
	                                                                 -> m_serial_return_code_t>,
	pub write_map_start: ::core::option::Option<unsafe extern "C" fn(arg1: *mut m_serial_local_t,
	                                                                 arg2: *mut m_serial_write_t,
	                                                                 number_of_elements: usize)
	                                                                 -> m_serial_return_code_t>,
	pub write_map_value: ::core::option::Option<unsafe extern "C" fn(arg1: *mut m_serial_local_t,
	                                                                 arg2: *mut m_serial_write_t)
	                                                                 -> m_serial_return_code_t>,
	pub write_map_next: ::core::option::Option<unsafe extern "C" fn(arg1: *mut m_serial_local_t,
	                                                                arg2: *mut m_serial_write_t)
	                                                                -> m_serial_return_code_t>,
	pub write_map_end: ::core::option::Option<unsafe extern "C" fn(arg1: *mut m_serial_local_t,
	                                                               arg2: *mut m_serial_write_t)
	                                                               -> m_serial_return_code_t>,
	pub write_tuple_start: ::core::option::Option<unsafe extern "C" fn(arg1: *mut m_serial_local_t,
	                                                                   arg2: *mut m_serial_write_t)
	                                                                   -> m_serial_return_code_t>,
	pub write_tuple_id: ::core::option::Option<unsafe extern "C" fn(arg1: *mut m_serial_local_t,
	                                                                arg2: *mut m_serial_write_t,
	                                                                field_name: *const [*const core::ffi::c_char; 0usize],
	                                                                max: core::ffi::c_int,
	                                                                index: core::ffi::c_int)
	                                                                -> m_serial_return_code_t>,
	pub write_tuple_end: ::core::option::Option<unsafe extern "C" fn(arg1: *mut m_serial_local_t,
	                                                                 arg2: *mut m_serial_write_t)
	                                                                 -> m_serial_return_code_t>,
	pub write_variant_start: ::core::option::Option<unsafe extern "C" fn(arg1: *mut m_serial_local_t,
	                                                                     arg2: *mut m_serial_write_t,
	                                                                     field_name: *const [*const core::ffi::c_char; 0usize],
	                                                                     max: core::ffi::c_int,
	                                                                     index: core::ffi::c_int)
	                                                                     -> m_serial_return_code_t>,
	pub write_variant_end: ::core::option::Option<unsafe extern "C" fn(arg1: *mut m_serial_local_t,
	                                                                   arg2: *mut m_serial_write_t)
	                                                                   -> m_serial_return_code_t>,
}
#[test]
fn bindgen_test_layout_m_serial_write_interface_s() {
	assert_eq!(
	           ::core::mem::size_of::<m_serial_write_interface_s>(),
	           64usize,
	           concat!("Size of: ", stringify!(m_serial_write_interface_s))
	);
	assert_eq!(
	           ::core::mem::align_of::<m_serial_write_interface_s>(),
	           4usize,
	           concat!("Alignment of ", stringify!(m_serial_write_interface_s))
	);
	fn test_field_write_boolean() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<m_serial_write_interface_s>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).write_boolean) as usize - ptr as usize
		           },
		           0usize,
		           concat!(
			"Offset of field: ",
			stringify!(m_serial_write_interface_s),
			"::",
			stringify!(write_boolean)
		)
		);
	}
	test_field_write_boolean();
	fn test_field_write_integer() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<m_serial_write_interface_s>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).write_integer) as usize - ptr as usize
		           },
		           4usize,
		           concat!(
			"Offset of field: ",
			stringify!(m_serial_write_interface_s),
			"::",
			stringify!(write_integer)
		)
		);
	}
	test_field_write_integer();
	fn test_field_write_float() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<m_serial_write_interface_s>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).write_float) as usize - ptr as usize
		           },
		           8usize,
		           concat!(
			"Offset of field: ",
			stringify!(m_serial_write_interface_s),
			"::",
			stringify!(write_float)
		)
		);
	}
	test_field_write_float();
	fn test_field_write_string() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<m_serial_write_interface_s>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).write_string) as usize - ptr as usize
		           },
		           12usize,
		           concat!(
			"Offset of field: ",
			stringify!(m_serial_write_interface_s),
			"::",
			stringify!(write_string)
		)
		);
	}
	test_field_write_string();
	fn test_field_write_array_start() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<m_serial_write_interface_s>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).write_array_start) as usize - ptr as usize
		           },
		           16usize,
		           concat!(
			"Offset of field: ",
			stringify!(m_serial_write_interface_s),
			"::",
			stringify!(write_array_start)
		)
		);
	}
	test_field_write_array_start();
	fn test_field_write_array_next() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<m_serial_write_interface_s>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).write_array_next) as usize - ptr as usize
		           },
		           20usize,
		           concat!(
			"Offset of field: ",
			stringify!(m_serial_write_interface_s),
			"::",
			stringify!(write_array_next)
		)
		);
	}
	test_field_write_array_next();
	fn test_field_write_array_end() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<m_serial_write_interface_s>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).write_array_end) as usize - ptr as usize
		           },
		           24usize,
		           concat!(
			"Offset of field: ",
			stringify!(m_serial_write_interface_s),
			"::",
			stringify!(write_array_end)
		)
		);
	}
	test_field_write_array_end();
	fn test_field_write_map_start() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<m_serial_write_interface_s>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).write_map_start) as usize - ptr as usize
		           },
		           28usize,
		           concat!(
			"Offset of field: ",
			stringify!(m_serial_write_interface_s),
			"::",
			stringify!(write_map_start)
		)
		);
	}
	test_field_write_map_start();
	fn test_field_write_map_value() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<m_serial_write_interface_s>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).write_map_value) as usize - ptr as usize
		           },
		           32usize,
		           concat!(
			"Offset of field: ",
			stringify!(m_serial_write_interface_s),
			"::",
			stringify!(write_map_value)
		)
		);
	}
	test_field_write_map_value();
	fn test_field_write_map_next() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<m_serial_write_interface_s>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).write_map_next) as usize - ptr as usize
		           },
		           36usize,
		           concat!(
			"Offset of field: ",
			stringify!(m_serial_write_interface_s),
			"::",
			stringify!(write_map_next)
		)
		);
	}
	test_field_write_map_next();
	fn test_field_write_map_end() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<m_serial_write_interface_s>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).write_map_end) as usize - ptr as usize
		           },
		           40usize,
		           concat!(
			"Offset of field: ",
			stringify!(m_serial_write_interface_s),
			"::",
			stringify!(write_map_end)
		)
		);
	}
	test_field_write_map_end();
	fn test_field_write_tuple_start() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<m_serial_write_interface_s>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).write_tuple_start) as usize - ptr as usize
		           },
		           44usize,
		           concat!(
			"Offset of field: ",
			stringify!(m_serial_write_interface_s),
			"::",
			stringify!(write_tuple_start)
		)
		);
	}
	test_field_write_tuple_start();
	fn test_field_write_tuple_id() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<m_serial_write_interface_s>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).write_tuple_id) as usize - ptr as usize
		           },
		           48usize,
		           concat!(
			"Offset of field: ",
			stringify!(m_serial_write_interface_s),
			"::",
			stringify!(write_tuple_id)
		)
		);
	}
	test_field_write_tuple_id();
	fn test_field_write_tuple_end() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<m_serial_write_interface_s>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).write_tuple_end) as usize - ptr as usize
		           },
		           52usize,
		           concat!(
			"Offset of field: ",
			stringify!(m_serial_write_interface_s),
			"::",
			stringify!(write_tuple_end)
		)
		);
	}
	test_field_write_tuple_end();
	fn test_field_write_variant_start() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<m_serial_write_interface_s>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).write_variant_start) as usize - ptr as usize
		           },
		           56usize,
		           concat!(
			"Offset of field: ",
			stringify!(m_serial_write_interface_s),
			"::",
			stringify!(write_variant_start)
		)
		);
	}
	test_field_write_variant_start();
	fn test_field_write_variant_end() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<m_serial_write_interface_s>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).write_variant_end) as usize - ptr as usize
		           },
		           60usize,
		           concat!(
			"Offset of field: ",
			stringify!(m_serial_write_interface_s),
			"::",
			stringify!(write_variant_end)
		)
		);
	}
	test_field_write_variant_end();
}
pub type m_serial_write_interface_t = m_serial_write_interface_s;
#[repr(C)]
pub struct string_heap_s {
	pub size: usize,
	pub alloc: usize,
}
#[test]
fn bindgen_test_layout_string_heap_s() {
	assert_eq!(
	           ::core::mem::size_of::<string_heap_s>(),
	           8usize,
	           concat!("Size of: ", stringify!(string_heap_s))
	);
	assert_eq!(
	           ::core::mem::align_of::<string_heap_s>(),
	           4usize,
	           concat!("Alignment of ", stringify!(string_heap_s))
	);
	fn test_field_size() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<string_heap_s>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).size) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(string_heap_s), "::", stringify!(size))
		);
	}
	test_field_size();
	fn test_field_alloc() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<string_heap_s>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).alloc) as usize - ptr as usize
		           },
		           4usize,
		           concat!("Offset of field: ", stringify!(string_heap_s), "::", stringify!(alloc))
		);
	}
	test_field_alloc();
}
pub type string_heap_ct = string_heap_s;
#[repr(C)]
pub struct string_stack_s {
	pub buffer: [core::ffi::c_char; 8usize],
}
#[test]
fn bindgen_test_layout_string_stack_s() {
	assert_eq!(
	           ::core::mem::size_of::<string_stack_s>(),
	           8usize,
	           concat!("Size of: ", stringify!(string_stack_s))
	);
	assert_eq!(
	           ::core::mem::align_of::<string_stack_s>(),
	           1usize,
	           concat!("Alignment of ", stringify!(string_stack_s))
	);
	fn test_field_buffer() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<string_stack_s>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).buffer) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(string_stack_s), "::", stringify!(buffer))
		);
	}
	test_field_buffer();
}
pub type string_stack_ct = string_stack_s;
#[repr(C)]
pub struct string_union_u {
	pub heap: __BindgenUnionField<string_heap_ct>,
	pub stack: __BindgenUnionField<string_stack_ct>,
	pub bindgen_union_field: [u32; 2usize],
}
#[test]
fn bindgen_test_layout_string_union_u() {
	assert_eq!(
	           ::core::mem::size_of::<string_union_u>(),
	           8usize,
	           concat!("Size of: ", stringify!(string_union_u))
	);
	assert_eq!(
	           ::core::mem::align_of::<string_union_u>(),
	           4usize,
	           concat!("Alignment of ", stringify!(string_union_u))
	);
	fn test_field_heap() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<string_union_u>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).heap) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(string_union_u), "::", stringify!(heap))
		);
	}
	test_field_heap();
	fn test_field_stack() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<string_union_u>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).stack) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(string_union_u), "::", stringify!(stack))
		);
	}
	test_field_stack();
}
pub type string_union_ct = string_union_u;
#[repr(C)]
pub struct string_s {
	pub u: string_union_ct,
	pub ptr: *mut core::ffi::c_char,
}
#[test]
fn bindgen_test_layout_string_s() {
	assert_eq!(
	           ::core::mem::size_of::<string_s>(),
	           12usize,
	           concat!("Size of: ", stringify!(string_s))
	);
	assert_eq!(
	           ::core::mem::align_of::<string_s>(),
	           4usize,
	           concat!("Alignment of ", stringify!(string_s))
	);
	fn test_field_u() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<string_s>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).u) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(string_s), "::", stringify!(u))
		);
	}
	test_field_u();
	fn test_field_ptr() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<string_s>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).ptr) as usize - ptr as usize
		           },
		           8usize,
		           concat!("Offset of field: ", stringify!(string_s), "::", stringify!(ptr))
		);
	}
	test_field_ptr();
}
pub type string_t = [string_s; 1usize];
pub type string_ptr = *mut string_s;
pub type string_srcptr = *const string_s;
#[repr(u32)]
#[non_exhaustive]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum string_fgets_e {
	STRING_READ_LINE = 0,
	STRING_READ_PURE_LINE = 1,
	STRING_READ_FILE = 2,
}
pub use self::string_fgets_e as string_fgets_t;
#[repr(u32)]
#[non_exhaustive]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum m_str1ng_utf8_state_e {
	M_STRING_UTF8_STARTING = 0,
	M_STRING_UTF8_DECODING_1 = 8,
	M_STRING_UTF8_DECODING_2 = 16,
	M_STRING_UTF8_DOCODING_3 = 24,
	M_STRING_UTF8_ERROR = 32,
}
pub type string_unicode_t = core::ffi::c_uint;
#[repr(C)]
pub struct string_it_s {
	pub u: string_unicode_t,
	pub ptr: *const core::ffi::c_char,
	pub next_ptr: *const core::ffi::c_char,
}
#[test]
fn bindgen_test_layout_string_it_s() {
	assert_eq!(
	           ::core::mem::size_of::<string_it_s>(),
	           12usize,
	           concat!("Size of: ", stringify!(string_it_s))
	);
	assert_eq!(
	           ::core::mem::align_of::<string_it_s>(),
	           4usize,
	           concat!("Alignment of ", stringify!(string_it_s))
	);
	fn test_field_u() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<string_it_s>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).u) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(string_it_s), "::", stringify!(u))
		);
	}
	test_field_u();
	fn test_field_ptr() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<string_it_s>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).ptr) as usize - ptr as usize
		           },
		           4usize,
		           concat!("Offset of field: ", stringify!(string_it_s), "::", stringify!(ptr))
		);
	}
	test_field_ptr();
	fn test_field_next_ptr() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<string_it_s>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).next_ptr) as usize - ptr as usize
		           },
		           8usize,
		           concat!("Offset of field: ", stringify!(string_it_s), "::", stringify!(next_ptr))
		);
	}
	test_field_next_ptr();
}
pub type string_it_t = [string_it_s; 1usize];
#[repr(u32)]
#[non_exhaustive]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum CliSymbols {
	CliSymbolAsciiSOH = 1,
	CliSymbolAsciiETX = 3,
	CliSymbolAsciiEOT = 4,
	CliSymbolAsciiBell = 7,
	CliSymbolAsciiBackspace = 8,
	CliSymbolAsciiTab = 9,
	CliSymbolAsciiLF = 10,
	CliSymbolAsciiCR = 13,
	CliSymbolAsciiEsc = 27,
	CliSymbolAsciiUS = 31,
	CliSymbolAsciiSpace = 32,
	CliSymbolAsciiDel = 127,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum CliCommandFlag {
	#[doc = "< Default, loader lock is used"]
	CliCommandFlagDefault = 0,
	CliCommandFlagParallelSafe = 1,
	#[doc = "< Safe to run with insomnia mode on"]
	CliCommandFlagInsomniaSafe = 2,
}
#[repr(C)]
pub struct Cli {
	_unused: [u8; 0],
}
#[doc = " Cli callback function pointer. Implement this interface and use"]
#[doc = " add_cli_command"]
#[doc = " @param      args     string with what was passed after command"]
#[doc = " @param      context  pointer to whatever you gave us on cli_add_command"]
pub type CliCallback =
	::core::option::Option<unsafe extern "C" fn(cli: *mut Cli, args: *mut string_t, context: *mut core::ffi::c_void)>;
extern "C" {
	#[doc = " Add cli command Registers you command callback"]
	#[doc = ""]
	#[doc = " @param      cli       pointer to cli instance"]
	#[doc = " @param      name      command name"]
	#[doc = " @param      flags     CliCommandFlag"]
	#[doc = " @param      callback  callback function"]
	#[doc = " @param      context   pointer to whatever we need to pass to callback"]
	pub fn cli_add_command(cli: *mut Cli,
	                       name: *const core::ffi::c_char,
	                       flags: CliCommandFlag,
	                       callback: CliCallback,
	                       context: *mut core::ffi::c_void);
}
extern "C" {
	#[doc = " Print unified cmd usage tip"]
	#[doc = ""]
	#[doc = " @param      cmd    cmd name"]
	#[doc = " @param      usage  usage tip"]
	#[doc = " @param      arg    arg passed by user"]
	pub fn cli_print_usage(cmd: *const core::ffi::c_char, usage: *const core::ffi::c_char, arg: *const core::ffi::c_char);
}
extern "C" {
	#[doc = " Delete cli command"]
	#[doc = ""]
	#[doc = " @param      cli   pointer to cli instance"]
	#[doc = " @param      name  command name"]
	pub fn cli_delete_command(cli: *mut Cli, name: *const core::ffi::c_char);
}
extern "C" {
	#[doc = " Read from terminal"]
	#[doc = ""]
	#[doc = " @param      cli     Cli instance"]
	#[doc = " @param      buffer  pointer to buffer"]
	#[doc = " @param      size    size of buffer in bytes"]
	#[doc = ""]
	#[doc = " @return     bytes read"]
	pub fn cli_read(cli: *mut Cli, buffer: *mut u8, size: usize) -> usize;
}
extern "C" {
	#[doc = " Non-blocking read from terminal"]
	#[doc = ""]
	#[doc = " @param      cli     Cli instance"]
	#[doc = " @param      buffer  pointer to buffer"]
	#[doc = " @param      size    size of buffer in bytes"]
	#[doc = " @param      timeout timeout value in ms"]
	#[doc = ""]
	#[doc = " @return     bytes read"]
	pub fn cli_read_timeout(cli: *mut Cli, buffer: *mut u8, size: usize, timeout: u32) -> usize;
}
extern "C" {
	#[doc = " Non-blocking check for interrupt command received"]
	#[doc = ""]
	#[doc = " @param      cli   Cli instance"]
	#[doc = ""]
	#[doc = " @return     true if received"]
	pub fn cli_cmd_interrupt_received(cli: *mut Cli) -> bool;
}
extern "C" {
	#[doc = " Write to terminal Do it only from inside of cli call."]
	#[doc = ""]
	#[doc = " @param      cli     Cli instance"]
	#[doc = " @param      buffer  pointer to buffer"]
	#[doc = " @param      size    size of buffer in bytes"]
	pub fn cli_write(cli: *mut Cli, buffer: *const u8, size: usize);
}
extern "C" {
	#[doc = " Read character"]
	#[doc = ""]
	#[doc = " @param      cli   Cli instance"]
	#[doc = ""]
	#[doc = " @return     char"]
	pub fn cli_getc(cli: *mut Cli) -> core::ffi::c_char;
}
extern "C" {
	#[doc = " New line Send new ine sequence"]
	pub fn cli_nl();
}
extern "C" {
	pub fn cli_session_open(cli: *mut Cli, session: *mut core::ffi::c_void);
}
extern "C" {
	pub fn cli_session_close(cli: *mut Cli);
}
extern "C" {
	pub fn cli_is_connected(cli: *mut Cli) -> bool;
}
#[repr(C)]
pub struct CliSession {
	_unused: [u8; 0],
}
extern "C" {
	pub static mut cli_vcp: CliSession;
}
extern "C" {
	#[doc = " Crash system"]
	pub fn furi_crash(message: *const core::ffi::c_char);
}
extern "C" {
	#[doc = " Halt system"]
	pub fn furi_halt(message: *const core::ffi::c_char);
}
extern "C" {
	#[doc = "< System Clock Frequency"]
	pub static mut SystemCoreClock: u32;
}
extern "C" {
	pub fn furi_thread_catch();
}
pub type TaskFunction_t = ::core::option::Option<unsafe extern "C" fn(arg1: *mut core::ffi::c_void)>;
pub type StackType_t = u32;
pub type BaseType_t = core::ffi::c_long;
pub type UBaseType_t = core::ffi::c_ulong;
pub type TickType_t = u32;
extern "C" {
	pub fn vPortEnterCritical();
}
extern "C" {
	pub fn vPortExitCritical();
}
extern "C" {
	pub fn vPortSuppressTicksAndSleep(xExpectedIdleTime: TickType_t);
}
extern "C" {
	pub fn pxPortInitialiseStack(pxTopOfStack: *mut StackType_t,
	                             pxCode: TaskFunction_t,
	                             pvParameters: *mut core::ffi::c_void)
	                             -> *mut StackType_t;
}
#[repr(C)]
pub struct HeapRegion {
	pub pucStartAddress: *mut u8,
	pub xSizeInBytes: usize,
}
#[test]
fn bindgen_test_layout_HeapRegion() {
	assert_eq!(
	           ::core::mem::size_of::<HeapRegion>(),
	           8usize,
	           concat!("Size of: ", stringify!(HeapRegion))
	);
	assert_eq!(
	           ::core::mem::align_of::<HeapRegion>(),
	           4usize,
	           concat!("Alignment of ", stringify!(HeapRegion))
	);
	fn test_field_pucStartAddress() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<HeapRegion>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).pucStartAddress) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(HeapRegion), "::", stringify!(pucStartAddress))
		);
	}
	test_field_pucStartAddress();
	fn test_field_xSizeInBytes() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<HeapRegion>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).xSizeInBytes) as usize - ptr as usize
		           },
		           4usize,
		           concat!("Offset of field: ", stringify!(HeapRegion), "::", stringify!(xSizeInBytes))
		);
	}
	test_field_xSizeInBytes();
}
pub type HeapRegion_t = HeapRegion;
#[repr(C)]
pub struct xHeapStats {
	pub xAvailableHeapSpaceInBytes: usize,
	pub xSizeOfLargestFreeBlockInBytes: usize,
	pub xSizeOfSmallestFreeBlockInBytes: usize,
	pub xNumberOfFreeBlocks: usize,
	pub xMinimumEverFreeBytesRemaining: usize,
	pub xNumberOfSuccessfulAllocations: usize,
	pub xNumberOfSuccessfulFrees: usize,
}
#[test]
fn bindgen_test_layout_xHeapStats() {
	assert_eq!(
	           ::core::mem::size_of::<xHeapStats>(),
	           28usize,
	           concat!("Size of: ", stringify!(xHeapStats))
	);
	assert_eq!(
	           ::core::mem::align_of::<xHeapStats>(),
	           4usize,
	           concat!("Alignment of ", stringify!(xHeapStats))
	);
	fn test_field_xAvailableHeapSpaceInBytes() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<xHeapStats>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).xAvailableHeapSpaceInBytes) as usize - ptr as usize
		           },
		           0usize,
		           concat!(
			"Offset of field: ",
			stringify!(xHeapStats),
			"::",
			stringify!(xAvailableHeapSpaceInBytes)
		)
		);
	}
	test_field_xAvailableHeapSpaceInBytes();
	fn test_field_xSizeOfLargestFreeBlockInBytes() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<xHeapStats>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).xSizeOfLargestFreeBlockInBytes) as usize - ptr as usize
		           },
		           4usize,
		           concat!(
			"Offset of field: ",
			stringify!(xHeapStats),
			"::",
			stringify!(xSizeOfLargestFreeBlockInBytes)
		)
		);
	}
	test_field_xSizeOfLargestFreeBlockInBytes();
	fn test_field_xSizeOfSmallestFreeBlockInBytes() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<xHeapStats>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).xSizeOfSmallestFreeBlockInBytes) as usize - ptr as usize
		           },
		           8usize,
		           concat!(
			"Offset of field: ",
			stringify!(xHeapStats),
			"::",
			stringify!(xSizeOfSmallestFreeBlockInBytes)
		)
		);
	}
	test_field_xSizeOfSmallestFreeBlockInBytes();
	fn test_field_xNumberOfFreeBlocks() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<xHeapStats>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).xNumberOfFreeBlocks) as usize - ptr as usize
		           },
		           12usize,
		           concat!(
			"Offset of field: ",
			stringify!(xHeapStats),
			"::",
			stringify!(xNumberOfFreeBlocks)
		)
		);
	}
	test_field_xNumberOfFreeBlocks();
	fn test_field_xMinimumEverFreeBytesRemaining() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<xHeapStats>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).xMinimumEverFreeBytesRemaining) as usize - ptr as usize
		           },
		           16usize,
		           concat!(
			"Offset of field: ",
			stringify!(xHeapStats),
			"::",
			stringify!(xMinimumEverFreeBytesRemaining)
		)
		);
	}
	test_field_xMinimumEverFreeBytesRemaining();
	fn test_field_xNumberOfSuccessfulAllocations() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<xHeapStats>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).xNumberOfSuccessfulAllocations) as usize - ptr as usize
		           },
		           20usize,
		           concat!(
			"Offset of field: ",
			stringify!(xHeapStats),
			"::",
			stringify!(xNumberOfSuccessfulAllocations)
		)
		);
	}
	test_field_xNumberOfSuccessfulAllocations();
	fn test_field_xNumberOfSuccessfulFrees() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<xHeapStats>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).xNumberOfSuccessfulFrees) as usize - ptr as usize
		           },
		           24usize,
		           concat!(
			"Offset of field: ",
			stringify!(xHeapStats),
			"::",
			stringify!(xNumberOfSuccessfulFrees)
		)
		);
	}
	test_field_xNumberOfSuccessfulFrees();
}
pub type HeapStats_t = xHeapStats;
extern "C" {
	pub fn vPortDefineHeapRegions(pxHeapRegions: *const HeapRegion_t);
}
extern "C" {
	pub fn vPortGetHeapStats(pxHeapStats: *mut HeapStats_t);
}
extern "C" {
	pub fn pvPortMalloc(xSize: usize) -> *mut core::ffi::c_void;
}
extern "C" {
	pub fn vPortFree(pv: *mut core::ffi::c_void);
}
extern "C" {
	pub fn vPortInitialiseBlocks();
}
extern "C" {
	pub fn xPortGetFreeHeapSize() -> usize;
}
extern "C" {
	pub fn xPortGetMinimumEverFreeHeapSize() -> usize;
}
extern "C" {
	pub fn xPortStartScheduler() -> BaseType_t;
}
extern "C" {
	pub fn vPortEndScheduler();
}
#[repr(C)]
pub struct xSTATIC_LIST_ITEM {
	pub xDummy2: TickType_t,
	pub pvDummy3: [*mut core::ffi::c_void; 4usize],
}
#[test]
fn bindgen_test_layout_xSTATIC_LIST_ITEM() {
	assert_eq!(
	           ::core::mem::size_of::<xSTATIC_LIST_ITEM>(),
	           20usize,
	           concat!("Size of: ", stringify!(xSTATIC_LIST_ITEM))
	);
	assert_eq!(
	           ::core::mem::align_of::<xSTATIC_LIST_ITEM>(),
	           4usize,
	           concat!("Alignment of ", stringify!(xSTATIC_LIST_ITEM))
	);
	fn test_field_xDummy2() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<xSTATIC_LIST_ITEM>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).xDummy2) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(xSTATIC_LIST_ITEM), "::", stringify!(xDummy2))
		);
	}
	test_field_xDummy2();
	fn test_field_pvDummy3() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<xSTATIC_LIST_ITEM>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).pvDummy3) as usize - ptr as usize
		           },
		           4usize,
		           concat!("Offset of field: ", stringify!(xSTATIC_LIST_ITEM), "::", stringify!(pvDummy3))
		);
	}
	test_field_pvDummy3();
}
pub type StaticListItem_t = xSTATIC_LIST_ITEM;
#[repr(C)]
pub struct xSTATIC_MINI_LIST_ITEM {
	pub xDummy2: TickType_t,
	pub pvDummy3: [*mut core::ffi::c_void; 2usize],
}
#[test]
fn bindgen_test_layout_xSTATIC_MINI_LIST_ITEM() {
	assert_eq!(
	           ::core::mem::size_of::<xSTATIC_MINI_LIST_ITEM>(),
	           12usize,
	           concat!("Size of: ", stringify!(xSTATIC_MINI_LIST_ITEM))
	);
	assert_eq!(
	           ::core::mem::align_of::<xSTATIC_MINI_LIST_ITEM>(),
	           4usize,
	           concat!("Alignment of ", stringify!(xSTATIC_MINI_LIST_ITEM))
	);
	fn test_field_xDummy2() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<xSTATIC_MINI_LIST_ITEM>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).xDummy2) as usize - ptr as usize
		           },
		           0usize,
		           concat!(
			"Offset of field: ",
			stringify!(xSTATIC_MINI_LIST_ITEM),
			"::",
			stringify!(xDummy2)
		)
		);
	}
	test_field_xDummy2();
	fn test_field_pvDummy3() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<xSTATIC_MINI_LIST_ITEM>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).pvDummy3) as usize - ptr as usize
		           },
		           4usize,
		           concat!(
			"Offset of field: ",
			stringify!(xSTATIC_MINI_LIST_ITEM),
			"::",
			stringify!(pvDummy3)
		)
		);
	}
	test_field_pvDummy3();
}
pub type StaticMiniListItem_t = xSTATIC_MINI_LIST_ITEM;
#[repr(C)]
pub struct xSTATIC_LIST {
	pub uxDummy2: UBaseType_t,
	pub pvDummy3: *mut core::ffi::c_void,
	pub xDummy4: StaticMiniListItem_t,
}
#[test]
fn bindgen_test_layout_xSTATIC_LIST() {
	assert_eq!(
	           ::core::mem::size_of::<xSTATIC_LIST>(),
	           20usize,
	           concat!("Size of: ", stringify!(xSTATIC_LIST))
	);
	assert_eq!(
	           ::core::mem::align_of::<xSTATIC_LIST>(),
	           4usize,
	           concat!("Alignment of ", stringify!(xSTATIC_LIST))
	);
	fn test_field_uxDummy2() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<xSTATIC_LIST>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).uxDummy2) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(xSTATIC_LIST), "::", stringify!(uxDummy2))
		);
	}
	test_field_uxDummy2();
	fn test_field_pvDummy3() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<xSTATIC_LIST>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).pvDummy3) as usize - ptr as usize
		           },
		           4usize,
		           concat!("Offset of field: ", stringify!(xSTATIC_LIST), "::", stringify!(pvDummy3))
		);
	}
	test_field_pvDummy3();
	fn test_field_xDummy4() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<xSTATIC_LIST>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).xDummy4) as usize - ptr as usize
		           },
		           8usize,
		           concat!("Offset of field: ", stringify!(xSTATIC_LIST), "::", stringify!(xDummy4))
		);
	}
	test_field_xDummy4();
}
pub type StaticList_t = xSTATIC_LIST;
#[repr(C)]
pub struct xSTATIC_TCB {
	pub pxDummy1: *mut core::ffi::c_void,
	pub xDummy3: [StaticListItem_t; 2usize],
	pub uxDummy5: UBaseType_t,
	pub pxDummy6: *mut core::ffi::c_void,
	pub ucDummy7: [u8; 16usize],
	pub pxDummy8: *mut core::ffi::c_void,
	pub uxDummy10: [UBaseType_t; 2usize],
	pub uxDummy12: [UBaseType_t; 2usize],
	pub pvDummy15: [*mut core::ffi::c_void; 1usize],
	pub ulDummy18: [u32; 2usize],
	pub ucDummy19: [u8; 2usize],
	pub uxDummy20: u8,
}
#[test]
fn bindgen_test_layout_xSTATIC_TCB() {
	assert_eq!(
	           ::core::mem::size_of::<xSTATIC_TCB>(),
	           104usize,
	           concat!("Size of: ", stringify!(xSTATIC_TCB))
	);
	assert_eq!(
	           ::core::mem::align_of::<xSTATIC_TCB>(),
	           4usize,
	           concat!("Alignment of ", stringify!(xSTATIC_TCB))
	);
	fn test_field_pxDummy1() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<xSTATIC_TCB>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).pxDummy1) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(xSTATIC_TCB), "::", stringify!(pxDummy1))
		);
	}
	test_field_pxDummy1();
	fn test_field_xDummy3() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<xSTATIC_TCB>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).xDummy3) as usize - ptr as usize
		           },
		           4usize,
		           concat!("Offset of field: ", stringify!(xSTATIC_TCB), "::", stringify!(xDummy3))
		);
	}
	test_field_xDummy3();
	fn test_field_uxDummy5() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<xSTATIC_TCB>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).uxDummy5) as usize - ptr as usize
		           },
		           44usize,
		           concat!("Offset of field: ", stringify!(xSTATIC_TCB), "::", stringify!(uxDummy5))
		);
	}
	test_field_uxDummy5();
	fn test_field_pxDummy6() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<xSTATIC_TCB>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).pxDummy6) as usize - ptr as usize
		           },
		           48usize,
		           concat!("Offset of field: ", stringify!(xSTATIC_TCB), "::", stringify!(pxDummy6))
		);
	}
	test_field_pxDummy6();
	fn test_field_ucDummy7() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<xSTATIC_TCB>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).ucDummy7) as usize - ptr as usize
		           },
		           52usize,
		           concat!("Offset of field: ", stringify!(xSTATIC_TCB), "::", stringify!(ucDummy7))
		);
	}
	test_field_ucDummy7();
	fn test_field_pxDummy8() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<xSTATIC_TCB>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).pxDummy8) as usize - ptr as usize
		           },
		           68usize,
		           concat!("Offset of field: ", stringify!(xSTATIC_TCB), "::", stringify!(pxDummy8))
		);
	}
	test_field_pxDummy8();
	fn test_field_uxDummy10() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<xSTATIC_TCB>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).uxDummy10) as usize - ptr as usize
		           },
		           72usize,
		           concat!("Offset of field: ", stringify!(xSTATIC_TCB), "::", stringify!(uxDummy10))
		);
	}
	test_field_uxDummy10();
	fn test_field_uxDummy12() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<xSTATIC_TCB>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).uxDummy12) as usize - ptr as usize
		           },
		           80usize,
		           concat!("Offset of field: ", stringify!(xSTATIC_TCB), "::", stringify!(uxDummy12))
		);
	}
	test_field_uxDummy12();
	fn test_field_pvDummy15() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<xSTATIC_TCB>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).pvDummy15) as usize - ptr as usize
		           },
		           88usize,
		           concat!("Offset of field: ", stringify!(xSTATIC_TCB), "::", stringify!(pvDummy15))
		);
	}
	test_field_pvDummy15();
	fn test_field_ulDummy18() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<xSTATIC_TCB>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).ulDummy18) as usize - ptr as usize
		           },
		           92usize,
		           concat!("Offset of field: ", stringify!(xSTATIC_TCB), "::", stringify!(ulDummy18))
		);
	}
	test_field_ulDummy18();
	fn test_field_ucDummy19() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<xSTATIC_TCB>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).ucDummy19) as usize - ptr as usize
		           },
		           100usize,
		           concat!("Offset of field: ", stringify!(xSTATIC_TCB), "::", stringify!(ucDummy19))
		);
	}
	test_field_ucDummy19();
	fn test_field_uxDummy20() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<xSTATIC_TCB>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).uxDummy20) as usize - ptr as usize
		           },
		           102usize,
		           concat!("Offset of field: ", stringify!(xSTATIC_TCB), "::", stringify!(uxDummy20))
		);
	}
	test_field_uxDummy20();
}
pub type StaticTask_t = xSTATIC_TCB;
#[repr(C)]
pub struct xSTATIC_QUEUE {
	pub pvDummy1: [*mut core::ffi::c_void; 3usize],
	pub u: xSTATIC_QUEUE__bindgen_ty_1,
	pub xDummy3: [StaticList_t; 2usize],
	pub uxDummy4: [UBaseType_t; 3usize],
	pub ucDummy5: [u8; 2usize],
	pub ucDummy6: u8,
	pub uxDummy8: UBaseType_t,
	pub ucDummy9: u8,
}
#[repr(C)]
pub struct xSTATIC_QUEUE__bindgen_ty_1 {
	pub pvDummy2: __BindgenUnionField<*mut core::ffi::c_void>,
	pub uxDummy2: __BindgenUnionField<UBaseType_t>,
	pub bindgen_union_field: u32,
}
#[test]
fn bindgen_test_layout_xSTATIC_QUEUE__bindgen_ty_1() {
	assert_eq!(
	           ::core::mem::size_of::<xSTATIC_QUEUE__bindgen_ty_1>(),
	           4usize,
	           concat!("Size of: ", stringify!(xSTATIC_QUEUE__bindgen_ty_1))
	);
	assert_eq!(
	           ::core::mem::align_of::<xSTATIC_QUEUE__bindgen_ty_1>(),
	           4usize,
	           concat!("Alignment of ", stringify!(xSTATIC_QUEUE__bindgen_ty_1))
	);
	fn test_field_pvDummy2() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<xSTATIC_QUEUE__bindgen_ty_1>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).pvDummy2) as usize - ptr as usize
		           },
		           0usize,
		           concat!(
			"Offset of field: ",
			stringify!(xSTATIC_QUEUE__bindgen_ty_1),
			"::",
			stringify!(pvDummy2)
		)
		);
	}
	test_field_pvDummy2();
	fn test_field_uxDummy2() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<xSTATIC_QUEUE__bindgen_ty_1>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).uxDummy2) as usize - ptr as usize
		           },
		           0usize,
		           concat!(
			"Offset of field: ",
			stringify!(xSTATIC_QUEUE__bindgen_ty_1),
			"::",
			stringify!(uxDummy2)
		)
		);
	}
	test_field_uxDummy2();
}
#[test]
fn bindgen_test_layout_xSTATIC_QUEUE() {
	assert_eq!(
	           ::core::mem::size_of::<xSTATIC_QUEUE>(),
	           80usize,
	           concat!("Size of: ", stringify!(xSTATIC_QUEUE))
	);
	assert_eq!(
	           ::core::mem::align_of::<xSTATIC_QUEUE>(),
	           4usize,
	           concat!("Alignment of ", stringify!(xSTATIC_QUEUE))
	);
	fn test_field_pvDummy1() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<xSTATIC_QUEUE>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).pvDummy1) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(xSTATIC_QUEUE), "::", stringify!(pvDummy1))
		);
	}
	test_field_pvDummy1();
	fn test_field_u() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<xSTATIC_QUEUE>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).u) as usize - ptr as usize
		           },
		           12usize,
		           concat!("Offset of field: ", stringify!(xSTATIC_QUEUE), "::", stringify!(u))
		);
	}
	test_field_u();
	fn test_field_xDummy3() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<xSTATIC_QUEUE>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).xDummy3) as usize - ptr as usize
		           },
		           16usize,
		           concat!("Offset of field: ", stringify!(xSTATIC_QUEUE), "::", stringify!(xDummy3))
		);
	}
	test_field_xDummy3();
	fn test_field_uxDummy4() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<xSTATIC_QUEUE>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).uxDummy4) as usize - ptr as usize
		           },
		           56usize,
		           concat!("Offset of field: ", stringify!(xSTATIC_QUEUE), "::", stringify!(uxDummy4))
		);
	}
	test_field_uxDummy4();
	fn test_field_ucDummy5() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<xSTATIC_QUEUE>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).ucDummy5) as usize - ptr as usize
		           },
		           68usize,
		           concat!("Offset of field: ", stringify!(xSTATIC_QUEUE), "::", stringify!(ucDummy5))
		);
	}
	test_field_ucDummy5();
	fn test_field_ucDummy6() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<xSTATIC_QUEUE>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).ucDummy6) as usize - ptr as usize
		           },
		           70usize,
		           concat!("Offset of field: ", stringify!(xSTATIC_QUEUE), "::", stringify!(ucDummy6))
		);
	}
	test_field_ucDummy6();
	fn test_field_uxDummy8() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<xSTATIC_QUEUE>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).uxDummy8) as usize - ptr as usize
		           },
		           72usize,
		           concat!("Offset of field: ", stringify!(xSTATIC_QUEUE), "::", stringify!(uxDummy8))
		);
	}
	test_field_uxDummy8();
	fn test_field_ucDummy9() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<xSTATIC_QUEUE>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).ucDummy9) as usize - ptr as usize
		           },
		           76usize,
		           concat!("Offset of field: ", stringify!(xSTATIC_QUEUE), "::", stringify!(ucDummy9))
		);
	}
	test_field_ucDummy9();
}
pub type StaticQueue_t = xSTATIC_QUEUE;
pub type StaticSemaphore_t = StaticQueue_t;
#[repr(C)]
pub struct xSTATIC_EVENT_GROUP {
	pub xDummy1: TickType_t,
	pub xDummy2: StaticList_t,
	pub uxDummy3: UBaseType_t,
	pub ucDummy4: u8,
}
#[test]
fn bindgen_test_layout_xSTATIC_EVENT_GROUP() {
	assert_eq!(
	           ::core::mem::size_of::<xSTATIC_EVENT_GROUP>(),
	           32usize,
	           concat!("Size of: ", stringify!(xSTATIC_EVENT_GROUP))
	);
	assert_eq!(
	           ::core::mem::align_of::<xSTATIC_EVENT_GROUP>(),
	           4usize,
	           concat!("Alignment of ", stringify!(xSTATIC_EVENT_GROUP))
	);
	fn test_field_xDummy1() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<xSTATIC_EVENT_GROUP>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).xDummy1) as usize - ptr as usize
		           },
		           0usize,
		           concat!(
			"Offset of field: ",
			stringify!(xSTATIC_EVENT_GROUP),
			"::",
			stringify!(xDummy1)
		)
		);
	}
	test_field_xDummy1();
	fn test_field_xDummy2() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<xSTATIC_EVENT_GROUP>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).xDummy2) as usize - ptr as usize
		           },
		           4usize,
		           concat!(
			"Offset of field: ",
			stringify!(xSTATIC_EVENT_GROUP),
			"::",
			stringify!(xDummy2)
		)
		);
	}
	test_field_xDummy2();
	fn test_field_uxDummy3() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<xSTATIC_EVENT_GROUP>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).uxDummy3) as usize - ptr as usize
		           },
		           24usize,
		           concat!(
			"Offset of field: ",
			stringify!(xSTATIC_EVENT_GROUP),
			"::",
			stringify!(uxDummy3)
		)
		);
	}
	test_field_uxDummy3();
	fn test_field_ucDummy4() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<xSTATIC_EVENT_GROUP>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).ucDummy4) as usize - ptr as usize
		           },
		           28usize,
		           concat!(
			"Offset of field: ",
			stringify!(xSTATIC_EVENT_GROUP),
			"::",
			stringify!(ucDummy4)
		)
		);
	}
	test_field_ucDummy4();
}
pub type StaticEventGroup_t = xSTATIC_EVENT_GROUP;
#[repr(C)]
pub struct xSTATIC_TIMER {
	pub pvDummy1: *mut core::ffi::c_void,
	pub xDummy2: StaticListItem_t,
	pub xDummy3: TickType_t,
	pub pvDummy5: *mut core::ffi::c_void,
	pub pvDummy6: TaskFunction_t,
	pub uxDummy7: UBaseType_t,
	pub ucDummy8: u8,
}
#[test]
fn bindgen_test_layout_xSTATIC_TIMER() {
	assert_eq!(
	           ::core::mem::size_of::<xSTATIC_TIMER>(),
	           44usize,
	           concat!("Size of: ", stringify!(xSTATIC_TIMER))
	);
	assert_eq!(
	           ::core::mem::align_of::<xSTATIC_TIMER>(),
	           4usize,
	           concat!("Alignment of ", stringify!(xSTATIC_TIMER))
	);
	fn test_field_pvDummy1() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<xSTATIC_TIMER>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).pvDummy1) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(xSTATIC_TIMER), "::", stringify!(pvDummy1))
		);
	}
	test_field_pvDummy1();
	fn test_field_xDummy2() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<xSTATIC_TIMER>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).xDummy2) as usize - ptr as usize
		           },
		           4usize,
		           concat!("Offset of field: ", stringify!(xSTATIC_TIMER), "::", stringify!(xDummy2))
		);
	}
	test_field_xDummy2();
	fn test_field_xDummy3() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<xSTATIC_TIMER>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).xDummy3) as usize - ptr as usize
		           },
		           24usize,
		           concat!("Offset of field: ", stringify!(xSTATIC_TIMER), "::", stringify!(xDummy3))
		);
	}
	test_field_xDummy3();
	fn test_field_pvDummy5() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<xSTATIC_TIMER>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).pvDummy5) as usize - ptr as usize
		           },
		           28usize,
		           concat!("Offset of field: ", stringify!(xSTATIC_TIMER), "::", stringify!(pvDummy5))
		);
	}
	test_field_pvDummy5();
	fn test_field_pvDummy6() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<xSTATIC_TIMER>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).pvDummy6) as usize - ptr as usize
		           },
		           32usize,
		           concat!("Offset of field: ", stringify!(xSTATIC_TIMER), "::", stringify!(pvDummy6))
		);
	}
	test_field_pvDummy6();
	fn test_field_uxDummy7() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<xSTATIC_TIMER>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).uxDummy7) as usize - ptr as usize
		           },
		           36usize,
		           concat!("Offset of field: ", stringify!(xSTATIC_TIMER), "::", stringify!(uxDummy7))
		);
	}
	test_field_uxDummy7();
	fn test_field_ucDummy8() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<xSTATIC_TIMER>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).ucDummy8) as usize - ptr as usize
		           },
		           40usize,
		           concat!("Offset of field: ", stringify!(xSTATIC_TIMER), "::", stringify!(ucDummy8))
		);
	}
	test_field_ucDummy8();
}
pub type StaticTimer_t = xSTATIC_TIMER;
#[repr(C)]
pub struct xSTATIC_STREAM_BUFFER {
	pub uxDummy1: [usize; 4usize],
	pub pvDummy2: [*mut core::ffi::c_void; 3usize],
	pub ucDummy3: u8,
	pub uxDummy4: UBaseType_t,
}
#[test]
fn bindgen_test_layout_xSTATIC_STREAM_BUFFER() {
	assert_eq!(
	           ::core::mem::size_of::<xSTATIC_STREAM_BUFFER>(),
	           36usize,
	           concat!("Size of: ", stringify!(xSTATIC_STREAM_BUFFER))
	);
	assert_eq!(
	           ::core::mem::align_of::<xSTATIC_STREAM_BUFFER>(),
	           4usize,
	           concat!("Alignment of ", stringify!(xSTATIC_STREAM_BUFFER))
	);
	fn test_field_uxDummy1() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<xSTATIC_STREAM_BUFFER>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).uxDummy1) as usize - ptr as usize
		           },
		           0usize,
		           concat!(
			"Offset of field: ",
			stringify!(xSTATIC_STREAM_BUFFER),
			"::",
			stringify!(uxDummy1)
		)
		);
	}
	test_field_uxDummy1();
	fn test_field_pvDummy2() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<xSTATIC_STREAM_BUFFER>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).pvDummy2) as usize - ptr as usize
		           },
		           16usize,
		           concat!(
			"Offset of field: ",
			stringify!(xSTATIC_STREAM_BUFFER),
			"::",
			stringify!(pvDummy2)
		)
		);
	}
	test_field_pvDummy2();
	fn test_field_ucDummy3() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<xSTATIC_STREAM_BUFFER>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).ucDummy3) as usize - ptr as usize
		           },
		           28usize,
		           concat!(
			"Offset of field: ",
			stringify!(xSTATIC_STREAM_BUFFER),
			"::",
			stringify!(ucDummy3)
		)
		);
	}
	test_field_ucDummy3();
	fn test_field_uxDummy4() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<xSTATIC_STREAM_BUFFER>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).uxDummy4) as usize - ptr as usize
		           },
		           32usize,
		           concat!(
			"Offset of field: ",
			stringify!(xSTATIC_STREAM_BUFFER),
			"::",
			stringify!(uxDummy4)
		)
		);
	}
	test_field_uxDummy4();
}
pub type StaticStreamBuffer_t = xSTATIC_STREAM_BUFFER;
pub type StaticMessageBuffer_t = StaticStreamBuffer_t;
#[repr(C)]
pub struct xLIST_ITEM {
	pub xItemValue: TickType_t,
	pub pxNext: *mut xLIST_ITEM,
	pub pxPrevious: *mut xLIST_ITEM,
	pub pvOwner: *mut core::ffi::c_void,
	pub pxContainer: *mut xLIST,
}
#[test]
fn bindgen_test_layout_xLIST_ITEM() {
	assert_eq!(
	           ::core::mem::size_of::<xLIST_ITEM>(),
	           20usize,
	           concat!("Size of: ", stringify!(xLIST_ITEM))
	);
	assert_eq!(
	           ::core::mem::align_of::<xLIST_ITEM>(),
	           4usize,
	           concat!("Alignment of ", stringify!(xLIST_ITEM))
	);
	fn test_field_xItemValue() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<xLIST_ITEM>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).xItemValue) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(xLIST_ITEM), "::", stringify!(xItemValue))
		);
	}
	test_field_xItemValue();
	fn test_field_pxNext() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<xLIST_ITEM>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).pxNext) as usize - ptr as usize
		           },
		           4usize,
		           concat!("Offset of field: ", stringify!(xLIST_ITEM), "::", stringify!(pxNext))
		);
	}
	test_field_pxNext();
	fn test_field_pxPrevious() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<xLIST_ITEM>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).pxPrevious) as usize - ptr as usize
		           },
		           8usize,
		           concat!("Offset of field: ", stringify!(xLIST_ITEM), "::", stringify!(pxPrevious))
		);
	}
	test_field_pxPrevious();
	fn test_field_pvOwner() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<xLIST_ITEM>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).pvOwner) as usize - ptr as usize
		           },
		           12usize,
		           concat!("Offset of field: ", stringify!(xLIST_ITEM), "::", stringify!(pvOwner))
		);
	}
	test_field_pvOwner();
	fn test_field_pxContainer() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<xLIST_ITEM>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).pxContainer) as usize - ptr as usize
		           },
		           16usize,
		           concat!("Offset of field: ", stringify!(xLIST_ITEM), "::", stringify!(pxContainer))
		);
	}
	test_field_pxContainer();
}
pub type ListItem_t = xLIST_ITEM;
#[repr(C)]
pub struct xMINI_LIST_ITEM {
	pub xItemValue: TickType_t,
	pub pxNext: *mut xLIST_ITEM,
	pub pxPrevious: *mut xLIST_ITEM,
}
#[test]
fn bindgen_test_layout_xMINI_LIST_ITEM() {
	assert_eq!(
	           ::core::mem::size_of::<xMINI_LIST_ITEM>(),
	           12usize,
	           concat!("Size of: ", stringify!(xMINI_LIST_ITEM))
	);
	assert_eq!(
	           ::core::mem::align_of::<xMINI_LIST_ITEM>(),
	           4usize,
	           concat!("Alignment of ", stringify!(xMINI_LIST_ITEM))
	);
	fn test_field_xItemValue() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<xMINI_LIST_ITEM>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).xItemValue) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(xMINI_LIST_ITEM), "::", stringify!(xItemValue))
		);
	}
	test_field_xItemValue();
	fn test_field_pxNext() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<xMINI_LIST_ITEM>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).pxNext) as usize - ptr as usize
		           },
		           4usize,
		           concat!("Offset of field: ", stringify!(xMINI_LIST_ITEM), "::", stringify!(pxNext))
		);
	}
	test_field_pxNext();
	fn test_field_pxPrevious() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<xMINI_LIST_ITEM>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).pxPrevious) as usize - ptr as usize
		           },
		           8usize,
		           concat!("Offset of field: ", stringify!(xMINI_LIST_ITEM), "::", stringify!(pxPrevious))
		);
	}
	test_field_pxPrevious();
}
pub type MiniListItem_t = xMINI_LIST_ITEM;
#[repr(C)]
pub struct xLIST {
	pub uxNumberOfItems: UBaseType_t,
	pub pxIndex: *mut ListItem_t,
	pub xListEnd: MiniListItem_t,
}
#[test]
fn bindgen_test_layout_xLIST() {
	assert_eq!(
	           ::core::mem::size_of::<xLIST>(),
	           20usize,
	           concat!("Size of: ", stringify!(xLIST))
	);
	assert_eq!(
	           ::core::mem::align_of::<xLIST>(),
	           4usize,
	           concat!("Alignment of ", stringify!(xLIST))
	);
	fn test_field_uxNumberOfItems() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<xLIST>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).uxNumberOfItems) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(xLIST), "::", stringify!(uxNumberOfItems))
		);
	}
	test_field_uxNumberOfItems();
	fn test_field_pxIndex() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<xLIST>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).pxIndex) as usize - ptr as usize
		           },
		           4usize,
		           concat!("Offset of field: ", stringify!(xLIST), "::", stringify!(pxIndex))
		);
	}
	test_field_pxIndex();
	fn test_field_xListEnd() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<xLIST>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).xListEnd) as usize - ptr as usize
		           },
		           8usize,
		           concat!("Offset of field: ", stringify!(xLIST), "::", stringify!(xListEnd))
		);
	}
	test_field_xListEnd();
}
pub type List_t = xLIST;
extern "C" {
	pub fn vListInitialise(pxList: *mut List_t);
}
extern "C" {
	pub fn vListInitialiseItem(pxItem: *mut ListItem_t);
}
extern "C" {
	pub fn vListInsert(pxList: *mut List_t, pxNewListItem: *mut ListItem_t);
}
extern "C" {
	pub fn vListInsertEnd(pxList: *mut List_t, pxNewListItem: *mut ListItem_t);
}
extern "C" {
	pub fn uxListRemove(pxItemToRemove: *mut ListItem_t) -> UBaseType_t;
}
#[doc = " task. h"]
#[doc = ""]
#[doc = " Type by which tasks are referenced.  For example, a call to xTaskCreate"]
#[doc = " returns (via a pointer parameter) an TaskHandle_t variable that can then"]
#[doc = " be used as a parameter to vTaskDelete to delete the task."]
#[doc = ""]
#[doc = " \\defgroup TaskHandle_t TaskHandle_t"]
#[doc = " \\ingroup Tasks"]
#[repr(C)]
pub struct tskTaskControlBlock {
	_unused: [u8; 0],
}
pub type TaskHandle_t = *mut tskTaskControlBlock;
pub type TaskHookFunction_t = ::core::option::Option<unsafe extern "C" fn(arg1: *mut core::ffi::c_void) -> BaseType_t>;
#[repr(u32)]
#[non_exhaustive]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum eTaskState {
	eRunning = 0,
	eReady = 1,
	eBlocked = 2,
	eSuspended = 3,
	eDeleted = 4,
	eInvalid = 5,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum eNotifyAction {
	eNoAction = 0,
	eSetBits = 1,
	eIncrement = 2,
	eSetValueWithOverwrite = 3,
	eSetValueWithoutOverwrite = 4,
}
#[repr(C)]
pub struct xTIME_OUT {
	pub xOverflowCount: BaseType_t,
	pub xTimeOnEntering: TickType_t,
}
#[test]
fn bindgen_test_layout_xTIME_OUT() {
	assert_eq!(
	           ::core::mem::size_of::<xTIME_OUT>(),
	           8usize,
	           concat!("Size of: ", stringify!(xTIME_OUT))
	);
	assert_eq!(
	           ::core::mem::align_of::<xTIME_OUT>(),
	           4usize,
	           concat!("Alignment of ", stringify!(xTIME_OUT))
	);
	fn test_field_xOverflowCount() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<xTIME_OUT>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).xOverflowCount) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(xTIME_OUT), "::", stringify!(xOverflowCount))
		);
	}
	test_field_xOverflowCount();
	fn test_field_xTimeOnEntering() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<xTIME_OUT>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).xTimeOnEntering) as usize - ptr as usize
		           },
		           4usize,
		           concat!("Offset of field: ", stringify!(xTIME_OUT), "::", stringify!(xTimeOnEntering))
		);
	}
	test_field_xTimeOnEntering();
}
pub type TimeOut_t = xTIME_OUT;
#[repr(C)]
pub struct xMEMORY_REGION {
	pub pvBaseAddress: *mut core::ffi::c_void,
	pub ulLengthInBytes: u32,
	pub ulParameters: u32,
}
#[test]
fn bindgen_test_layout_xMEMORY_REGION() {
	assert_eq!(
	           ::core::mem::size_of::<xMEMORY_REGION>(),
	           12usize,
	           concat!("Size of: ", stringify!(xMEMORY_REGION))
	);
	assert_eq!(
	           ::core::mem::align_of::<xMEMORY_REGION>(),
	           4usize,
	           concat!("Alignment of ", stringify!(xMEMORY_REGION))
	);
	fn test_field_pvBaseAddress() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<xMEMORY_REGION>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).pvBaseAddress) as usize - ptr as usize
		           },
		           0usize,
		           concat!(
			"Offset of field: ",
			stringify!(xMEMORY_REGION),
			"::",
			stringify!(pvBaseAddress)
		)
		);
	}
	test_field_pvBaseAddress();
	fn test_field_ulLengthInBytes() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<xMEMORY_REGION>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).ulLengthInBytes) as usize - ptr as usize
		           },
		           4usize,
		           concat!(
			"Offset of field: ",
			stringify!(xMEMORY_REGION),
			"::",
			stringify!(ulLengthInBytes)
		)
		);
	}
	test_field_ulLengthInBytes();
	fn test_field_ulParameters() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<xMEMORY_REGION>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).ulParameters) as usize - ptr as usize
		           },
		           8usize,
		           concat!(
			"Offset of field: ",
			stringify!(xMEMORY_REGION),
			"::",
			stringify!(ulParameters)
		)
		);
	}
	test_field_ulParameters();
}
pub type MemoryRegion_t = xMEMORY_REGION;
#[repr(C)]
pub struct xTASK_PARAMETERS {
	pub pvTaskCode: TaskFunction_t,
	pub pcName: *const core::ffi::c_char,
	pub usStackDepth: u16,
	pub pvParameters: *mut core::ffi::c_void,
	pub uxPriority: UBaseType_t,
	pub puxStackBuffer: *mut StackType_t,
	pub xRegions: [MemoryRegion_t; 1usize],
}
#[test]
fn bindgen_test_layout_xTASK_PARAMETERS() {
	assert_eq!(
	           ::core::mem::size_of::<xTASK_PARAMETERS>(),
	           36usize,
	           concat!("Size of: ", stringify!(xTASK_PARAMETERS))
	);
	assert_eq!(
	           ::core::mem::align_of::<xTASK_PARAMETERS>(),
	           4usize,
	           concat!("Alignment of ", stringify!(xTASK_PARAMETERS))
	);
	fn test_field_pvTaskCode() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<xTASK_PARAMETERS>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).pvTaskCode) as usize - ptr as usize
		           },
		           0usize,
		           concat!(
			"Offset of field: ",
			stringify!(xTASK_PARAMETERS),
			"::",
			stringify!(pvTaskCode)
		)
		);
	}
	test_field_pvTaskCode();
	fn test_field_pcName() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<xTASK_PARAMETERS>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).pcName) as usize - ptr as usize
		           },
		           4usize,
		           concat!("Offset of field: ", stringify!(xTASK_PARAMETERS), "::", stringify!(pcName))
		);
	}
	test_field_pcName();
	fn test_field_usStackDepth() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<xTASK_PARAMETERS>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).usStackDepth) as usize - ptr as usize
		           },
		           8usize,
		           concat!(
			"Offset of field: ",
			stringify!(xTASK_PARAMETERS),
			"::",
			stringify!(usStackDepth)
		)
		);
	}
	test_field_usStackDepth();
	fn test_field_pvParameters() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<xTASK_PARAMETERS>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).pvParameters) as usize - ptr as usize
		           },
		           12usize,
		           concat!(
			"Offset of field: ",
			stringify!(xTASK_PARAMETERS),
			"::",
			stringify!(pvParameters)
		)
		);
	}
	test_field_pvParameters();
	fn test_field_uxPriority() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<xTASK_PARAMETERS>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).uxPriority) as usize - ptr as usize
		           },
		           16usize,
		           concat!(
			"Offset of field: ",
			stringify!(xTASK_PARAMETERS),
			"::",
			stringify!(uxPriority)
		)
		);
	}
	test_field_uxPriority();
	fn test_field_puxStackBuffer() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<xTASK_PARAMETERS>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).puxStackBuffer) as usize - ptr as usize
		           },
		           20usize,
		           concat!(
			"Offset of field: ",
			stringify!(xTASK_PARAMETERS),
			"::",
			stringify!(puxStackBuffer)
		)
		);
	}
	test_field_puxStackBuffer();
	fn test_field_xRegions() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<xTASK_PARAMETERS>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).xRegions) as usize - ptr as usize
		           },
		           24usize,
		           concat!("Offset of field: ", stringify!(xTASK_PARAMETERS), "::", stringify!(xRegions))
		);
	}
	test_field_xRegions();
}
pub type TaskParameters_t = xTASK_PARAMETERS;
#[repr(C)]
pub struct xTASK_STATUS {
	pub xHandle: TaskHandle_t,
	pub pcTaskName: *const core::ffi::c_char,
	pub xTaskNumber: UBaseType_t,
	pub eCurrentState: eTaskState,
	pub uxCurrentPriority: UBaseType_t,
	pub uxBasePriority: UBaseType_t,
	pub ulRunTimeCounter: u32,
	pub pxStackBase: *mut StackType_t,
	pub usStackHighWaterMark: u16,
}
#[test]
fn bindgen_test_layout_xTASK_STATUS() {
	assert_eq!(
	           ::core::mem::size_of::<xTASK_STATUS>(),
	           36usize,
	           concat!("Size of: ", stringify!(xTASK_STATUS))
	);
	assert_eq!(
	           ::core::mem::align_of::<xTASK_STATUS>(),
	           4usize,
	           concat!("Alignment of ", stringify!(xTASK_STATUS))
	);
	fn test_field_xHandle() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<xTASK_STATUS>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).xHandle) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(xTASK_STATUS), "::", stringify!(xHandle))
		);
	}
	test_field_xHandle();
	fn test_field_pcTaskName() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<xTASK_STATUS>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).pcTaskName) as usize - ptr as usize
		           },
		           4usize,
		           concat!("Offset of field: ", stringify!(xTASK_STATUS), "::", stringify!(pcTaskName))
		);
	}
	test_field_pcTaskName();
	fn test_field_xTaskNumber() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<xTASK_STATUS>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).xTaskNumber) as usize - ptr as usize
		           },
		           8usize,
		           concat!("Offset of field: ", stringify!(xTASK_STATUS), "::", stringify!(xTaskNumber))
		);
	}
	test_field_xTaskNumber();
	fn test_field_eCurrentState() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<xTASK_STATUS>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).eCurrentState) as usize - ptr as usize
		           },
		           12usize,
		           concat!("Offset of field: ", stringify!(xTASK_STATUS), "::", stringify!(eCurrentState))
		);
	}
	test_field_eCurrentState();
	fn test_field_uxCurrentPriority() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<xTASK_STATUS>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).uxCurrentPriority) as usize - ptr as usize
		           },
		           16usize,
		           concat!(
			"Offset of field: ",
			stringify!(xTASK_STATUS),
			"::",
			stringify!(uxCurrentPriority)
		)
		);
	}
	test_field_uxCurrentPriority();
	fn test_field_uxBasePriority() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<xTASK_STATUS>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).uxBasePriority) as usize - ptr as usize
		           },
		           20usize,
		           concat!(
			"Offset of field: ",
			stringify!(xTASK_STATUS),
			"::",
			stringify!(uxBasePriority)
		)
		);
	}
	test_field_uxBasePriority();
	fn test_field_ulRunTimeCounter() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<xTASK_STATUS>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).ulRunTimeCounter) as usize - ptr as usize
		           },
		           24usize,
		           concat!(
			"Offset of field: ",
			stringify!(xTASK_STATUS),
			"::",
			stringify!(ulRunTimeCounter)
		)
		);
	}
	test_field_ulRunTimeCounter();
	fn test_field_pxStackBase() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<xTASK_STATUS>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).pxStackBase) as usize - ptr as usize
		           },
		           28usize,
		           concat!("Offset of field: ", stringify!(xTASK_STATUS), "::", stringify!(pxStackBase))
		);
	}
	test_field_pxStackBase();
	fn test_field_usStackHighWaterMark() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<xTASK_STATUS>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).usStackHighWaterMark) as usize - ptr as usize
		           },
		           32usize,
		           concat!(
			"Offset of field: ",
			stringify!(xTASK_STATUS),
			"::",
			stringify!(usStackHighWaterMark)
		)
		);
	}
	test_field_usStackHighWaterMark();
}
pub type TaskStatus_t = xTASK_STATUS;
#[repr(u32)]
#[non_exhaustive]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum eSleepModeStatus {
	eAbortSleep = 0,
	eStandardSleep = 1,
	eNoTasksWaitingTimeout = 2,
}
extern "C" {
	pub fn xTaskCreate(pxTaskCode: TaskFunction_t,
	                   pcName: *const core::ffi::c_char,
	                   usStackDepth: u16,
	                   pvParameters: *mut core::ffi::c_void,
	                   uxPriority: UBaseType_t,
	                   pxCreatedTask: *mut TaskHandle_t)
	                   -> BaseType_t;
}
extern "C" {
	pub fn xTaskCreateStatic(pxTaskCode: TaskFunction_t,
	                         pcName: *const core::ffi::c_char,
	                         ulStackDepth: u32,
	                         pvParameters: *mut core::ffi::c_void,
	                         uxPriority: UBaseType_t,
	                         puxStackBuffer: *mut StackType_t,
	                         pxTaskBuffer: *mut StaticTask_t)
	                         -> TaskHandle_t;
}
extern "C" {
	#[doc = " task. h"]
	#[doc = " @code{c}"]
	#[doc = " void vTaskAllocateMPURegions( TaskHandle_t xTask, const MemoryRegion_t * const pxRegions );"]
	#[doc = " @endcode"]
	#[doc = ""]
	#[doc = " Memory regions are assigned to a restricted task when the task is created by"]
	#[doc = " a call to xTaskCreateRestricted().  These regions can be redefined using"]
	#[doc = " vTaskAllocateMPURegions()."]
	#[doc = ""]
	#[doc = " @param xTask The handle of the task being updated."]
	#[doc = ""]
	#[doc = " @param xRegions A pointer to a MemoryRegion_t structure that contains the"]
	#[doc = " new memory region definitions."]
	#[doc = ""]
	#[doc = " Example usage:"]
	#[doc = " @code{c}"]
	#[doc = " // Define an array of MemoryRegion_t structures that configures an MPU region"]
	#[doc = " // allowing read/write access for 1024 bytes starting at the beginning of the"]
	#[doc = " // ucOneKByte array.  The other two of the maximum 3 definable regions are"]
	#[doc = " // unused so set to zero."]
	#[doc = " static const MemoryRegion_t xAltRegions[ portNUM_CONFIGURABLE_REGIONS ] ="]
	#[doc = " {"]
	#[doc = "  // Base address     Length      Parameters"]
	#[doc = "  { ucOneKByte,       1024,       portMPU_REGION_READ_WRITE },"]
	#[doc = "  { 0,                0,          0 },"]
	#[doc = "  { 0,                0,          0 }"]
	#[doc = " };"]
	#[doc = ""]
	#[doc = " void vATask( void *pvParameters )"]
	#[doc = " {"]
	#[doc = "  // This task was created such that it has access to certain regions of"]
	#[doc = "  // memory as defined by the MPU configuration.  At some point it is"]
	#[doc = "  // desired that these MPU regions are replaced with that defined in the"]
	#[doc = "  // xAltRegions const struct above.  Use a call to vTaskAllocateMPURegions()"]
	#[doc = "  // for this purpose.  NULL is used as the task handle to indicate that this"]
	#[doc = "  // function should modify the MPU regions of the calling task."]
	#[doc = "  vTaskAllocateMPURegions( NULL, xAltRegions );"]
	#[doc = ""]
	#[doc = "  // Now the task can continue its function, but from this point on can only"]
	#[doc = "  // access its stack and the ucOneKByte array (unless any other statically"]
	#[doc = "  // defined or shared regions have been declared elsewhere)."]
	#[doc = " }"]
	#[doc = " @endcode"]
	#[doc = " \\defgroup xTaskCreateRestricted xTaskCreateRestricted"]
	#[doc = " \\ingroup Tasks"]
	pub fn vTaskAllocateMPURegions(xTask: TaskHandle_t, pxRegions: *const MemoryRegion_t);
}
extern "C" {
	#[doc = " task. h"]
	#[doc = " @code{c}"]
	#[doc = " void vTaskDelete( TaskHandle_t xTaskToDelete );"]
	#[doc = " @endcode"]
	#[doc = ""]
	#[doc = " INCLUDE_vTaskDelete must be defined as 1 for this function to be available."]
	#[doc = " See the configuration section for more information."]
	#[doc = ""]
	#[doc = " Remove a task from the RTOS real time kernel's management.  The task being"]
	#[doc = " deleted will be removed from all ready, blocked, suspended and event lists."]
	#[doc = ""]
	#[doc = " NOTE:  The idle task is responsible for freeing the kernel allocated"]
	#[doc = " memory from tasks that have been deleted.  It is therefore important that"]
	#[doc = " the idle task is not starved of microcontroller processing time if your"]
	#[doc = " application makes any calls to vTaskDelete ().  Memory allocated by the"]
	#[doc = " task code is not automatically freed, and should be freed before the task"]
	#[doc = " is deleted."]
	#[doc = ""]
	#[doc = " See the demo application file death.c for sample code that utilises"]
	#[doc = " vTaskDelete ()."]
	#[doc = ""]
	#[doc = " @param xTaskToDelete The handle of the task to be deleted.  Passing NULL will"]
	#[doc = " cause the calling task to be deleted."]
	#[doc = ""]
	#[doc = " Example usage:"]
	#[doc = " @code{c}"]
	#[doc = " void vOtherFunction( void )"]
	#[doc = " {"]
	#[doc = " TaskHandle_t xHandle;"]
	#[doc = ""]
	#[doc = "   // Create the task, storing the handle."]
	#[doc = "   xTaskCreate( vTaskCode, \"NAME\", STACK_SIZE, NULL, tskIDLE_PRIORITY, &xHandle );"]
	#[doc = ""]
	#[doc = "   // Use the handle to delete the task."]
	#[doc = "   vTaskDelete( xHandle );"]
	#[doc = " }"]
	#[doc = " @endcode"]
	#[doc = " \\defgroup vTaskDelete vTaskDelete"]
	#[doc = " \\ingroup Tasks"]
	pub fn vTaskDelete(xTaskToDelete: TaskHandle_t);
}
extern "C" {
	#[doc = " task. h"]
	#[doc = " @code{c}"]
	#[doc = " void vTaskDelay( const TickType_t xTicksToDelay );"]
	#[doc = " @endcode"]
	#[doc = ""]
	#[doc = " Delay a task for a given number of ticks.  The actual time that the"]
	#[doc = " task remains blocked depends on the tick rate.  The constant"]
	#[doc = " portTICK_PERIOD_MS can be used to calculate real time from the tick"]
	#[doc = " rate - with the resolution of one tick period."]
	#[doc = ""]
	#[doc = " INCLUDE_vTaskDelay must be defined as 1 for this function to be available."]
	#[doc = " See the configuration section for more information."]
	#[doc = ""]
	#[doc = ""]
	#[doc = " vTaskDelay() specifies a time at which the task wishes to unblock relative to"]
	#[doc = " the time at which vTaskDelay() is called.  For example, specifying a block"]
	#[doc = " period of 100 ticks will cause the task to unblock 100 ticks after"]
	#[doc = " vTaskDelay() is called.  vTaskDelay() does not therefore provide a good method"]
	#[doc = " of controlling the frequency of a periodic task as the path taken through the"]
	#[doc = " code, as well as other task and interrupt activity, will affect the frequency"]
	#[doc = " at which vTaskDelay() gets called and therefore the time at which the task"]
	#[doc = " next executes.  See xTaskDelayUntil() for an alternative API function designed"]
	#[doc = " to facilitate fixed frequency execution.  It does this by specifying an"]
	#[doc = " absolute time (rather than a relative time) at which the calling task should"]
	#[doc = " unblock."]
	#[doc = ""]
	#[doc = " @param xTicksToDelay The amount of time, in tick periods, that"]
	#[doc = " the calling task should block."]
	#[doc = ""]
	#[doc = " Example usage:"]
	#[doc = ""]
	#[doc = " void vTaskFunction( void * pvParameters )"]
	#[doc = " {"]
	#[doc = " // Block for 500ms."]
	#[doc = " const TickType_t xDelay = 500 / portTICK_PERIOD_MS;"]
	#[doc = ""]
	#[doc = "   for( ;; )"]
	#[doc = "   {"]
	#[doc = "       // Simply toggle the LED every 500ms, blocking between each toggle."]
	#[doc = "       vToggleLED();"]
	#[doc = "       vTaskDelay( xDelay );"]
	#[doc = "   }"]
	#[doc = " }"]
	#[doc = ""]
	#[doc = " \\defgroup vTaskDelay vTaskDelay"]
	#[doc = " \\ingroup TaskCtrl"]
	pub fn vTaskDelay(xTicksToDelay: TickType_t);
}
extern "C" {
	#[doc = " task. h"]
	#[doc = " @code{c}"]
	#[doc = " BaseType_t xTaskDelayUntil( TickType_t *pxPreviousWakeTime, const TickType_t xTimeIncrement );"]
	#[doc = " @endcode"]
	#[doc = ""]
	#[doc = " INCLUDE_xTaskDelayUntil must be defined as 1 for this function to be available."]
	#[doc = " See the configuration section for more information."]
	#[doc = ""]
	#[doc = " Delay a task until a specified time.  This function can be used by periodic"]
	#[doc = " tasks to ensure a constant execution frequency."]
	#[doc = ""]
	#[doc = " This function differs from vTaskDelay () in one important aspect:  vTaskDelay () will"]
	#[doc = " cause a task to block for the specified number of ticks from the time vTaskDelay () is"]
	#[doc = " called.  It is therefore difficult to use vTaskDelay () by itself to generate a fixed"]
	#[doc = " execution frequency as the time between a task starting to execute and that task"]
	#[doc = " calling vTaskDelay () may not be fixed [the task may take a different path though the"]
	#[doc = " code between calls, or may get interrupted or preempted a different number of times"]
	#[doc = " each time it executes]."]
	#[doc = ""]
	#[doc = " Whereas vTaskDelay () specifies a wake time relative to the time at which the function"]
	#[doc = " is called, xTaskDelayUntil () specifies the absolute (exact) time at which it wishes to"]
	#[doc = " unblock."]
	#[doc = ""]
	#[doc = " The macro pdMS_TO_TICKS() can be used to calculate the number of ticks from a"]
	#[doc = " time specified in milliseconds with a resolution of one tick period."]
	#[doc = ""]
	#[doc = " @param pxPreviousWakeTime Pointer to a variable that holds the time at which the"]
	#[doc = " task was last unblocked.  The variable must be initialised with the current time"]
	#[doc = " prior to its first use (see the example below).  Following this the variable is"]
	#[doc = " automatically updated within xTaskDelayUntil ()."]
	#[doc = ""]
	#[doc = " @param xTimeIncrement The cycle time period.  The task will be unblocked at"]
	#[doc = " time *pxPreviousWakeTime + xTimeIncrement.  Calling xTaskDelayUntil with the"]
	#[doc = " same xTimeIncrement parameter value will cause the task to execute with"]
	#[doc = " a fixed interface period."]
	#[doc = ""]
	#[doc = " @return Value which can be used to check whether the task was actually delayed."]
	#[doc = " Will be pdTRUE if the task way delayed and pdFALSE otherwise.  A task will not"]
	#[doc = " be delayed if the next expected wake time is in the past."]
	#[doc = ""]
	#[doc = " Example usage:"]
	#[doc = " @code{c}"]
	#[doc = " // Perform an action every 10 ticks."]
	#[doc = " void vTaskFunction( void * pvParameters )"]
	#[doc = " {"]
	#[doc = " TickType_t xLastWakeTime;"]
	#[doc = " const TickType_t xFrequency = 10;"]
	#[doc = " BaseType_t xWasDelayed;"]
	#[doc = ""]
	#[doc = "     // Initialise the xLastWakeTime variable with the current time."]
	#[doc = "     xLastWakeTime = xTaskGetTickCount ();"]
	#[doc = "     for( ;; )"]
	#[doc = "     {"]
	#[doc = "         // Wait for the next cycle."]
	#[doc = "         xWasDelayed = xTaskDelayUntil( &xLastWakeTime, xFrequency );"]
	#[doc = ""]
	#[doc = "         // Perform action here. xWasDelayed value can be used to determine"]
	#[doc = "         // whether a deadline was missed if the code here took too long."]
	#[doc = "     }"]
	#[doc = " }"]
	#[doc = " @endcode"]
	#[doc = " \\defgroup xTaskDelayUntil xTaskDelayUntil"]
	#[doc = " \\ingroup TaskCtrl"]
	pub fn xTaskDelayUntil(pxPreviousWakeTime: *mut TickType_t, xTimeIncrement: TickType_t) -> BaseType_t;
}
extern "C" {
	#[doc = " task. h"]
	#[doc = " @code{c}"]
	#[doc = " BaseType_t xTaskAbortDelay( TaskHandle_t xTask );"]
	#[doc = " @endcode"]
	#[doc = ""]
	#[doc = " INCLUDE_xTaskAbortDelay must be defined as 1 in FreeRTOSConfig.h for this"]
	#[doc = " function to be available."]
	#[doc = ""]
	#[doc = " A task will enter the Blocked state when it is waiting for an event.  The"]
	#[doc = " event it is waiting for can be a temporal event (waiting for a time), such"]
	#[doc = " as when vTaskDelay() is called, or an event on an object, such as when"]
	#[doc = " xQueueReceive() or ulTaskNotifyTake() is called.  If the handle of a task"]
	#[doc = " that is in the Blocked state is used in a call to xTaskAbortDelay() then the"]
	#[doc = " task will leave the Blocked state, and return from whichever function call"]
	#[doc = " placed the task into the Blocked state."]
	#[doc = ""]
	#[doc = " There is no 'FromISR' version of this function as an interrupt would need to"]
	#[doc = " know which object a task was blocked on in order to know which actions to"]
	#[doc = " take.  For example, if the task was blocked on a queue the interrupt handler"]
	#[doc = " would then need to know if the queue was locked."]
	#[doc = ""]
	#[doc = " @param xTask The handle of the task to remove from the Blocked state."]
	#[doc = ""]
	#[doc = " @return If the task referenced by xTask was not in the Blocked state then"]
	#[doc = " pdFAIL is returned.  Otherwise pdPASS is returned."]
	#[doc = ""]
	#[doc = " \\defgroup xTaskAbortDelay xTaskAbortDelay"]
	#[doc = " \\ingroup TaskCtrl"]
	pub fn xTaskAbortDelay(xTask: TaskHandle_t) -> BaseType_t;
}
extern "C" {
	#[doc = " task. h"]
	#[doc = " @code{c}"]
	#[doc = " UBaseType_t uxTaskPriorityGet( const TaskHandle_t xTask );"]
	#[doc = " @endcode"]
	#[doc = ""]
	#[doc = " INCLUDE_uxTaskPriorityGet must be defined as 1 for this function to be available."]
	#[doc = " See the configuration section for more information."]
	#[doc = ""]
	#[doc = " Obtain the priority of any task."]
	#[doc = ""]
	#[doc = " @param xTask Handle of the task to be queried.  Passing a NULL"]
	#[doc = " handle results in the priority of the calling task being returned."]
	#[doc = ""]
	#[doc = " @return The priority of xTask."]
	#[doc = ""]
	#[doc = " Example usage:"]
	#[doc = " @code{c}"]
	#[doc = " void vAFunction( void )"]
	#[doc = " {"]
	#[doc = " TaskHandle_t xHandle;"]
	#[doc = ""]
	#[doc = "   // Create a task, storing the handle."]
	#[doc = "   xTaskCreate( vTaskCode, \"NAME\", STACK_SIZE, NULL, tskIDLE_PRIORITY, &xHandle );"]
	#[doc = ""]
	#[doc = "   // ..."]
	#[doc = ""]
	#[doc = "   // Use the handle to obtain the priority of the created task."]
	#[doc = "   // It was created with tskIDLE_PRIORITY, but may have changed"]
	#[doc = "   // it itself."]
	#[doc = "   if( uxTaskPriorityGet( xHandle ) != tskIDLE_PRIORITY )"]
	#[doc = "   {"]
	#[doc = "       // The task has changed it's priority."]
	#[doc = "   }"]
	#[doc = ""]
	#[doc = "   // ..."]
	#[doc = ""]
	#[doc = "   // Is our priority higher than the created task?"]
	#[doc = "   if( uxTaskPriorityGet( xHandle ) < uxTaskPriorityGet( NULL ) )"]
	#[doc = "   {"]
	#[doc = "       // Our priority (obtained using NULL handle) is higher."]
	#[doc = "   }"]
	#[doc = " }"]
	#[doc = " @endcode"]
	#[doc = " \\defgroup uxTaskPriorityGet uxTaskPriorityGet"]
	#[doc = " \\ingroup TaskCtrl"]
	pub fn uxTaskPriorityGet(xTask: TaskHandle_t) -> UBaseType_t;
}
extern "C" {
	#[doc = " task. h"]
	#[doc = " @code{c}"]
	#[doc = " UBaseType_t uxTaskPriorityGetFromISR( const TaskHandle_t xTask );"]
	#[doc = " @endcode"]
	#[doc = ""]
	#[doc = " A version of uxTaskPriorityGet() that can be used from an ISR."]
	pub fn uxTaskPriorityGetFromISR(xTask: TaskHandle_t) -> UBaseType_t;
}
extern "C" {
	#[doc = " task. h"]
	#[doc = " @code{c}"]
	#[doc = " eTaskState eTaskGetState( TaskHandle_t xTask );"]
	#[doc = " @endcode"]
	#[doc = ""]
	#[doc = " INCLUDE_eTaskGetState must be defined as 1 for this function to be available."]
	#[doc = " See the configuration section for more information."]
	#[doc = ""]
	#[doc = " Obtain the state of any task.  States are encoded by the eTaskState"]
	#[doc = " enumerated type."]
	#[doc = ""]
	#[doc = " @param xTask Handle of the task to be queried."]
	#[doc = ""]
	#[doc = " @return The state of xTask at the time the function was called.  Note the"]
	#[doc = " state of the task might change between the function being called, and the"]
	#[doc = " functions return value being tested by the calling task."]
	pub fn eTaskGetState(xTask: TaskHandle_t) -> eTaskState;
}
extern "C" {
	#[doc = " task. h"]
	#[doc = " @code{c}"]
	#[doc = " void vTaskGetInfo( TaskHandle_t xTask, TaskStatus_t *pxTaskStatus, BaseType_t xGetFreeStackSpace, eTaskState eState );"]
	#[doc = " @endcode"]
	#[doc = ""]
	#[doc = " configUSE_TRACE_FACILITY must be defined as 1 for this function to be"]
	#[doc = " available.  See the configuration section for more information."]
	#[doc = ""]
	#[doc = " Populates a TaskStatus_t structure with information about a task."]
	#[doc = ""]
	#[doc = " @param xTask Handle of the task being queried.  If xTask is NULL then"]
	#[doc = " information will be returned about the calling task."]
	#[doc = ""]
	#[doc = " @param pxTaskStatus A pointer to the TaskStatus_t structure that will be"]
	#[doc = " filled with information about the task referenced by the handle passed using"]
	#[doc = " the xTask parameter."]
	#[doc = ""]
	#[doc = " @xGetFreeStackSpace The TaskStatus_t structure contains a member to report"]
	#[doc = " the stack high water mark of the task being queried.  Calculating the stack"]
	#[doc = " high water mark takes a relatively long time, and can make the system"]
	#[doc = " temporarily unresponsive - so the xGetFreeStackSpace parameter is provided to"]
	#[doc = " allow the high water mark checking to be skipped.  The high watermark value"]
	#[doc = " will only be written to the TaskStatus_t structure if xGetFreeStackSpace is"]
	#[doc = " not set to pdFALSE;"]
	#[doc = ""]
	#[doc = " @param eState The TaskStatus_t structure contains a member to report the"]
	#[doc = " state of the task being queried.  Obtaining the task state is not as fast as"]
	#[doc = " a simple assignment - so the eState parameter is provided to allow the state"]
	#[doc = " information to be omitted from the TaskStatus_t structure.  To obtain state"]
	#[doc = " information then set eState to eInvalid - otherwise the value passed in"]
	#[doc = " eState will be reported as the task state in the TaskStatus_t structure."]
	#[doc = ""]
	#[doc = " Example usage:"]
	#[doc = " @code{c}"]
	#[doc = " void vAFunction( void )"]
	#[doc = " {"]
	#[doc = " TaskHandle_t xHandle;"]
	#[doc = " TaskStatus_t xTaskDetails;"]
	#[doc = ""]
	#[doc = "  // Obtain the handle of a task from its name."]
	#[doc = "  xHandle = xTaskGetHandle( \"Task_Name\" );"]
	#[doc = ""]
	#[doc = "  // Check the handle is not NULL."]
	#[doc = "  configASSERT( xHandle );"]
	#[doc = ""]
	#[doc = "  // Use the handle to obtain further information about the task."]
	#[doc = "  vTaskGetInfo( xHandle,"]
	#[doc = "                &xTaskDetails,"]
	#[doc = "                pdTRUE, // Include the high water mark in xTaskDetails."]
	#[doc = "                eInvalid ); // Include the task state in xTaskDetails."]
	#[doc = " }"]
	#[doc = " @endcode"]
	#[doc = " \\defgroup vTaskGetInfo vTaskGetInfo"]
	#[doc = " \\ingroup TaskCtrl"]
	pub fn vTaskGetInfo(xTask: TaskHandle_t, pxTaskStatus: *mut TaskStatus_t, xGetFreeStackSpace: BaseType_t, eState: eTaskState);
}
extern "C" {
	#[doc = " task. h"]
	#[doc = " @code{c}"]
	#[doc = " void vTaskPrioritySet( TaskHandle_t xTask, UBaseType_t uxNewPriority );"]
	#[doc = " @endcode"]
	#[doc = ""]
	#[doc = " INCLUDE_vTaskPrioritySet must be defined as 1 for this function to be available."]
	#[doc = " See the configuration section for more information."]
	#[doc = ""]
	#[doc = " Set the priority of any task."]
	#[doc = ""]
	#[doc = " A context switch will occur before the function returns if the priority"]
	#[doc = " being set is higher than the currently executing task."]
	#[doc = ""]
	#[doc = " @param xTask Handle to the task for which the priority is being set."]
	#[doc = " Passing a NULL handle results in the priority of the calling task being set."]
	#[doc = ""]
	#[doc = " @param uxNewPriority The priority to which the task will be set."]
	#[doc = ""]
	#[doc = " Example usage:"]
	#[doc = " @code{c}"]
	#[doc = " void vAFunction( void )"]
	#[doc = " {"]
	#[doc = " TaskHandle_t xHandle;"]
	#[doc = ""]
	#[doc = "   // Create a task, storing the handle."]
	#[doc = "   xTaskCreate( vTaskCode, \"NAME\", STACK_SIZE, NULL, tskIDLE_PRIORITY, &xHandle );"]
	#[doc = ""]
	#[doc = "   // ..."]
	#[doc = ""]
	#[doc = "   // Use the handle to raise the priority of the created task."]
	#[doc = "   vTaskPrioritySet( xHandle, tskIDLE_PRIORITY + 1 );"]
	#[doc = ""]
	#[doc = "   // ..."]
	#[doc = ""]
	#[doc = "   // Use a NULL handle to raise our priority to the same value."]
	#[doc = "   vTaskPrioritySet( NULL, tskIDLE_PRIORITY + 1 );"]
	#[doc = " }"]
	#[doc = " @endcode"]
	#[doc = " \\defgroup vTaskPrioritySet vTaskPrioritySet"]
	#[doc = " \\ingroup TaskCtrl"]
	pub fn vTaskPrioritySet(xTask: TaskHandle_t, uxNewPriority: UBaseType_t);
}
extern "C" {
	#[doc = " task. h"]
	#[doc = " @code{c}"]
	#[doc = " void vTaskSuspend( TaskHandle_t xTaskToSuspend );"]
	#[doc = " @endcode"]
	#[doc = ""]
	#[doc = " INCLUDE_vTaskSuspend must be defined as 1 for this function to be available."]
	#[doc = " See the configuration section for more information."]
	#[doc = ""]
	#[doc = " Suspend any task.  When suspended a task will never get any microcontroller"]
	#[doc = " processing time, no matter what its priority."]
	#[doc = ""]
	#[doc = " Calls to vTaskSuspend are not accumulative -"]
	#[doc = " i.e. calling vTaskSuspend () twice on the same task still only requires one"]
	#[doc = " call to vTaskResume () to ready the suspended task."]
	#[doc = ""]
	#[doc = " @param xTaskToSuspend Handle to the task being suspended.  Passing a NULL"]
	#[doc = " handle will cause the calling task to be suspended."]
	#[doc = ""]
	#[doc = " Example usage:"]
	#[doc = " @code{c}"]
	#[doc = " void vAFunction( void )"]
	#[doc = " {"]
	#[doc = " TaskHandle_t xHandle;"]
	#[doc = ""]
	#[doc = "   // Create a task, storing the handle."]
	#[doc = "   xTaskCreate( vTaskCode, \"NAME\", STACK_SIZE, NULL, tskIDLE_PRIORITY, &xHandle );"]
	#[doc = ""]
	#[doc = "   // ..."]
	#[doc = ""]
	#[doc = "   // Use the handle to suspend the created task."]
	#[doc = "   vTaskSuspend( xHandle );"]
	#[doc = ""]
	#[doc = "   // ..."]
	#[doc = ""]
	#[doc = "   // The created task will not run during this period, unless"]
	#[doc = "   // another task calls vTaskResume( xHandle )."]
	#[doc = ""]
	#[doc = "   //..."]
	#[doc = ""]
	#[doc = ""]
	#[doc = "   // Suspend ourselves."]
	#[doc = "   vTaskSuspend( NULL );"]
	#[doc = ""]
	#[doc = "   // We cannot get here unless another task calls vTaskResume"]
	#[doc = "   // with our handle as the parameter."]
	#[doc = " }"]
	#[doc = " @endcode"]
	#[doc = " \\defgroup vTaskSuspend vTaskSuspend"]
	#[doc = " \\ingroup TaskCtrl"]
	pub fn vTaskSuspend(xTaskToSuspend: TaskHandle_t);
}
extern "C" {
	#[doc = " task. h"]
	#[doc = " @code{c}"]
	#[doc = " void vTaskResume( TaskHandle_t xTaskToResume );"]
	#[doc = " @endcode"]
	#[doc = ""]
	#[doc = " INCLUDE_vTaskSuspend must be defined as 1 for this function to be available."]
	#[doc = " See the configuration section for more information."]
	#[doc = ""]
	#[doc = " Resumes a suspended task."]
	#[doc = ""]
	#[doc = " A task that has been suspended by one or more calls to vTaskSuspend ()"]
	#[doc = " will be made available for running again by a single call to"]
	#[doc = " vTaskResume ()."]
	#[doc = ""]
	#[doc = " @param xTaskToResume Handle to the task being readied."]
	#[doc = ""]
	#[doc = " Example usage:"]
	#[doc = " @code{c}"]
	#[doc = " void vAFunction( void )"]
	#[doc = " {"]
	#[doc = " TaskHandle_t xHandle;"]
	#[doc = ""]
	#[doc = "   // Create a task, storing the handle."]
	#[doc = "   xTaskCreate( vTaskCode, \"NAME\", STACK_SIZE, NULL, tskIDLE_PRIORITY, &xHandle );"]
	#[doc = ""]
	#[doc = "   // ..."]
	#[doc = ""]
	#[doc = "   // Use the handle to suspend the created task."]
	#[doc = "   vTaskSuspend( xHandle );"]
	#[doc = ""]
	#[doc = "   // ..."]
	#[doc = ""]
	#[doc = "   // The created task will not run during this period, unless"]
	#[doc = "   // another task calls vTaskResume( xHandle )."]
	#[doc = ""]
	#[doc = "   //..."]
	#[doc = ""]
	#[doc = ""]
	#[doc = "   // Resume the suspended task ourselves."]
	#[doc = "   vTaskResume( xHandle );"]
	#[doc = ""]
	#[doc = "   // The created task will once again get microcontroller processing"]
	#[doc = "   // time in accordance with its priority within the system."]
	#[doc = " }"]
	#[doc = " @endcode"]
	#[doc = " \\defgroup vTaskResume vTaskResume"]
	#[doc = " \\ingroup TaskCtrl"]
	pub fn vTaskResume(xTaskToResume: TaskHandle_t);
}
extern "C" {
	#[doc = " task. h"]
	#[doc = " @code{c}"]
	#[doc = " void xTaskResumeFromISR( TaskHandle_t xTaskToResume );"]
	#[doc = " @endcode"]
	#[doc = ""]
	#[doc = " INCLUDE_xTaskResumeFromISR must be defined as 1 for this function to be"]
	#[doc = " available.  See the configuration section for more information."]
	#[doc = ""]
	#[doc = " An implementation of vTaskResume() that can be called from within an ISR."]
	#[doc = ""]
	#[doc = " A task that has been suspended by one or more calls to vTaskSuspend ()"]
	#[doc = " will be made available for running again by a single call to"]
	#[doc = " xTaskResumeFromISR ()."]
	#[doc = ""]
	#[doc = " xTaskResumeFromISR() should not be used to synchronise a task with an"]
	#[doc = " interrupt if there is a chance that the interrupt could arrive prior to the"]
	#[doc = " task being suspended - as this can lead to interrupts being missed. Use of a"]
	#[doc = " semaphore as a synchronisation mechanism would avoid this eventuality."]
	#[doc = ""]
	#[doc = " @param xTaskToResume Handle to the task being readied."]
	#[doc = ""]
	#[doc = " @return pdTRUE if resuming the task should result in a context switch,"]
	#[doc = " otherwise pdFALSE. This is used by the ISR to determine if a context switch"]
	#[doc = " may be required following the ISR."]
	#[doc = ""]
	#[doc = " \\defgroup vTaskResumeFromISR vTaskResumeFromISR"]
	#[doc = " \\ingroup TaskCtrl"]
	pub fn xTaskResumeFromISR(xTaskToResume: TaskHandle_t) -> BaseType_t;
}
extern "C" {
	#[doc = " task. h"]
	#[doc = " @code{c}"]
	#[doc = " void vTaskStartScheduler( void );"]
	#[doc = " @endcode"]
	#[doc = ""]
	#[doc = " Starts the real time kernel tick processing.  After calling the kernel"]
	#[doc = " has control over which tasks are executed and when."]
	#[doc = ""]
	#[doc = " See the demo application file main.c for an example of creating"]
	#[doc = " tasks and starting the kernel."]
	#[doc = ""]
	#[doc = " Example usage:"]
	#[doc = " @code{c}"]
	#[doc = " void vAFunction( void )"]
	#[doc = " {"]
	#[doc = "   // Create at least one task before starting the kernel."]
	#[doc = "   xTaskCreate( vTaskCode, \"NAME\", STACK_SIZE, NULL, tskIDLE_PRIORITY, NULL );"]
	#[doc = ""]
	#[doc = "   // Start the real time kernel with preemption."]
	#[doc = "   vTaskStartScheduler ();"]
	#[doc = ""]
	#[doc = "   // Will not get here unless a task calls vTaskEndScheduler ()"]
	#[doc = " }"]
	#[doc = " @endcode"]
	#[doc = ""]
	#[doc = " \\defgroup vTaskStartScheduler vTaskStartScheduler"]
	#[doc = " \\ingroup SchedulerControl"]
	pub fn vTaskStartScheduler();
}
extern "C" {
	#[doc = " task. h"]
	#[doc = " @code{c}"]
	#[doc = " void vTaskEndScheduler( void );"]
	#[doc = " @endcode"]
	#[doc = ""]
	#[doc = " NOTE:  At the time of writing only the x86 real mode port, which runs on a PC"]
	#[doc = " in place of DOS, implements this function."]
	#[doc = ""]
	#[doc = " Stops the real time kernel tick.  All created tasks will be automatically"]
	#[doc = " deleted and multitasking (either preemptive or cooperative) will"]
	#[doc = " stop.  Execution then resumes from the point where vTaskStartScheduler ()"]
	#[doc = " was called, as if vTaskStartScheduler () had just returned."]
	#[doc = ""]
	#[doc = " See the demo application file main. c in the demo/PC directory for an"]
	#[doc = " example that uses vTaskEndScheduler ()."]
	#[doc = ""]
	#[doc = " vTaskEndScheduler () requires an exit function to be defined within the"]
	#[doc = " portable layer (see vPortEndScheduler () in port. c for the PC port).  This"]
	#[doc = " performs hardware specific operations such as stopping the kernel tick."]
	#[doc = ""]
	#[doc = " vTaskEndScheduler () will cause all of the resources allocated by the"]
	#[doc = " kernel to be freed - but will not free resources allocated by application"]
	#[doc = " tasks."]
	#[doc = ""]
	#[doc = " Example usage:"]
	#[doc = " @code{c}"]
	#[doc = " void vTaskCode( void * pvParameters )"]
	#[doc = " {"]
	#[doc = "   for( ;; )"]
	#[doc = "   {"]
	#[doc = "       // Task code goes here."]
	#[doc = ""]
	#[doc = "       // At some point we want to end the real time kernel processing"]
	#[doc = "       // so call ..."]
	#[doc = "       vTaskEndScheduler ();"]
	#[doc = "   }"]
	#[doc = " }"]
	#[doc = ""]
	#[doc = " void vAFunction( void )"]
	#[doc = " {"]
	#[doc = "   // Create at least one task before starting the kernel."]
	#[doc = "   xTaskCreate( vTaskCode, \"NAME\", STACK_SIZE, NULL, tskIDLE_PRIORITY, NULL );"]
	#[doc = ""]
	#[doc = "   // Start the real time kernel with preemption."]
	#[doc = "   vTaskStartScheduler ();"]
	#[doc = ""]
	#[doc = "   // Will only get here when the vTaskCode () task has called"]
	#[doc = "   // vTaskEndScheduler ().  When we get here we are back to single task"]
	#[doc = "   // execution."]
	#[doc = " }"]
	#[doc = " @endcode"]
	#[doc = ""]
	#[doc = " \\defgroup vTaskEndScheduler vTaskEndScheduler"]
	#[doc = " \\ingroup SchedulerControl"]
	pub fn vTaskEndScheduler();
}
extern "C" {
	#[doc = " task. h"]
	#[doc = " @code{c}"]
	#[doc = " void vTaskSuspendAll( void );"]
	#[doc = " @endcode"]
	#[doc = ""]
	#[doc = " Suspends the scheduler without disabling interrupts.  Context switches will"]
	#[doc = " not occur while the scheduler is suspended."]
	#[doc = ""]
	#[doc = " After calling vTaskSuspendAll () the calling task will continue to execute"]
	#[doc = " without risk of being swapped out until a call to xTaskResumeAll () has been"]
	#[doc = " made."]
	#[doc = ""]
	#[doc = " API functions that have the potential to cause a context switch (for example,"]
	#[doc = " xTaskDelayUntil(), xQueueSend(), etc.) must not be called while the scheduler"]
	#[doc = " is suspended."]
	#[doc = ""]
	#[doc = " Example usage:"]
	#[doc = " @code{c}"]
	#[doc = " void vTask1( void * pvParameters )"]
	#[doc = " {"]
	#[doc = "   for( ;; )"]
	#[doc = "   {"]
	#[doc = "       // Task code goes here."]
	#[doc = ""]
	#[doc = "       // ..."]
	#[doc = ""]
	#[doc = "       // At some point the task wants to perform a long operation during"]
	#[doc = "       // which it does not want to get swapped out.  It cannot use"]
	#[doc = "       // taskENTER_CRITICAL ()/taskEXIT_CRITICAL () as the length of the"]
	#[doc = "       // operation may cause interrupts to be missed - including the"]
	#[doc = "       // ticks."]
	#[doc = ""]
	#[doc = "       // Prevent the real time kernel swapping out the task."]
	#[doc = "       vTaskSuspendAll ();"]
	#[doc = ""]
	#[doc = "       // Perform the operation here.  There is no need to use critical"]
	#[doc = "       // sections as we have all the microcontroller processing time."]
	#[doc = "       // During this time interrupts will still operate and the kernel"]
	#[doc = "       // tick count will be maintained."]
	#[doc = ""]
	#[doc = "       // ..."]
	#[doc = ""]
	#[doc = "       // The operation is complete.  Restart the kernel."]
	#[doc = "       xTaskResumeAll ();"]
	#[doc = "   }"]
	#[doc = " }"]
	#[doc = " @endcode"]
	#[doc = " \\defgroup vTaskSuspendAll vTaskSuspendAll"]
	#[doc = " \\ingroup SchedulerControl"]
	pub fn vTaskSuspendAll();
}
extern "C" {
	#[doc = " task. h"]
	#[doc = " @code{c}"]
	#[doc = " BaseType_t xTaskResumeAll( void );"]
	#[doc = " @endcode"]
	#[doc = ""]
	#[doc = " Resumes scheduler activity after it was suspended by a call to"]
	#[doc = " vTaskSuspendAll()."]
	#[doc = ""]
	#[doc = " xTaskResumeAll() only resumes the scheduler.  It does not unsuspend tasks"]
	#[doc = " that were previously suspended by a call to vTaskSuspend()."]
	#[doc = ""]
	#[doc = " @return If resuming the scheduler caused a context switch then pdTRUE is"]
	#[doc = "         returned, otherwise pdFALSE is returned."]
	#[doc = ""]
	#[doc = " Example usage:"]
	#[doc = " @code{c}"]
	#[doc = " void vTask1( void * pvParameters )"]
	#[doc = " {"]
	#[doc = "   for( ;; )"]
	#[doc = "   {"]
	#[doc = "       // Task code goes here."]
	#[doc = ""]
	#[doc = "       // ..."]
	#[doc = ""]
	#[doc = "       // At some point the task wants to perform a long operation during"]
	#[doc = "       // which it does not want to get swapped out.  It cannot use"]
	#[doc = "       // taskENTER_CRITICAL ()/taskEXIT_CRITICAL () as the length of the"]
	#[doc = "       // operation may cause interrupts to be missed - including the"]
	#[doc = "       // ticks."]
	#[doc = ""]
	#[doc = "       // Prevent the real time kernel swapping out the task."]
	#[doc = "       vTaskSuspendAll ();"]
	#[doc = ""]
	#[doc = "       // Perform the operation here.  There is no need to use critical"]
	#[doc = "       // sections as we have all the microcontroller processing time."]
	#[doc = "       // During this time interrupts will still operate and the real"]
	#[doc = "       // time kernel tick count will be maintained."]
	#[doc = ""]
	#[doc = "       // ..."]
	#[doc = ""]
	#[doc = "       // The operation is complete.  Restart the kernel.  We want to force"]
	#[doc = "       // a context switch - but there is no point if resuming the scheduler"]
	#[doc = "       // caused a context switch already."]
	#[doc = "       if( !xTaskResumeAll () )"]
	#[doc = "       {"]
	#[doc = "            taskYIELD ();"]
	#[doc = "       }"]
	#[doc = "   }"]
	#[doc = " }"]
	#[doc = " @endcode"]
	#[doc = " \\defgroup xTaskResumeAll xTaskResumeAll"]
	#[doc = " \\ingroup SchedulerControl"]
	pub fn xTaskResumeAll() -> BaseType_t;
}
extern "C" {
	#[doc = " task. h"]
	#[doc = " @code{c}"]
	#[doc = " TickType_t xTaskGetTickCount( void );"]
	#[doc = " @endcode"]
	#[doc = ""]
	#[doc = " @return The count of ticks since vTaskStartScheduler was called."]
	#[doc = ""]
	#[doc = " \\defgroup xTaskGetTickCount xTaskGetTickCount"]
	#[doc = " \\ingroup TaskUtils"]
	pub fn xTaskGetTickCount() -> TickType_t;
}
extern "C" {
	#[doc = " task. h"]
	#[doc = " @code{c}"]
	#[doc = " TickType_t xTaskGetTickCountFromISR( void );"]
	#[doc = " @endcode"]
	#[doc = ""]
	#[doc = " @return The count of ticks since vTaskStartScheduler was called."]
	#[doc = ""]
	#[doc = " This is a version of xTaskGetTickCount() that is safe to be called from an"]
	#[doc = " ISR - provided that TickType_t is the natural word size of the"]
	#[doc = " microcontroller being used or interrupt nesting is either not supported or"]
	#[doc = " not being used."]
	#[doc = ""]
	#[doc = " \\defgroup xTaskGetTickCountFromISR xTaskGetTickCountFromISR"]
	#[doc = " \\ingroup TaskUtils"]
	pub fn xTaskGetTickCountFromISR() -> TickType_t;
}
extern "C" {
	#[doc = " task. h"]
	#[doc = " @code{c}"]
	#[doc = " uint16_t uxTaskGetNumberOfTasks( void );"]
	#[doc = " @endcode"]
	#[doc = ""]
	#[doc = " @return The number of tasks that the real time kernel is currently managing."]
	#[doc = " This includes all ready, blocked and suspended tasks.  A task that"]
	#[doc = " has been deleted but not yet freed by the idle task will also be"]
	#[doc = " included in the count."]
	#[doc = ""]
	#[doc = " \\defgroup uxTaskGetNumberOfTasks uxTaskGetNumberOfTasks"]
	#[doc = " \\ingroup TaskUtils"]
	pub fn uxTaskGetNumberOfTasks() -> UBaseType_t;
}
extern "C" {
	#[doc = " task. h"]
	#[doc = " @code{c}"]
	#[doc = " char *pcTaskGetName( TaskHandle_t xTaskToQuery );"]
	#[doc = " @endcode"]
	#[doc = ""]
	#[doc = " @return The text (human readable) name of the task referenced by the handle"]
	#[doc = " xTaskToQuery.  A task can query its own name by either passing in its own"]
	#[doc = " handle, or by setting xTaskToQuery to NULL."]
	#[doc = ""]
	#[doc = " \\defgroup pcTaskGetName pcTaskGetName"]
	#[doc = " \\ingroup TaskUtils"]
	pub fn pcTaskGetName(xTaskToQuery: TaskHandle_t) -> *mut core::ffi::c_char;
}
extern "C" {
	#[doc = " task. h"]
	#[doc = " @code{c}"]
	#[doc = " TaskHandle_t xTaskGetHandle( const char *pcNameToQuery );"]
	#[doc = " @endcode"]
	#[doc = ""]
	#[doc = " NOTE:  This function takes a relatively long time to complete and should be"]
	#[doc = " used sparingly."]
	#[doc = ""]
	#[doc = " @return The handle of the task that has the human readable name pcNameToQuery."]
	#[doc = " NULL is returned if no matching name is found.  INCLUDE_xTaskGetHandle"]
	#[doc = " must be set to 1 in FreeRTOSConfig.h for pcTaskGetHandle() to be available."]
	#[doc = ""]
	#[doc = " \\defgroup pcTaskGetHandle pcTaskGetHandle"]
	#[doc = " \\ingroup TaskUtils"]
	pub fn xTaskGetHandle(pcNameToQuery: *const core::ffi::c_char) -> TaskHandle_t;
}
extern "C" {
	#[doc = " task.h"]
	#[doc = " @code{c}"]
	#[doc = " UBaseType_t uxTaskGetStackHighWaterMark( TaskHandle_t xTask );"]
	#[doc = " @endcode"]
	#[doc = ""]
	#[doc = " INCLUDE_uxTaskGetStackHighWaterMark must be set to 1 in FreeRTOSConfig.h for"]
	#[doc = " this function to be available."]
	#[doc = ""]
	#[doc = " Returns the high water mark of the stack associated with xTask.  That is,"]
	#[doc = " the minimum free stack space there has been (in words, so on a 32 bit machine"]
	#[doc = " a value of 1 means 4 bytes) since the task started.  The smaller the returned"]
	#[doc = " number the closer the task has come to overflowing its stack."]
	#[doc = ""]
	#[doc = " uxTaskGetStackHighWaterMark() and uxTaskGetStackHighWaterMark2() are the"]
	#[doc = " same except for their return type.  Using configSTACK_DEPTH_TYPE allows the"]
	#[doc = " user to determine the return type.  It gets around the problem of the value"]
	#[doc = " overflowing on 8-bit types without breaking backward compatibility for"]
	#[doc = " applications that expect an 8-bit return type."]
	#[doc = ""]
	#[doc = " @param xTask Handle of the task associated with the stack to be checked."]
	#[doc = " Set xTask to NULL to check the stack of the calling task."]
	#[doc = ""]
	#[doc = " @return The smallest amount of free stack space there has been (in words, so"]
	#[doc = " actual spaces on the stack rather than bytes) since the task referenced by"]
	#[doc = " xTask was created."]
	pub fn uxTaskGetStackHighWaterMark(xTask: TaskHandle_t) -> UBaseType_t;
}
extern "C" {
	#[doc = " task.h"]
	#[doc = " @code{c}"]
	#[doc = " configSTACK_DEPTH_TYPE uxTaskGetStackHighWaterMark2( TaskHandle_t xTask );"]
	#[doc = " @endcode"]
	#[doc = ""]
	#[doc = " INCLUDE_uxTaskGetStackHighWaterMark2 must be set to 1 in FreeRTOSConfig.h for"]
	#[doc = " this function to be available."]
	#[doc = ""]
	#[doc = " Returns the high water mark of the stack associated with xTask.  That is,"]
	#[doc = " the minimum free stack space there has been (in words, so on a 32 bit machine"]
	#[doc = " a value of 1 means 4 bytes) since the task started.  The smaller the returned"]
	#[doc = " number the closer the task has come to overflowing its stack."]
	#[doc = ""]
	#[doc = " uxTaskGetStackHighWaterMark() and uxTaskGetStackHighWaterMark2() are the"]
	#[doc = " same except for their return type.  Using configSTACK_DEPTH_TYPE allows the"]
	#[doc = " user to determine the return type.  It gets around the problem of the value"]
	#[doc = " overflowing on 8-bit types without breaking backward compatibility for"]
	#[doc = " applications that expect an 8-bit return type."]
	#[doc = ""]
	#[doc = " @param xTask Handle of the task associated with the stack to be checked."]
	#[doc = " Set xTask to NULL to check the stack of the calling task."]
	#[doc = ""]
	#[doc = " @return The smallest amount of free stack space there has been (in words, so"]
	#[doc = " actual spaces on the stack rather than bytes) since the task referenced by"]
	#[doc = " xTask was created."]
	pub fn uxTaskGetStackHighWaterMark2(xTask: TaskHandle_t) -> u16;
}
extern "C" {
	pub fn vTaskSetThreadLocalStoragePointer(xTaskToSet: TaskHandle_t, xIndex: BaseType_t, pvValue: *mut core::ffi::c_void);
}
extern "C" {
	pub fn pvTaskGetThreadLocalStoragePointer(xTaskToQuery: TaskHandle_t, xIndex: BaseType_t) -> *mut core::ffi::c_void;
}
extern "C" {
	#[doc = " task.h"]
	#[doc = " @code{c}"]
	#[doc = " void vApplicationGetIdleTaskMemory( StaticTask_t ** ppxIdleTaskTCBBuffer, StackType_t ** ppxIdleTaskStackBuffer, uint32_t *pulIdleTaskStackSize )"]
	#[doc = " @endcode"]
	#[doc = ""]
	#[doc = " This function is used to provide a statically allocated block of memory to FreeRTOS to hold the Idle Task TCB.  This function is required when"]
	#[doc = " configSUPPORT_STATIC_ALLOCATION is set.  For more information see this URI: https://www.FreeRTOS.org/a00110.html#configSUPPORT_STATIC_ALLOCATION"]
	#[doc = ""]
	#[doc = " @param ppxIdleTaskTCBBuffer A handle to a statically allocated TCB buffer"]
	#[doc = " @param ppxIdleTaskStackBuffer A handle to a statically allocated Stack buffer for the idle task"]
	#[doc = " @param pulIdleTaskStackSize A pointer to the number of elements that will fit in the allocated stack buffer"]
	pub fn vApplicationGetIdleTaskMemory(ppxIdleTaskTCBBuffer: *mut *mut StaticTask_t,
	                                     ppxIdleTaskStackBuffer: *mut *mut StackType_t,
	                                     pulIdleTaskStackSize: *mut u32);
}
extern "C" {
	#[doc = " task.h"]
	#[doc = " @code{c}"]
	#[doc = " BaseType_t xTaskCallApplicationTaskHook( TaskHandle_t xTask, void *pvParameter );"]
	#[doc = " @endcode"]
	#[doc = ""]
	#[doc = " Calls the hook function associated with xTask.  Passing xTask as NULL has"]
	#[doc = " the effect of calling the Running tasks (the calling task) hook function."]
	#[doc = ""]
	#[doc = " pvParameter is passed to the hook function for the task to interpret as it"]
	#[doc = " wants.  The return value is the value returned by the task hook function"]
	#[doc = " registered by the user."]
	pub fn xTaskCallApplicationTaskHook(xTask: TaskHandle_t, pvParameter: *mut core::ffi::c_void) -> BaseType_t;
}
extern "C" {
	#[doc = " xTaskGetIdleTaskHandle() is only available if"]
	#[doc = " INCLUDE_xTaskGetIdleTaskHandle is set to 1 in FreeRTOSConfig.h."]
	#[doc = ""]
	#[doc = " Simply returns the handle of the idle task.  It is not valid to call"]
	#[doc = " xTaskGetIdleTaskHandle() before the scheduler has been started."]
	pub fn xTaskGetIdleTaskHandle() -> TaskHandle_t;
}
extern "C" {
	#[doc = " configUSE_TRACE_FACILITY must be defined as 1 in FreeRTOSConfig.h for"]
	#[doc = " uxTaskGetSystemState() to be available."]
	#[doc = ""]
	#[doc = " uxTaskGetSystemState() populates an TaskStatus_t structure for each task in"]
	#[doc = " the system.  TaskStatus_t structures contain, among other things, members"]
	#[doc = " for the task handle, task name, task priority, task state, and total amount"]
	#[doc = " of run time consumed by the task.  See the TaskStatus_t structure"]
	#[doc = " definition in this file for the full member list."]
	#[doc = ""]
	#[doc = " NOTE:  This function is intended for debugging use only as its use results in"]
	#[doc = " the scheduler remaining suspended for an extended period."]
	#[doc = ""]
	#[doc = " @param pxTaskStatusArray A pointer to an array of TaskStatus_t structures."]
	#[doc = " The array must contain at least one TaskStatus_t structure for each task"]
	#[doc = " that is under the control of the RTOS.  The number of tasks under the control"]
	#[doc = " of the RTOS can be determined using the uxTaskGetNumberOfTasks() API function."]
	#[doc = ""]
	#[doc = " @param uxArraySize The size of the array pointed to by the pxTaskStatusArray"]
	#[doc = " parameter.  The size is specified as the number of indexes in the array, or"]
	#[doc = " the number of TaskStatus_t structures contained in the array, not by the"]
	#[doc = " number of bytes in the array."]
	#[doc = ""]
	#[doc = " @param pulTotalRunTime If configGENERATE_RUN_TIME_STATS is set to 1 in"]
	#[doc = " FreeRTOSConfig.h then *pulTotalRunTime is set by uxTaskGetSystemState() to the"]
	#[doc = " total run time (as defined by the run time stats clock, see"]
	#[doc = " https://www.FreeRTOS.org/rtos-run-time-stats.html) since the target booted."]
	#[doc = " pulTotalRunTime can be set to NULL to omit the total run time information."]
	#[doc = ""]
	#[doc = " @return The number of TaskStatus_t structures that were populated by"]
	#[doc = " uxTaskGetSystemState().  This should equal the number returned by the"]
	#[doc = " uxTaskGetNumberOfTasks() API function, but will be zero if the value passed"]
	#[doc = " in the uxArraySize parameter was too small."]
	#[doc = ""]
	#[doc = " Example usage:"]
	#[doc = " @code{c}"]
	#[doc = "  // This example demonstrates how a human readable table of run time stats"]
	#[doc = "  // information is generated from raw data provided by uxTaskGetSystemState()."]
	#[doc = "  // The human readable table is written to pcWriteBuffer"]
	#[doc = "  void vTaskGetRunTimeStats( char *pcWriteBuffer )"]
	#[doc = "  {"]
	#[doc = "  TaskStatus_t *pxTaskStatusArray;"]
	#[doc = "  volatile UBaseType_t uxArraySize, x;"]
	#[doc = "  configRUN_TIME_COUNTER_TYPE ulTotalRunTime, ulStatsAsPercentage;"]
	#[doc = ""]
	#[doc = "      // Make sure the write buffer does not contain a string."]
	#[doc = " pcWriteBuffer = 0x00;"]
	#[doc = ""]
	#[doc = "      // Take a snapshot of the number of tasks in case it changes while this"]
	#[doc = "      // function is executing."]
	#[doc = "      uxArraySize = uxTaskGetNumberOfTasks();"]
	#[doc = ""]
	#[doc = "      // Allocate a TaskStatus_t structure for each task.  An array could be"]
	#[doc = "      // allocated statically at compile time."]
	#[doc = "      pxTaskStatusArray = pvPortMalloc( uxArraySize * sizeof( TaskStatus_t ) );"]
	#[doc = ""]
	#[doc = "      if( pxTaskStatusArray != NULL )"]
	#[doc = "      {"]
	#[doc = "          // Generate raw status information about each task."]
	#[doc = "          uxArraySize = uxTaskGetSystemState( pxTaskStatusArray, uxArraySize, &ulTotalRunTime );"]
	#[doc = ""]
	#[doc = "          // For percentage calculations."]
	#[doc = "          ulTotalRunTime /= 100UL;"]
	#[doc = ""]
	#[doc = "          // Avoid divide by zero errors."]
	#[doc = "          if( ulTotalRunTime > 0 )"]
	#[doc = "          {"]
	#[doc = "              // For each populated position in the pxTaskStatusArray array,"]
	#[doc = "              // format the raw data as human readable ASCII data"]
	#[doc = "              for( x = 0; x < uxArraySize; x++ )"]
	#[doc = "              {"]
	#[doc = "                  // What percentage of the total run time has the task used?"]
	#[doc = "                  // This will always be rounded down to the nearest integer."]
	#[doc = "                  // ulTotalRunTimeDiv100 has already been divided by 100."]
	#[doc = "                  ulStatsAsPercentage = pxTaskStatusArray[ x ].ulRunTimeCounter / ulTotalRunTime;"]
	#[doc = ""]
	#[doc = "                  if( ulStatsAsPercentage > 0UL )"]
	#[doc = "                  {"]
	#[doc = "                      sprintf( pcWriteBuffer, \"%s\\t\\t%lu\\t\\t%lu%%\\r\\n\", pxTaskStatusArray[ x ].pcTaskName, pxTaskStatusArray[ x ].ulRunTimeCounter, ulStatsAsPercentage );"]
	#[doc = "                  }"]
	#[doc = "                  else"]
	#[doc = "                  {"]
	#[doc = "                      // If the percentage is zero here then the task has"]
	#[doc = "                      // consumed less than 1% of the total run time."]
	#[doc = "                      sprintf( pcWriteBuffer, \"%s\\t\\t%lu\\t\\t<1%%\\r\\n\", pxTaskStatusArray[ x ].pcTaskName, pxTaskStatusArray[ x ].ulRunTimeCounter );"]
	#[doc = "                  }"]
	#[doc = ""]
	#[doc = "                  pcWriteBuffer += strlen( ( char * ) pcWriteBuffer );"]
	#[doc = "              }"]
	#[doc = "          }"]
	#[doc = ""]
	#[doc = "          // The array is no longer needed, free the memory it consumes."]
	#[doc = "          vPortFree( pxTaskStatusArray );"]
	#[doc = "      }"]
	#[doc = "  }"]
	#[doc = "  @endcode"]
	pub fn uxTaskGetSystemState(pxTaskStatusArray: *mut TaskStatus_t,
	                            uxArraySize: UBaseType_t,
	                            pulTotalRunTime: *mut u32)
	                            -> UBaseType_t;
}
extern "C" {
	#[doc = " task. h"]
	#[doc = " @code{c}"]
	#[doc = " void vTaskList( char *pcWriteBuffer );"]
	#[doc = " @endcode"]
	#[doc = ""]
	#[doc = " configUSE_TRACE_FACILITY and configUSE_STATS_FORMATTING_FUNCTIONS must"]
	#[doc = " both be defined as 1 for this function to be available.  See the"]
	#[doc = " configuration section of the FreeRTOS.org website for more information."]
	#[doc = ""]
	#[doc = " NOTE 1: This function will disable interrupts for its duration.  It is"]
	#[doc = " not intended for normal application runtime use but as a debug aid."]
	#[doc = ""]
	#[doc = " Lists all the current tasks, along with their current state and stack"]
	#[doc = " usage high water mark."]
	#[doc = ""]
	#[doc = " Tasks are reported as blocked ('B'), ready ('R'), deleted ('D') or"]
	#[doc = " suspended ('S')."]
	#[doc = ""]
	#[doc = " PLEASE NOTE:"]
	#[doc = ""]
	#[doc = " This function is provided for convenience only, and is used by many of the"]
	#[doc = " demo applications.  Do not consider it to be part of the scheduler."]
	#[doc = ""]
	#[doc = " vTaskList() calls uxTaskGetSystemState(), then formats part of the"]
	#[doc = " uxTaskGetSystemState() output into a human readable table that displays task:"]
	#[doc = " names, states, priority, stack usage and task number."]
	#[doc = " Stack usage specified as the number of unused StackType_t words stack can hold"]
	#[doc = " on top of stack - not the number of bytes."]
	#[doc = ""]
	#[doc = " vTaskList() has a dependency on the sprintf() C library function that might"]
	#[doc = " bloat the code size, use a lot of stack, and provide different results on"]
	#[doc = " different platforms.  An alternative, tiny, third party, and limited"]
	#[doc = " functionality implementation of sprintf() is provided in many of the"]
	#[doc = " FreeRTOS/Demo sub-directories in a file called printf-stdarg.c (note"]
	#[doc = " printf-stdarg.c does not provide a full snprintf() implementation!)."]
	#[doc = ""]
	#[doc = " It is recommended that production systems call uxTaskGetSystemState()"]
	#[doc = " directly to get access to raw stats data, rather than indirectly through a"]
	#[doc = " call to vTaskList()."]
	#[doc = ""]
	#[doc = " @param pcWriteBuffer A buffer into which the above mentioned details"]
	#[doc = " will be written, in ASCII form.  This buffer is assumed to be large"]
	#[doc = " enough to contain the generated report.  Approximately 40 bytes per"]
	#[doc = " task should be sufficient."]
	#[doc = ""]
	#[doc = " \\defgroup vTaskList vTaskList"]
	#[doc = " \\ingroup TaskUtils"]
	pub fn vTaskList(pcWriteBuffer: *mut core::ffi::c_char);
}
extern "C" {
	#[doc = " task. h"]
	#[doc = " @code{c}"]
	#[doc = " void vTaskGetRunTimeStats( char *pcWriteBuffer );"]
	#[doc = " @endcode"]
	#[doc = ""]
	#[doc = " configGENERATE_RUN_TIME_STATS and configUSE_STATS_FORMATTING_FUNCTIONS"]
	#[doc = " must both be defined as 1 for this function to be available.  The application"]
	#[doc = " must also then provide definitions for"]
	#[doc = " portCONFIGURE_TIMER_FOR_RUN_TIME_STATS() and portGET_RUN_TIME_COUNTER_VALUE()"]
	#[doc = " to configure a peripheral timer/counter and return the timers current count"]
	#[doc = " value respectively.  The counter should be at least 10 times the frequency of"]
	#[doc = " the tick count."]
	#[doc = ""]
	#[doc = " NOTE 1: This function will disable interrupts for its duration.  It is"]
	#[doc = " not intended for normal application runtime use but as a debug aid."]
	#[doc = ""]
	#[doc = " Setting configGENERATE_RUN_TIME_STATS to 1 will result in a total"]
	#[doc = " accumulated execution time being stored for each task.  The resolution"]
	#[doc = " of the accumulated time value depends on the frequency of the timer"]
	#[doc = " configured by the portCONFIGURE_TIMER_FOR_RUN_TIME_STATS() macro."]
	#[doc = " Calling vTaskGetRunTimeStats() writes the total execution time of each"]
	#[doc = " task into a buffer, both as an absolute count value and as a percentage"]
	#[doc = " of the total system execution time."]
	#[doc = ""]
	#[doc = " NOTE 2:"]
	#[doc = ""]
	#[doc = " This function is provided for convenience only, and is used by many of the"]
	#[doc = " demo applications.  Do not consider it to be part of the scheduler."]
	#[doc = ""]
	#[doc = " vTaskGetRunTimeStats() calls uxTaskGetSystemState(), then formats part of the"]
	#[doc = " uxTaskGetSystemState() output into a human readable table that displays the"]
	#[doc = " amount of time each task has spent in the Running state in both absolute and"]
	#[doc = " percentage terms."]
	#[doc = ""]
	#[doc = " vTaskGetRunTimeStats() has a dependency on the sprintf() C library function"]
	#[doc = " that might bloat the code size, use a lot of stack, and provide different"]
	#[doc = " results on different platforms.  An alternative, tiny, third party, and"]
	#[doc = " limited functionality implementation of sprintf() is provided in many of the"]
	#[doc = " FreeRTOS/Demo sub-directories in a file called printf-stdarg.c (note"]
	#[doc = " printf-stdarg.c does not provide a full snprintf() implementation!)."]
	#[doc = ""]
	#[doc = " It is recommended that production systems call uxTaskGetSystemState() directly"]
	#[doc = " to get access to raw stats data, rather than indirectly through a call to"]
	#[doc = " vTaskGetRunTimeStats()."]
	#[doc = ""]
	#[doc = " @param pcWriteBuffer A buffer into which the execution times will be"]
	#[doc = " written, in ASCII form.  This buffer is assumed to be large enough to"]
	#[doc = " contain the generated report.  Approximately 40 bytes per task should"]
	#[doc = " be sufficient."]
	#[doc = ""]
	#[doc = " \\defgroup vTaskGetRunTimeStats vTaskGetRunTimeStats"]
	#[doc = " \\ingroup TaskUtils"]
	pub fn vTaskGetRunTimeStats(pcWriteBuffer: *mut core::ffi::c_char);
}
extern "C" {
	#[doc = " task. h"]
	#[doc = " @code{c}"]
	#[doc = " configRUN_TIME_COUNTER_TYPE ulTaskGetIdleRunTimeCounter( void );"]
	#[doc = " configRUN_TIME_COUNTER_TYPE ulTaskGetIdleRunTimePercent( void );"]
	#[doc = " @endcode"]
	#[doc = ""]
	#[doc = " configGENERATE_RUN_TIME_STATS, configUSE_STATS_FORMATTING_FUNCTIONS and"]
	#[doc = " INCLUDE_xTaskGetIdleTaskHandle must all be defined as 1 for these functions"]
	#[doc = " to be available.  The application must also then provide definitions for"]
	#[doc = " portCONFIGURE_TIMER_FOR_RUN_TIME_STATS() and portGET_RUN_TIME_COUNTER_VALUE()"]
	#[doc = " to configure a peripheral timer/counter and return the timers current count"]
	#[doc = " value respectively.  The counter should be at least 10 times the frequency of"]
	#[doc = " the tick count."]
	#[doc = ""]
	#[doc = " Setting configGENERATE_RUN_TIME_STATS to 1 will result in a total"]
	#[doc = " accumulated execution time being stored for each task.  The resolution"]
	#[doc = " of the accumulated time value depends on the frequency of the timer"]
	#[doc = " configured by the portCONFIGURE_TIMER_FOR_RUN_TIME_STATS() macro."]
	#[doc = " While uxTaskGetSystemState() and vTaskGetRunTimeStats() writes the total"]
	#[doc = " execution time of each task into a buffer, ulTaskGetIdleRunTimeCounter()"]
	#[doc = " returns the total execution time of just the idle task and"]
	#[doc = " ulTaskGetIdleRunTimePercent() returns the percentage of the CPU time used by"]
	#[doc = " just the idle task."]
	#[doc = ""]
	#[doc = " Note the amount of idle time is only a good measure of the slack time in a"]
	#[doc = " system if there are no other tasks executing at the idle priority, tickless"]
	#[doc = " idle is not used, and configIDLE_SHOULD_YIELD is set to 0."]
	#[doc = ""]
	#[doc = " @return The total run time of the idle task or the percentage of the total"]
	#[doc = " run time consumed by the idle task.  This is the amount of time the"]
	#[doc = " idle task has actually been executing.  The unit of time is dependent on the"]
	#[doc = " frequency configured using the portCONFIGURE_TIMER_FOR_RUN_TIME_STATS() and"]
	#[doc = " portGET_RUN_TIME_COUNTER_VALUE() macros."]
	#[doc = ""]
	#[doc = " \\defgroup ulTaskGetIdleRunTimeCounter ulTaskGetIdleRunTimeCounter"]
	#[doc = " \\ingroup TaskUtils"]
	pub fn ulTaskGetIdleRunTimeCounter() -> u32;
}
extern "C" {
	pub fn ulTaskGetIdleRunTimePercent() -> u32;
}
extern "C" {
	#[doc = " task. h"]
	#[doc = " @code{c}"]
	#[doc = " BaseType_t xTaskNotifyIndexed( TaskHandle_t xTaskToNotify, UBaseType_t uxIndexToNotify, uint32_t ulValue, eNotifyAction eAction );"]
	#[doc = " BaseType_t xTaskNotify( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction );"]
	#[doc = " @endcode"]
	#[doc = ""]
	#[doc = " See https://www.FreeRTOS.org/RTOS-task-notifications.html for details."]
	#[doc = ""]
	#[doc = " configUSE_TASK_NOTIFICATIONS must be undefined or defined as 1 for these"]
	#[doc = " functions to be available."]
	#[doc = ""]
	#[doc = " Sends a direct to task notification to a task, with an optional value and"]
	#[doc = " action."]
	#[doc = ""]
	#[doc = " Each task has a private array of \"notification values\" (or 'notifications'),"]
	#[doc = " each of which is a 32-bit unsigned integer (uint32_t).  The constant"]
	#[doc = " configTASK_NOTIFICATION_ARRAY_ENTRIES sets the number of indexes in the"]
	#[doc = " array, and (for backward compatibility) defaults to 1 if left undefined."]
	#[doc = " Prior to FreeRTOS V10.4.0 there was only one notification value per task."]
	#[doc = ""]
	#[doc = " Events can be sent to a task using an intermediary object.  Examples of such"]
	#[doc = " objects are queues, semaphores, mutexes and event groups.  Task notifications"]
	#[doc = " are a method of sending an event directly to a task without the need for such"]
	#[doc = " an intermediary object."]
	#[doc = ""]
	#[doc = " A notification sent to a task can optionally perform an action, such as"]
	#[doc = " update, overwrite or increment one of the task's notification values.  In"]
	#[doc = " that way task notifications can be used to send data to a task, or be used as"]
	#[doc = " light weight and fast binary or counting semaphores."]
	#[doc = ""]
	#[doc = " A task can use xTaskNotifyWaitIndexed() or ulTaskNotifyTakeIndexed() to"]
	#[doc = " [optionally] block to wait for a notification to be pending.  The task does"]
	#[doc = " not consume any CPU time while it is in the Blocked state."]
	#[doc = ""]
	#[doc = " A notification sent to a task will remain pending until it is cleared by the"]
	#[doc = " task calling xTaskNotifyWaitIndexed() or ulTaskNotifyTakeIndexed() (or their"]
	#[doc = " un-indexed equivalents).  If the task was already in the Blocked state to"]
	#[doc = " wait for a notification when the notification arrives then the task will"]
	#[doc = " automatically be removed from the Blocked state (unblocked) and the"]
	#[doc = " notification cleared."]
	#[doc = ""]
	#[doc = " **NOTE** Each notification within the array operates independently - a task"]
	#[doc = " can only block on one notification within the array at a time and will not be"]
	#[doc = " unblocked by a notification sent to any other array index."]
	#[doc = ""]
	#[doc = " Backward compatibility information:"]
	#[doc = " Prior to FreeRTOS V10.4.0 each task had a single \"notification value\", and"]
	#[doc = " all task notification API functions operated on that value. Replacing the"]
	#[doc = " single notification value with an array of notification values necessitated a"]
	#[doc = " new set of API functions that could address specific notifications within the"]
	#[doc = " array.  xTaskNotify() is the original API function, and remains backward"]
	#[doc = " compatible by always operating on the notification value at index 0 in the"]
	#[doc = " array. Calling xTaskNotify() is equivalent to calling xTaskNotifyIndexed()"]
	#[doc = " with the uxIndexToNotify parameter set to 0."]
	#[doc = ""]
	#[doc = " @param xTaskToNotify The handle of the task being notified.  The handle to a"]
	#[doc = " task can be returned from the xTaskCreate() API function used to create the"]
	#[doc = " task, and the handle of the currently running task can be obtained by calling"]
	#[doc = " xTaskGetCurrentTaskHandle()."]
	#[doc = ""]
	#[doc = " @param uxIndexToNotify The index within the target task's array of"]
	#[doc = " notification values to which the notification is to be sent.  uxIndexToNotify"]
	#[doc = " must be less than configTASK_NOTIFICATION_ARRAY_ENTRIES.  xTaskNotify() does"]
	#[doc = " not have this parameter and always sends notifications to index 0."]
	#[doc = ""]
	#[doc = " @param ulValue Data that can be sent with the notification.  How the data is"]
	#[doc = " used depends on the value of the eAction parameter."]
	#[doc = ""]
	#[doc = " @param eAction Specifies how the notification updates the task's notification"]
	#[doc = " value, if at all.  Valid values for eAction are as follows:"]
	#[doc = ""]
	#[doc = " eSetBits -"]
	#[doc = " The target notification value is bitwise ORed with ulValue."]
	#[doc = " xTaskNotifyIndexed() always returns pdPASS in this case."]
	#[doc = ""]
	#[doc = " eIncrement -"]
	#[doc = " The target notification value is incremented.  ulValue is not used and"]
	#[doc = " xTaskNotifyIndexed() always returns pdPASS in this case."]
	#[doc = ""]
	#[doc = " eSetValueWithOverwrite -"]
	#[doc = " The target notification value is set to the value of ulValue, even if the"]
	#[doc = " task being notified had not yet processed the previous notification at the"]
	#[doc = " same array index (the task already had a notification pending at that index)."]
	#[doc = " xTaskNotifyIndexed() always returns pdPASS in this case."]
	#[doc = ""]
	#[doc = " eSetValueWithoutOverwrite -"]
	#[doc = " If the task being notified did not already have a notification pending at the"]
	#[doc = " same array index then the target notification value is set to ulValue and"]
	#[doc = " xTaskNotifyIndexed() will return pdPASS.  If the task being notified already"]
	#[doc = " had a notification pending at the same array index then no action is"]
	#[doc = " performed and pdFAIL is returned."]
	#[doc = ""]
	#[doc = " eNoAction -"]
	#[doc = " The task receives a notification at the specified array index without the"]
	#[doc = " notification value at that index being updated.  ulValue is not used and"]
	#[doc = " xTaskNotifyIndexed() always returns pdPASS in this case."]
	#[doc = ""]
	#[doc = " pulPreviousNotificationValue -"]
	#[doc = " Can be used to pass out the subject task's notification value before any"]
	#[doc = " bits are modified by the notify function."]
	#[doc = ""]
	#[doc = " @return Dependent on the value of eAction.  See the description of the"]
	#[doc = " eAction parameter."]
	#[doc = ""]
	#[doc = " \\defgroup xTaskNotifyIndexed xTaskNotifyIndexed"]
	#[doc = " \\ingroup TaskNotifications"]
	pub fn xTaskGenericNotify(xTaskToNotify: TaskHandle_t,
	                          uxIndexToNotify: UBaseType_t,
	                          ulValue: u32,
	                          eAction: eNotifyAction,
	                          pulPreviousNotificationValue: *mut u32)
	                          -> BaseType_t;
}
extern "C" {
	#[doc = " task. h"]
	#[doc = " @code{c}"]
	#[doc = " BaseType_t xTaskNotifyIndexedFromISR( TaskHandle_t xTaskToNotify, UBaseType_t uxIndexToNotify, uint32_t ulValue, eNotifyAction eAction, BaseType_t *pxHigherPriorityTaskWoken );"]
	#[doc = " BaseType_t xTaskNotifyFromISR( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, BaseType_t *pxHigherPriorityTaskWoken );"]
	#[doc = " @endcode"]
	#[doc = ""]
	#[doc = " See https://www.FreeRTOS.org/RTOS-task-notifications.html for details."]
	#[doc = ""]
	#[doc = " configUSE_TASK_NOTIFICATIONS must be undefined or defined as 1 for these"]
	#[doc = " functions to be available."]
	#[doc = ""]
	#[doc = " A version of xTaskNotifyIndexed() that can be used from an interrupt service"]
	#[doc = " routine (ISR)."]
	#[doc = ""]
	#[doc = " Each task has a private array of \"notification values\" (or 'notifications'),"]
	#[doc = " each of which is a 32-bit unsigned integer (uint32_t).  The constant"]
	#[doc = " configTASK_NOTIFICATION_ARRAY_ENTRIES sets the number of indexes in the"]
	#[doc = " array, and (for backward compatibility) defaults to 1 if left undefined."]
	#[doc = " Prior to FreeRTOS V10.4.0 there was only one notification value per task."]
	#[doc = ""]
	#[doc = " Events can be sent to a task using an intermediary object.  Examples of such"]
	#[doc = " objects are queues, semaphores, mutexes and event groups.  Task notifications"]
	#[doc = " are a method of sending an event directly to a task without the need for such"]
	#[doc = " an intermediary object."]
	#[doc = ""]
	#[doc = " A notification sent to a task can optionally perform an action, such as"]
	#[doc = " update, overwrite or increment one of the task's notification values.  In"]
	#[doc = " that way task notifications can be used to send data to a task, or be used as"]
	#[doc = " light weight and fast binary or counting semaphores."]
	#[doc = ""]
	#[doc = " A task can use xTaskNotifyWaitIndexed() to [optionally] block to wait for a"]
	#[doc = " notification to be pending, or ulTaskNotifyTakeIndexed() to [optionally] block"]
	#[doc = " to wait for a notification value to have a non-zero value.  The task does"]
	#[doc = " not consume any CPU time while it is in the Blocked state."]
	#[doc = ""]
	#[doc = " A notification sent to a task will remain pending until it is cleared by the"]
	#[doc = " task calling xTaskNotifyWaitIndexed() or ulTaskNotifyTakeIndexed() (or their"]
	#[doc = " un-indexed equivalents).  If the task was already in the Blocked state to"]
	#[doc = " wait for a notification when the notification arrives then the task will"]
	#[doc = " automatically be removed from the Blocked state (unblocked) and the"]
	#[doc = " notification cleared."]
	#[doc = ""]
	#[doc = " **NOTE** Each notification within the array operates independently - a task"]
	#[doc = " can only block on one notification within the array at a time and will not be"]
	#[doc = " unblocked by a notification sent to any other array index."]
	#[doc = ""]
	#[doc = " Backward compatibility information:"]
	#[doc = " Prior to FreeRTOS V10.4.0 each task had a single \"notification value\", and"]
	#[doc = " all task notification API functions operated on that value. Replacing the"]
	#[doc = " single notification value with an array of notification values necessitated a"]
	#[doc = " new set of API functions that could address specific notifications within the"]
	#[doc = " array.  xTaskNotifyFromISR() is the original API function, and remains"]
	#[doc = " backward compatible by always operating on the notification value at index 0"]
	#[doc = " within the array. Calling xTaskNotifyFromISR() is equivalent to calling"]
	#[doc = " xTaskNotifyIndexedFromISR() with the uxIndexToNotify parameter set to 0."]
	#[doc = ""]
	#[doc = " @param uxIndexToNotify The index within the target task's array of"]
	#[doc = " notification values to which the notification is to be sent.  uxIndexToNotify"]
	#[doc = " must be less than configTASK_NOTIFICATION_ARRAY_ENTRIES.  xTaskNotifyFromISR()"]
	#[doc = " does not have this parameter and always sends notifications to index 0."]
	#[doc = ""]
	#[doc = " @param xTaskToNotify The handle of the task being notified.  The handle to a"]
	#[doc = " task can be returned from the xTaskCreate() API function used to create the"]
	#[doc = " task, and the handle of the currently running task can be obtained by calling"]
	#[doc = " xTaskGetCurrentTaskHandle()."]
	#[doc = ""]
	#[doc = " @param ulValue Data that can be sent with the notification.  How the data is"]
	#[doc = " used depends on the value of the eAction parameter."]
	#[doc = ""]
	#[doc = " @param eAction Specifies how the notification updates the task's notification"]
	#[doc = " value, if at all.  Valid values for eAction are as follows:"]
	#[doc = ""]
	#[doc = " eSetBits -"]
	#[doc = " The task's notification value is bitwise ORed with ulValue.  xTaskNotify()"]
	#[doc = " always returns pdPASS in this case."]
	#[doc = ""]
	#[doc = " eIncrement -"]
	#[doc = " The task's notification value is incremented.  ulValue is not used and"]
	#[doc = " xTaskNotify() always returns pdPASS in this case."]
	#[doc = ""]
	#[doc = " eSetValueWithOverwrite -"]
	#[doc = " The task's notification value is set to the value of ulValue, even if the"]
	#[doc = " task being notified had not yet processed the previous notification (the"]
	#[doc = " task already had a notification pending).  xTaskNotify() always returns"]
	#[doc = " pdPASS in this case."]
	#[doc = ""]
	#[doc = " eSetValueWithoutOverwrite -"]
	#[doc = " If the task being notified did not already have a notification pending then"]
	#[doc = " the task's notification value is set to ulValue and xTaskNotify() will"]
	#[doc = " return pdPASS.  If the task being notified already had a notification"]
	#[doc = " pending then no action is performed and pdFAIL is returned."]
	#[doc = ""]
	#[doc = " eNoAction -"]
	#[doc = " The task receives a notification without its notification value being"]
	#[doc = " updated.  ulValue is not used and xTaskNotify() always returns pdPASS in"]
	#[doc = " this case."]
	#[doc = ""]
	#[doc = " @param pxHigherPriorityTaskWoken  xTaskNotifyFromISR() will set"]
	#[doc = " *pxHigherPriorityTaskWoken to pdTRUE if sending the notification caused the"]
	#[doc = " task to which the notification was sent to leave the Blocked state, and the"]
	#[doc = " unblocked task has a priority higher than the currently running task.  If"]
	#[doc = " xTaskNotifyFromISR() sets this value to pdTRUE then a context switch should"]
	#[doc = " be requested before the interrupt is exited.  How a context switch is"]
	#[doc = " requested from an ISR is dependent on the port - see the documentation page"]
	#[doc = " for the port in use."]
	#[doc = ""]
	#[doc = " @return Dependent on the value of eAction.  See the description of the"]
	#[doc = " eAction parameter."]
	#[doc = ""]
	#[doc = " \\defgroup xTaskNotifyIndexedFromISR xTaskNotifyIndexedFromISR"]
	#[doc = " \\ingroup TaskNotifications"]
	pub fn xTaskGenericNotifyFromISR(xTaskToNotify: TaskHandle_t,
	                                 uxIndexToNotify: UBaseType_t,
	                                 ulValue: u32,
	                                 eAction: eNotifyAction,
	                                 pulPreviousNotificationValue: *mut u32,
	                                 pxHigherPriorityTaskWoken: *mut BaseType_t)
	                                 -> BaseType_t;
}
extern "C" {
	#[doc = " task. h"]
	#[doc = " @code{c}"]
	#[doc = " BaseType_t xTaskNotifyWaitIndexed( UBaseType_t uxIndexToWaitOn, uint32_t ulBitsToClearOnEntry, uint32_t ulBitsToClearOnExit, uint32_t *pulNotificationValue, TickType_t xTicksToWait );"]
	#[doc = ""]
	#[doc = " BaseType_t xTaskNotifyWait( uint32_t ulBitsToClearOnEntry, uint32_t ulBitsToClearOnExit, uint32_t *pulNotificationValue, TickType_t xTicksToWait );"]
	#[doc = " @endcode"]
	#[doc = ""]
	#[doc = " Waits for a direct to task notification to be pending at a given index within"]
	#[doc = " an array of direct to task notifications."]
	#[doc = ""]
	#[doc = " See https://www.FreeRTOS.org/RTOS-task-notifications.html for details."]
	#[doc = ""]
	#[doc = " configUSE_TASK_NOTIFICATIONS must be undefined or defined as 1 for this"]
	#[doc = " function to be available."]
	#[doc = ""]
	#[doc = " Each task has a private array of \"notification values\" (or 'notifications'),"]
	#[doc = " each of which is a 32-bit unsigned integer (uint32_t).  The constant"]
	#[doc = " configTASK_NOTIFICATION_ARRAY_ENTRIES sets the number of indexes in the"]
	#[doc = " array, and (for backward compatibility) defaults to 1 if left undefined."]
	#[doc = " Prior to FreeRTOS V10.4.0 there was only one notification value per task."]
	#[doc = ""]
	#[doc = " Events can be sent to a task using an intermediary object.  Examples of such"]
	#[doc = " objects are queues, semaphores, mutexes and event groups.  Task notifications"]
	#[doc = " are a method of sending an event directly to a task without the need for such"]
	#[doc = " an intermediary object."]
	#[doc = ""]
	#[doc = " A notification sent to a task can optionally perform an action, such as"]
	#[doc = " update, overwrite or increment one of the task's notification values.  In"]
	#[doc = " that way task notifications can be used to send data to a task, or be used as"]
	#[doc = " light weight and fast binary or counting semaphores."]
	#[doc = ""]
	#[doc = " A notification sent to a task will remain pending until it is cleared by the"]
	#[doc = " task calling xTaskNotifyWaitIndexed() or ulTaskNotifyTakeIndexed() (or their"]
	#[doc = " un-indexed equivalents).  If the task was already in the Blocked state to"]
	#[doc = " wait for a notification when the notification arrives then the task will"]
	#[doc = " automatically be removed from the Blocked state (unblocked) and the"]
	#[doc = " notification cleared."]
	#[doc = ""]
	#[doc = " A task can use xTaskNotifyWaitIndexed() to [optionally] block to wait for a"]
	#[doc = " notification to be pending, or ulTaskNotifyTakeIndexed() to [optionally] block"]
	#[doc = " to wait for a notification value to have a non-zero value.  The task does"]
	#[doc = " not consume any CPU time while it is in the Blocked state."]
	#[doc = ""]
	#[doc = " **NOTE** Each notification within the array operates independently - a task"]
	#[doc = " can only block on one notification within the array at a time and will not be"]
	#[doc = " unblocked by a notification sent to any other array index."]
	#[doc = ""]
	#[doc = " Backward compatibility information:"]
	#[doc = " Prior to FreeRTOS V10.4.0 each task had a single \"notification value\", and"]
	#[doc = " all task notification API functions operated on that value. Replacing the"]
	#[doc = " single notification value with an array of notification values necessitated a"]
	#[doc = " new set of API functions that could address specific notifications within the"]
	#[doc = " array.  xTaskNotifyWait() is the original API function, and remains backward"]
	#[doc = " compatible by always operating on the notification value at index 0 in the"]
	#[doc = " array. Calling xTaskNotifyWait() is equivalent to calling"]
	#[doc = " xTaskNotifyWaitIndexed() with the uxIndexToWaitOn parameter set to 0."]
	#[doc = ""]
	#[doc = " @param uxIndexToWaitOn The index within the calling task's array of"]
	#[doc = " notification values on which the calling task will wait for a notification to"]
	#[doc = " be received.  uxIndexToWaitOn must be less than"]
	#[doc = " configTASK_NOTIFICATION_ARRAY_ENTRIES.  xTaskNotifyWait() does"]
	#[doc = " not have this parameter and always waits for notifications on index 0."]
	#[doc = ""]
	#[doc = " @param ulBitsToClearOnEntry Bits that are set in ulBitsToClearOnEntry value"]
	#[doc = " will be cleared in the calling task's notification value before the task"]
	#[doc = " checks to see if any notifications are pending, and optionally blocks if no"]
	#[doc = " notifications are pending.  Setting ulBitsToClearOnEntry to ULONG_MAX (if"]
	#[doc = " limits.h is included) or 0xffffffffUL (if limits.h is not included) will have"]
	#[doc = " the effect of resetting the task's notification value to 0.  Setting"]
	#[doc = " ulBitsToClearOnEntry to 0 will leave the task's notification value unchanged."]
	#[doc = ""]
	#[doc = " @param ulBitsToClearOnExit If a notification is pending or received before"]
	#[doc = " the calling task exits the xTaskNotifyWait() function then the task's"]
	#[doc = " notification value (see the xTaskNotify() API function) is passed out using"]
	#[doc = " the pulNotificationValue parameter.  Then any bits that are set in"]
	#[doc = " ulBitsToClearOnExit will be cleared in the task's notification value (note"]
	#[doc = " *pulNotificationValue is set before any bits are cleared).  Setting"]
	#[doc = " ulBitsToClearOnExit to ULONG_MAX (if limits.h is included) or 0xffffffffUL"]
	#[doc = " (if limits.h is not included) will have the effect of resetting the task's"]
	#[doc = " notification value to 0 before the function exits.  Setting"]
	#[doc = " ulBitsToClearOnExit to 0 will leave the task's notification value unchanged"]
	#[doc = " when the function exits (in which case the value passed out in"]
	#[doc = " pulNotificationValue will match the task's notification value)."]
	#[doc = ""]
	#[doc = " @param pulNotificationValue Used to pass the task's notification value out"]
	#[doc = " of the function.  Note the value passed out will not be effected by the"]
	#[doc = " clearing of any bits caused by ulBitsToClearOnExit being non-zero."]
	#[doc = ""]
	#[doc = " @param xTicksToWait The maximum amount of time that the task should wait in"]
	#[doc = " the Blocked state for a notification to be received, should a notification"]
	#[doc = " not already be pending when xTaskNotifyWait() was called.  The task"]
	#[doc = " will not consume any processing time while it is in the Blocked state.  This"]
	#[doc = " is specified in kernel ticks, the macro pdMS_TO_TICKS( value_in_ms ) can be"]
	#[doc = " used to convert a time specified in milliseconds to a time specified in"]
	#[doc = " ticks."]
	#[doc = ""]
	#[doc = " @return If a notification was received (including notifications that were"]
	#[doc = " already pending when xTaskNotifyWait was called) then pdPASS is"]
	#[doc = " returned.  Otherwise pdFAIL is returned."]
	#[doc = ""]
	#[doc = " \\defgroup xTaskNotifyWaitIndexed xTaskNotifyWaitIndexed"]
	#[doc = " \\ingroup TaskNotifications"]
	pub fn xTaskGenericNotifyWait(uxIndexToWaitOn: UBaseType_t,
	                              ulBitsToClearOnEntry: u32,
	                              ulBitsToClearOnExit: u32,
	                              pulNotificationValue: *mut u32,
	                              xTicksToWait: TickType_t)
	                              -> BaseType_t;
}
extern "C" {
	#[doc = " task. h"]
	#[doc = " @code{c}"]
	#[doc = " void vTaskNotifyGiveIndexedFromISR( TaskHandle_t xTaskHandle, UBaseType_t uxIndexToNotify, BaseType_t *pxHigherPriorityTaskWoken );"]
	#[doc = " void vTaskNotifyGiveFromISR( TaskHandle_t xTaskHandle, BaseType_t *pxHigherPriorityTaskWoken );"]
	#[doc = " @endcode"]
	#[doc = ""]
	#[doc = " A version of xTaskNotifyGiveIndexed() that can be called from an interrupt"]
	#[doc = " service routine (ISR)."]
	#[doc = ""]
	#[doc = " See https://www.FreeRTOS.org/RTOS-task-notifications.html for more details."]
	#[doc = ""]
	#[doc = " configUSE_TASK_NOTIFICATIONS must be undefined or defined as 1 for this macro"]
	#[doc = " to be available."]
	#[doc = ""]
	#[doc = " Each task has a private array of \"notification values\" (or 'notifications'),"]
	#[doc = " each of which is a 32-bit unsigned integer (uint32_t).  The constant"]
	#[doc = " configTASK_NOTIFICATION_ARRAY_ENTRIES sets the number of indexes in the"]
	#[doc = " array, and (for backward compatibility) defaults to 1 if left undefined."]
	#[doc = " Prior to FreeRTOS V10.4.0 there was only one notification value per task."]
	#[doc = ""]
	#[doc = " Events can be sent to a task using an intermediary object.  Examples of such"]
	#[doc = " objects are queues, semaphores, mutexes and event groups.  Task notifications"]
	#[doc = " are a method of sending an event directly to a task without the need for such"]
	#[doc = " an intermediary object."]
	#[doc = ""]
	#[doc = " A notification sent to a task can optionally perform an action, such as"]
	#[doc = " update, overwrite or increment one of the task's notification values.  In"]
	#[doc = " that way task notifications can be used to send data to a task, or be used as"]
	#[doc = " light weight and fast binary or counting semaphores."]
	#[doc = ""]
	#[doc = " vTaskNotifyGiveIndexedFromISR() is intended for use when task notifications"]
	#[doc = " are used as light weight and faster binary or counting semaphore equivalents."]
	#[doc = " Actual FreeRTOS semaphores are given from an ISR using the"]
	#[doc = " xSemaphoreGiveFromISR() API function, the equivalent action that instead uses"]
	#[doc = " a task notification is vTaskNotifyGiveIndexedFromISR()."]
	#[doc = ""]
	#[doc = " When task notifications are being used as a binary or counting semaphore"]
	#[doc = " equivalent then the task being notified should wait for the notification"]
	#[doc = " using the ulTaskNotifyTakeIndexed() API function rather than the"]
	#[doc = " xTaskNotifyWaitIndexed() API function."]
	#[doc = ""]
	#[doc = " **NOTE** Each notification within the array operates independently - a task"]
	#[doc = " can only block on one notification within the array at a time and will not be"]
	#[doc = " unblocked by a notification sent to any other array index."]
	#[doc = ""]
	#[doc = " Backward compatibility information:"]
	#[doc = " Prior to FreeRTOS V10.4.0 each task had a single \"notification value\", and"]
	#[doc = " all task notification API functions operated on that value. Replacing the"]
	#[doc = " single notification value with an array of notification values necessitated a"]
	#[doc = " new set of API functions that could address specific notifications within the"]
	#[doc = " array.  xTaskNotifyFromISR() is the original API function, and remains"]
	#[doc = " backward compatible by always operating on the notification value at index 0"]
	#[doc = " within the array. Calling xTaskNotifyGiveFromISR() is equivalent to calling"]
	#[doc = " xTaskNotifyGiveIndexedFromISR() with the uxIndexToNotify parameter set to 0."]
	#[doc = ""]
	#[doc = " @param xTaskToNotify The handle of the task being notified.  The handle to a"]
	#[doc = " task can be returned from the xTaskCreate() API function used to create the"]
	#[doc = " task, and the handle of the currently running task can be obtained by calling"]
	#[doc = " xTaskGetCurrentTaskHandle()."]
	#[doc = ""]
	#[doc = " @param uxIndexToNotify The index within the target task's array of"]
	#[doc = " notification values to which the notification is to be sent.  uxIndexToNotify"]
	#[doc = " must be less than configTASK_NOTIFICATION_ARRAY_ENTRIES."]
	#[doc = " xTaskNotifyGiveFromISR() does not have this parameter and always sends"]
	#[doc = " notifications to index 0."]
	#[doc = ""]
	#[doc = " @param pxHigherPriorityTaskWoken  vTaskNotifyGiveFromISR() will set"]
	#[doc = " *pxHigherPriorityTaskWoken to pdTRUE if sending the notification caused the"]
	#[doc = " task to which the notification was sent to leave the Blocked state, and the"]
	#[doc = " unblocked task has a priority higher than the currently running task.  If"]
	#[doc = " vTaskNotifyGiveFromISR() sets this value to pdTRUE then a context switch"]
	#[doc = " should be requested before the interrupt is exited.  How a context switch is"]
	#[doc = " requested from an ISR is dependent on the port - see the documentation page"]
	#[doc = " for the port in use."]
	#[doc = ""]
	#[doc = " \\defgroup vTaskNotifyGiveIndexedFromISR vTaskNotifyGiveIndexedFromISR"]
	#[doc = " \\ingroup TaskNotifications"]
	pub fn vTaskGenericNotifyGiveFromISR(xTaskToNotify: TaskHandle_t,
	                                     uxIndexToNotify: UBaseType_t,
	                                     pxHigherPriorityTaskWoken: *mut BaseType_t);
}
extern "C" {
	#[doc = " task. h"]
	#[doc = " @code{c}"]
	#[doc = " uint32_t ulTaskNotifyTakeIndexed( UBaseType_t uxIndexToWaitOn, BaseType_t xClearCountOnExit, TickType_t xTicksToWait );"]
	#[doc = ""]
	#[doc = " uint32_t ulTaskNotifyTake( BaseType_t xClearCountOnExit, TickType_t xTicksToWait );"]
	#[doc = " @endcode"]
	#[doc = ""]
	#[doc = " Waits for a direct to task notification on a particular index in the calling"]
	#[doc = " task's notification array in a manner similar to taking a counting semaphore."]
	#[doc = ""]
	#[doc = " See https://www.FreeRTOS.org/RTOS-task-notifications.html for details."]
	#[doc = ""]
	#[doc = " configUSE_TASK_NOTIFICATIONS must be undefined or defined as 1 for this"]
	#[doc = " function to be available."]
	#[doc = ""]
	#[doc = " Each task has a private array of \"notification values\" (or 'notifications'),"]
	#[doc = " each of which is a 32-bit unsigned integer (uint32_t).  The constant"]
	#[doc = " configTASK_NOTIFICATION_ARRAY_ENTRIES sets the number of indexes in the"]
	#[doc = " array, and (for backward compatibility) defaults to 1 if left undefined."]
	#[doc = " Prior to FreeRTOS V10.4.0 there was only one notification value per task."]
	#[doc = ""]
	#[doc = " Events can be sent to a task using an intermediary object.  Examples of such"]
	#[doc = " objects are queues, semaphores, mutexes and event groups.  Task notifications"]
	#[doc = " are a method of sending an event directly to a task without the need for such"]
	#[doc = " an intermediary object."]
	#[doc = ""]
	#[doc = " A notification sent to a task can optionally perform an action, such as"]
	#[doc = " update, overwrite or increment one of the task's notification values.  In"]
	#[doc = " that way task notifications can be used to send data to a task, or be used as"]
	#[doc = " light weight and fast binary or counting semaphores."]
	#[doc = ""]
	#[doc = " ulTaskNotifyTakeIndexed() is intended for use when a task notification is"]
	#[doc = " used as a faster and lighter weight binary or counting semaphore alternative."]
	#[doc = " Actual FreeRTOS semaphores are taken using the xSemaphoreTake() API function,"]
	#[doc = " the equivalent action that instead uses a task notification is"]
	#[doc = " ulTaskNotifyTakeIndexed()."]
	#[doc = ""]
	#[doc = " When a task is using its notification value as a binary or counting semaphore"]
	#[doc = " other tasks should send notifications to it using the xTaskNotifyGiveIndexed()"]
	#[doc = " macro, or xTaskNotifyIndex() function with the eAction parameter set to"]
	#[doc = " eIncrement."]
	#[doc = ""]
	#[doc = " ulTaskNotifyTakeIndexed() can either clear the task's notification value at"]
	#[doc = " the array index specified by the uxIndexToWaitOn parameter to zero on exit,"]
	#[doc = " in which case the notification value acts like a binary semaphore, or"]
	#[doc = " decrement the notification value on exit, in which case the notification"]
	#[doc = " value acts like a counting semaphore."]
	#[doc = ""]
	#[doc = " A task can use ulTaskNotifyTakeIndexed() to [optionally] block to wait for"]
	#[doc = " a notification.  The task does not consume any CPU time while it is in the"]
	#[doc = " Blocked state."]
	#[doc = ""]
	#[doc = " Where as xTaskNotifyWaitIndexed() will return when a notification is pending,"]
	#[doc = " ulTaskNotifyTakeIndexed() will return when the task's notification value is"]
	#[doc = " not zero."]
	#[doc = ""]
	#[doc = " **NOTE** Each notification within the array operates independently - a task"]
	#[doc = " can only block on one notification within the array at a time and will not be"]
	#[doc = " unblocked by a notification sent to any other array index."]
	#[doc = ""]
	#[doc = " Backward compatibility information:"]
	#[doc = " Prior to FreeRTOS V10.4.0 each task had a single \"notification value\", and"]
	#[doc = " all task notification API functions operated on that value. Replacing the"]
	#[doc = " single notification value with an array of notification values necessitated a"]
	#[doc = " new set of API functions that could address specific notifications within the"]
	#[doc = " array.  ulTaskNotifyTake() is the original API function, and remains backward"]
	#[doc = " compatible by always operating on the notification value at index 0 in the"]
	#[doc = " array. Calling ulTaskNotifyTake() is equivalent to calling"]
	#[doc = " ulTaskNotifyTakeIndexed() with the uxIndexToWaitOn parameter set to 0."]
	#[doc = ""]
	#[doc = " @param uxIndexToWaitOn The index within the calling task's array of"]
	#[doc = " notification values on which the calling task will wait for a notification to"]
	#[doc = " be non-zero.  uxIndexToWaitOn must be less than"]
	#[doc = " configTASK_NOTIFICATION_ARRAY_ENTRIES.  xTaskNotifyTake() does"]
	#[doc = " not have this parameter and always waits for notifications on index 0."]
	#[doc = ""]
	#[doc = " @param xClearCountOnExit if xClearCountOnExit is pdFALSE then the task's"]
	#[doc = " notification value is decremented when the function exits.  In this way the"]
	#[doc = " notification value acts like a counting semaphore.  If xClearCountOnExit is"]
	#[doc = " not pdFALSE then the task's notification value is cleared to zero when the"]
	#[doc = " function exits.  In this way the notification value acts like a binary"]
	#[doc = " semaphore."]
	#[doc = ""]
	#[doc = " @param xTicksToWait The maximum amount of time that the task should wait in"]
	#[doc = " the Blocked state for the task's notification value to be greater than zero,"]
	#[doc = " should the count not already be greater than zero when"]
	#[doc = " ulTaskNotifyTake() was called.  The task will not consume any processing"]
	#[doc = " time while it is in the Blocked state.  This is specified in kernel ticks,"]
	#[doc = " the macro pdMS_TO_TICKS( value_in_ms ) can be used to convert a time"]
	#[doc = " specified in milliseconds to a time specified in ticks."]
	#[doc = ""]
	#[doc = " @return The task's notification count before it is either cleared to zero or"]
	#[doc = " decremented (see the xClearCountOnExit parameter)."]
	#[doc = ""]
	#[doc = " \\defgroup ulTaskNotifyTakeIndexed ulTaskNotifyTakeIndexed"]
	#[doc = " \\ingroup TaskNotifications"]
	pub fn ulTaskGenericNotifyTake(uxIndexToWaitOn: UBaseType_t, xClearCountOnExit: BaseType_t, xTicksToWait: TickType_t) -> u32;
}
extern "C" {
	#[doc = " task. h"]
	#[doc = " @code{c}"]
	#[doc = " BaseType_t xTaskNotifyStateClearIndexed( TaskHandle_t xTask, UBaseType_t uxIndexToCLear );"]
	#[doc = ""]
	#[doc = " BaseType_t xTaskNotifyStateClear( TaskHandle_t xTask );"]
	#[doc = " @endcode"]
	#[doc = ""]
	#[doc = " See https://www.FreeRTOS.org/RTOS-task-notifications.html for details."]
	#[doc = ""]
	#[doc = " configUSE_TASK_NOTIFICATIONS must be undefined or defined as 1 for these"]
	#[doc = " functions to be available."]
	#[doc = ""]
	#[doc = " Each task has a private array of \"notification values\" (or 'notifications'),"]
	#[doc = " each of which is a 32-bit unsigned integer (uint32_t).  The constant"]
	#[doc = " configTASK_NOTIFICATION_ARRAY_ENTRIES sets the number of indexes in the"]
	#[doc = " array, and (for backward compatibility) defaults to 1 if left undefined."]
	#[doc = " Prior to FreeRTOS V10.4.0 there was only one notification value per task."]
	#[doc = ""]
	#[doc = " If a notification is sent to an index within the array of notifications then"]
	#[doc = " the notification at that index is said to be 'pending' until it is read or"]
	#[doc = " explicitly cleared by the receiving task.  xTaskNotifyStateClearIndexed()"]
	#[doc = " is the function that clears a pending notification without reading the"]
	#[doc = " notification value.  The notification value at the same array index is not"]
	#[doc = " altered.  Set xTask to NULL to clear the notification state of the calling"]
	#[doc = " task."]
	#[doc = ""]
	#[doc = " Backward compatibility information:"]
	#[doc = " Prior to FreeRTOS V10.4.0 each task had a single \"notification value\", and"]
	#[doc = " all task notification API functions operated on that value. Replacing the"]
	#[doc = " single notification value with an array of notification values necessitated a"]
	#[doc = " new set of API functions that could address specific notifications within the"]
	#[doc = " array.  xTaskNotifyStateClear() is the original API function, and remains"]
	#[doc = " backward compatible by always operating on the notification value at index 0"]
	#[doc = " within the array. Calling xTaskNotifyStateClear() is equivalent to calling"]
	#[doc = " xTaskNotifyStateClearIndexed() with the uxIndexToNotify parameter set to 0."]
	#[doc = ""]
	#[doc = " @param xTask The handle of the RTOS task that will have a notification state"]
	#[doc = " cleared.  Set xTask to NULL to clear a notification state in the calling"]
	#[doc = " task.  To obtain a task's handle create the task using xTaskCreate() and"]
	#[doc = " make use of the pxCreatedTask parameter, or create the task using"]
	#[doc = " xTaskCreateStatic() and store the returned value, or use the task's name in"]
	#[doc = " a call to xTaskGetHandle()."]
	#[doc = ""]
	#[doc = " @param uxIndexToClear The index within the target task's array of"]
	#[doc = " notification values to act upon.  For example, setting uxIndexToClear to 1"]
	#[doc = " will clear the state of the notification at index 1 within the array."]
	#[doc = " uxIndexToClear must be less than configTASK_NOTIFICATION_ARRAY_ENTRIES."]
	#[doc = " ulTaskNotifyStateClear() does not have this parameter and always acts on the"]
	#[doc = " notification at index 0."]
	#[doc = ""]
	#[doc = " @return pdTRUE if the task's notification state was set to"]
	#[doc = " eNotWaitingNotification, otherwise pdFALSE."]
	#[doc = ""]
	#[doc = " \\defgroup xTaskNotifyStateClearIndexed xTaskNotifyStateClearIndexed"]
	#[doc = " \\ingroup TaskNotifications"]
	pub fn xTaskGenericNotifyStateClear(xTask: TaskHandle_t, uxIndexToClear: UBaseType_t) -> BaseType_t;
}
extern "C" {
	#[doc = " task. h"]
	#[doc = " @code{c}"]
	#[doc = " uint32_t ulTaskNotifyValueClearIndexed( TaskHandle_t xTask, UBaseType_t uxIndexToClear, uint32_t ulBitsToClear );"]
	#[doc = ""]
	#[doc = " uint32_t ulTaskNotifyValueClear( TaskHandle_t xTask, uint32_t ulBitsToClear );"]
	#[doc = " @endcode"]
	#[doc = ""]
	#[doc = " See https://www.FreeRTOS.org/RTOS-task-notifications.html for details."]
	#[doc = ""]
	#[doc = " configUSE_TASK_NOTIFICATIONS must be undefined or defined as 1 for these"]
	#[doc = " functions to be available."]
	#[doc = ""]
	#[doc = " Each task has a private array of \"notification values\" (or 'notifications'),"]
	#[doc = " each of which is a 32-bit unsigned integer (uint32_t).  The constant"]
	#[doc = " configTASK_NOTIFICATION_ARRAY_ENTRIES sets the number of indexes in the"]
	#[doc = " array, and (for backward compatibility) defaults to 1 if left undefined."]
	#[doc = " Prior to FreeRTOS V10.4.0 there was only one notification value per task."]
	#[doc = ""]
	#[doc = " ulTaskNotifyValueClearIndexed() clears the bits specified by the"]
	#[doc = " ulBitsToClear bit mask in the notification value at array index uxIndexToClear"]
	#[doc = " of the task referenced by xTask."]
	#[doc = ""]
	#[doc = " Backward compatibility information:"]
	#[doc = " Prior to FreeRTOS V10.4.0 each task had a single \"notification value\", and"]
	#[doc = " all task notification API functions operated on that value. Replacing the"]
	#[doc = " single notification value with an array of notification values necessitated a"]
	#[doc = " new set of API functions that could address specific notifications within the"]
	#[doc = " array.  ulTaskNotifyValueClear() is the original API function, and remains"]
	#[doc = " backward compatible by always operating on the notification value at index 0"]
	#[doc = " within the array. Calling ulTaskNotifyValueClear() is equivalent to calling"]
	#[doc = " ulTaskNotifyValueClearIndexed() with the uxIndexToClear parameter set to 0."]
	#[doc = ""]
	#[doc = " @param xTask The handle of the RTOS task that will have bits in one of its"]
	#[doc = " notification values cleared. Set xTask to NULL to clear bits in a"]
	#[doc = " notification value of the calling task.  To obtain a task's handle create the"]
	#[doc = " task using xTaskCreate() and make use of the pxCreatedTask parameter, or"]
	#[doc = " create the task using xTaskCreateStatic() and store the returned value, or"]
	#[doc = " use the task's name in a call to xTaskGetHandle()."]
	#[doc = ""]
	#[doc = " @param uxIndexToClear The index within the target task's array of"]
	#[doc = " notification values in which to clear the bits.  uxIndexToClear"]
	#[doc = " must be less than configTASK_NOTIFICATION_ARRAY_ENTRIES."]
	#[doc = " ulTaskNotifyValueClear() does not have this parameter and always clears bits"]
	#[doc = " in the notification value at index 0."]
	#[doc = ""]
	#[doc = " @param ulBitsToClear Bit mask of the bits to clear in the notification value of"]
	#[doc = " xTask. Set a bit to 1 to clear the corresponding bits in the task's notification"]
	#[doc = " value. Set ulBitsToClear to 0xffffffff (UINT_MAX on 32-bit architectures) to clear"]
	#[doc = " the notification value to 0.  Set ulBitsToClear to 0 to query the task's"]
	#[doc = " notification value without clearing any bits."]
	#[doc = ""]
	#[doc = ""]
	#[doc = " @return The value of the target task's notification value before the bits"]
	#[doc = " specified by ulBitsToClear were cleared."]
	#[doc = " \\defgroup ulTaskNotifyValueClear ulTaskNotifyValueClear"]
	#[doc = " \\ingroup TaskNotifications"]
	pub fn ulTaskGenericNotifyValueClear(xTask: TaskHandle_t, uxIndexToClear: UBaseType_t, ulBitsToClear: u32) -> u32;
}
extern "C" {
	#[doc = " task.h"]
	#[doc = " @code{c}"]
	#[doc = " void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut );"]
	#[doc = " @endcode"]
	#[doc = ""]
	#[doc = " Capture the current time for future use with xTaskCheckForTimeOut()."]
	#[doc = ""]
	#[doc = " @param pxTimeOut Pointer to a timeout object into which the current time"]
	#[doc = " is to be captured.  The captured time includes the tick count and the number"]
	#[doc = " of times the tick count has overflowed since the system first booted."]
	#[doc = " \\defgroup vTaskSetTimeOutState vTaskSetTimeOutState"]
	#[doc = " \\ingroup TaskCtrl"]
	pub fn vTaskSetTimeOutState(pxTimeOut: *mut TimeOut_t);
}
extern "C" {
	#[doc = " task.h"]
	#[doc = " @code{c}"]
	#[doc = " BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait );"]
	#[doc = " @endcode"]
	#[doc = ""]
	#[doc = " Determines if pxTicksToWait ticks has passed since a time was captured"]
	#[doc = " using a call to vTaskSetTimeOutState().  The captured time includes the tick"]
	#[doc = " count and the number of times the tick count has overflowed."]
	#[doc = ""]
	#[doc = " @param pxTimeOut The time status as captured previously using"]
	#[doc = " vTaskSetTimeOutState. If the timeout has not yet occurred, it is updated"]
	#[doc = " to reflect the current time status."]
	#[doc = " @param pxTicksToWait The number of ticks to check for timeout i.e. if"]
	#[doc = " pxTicksToWait ticks have passed since pxTimeOut was last updated (either by"]
	#[doc = " vTaskSetTimeOutState() or xTaskCheckForTimeOut()), the timeout has occurred."]
	#[doc = " If the timeout has not occurred, pxTicksToWait is updated to reflect the"]
	#[doc = " number of remaining ticks."]
	#[doc = ""]
	#[doc = " @return If timeout has occurred, pdTRUE is returned. Otherwise pdFALSE is"]
	#[doc = " returned and pxTicksToWait is updated to reflect the number of remaining"]
	#[doc = " ticks."]
	#[doc = ""]
	#[doc = " @see https://www.FreeRTOS.org/xTaskCheckForTimeOut.html"]
	#[doc = ""]
	#[doc = " Example Usage:"]
	#[doc = " @code{c}"]
	#[doc = "  // Driver library function used to receive uxWantedBytes from an Rx buffer"]
	#[doc = "  // that is filled by a UART interrupt. If there are not enough bytes in the"]
	#[doc = "  // Rx buffer then the task enters the Blocked state until it is notified that"]
	#[doc = "  // more data has been placed into the buffer. If there is still not enough"]
	#[doc = "  // data then the task re-enters the Blocked state, and xTaskCheckForTimeOut()"]
	#[doc = "  // is used to re-calculate the Block time to ensure the total amount of time"]
	#[doc = "  // spent in the Blocked state does not exceed MAX_TIME_TO_WAIT. This"]
	#[doc = "  // continues until either the buffer contains at least uxWantedBytes bytes,"]
	#[doc = "  // or the total amount of time spent in the Blocked state reaches"]
	#[doc = "  // MAX_TIME_TO_WAIT - at which point the task reads however many bytes are"]
	#[doc = "  // available up to a maximum of uxWantedBytes."]
	#[doc = ""]
	#[doc = "  size_t xUART_Receive( uint8_t *pucBuffer, size_t uxWantedBytes )"]
	#[doc = "  {"]
	#[doc = "  size_t uxReceived = 0;"]
	#[doc = "  TickType_t xTicksToWait = MAX_TIME_TO_WAIT;"]
	#[doc = "  TimeOut_t xTimeOut;"]
	#[doc = ""]
	#[doc = "      // Initialize xTimeOut.  This records the time at which this function"]
	#[doc = "      // was entered."]
	#[doc = "      vTaskSetTimeOutState( &xTimeOut );"]
	#[doc = ""]
	#[doc = "      // Loop until the buffer contains the wanted number of bytes, or a"]
	#[doc = "      // timeout occurs."]
	#[doc = "      while( UART_bytes_in_rx_buffer( pxUARTInstance ) < uxWantedBytes )"]
	#[doc = "      {"]
	#[doc = "          // The buffer didn't contain enough data so this task is going to"]
	#[doc = "          // enter the Blocked state. Adjusting xTicksToWait to account for"]
	#[doc = "          // any time that has been spent in the Blocked state within this"]
	#[doc = "          // function so far to ensure the total amount of time spent in the"]
	#[doc = "          // Blocked state does not exceed MAX_TIME_TO_WAIT."]
	#[doc = "          if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) != pdFALSE )"]
	#[doc = "          {"]
	#[doc = "              //Timed out before the wanted number of bytes were available,"]
	#[doc = "              // exit the loop."]
	#[doc = "              break;"]
	#[doc = "          }"]
	#[doc = ""]
	#[doc = "          // Wait for a maximum of xTicksToWait ticks to be notified that the"]
	#[doc = "          // receive interrupt has placed more data into the buffer."]
	#[doc = "          ulTaskNotifyTake( pdTRUE, xTicksToWait );"]
	#[doc = "      }"]
	#[doc = ""]
	#[doc = "      // Attempt to read uxWantedBytes from the receive buffer into pucBuffer."]
	#[doc = "      // The actual number of bytes read (which might be less than"]
	#[doc = "      // uxWantedBytes) is returned."]
	#[doc = "      uxReceived = UART_read_from_receive_buffer( pxUARTInstance,"]
	#[doc = "                                                  pucBuffer,"]
	#[doc = "                                                  uxWantedBytes );"]
	#[doc = ""]
	#[doc = "      return uxReceived;"]
	#[doc = "  }"]
	#[doc = " @endcode"]
	#[doc = " \\defgroup xTaskCheckForTimeOut xTaskCheckForTimeOut"]
	#[doc = " \\ingroup TaskCtrl"]
	pub fn xTaskCheckForTimeOut(pxTimeOut: *mut TimeOut_t, pxTicksToWait: *mut TickType_t) -> BaseType_t;
}
extern "C" {
	#[doc = " task.h"]
	#[doc = " @code{c}"]
	#[doc = " BaseType_t xTaskCatchUpTicks( TickType_t xTicksToCatchUp );"]
	#[doc = " @endcode"]
	#[doc = ""]
	#[doc = " This function corrects the tick count value after the application code has held"]
	#[doc = " interrupts disabled for an extended period resulting in tick interrupts having"]
	#[doc = " been missed."]
	#[doc = ""]
	#[doc = " This function is similar to vTaskStepTick(), however, unlike"]
	#[doc = " vTaskStepTick(), xTaskCatchUpTicks() may move the tick count forward past a"]
	#[doc = " time at which a task should be removed from the blocked state.  That means"]
	#[doc = " tasks may have to be removed from the blocked state as the tick count is"]
	#[doc = " moved."]
	#[doc = ""]
	#[doc = " @param xTicksToCatchUp The number of tick interrupts that have been missed due to"]
	#[doc = " interrupts being disabled.  Its value is not computed automatically, so must be"]
	#[doc = " computed by the application writer."]
	#[doc = ""]
	#[doc = " @return pdTRUE if moving the tick count forward resulted in a task leaving the"]
	#[doc = " blocked state and a context switch being performed.  Otherwise pdFALSE."]
	#[doc = ""]
	#[doc = " \\defgroup xTaskCatchUpTicks xTaskCatchUpTicks"]
	#[doc = " \\ingroup TaskCtrl"]
	pub fn xTaskCatchUpTicks(xTicksToCatchUp: TickType_t) -> BaseType_t;
}
extern "C" {
	pub fn xTaskIncrementTick() -> BaseType_t;
}
extern "C" {
	pub fn vTaskPlaceOnEventList(pxEventList: *mut List_t, xTicksToWait: TickType_t);
}
extern "C" {
	pub fn vTaskPlaceOnUnorderedEventList(pxEventList: *mut List_t, xItemValue: TickType_t, xTicksToWait: TickType_t);
}
extern "C" {
	pub fn vTaskPlaceOnEventListRestricted(pxEventList: *mut List_t, xTicksToWait: TickType_t, xWaitIndefinitely: BaseType_t);
}
extern "C" {
	pub fn xTaskRemoveFromEventList(pxEventList: *const List_t) -> BaseType_t;
}
extern "C" {
	pub fn vTaskRemoveFromUnorderedEventList(pxEventListItem: *mut ListItem_t, xItemValue: TickType_t);
}
extern "C" {
	pub fn vTaskSwitchContext();
}
extern "C" {
	pub fn uxTaskResetEventItemValue() -> TickType_t;
}
extern "C" {
	pub fn xTaskGetCurrentTaskHandle() -> TaskHandle_t;
}
extern "C" {
	pub fn vTaskMissedYield();
}
extern "C" {
	pub fn xTaskGetSchedulerState() -> BaseType_t;
}
extern "C" {
	pub fn xTaskPriorityInherit(pxMutexHolder: TaskHandle_t) -> BaseType_t;
}
extern "C" {
	pub fn xTaskPriorityDisinherit(pxMutexHolder: TaskHandle_t) -> BaseType_t;
}
extern "C" {
	pub fn vTaskPriorityDisinheritAfterTimeout(pxMutexHolder: TaskHandle_t, uxHighestPriorityWaitingTask: UBaseType_t);
}
extern "C" {
	pub fn uxTaskGetTaskNumber(xTask: TaskHandle_t) -> UBaseType_t;
}
extern "C" {
	pub fn vTaskSetTaskNumber(xTask: TaskHandle_t, uxHandle: UBaseType_t);
}
extern "C" {
	pub fn vTaskStepTick(xTicksToJump: TickType_t);
}
extern "C" {
	pub fn eTaskConfirmSleepModeStatus() -> eSleepModeStatus;
}
extern "C" {
	pub fn pvTaskIncrementMutexHeldCount() -> TaskHandle_t;
}
extern "C" {
	pub fn vTaskInternalSetTimeOutState(pxTimeOut: *mut TimeOut_t);
}
#[repr(C, packed)]
pub struct T_UINT32 {
	pub v: u32,
}
#[test]
fn bindgen_test_layout_T_UINT32() {
	assert_eq!(
	           ::core::mem::size_of::<T_UINT32>(),
	           4usize,
	           concat!("Size of: ", stringify!(T_UINT32))
	);
	assert_eq!(
	           ::core::mem::align_of::<T_UINT32>(),
	           1usize,
	           concat!("Alignment of ", stringify!(T_UINT32))
	);
	fn test_field_v() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<T_UINT32>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).v) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(T_UINT32), "::", stringify!(v))
		);
	}
	test_field_v();
}
#[repr(C, packed)]
pub struct T_UINT16_WRITE {
	pub v: u16,
}
#[test]
fn bindgen_test_layout_T_UINT16_WRITE() {
	assert_eq!(
	           ::core::mem::size_of::<T_UINT16_WRITE>(),
	           2usize,
	           concat!("Size of: ", stringify!(T_UINT16_WRITE))
	);
	assert_eq!(
	           ::core::mem::align_of::<T_UINT16_WRITE>(),
	           1usize,
	           concat!("Alignment of ", stringify!(T_UINT16_WRITE))
	);
	fn test_field_v() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<T_UINT16_WRITE>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).v) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(T_UINT16_WRITE), "::", stringify!(v))
		);
	}
	test_field_v();
}
#[repr(C, packed)]
pub struct T_UINT16_READ {
	pub v: u16,
}
#[test]
fn bindgen_test_layout_T_UINT16_READ() {
	assert_eq!(
	           ::core::mem::size_of::<T_UINT16_READ>(),
	           2usize,
	           concat!("Size of: ", stringify!(T_UINT16_READ))
	);
	assert_eq!(
	           ::core::mem::align_of::<T_UINT16_READ>(),
	           1usize,
	           concat!("Alignment of ", stringify!(T_UINT16_READ))
	);
	fn test_field_v() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<T_UINT16_READ>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).v) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(T_UINT16_READ), "::", stringify!(v))
		);
	}
	test_field_v();
}
#[repr(C, packed)]
pub struct T_UINT32_WRITE {
	pub v: u32,
}
#[test]
fn bindgen_test_layout_T_UINT32_WRITE() {
	assert_eq!(
	           ::core::mem::size_of::<T_UINT32_WRITE>(),
	           4usize,
	           concat!("Size of: ", stringify!(T_UINT32_WRITE))
	);
	assert_eq!(
	           ::core::mem::align_of::<T_UINT32_WRITE>(),
	           1usize,
	           concat!("Alignment of ", stringify!(T_UINT32_WRITE))
	);
	fn test_field_v() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<T_UINT32_WRITE>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).v) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(T_UINT32_WRITE), "::", stringify!(v))
		);
	}
	test_field_v();
}
#[repr(C, packed)]
pub struct T_UINT32_READ {
	pub v: u32,
}
#[test]
fn bindgen_test_layout_T_UINT32_READ() {
	assert_eq!(
	           ::core::mem::size_of::<T_UINT32_READ>(),
	           4usize,
	           concat!("Size of: ", stringify!(T_UINT32_READ))
	);
	assert_eq!(
	           ::core::mem::align_of::<T_UINT32_READ>(),
	           1usize,
	           concat!("Alignment of ", stringify!(T_UINT32_READ))
	);
	fn test_field_v() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<T_UINT32_READ>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).v) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(T_UINT32_READ), "::", stringify!(v))
		);
	}
	test_field_v();
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum FuriWait {
	FuriWaitForever = 4294967295,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum FuriFlag {
	#[doc = "< Wait for any flag (default)."]
	FuriFlagWaitAny = 0,
	#[doc = "< Wait for all flags."]
	FuriFlagWaitAll = 1,
	#[doc = "< Do not clear flags which have been specified to wait for."]
	FuriFlagNoClear = 2,
	#[doc = "< Error indicator."]
	FuriFlagError = 2147483648,
	#[doc = "< FuriStatusError (-1)."]
	FuriFlagErrorUnknown = 4294967295,
	#[doc = "< FuriStatusErrorTimeout (-2)."]
	FuriFlagErrorTimeout = 4294967294,
	#[doc = "< FuriStatusErrorResource (-3)."]
	FuriFlagErrorResource = 4294967293,
	#[doc = "< FuriStatusErrorParameter (-4)."]
	FuriFlagErrorParameter = 4294967292,
	#[doc = "< FuriStatusErrorISR (-6)."]
	FuriFlagErrorISR = 4294967290,
}
#[repr(i32)]
#[non_exhaustive]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum FuriStatus {
	#[doc = "< Operation completed successfully."]
	FuriStatusOk = 0,
	FuriStatusError = -1,
	#[doc = "< Operation not completed within the timeout period."]
	FuriStatusErrorTimeout = -2,
	#[doc = "< Resource not available."]
	FuriStatusErrorResource = -3,
	#[doc = "< Parameter error."]
	FuriStatusErrorParameter = -4,
	FuriStatusErrorNoMemory = -5,
	FuriStatusErrorISR = -6,
	#[doc = "< Prevents enum down-size compiler optimization."]
	FuriStatusReserved = 2147483647,
}
pub type FuriEventFlag = core::ffi::c_void;
extern "C" {
	#[doc = " Allocate FuriEventFlag"]
	#[doc = ""]
	#[doc = " @return     pointer to FuriEventFlag"]
	pub fn furi_event_flag_alloc() -> *mut FuriEventFlag;
}
extern "C" {
	#[doc = " Deallocate FuriEventFlag"]
	#[doc = ""]
	#[doc = " @param      instance  pointer to FuriEventFlag"]
	pub fn furi_event_flag_free(instance: *mut FuriEventFlag);
}
extern "C" {
	#[doc = " Set flags"]
	#[doc = ""]
	#[doc = " @param      instance  pointer to FuriEventFlag"]
	#[doc = " @param[in]  flags     The flags"]
	#[doc = ""]
	#[doc = " @return     Resulting flags or error (FuriStatus)"]
	pub fn furi_event_flag_set(instance: *mut FuriEventFlag, flags: u32) -> u32;
}
extern "C" {
	#[doc = " Clear flags"]
	#[doc = ""]
	#[doc = " @param      instance  pointer to FuriEventFlag"]
	#[doc = " @param[in]  flags     The flags"]
	#[doc = ""]
	#[doc = " @return     Resulting flags or error (FuriStatus)"]
	pub fn furi_event_flag_clear(instance: *mut FuriEventFlag, flags: u32) -> u32;
}
extern "C" {
	#[doc = " Get flags"]
	#[doc = ""]
	#[doc = " @param      instance  pointer to FuriEventFlag"]
	#[doc = ""]
	#[doc = " @return     Resulting flags"]
	pub fn furi_event_flag_get(instance: *mut FuriEventFlag) -> u32;
}
extern "C" {
	#[doc = " Wait flags"]
	#[doc = ""]
	#[doc = " @param      instance  pointer to FuriEventFlag"]
	#[doc = " @param[in]  flags     The flags"]
	#[doc = " @param[in]  options   The option flags"]
	#[doc = " @param[in]  timeout   The timeout"]
	#[doc = ""]
	#[doc = " @return     Resulting flags or error (FuriStatus)"]
	pub fn furi_event_flag_wait(instance: *mut FuriEventFlag, flags: u32, options: u32, timeout: u32) -> u32;
}
extern "C" {
	#[doc = " Lock kernel, pause process scheduling"]
	#[doc = ""]
	#[doc = " @return     previous lock state(0 - unlocked, 1 - locked)"]
	pub fn furi_kernel_lock() -> i32;
}
extern "C" {
	#[doc = " Unlock kernel, resume process scheduling"]
	#[doc = ""]
	#[doc = " @return     previous lock state(0 - unlocked, 1 - locked)"]
	pub fn furi_kernel_unlock() -> i32;
}
extern "C" {
	#[doc = " Restore kernel lock state"]
	#[doc = ""]
	#[doc = " @param[in]  lock  The lock state"]
	#[doc = ""]
	#[doc = " @return     new lock state or error"]
	pub fn furi_kernel_restore_lock(lock: i32) -> i32;
}
extern "C" {
	#[doc = " Get kernel systick frequency"]
	#[doc = ""]
	#[doc = " @return     systick counts per second"]
	pub fn furi_kernel_get_tick_frequency() -> u32;
}
extern "C" {
	#[doc = " Delay execution"]
	#[doc = ""]
	#[doc = " Also keep in mind delay is aliased to scheduler timer intervals."]
	#[doc = ""]
	#[doc = " @param[in]  ticks  The ticks count to pause"]
	pub fn furi_delay_tick(ticks: u32);
}
extern "C" {
	#[doc = " Delay until tick"]
	#[doc = ""]
	#[doc = " @param[in]  ticks  The tick until which kerel should delay task execution"]
	#[doc = ""]
	#[doc = " @return     The furi status."]
	pub fn furi_delay_until_tick(tick: u32) -> FuriStatus;
}
extern "C" {
	#[doc = " Get current tick counter"]
	#[doc = ""]
	#[doc = " System uptime, may overflow."]
	#[doc = ""]
	#[doc = " @return     Current ticks in milliseconds"]
	pub fn furi_get_tick() -> u32;
}
extern "C" {
	#[doc = " Convert milliseconds to ticks"]
	#[doc = ""]
	#[doc = " @param[in]   milliseconds    time in milliseconds"]
	#[doc = " @return      time in ticks"]
	pub fn furi_ms_to_ticks(milliseconds: u32) -> u32;
}
extern "C" {
	#[doc = " Delay in milliseconds"]
	#[doc = ""]
	#[doc = " This method uses kernel ticks on the inside, which causes delay to be aliased to scheduler timer intervals."]
	#[doc = " Real wait time will be between X+ milliseconds."]
	#[doc = " Special value: 0, will cause task yield."]
	#[doc = " Also if used when kernel is not running will fall back to `furi_delay_us`."]
	#[doc = ""]
	#[doc = " @warning    Cannot be used from ISR"]
	#[doc = ""]
	#[doc = " @param[in]  milliseconds  milliseconds to wait"]
	pub fn furi_delay_ms(milliseconds: u32);
}
extern "C" {
	#[doc = " Delay in microseconds"]
	#[doc = ""]
	#[doc = " Implemented using Cortex DWT counter. Blocking and non aliased."]
	#[doc = ""]
	#[doc = " @param[in]  microseconds  microseconds to wait"]
	pub fn furi_delay_us(microseconds: u32);
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum FuriLogLevel {
	FuriLogLevelDefault = 0,
	FuriLogLevelNone = 1,
	FuriLogLevelError = 2,
	FuriLogLevelWarn = 3,
	FuriLogLevelInfo = 4,
	FuriLogLevelDebug = 5,
	FuriLogLevelTrace = 6,
}
pub type FuriLogPuts = ::core::option::Option<unsafe extern "C" fn(data: *const core::ffi::c_char)>;
pub type FuriLogTimestamp = ::core::option::Option<unsafe extern "C" fn() -> u32>;
extern "C" {
	#[doc = " Initialize logging"]
	pub fn furi_log_init();
}
extern "C" {
	#[doc = " Print log record"]
	#[doc = ""]
	#[doc = " @param level"]
	#[doc = " @param tag"]
	#[doc = " @param format"]
	#[doc = " @param ..."]
	pub fn furi_log_print_format(level: FuriLogLevel, tag: *const core::ffi::c_char, format: *const core::ffi::c_char, ...);
}
extern "C" {
	#[doc = " Set log level"]
	#[doc = ""]
	#[doc = " @param[in]  level  The level"]
	pub fn furi_log_set_level(level: FuriLogLevel);
}
extern "C" {
	#[doc = " Get log level"]
	#[doc = ""]
	#[doc = " @return     The furi log level."]
	pub fn furi_log_get_level() -> FuriLogLevel;
}
extern "C" {
	#[doc = " Set log output callback"]
	#[doc = ""]
	#[doc = " @param[in]  puts  The puts callback"]
	pub fn furi_log_set_puts(puts: FuriLogPuts);
}
extern "C" {
	#[doc = " Set timestamp callback"]
	#[doc = ""]
	#[doc = " @param[in]  timestamp  The timestamp callback"]
	pub fn furi_log_set_timestamp(timestamp: FuriLogTimestamp);
}
extern "C" {
	#[doc = " Get free heap size"]
	#[doc = ""]
	#[doc = " @return     free heap size in bytes"]
	pub fn memmgr_get_free_heap() -> usize;
}
extern "C" {
	#[doc = " Get total heap size"]
	#[doc = ""]
	#[doc = " @return     total heap size in bytes"]
	pub fn memmgr_get_total_heap() -> usize;
}
extern "C" {
	#[doc = " Get heap watermark"]
	#[doc = ""]
	#[doc = " @return     minimum heap in bytes"]
	pub fn memmgr_get_minimum_free_heap() -> usize;
}
extern "C" {
	#[doc = " An aligned version of malloc, used when you need to get the aligned space on the heap"]
	#[doc = " Freeing the received address is performed ONLY through the aligned_free function"]
	#[doc = " @param size"]
	#[doc = " @param alignment"]
	#[doc = " @return void*"]
	pub fn aligned_malloc(size: usize, alignment: usize) -> *mut core::ffi::c_void;
}
extern "C" {
	#[doc = " Freed space obtained through the aligned_malloc function"]
	#[doc = " @param p pointer to result of aligned_malloc"]
	pub fn aligned_free(p: *mut core::ffi::c_void);
}
extern "C" {
	#[doc = " @brief Allocate memory from separate memory pool. That memory can't be freed."]
	#[doc = ""]
	#[doc = " @param size"]
	#[doc = " @return void*"]
	pub fn memmgr_alloc_from_pool(size: usize) -> *mut core::ffi::c_void;
}
extern "C" {
	#[doc = " @brief Get free memory pool size"]
	#[doc = ""]
	#[doc = " @return size_t"]
	pub fn memmgr_pool_get_free() -> usize;
}
extern "C" {
	#[doc = " @brief Get max free block size from memory pool"]
	#[doc = ""]
	#[doc = " @return size_t"]
	pub fn memmgr_pool_get_max_block() -> usize;
}
#[repr(u32)]
#[non_exhaustive]
#[doc = " FuriThreadState"]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum FuriThreadState {
	FuriThreadStateStopped = 0,
	FuriThreadStateStarting = 1,
	FuriThreadStateRunning = 2,
}
#[repr(u32)]
#[non_exhaustive]
#[doc = " FuriThreadPriority"]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum FuriThreadPriority {
	#[doc = "< Uninitialized, choose system default"]
	FuriThreadPriorityNone = 0,
	#[doc = "< Idle priority"]
	FuriThreadPriorityIdle = 1,
	#[doc = "< Lowest"]
	FuriThreadPriorityLowest = 14,
	#[doc = "< Low"]
	FuriThreadPriorityLow = 15,
	#[doc = "< Normal"]
	FuriThreadPriorityNormal = 16,
	#[doc = "< High"]
	FuriThreadPriorityHigh = 17,
	#[doc = "< Highest"]
	FuriThreadPriorityHighest = 18,
	#[doc = "< Deffered Isr (highest possible)"]
	FuriThreadPriorityIsr = 32,
}
#[repr(C)]
pub struct FuriThread {
	_unused: [u8; 0],
}
#[doc = " FuriThreadId proxy type to OS low level functions"]
pub type FuriThreadId = *mut core::ffi::c_void;
#[doc = " FuriThreadCallback Your callback to run in new thread"]
#[doc = " @warning    never use osThreadExit in FuriThread"]
pub type FuriThreadCallback = ::core::option::Option<unsafe extern "C" fn(context: *mut core::ffi::c_void) -> i32>;
#[doc = " Write to stdout callback"]
#[doc = " @param      data     pointer to data"]
#[doc = " @param      size     data size @warning your handler must consume everything"]
pub type FuriThreadStdoutWriteCallback = ::core::option::Option<unsafe extern "C" fn(data: *const core::ffi::c_char, size: usize)>;
#[doc = " FuriThread state change calback called upon thread state change"]
#[doc = " @param      state    new thread state"]
#[doc = " @param      context  callback context"]
pub type FuriThreadStateCallback =
	::core::option::Option<unsafe extern "C" fn(state: FuriThreadState, context: *mut core::ffi::c_void)>;
extern "C" {
	#[doc = " Allocate FuriThread"]
	#[doc = ""]
	#[doc = " @return     FuriThread instance"]
	pub fn furi_thread_alloc() -> *mut FuriThread;
}
extern "C" {
	#[doc = " Release FuriThread"]
	#[doc = ""]
	#[doc = " @param      thread  FuriThread instance"]
	pub fn furi_thread_free(thread: *mut FuriThread);
}
extern "C" {
	#[doc = " Set FuriThread name"]
	#[doc = ""]
	#[doc = " @param      thread  FuriThread instance"]
	#[doc = " @param      name    string"]
	pub fn furi_thread_set_name(thread: *mut FuriThread, name: *const core::ffi::c_char);
}
extern "C" {
	#[doc = " Mark thread as service"]
	#[doc = " The service cannot be stopped or removed, and cannot exit from the thread body"]
	#[doc = ""]
	#[doc = " @param thread"]
	pub fn furi_thread_mark_as_service(thread: *mut FuriThread);
}
extern "C" {
	#[doc = " Set FuriThread stack size"]
	#[doc = ""]
	#[doc = " @param      thread      FuriThread instance"]
	#[doc = " @param      stack_size  stack size in bytes"]
	pub fn furi_thread_set_stack_size(thread: *mut FuriThread, stack_size: usize);
}
extern "C" {
	#[doc = " Set FuriThread callback"]
	#[doc = ""]
	#[doc = " @param      thread    FuriThread instance"]
	#[doc = " @param      callback  FuriThreadCallback, called upon thread run"]
	pub fn furi_thread_set_callback(thread: *mut FuriThread, callback: FuriThreadCallback);
}
extern "C" {
	#[doc = " Set FuriThread context"]
	#[doc = ""]
	#[doc = " @param      thread   FuriThread instance"]
	#[doc = " @param      context  pointer to context for thread callback"]
	pub fn furi_thread_set_context(thread: *mut FuriThread, context: *mut core::ffi::c_void);
}
extern "C" {
	#[doc = " Set FuriThread priority"]
	#[doc = ""]
	#[doc = " @param      thread   FuriThread instance"]
	#[doc = " @param      priority FuriThreadPriority value"]
	pub fn furi_thread_set_priority(thread: *mut FuriThread, priority: FuriThreadPriority);
}
extern "C" {
	#[doc = " Set FuriThread state change callback"]
	#[doc = ""]
	#[doc = " @param      thread    FuriThread instance"]
	#[doc = " @param      callback  state change callback"]
	pub fn furi_thread_set_state_callback(thread: *mut FuriThread, callback: FuriThreadStateCallback);
}
extern "C" {
	#[doc = " Set FuriThread state change context"]
	#[doc = ""]
	#[doc = " @param      thread   FuriThread instance"]
	#[doc = " @param      context  pointer to context"]
	pub fn furi_thread_set_state_context(thread: *mut FuriThread, context: *mut core::ffi::c_void);
}
extern "C" {
	#[doc = " Get FuriThread state"]
	#[doc = ""]
	#[doc = " @param      thread  FuriThread instance"]
	#[doc = ""]
	#[doc = " @return     thread state from FuriThreadState"]
	pub fn furi_thread_get_state(thread: *mut FuriThread) -> FuriThreadState;
}
extern "C" {
	#[doc = " Start FuriThread"]
	#[doc = ""]
	#[doc = " @param      thread  FuriThread instance"]
	pub fn furi_thread_start(thread: *mut FuriThread);
}
extern "C" {
	#[doc = " Join FuriThread"]
	#[doc = ""]
	#[doc = " @param      thread  FuriThread instance"]
	#[doc = ""]
	#[doc = " @return     bool"]
	pub fn furi_thread_join(thread: *mut FuriThread) -> bool;
}
extern "C" {
	#[doc = " Get FreeRTOS FuriThreadId for FuriThread instance"]
	#[doc = ""]
	#[doc = " @param      thread  FuriThread instance"]
	#[doc = ""]
	#[doc = " @return     FuriThreadId or NULL"]
	pub fn furi_thread_get_id(thread: *mut FuriThread) -> FuriThreadId;
}
extern "C" {
	#[doc = " Enable heap tracing"]
	#[doc = ""]
	#[doc = " @param      thread  FuriThread instance"]
	pub fn furi_thread_enable_heap_trace(thread: *mut FuriThread);
}
extern "C" {
	#[doc = " Disable heap tracing"]
	#[doc = ""]
	#[doc = " @param      thread  FuriThread instance"]
	pub fn furi_thread_disable_heap_trace(thread: *mut FuriThread);
}
extern "C" {
	#[doc = " Get thread heap size"]
	#[doc = ""]
	#[doc = " @param      thread  FuriThread instance"]
	#[doc = ""]
	#[doc = " @return     size in bytes"]
	pub fn furi_thread_get_heap_size(thread: *mut FuriThread) -> usize;
}
extern "C" {
	#[doc = " Get thread return code"]
	#[doc = ""]
	#[doc = " @param      thread  FuriThread instance"]
	#[doc = ""]
	#[doc = " @return     return code"]
	pub fn furi_thread_get_return_code(thread: *mut FuriThread) -> i32;
}
extern "C" {
	#[doc = " Get FreeRTOS FuriThreadId for current thread"]
	#[doc = ""]
	#[doc = " @param      thread  FuriThread instance"]
	#[doc = ""]
	#[doc = " @return     FuriThreadId or NULL"]
	pub fn furi_thread_get_current_id() -> FuriThreadId;
}
extern "C" {
	#[doc = " Get FuriThread instance for current thread"]
	#[doc = ""]
	#[doc = " @return FuriThread*"]
	pub fn furi_thread_get_current() -> *mut FuriThread;
}
extern "C" {
	#[doc = " Return control to scheduler"]
	pub fn furi_thread_yield();
}
extern "C" {
	pub fn furi_thread_flags_set(thread_id: FuriThreadId, flags: u32) -> u32;
}
extern "C" {
	pub fn furi_thread_flags_clear(flags: u32) -> u32;
}
extern "C" {
	pub fn furi_thread_flags_get() -> u32;
}
extern "C" {
	pub fn furi_thread_flags_wait(flags: u32, options: u32, timeout: u32) -> u32;
}
extern "C" {
	pub fn furi_thread_enumerate(thread_array: *mut FuriThreadId, array_items: u32) -> u32;
}
extern "C" {
	pub fn furi_thread_get_name(thread_id: FuriThreadId) -> *const core::ffi::c_char;
}
extern "C" {
	pub fn furi_thread_get_stack_space(thread_id: FuriThreadId) -> u32;
}
extern "C" {
	#[doc = " Set STDOUT callback for thread"]
	#[doc = ""]
	#[doc = " @param      callback  callback or NULL to clear"]
	#[doc = ""]
	#[doc = " @return     true on success, otherwise fail"]
	pub fn furi_thread_set_stdout_callback(callback: FuriThreadStdoutWriteCallback) -> bool;
}
extern "C" {
	#[doc = " Write data to buffered STDOUT"]
	#[doc = ""]
	#[doc = " @param data input data"]
	#[doc = " @param size input data size"]
	#[doc = ""]
	#[doc = " @return size_t written data size"]
	pub fn furi_thread_stdout_write(data: *const core::ffi::c_char, size: usize) -> usize;
}
extern "C" {
	#[doc = " Flush data to STDOUT"]
	#[doc = ""]
	#[doc = " @return int32_t error code"]
	pub fn furi_thread_stdout_flush() -> i32;
}
extern "C" {
	#[doc = " Suspend thread"]
	#[doc = ""]
	#[doc = " @param thread_id thread id"]
	pub fn furi_thread_suspend(thread_id: FuriThreadId);
}
extern "C" {
	#[doc = " Resume thread"]
	#[doc = ""]
	#[doc = " @param thread_id thread id"]
	pub fn furi_thread_resume(thread_id: FuriThreadId);
}
extern "C" {
	#[doc = " Get thread suspended state"]
	#[doc = ""]
	#[doc = " @param thread_id thread id"]
	#[doc = " @return true if thread is suspended"]
	pub fn furi_thread_is_suspended(thread_id: FuriThreadId) -> bool;
}
extern "C" {
	#[doc = " Memmgr heap enable thread allocation tracking"]
	#[doc = ""]
	#[doc = " @param      thread_id  - thread id to track"]
	pub fn memmgr_heap_enable_thread_trace(taks_handle: FuriThreadId);
}
extern "C" {
	#[doc = " Memmgr heap disable thread allocation tracking"]
	#[doc = ""]
	#[doc = " @param      thread_id  - thread id to track"]
	pub fn memmgr_heap_disable_thread_trace(taks_handle: FuriThreadId);
}
extern "C" {
	#[doc = " Memmgr heap get allocatred thread memory"]
	#[doc = ""]
	#[doc = " @param      thread_id  - thread id to track"]
	#[doc = ""]
	#[doc = " @return     bytes allocated right now"]
	pub fn memmgr_heap_get_thread_memory(taks_handle: FuriThreadId) -> usize;
}
extern "C" {
	#[doc = " Memmgr heap get the max contiguous block size on the heap"]
	#[doc = ""]
	#[doc = " @return     size_t max contiguous block size"]
	pub fn memmgr_heap_get_max_free_block() -> usize;
}
extern "C" {
	#[doc = " Print the address and size of all free blocks to stdout"]
	pub fn memmgr_heap_printf_free_blocks();
}
pub type FuriMessageQueue = core::ffi::c_void;
extern "C" {
	#[doc = " Allocate furi message queue"]
	#[doc = ""]
	#[doc = " @param[in]  msg_count  The message count"]
	#[doc = " @param[in]  msg_size   The message size"]
	#[doc = ""]
	#[doc = " @return     pointer to FuriMessageQueue instance"]
	pub fn furi_message_queue_alloc(msg_count: u32, msg_size: u32) -> *mut FuriMessageQueue;
}
extern "C" {
	#[doc = " Free queue"]
	#[doc = ""]
	#[doc = " @param      instance  pointer to FuriMessageQueue instance"]
	pub fn furi_message_queue_free(instance: *mut FuriMessageQueue);
}
extern "C" {
	#[doc = " Put message into queue"]
	#[doc = ""]
	#[doc = " @param      instance  pointer to FuriMessageQueue instance"]
	#[doc = " @param[in]  msg_ptr   The message pointer"]
	#[doc = " @param[in]  timeout   The timeout"]
	#[doc = " @param[in]  msg_prio  The message prio"]
	#[doc = ""]
	#[doc = " @return     The furi status."]
	pub fn furi_message_queue_put(instance: *mut FuriMessageQueue, msg_ptr: *const core::ffi::c_void, timeout: u32) -> FuriStatus;
}
extern "C" {
	#[doc = " Get message from queue"]
	#[doc = ""]
	#[doc = " @param      instance  pointer to FuriMessageQueue instance"]
	#[doc = " @param      msg_ptr   The message pointer"]
	#[doc = " @param      msg_prio  The message prioority"]
	#[doc = " @param[in]  timeout   The timeout"]
	#[doc = ""]
	#[doc = " @return     The furi status."]
	pub fn furi_message_queue_get(instance: *mut FuriMessageQueue, msg_ptr: *mut core::ffi::c_void, timeout: u32) -> FuriStatus;
}
extern "C" {
	#[doc = " Get queue capacity"]
	#[doc = ""]
	#[doc = " @param      instance  pointer to FuriMessageQueue instance"]
	#[doc = ""]
	#[doc = " @return     capacity in object count"]
	pub fn furi_message_queue_get_capacity(instance: *mut FuriMessageQueue) -> u32;
}
extern "C" {
	#[doc = " Get message size"]
	#[doc = ""]
	#[doc = " @param      instance  pointer to FuriMessageQueue instance"]
	#[doc = ""]
	#[doc = " @return     Message size in bytes"]
	pub fn furi_message_queue_get_message_size(instance: *mut FuriMessageQueue) -> u32;
}
extern "C" {
	#[doc = " Get message count in queue"]
	#[doc = ""]
	#[doc = " @param      instance  pointer to FuriMessageQueue instance"]
	#[doc = ""]
	#[doc = " @return     Message count"]
	pub fn furi_message_queue_get_count(instance: *mut FuriMessageQueue) -> u32;
}
extern "C" {
	#[doc = " Get queue available space"]
	#[doc = ""]
	#[doc = " @param      instance  pointer to FuriMessageQueue instance"]
	#[doc = ""]
	#[doc = " @return     Message count"]
	pub fn furi_message_queue_get_space(instance: *mut FuriMessageQueue) -> u32;
}
extern "C" {
	#[doc = " Reset queue"]
	#[doc = ""]
	#[doc = " @param      instance  pointer to FuriMessageQueue instance"]
	#[doc = ""]
	#[doc = " @return     The furi status."]
	pub fn furi_message_queue_reset(instance: *mut FuriMessageQueue) -> FuriStatus;
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum FuriMutexType {
	FuriMutexTypeNormal = 0,
	FuriMutexTypeRecursive = 1,
}
pub type FuriMutex = core::ffi::c_void;
extern "C" {
	#[doc = " Allocate FuriMutex"]
	#[doc = ""]
	#[doc = " @param[in]  type  The mutex type"]
	#[doc = ""]
	#[doc = " @return     pointer to FuriMutex instance"]
	pub fn furi_mutex_alloc(type_: FuriMutexType) -> *mut FuriMutex;
}
extern "C" {
	#[doc = " Free FuriMutex"]
	#[doc = ""]
	#[doc = " @param      instance  The pointer to FuriMutex instance"]
	pub fn furi_mutex_free(instance: *mut FuriMutex);
}
extern "C" {
	#[doc = " Acquire mutex"]
	#[doc = ""]
	#[doc = " @param      instance  The pointer to FuriMutex instance"]
	#[doc = " @param[in]  timeout   The timeout"]
	#[doc = ""]
	#[doc = " @return     The furi status."]
	pub fn furi_mutex_acquire(instance: *mut FuriMutex, timeout: u32) -> FuriStatus;
}
extern "C" {
	#[doc = " Release mutex"]
	#[doc = ""]
	#[doc = " @param      instance  The pointer to FuriMutex instance"]
	#[doc = ""]
	#[doc = " @return     The furi status."]
	pub fn furi_mutex_release(instance: *mut FuriMutex) -> FuriStatus;
}
extern "C" {
	#[doc = " Get mutex owner thread id"]
	#[doc = ""]
	#[doc = " @param      instance  The pointer to FuriMutex instance"]
	#[doc = ""]
	#[doc = " @return     The furi thread identifier."]
	pub fn furi_mutex_get_owner(instance: *mut FuriMutex) -> FuriThreadId;
}
#[doc = " FuriPubSub Callback type"]
pub type FuriPubSubCallback =
	::core::option::Option<unsafe extern "C" fn(message: *const core::ffi::c_void, context: *mut core::ffi::c_void)>;
#[repr(C)]
pub struct FuriPubSub {
	_unused: [u8; 0],
}
#[repr(C)]
pub struct FuriPubSubSubscription {
	_unused: [u8; 0],
}
extern "C" {
	#[doc = " Allocate FuriPubSub"]
	#[doc = ""]
	#[doc = " Reentrable, Not threadsafe, one owner"]
	#[doc = ""]
	#[doc = " @return     pointer to FuriPubSub instance"]
	pub fn furi_pubsub_alloc() -> *mut FuriPubSub;
}
extern "C" {
	#[doc = " Free FuriPubSub"]
	#[doc = ""]
	#[doc = " @param      pubsub  FuriPubSub instance"]
	pub fn furi_pubsub_free(pubsub: *mut FuriPubSub);
}
extern "C" {
	#[doc = " Subscribe to FuriPubSub"]
	#[doc = ""]
	#[doc = " Threadsafe, Reentrable"]
	#[doc = ""]
	#[doc = " @param      pubsub            pointer to FuriPubSub instance"]
	#[doc = " @param[in]  callback          The callback"]
	#[doc = " @param      callback_context  The callback context"]
	#[doc = ""]
	#[doc = " @return     pointer to FuriPubSubSubscription instance"]
	pub fn furi_pubsub_subscribe(pubsub: *mut FuriPubSub,
	                             callback: FuriPubSubCallback,
	                             callback_context: *mut core::ffi::c_void)
	                             -> *mut FuriPubSubSubscription;
}
extern "C" {
	#[doc = " Unsubscribe from FuriPubSub"]
	#[doc = ""]
	#[doc = " No use of `pubsub_subscription` allowed after call of this method"]
	#[doc = " Threadsafe, Reentrable."]
	#[doc = ""]
	#[doc = " @param      pubsub               pointer to FuriPubSub instance"]
	#[doc = " @param      pubsub_subscription  pointer to FuriPubSubSubscription instance"]
	pub fn furi_pubsub_unsubscribe(pubsub: *mut FuriPubSub, pubsub_subscription: *mut FuriPubSubSubscription);
}
extern "C" {
	#[doc = " Publish message to FuriPubSub"]
	#[doc = ""]
	#[doc = " Threadsafe, Reentrable."]
	#[doc = ""]
	#[doc = " @param      pubsub   pointer to FuriPubSub instance"]
	#[doc = " @param      message  message pointer to publish"]
	pub fn furi_pubsub_publish(pubsub: *mut FuriPubSub, message: *mut core::ffi::c_void);
}
extern "C" {
	#[doc = " Initialize record storage For internal use only."]
	pub fn furi_record_init();
}
extern "C" {
	#[doc = " Check if record exists"]
	#[doc = ""]
	#[doc = " @param      name  record name"]
	#[doc = " @note       Thread safe. Create and destroy must be executed from the same"]
	#[doc = "             thread."]
	pub fn furi_record_exists(name: *const core::ffi::c_char) -> bool;
}
extern "C" {
	#[doc = " Create record"]
	#[doc = ""]
	#[doc = " @param      name  record name"]
	#[doc = " @param      data  data pointer"]
	#[doc = " @note       Thread safe. Create and destroy must be executed from the same"]
	#[doc = "             thread."]
	pub fn furi_record_create(name: *const core::ffi::c_char, data: *mut core::ffi::c_void);
}
extern "C" {
	#[doc = " Destroy record"]
	#[doc = ""]
	#[doc = " @param      name  record name"]
	#[doc = ""]
	#[doc = " @return     true if successful, false if still have holders or thread is not"]
	#[doc = "             owner."]
	#[doc = " @note       Thread safe. Create and destroy must be executed from the same"]
	#[doc = "             thread."]
	pub fn furi_record_destroy(name: *const core::ffi::c_char) -> bool;
}
extern "C" {
	#[doc = " Open record"]
	#[doc = ""]
	#[doc = " @param      name  record name"]
	#[doc = ""]
	#[doc = " @return     pointer to the record"]
	#[doc = " @note       Thread safe. Open and close must be executed from the same"]
	#[doc = "             thread. Suspends caller thread till record is available"]
	pub fn furi_record_open(name: *const core::ffi::c_char) -> *mut core::ffi::c_void;
}
extern "C" {
	#[doc = " Close record"]
	#[doc = ""]
	#[doc = " @param      name  record name"]
	#[doc = " @note       Thread safe. Open and close must be executed from the same"]
	#[doc = "             thread."]
	pub fn furi_record_close(name: *const core::ffi::c_char);
}
pub type FuriSemaphore = core::ffi::c_void;
extern "C" {
	#[doc = " Allocate semaphore"]
	#[doc = ""]
	#[doc = " @param[in]  max_count      The maximum count"]
	#[doc = " @param[in]  initial_count  The initial count"]
	#[doc = ""]
	#[doc = " @return     pointer to FuriSemaphore instance"]
	pub fn furi_semaphore_alloc(max_count: u32, initial_count: u32) -> *mut FuriSemaphore;
}
extern "C" {
	#[doc = " Free semaphore"]
	#[doc = ""]
	#[doc = " @param      instance  The pointer to FuriSemaphore instance"]
	pub fn furi_semaphore_free(instance: *mut FuriSemaphore);
}
extern "C" {
	#[doc = " Acquire semaphore"]
	#[doc = ""]
	#[doc = " @param      instance  The pointer to FuriSemaphore instance"]
	#[doc = " @param[in]  timeout   The timeout"]
	#[doc = ""]
	#[doc = " @return     The furi status."]
	pub fn furi_semaphore_acquire(instance: *mut FuriSemaphore, timeout: u32) -> FuriStatus;
}
extern "C" {
	#[doc = " Release semaphore"]
	#[doc = ""]
	#[doc = " @param      instance  The pointer to FuriSemaphore instance"]
	#[doc = ""]
	#[doc = " @return     The furi status."]
	pub fn furi_semaphore_release(instance: *mut FuriSemaphore) -> FuriStatus;
}
extern "C" {
	#[doc = " Get semaphore count"]
	#[doc = ""]
	#[doc = " @param      instance  The pointer to FuriSemaphore instance"]
	#[doc = ""]
	#[doc = " @return     Semaphore count"]
	pub fn furi_semaphore_get_count(instance: *mut FuriSemaphore) -> u32;
}
pub type FuriTimerCallback = ::core::option::Option<unsafe extern "C" fn(context: *mut core::ffi::c_void)>;
#[repr(u32)]
#[non_exhaustive]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum FuriTimerType {
	#[doc = "< One-shot timer."]
	FuriTimerTypeOnce = 0,
	#[doc = "< Repeating timer."]
	FuriTimerTypePeriodic = 1,
}
pub type FuriTimer = core::ffi::c_void;
extern "C" {
	#[doc = " Allocate timer"]
	#[doc = ""]
	#[doc = " @param[in]  func     The callback function"]
	#[doc = " @param[in]  type     The timer type"]
	#[doc = " @param      context  The callback context"]
	#[doc = ""]
	#[doc = " @return     The pointer to FuriTimer instance"]
	pub fn furi_timer_alloc(func: FuriTimerCallback, type_: FuriTimerType, context: *mut core::ffi::c_void) -> *mut FuriTimer;
}
extern "C" {
	#[doc = " Free timer"]
	#[doc = ""]
	#[doc = " @param      instance  The pointer to FuriTimer instance"]
	pub fn furi_timer_free(instance: *mut FuriTimer);
}
extern "C" {
	#[doc = " Start timer"]
	#[doc = ""]
	#[doc = " @param      instance  The pointer to FuriTimer instance"]
	#[doc = " @param[in]  ticks     The ticks"]
	#[doc = ""]
	#[doc = " @return     The furi status."]
	pub fn furi_timer_start(instance: *mut FuriTimer, ticks: u32) -> FuriStatus;
}
extern "C" {
	#[doc = " Stop timer"]
	#[doc = ""]
	#[doc = " @param      instance  The pointer to FuriTimer instance"]
	#[doc = ""]
	#[doc = " @return     The furi status."]
	pub fn furi_timer_stop(instance: *mut FuriTimer) -> FuriStatus;
}
extern "C" {
	#[doc = " Is timer running"]
	#[doc = ""]
	#[doc = " @param      instance  The pointer to FuriTimer instance"]
	#[doc = ""]
	#[doc = " @return     0: not running, 1: running"]
	pub fn furi_timer_is_running(instance: *mut FuriTimer) -> u32;
}
#[doc = " == ValueMutex =="]
#[doc = ""]
#[doc = " The most simple concept is ValueMutex."]
#[doc = " It is wrapper around mutex and value pointer."]
#[doc = " You can take and give mutex to work with value and read and write value."]
#[repr(C)]
pub struct ValueMutex {
	pub value: *mut core::ffi::c_void,
	pub size: usize,
	pub mutex: *mut FuriMutex,
}
#[test]
fn bindgen_test_layout_ValueMutex() {
	assert_eq!(
	           ::core::mem::size_of::<ValueMutex>(),
	           12usize,
	           concat!("Size of: ", stringify!(ValueMutex))
	);
	assert_eq!(
	           ::core::mem::align_of::<ValueMutex>(),
	           4usize,
	           concat!("Alignment of ", stringify!(ValueMutex))
	);
	fn test_field_value() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<ValueMutex>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).value) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(ValueMutex), "::", stringify!(value))
		);
	}
	test_field_value();
	fn test_field_size() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<ValueMutex>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).size) as usize - ptr as usize
		           },
		           4usize,
		           concat!("Offset of field: ", stringify!(ValueMutex), "::", stringify!(size))
		);
	}
	test_field_size();
	fn test_field_mutex() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<ValueMutex>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).mutex) as usize - ptr as usize
		           },
		           8usize,
		           concat!("Offset of field: ", stringify!(ValueMutex), "::", stringify!(mutex))
		);
	}
	test_field_mutex();
}
extern "C" {
	#[doc = " Creates ValueMutex."]
	pub fn init_mutex(valuemutex: *mut ValueMutex, value: *mut core::ffi::c_void, size: usize) -> bool;
}
extern "C" {
	#[doc = " Free resources allocated by `init_mutex`."]
	#[doc = " This function doesn't free the memory occupied by `ValueMutex` itself."]
	pub fn delete_mutex(valuemutex: *mut ValueMutex) -> bool;
}
extern "C" {
	#[doc = " Call for work with data stored in mutex."]
	#[doc = " @return pointer to data if success, NULL otherwise."]
	pub fn acquire_mutex(valuemutex: *mut ValueMutex, timeout: u32) -> *mut core::ffi::c_void;
}
extern "C" {
	#[doc = " Release mutex after end of work with data."]
	#[doc = " Call `release_mutex` and pass ValueData instance and pointer to data."]
	pub fn release_mutex(valuemutex: *mut ValueMutex, value: *const core::ffi::c_void) -> bool;
}
extern "C" {
	#[doc = " Instead of take-access-give sequence you can use `read_mutex` and `write_mutex` functions."]
	#[doc = " Both functions return true in case of success, false otherwise."]
	pub fn read_mutex(valuemutex: *mut ValueMutex, data: *mut core::ffi::c_void, len: usize, timeout: u32) -> bool;
}
extern "C" {
	pub fn write_mutex(valuemutex: *mut ValueMutex, data: *mut core::ffi::c_void, len: usize, timeout: u32) -> bool;
}
#[repr(i32)]
#[non_exhaustive]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum IRQn_Type {
	#[doc = "< Non Maskable Interrupt"]
	NonMaskableInt_IRQn = -14,
	#[doc = "< Cortex-M4 Hard Fault Interrupt"]
	HardFault_IRQn = -13,
	#[doc = "< Cortex-M4 Memory Management Interrupt"]
	MemoryManagement_IRQn = -12,
	#[doc = "< Cortex-M4 Bus Fault Interrupt"]
	BusFault_IRQn = -11,
	#[doc = "< Cortex-M4 Usage Fault Interrupt"]
	UsageFault_IRQn = -10,
	#[doc = "< Cortex-M4 SV Call Interrupt"]
	SVCall_IRQn = -5,
	#[doc = "< Cortex-M4 Debug Monitor Interrupt"]
	DebugMonitor_IRQn = -4,
	#[doc = "< Cortex-M4 Pend SV Interrupt"]
	PendSV_IRQn = -2,
	#[doc = "< Cortex-M4 System Tick Interrupt"]
	SysTick_IRQn = -1,
	#[doc = "< Window WatchDog Interrupt"]
	WWDG_IRQn = 0,
	#[doc = "< PVD and PVM detector"]
	PVD_PVM_IRQn = 1,
	#[doc = "< RTC Tamper and TimeStamp Interrupts and LSECSS Interrupts"]
	TAMP_STAMP_LSECSS_IRQn = 2,
	#[doc = "< RTC Wakeup Interrupt"]
	RTC_WKUP_IRQn = 3,
	#[doc = "< FLASH (CFI)  global Interrupt"]
	FLASH_IRQn = 4,
	#[doc = "< RCC Interrupt"]
	RCC_IRQn = 5,
	#[doc = "< EXTI Line 0 Interrupt"]
	EXTI0_IRQn = 6,
	#[doc = "< EXTI Line 1 Interrupt"]
	EXTI1_IRQn = 7,
	#[doc = "< EXTI Line 2 Interrupt"]
	EXTI2_IRQn = 8,
	#[doc = "< EXTI Line 3 Interrupt"]
	EXTI3_IRQn = 9,
	#[doc = "< EXTI Line 4 Interrupt"]
	EXTI4_IRQn = 10,
	#[doc = "< DMA1 Channel 1 Interrupt"]
	DMA1_Channel1_IRQn = 11,
	#[doc = "< DMA1 Channel 2 Interrupt"]
	DMA1_Channel2_IRQn = 12,
	#[doc = "< DMA1 Channel 3 Interrupt"]
	DMA1_Channel3_IRQn = 13,
	#[doc = "< DMA1 Channel 4 Interrupt"]
	DMA1_Channel4_IRQn = 14,
	#[doc = "< DMA1 Channel 5 Interrupt"]
	DMA1_Channel5_IRQn = 15,
	#[doc = "< DMA1 Channel 6 Interrupt"]
	DMA1_Channel6_IRQn = 16,
	#[doc = "< DMA1 Channel 7 Interrupt"]
	DMA1_Channel7_IRQn = 17,
	#[doc = "< ADC1 Interrupt"]
	ADC1_IRQn = 18,
	#[doc = "< USB High Priority Interrupt"]
	USB_HP_IRQn = 19,
	#[doc = "< USB Low Priority Interrupt (including USB wakeup)"]
	USB_LP_IRQn = 20,
	#[doc = "< CPU2 SEV Interrupt"]
	C2SEV_PWR_C2H_IRQn = 21,
	#[doc = "< COMP1 and COMP2 Interrupts"]
	COMP_IRQn = 22,
	#[doc = "< EXTI Lines [9:5] Interrupt"]
	EXTI9_5_IRQn = 23,
	#[doc = "< TIM1 Break Interrupt"]
	TIM1_BRK_IRQn = 24,
	#[doc = "< TIM1 Update and TIM16 global Interrupts"]
	TIM1_UP_TIM16_IRQn = 25,
	#[doc = "< TIM1 Trigger and Communication and TIM17 global Interrupts"]
	TIM1_TRG_COM_TIM17_IRQn = 26,
	#[doc = "< TIM1 Capture Compare Interrupt"]
	TIM1_CC_IRQn = 27,
	#[doc = "< TIM2 Global Interrupt"]
	TIM2_IRQn = 28,
	#[doc = "< PKA Interrupt"]
	PKA_IRQn = 29,
	#[doc = "< I2C1 Event Interrupt"]
	I2C1_EV_IRQn = 30,
	#[doc = "< I2C1 Error Interrupt"]
	I2C1_ER_IRQn = 31,
	#[doc = "< I2C3 Event Interrupt"]
	I2C3_EV_IRQn = 32,
	#[doc = "< I2C3 Error Interrupt"]
	I2C3_ER_IRQn = 33,
	#[doc = "< SPI1 Interrupt"]
	SPI1_IRQn = 34,
	#[doc = "< SPI2 Interrupt"]
	SPI2_IRQn = 35,
	#[doc = "< USART1 Interrupt"]
	USART1_IRQn = 36,
	#[doc = "< LPUART1 Interrupt"]
	LPUART1_IRQn = 37,
	#[doc = "< SAI1 A and B global interrupt"]
	SAI1_IRQn = 38,
	#[doc = "< TSC Interrupt"]
	TSC_IRQn = 39,
	#[doc = "< EXTI Lines1[15:10 ]Interrupts"]
	EXTI15_10_IRQn = 40,
	#[doc = "< RTC Alarms (A and B) Interrupt"]
	RTC_Alarm_IRQn = 41,
	#[doc = "< CRS interrupt"]
	CRS_IRQn = 42,
	#[doc = "< PWR switching on the fly interrupt"]
	#[doc = "PWR end of BLE activity interrupt"]
	#[doc = "PWR end of 802.15.4 (Zigbee) activity interrupt"]
	#[doc = "PWR end of critical radio phase interrupt"]
	PWR_SOTF_BLEACT_802ACT_RFPHASE_IRQn = 43,
	#[doc = "< IPCC RX Occupied Interrupt"]
	IPCC_C1_RX_IRQn = 44,
	#[doc = "< IPCC TX Free Interrupt"]
	IPCC_C1_TX_IRQn = 45,
	#[doc = "< HSEM Interrupt"]
	HSEM_IRQn = 46,
	#[doc = "< LPTIM1 Interrupt"]
	LPTIM1_IRQn = 47,
	#[doc = "< LPTIM2 Interrupt"]
	LPTIM2_IRQn = 48,
	#[doc = "< LCD Interrupt"]
	LCD_IRQn = 49,
	#[doc = "< QUADSPI Interrupt"]
	QUADSPI_IRQn = 50,
	#[doc = "< AES1 Interrupt"]
	AES1_IRQn = 51,
	#[doc = "< AES2 Interrupt"]
	AES2_IRQn = 52,
	#[doc = "< RNG Interrupt"]
	RNG_IRQn = 53,
	#[doc = "< FPU Interrupt"]
	FPU_IRQn = 54,
	#[doc = "< DMA2 Channel 1 Interrupt"]
	DMA2_Channel1_IRQn = 55,
	#[doc = "< DMA2 Channel 2 Interrupt"]
	DMA2_Channel2_IRQn = 56,
	#[doc = "< DMA2 Channel 3 Interrupt"]
	DMA2_Channel3_IRQn = 57,
	#[doc = "< DMA2 Channel 4 Interrupt"]
	DMA2_Channel4_IRQn = 58,
	#[doc = "< DMA2 Channel 5 Interrupt"]
	DMA2_Channel5_IRQn = 59,
	#[doc = "< DMA2 Channel 6 Interrupt"]
	DMA2_Channel6_IRQn = 60,
	#[doc = "< DMA2 Channel 7 Interrupt"]
	DMA2_Channel7_IRQn = 61,
	#[doc = "< DMAMUX1 overrun Interrupt"]
	DMAMUX1_OVR_IRQn = 62,
}
#[repr(C)]
pub struct APSR_Type {
	pub b: __BindgenUnionField<APSR_Type__bindgen_ty_1>,
	pub w: __BindgenUnionField<u32>,
	pub bindgen_union_field: u32,
}
#[repr(C)]
#[repr(align(4))]
pub struct APSR_Type__bindgen_ty_1 {
	pub _bitfield_align_1: [u16; 0],
	pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_APSR_Type__bindgen_ty_1() {
	assert_eq!(
	           ::core::mem::size_of::<APSR_Type__bindgen_ty_1>(),
	           4usize,
	           concat!("Size of: ", stringify!(APSR_Type__bindgen_ty_1))
	);
	assert_eq!(
	           ::core::mem::align_of::<APSR_Type__bindgen_ty_1>(),
	           4usize,
	           concat!("Alignment of ", stringify!(APSR_Type__bindgen_ty_1))
	);
}
impl APSR_Type__bindgen_ty_1 {
	#[inline]
	pub fn _reserved0(&self) -> u32 { unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u32) } }
	#[inline]
	pub fn set__reserved0(&mut self, val: u32) {
		unsafe {
			let val: u32 = ::core::mem::transmute(val);
			self._bitfield_1.set(0usize, 16u8, val as u64)
		}
	}
	#[inline]
	pub fn GE(&self) -> u32 { unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 4u8) as u32) } }
	#[inline]
	pub fn set_GE(&mut self, val: u32) {
		unsafe {
			let val: u32 = ::core::mem::transmute(val);
			self._bitfield_1.set(16usize, 4u8, val as u64)
		}
	}
	#[inline]
	pub fn _reserved1(&self) -> u32 { unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 7u8) as u32) } }
	#[inline]
	pub fn set__reserved1(&mut self, val: u32) {
		unsafe {
			let val: u32 = ::core::mem::transmute(val);
			self._bitfield_1.set(20usize, 7u8, val as u64)
		}
	}
	#[inline]
	pub fn Q(&self) -> u32 { unsafe { ::core::mem::transmute(self._bitfield_1.get(27usize, 1u8) as u32) } }
	#[inline]
	pub fn set_Q(&mut self, val: u32) {
		unsafe {
			let val: u32 = ::core::mem::transmute(val);
			self._bitfield_1.set(27usize, 1u8, val as u64)
		}
	}
	#[inline]
	pub fn V(&self) -> u32 { unsafe { ::core::mem::transmute(self._bitfield_1.get(28usize, 1u8) as u32) } }
	#[inline]
	pub fn set_V(&mut self, val: u32) {
		unsafe {
			let val: u32 = ::core::mem::transmute(val);
			self._bitfield_1.set(28usize, 1u8, val as u64)
		}
	}
	#[inline]
	pub fn C(&self) -> u32 { unsafe { ::core::mem::transmute(self._bitfield_1.get(29usize, 1u8) as u32) } }
	#[inline]
	pub fn set_C(&mut self, val: u32) {
		unsafe {
			let val: u32 = ::core::mem::transmute(val);
			self._bitfield_1.set(29usize, 1u8, val as u64)
		}
	}
	#[inline]
	pub fn Z(&self) -> u32 { unsafe { ::core::mem::transmute(self._bitfield_1.get(30usize, 1u8) as u32) } }
	#[inline]
	pub fn set_Z(&mut self, val: u32) {
		unsafe {
			let val: u32 = ::core::mem::transmute(val);
			self._bitfield_1.set(30usize, 1u8, val as u64)
		}
	}
	#[inline]
	pub fn N(&self) -> u32 { unsafe { ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) } }
	#[inline]
	pub fn set_N(&mut self, val: u32) {
		unsafe {
			let val: u32 = ::core::mem::transmute(val);
			self._bitfield_1.set(31usize, 1u8, val as u64)
		}
	}
	#[inline]
	pub fn new_bitfield_1(_reserved0: u32,
	                      GE: u32,
	                      _reserved1: u32,
	                      Q: u32,
	                      V: u32,
	                      C: u32,
	                      Z: u32,
	                      N: u32)
	                      -> __BindgenBitfieldUnit<[u8; 4usize]> {
		let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
		__bindgen_bitfield_unit.set(0usize, 16u8, {
			                       let _reserved0: u32 = unsafe { ::core::mem::transmute(_reserved0) };
			                       _reserved0 as u64
		                       });
		__bindgen_bitfield_unit.set(16usize, 4u8, {
			                       let GE: u32 = unsafe { ::core::mem::transmute(GE) };
			                       GE as u64
		                       });
		__bindgen_bitfield_unit.set(20usize, 7u8, {
			                       let _reserved1: u32 = unsafe { ::core::mem::transmute(_reserved1) };
			                       _reserved1 as u64
		                       });
		__bindgen_bitfield_unit.set(27usize, 1u8, {
			                       let Q: u32 = unsafe { ::core::mem::transmute(Q) };
			                       Q as u64
		                       });
		__bindgen_bitfield_unit.set(28usize, 1u8, {
			                       let V: u32 = unsafe { ::core::mem::transmute(V) };
			                       V as u64
		                       });
		__bindgen_bitfield_unit.set(29usize, 1u8, {
			                       let C: u32 = unsafe { ::core::mem::transmute(C) };
			                       C as u64
		                       });
		__bindgen_bitfield_unit.set(30usize, 1u8, {
			                       let Z: u32 = unsafe { ::core::mem::transmute(Z) };
			                       Z as u64
		                       });
		__bindgen_bitfield_unit.set(31usize, 1u8, {
			                       let N: u32 = unsafe { ::core::mem::transmute(N) };
			                       N as u64
		                       });
		__bindgen_bitfield_unit
	}
}
#[test]
fn bindgen_test_layout_APSR_Type() {
	assert_eq!(
	           ::core::mem::size_of::<APSR_Type>(),
	           4usize,
	           concat!("Size of: ", stringify!(APSR_Type))
	);
	assert_eq!(
	           ::core::mem::align_of::<APSR_Type>(),
	           4usize,
	           concat!("Alignment of ", stringify!(APSR_Type))
	);
	fn test_field_b() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<APSR_Type>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).b) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(APSR_Type), "::", stringify!(b))
		);
	}
	test_field_b();
	fn test_field_w() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<APSR_Type>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).w) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(APSR_Type), "::", stringify!(w))
		);
	}
	test_field_w();
}
#[repr(C)]
pub struct IPSR_Type {
	pub b: __BindgenUnionField<IPSR_Type__bindgen_ty_1>,
	pub w: __BindgenUnionField<u32>,
	pub bindgen_union_field: u32,
}
#[repr(C)]
#[repr(align(4))]
pub struct IPSR_Type__bindgen_ty_1 {
	pub _bitfield_align_1: [u32; 0],
	pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_IPSR_Type__bindgen_ty_1() {
	assert_eq!(
	           ::core::mem::size_of::<IPSR_Type__bindgen_ty_1>(),
	           4usize,
	           concat!("Size of: ", stringify!(IPSR_Type__bindgen_ty_1))
	);
	assert_eq!(
	           ::core::mem::align_of::<IPSR_Type__bindgen_ty_1>(),
	           4usize,
	           concat!("Alignment of ", stringify!(IPSR_Type__bindgen_ty_1))
	);
}
impl IPSR_Type__bindgen_ty_1 {
	#[inline]
	pub fn ISR(&self) -> u32 { unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 9u8) as u32) } }
	#[inline]
	pub fn set_ISR(&mut self, val: u32) {
		unsafe {
			let val: u32 = ::core::mem::transmute(val);
			self._bitfield_1.set(0usize, 9u8, val as u64)
		}
	}
	#[inline]
	pub fn _reserved0(&self) -> u32 { unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 23u8) as u32) } }
	#[inline]
	pub fn set__reserved0(&mut self, val: u32) {
		unsafe {
			let val: u32 = ::core::mem::transmute(val);
			self._bitfield_1.set(9usize, 23u8, val as u64)
		}
	}
	#[inline]
	pub fn new_bitfield_1(ISR: u32, _reserved0: u32) -> __BindgenBitfieldUnit<[u8; 4usize]> {
		let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
		__bindgen_bitfield_unit.set(0usize, 9u8, {
			                       let ISR: u32 = unsafe { ::core::mem::transmute(ISR) };
			                       ISR as u64
		                       });
		__bindgen_bitfield_unit.set(9usize, 23u8, {
			                       let _reserved0: u32 = unsafe { ::core::mem::transmute(_reserved0) };
			                       _reserved0 as u64
		                       });
		__bindgen_bitfield_unit
	}
}
#[test]
fn bindgen_test_layout_IPSR_Type() {
	assert_eq!(
	           ::core::mem::size_of::<IPSR_Type>(),
	           4usize,
	           concat!("Size of: ", stringify!(IPSR_Type))
	);
	assert_eq!(
	           ::core::mem::align_of::<IPSR_Type>(),
	           4usize,
	           concat!("Alignment of ", stringify!(IPSR_Type))
	);
	fn test_field_b() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<IPSR_Type>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).b) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(IPSR_Type), "::", stringify!(b))
		);
	}
	test_field_b();
	fn test_field_w() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<IPSR_Type>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).w) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(IPSR_Type), "::", stringify!(w))
		);
	}
	test_field_w();
}
#[repr(C)]
pub struct xPSR_Type {
	pub b: __BindgenUnionField<xPSR_Type__bindgen_ty_1>,
	pub w: __BindgenUnionField<u32>,
	pub bindgen_union_field: u32,
}
#[repr(C)]
#[repr(align(4))]
pub struct xPSR_Type__bindgen_ty_1 {
	pub _bitfield_align_1: [u16; 0],
	pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_xPSR_Type__bindgen_ty_1() {
	assert_eq!(
	           ::core::mem::size_of::<xPSR_Type__bindgen_ty_1>(),
	           4usize,
	           concat!("Size of: ", stringify!(xPSR_Type__bindgen_ty_1))
	);
	assert_eq!(
	           ::core::mem::align_of::<xPSR_Type__bindgen_ty_1>(),
	           4usize,
	           concat!("Alignment of ", stringify!(xPSR_Type__bindgen_ty_1))
	);
}
impl xPSR_Type__bindgen_ty_1 {
	#[inline]
	pub fn ISR(&self) -> u32 { unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 9u8) as u32) } }
	#[inline]
	pub fn set_ISR(&mut self, val: u32) {
		unsafe {
			let val: u32 = ::core::mem::transmute(val);
			self._bitfield_1.set(0usize, 9u8, val as u64)
		}
	}
	#[inline]
	pub fn _reserved0(&self) -> u32 { unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) } }
	#[inline]
	pub fn set__reserved0(&mut self, val: u32) {
		unsafe {
			let val: u32 = ::core::mem::transmute(val);
			self._bitfield_1.set(9usize, 1u8, val as u64)
		}
	}
	#[inline]
	pub fn ICI_IT_1(&self) -> u32 { unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 6u8) as u32) } }
	#[inline]
	pub fn set_ICI_IT_1(&mut self, val: u32) {
		unsafe {
			let val: u32 = ::core::mem::transmute(val);
			self._bitfield_1.set(10usize, 6u8, val as u64)
		}
	}
	#[inline]
	pub fn GE(&self) -> u32 { unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 4u8) as u32) } }
	#[inline]
	pub fn set_GE(&mut self, val: u32) {
		unsafe {
			let val: u32 = ::core::mem::transmute(val);
			self._bitfield_1.set(16usize, 4u8, val as u64)
		}
	}
	#[inline]
	pub fn _reserved1(&self) -> u32 { unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 4u8) as u32) } }
	#[inline]
	pub fn set__reserved1(&mut self, val: u32) {
		unsafe {
			let val: u32 = ::core::mem::transmute(val);
			self._bitfield_1.set(20usize, 4u8, val as u64)
		}
	}
	#[inline]
	pub fn T(&self) -> u32 { unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 1u8) as u32) } }
	#[inline]
	pub fn set_T(&mut self, val: u32) {
		unsafe {
			let val: u32 = ::core::mem::transmute(val);
			self._bitfield_1.set(24usize, 1u8, val as u64)
		}
	}
	#[inline]
	pub fn ICI_IT_2(&self) -> u32 { unsafe { ::core::mem::transmute(self._bitfield_1.get(25usize, 2u8) as u32) } }
	#[inline]
	pub fn set_ICI_IT_2(&mut self, val: u32) {
		unsafe {
			let val: u32 = ::core::mem::transmute(val);
			self._bitfield_1.set(25usize, 2u8, val as u64)
		}
	}
	#[inline]
	pub fn Q(&self) -> u32 { unsafe { ::core::mem::transmute(self._bitfield_1.get(27usize, 1u8) as u32) } }
	#[inline]
	pub fn set_Q(&mut self, val: u32) {
		unsafe {
			let val: u32 = ::core::mem::transmute(val);
			self._bitfield_1.set(27usize, 1u8, val as u64)
		}
	}
	#[inline]
	pub fn V(&self) -> u32 { unsafe { ::core::mem::transmute(self._bitfield_1.get(28usize, 1u8) as u32) } }
	#[inline]
	pub fn set_V(&mut self, val: u32) {
		unsafe {
			let val: u32 = ::core::mem::transmute(val);
			self._bitfield_1.set(28usize, 1u8, val as u64)
		}
	}
	#[inline]
	pub fn C(&self) -> u32 { unsafe { ::core::mem::transmute(self._bitfield_1.get(29usize, 1u8) as u32) } }
	#[inline]
	pub fn set_C(&mut self, val: u32) {
		unsafe {
			let val: u32 = ::core::mem::transmute(val);
			self._bitfield_1.set(29usize, 1u8, val as u64)
		}
	}
	#[inline]
	pub fn Z(&self) -> u32 { unsafe { ::core::mem::transmute(self._bitfield_1.get(30usize, 1u8) as u32) } }
	#[inline]
	pub fn set_Z(&mut self, val: u32) {
		unsafe {
			let val: u32 = ::core::mem::transmute(val);
			self._bitfield_1.set(30usize, 1u8, val as u64)
		}
	}
	#[inline]
	pub fn N(&self) -> u32 { unsafe { ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) } }
	#[inline]
	pub fn set_N(&mut self, val: u32) {
		unsafe {
			let val: u32 = ::core::mem::transmute(val);
			self._bitfield_1.set(31usize, 1u8, val as u64)
		}
	}
	#[inline]
	pub fn new_bitfield_1(ISR: u32,
	                      _reserved0: u32,
	                      ICI_IT_1: u32,
	                      GE: u32,
	                      _reserved1: u32,
	                      T: u32,
	                      ICI_IT_2: u32,
	                      Q: u32,
	                      V: u32,
	                      C: u32,
	                      Z: u32,
	                      N: u32)
	                      -> __BindgenBitfieldUnit<[u8; 4usize]> {
		let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
		__bindgen_bitfield_unit.set(0usize, 9u8, {
			                       let ISR: u32 = unsafe { ::core::mem::transmute(ISR) };
			                       ISR as u64
		                       });
		__bindgen_bitfield_unit.set(9usize, 1u8, {
			                       let _reserved0: u32 = unsafe { ::core::mem::transmute(_reserved0) };
			                       _reserved0 as u64
		                       });
		__bindgen_bitfield_unit.set(10usize, 6u8, {
			                       let ICI_IT_1: u32 = unsafe { ::core::mem::transmute(ICI_IT_1) };
			                       ICI_IT_1 as u64
		                       });
		__bindgen_bitfield_unit.set(16usize, 4u8, {
			                       let GE: u32 = unsafe { ::core::mem::transmute(GE) };
			                       GE as u64
		                       });
		__bindgen_bitfield_unit.set(20usize, 4u8, {
			                       let _reserved1: u32 = unsafe { ::core::mem::transmute(_reserved1) };
			                       _reserved1 as u64
		                       });
		__bindgen_bitfield_unit.set(24usize, 1u8, {
			                       let T: u32 = unsafe { ::core::mem::transmute(T) };
			                       T as u64
		                       });
		__bindgen_bitfield_unit.set(25usize, 2u8, {
			                       let ICI_IT_2: u32 = unsafe { ::core::mem::transmute(ICI_IT_2) };
			                       ICI_IT_2 as u64
		                       });
		__bindgen_bitfield_unit.set(27usize, 1u8, {
			                       let Q: u32 = unsafe { ::core::mem::transmute(Q) };
			                       Q as u64
		                       });
		__bindgen_bitfield_unit.set(28usize, 1u8, {
			                       let V: u32 = unsafe { ::core::mem::transmute(V) };
			                       V as u64
		                       });
		__bindgen_bitfield_unit.set(29usize, 1u8, {
			                       let C: u32 = unsafe { ::core::mem::transmute(C) };
			                       C as u64
		                       });
		__bindgen_bitfield_unit.set(30usize, 1u8, {
			                       let Z: u32 = unsafe { ::core::mem::transmute(Z) };
			                       Z as u64
		                       });
		__bindgen_bitfield_unit.set(31usize, 1u8, {
			                       let N: u32 = unsafe { ::core::mem::transmute(N) };
			                       N as u64
		                       });
		__bindgen_bitfield_unit
	}
}
#[test]
fn bindgen_test_layout_xPSR_Type() {
	assert_eq!(
	           ::core::mem::size_of::<xPSR_Type>(),
	           4usize,
	           concat!("Size of: ", stringify!(xPSR_Type))
	);
	assert_eq!(
	           ::core::mem::align_of::<xPSR_Type>(),
	           4usize,
	           concat!("Alignment of ", stringify!(xPSR_Type))
	);
	fn test_field_b() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<xPSR_Type>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).b) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(xPSR_Type), "::", stringify!(b))
		);
	}
	test_field_b();
	fn test_field_w() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<xPSR_Type>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).w) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(xPSR_Type), "::", stringify!(w))
		);
	}
	test_field_w();
}
#[repr(C)]
pub struct CONTROL_Type {
	pub b: __BindgenUnionField<CONTROL_Type__bindgen_ty_1>,
	pub w: __BindgenUnionField<u32>,
	pub bindgen_union_field: u32,
}
#[repr(C)]
#[repr(align(4))]
pub struct CONTROL_Type__bindgen_ty_1 {
	pub _bitfield_align_1: [u32; 0],
	pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_CONTROL_Type__bindgen_ty_1() {
	assert_eq!(
	           ::core::mem::size_of::<CONTROL_Type__bindgen_ty_1>(),
	           4usize,
	           concat!("Size of: ", stringify!(CONTROL_Type__bindgen_ty_1))
	);
	assert_eq!(
	           ::core::mem::align_of::<CONTROL_Type__bindgen_ty_1>(),
	           4usize,
	           concat!("Alignment of ", stringify!(CONTROL_Type__bindgen_ty_1))
	);
}
impl CONTROL_Type__bindgen_ty_1 {
	#[inline]
	pub fn nPRIV(&self) -> u32 { unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) } }
	#[inline]
	pub fn set_nPRIV(&mut self, val: u32) {
		unsafe {
			let val: u32 = ::core::mem::transmute(val);
			self._bitfield_1.set(0usize, 1u8, val as u64)
		}
	}
	#[inline]
	pub fn SPSEL(&self) -> u32 { unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) } }
	#[inline]
	pub fn set_SPSEL(&mut self, val: u32) {
		unsafe {
			let val: u32 = ::core::mem::transmute(val);
			self._bitfield_1.set(1usize, 1u8, val as u64)
		}
	}
	#[inline]
	pub fn FPCA(&self) -> u32 { unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) } }
	#[inline]
	pub fn set_FPCA(&mut self, val: u32) {
		unsafe {
			let val: u32 = ::core::mem::transmute(val);
			self._bitfield_1.set(2usize, 1u8, val as u64)
		}
	}
	#[inline]
	pub fn _reserved0(&self) -> u32 { unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 29u8) as u32) } }
	#[inline]
	pub fn set__reserved0(&mut self, val: u32) {
		unsafe {
			let val: u32 = ::core::mem::transmute(val);
			self._bitfield_1.set(3usize, 29u8, val as u64)
		}
	}
	#[inline]
	pub fn new_bitfield_1(nPRIV: u32, SPSEL: u32, FPCA: u32, _reserved0: u32) -> __BindgenBitfieldUnit<[u8; 4usize]> {
		let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
		__bindgen_bitfield_unit.set(0usize, 1u8, {
			                       let nPRIV: u32 = unsafe { ::core::mem::transmute(nPRIV) };
			                       nPRIV as u64
		                       });
		__bindgen_bitfield_unit.set(1usize, 1u8, {
			                       let SPSEL: u32 = unsafe { ::core::mem::transmute(SPSEL) };
			                       SPSEL as u64
		                       });
		__bindgen_bitfield_unit.set(2usize, 1u8, {
			                       let FPCA: u32 = unsafe { ::core::mem::transmute(FPCA) };
			                       FPCA as u64
		                       });
		__bindgen_bitfield_unit.set(3usize, 29u8, {
			                       let _reserved0: u32 = unsafe { ::core::mem::transmute(_reserved0) };
			                       _reserved0 as u64
		                       });
		__bindgen_bitfield_unit
	}
}
#[test]
fn bindgen_test_layout_CONTROL_Type() {
	assert_eq!(
	           ::core::mem::size_of::<CONTROL_Type>(),
	           4usize,
	           concat!("Size of: ", stringify!(CONTROL_Type))
	);
	assert_eq!(
	           ::core::mem::align_of::<CONTROL_Type>(),
	           4usize,
	           concat!("Alignment of ", stringify!(CONTROL_Type))
	);
	fn test_field_b() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<CONTROL_Type>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).b) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(CONTROL_Type), "::", stringify!(b))
		);
	}
	test_field_b();
	fn test_field_w() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<CONTROL_Type>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).w) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(CONTROL_Type), "::", stringify!(w))
		);
	}
	test_field_w();
}
#[repr(C)]
pub struct NVIC_Type {
	pub ISER: [u32; 8usize],
	pub RESERVED0: [u32; 24usize],
	pub ICER: [u32; 8usize],
	pub RESERVED1: [u32; 24usize],
	pub ISPR: [u32; 8usize],
	pub RESERVED2: [u32; 24usize],
	pub ICPR: [u32; 8usize],
	pub RESERVED3: [u32; 24usize],
	pub IABR: [u32; 8usize],
	pub RESERVED4: [u32; 56usize],
	pub IP: [u8; 240usize],
	pub RESERVED5: [u32; 644usize],
	pub STIR: u32,
}
#[test]
fn bindgen_test_layout_NVIC_Type() {
	assert_eq!(
	           ::core::mem::size_of::<NVIC_Type>(),
	           3588usize,
	           concat!("Size of: ", stringify!(NVIC_Type))
	);
	assert_eq!(
	           ::core::mem::align_of::<NVIC_Type>(),
	           4usize,
	           concat!("Alignment of ", stringify!(NVIC_Type))
	);
	fn test_field_ISER() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<NVIC_Type>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).ISER) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(NVIC_Type), "::", stringify!(ISER))
		);
	}
	test_field_ISER();
	fn test_field_RESERVED0() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<NVIC_Type>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).RESERVED0) as usize - ptr as usize
		           },
		           32usize,
		           concat!("Offset of field: ", stringify!(NVIC_Type), "::", stringify!(RESERVED0))
		);
	}
	test_field_RESERVED0();
	fn test_field_ICER() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<NVIC_Type>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).ICER) as usize - ptr as usize
		           },
		           128usize,
		           concat!("Offset of field: ", stringify!(NVIC_Type), "::", stringify!(ICER))
		);
	}
	test_field_ICER();
	fn test_field_RESERVED1() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<NVIC_Type>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).RESERVED1) as usize - ptr as usize
		           },
		           160usize,
		           concat!("Offset of field: ", stringify!(NVIC_Type), "::", stringify!(RESERVED1))
		);
	}
	test_field_RESERVED1();
	fn test_field_ISPR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<NVIC_Type>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).ISPR) as usize - ptr as usize
		           },
		           256usize,
		           concat!("Offset of field: ", stringify!(NVIC_Type), "::", stringify!(ISPR))
		);
	}
	test_field_ISPR();
	fn test_field_RESERVED2() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<NVIC_Type>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).RESERVED2) as usize - ptr as usize
		           },
		           288usize,
		           concat!("Offset of field: ", stringify!(NVIC_Type), "::", stringify!(RESERVED2))
		);
	}
	test_field_RESERVED2();
	fn test_field_ICPR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<NVIC_Type>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).ICPR) as usize - ptr as usize
		           },
		           384usize,
		           concat!("Offset of field: ", stringify!(NVIC_Type), "::", stringify!(ICPR))
		);
	}
	test_field_ICPR();
	fn test_field_RESERVED3() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<NVIC_Type>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).RESERVED3) as usize - ptr as usize
		           },
		           416usize,
		           concat!("Offset of field: ", stringify!(NVIC_Type), "::", stringify!(RESERVED3))
		);
	}
	test_field_RESERVED3();
	fn test_field_IABR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<NVIC_Type>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).IABR) as usize - ptr as usize
		           },
		           512usize,
		           concat!("Offset of field: ", stringify!(NVIC_Type), "::", stringify!(IABR))
		);
	}
	test_field_IABR();
	fn test_field_RESERVED4() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<NVIC_Type>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).RESERVED4) as usize - ptr as usize
		           },
		           544usize,
		           concat!("Offset of field: ", stringify!(NVIC_Type), "::", stringify!(RESERVED4))
		);
	}
	test_field_RESERVED4();
	fn test_field_IP() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<NVIC_Type>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).IP) as usize - ptr as usize
		           },
		           768usize,
		           concat!("Offset of field: ", stringify!(NVIC_Type), "::", stringify!(IP))
		);
	}
	test_field_IP();
	fn test_field_RESERVED5() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<NVIC_Type>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).RESERVED5) as usize - ptr as usize
		           },
		           1008usize,
		           concat!("Offset of field: ", stringify!(NVIC_Type), "::", stringify!(RESERVED5))
		);
	}
	test_field_RESERVED5();
	fn test_field_STIR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<NVIC_Type>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).STIR) as usize - ptr as usize
		           },
		           3584usize,
		           concat!("Offset of field: ", stringify!(NVIC_Type), "::", stringify!(STIR))
		);
	}
	test_field_STIR();
}
#[repr(C)]
pub struct SCB_Type {
	pub CPUID: u32,
	pub ICSR: u32,
	pub VTOR: u32,
	pub AIRCR: u32,
	pub SCR: u32,
	pub CCR: u32,
	pub SHP: [u8; 12usize],
	pub SHCSR: u32,
	pub CFSR: u32,
	pub HFSR: u32,
	pub DFSR: u32,
	pub MMFAR: u32,
	pub BFAR: u32,
	pub AFSR: u32,
	pub PFR: [u32; 2usize],
	pub DFR: u32,
	pub ADR: u32,
	pub MMFR: [u32; 4usize],
	pub ISAR: [u32; 5usize],
	pub RESERVED0: [u32; 5usize],
	pub CPACR: u32,
}
#[test]
fn bindgen_test_layout_SCB_Type() {
	assert_eq!(
	           ::core::mem::size_of::<SCB_Type>(),
	           140usize,
	           concat!("Size of: ", stringify!(SCB_Type))
	);
	assert_eq!(
	           ::core::mem::align_of::<SCB_Type>(),
	           4usize,
	           concat!("Alignment of ", stringify!(SCB_Type))
	);
	fn test_field_CPUID() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<SCB_Type>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).CPUID) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(SCB_Type), "::", stringify!(CPUID))
		);
	}
	test_field_CPUID();
	fn test_field_ICSR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<SCB_Type>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).ICSR) as usize - ptr as usize
		           },
		           4usize,
		           concat!("Offset of field: ", stringify!(SCB_Type), "::", stringify!(ICSR))
		);
	}
	test_field_ICSR();
	fn test_field_VTOR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<SCB_Type>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).VTOR) as usize - ptr as usize
		           },
		           8usize,
		           concat!("Offset of field: ", stringify!(SCB_Type), "::", stringify!(VTOR))
		);
	}
	test_field_VTOR();
	fn test_field_AIRCR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<SCB_Type>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).AIRCR) as usize - ptr as usize
		           },
		           12usize,
		           concat!("Offset of field: ", stringify!(SCB_Type), "::", stringify!(AIRCR))
		);
	}
	test_field_AIRCR();
	fn test_field_SCR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<SCB_Type>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).SCR) as usize - ptr as usize
		           },
		           16usize,
		           concat!("Offset of field: ", stringify!(SCB_Type), "::", stringify!(SCR))
		);
	}
	test_field_SCR();
	fn test_field_CCR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<SCB_Type>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).CCR) as usize - ptr as usize
		           },
		           20usize,
		           concat!("Offset of field: ", stringify!(SCB_Type), "::", stringify!(CCR))
		);
	}
	test_field_CCR();
	fn test_field_SHP() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<SCB_Type>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).SHP) as usize - ptr as usize
		           },
		           24usize,
		           concat!("Offset of field: ", stringify!(SCB_Type), "::", stringify!(SHP))
		);
	}
	test_field_SHP();
	fn test_field_SHCSR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<SCB_Type>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).SHCSR) as usize - ptr as usize
		           },
		           36usize,
		           concat!("Offset of field: ", stringify!(SCB_Type), "::", stringify!(SHCSR))
		);
	}
	test_field_SHCSR();
	fn test_field_CFSR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<SCB_Type>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).CFSR) as usize - ptr as usize
		           },
		           40usize,
		           concat!("Offset of field: ", stringify!(SCB_Type), "::", stringify!(CFSR))
		);
	}
	test_field_CFSR();
	fn test_field_HFSR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<SCB_Type>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).HFSR) as usize - ptr as usize
		           },
		           44usize,
		           concat!("Offset of field: ", stringify!(SCB_Type), "::", stringify!(HFSR))
		);
	}
	test_field_HFSR();
	fn test_field_DFSR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<SCB_Type>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).DFSR) as usize - ptr as usize
		           },
		           48usize,
		           concat!("Offset of field: ", stringify!(SCB_Type), "::", stringify!(DFSR))
		);
	}
	test_field_DFSR();
	fn test_field_MMFAR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<SCB_Type>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).MMFAR) as usize - ptr as usize
		           },
		           52usize,
		           concat!("Offset of field: ", stringify!(SCB_Type), "::", stringify!(MMFAR))
		);
	}
	test_field_MMFAR();
	fn test_field_BFAR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<SCB_Type>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).BFAR) as usize - ptr as usize
		           },
		           56usize,
		           concat!("Offset of field: ", stringify!(SCB_Type), "::", stringify!(BFAR))
		);
	}
	test_field_BFAR();
	fn test_field_AFSR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<SCB_Type>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).AFSR) as usize - ptr as usize
		           },
		           60usize,
		           concat!("Offset of field: ", stringify!(SCB_Type), "::", stringify!(AFSR))
		);
	}
	test_field_AFSR();
	fn test_field_PFR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<SCB_Type>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).PFR) as usize - ptr as usize
		           },
		           64usize,
		           concat!("Offset of field: ", stringify!(SCB_Type), "::", stringify!(PFR))
		);
	}
	test_field_PFR();
	fn test_field_DFR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<SCB_Type>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).DFR) as usize - ptr as usize
		           },
		           72usize,
		           concat!("Offset of field: ", stringify!(SCB_Type), "::", stringify!(DFR))
		);
	}
	test_field_DFR();
	fn test_field_ADR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<SCB_Type>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).ADR) as usize - ptr as usize
		           },
		           76usize,
		           concat!("Offset of field: ", stringify!(SCB_Type), "::", stringify!(ADR))
		);
	}
	test_field_ADR();
	fn test_field_MMFR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<SCB_Type>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).MMFR) as usize - ptr as usize
		           },
		           80usize,
		           concat!("Offset of field: ", stringify!(SCB_Type), "::", stringify!(MMFR))
		);
	}
	test_field_MMFR();
	fn test_field_ISAR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<SCB_Type>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).ISAR) as usize - ptr as usize
		           },
		           96usize,
		           concat!("Offset of field: ", stringify!(SCB_Type), "::", stringify!(ISAR))
		);
	}
	test_field_ISAR();
	fn test_field_RESERVED0() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<SCB_Type>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).RESERVED0) as usize - ptr as usize
		           },
		           116usize,
		           concat!("Offset of field: ", stringify!(SCB_Type), "::", stringify!(RESERVED0))
		);
	}
	test_field_RESERVED0();
	fn test_field_CPACR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<SCB_Type>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).CPACR) as usize - ptr as usize
		           },
		           136usize,
		           concat!("Offset of field: ", stringify!(SCB_Type), "::", stringify!(CPACR))
		);
	}
	test_field_CPACR();
}
#[repr(C)]
pub struct SCnSCB_Type {
	pub RESERVED0: [u32; 1usize],
	pub ICTR: u32,
	pub ACTLR: u32,
}
#[test]
fn bindgen_test_layout_SCnSCB_Type() {
	assert_eq!(
	           ::core::mem::size_of::<SCnSCB_Type>(),
	           12usize,
	           concat!("Size of: ", stringify!(SCnSCB_Type))
	);
	assert_eq!(
	           ::core::mem::align_of::<SCnSCB_Type>(),
	           4usize,
	           concat!("Alignment of ", stringify!(SCnSCB_Type))
	);
	fn test_field_RESERVED0() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<SCnSCB_Type>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).RESERVED0) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(SCnSCB_Type), "::", stringify!(RESERVED0))
		);
	}
	test_field_RESERVED0();
	fn test_field_ICTR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<SCnSCB_Type>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).ICTR) as usize - ptr as usize
		           },
		           4usize,
		           concat!("Offset of field: ", stringify!(SCnSCB_Type), "::", stringify!(ICTR))
		);
	}
	test_field_ICTR();
	fn test_field_ACTLR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<SCnSCB_Type>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).ACTLR) as usize - ptr as usize
		           },
		           8usize,
		           concat!("Offset of field: ", stringify!(SCnSCB_Type), "::", stringify!(ACTLR))
		);
	}
	test_field_ACTLR();
}
#[repr(C)]
pub struct SysTick_Type {
	pub CTRL: u32,
	pub LOAD: u32,
	pub VAL: u32,
	pub CALIB: u32,
}
#[test]
fn bindgen_test_layout_SysTick_Type() {
	assert_eq!(
	           ::core::mem::size_of::<SysTick_Type>(),
	           16usize,
	           concat!("Size of: ", stringify!(SysTick_Type))
	);
	assert_eq!(
	           ::core::mem::align_of::<SysTick_Type>(),
	           4usize,
	           concat!("Alignment of ", stringify!(SysTick_Type))
	);
	fn test_field_CTRL() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<SysTick_Type>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).CTRL) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(SysTick_Type), "::", stringify!(CTRL))
		);
	}
	test_field_CTRL();
	fn test_field_LOAD() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<SysTick_Type>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).LOAD) as usize - ptr as usize
		           },
		           4usize,
		           concat!("Offset of field: ", stringify!(SysTick_Type), "::", stringify!(LOAD))
		);
	}
	test_field_LOAD();
	fn test_field_VAL() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<SysTick_Type>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).VAL) as usize - ptr as usize
		           },
		           8usize,
		           concat!("Offset of field: ", stringify!(SysTick_Type), "::", stringify!(VAL))
		);
	}
	test_field_VAL();
	fn test_field_CALIB() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<SysTick_Type>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).CALIB) as usize - ptr as usize
		           },
		           12usize,
		           concat!("Offset of field: ", stringify!(SysTick_Type), "::", stringify!(CALIB))
		);
	}
	test_field_CALIB();
}
#[repr(C)]
pub struct ITM_Type {
	pub PORT: [ITM_Type__bindgen_ty_1; 32usize],
	pub RESERVED0: [u32; 864usize],
	pub TER: u32,
	pub RESERVED1: [u32; 15usize],
	pub TPR: u32,
	pub RESERVED2: [u32; 15usize],
	pub TCR: u32,
	pub RESERVED3: [u32; 32usize],
	pub RESERVED4: [u32; 43usize],
	pub LAR: u32,
	pub LSR: u32,
	pub RESERVED5: [u32; 6usize],
	pub PID4: u32,
	pub PID5: u32,
	pub PID6: u32,
	pub PID7: u32,
	pub PID0: u32,
	pub PID1: u32,
	pub PID2: u32,
	pub PID3: u32,
	pub CID0: u32,
	pub CID1: u32,
	pub CID2: u32,
	pub CID3: u32,
}
#[repr(C)]
pub struct ITM_Type__bindgen_ty_1 {
	pub u8_: __BindgenUnionField<u8>,
	pub u16_: __BindgenUnionField<u16>,
	pub u32_: __BindgenUnionField<u32>,
	pub bindgen_union_field: u32,
}
#[test]
fn bindgen_test_layout_ITM_Type__bindgen_ty_1() {
	assert_eq!(
	           ::core::mem::size_of::<ITM_Type__bindgen_ty_1>(),
	           4usize,
	           concat!("Size of: ", stringify!(ITM_Type__bindgen_ty_1))
	);
	assert_eq!(
	           ::core::mem::align_of::<ITM_Type__bindgen_ty_1>(),
	           4usize,
	           concat!("Alignment of ", stringify!(ITM_Type__bindgen_ty_1))
	);
	fn test_field_u8() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<ITM_Type__bindgen_ty_1>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).u8_) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(ITM_Type__bindgen_ty_1), "::", stringify!(u8_))
		);
	}
	test_field_u8();
	fn test_field_u16() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<ITM_Type__bindgen_ty_1>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).u16_) as usize - ptr as usize
		           },
		           0usize,
		           concat!(
			"Offset of field: ",
			stringify!(ITM_Type__bindgen_ty_1),
			"::",
			stringify!(u16_)
		)
		);
	}
	test_field_u16();
	fn test_field_u32() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<ITM_Type__bindgen_ty_1>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).u32_) as usize - ptr as usize
		           },
		           0usize,
		           concat!(
			"Offset of field: ",
			stringify!(ITM_Type__bindgen_ty_1),
			"::",
			stringify!(u32_)
		)
		);
	}
	test_field_u32();
}
#[test]
fn bindgen_test_layout_ITM_Type() {
	assert_eq!(
	           ::core::mem::size_of::<ITM_Type>(),
	           4096usize,
	           concat!("Size of: ", stringify!(ITM_Type))
	);
	assert_eq!(
	           ::core::mem::align_of::<ITM_Type>(),
	           4usize,
	           concat!("Alignment of ", stringify!(ITM_Type))
	);
	fn test_field_PORT() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<ITM_Type>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).PORT) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(ITM_Type), "::", stringify!(PORT))
		);
	}
	test_field_PORT();
	fn test_field_RESERVED0() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<ITM_Type>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).RESERVED0) as usize - ptr as usize
		           },
		           128usize,
		           concat!("Offset of field: ", stringify!(ITM_Type), "::", stringify!(RESERVED0))
		);
	}
	test_field_RESERVED0();
	fn test_field_TER() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<ITM_Type>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).TER) as usize - ptr as usize
		           },
		           3584usize,
		           concat!("Offset of field: ", stringify!(ITM_Type), "::", stringify!(TER))
		);
	}
	test_field_TER();
	fn test_field_RESERVED1() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<ITM_Type>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).RESERVED1) as usize - ptr as usize
		           },
		           3588usize,
		           concat!("Offset of field: ", stringify!(ITM_Type), "::", stringify!(RESERVED1))
		);
	}
	test_field_RESERVED1();
	fn test_field_TPR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<ITM_Type>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).TPR) as usize - ptr as usize
		           },
		           3648usize,
		           concat!("Offset of field: ", stringify!(ITM_Type), "::", stringify!(TPR))
		);
	}
	test_field_TPR();
	fn test_field_RESERVED2() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<ITM_Type>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).RESERVED2) as usize - ptr as usize
		           },
		           3652usize,
		           concat!("Offset of field: ", stringify!(ITM_Type), "::", stringify!(RESERVED2))
		);
	}
	test_field_RESERVED2();
	fn test_field_TCR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<ITM_Type>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).TCR) as usize - ptr as usize
		           },
		           3712usize,
		           concat!("Offset of field: ", stringify!(ITM_Type), "::", stringify!(TCR))
		);
	}
	test_field_TCR();
	fn test_field_RESERVED3() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<ITM_Type>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).RESERVED3) as usize - ptr as usize
		           },
		           3716usize,
		           concat!("Offset of field: ", stringify!(ITM_Type), "::", stringify!(RESERVED3))
		);
	}
	test_field_RESERVED3();
	fn test_field_RESERVED4() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<ITM_Type>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).RESERVED4) as usize - ptr as usize
		           },
		           3844usize,
		           concat!("Offset of field: ", stringify!(ITM_Type), "::", stringify!(RESERVED4))
		);
	}
	test_field_RESERVED4();
	fn test_field_LAR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<ITM_Type>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).LAR) as usize - ptr as usize
		           },
		           4016usize,
		           concat!("Offset of field: ", stringify!(ITM_Type), "::", stringify!(LAR))
		);
	}
	test_field_LAR();
	fn test_field_LSR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<ITM_Type>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).LSR) as usize - ptr as usize
		           },
		           4020usize,
		           concat!("Offset of field: ", stringify!(ITM_Type), "::", stringify!(LSR))
		);
	}
	test_field_LSR();
	fn test_field_RESERVED5() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<ITM_Type>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).RESERVED5) as usize - ptr as usize
		           },
		           4024usize,
		           concat!("Offset of field: ", stringify!(ITM_Type), "::", stringify!(RESERVED5))
		);
	}
	test_field_RESERVED5();
	fn test_field_PID4() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<ITM_Type>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).PID4) as usize - ptr as usize
		           },
		           4048usize,
		           concat!("Offset of field: ", stringify!(ITM_Type), "::", stringify!(PID4))
		);
	}
	test_field_PID4();
	fn test_field_PID5() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<ITM_Type>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).PID5) as usize - ptr as usize
		           },
		           4052usize,
		           concat!("Offset of field: ", stringify!(ITM_Type), "::", stringify!(PID5))
		);
	}
	test_field_PID5();
	fn test_field_PID6() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<ITM_Type>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).PID6) as usize - ptr as usize
		           },
		           4056usize,
		           concat!("Offset of field: ", stringify!(ITM_Type), "::", stringify!(PID6))
		);
	}
	test_field_PID6();
	fn test_field_PID7() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<ITM_Type>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).PID7) as usize - ptr as usize
		           },
		           4060usize,
		           concat!("Offset of field: ", stringify!(ITM_Type), "::", stringify!(PID7))
		);
	}
	test_field_PID7();
	fn test_field_PID0() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<ITM_Type>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).PID0) as usize - ptr as usize
		           },
		           4064usize,
		           concat!("Offset of field: ", stringify!(ITM_Type), "::", stringify!(PID0))
		);
	}
	test_field_PID0();
	fn test_field_PID1() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<ITM_Type>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).PID1) as usize - ptr as usize
		           },
		           4068usize,
		           concat!("Offset of field: ", stringify!(ITM_Type), "::", stringify!(PID1))
		);
	}
	test_field_PID1();
	fn test_field_PID2() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<ITM_Type>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).PID2) as usize - ptr as usize
		           },
		           4072usize,
		           concat!("Offset of field: ", stringify!(ITM_Type), "::", stringify!(PID2))
		);
	}
	test_field_PID2();
	fn test_field_PID3() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<ITM_Type>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).PID3) as usize - ptr as usize
		           },
		           4076usize,
		           concat!("Offset of field: ", stringify!(ITM_Type), "::", stringify!(PID3))
		);
	}
	test_field_PID3();
	fn test_field_CID0() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<ITM_Type>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).CID0) as usize - ptr as usize
		           },
		           4080usize,
		           concat!("Offset of field: ", stringify!(ITM_Type), "::", stringify!(CID0))
		);
	}
	test_field_CID0();
	fn test_field_CID1() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<ITM_Type>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).CID1) as usize - ptr as usize
		           },
		           4084usize,
		           concat!("Offset of field: ", stringify!(ITM_Type), "::", stringify!(CID1))
		);
	}
	test_field_CID1();
	fn test_field_CID2() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<ITM_Type>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).CID2) as usize - ptr as usize
		           },
		           4088usize,
		           concat!("Offset of field: ", stringify!(ITM_Type), "::", stringify!(CID2))
		);
	}
	test_field_CID2();
	fn test_field_CID3() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<ITM_Type>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).CID3) as usize - ptr as usize
		           },
		           4092usize,
		           concat!("Offset of field: ", stringify!(ITM_Type), "::", stringify!(CID3))
		);
	}
	test_field_CID3();
}
#[repr(C)]
pub struct DWT_Type {
	pub CTRL: u32,
	pub CYCCNT: u32,
	pub CPICNT: u32,
	pub EXCCNT: u32,
	pub SLEEPCNT: u32,
	pub LSUCNT: u32,
	pub FOLDCNT: u32,
	pub PCSR: u32,
	pub COMP0: u32,
	pub MASK0: u32,
	pub FUNCTION0: u32,
	pub RESERVED0: [u32; 1usize],
	pub COMP1: u32,
	pub MASK1: u32,
	pub FUNCTION1: u32,
	pub RESERVED1: [u32; 1usize],
	pub COMP2: u32,
	pub MASK2: u32,
	pub FUNCTION2: u32,
	pub RESERVED2: [u32; 1usize],
	pub COMP3: u32,
	pub MASK3: u32,
	pub FUNCTION3: u32,
}
#[test]
fn bindgen_test_layout_DWT_Type() {
	assert_eq!(
	           ::core::mem::size_of::<DWT_Type>(),
	           92usize,
	           concat!("Size of: ", stringify!(DWT_Type))
	);
	assert_eq!(
	           ::core::mem::align_of::<DWT_Type>(),
	           4usize,
	           concat!("Alignment of ", stringify!(DWT_Type))
	);
	fn test_field_CTRL() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<DWT_Type>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).CTRL) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(DWT_Type), "::", stringify!(CTRL))
		);
	}
	test_field_CTRL();
	fn test_field_CYCCNT() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<DWT_Type>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).CYCCNT) as usize - ptr as usize
		           },
		           4usize,
		           concat!("Offset of field: ", stringify!(DWT_Type), "::", stringify!(CYCCNT))
		);
	}
	test_field_CYCCNT();
	fn test_field_CPICNT() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<DWT_Type>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).CPICNT) as usize - ptr as usize
		           },
		           8usize,
		           concat!("Offset of field: ", stringify!(DWT_Type), "::", stringify!(CPICNT))
		);
	}
	test_field_CPICNT();
	fn test_field_EXCCNT() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<DWT_Type>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).EXCCNT) as usize - ptr as usize
		           },
		           12usize,
		           concat!("Offset of field: ", stringify!(DWT_Type), "::", stringify!(EXCCNT))
		);
	}
	test_field_EXCCNT();
	fn test_field_SLEEPCNT() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<DWT_Type>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).SLEEPCNT) as usize - ptr as usize
		           },
		           16usize,
		           concat!("Offset of field: ", stringify!(DWT_Type), "::", stringify!(SLEEPCNT))
		);
	}
	test_field_SLEEPCNT();
	fn test_field_LSUCNT() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<DWT_Type>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).LSUCNT) as usize - ptr as usize
		           },
		           20usize,
		           concat!("Offset of field: ", stringify!(DWT_Type), "::", stringify!(LSUCNT))
		);
	}
	test_field_LSUCNT();
	fn test_field_FOLDCNT() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<DWT_Type>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).FOLDCNT) as usize - ptr as usize
		           },
		           24usize,
		           concat!("Offset of field: ", stringify!(DWT_Type), "::", stringify!(FOLDCNT))
		);
	}
	test_field_FOLDCNT();
	fn test_field_PCSR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<DWT_Type>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).PCSR) as usize - ptr as usize
		           },
		           28usize,
		           concat!("Offset of field: ", stringify!(DWT_Type), "::", stringify!(PCSR))
		);
	}
	test_field_PCSR();
	fn test_field_COMP0() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<DWT_Type>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).COMP0) as usize - ptr as usize
		           },
		           32usize,
		           concat!("Offset of field: ", stringify!(DWT_Type), "::", stringify!(COMP0))
		);
	}
	test_field_COMP0();
	fn test_field_MASK0() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<DWT_Type>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).MASK0) as usize - ptr as usize
		           },
		           36usize,
		           concat!("Offset of field: ", stringify!(DWT_Type), "::", stringify!(MASK0))
		);
	}
	test_field_MASK0();
	fn test_field_FUNCTION0() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<DWT_Type>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).FUNCTION0) as usize - ptr as usize
		           },
		           40usize,
		           concat!("Offset of field: ", stringify!(DWT_Type), "::", stringify!(FUNCTION0))
		);
	}
	test_field_FUNCTION0();
	fn test_field_RESERVED0() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<DWT_Type>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).RESERVED0) as usize - ptr as usize
		           },
		           44usize,
		           concat!("Offset of field: ", stringify!(DWT_Type), "::", stringify!(RESERVED0))
		);
	}
	test_field_RESERVED0();
	fn test_field_COMP1() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<DWT_Type>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).COMP1) as usize - ptr as usize
		           },
		           48usize,
		           concat!("Offset of field: ", stringify!(DWT_Type), "::", stringify!(COMP1))
		);
	}
	test_field_COMP1();
	fn test_field_MASK1() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<DWT_Type>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).MASK1) as usize - ptr as usize
		           },
		           52usize,
		           concat!("Offset of field: ", stringify!(DWT_Type), "::", stringify!(MASK1))
		);
	}
	test_field_MASK1();
	fn test_field_FUNCTION1() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<DWT_Type>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).FUNCTION1) as usize - ptr as usize
		           },
		           56usize,
		           concat!("Offset of field: ", stringify!(DWT_Type), "::", stringify!(FUNCTION1))
		);
	}
	test_field_FUNCTION1();
	fn test_field_RESERVED1() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<DWT_Type>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).RESERVED1) as usize - ptr as usize
		           },
		           60usize,
		           concat!("Offset of field: ", stringify!(DWT_Type), "::", stringify!(RESERVED1))
		);
	}
	test_field_RESERVED1();
	fn test_field_COMP2() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<DWT_Type>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).COMP2) as usize - ptr as usize
		           },
		           64usize,
		           concat!("Offset of field: ", stringify!(DWT_Type), "::", stringify!(COMP2))
		);
	}
	test_field_COMP2();
	fn test_field_MASK2() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<DWT_Type>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).MASK2) as usize - ptr as usize
		           },
		           68usize,
		           concat!("Offset of field: ", stringify!(DWT_Type), "::", stringify!(MASK2))
		);
	}
	test_field_MASK2();
	fn test_field_FUNCTION2() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<DWT_Type>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).FUNCTION2) as usize - ptr as usize
		           },
		           72usize,
		           concat!("Offset of field: ", stringify!(DWT_Type), "::", stringify!(FUNCTION2))
		);
	}
	test_field_FUNCTION2();
	fn test_field_RESERVED2() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<DWT_Type>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).RESERVED2) as usize - ptr as usize
		           },
		           76usize,
		           concat!("Offset of field: ", stringify!(DWT_Type), "::", stringify!(RESERVED2))
		);
	}
	test_field_RESERVED2();
	fn test_field_COMP3() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<DWT_Type>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).COMP3) as usize - ptr as usize
		           },
		           80usize,
		           concat!("Offset of field: ", stringify!(DWT_Type), "::", stringify!(COMP3))
		);
	}
	test_field_COMP3();
	fn test_field_MASK3() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<DWT_Type>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).MASK3) as usize - ptr as usize
		           },
		           84usize,
		           concat!("Offset of field: ", stringify!(DWT_Type), "::", stringify!(MASK3))
		);
	}
	test_field_MASK3();
	fn test_field_FUNCTION3() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<DWT_Type>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).FUNCTION3) as usize - ptr as usize
		           },
		           88usize,
		           concat!("Offset of field: ", stringify!(DWT_Type), "::", stringify!(FUNCTION3))
		);
	}
	test_field_FUNCTION3();
}
#[repr(C)]
pub struct TPI_Type {
	pub SSPSR: u32,
	pub CSPSR: u32,
	pub RESERVED0: [u32; 2usize],
	pub ACPR: u32,
	pub RESERVED1: [u32; 55usize],
	pub SPPR: u32,
	pub RESERVED2: [u32; 131usize],
	pub FFSR: u32,
	pub FFCR: u32,
	pub FSCR: u32,
	pub RESERVED3: [u32; 759usize],
	pub TRIGGER: u32,
	pub FIFO0: u32,
	pub ITATBCTR2: u32,
	pub RESERVED4: [u32; 1usize],
	pub ITATBCTR0: u32,
	pub FIFO1: u32,
	pub ITCTRL: u32,
	pub RESERVED5: [u32; 39usize],
	pub CLAIMSET: u32,
	pub CLAIMCLR: u32,
	pub RESERVED7: [u32; 8usize],
	pub DEVID: u32,
	pub DEVTYPE: u32,
}
#[test]
fn bindgen_test_layout_TPI_Type() {
	assert_eq!(
	           ::core::mem::size_of::<TPI_Type>(),
	           4048usize,
	           concat!("Size of: ", stringify!(TPI_Type))
	);
	assert_eq!(
	           ::core::mem::align_of::<TPI_Type>(),
	           4usize,
	           concat!("Alignment of ", stringify!(TPI_Type))
	);
	fn test_field_SSPSR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<TPI_Type>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).SSPSR) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(TPI_Type), "::", stringify!(SSPSR))
		);
	}
	test_field_SSPSR();
	fn test_field_CSPSR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<TPI_Type>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).CSPSR) as usize - ptr as usize
		           },
		           4usize,
		           concat!("Offset of field: ", stringify!(TPI_Type), "::", stringify!(CSPSR))
		);
	}
	test_field_CSPSR();
	fn test_field_RESERVED0() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<TPI_Type>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).RESERVED0) as usize - ptr as usize
		           },
		           8usize,
		           concat!("Offset of field: ", stringify!(TPI_Type), "::", stringify!(RESERVED0))
		);
	}
	test_field_RESERVED0();
	fn test_field_ACPR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<TPI_Type>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).ACPR) as usize - ptr as usize
		           },
		           16usize,
		           concat!("Offset of field: ", stringify!(TPI_Type), "::", stringify!(ACPR))
		);
	}
	test_field_ACPR();
	fn test_field_RESERVED1() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<TPI_Type>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).RESERVED1) as usize - ptr as usize
		           },
		           20usize,
		           concat!("Offset of field: ", stringify!(TPI_Type), "::", stringify!(RESERVED1))
		);
	}
	test_field_RESERVED1();
	fn test_field_SPPR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<TPI_Type>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).SPPR) as usize - ptr as usize
		           },
		           240usize,
		           concat!("Offset of field: ", stringify!(TPI_Type), "::", stringify!(SPPR))
		);
	}
	test_field_SPPR();
	fn test_field_RESERVED2() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<TPI_Type>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).RESERVED2) as usize - ptr as usize
		           },
		           244usize,
		           concat!("Offset of field: ", stringify!(TPI_Type), "::", stringify!(RESERVED2))
		);
	}
	test_field_RESERVED2();
	fn test_field_FFSR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<TPI_Type>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).FFSR) as usize - ptr as usize
		           },
		           768usize,
		           concat!("Offset of field: ", stringify!(TPI_Type), "::", stringify!(FFSR))
		);
	}
	test_field_FFSR();
	fn test_field_FFCR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<TPI_Type>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).FFCR) as usize - ptr as usize
		           },
		           772usize,
		           concat!("Offset of field: ", stringify!(TPI_Type), "::", stringify!(FFCR))
		);
	}
	test_field_FFCR();
	fn test_field_FSCR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<TPI_Type>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).FSCR) as usize - ptr as usize
		           },
		           776usize,
		           concat!("Offset of field: ", stringify!(TPI_Type), "::", stringify!(FSCR))
		);
	}
	test_field_FSCR();
	fn test_field_RESERVED3() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<TPI_Type>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).RESERVED3) as usize - ptr as usize
		           },
		           780usize,
		           concat!("Offset of field: ", stringify!(TPI_Type), "::", stringify!(RESERVED3))
		);
	}
	test_field_RESERVED3();
	fn test_field_TRIGGER() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<TPI_Type>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).TRIGGER) as usize - ptr as usize
		           },
		           3816usize,
		           concat!("Offset of field: ", stringify!(TPI_Type), "::", stringify!(TRIGGER))
		);
	}
	test_field_TRIGGER();
	fn test_field_FIFO0() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<TPI_Type>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).FIFO0) as usize - ptr as usize
		           },
		           3820usize,
		           concat!("Offset of field: ", stringify!(TPI_Type), "::", stringify!(FIFO0))
		);
	}
	test_field_FIFO0();
	fn test_field_ITATBCTR2() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<TPI_Type>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).ITATBCTR2) as usize - ptr as usize
		           },
		           3824usize,
		           concat!("Offset of field: ", stringify!(TPI_Type), "::", stringify!(ITATBCTR2))
		);
	}
	test_field_ITATBCTR2();
	fn test_field_RESERVED4() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<TPI_Type>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).RESERVED4) as usize - ptr as usize
		           },
		           3828usize,
		           concat!("Offset of field: ", stringify!(TPI_Type), "::", stringify!(RESERVED4))
		);
	}
	test_field_RESERVED4();
	fn test_field_ITATBCTR0() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<TPI_Type>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).ITATBCTR0) as usize - ptr as usize
		           },
		           3832usize,
		           concat!("Offset of field: ", stringify!(TPI_Type), "::", stringify!(ITATBCTR0))
		);
	}
	test_field_ITATBCTR0();
	fn test_field_FIFO1() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<TPI_Type>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).FIFO1) as usize - ptr as usize
		           },
		           3836usize,
		           concat!("Offset of field: ", stringify!(TPI_Type), "::", stringify!(FIFO1))
		);
	}
	test_field_FIFO1();
	fn test_field_ITCTRL() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<TPI_Type>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).ITCTRL) as usize - ptr as usize
		           },
		           3840usize,
		           concat!("Offset of field: ", stringify!(TPI_Type), "::", stringify!(ITCTRL))
		);
	}
	test_field_ITCTRL();
	fn test_field_RESERVED5() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<TPI_Type>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).RESERVED5) as usize - ptr as usize
		           },
		           3844usize,
		           concat!("Offset of field: ", stringify!(TPI_Type), "::", stringify!(RESERVED5))
		);
	}
	test_field_RESERVED5();
	fn test_field_CLAIMSET() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<TPI_Type>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).CLAIMSET) as usize - ptr as usize
		           },
		           4000usize,
		           concat!("Offset of field: ", stringify!(TPI_Type), "::", stringify!(CLAIMSET))
		);
	}
	test_field_CLAIMSET();
	fn test_field_CLAIMCLR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<TPI_Type>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).CLAIMCLR) as usize - ptr as usize
		           },
		           4004usize,
		           concat!("Offset of field: ", stringify!(TPI_Type), "::", stringify!(CLAIMCLR))
		);
	}
	test_field_CLAIMCLR();
	fn test_field_RESERVED7() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<TPI_Type>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).RESERVED7) as usize - ptr as usize
		           },
		           4008usize,
		           concat!("Offset of field: ", stringify!(TPI_Type), "::", stringify!(RESERVED7))
		);
	}
	test_field_RESERVED7();
	fn test_field_DEVID() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<TPI_Type>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).DEVID) as usize - ptr as usize
		           },
		           4040usize,
		           concat!("Offset of field: ", stringify!(TPI_Type), "::", stringify!(DEVID))
		);
	}
	test_field_DEVID();
	fn test_field_DEVTYPE() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<TPI_Type>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).DEVTYPE) as usize - ptr as usize
		           },
		           4044usize,
		           concat!("Offset of field: ", stringify!(TPI_Type), "::", stringify!(DEVTYPE))
		);
	}
	test_field_DEVTYPE();
}
#[repr(C)]
pub struct MPU_Type {
	pub TYPE: u32,
	pub CTRL: u32,
	pub RNR: u32,
	pub RBAR: u32,
	pub RASR: u32,
	pub RBAR_A1: u32,
	pub RASR_A1: u32,
	pub RBAR_A2: u32,
	pub RASR_A2: u32,
	pub RBAR_A3: u32,
	pub RASR_A3: u32,
}
#[test]
fn bindgen_test_layout_MPU_Type() {
	assert_eq!(
	           ::core::mem::size_of::<MPU_Type>(),
	           44usize,
	           concat!("Size of: ", stringify!(MPU_Type))
	);
	assert_eq!(
	           ::core::mem::align_of::<MPU_Type>(),
	           4usize,
	           concat!("Alignment of ", stringify!(MPU_Type))
	);
	fn test_field_TYPE() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<MPU_Type>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).TYPE) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(MPU_Type), "::", stringify!(TYPE))
		);
	}
	test_field_TYPE();
	fn test_field_CTRL() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<MPU_Type>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).CTRL) as usize - ptr as usize
		           },
		           4usize,
		           concat!("Offset of field: ", stringify!(MPU_Type), "::", stringify!(CTRL))
		);
	}
	test_field_CTRL();
	fn test_field_RNR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<MPU_Type>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).RNR) as usize - ptr as usize
		           },
		           8usize,
		           concat!("Offset of field: ", stringify!(MPU_Type), "::", stringify!(RNR))
		);
	}
	test_field_RNR();
	fn test_field_RBAR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<MPU_Type>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).RBAR) as usize - ptr as usize
		           },
		           12usize,
		           concat!("Offset of field: ", stringify!(MPU_Type), "::", stringify!(RBAR))
		);
	}
	test_field_RBAR();
	fn test_field_RASR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<MPU_Type>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).RASR) as usize - ptr as usize
		           },
		           16usize,
		           concat!("Offset of field: ", stringify!(MPU_Type), "::", stringify!(RASR))
		);
	}
	test_field_RASR();
	fn test_field_RBAR_A1() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<MPU_Type>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).RBAR_A1) as usize - ptr as usize
		           },
		           20usize,
		           concat!("Offset of field: ", stringify!(MPU_Type), "::", stringify!(RBAR_A1))
		);
	}
	test_field_RBAR_A1();
	fn test_field_RASR_A1() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<MPU_Type>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).RASR_A1) as usize - ptr as usize
		           },
		           24usize,
		           concat!("Offset of field: ", stringify!(MPU_Type), "::", stringify!(RASR_A1))
		);
	}
	test_field_RASR_A1();
	fn test_field_RBAR_A2() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<MPU_Type>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).RBAR_A2) as usize - ptr as usize
		           },
		           28usize,
		           concat!("Offset of field: ", stringify!(MPU_Type), "::", stringify!(RBAR_A2))
		);
	}
	test_field_RBAR_A2();
	fn test_field_RASR_A2() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<MPU_Type>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).RASR_A2) as usize - ptr as usize
		           },
		           32usize,
		           concat!("Offset of field: ", stringify!(MPU_Type), "::", stringify!(RASR_A2))
		);
	}
	test_field_RASR_A2();
	fn test_field_RBAR_A3() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<MPU_Type>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).RBAR_A3) as usize - ptr as usize
		           },
		           36usize,
		           concat!("Offset of field: ", stringify!(MPU_Type), "::", stringify!(RBAR_A3))
		);
	}
	test_field_RBAR_A3();
	fn test_field_RASR_A3() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<MPU_Type>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).RASR_A3) as usize - ptr as usize
		           },
		           40usize,
		           concat!("Offset of field: ", stringify!(MPU_Type), "::", stringify!(RASR_A3))
		);
	}
	test_field_RASR_A3();
}
#[repr(C)]
pub struct FPU_Type {
	pub RESERVED0: [u32; 1usize],
	pub FPCCR: u32,
	pub FPCAR: u32,
	pub FPDSCR: u32,
	pub MVFR0: u32,
	pub MVFR1: u32,
	pub MVFR2: u32,
}
#[test]
fn bindgen_test_layout_FPU_Type() {
	assert_eq!(
	           ::core::mem::size_of::<FPU_Type>(),
	           28usize,
	           concat!("Size of: ", stringify!(FPU_Type))
	);
	assert_eq!(
	           ::core::mem::align_of::<FPU_Type>(),
	           4usize,
	           concat!("Alignment of ", stringify!(FPU_Type))
	);
	fn test_field_RESERVED0() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<FPU_Type>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).RESERVED0) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(FPU_Type), "::", stringify!(RESERVED0))
		);
	}
	test_field_RESERVED0();
	fn test_field_FPCCR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<FPU_Type>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).FPCCR) as usize - ptr as usize
		           },
		           4usize,
		           concat!("Offset of field: ", stringify!(FPU_Type), "::", stringify!(FPCCR))
		);
	}
	test_field_FPCCR();
	fn test_field_FPCAR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<FPU_Type>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).FPCAR) as usize - ptr as usize
		           },
		           8usize,
		           concat!("Offset of field: ", stringify!(FPU_Type), "::", stringify!(FPCAR))
		);
	}
	test_field_FPCAR();
	fn test_field_FPDSCR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<FPU_Type>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).FPDSCR) as usize - ptr as usize
		           },
		           12usize,
		           concat!("Offset of field: ", stringify!(FPU_Type), "::", stringify!(FPDSCR))
		);
	}
	test_field_FPDSCR();
	fn test_field_MVFR0() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<FPU_Type>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).MVFR0) as usize - ptr as usize
		           },
		           16usize,
		           concat!("Offset of field: ", stringify!(FPU_Type), "::", stringify!(MVFR0))
		);
	}
	test_field_MVFR0();
	fn test_field_MVFR1() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<FPU_Type>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).MVFR1) as usize - ptr as usize
		           },
		           20usize,
		           concat!("Offset of field: ", stringify!(FPU_Type), "::", stringify!(MVFR1))
		);
	}
	test_field_MVFR1();
	fn test_field_MVFR2() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<FPU_Type>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).MVFR2) as usize - ptr as usize
		           },
		           24usize,
		           concat!("Offset of field: ", stringify!(FPU_Type), "::", stringify!(MVFR2))
		);
	}
	test_field_MVFR2();
}
#[repr(C)]
pub struct CoreDebug_Type {
	pub DHCSR: u32,
	pub DCRSR: u32,
	pub DCRDR: u32,
	pub DEMCR: u32,
}
#[test]
fn bindgen_test_layout_CoreDebug_Type() {
	assert_eq!(
	           ::core::mem::size_of::<CoreDebug_Type>(),
	           16usize,
	           concat!("Size of: ", stringify!(CoreDebug_Type))
	);
	assert_eq!(
	           ::core::mem::align_of::<CoreDebug_Type>(),
	           4usize,
	           concat!("Alignment of ", stringify!(CoreDebug_Type))
	);
	fn test_field_DHCSR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<CoreDebug_Type>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).DHCSR) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(CoreDebug_Type), "::", stringify!(DHCSR))
		);
	}
	test_field_DHCSR();
	fn test_field_DCRSR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<CoreDebug_Type>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).DCRSR) as usize - ptr as usize
		           },
		           4usize,
		           concat!("Offset of field: ", stringify!(CoreDebug_Type), "::", stringify!(DCRSR))
		);
	}
	test_field_DCRSR();
	fn test_field_DCRDR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<CoreDebug_Type>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).DCRDR) as usize - ptr as usize
		           },
		           8usize,
		           concat!("Offset of field: ", stringify!(CoreDebug_Type), "::", stringify!(DCRDR))
		);
	}
	test_field_DCRDR();
	fn test_field_DEMCR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<CoreDebug_Type>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).DEMCR) as usize - ptr as usize
		           },
		           12usize,
		           concat!("Offset of field: ", stringify!(CoreDebug_Type), "::", stringify!(DEMCR))
		);
	}
	test_field_DEMCR();
}
#[repr(C)]
pub struct ARM_MPU_Region_t {
	pub RBAR: u32,
	pub RASR: u32,
}
#[test]
fn bindgen_test_layout_ARM_MPU_Region_t() {
	assert_eq!(
	           ::core::mem::size_of::<ARM_MPU_Region_t>(),
	           8usize,
	           concat!("Size of: ", stringify!(ARM_MPU_Region_t))
	);
	assert_eq!(
	           ::core::mem::align_of::<ARM_MPU_Region_t>(),
	           4usize,
	           concat!("Alignment of ", stringify!(ARM_MPU_Region_t))
	);
	fn test_field_RBAR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<ARM_MPU_Region_t>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).RBAR) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(ARM_MPU_Region_t), "::", stringify!(RBAR))
		);
	}
	test_field_RBAR();
	fn test_field_RASR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<ARM_MPU_Region_t>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).RASR) as usize - ptr as usize
		           },
		           4usize,
		           concat!("Offset of field: ", stringify!(ARM_MPU_Region_t), "::", stringify!(RASR))
		);
	}
	test_field_RASR();
}
extern "C" {
	pub static mut ITM_RxBuffer: i32;
}
extern "C" {
	#[doc = "< AHB prescalers table values"]
	pub static AHBPrescTable: [u32; 16usize];
}
extern "C" {
	#[doc = "< APB prescalers table values"]
	pub static APBPrescTable: [u32; 8usize];
}
extern "C" {
	#[doc = "< MSI ranges table values"]
	pub static MSIRangeTable: [u32; 16usize];
}
extern "C" {
	#[doc = "< SMPS factor ranges table values"]
	pub static mut SmpsPrescalerTable: [[u32; 6usize]; 4usize];
}
extern "C" {
	#[doc = " @addtogroup STM32WBxx_System_Exported_Functions"]
	#[doc = " @{"]
	pub fn SystemInit();
}
extern "C" {
	pub fn SystemCoreClockUpdate();
}
#[doc = " @brief Analog to Digital Converter"]
#[repr(C)]
pub struct ADC_TypeDef {
	#[doc = "< ADC interrupt and status register,             Address offset: 0x00"]
	pub ISR: u32,
	#[doc = "< ADC interrupt enable register,                 Address offset: 0x04"]
	pub IER: u32,
	#[doc = "< ADC control register,                          Address offset: 0x08"]
	pub CR: u32,
	#[doc = "< ADC configuration register 1,                  Address offset: 0x0C"]
	pub CFGR: u32,
	#[doc = "< ADC configuration register 2,                  Address offset: 0x10"]
	pub CFGR2: u32,
	#[doc = "< ADC sampling time register 1,                  Address offset: 0x14"]
	pub SMPR1: u32,
	#[doc = "< ADC sampling time register 2,                  Address offset: 0x18"]
	pub SMPR2: u32,
	#[doc = "< Reserved,                                                      0x1C"]
	pub RESERVED1: u32,
	#[doc = "< ADC analog watchdog 1 threshold register,      Address offset: 0x20"]
	pub TR1: u32,
	#[doc = "< ADC analog watchdog 2 threshold register,      Address offset: 0x24"]
	pub TR2: u32,
	#[doc = "< ADC analog watchdog 3 threshold register,      Address offset: 0x28"]
	pub TR3: u32,
	#[doc = "< Reserved,                                                      0x2C"]
	pub RESERVED2: u32,
	#[doc = "< ADC group regular sequencer register 1,        Address offset: 0x30"]
	pub SQR1: u32,
	#[doc = "< ADC group regular sequencer register 2,        Address offset: 0x34"]
	pub SQR2: u32,
	#[doc = "< ADC group regular sequencer register 3,        Address offset: 0x38"]
	pub SQR3: u32,
	#[doc = "< ADC group regular sequencer register 4,        Address offset: 0x3C"]
	pub SQR4: u32,
	#[doc = "< ADC group regular data register,               Address offset: 0x40"]
	pub DR: u32,
	#[doc = "< Reserved,                                                      0x44"]
	pub RESERVED3: u32,
	#[doc = "< Reserved,                                                      0x48"]
	pub RESERVED4: u32,
	#[doc = "< ADC group injected sequencer register,         Address offset: 0x4C"]
	pub JSQR: u32,
	#[doc = "< Reserved,                                               0x50 - 0x5C"]
	pub RESERVED5: [u32; 4usize],
	#[doc = "< ADC offset register 1,                         Address offset: 0x60"]
	pub OFR1: u32,
	#[doc = "< ADC offset register 2,                         Address offset: 0x64"]
	pub OFR2: u32,
	#[doc = "< ADC offset register 3,                         Address offset: 0x68"]
	pub OFR3: u32,
	#[doc = "< ADC offset register 4,                         Address offset: 0x6C"]
	pub OFR4: u32,
	#[doc = "< Reserved,                                               0x70 - 0x7C"]
	pub RESERVED6: [u32; 4usize],
	#[doc = "< ADC group injected rank 1 data register,       Address offset: 0x80"]
	pub JDR1: u32,
	#[doc = "< ADC group injected rank 2 data register,       Address offset: 0x84"]
	pub JDR2: u32,
	#[doc = "< ADC group injected rank 3 data register,       Address offset: 0x88"]
	pub JDR3: u32,
	#[doc = "< ADC group injected rank 4 data register,       Address offset: 0x8C"]
	pub JDR4: u32,
	#[doc = "< Reserved,                                             0x090 - 0x09C"]
	pub RESERVED7: [u32; 4usize],
	#[doc = "< ADC analog watchdog 1 configuration register,  Address offset: 0xA0"]
	pub AWD2CR: u32,
	#[doc = "< ADC analog watchdog 3 Configuration Register,  Address offset: 0xA4"]
	pub AWD3CR: u32,
	#[doc = "< Reserved,                                                     0x0A8"]
	pub RESERVED8: u32,
	#[doc = "< Reserved,                                                     0x0AC"]
	pub RESERVED9: u32,
	#[doc = "< ADC differential mode selection register,      Address offset: 0xB0"]
	pub DIFSEL: u32,
	#[doc = "< ADC calibration factors,                       Address offset: 0xB4"]
	pub CALFACT: u32,
}
#[test]
fn bindgen_test_layout_ADC_TypeDef() {
	assert_eq!(
	           ::core::mem::size_of::<ADC_TypeDef>(),
	           184usize,
	           concat!("Size of: ", stringify!(ADC_TypeDef))
	);
	assert_eq!(
	           ::core::mem::align_of::<ADC_TypeDef>(),
	           4usize,
	           concat!("Alignment of ", stringify!(ADC_TypeDef))
	);
	fn test_field_ISR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<ADC_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).ISR) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(ADC_TypeDef), "::", stringify!(ISR))
		);
	}
	test_field_ISR();
	fn test_field_IER() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<ADC_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).IER) as usize - ptr as usize
		           },
		           4usize,
		           concat!("Offset of field: ", stringify!(ADC_TypeDef), "::", stringify!(IER))
		);
	}
	test_field_IER();
	fn test_field_CR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<ADC_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).CR) as usize - ptr as usize
		           },
		           8usize,
		           concat!("Offset of field: ", stringify!(ADC_TypeDef), "::", stringify!(CR))
		);
	}
	test_field_CR();
	fn test_field_CFGR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<ADC_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).CFGR) as usize - ptr as usize
		           },
		           12usize,
		           concat!("Offset of field: ", stringify!(ADC_TypeDef), "::", stringify!(CFGR))
		);
	}
	test_field_CFGR();
	fn test_field_CFGR2() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<ADC_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).CFGR2) as usize - ptr as usize
		           },
		           16usize,
		           concat!("Offset of field: ", stringify!(ADC_TypeDef), "::", stringify!(CFGR2))
		);
	}
	test_field_CFGR2();
	fn test_field_SMPR1() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<ADC_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).SMPR1) as usize - ptr as usize
		           },
		           20usize,
		           concat!("Offset of field: ", stringify!(ADC_TypeDef), "::", stringify!(SMPR1))
		);
	}
	test_field_SMPR1();
	fn test_field_SMPR2() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<ADC_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).SMPR2) as usize - ptr as usize
		           },
		           24usize,
		           concat!("Offset of field: ", stringify!(ADC_TypeDef), "::", stringify!(SMPR2))
		);
	}
	test_field_SMPR2();
	fn test_field_RESERVED1() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<ADC_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).RESERVED1) as usize - ptr as usize
		           },
		           28usize,
		           concat!("Offset of field: ", stringify!(ADC_TypeDef), "::", stringify!(RESERVED1))
		);
	}
	test_field_RESERVED1();
	fn test_field_TR1() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<ADC_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).TR1) as usize - ptr as usize
		           },
		           32usize,
		           concat!("Offset of field: ", stringify!(ADC_TypeDef), "::", stringify!(TR1))
		);
	}
	test_field_TR1();
	fn test_field_TR2() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<ADC_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).TR2) as usize - ptr as usize
		           },
		           36usize,
		           concat!("Offset of field: ", stringify!(ADC_TypeDef), "::", stringify!(TR2))
		);
	}
	test_field_TR2();
	fn test_field_TR3() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<ADC_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).TR3) as usize - ptr as usize
		           },
		           40usize,
		           concat!("Offset of field: ", stringify!(ADC_TypeDef), "::", stringify!(TR3))
		);
	}
	test_field_TR3();
	fn test_field_RESERVED2() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<ADC_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).RESERVED2) as usize - ptr as usize
		           },
		           44usize,
		           concat!("Offset of field: ", stringify!(ADC_TypeDef), "::", stringify!(RESERVED2))
		);
	}
	test_field_RESERVED2();
	fn test_field_SQR1() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<ADC_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).SQR1) as usize - ptr as usize
		           },
		           48usize,
		           concat!("Offset of field: ", stringify!(ADC_TypeDef), "::", stringify!(SQR1))
		);
	}
	test_field_SQR1();
	fn test_field_SQR2() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<ADC_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).SQR2) as usize - ptr as usize
		           },
		           52usize,
		           concat!("Offset of field: ", stringify!(ADC_TypeDef), "::", stringify!(SQR2))
		);
	}
	test_field_SQR2();
	fn test_field_SQR3() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<ADC_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).SQR3) as usize - ptr as usize
		           },
		           56usize,
		           concat!("Offset of field: ", stringify!(ADC_TypeDef), "::", stringify!(SQR3))
		);
	}
	test_field_SQR3();
	fn test_field_SQR4() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<ADC_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).SQR4) as usize - ptr as usize
		           },
		           60usize,
		           concat!("Offset of field: ", stringify!(ADC_TypeDef), "::", stringify!(SQR4))
		);
	}
	test_field_SQR4();
	fn test_field_DR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<ADC_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).DR) as usize - ptr as usize
		           },
		           64usize,
		           concat!("Offset of field: ", stringify!(ADC_TypeDef), "::", stringify!(DR))
		);
	}
	test_field_DR();
	fn test_field_RESERVED3() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<ADC_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).RESERVED3) as usize - ptr as usize
		           },
		           68usize,
		           concat!("Offset of field: ", stringify!(ADC_TypeDef), "::", stringify!(RESERVED3))
		);
	}
	test_field_RESERVED3();
	fn test_field_RESERVED4() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<ADC_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).RESERVED4) as usize - ptr as usize
		           },
		           72usize,
		           concat!("Offset of field: ", stringify!(ADC_TypeDef), "::", stringify!(RESERVED4))
		);
	}
	test_field_RESERVED4();
	fn test_field_JSQR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<ADC_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).JSQR) as usize - ptr as usize
		           },
		           76usize,
		           concat!("Offset of field: ", stringify!(ADC_TypeDef), "::", stringify!(JSQR))
		);
	}
	test_field_JSQR();
	fn test_field_RESERVED5() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<ADC_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).RESERVED5) as usize - ptr as usize
		           },
		           80usize,
		           concat!("Offset of field: ", stringify!(ADC_TypeDef), "::", stringify!(RESERVED5))
		);
	}
	test_field_RESERVED5();
	fn test_field_OFR1() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<ADC_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).OFR1) as usize - ptr as usize
		           },
		           96usize,
		           concat!("Offset of field: ", stringify!(ADC_TypeDef), "::", stringify!(OFR1))
		);
	}
	test_field_OFR1();
	fn test_field_OFR2() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<ADC_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).OFR2) as usize - ptr as usize
		           },
		           100usize,
		           concat!("Offset of field: ", stringify!(ADC_TypeDef), "::", stringify!(OFR2))
		);
	}
	test_field_OFR2();
	fn test_field_OFR3() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<ADC_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).OFR3) as usize - ptr as usize
		           },
		           104usize,
		           concat!("Offset of field: ", stringify!(ADC_TypeDef), "::", stringify!(OFR3))
		);
	}
	test_field_OFR3();
	fn test_field_OFR4() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<ADC_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).OFR4) as usize - ptr as usize
		           },
		           108usize,
		           concat!("Offset of field: ", stringify!(ADC_TypeDef), "::", stringify!(OFR4))
		);
	}
	test_field_OFR4();
	fn test_field_RESERVED6() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<ADC_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).RESERVED6) as usize - ptr as usize
		           },
		           112usize,
		           concat!("Offset of field: ", stringify!(ADC_TypeDef), "::", stringify!(RESERVED6))
		);
	}
	test_field_RESERVED6();
	fn test_field_JDR1() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<ADC_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).JDR1) as usize - ptr as usize
		           },
		           128usize,
		           concat!("Offset of field: ", stringify!(ADC_TypeDef), "::", stringify!(JDR1))
		);
	}
	test_field_JDR1();
	fn test_field_JDR2() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<ADC_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).JDR2) as usize - ptr as usize
		           },
		           132usize,
		           concat!("Offset of field: ", stringify!(ADC_TypeDef), "::", stringify!(JDR2))
		);
	}
	test_field_JDR2();
	fn test_field_JDR3() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<ADC_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).JDR3) as usize - ptr as usize
		           },
		           136usize,
		           concat!("Offset of field: ", stringify!(ADC_TypeDef), "::", stringify!(JDR3))
		);
	}
	test_field_JDR3();
	fn test_field_JDR4() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<ADC_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).JDR4) as usize - ptr as usize
		           },
		           140usize,
		           concat!("Offset of field: ", stringify!(ADC_TypeDef), "::", stringify!(JDR4))
		);
	}
	test_field_JDR4();
	fn test_field_RESERVED7() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<ADC_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).RESERVED7) as usize - ptr as usize
		           },
		           144usize,
		           concat!("Offset of field: ", stringify!(ADC_TypeDef), "::", stringify!(RESERVED7))
		);
	}
	test_field_RESERVED7();
	fn test_field_AWD2CR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<ADC_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).AWD2CR) as usize - ptr as usize
		           },
		           160usize,
		           concat!("Offset of field: ", stringify!(ADC_TypeDef), "::", stringify!(AWD2CR))
		);
	}
	test_field_AWD2CR();
	fn test_field_AWD3CR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<ADC_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).AWD3CR) as usize - ptr as usize
		           },
		           164usize,
		           concat!("Offset of field: ", stringify!(ADC_TypeDef), "::", stringify!(AWD3CR))
		);
	}
	test_field_AWD3CR();
	fn test_field_RESERVED8() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<ADC_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).RESERVED8) as usize - ptr as usize
		           },
		           168usize,
		           concat!("Offset of field: ", stringify!(ADC_TypeDef), "::", stringify!(RESERVED8))
		);
	}
	test_field_RESERVED8();
	fn test_field_RESERVED9() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<ADC_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).RESERVED9) as usize - ptr as usize
		           },
		           172usize,
		           concat!("Offset of field: ", stringify!(ADC_TypeDef), "::", stringify!(RESERVED9))
		);
	}
	test_field_RESERVED9();
	fn test_field_DIFSEL() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<ADC_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).DIFSEL) as usize - ptr as usize
		           },
		           176usize,
		           concat!("Offset of field: ", stringify!(ADC_TypeDef), "::", stringify!(DIFSEL))
		);
	}
	test_field_DIFSEL();
	fn test_field_CALFACT() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<ADC_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).CALFACT) as usize - ptr as usize
		           },
		           180usize,
		           concat!("Offset of field: ", stringify!(ADC_TypeDef), "::", stringify!(CALFACT))
		);
	}
	test_field_CALFACT();
}
#[repr(C)]
pub struct ADC_Common_TypeDef {
	#[doc = "< Reserved,                                      Address offset: ADC1 base address + 0x300"]
	pub RESERVED1: u32,
	#[doc = "< Reserved,                                      Address offset: ADC1 base address + 0x304"]
	pub RESERVED2: u32,
	#[doc = "< ADC common configuration register,             Address offset: ADC1 base address + 0x308"]
	pub CCR: u32,
	#[doc = "< Reserved,                                      Address offset: ADC1 base address + 0x30C"]
	pub RESERVED3: u32,
}
#[test]
fn bindgen_test_layout_ADC_Common_TypeDef() {
	assert_eq!(
	           ::core::mem::size_of::<ADC_Common_TypeDef>(),
	           16usize,
	           concat!("Size of: ", stringify!(ADC_Common_TypeDef))
	);
	assert_eq!(
	           ::core::mem::align_of::<ADC_Common_TypeDef>(),
	           4usize,
	           concat!("Alignment of ", stringify!(ADC_Common_TypeDef))
	);
	fn test_field_RESERVED1() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<ADC_Common_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).RESERVED1) as usize - ptr as usize
		           },
		           0usize,
		           concat!(
			"Offset of field: ",
			stringify!(ADC_Common_TypeDef),
			"::",
			stringify!(RESERVED1)
		)
		);
	}
	test_field_RESERVED1();
	fn test_field_RESERVED2() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<ADC_Common_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).RESERVED2) as usize - ptr as usize
		           },
		           4usize,
		           concat!(
			"Offset of field: ",
			stringify!(ADC_Common_TypeDef),
			"::",
			stringify!(RESERVED2)
		)
		);
	}
	test_field_RESERVED2();
	fn test_field_CCR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<ADC_Common_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).CCR) as usize - ptr as usize
		           },
		           8usize,
		           concat!("Offset of field: ", stringify!(ADC_Common_TypeDef), "::", stringify!(CCR))
		);
	}
	test_field_CCR();
	fn test_field_RESERVED3() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<ADC_Common_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).RESERVED3) as usize - ptr as usize
		           },
		           12usize,
		           concat!(
			"Offset of field: ",
			stringify!(ADC_Common_TypeDef),
			"::",
			stringify!(RESERVED3)
		)
		);
	}
	test_field_RESERVED3();
}
#[doc = " @brief Comparator"]
#[repr(C)]
pub struct COMP_TypeDef {
	#[doc = "< COMP control and status register,               Address offset: 0x00"]
	pub CSR: u32,
}
#[test]
fn bindgen_test_layout_COMP_TypeDef() {
	assert_eq!(
	           ::core::mem::size_of::<COMP_TypeDef>(),
	           4usize,
	           concat!("Size of: ", stringify!(COMP_TypeDef))
	);
	assert_eq!(
	           ::core::mem::align_of::<COMP_TypeDef>(),
	           4usize,
	           concat!("Alignment of ", stringify!(COMP_TypeDef))
	);
	fn test_field_CSR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<COMP_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).CSR) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(COMP_TypeDef), "::", stringify!(CSR))
		);
	}
	test_field_CSR();
}
#[repr(C)]
pub struct COMP_Common_TypeDef {
	#[doc = "< COMP control and status register, used for bits common to several COMP instances, Address offset: 0x00"]
	pub CSR: u32,
}
#[test]
fn bindgen_test_layout_COMP_Common_TypeDef() {
	assert_eq!(
	           ::core::mem::size_of::<COMP_Common_TypeDef>(),
	           4usize,
	           concat!("Size of: ", stringify!(COMP_Common_TypeDef))
	);
	assert_eq!(
	           ::core::mem::align_of::<COMP_Common_TypeDef>(),
	           4usize,
	           concat!("Alignment of ", stringify!(COMP_Common_TypeDef))
	);
	fn test_field_CSR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<COMP_Common_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).CSR) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(COMP_Common_TypeDef), "::", stringify!(CSR))
		);
	}
	test_field_CSR();
}
#[doc = " @brief CRC calculation unit"]
#[repr(C)]
pub struct CRC_TypeDef {
	#[doc = "< CRC Data register,                           Address offset: 0x00"]
	pub DR: u32,
	#[doc = "< CRC Independent data register,               Address offset: 0x04"]
	pub IDR: u32,
	#[doc = "< CRC Control register,                        Address offset: 0x08"]
	pub CR: u32,
	#[doc = "< Reserved,                                                    0x0C"]
	pub RESERVED2: u32,
	#[doc = "< Initial CRC value register,                  Address offset: 0x10"]
	pub INIT: u32,
	#[doc = "< CRC polynomial register,                     Address offset: 0x14"]
	pub POL: u32,
}
#[test]
fn bindgen_test_layout_CRC_TypeDef() {
	assert_eq!(
	           ::core::mem::size_of::<CRC_TypeDef>(),
	           24usize,
	           concat!("Size of: ", stringify!(CRC_TypeDef))
	);
	assert_eq!(
	           ::core::mem::align_of::<CRC_TypeDef>(),
	           4usize,
	           concat!("Alignment of ", stringify!(CRC_TypeDef))
	);
	fn test_field_DR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<CRC_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).DR) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(CRC_TypeDef), "::", stringify!(DR))
		);
	}
	test_field_DR();
	fn test_field_IDR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<CRC_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).IDR) as usize - ptr as usize
		           },
		           4usize,
		           concat!("Offset of field: ", stringify!(CRC_TypeDef), "::", stringify!(IDR))
		);
	}
	test_field_IDR();
	fn test_field_CR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<CRC_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).CR) as usize - ptr as usize
		           },
		           8usize,
		           concat!("Offset of field: ", stringify!(CRC_TypeDef), "::", stringify!(CR))
		);
	}
	test_field_CR();
	fn test_field_RESERVED2() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<CRC_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).RESERVED2) as usize - ptr as usize
		           },
		           12usize,
		           concat!("Offset of field: ", stringify!(CRC_TypeDef), "::", stringify!(RESERVED2))
		);
	}
	test_field_RESERVED2();
	fn test_field_INIT() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<CRC_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).INIT) as usize - ptr as usize
		           },
		           16usize,
		           concat!("Offset of field: ", stringify!(CRC_TypeDef), "::", stringify!(INIT))
		);
	}
	test_field_INIT();
	fn test_field_POL() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<CRC_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).POL) as usize - ptr as usize
		           },
		           20usize,
		           concat!("Offset of field: ", stringify!(CRC_TypeDef), "::", stringify!(POL))
		);
	}
	test_field_POL();
}
#[doc = " @brief Debug MCU"]
#[repr(C)]
pub struct DBGMCU_TypeDef {
	#[doc = "< MCU device ID code,                          Address offset: 0x00"]
	pub IDCODE: u32,
	#[doc = "< Debug MCU configuration register,            Address offset: 0x04"]
	pub CR: u32,
	#[doc = "< Reserved,                                               0x08-0x38"]
	pub RESERVED1: [u32; 13usize],
	#[doc = "< Debug MCU CPU1 APB1 freeze register,         Address offset: 0x3C"]
	pub APB1FZR1: u32,
	#[doc = "< Debug MCU CPU2 APB1 freeze register,         Address offset: 0x40"]
	pub C2APB1FZR1: u32,
	#[doc = "< Debug MCU CPU1 APB1 freeze register,         Address offset: 0x44"]
	pub APB1FZR2: u32,
	#[doc = "< Debug MCU CPU2 APB1 freeze register,         Address offset: 0x48"]
	pub C2APB1FZR2: u32,
	#[doc = "< Debug MCU CPU1 APB2 freeze register,         Address offset: 0x4C"]
	pub APB2FZR: u32,
	#[doc = "< Debug MCU CPU2 APB2 freeze register,         Address offset: 0x50"]
	pub C2APB2FZR: u32,
}
#[test]
fn bindgen_test_layout_DBGMCU_TypeDef() {
	assert_eq!(
	           ::core::mem::size_of::<DBGMCU_TypeDef>(),
	           84usize,
	           concat!("Size of: ", stringify!(DBGMCU_TypeDef))
	);
	assert_eq!(
	           ::core::mem::align_of::<DBGMCU_TypeDef>(),
	           4usize,
	           concat!("Alignment of ", stringify!(DBGMCU_TypeDef))
	);
	fn test_field_IDCODE() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<DBGMCU_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).IDCODE) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(DBGMCU_TypeDef), "::", stringify!(IDCODE))
		);
	}
	test_field_IDCODE();
	fn test_field_CR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<DBGMCU_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).CR) as usize - ptr as usize
		           },
		           4usize,
		           concat!("Offset of field: ", stringify!(DBGMCU_TypeDef), "::", stringify!(CR))
		);
	}
	test_field_CR();
	fn test_field_RESERVED1() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<DBGMCU_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).RESERVED1) as usize - ptr as usize
		           },
		           8usize,
		           concat!("Offset of field: ", stringify!(DBGMCU_TypeDef), "::", stringify!(RESERVED1))
		);
	}
	test_field_RESERVED1();
	fn test_field_APB1FZR1() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<DBGMCU_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).APB1FZR1) as usize - ptr as usize
		           },
		           60usize,
		           concat!("Offset of field: ", stringify!(DBGMCU_TypeDef), "::", stringify!(APB1FZR1))
		);
	}
	test_field_APB1FZR1();
	fn test_field_C2APB1FZR1() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<DBGMCU_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).C2APB1FZR1) as usize - ptr as usize
		           },
		           64usize,
		           concat!("Offset of field: ", stringify!(DBGMCU_TypeDef), "::", stringify!(C2APB1FZR1))
		);
	}
	test_field_C2APB1FZR1();
	fn test_field_APB1FZR2() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<DBGMCU_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).APB1FZR2) as usize - ptr as usize
		           },
		           68usize,
		           concat!("Offset of field: ", stringify!(DBGMCU_TypeDef), "::", stringify!(APB1FZR2))
		);
	}
	test_field_APB1FZR2();
	fn test_field_C2APB1FZR2() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<DBGMCU_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).C2APB1FZR2) as usize - ptr as usize
		           },
		           72usize,
		           concat!("Offset of field: ", stringify!(DBGMCU_TypeDef), "::", stringify!(C2APB1FZR2))
		);
	}
	test_field_C2APB1FZR2();
	fn test_field_APB2FZR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<DBGMCU_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).APB2FZR) as usize - ptr as usize
		           },
		           76usize,
		           concat!("Offset of field: ", stringify!(DBGMCU_TypeDef), "::", stringify!(APB2FZR))
		);
	}
	test_field_APB2FZR();
	fn test_field_C2APB2FZR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<DBGMCU_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).C2APB2FZR) as usize - ptr as usize
		           },
		           80usize,
		           concat!("Offset of field: ", stringify!(DBGMCU_TypeDef), "::", stringify!(C2APB2FZR))
		);
	}
	test_field_C2APB2FZR();
}
#[doc = " @brief DMA Controller"]
#[repr(C)]
pub struct DMA_Channel_TypeDef {
	#[doc = "< DMA channel x configuration register        0x00"]
	pub CCR: u32,
	#[doc = "< DMA channel x number of data register       0x04"]
	pub CNDTR: u32,
	#[doc = "< DMA channel x peripheral address register   0x08"]
	pub CPAR: u32,
	#[doc = "< DMA channel x memory address register       0x0C"]
	pub CMAR: u32,
	#[doc = "< Reserved,                                   0x10"]
	pub RESERVED: u32,
}
#[test]
fn bindgen_test_layout_DMA_Channel_TypeDef() {
	assert_eq!(
	           ::core::mem::size_of::<DMA_Channel_TypeDef>(),
	           20usize,
	           concat!("Size of: ", stringify!(DMA_Channel_TypeDef))
	);
	assert_eq!(
	           ::core::mem::align_of::<DMA_Channel_TypeDef>(),
	           4usize,
	           concat!("Alignment of ", stringify!(DMA_Channel_TypeDef))
	);
	fn test_field_CCR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<DMA_Channel_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).CCR) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(DMA_Channel_TypeDef), "::", stringify!(CCR))
		);
	}
	test_field_CCR();
	fn test_field_CNDTR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<DMA_Channel_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).CNDTR) as usize - ptr as usize
		           },
		           4usize,
		           concat!("Offset of field: ", stringify!(DMA_Channel_TypeDef), "::", stringify!(CNDTR))
		);
	}
	test_field_CNDTR();
	fn test_field_CPAR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<DMA_Channel_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).CPAR) as usize - ptr as usize
		           },
		           8usize,
		           concat!("Offset of field: ", stringify!(DMA_Channel_TypeDef), "::", stringify!(CPAR))
		);
	}
	test_field_CPAR();
	fn test_field_CMAR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<DMA_Channel_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).CMAR) as usize - ptr as usize
		           },
		           12usize,
		           concat!("Offset of field: ", stringify!(DMA_Channel_TypeDef), "::", stringify!(CMAR))
		);
	}
	test_field_CMAR();
	fn test_field_RESERVED() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<DMA_Channel_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).RESERVED) as usize - ptr as usize
		           },
		           16usize,
		           concat!(
			"Offset of field: ",
			stringify!(DMA_Channel_TypeDef),
			"::",
			stringify!(RESERVED)
		)
		);
	}
	test_field_RESERVED();
}
#[repr(C)]
pub struct DMA_TypeDef {
	#[doc = "< DMA interrupt status register,                 Address offset: 0x00"]
	pub ISR: u32,
	#[doc = "< DMA interrupt flag clear register,             Address offset: 0x04"]
	pub IFCR: u32,
}
#[test]
fn bindgen_test_layout_DMA_TypeDef() {
	assert_eq!(
	           ::core::mem::size_of::<DMA_TypeDef>(),
	           8usize,
	           concat!("Size of: ", stringify!(DMA_TypeDef))
	);
	assert_eq!(
	           ::core::mem::align_of::<DMA_TypeDef>(),
	           4usize,
	           concat!("Alignment of ", stringify!(DMA_TypeDef))
	);
	fn test_field_ISR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<DMA_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).ISR) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(DMA_TypeDef), "::", stringify!(ISR))
		);
	}
	test_field_ISR();
	fn test_field_IFCR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<DMA_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).IFCR) as usize - ptr as usize
		           },
		           4usize,
		           concat!("Offset of field: ", stringify!(DMA_TypeDef), "::", stringify!(IFCR))
		);
	}
	test_field_IFCR();
}
#[doc = " @brief DMA Multiplexer"]
#[repr(C)]
pub struct DMAMUX_Channel_TypeDef {
	#[doc = "< DMA Multiplexer Channel x Control Register    Address offset: 0x0004 * (channel x)"]
	pub CCR: u32,
}
#[test]
fn bindgen_test_layout_DMAMUX_Channel_TypeDef() {
	assert_eq!(
	           ::core::mem::size_of::<DMAMUX_Channel_TypeDef>(),
	           4usize,
	           concat!("Size of: ", stringify!(DMAMUX_Channel_TypeDef))
	);
	assert_eq!(
	           ::core::mem::align_of::<DMAMUX_Channel_TypeDef>(),
	           4usize,
	           concat!("Alignment of ", stringify!(DMAMUX_Channel_TypeDef))
	);
	fn test_field_CCR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<DMAMUX_Channel_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).CCR) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(DMAMUX_Channel_TypeDef), "::", stringify!(CCR))
		);
	}
	test_field_CCR();
}
#[repr(C)]
pub struct DMAMUX_ChannelStatus_TypeDef {
	#[doc = "< DMA Channel Status Register                    Address offset: 0x0080"]
	pub CSR: u32,
	#[doc = "< DMA Channel Clear Flag Register                Address offset: 0x0084"]
	pub CFR: u32,
}
#[test]
fn bindgen_test_layout_DMAMUX_ChannelStatus_TypeDef() {
	assert_eq!(
	           ::core::mem::size_of::<DMAMUX_ChannelStatus_TypeDef>(),
	           8usize,
	           concat!("Size of: ", stringify!(DMAMUX_ChannelStatus_TypeDef))
	);
	assert_eq!(
	           ::core::mem::align_of::<DMAMUX_ChannelStatus_TypeDef>(),
	           4usize,
	           concat!("Alignment of ", stringify!(DMAMUX_ChannelStatus_TypeDef))
	);
	fn test_field_CSR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<DMAMUX_ChannelStatus_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).CSR) as usize - ptr as usize
		           },
		           0usize,
		           concat!(
			"Offset of field: ",
			stringify!(DMAMUX_ChannelStatus_TypeDef),
			"::",
			stringify!(CSR)
		)
		);
	}
	test_field_CSR();
	fn test_field_CFR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<DMAMUX_ChannelStatus_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).CFR) as usize - ptr as usize
		           },
		           4usize,
		           concat!(
			"Offset of field: ",
			stringify!(DMAMUX_ChannelStatus_TypeDef),
			"::",
			stringify!(CFR)
		)
		);
	}
	test_field_CFR();
}
#[repr(C)]
pub struct DMAMUX_RequestGen_TypeDef {
	#[doc = "< DMA Request Generator x Control Register     Address offset: 0x0100 + 0x0004 * (Req Gen x)"]
	pub RGCR: u32,
}
#[test]
fn bindgen_test_layout_DMAMUX_RequestGen_TypeDef() {
	assert_eq!(
	           ::core::mem::size_of::<DMAMUX_RequestGen_TypeDef>(),
	           4usize,
	           concat!("Size of: ", stringify!(DMAMUX_RequestGen_TypeDef))
	);
	assert_eq!(
	           ::core::mem::align_of::<DMAMUX_RequestGen_TypeDef>(),
	           4usize,
	           concat!("Alignment of ", stringify!(DMAMUX_RequestGen_TypeDef))
	);
	fn test_field_RGCR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<DMAMUX_RequestGen_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).RGCR) as usize - ptr as usize
		           },
		           0usize,
		           concat!(
			"Offset of field: ",
			stringify!(DMAMUX_RequestGen_TypeDef),
			"::",
			stringify!(RGCR)
		)
		);
	}
	test_field_RGCR();
}
#[repr(C)]
pub struct DMAMUX_RequestGenStatus_TypeDef {
	#[doc = "< DMA Request Generator Status Register        Address offset: 0x0140"]
	pub RGSR: u32,
	#[doc = "< DMA Request Generator Clear Flag Register    Address offset: 0x0144"]
	pub RGCFR: u32,
}
#[test]
fn bindgen_test_layout_DMAMUX_RequestGenStatus_TypeDef() {
	assert_eq!(
	           ::core::mem::size_of::<DMAMUX_RequestGenStatus_TypeDef>(),
	           8usize,
	           concat!("Size of: ", stringify!(DMAMUX_RequestGenStatus_TypeDef))
	);
	assert_eq!(
	           ::core::mem::align_of::<DMAMUX_RequestGenStatus_TypeDef>(),
	           4usize,
	           concat!("Alignment of ", stringify!(DMAMUX_RequestGenStatus_TypeDef))
	);
	fn test_field_RGSR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<DMAMUX_RequestGenStatus_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).RGSR) as usize - ptr as usize
		           },
		           0usize,
		           concat!(
			"Offset of field: ",
			stringify!(DMAMUX_RequestGenStatus_TypeDef),
			"::",
			stringify!(RGSR)
		)
		);
	}
	test_field_RGSR();
	fn test_field_RGCFR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<DMAMUX_RequestGenStatus_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).RGCFR) as usize - ptr as usize
		           },
		           4usize,
		           concat!(
			"Offset of field: ",
			stringify!(DMAMUX_RequestGenStatus_TypeDef),
			"::",
			stringify!(RGCFR)
		)
		);
	}
	test_field_RGCFR();
}
#[doc = " @brief FLASH Registers"]
#[repr(C)]
pub struct FLASH_TypeDef {
	#[doc = "< FLASH Access control register,                      Address offset: 0x00"]
	pub ACR: u32,
	#[doc = "< Reserved,                                           Address offset: 0x04"]
	pub RESERVED: u32,
	#[doc = "< FLASH Key register,                                 Address offset: 0x08"]
	pub KEYR: u32,
	#[doc = "< FLASH Option Key register,                          Address offset: 0x0C"]
	pub OPTKEYR: u32,
	#[doc = "< FLASH Status register,                              Address offset: 0x10"]
	pub SR: u32,
	#[doc = "< FLASH Control register,                             Address offset: 0x14"]
	pub CR: u32,
	#[doc = "< FLASH ECC register,                                 Address offset: 0x18"]
	pub ECCR: u32,
	#[doc = "< Reserved,                                           Address offset: 0x1C"]
	pub RESERVED1: u32,
	#[doc = "< FLASH Option register,                              Address offset: 0x20"]
	pub OPTR: u32,
	#[doc = "< FLASH Bank 1 PCROP area A Start address register,   Address offset: 0x24"]
	pub PCROP1ASR: u32,
	#[doc = "< FLASH Bank 1 PCROP area A End address register,     Address offset: 0x28"]
	pub PCROP1AER: u32,
	#[doc = "< FLASH Bank 1 WRP area A address register,           Address offset: 0x2C"]
	pub WRP1AR: u32,
	#[doc = "< FLASH Bank 1 WRP area B address register,           Address offset: 0x30"]
	pub WRP1BR: u32,
	#[doc = "< FLASH Bank 1 PCROP area B Start address register,   Address offset: 0x34"]
	pub PCROP1BSR: u32,
	#[doc = "< FLASH Bank 1 PCROP area B End address register,     Address offset: 0x38"]
	pub PCROP1BER: u32,
	#[doc = "< FLASH IPCC data buffer address,                     Address offset: 0x3C"]
	pub IPCCBR: u32,
	#[doc = "< Reserved,                                           Address offset: 0x40-0x58"]
	pub RESERVED2: [u32; 7usize],
	#[doc = "< FLASH Core MO+ Access Control Register ,            Address offset: 0x5C"]
	pub C2ACR: u32,
	#[doc = "< FLASH Core MO+ Status Register,                     Address offset: 0x60"]
	pub C2SR: u32,
	#[doc = "< FLASH Core MO+ Control register,                    Address offset: 0x64"]
	pub C2CR: u32,
	#[doc = "< Reserved,                                           Address offset: 0x68-0x7C"]
	pub RESERVED3: [u32; 6usize],
	#[doc = "< FLASH secure start address,                         Address offset: 0x80"]
	pub SFR: u32,
	#[doc = "< FlASH secure SRAM2 start addr and CPU2 reset vector Address offset: 0x84"]
	pub SRRVR: u32,
}
#[test]
fn bindgen_test_layout_FLASH_TypeDef() {
	assert_eq!(
	           ::core::mem::size_of::<FLASH_TypeDef>(),
	           136usize,
	           concat!("Size of: ", stringify!(FLASH_TypeDef))
	);
	assert_eq!(
	           ::core::mem::align_of::<FLASH_TypeDef>(),
	           4usize,
	           concat!("Alignment of ", stringify!(FLASH_TypeDef))
	);
	fn test_field_ACR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<FLASH_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).ACR) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(FLASH_TypeDef), "::", stringify!(ACR))
		);
	}
	test_field_ACR();
	fn test_field_RESERVED() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<FLASH_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).RESERVED) as usize - ptr as usize
		           },
		           4usize,
		           concat!("Offset of field: ", stringify!(FLASH_TypeDef), "::", stringify!(RESERVED))
		);
	}
	test_field_RESERVED();
	fn test_field_KEYR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<FLASH_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).KEYR) as usize - ptr as usize
		           },
		           8usize,
		           concat!("Offset of field: ", stringify!(FLASH_TypeDef), "::", stringify!(KEYR))
		);
	}
	test_field_KEYR();
	fn test_field_OPTKEYR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<FLASH_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).OPTKEYR) as usize - ptr as usize
		           },
		           12usize,
		           concat!("Offset of field: ", stringify!(FLASH_TypeDef), "::", stringify!(OPTKEYR))
		);
	}
	test_field_OPTKEYR();
	fn test_field_SR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<FLASH_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).SR) as usize - ptr as usize
		           },
		           16usize,
		           concat!("Offset of field: ", stringify!(FLASH_TypeDef), "::", stringify!(SR))
		);
	}
	test_field_SR();
	fn test_field_CR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<FLASH_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).CR) as usize - ptr as usize
		           },
		           20usize,
		           concat!("Offset of field: ", stringify!(FLASH_TypeDef), "::", stringify!(CR))
		);
	}
	test_field_CR();
	fn test_field_ECCR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<FLASH_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).ECCR) as usize - ptr as usize
		           },
		           24usize,
		           concat!("Offset of field: ", stringify!(FLASH_TypeDef), "::", stringify!(ECCR))
		);
	}
	test_field_ECCR();
	fn test_field_RESERVED1() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<FLASH_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).RESERVED1) as usize - ptr as usize
		           },
		           28usize,
		           concat!("Offset of field: ", stringify!(FLASH_TypeDef), "::", stringify!(RESERVED1))
		);
	}
	test_field_RESERVED1();
	fn test_field_OPTR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<FLASH_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).OPTR) as usize - ptr as usize
		           },
		           32usize,
		           concat!("Offset of field: ", stringify!(FLASH_TypeDef), "::", stringify!(OPTR))
		);
	}
	test_field_OPTR();
	fn test_field_PCROP1ASR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<FLASH_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).PCROP1ASR) as usize - ptr as usize
		           },
		           36usize,
		           concat!("Offset of field: ", stringify!(FLASH_TypeDef), "::", stringify!(PCROP1ASR))
		);
	}
	test_field_PCROP1ASR();
	fn test_field_PCROP1AER() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<FLASH_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).PCROP1AER) as usize - ptr as usize
		           },
		           40usize,
		           concat!("Offset of field: ", stringify!(FLASH_TypeDef), "::", stringify!(PCROP1AER))
		);
	}
	test_field_PCROP1AER();
	fn test_field_WRP1AR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<FLASH_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).WRP1AR) as usize - ptr as usize
		           },
		           44usize,
		           concat!("Offset of field: ", stringify!(FLASH_TypeDef), "::", stringify!(WRP1AR))
		);
	}
	test_field_WRP1AR();
	fn test_field_WRP1BR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<FLASH_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).WRP1BR) as usize - ptr as usize
		           },
		           48usize,
		           concat!("Offset of field: ", stringify!(FLASH_TypeDef), "::", stringify!(WRP1BR))
		);
	}
	test_field_WRP1BR();
	fn test_field_PCROP1BSR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<FLASH_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).PCROP1BSR) as usize - ptr as usize
		           },
		           52usize,
		           concat!("Offset of field: ", stringify!(FLASH_TypeDef), "::", stringify!(PCROP1BSR))
		);
	}
	test_field_PCROP1BSR();
	fn test_field_PCROP1BER() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<FLASH_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).PCROP1BER) as usize - ptr as usize
		           },
		           56usize,
		           concat!("Offset of field: ", stringify!(FLASH_TypeDef), "::", stringify!(PCROP1BER))
		);
	}
	test_field_PCROP1BER();
	fn test_field_IPCCBR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<FLASH_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).IPCCBR) as usize - ptr as usize
		           },
		           60usize,
		           concat!("Offset of field: ", stringify!(FLASH_TypeDef), "::", stringify!(IPCCBR))
		);
	}
	test_field_IPCCBR();
	fn test_field_RESERVED2() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<FLASH_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).RESERVED2) as usize - ptr as usize
		           },
		           64usize,
		           concat!("Offset of field: ", stringify!(FLASH_TypeDef), "::", stringify!(RESERVED2))
		);
	}
	test_field_RESERVED2();
	fn test_field_C2ACR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<FLASH_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).C2ACR) as usize - ptr as usize
		           },
		           92usize,
		           concat!("Offset of field: ", stringify!(FLASH_TypeDef), "::", stringify!(C2ACR))
		);
	}
	test_field_C2ACR();
	fn test_field_C2SR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<FLASH_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).C2SR) as usize - ptr as usize
		           },
		           96usize,
		           concat!("Offset of field: ", stringify!(FLASH_TypeDef), "::", stringify!(C2SR))
		);
	}
	test_field_C2SR();
	fn test_field_C2CR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<FLASH_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).C2CR) as usize - ptr as usize
		           },
		           100usize,
		           concat!("Offset of field: ", stringify!(FLASH_TypeDef), "::", stringify!(C2CR))
		);
	}
	test_field_C2CR();
	fn test_field_RESERVED3() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<FLASH_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).RESERVED3) as usize - ptr as usize
		           },
		           104usize,
		           concat!("Offset of field: ", stringify!(FLASH_TypeDef), "::", stringify!(RESERVED3))
		);
	}
	test_field_RESERVED3();
	fn test_field_SFR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<FLASH_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).SFR) as usize - ptr as usize
		           },
		           128usize,
		           concat!("Offset of field: ", stringify!(FLASH_TypeDef), "::", stringify!(SFR))
		);
	}
	test_field_SFR();
	fn test_field_SRRVR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<FLASH_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).SRRVR) as usize - ptr as usize
		           },
		           132usize,
		           concat!("Offset of field: ", stringify!(FLASH_TypeDef), "::", stringify!(SRRVR))
		);
	}
	test_field_SRRVR();
}
#[doc = " @brief General Purpose I/O"]
#[repr(C)]
pub struct GPIO_TypeDef {
	#[doc = "< GPIO port mode register,               Address offset: 0x00"]
	pub MODER: u32,
	#[doc = "< GPIO port output type register,        Address offset: 0x04"]
	pub OTYPER: u32,
	#[doc = "< GPIO port output speed register,       Address offset: 0x08"]
	pub OSPEEDR: u32,
	#[doc = "< GPIO port pull-up/pull-down register,  Address offset: 0x0C"]
	pub PUPDR: u32,
	#[doc = "< GPIO port input data register,         Address offset: 0x10"]
	pub IDR: u32,
	#[doc = "< GPIO port output data register,        Address offset: 0x14"]
	pub ODR: u32,
	#[doc = "< GPIO port bit set/reset  register,     Address offset: 0x18"]
	pub BSRR: u32,
	#[doc = "< GPIO port configuration lock register, Address offset: 0x1C"]
	pub LCKR: u32,
	#[doc = "< GPIO alternate function registers,     Address offset: 0x20-0x24"]
	pub AFR: [u32; 2usize],
	#[doc = "< GPIO Bit Reset register,               Address offset: 0x28"]
	pub BRR: u32,
}
#[test]
fn bindgen_test_layout_GPIO_TypeDef() {
	assert_eq!(
	           ::core::mem::size_of::<GPIO_TypeDef>(),
	           44usize,
	           concat!("Size of: ", stringify!(GPIO_TypeDef))
	);
	assert_eq!(
	           ::core::mem::align_of::<GPIO_TypeDef>(),
	           4usize,
	           concat!("Alignment of ", stringify!(GPIO_TypeDef))
	);
	fn test_field_MODER() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<GPIO_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).MODER) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(GPIO_TypeDef), "::", stringify!(MODER))
		);
	}
	test_field_MODER();
	fn test_field_OTYPER() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<GPIO_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).OTYPER) as usize - ptr as usize
		           },
		           4usize,
		           concat!("Offset of field: ", stringify!(GPIO_TypeDef), "::", stringify!(OTYPER))
		);
	}
	test_field_OTYPER();
	fn test_field_OSPEEDR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<GPIO_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).OSPEEDR) as usize - ptr as usize
		           },
		           8usize,
		           concat!("Offset of field: ", stringify!(GPIO_TypeDef), "::", stringify!(OSPEEDR))
		);
	}
	test_field_OSPEEDR();
	fn test_field_PUPDR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<GPIO_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).PUPDR) as usize - ptr as usize
		           },
		           12usize,
		           concat!("Offset of field: ", stringify!(GPIO_TypeDef), "::", stringify!(PUPDR))
		);
	}
	test_field_PUPDR();
	fn test_field_IDR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<GPIO_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).IDR) as usize - ptr as usize
		           },
		           16usize,
		           concat!("Offset of field: ", stringify!(GPIO_TypeDef), "::", stringify!(IDR))
		);
	}
	test_field_IDR();
	fn test_field_ODR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<GPIO_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).ODR) as usize - ptr as usize
		           },
		           20usize,
		           concat!("Offset of field: ", stringify!(GPIO_TypeDef), "::", stringify!(ODR))
		);
	}
	test_field_ODR();
	fn test_field_BSRR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<GPIO_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).BSRR) as usize - ptr as usize
		           },
		           24usize,
		           concat!("Offset of field: ", stringify!(GPIO_TypeDef), "::", stringify!(BSRR))
		);
	}
	test_field_BSRR();
	fn test_field_LCKR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<GPIO_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).LCKR) as usize - ptr as usize
		           },
		           28usize,
		           concat!("Offset of field: ", stringify!(GPIO_TypeDef), "::", stringify!(LCKR))
		);
	}
	test_field_LCKR();
	fn test_field_AFR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<GPIO_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).AFR) as usize - ptr as usize
		           },
		           32usize,
		           concat!("Offset of field: ", stringify!(GPIO_TypeDef), "::", stringify!(AFR))
		);
	}
	test_field_AFR();
	fn test_field_BRR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<GPIO_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).BRR) as usize - ptr as usize
		           },
		           40usize,
		           concat!("Offset of field: ", stringify!(GPIO_TypeDef), "::", stringify!(BRR))
		);
	}
	test_field_BRR();
}
#[doc = " @brief Inter-integrated Circuit Interface"]
#[repr(C)]
pub struct I2C_TypeDef {
	#[doc = "< I2C Control register 1,            Address offset: 0x00"]
	pub CR1: u32,
	#[doc = "< I2C Control register 2,            Address offset: 0x04"]
	pub CR2: u32,
	#[doc = "< I2C Own address 1 register,        Address offset: 0x08"]
	pub OAR1: u32,
	#[doc = "< I2C Own address 2 register,        Address offset: 0x0C"]
	pub OAR2: u32,
	#[doc = "< I2C Timing register,               Address offset: 0x10"]
	pub TIMINGR: u32,
	#[doc = "< I2C Timeout register,              Address offset: 0x14"]
	pub TIMEOUTR: u32,
	#[doc = "< I2C Interrupt and status register, Address offset: 0x18"]
	pub ISR: u32,
	#[doc = "< I2C Interrupt clear register,      Address offset: 0x1C"]
	pub ICR: u32,
	#[doc = "< I2C PEC register,                  Address offset: 0x20"]
	pub PECR: u32,
	#[doc = "< I2C Receive data register,         Address offset: 0x24"]
	pub RXDR: u32,
	#[doc = "< I2C Transmit data register,        Address offset: 0x28"]
	pub TXDR: u32,
}
#[test]
fn bindgen_test_layout_I2C_TypeDef() {
	assert_eq!(
	           ::core::mem::size_of::<I2C_TypeDef>(),
	           44usize,
	           concat!("Size of: ", stringify!(I2C_TypeDef))
	);
	assert_eq!(
	           ::core::mem::align_of::<I2C_TypeDef>(),
	           4usize,
	           concat!("Alignment of ", stringify!(I2C_TypeDef))
	);
	fn test_field_CR1() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<I2C_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).CR1) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(I2C_TypeDef), "::", stringify!(CR1))
		);
	}
	test_field_CR1();
	fn test_field_CR2() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<I2C_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).CR2) as usize - ptr as usize
		           },
		           4usize,
		           concat!("Offset of field: ", stringify!(I2C_TypeDef), "::", stringify!(CR2))
		);
	}
	test_field_CR2();
	fn test_field_OAR1() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<I2C_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).OAR1) as usize - ptr as usize
		           },
		           8usize,
		           concat!("Offset of field: ", stringify!(I2C_TypeDef), "::", stringify!(OAR1))
		);
	}
	test_field_OAR1();
	fn test_field_OAR2() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<I2C_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).OAR2) as usize - ptr as usize
		           },
		           12usize,
		           concat!("Offset of field: ", stringify!(I2C_TypeDef), "::", stringify!(OAR2))
		);
	}
	test_field_OAR2();
	fn test_field_TIMINGR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<I2C_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).TIMINGR) as usize - ptr as usize
		           },
		           16usize,
		           concat!("Offset of field: ", stringify!(I2C_TypeDef), "::", stringify!(TIMINGR))
		);
	}
	test_field_TIMINGR();
	fn test_field_TIMEOUTR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<I2C_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).TIMEOUTR) as usize - ptr as usize
		           },
		           20usize,
		           concat!("Offset of field: ", stringify!(I2C_TypeDef), "::", stringify!(TIMEOUTR))
		);
	}
	test_field_TIMEOUTR();
	fn test_field_ISR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<I2C_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).ISR) as usize - ptr as usize
		           },
		           24usize,
		           concat!("Offset of field: ", stringify!(I2C_TypeDef), "::", stringify!(ISR))
		);
	}
	test_field_ISR();
	fn test_field_ICR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<I2C_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).ICR) as usize - ptr as usize
		           },
		           28usize,
		           concat!("Offset of field: ", stringify!(I2C_TypeDef), "::", stringify!(ICR))
		);
	}
	test_field_ICR();
	fn test_field_PECR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<I2C_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).PECR) as usize - ptr as usize
		           },
		           32usize,
		           concat!("Offset of field: ", stringify!(I2C_TypeDef), "::", stringify!(PECR))
		);
	}
	test_field_PECR();
	fn test_field_RXDR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<I2C_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).RXDR) as usize - ptr as usize
		           },
		           36usize,
		           concat!("Offset of field: ", stringify!(I2C_TypeDef), "::", stringify!(RXDR))
		);
	}
	test_field_RXDR();
	fn test_field_TXDR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<I2C_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).TXDR) as usize - ptr as usize
		           },
		           40usize,
		           concat!("Offset of field: ", stringify!(I2C_TypeDef), "::", stringify!(TXDR))
		);
	}
	test_field_TXDR();
}
#[doc = " @brief Independent WATCHDOG"]
#[repr(C)]
pub struct IWDG_TypeDef {
	#[doc = "< IWDG Key register,       Address offset: 0x00"]
	pub KR: u32,
	#[doc = "< IWDG Prescaler register, Address offset: 0x04"]
	pub PR: u32,
	#[doc = "< IWDG Reload register,    Address offset: 0x08"]
	pub RLR: u32,
	#[doc = "< IWDG Status register,    Address offset: 0x0C"]
	pub SR: u32,
	#[doc = "< IWDG Window register,    Address offset: 0x10"]
	pub WINR: u32,
}
#[test]
fn bindgen_test_layout_IWDG_TypeDef() {
	assert_eq!(
	           ::core::mem::size_of::<IWDG_TypeDef>(),
	           20usize,
	           concat!("Size of: ", stringify!(IWDG_TypeDef))
	);
	assert_eq!(
	           ::core::mem::align_of::<IWDG_TypeDef>(),
	           4usize,
	           concat!("Alignment of ", stringify!(IWDG_TypeDef))
	);
	fn test_field_KR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<IWDG_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).KR) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(IWDG_TypeDef), "::", stringify!(KR))
		);
	}
	test_field_KR();
	fn test_field_PR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<IWDG_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).PR) as usize - ptr as usize
		           },
		           4usize,
		           concat!("Offset of field: ", stringify!(IWDG_TypeDef), "::", stringify!(PR))
		);
	}
	test_field_PR();
	fn test_field_RLR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<IWDG_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).RLR) as usize - ptr as usize
		           },
		           8usize,
		           concat!("Offset of field: ", stringify!(IWDG_TypeDef), "::", stringify!(RLR))
		);
	}
	test_field_RLR();
	fn test_field_SR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<IWDG_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).SR) as usize - ptr as usize
		           },
		           12usize,
		           concat!("Offset of field: ", stringify!(IWDG_TypeDef), "::", stringify!(SR))
		);
	}
	test_field_SR();
	fn test_field_WINR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<IWDG_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).WINR) as usize - ptr as usize
		           },
		           16usize,
		           concat!("Offset of field: ", stringify!(IWDG_TypeDef), "::", stringify!(WINR))
		);
	}
	test_field_WINR();
}
#[doc = " @brief LPTIMER"]
#[repr(C)]
pub struct LPTIM_TypeDef {
	#[doc = "< LPTIM Interrupt and Status register,                Address offset: 0x00"]
	pub ISR: u32,
	#[doc = "< LPTIM Interrupt Clear register,                     Address offset: 0x04"]
	pub ICR: u32,
	#[doc = "< LPTIM Interrupt Enable register,                    Address offset: 0x08"]
	pub IER: u32,
	#[doc = "< LPTIM Configuration register,                       Address offset: 0x0C"]
	pub CFGR: u32,
	#[doc = "< LPTIM Control register,                             Address offset: 0x10"]
	pub CR: u32,
	#[doc = "< LPTIM Compare register,                             Address offset: 0x14"]
	pub CMP: u32,
	#[doc = "< LPTIM Autoreload register,                          Address offset: 0x18"]
	pub ARR: u32,
	#[doc = "< LPTIM Counter register,                             Address offset: 0x1C"]
	pub CNT: u32,
	#[doc = "< LPTIM Option register,                              Address offset: 0x20"]
	pub OR: u32,
}
#[test]
fn bindgen_test_layout_LPTIM_TypeDef() {
	assert_eq!(
	           ::core::mem::size_of::<LPTIM_TypeDef>(),
	           36usize,
	           concat!("Size of: ", stringify!(LPTIM_TypeDef))
	);
	assert_eq!(
	           ::core::mem::align_of::<LPTIM_TypeDef>(),
	           4usize,
	           concat!("Alignment of ", stringify!(LPTIM_TypeDef))
	);
	fn test_field_ISR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LPTIM_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).ISR) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(LPTIM_TypeDef), "::", stringify!(ISR))
		);
	}
	test_field_ISR();
	fn test_field_ICR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LPTIM_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).ICR) as usize - ptr as usize
		           },
		           4usize,
		           concat!("Offset of field: ", stringify!(LPTIM_TypeDef), "::", stringify!(ICR))
		);
	}
	test_field_ICR();
	fn test_field_IER() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LPTIM_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).IER) as usize - ptr as usize
		           },
		           8usize,
		           concat!("Offset of field: ", stringify!(LPTIM_TypeDef), "::", stringify!(IER))
		);
	}
	test_field_IER();
	fn test_field_CFGR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LPTIM_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).CFGR) as usize - ptr as usize
		           },
		           12usize,
		           concat!("Offset of field: ", stringify!(LPTIM_TypeDef), "::", stringify!(CFGR))
		);
	}
	test_field_CFGR();
	fn test_field_CR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LPTIM_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).CR) as usize - ptr as usize
		           },
		           16usize,
		           concat!("Offset of field: ", stringify!(LPTIM_TypeDef), "::", stringify!(CR))
		);
	}
	test_field_CR();
	fn test_field_CMP() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LPTIM_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).CMP) as usize - ptr as usize
		           },
		           20usize,
		           concat!("Offset of field: ", stringify!(LPTIM_TypeDef), "::", stringify!(CMP))
		);
	}
	test_field_CMP();
	fn test_field_ARR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LPTIM_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).ARR) as usize - ptr as usize
		           },
		           24usize,
		           concat!("Offset of field: ", stringify!(LPTIM_TypeDef), "::", stringify!(ARR))
		);
	}
	test_field_ARR();
	fn test_field_CNT() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LPTIM_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).CNT) as usize - ptr as usize
		           },
		           28usize,
		           concat!("Offset of field: ", stringify!(LPTIM_TypeDef), "::", stringify!(CNT))
		);
	}
	test_field_CNT();
	fn test_field_OR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LPTIM_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).OR) as usize - ptr as usize
		           },
		           32usize,
		           concat!("Offset of field: ", stringify!(LPTIM_TypeDef), "::", stringify!(OR))
		);
	}
	test_field_OR();
}
#[doc = " @brief Power Control"]
#[repr(C)]
pub struct PWR_TypeDef {
	#[doc = "< PWR Power Control Register 1,                     Address offset: 0x00"]
	pub CR1: u32,
	#[doc = "< PWR Power Control Register 2,                     Address offset: 0x04"]
	pub CR2: u32,
	#[doc = "< PWR Power Control Register 3,                     Address offset: 0x08"]
	pub CR3: u32,
	#[doc = "< PWR Power Control Register 4,                     Address offset: 0x0C"]
	pub CR4: u32,
	#[doc = "< PWR Power Status Register 1,                      Address offset: 0x10"]
	pub SR1: u32,
	#[doc = "< PWR Power Status Register 2,                      Address offset: 0x14"]
	pub SR2: u32,
	#[doc = "< PWR Power Status Reset Register,                  Address offset: 0x18"]
	pub SCR: u32,
	#[doc = "< PWR Power Control Register 5,                     Address offset: 0x1C"]
	pub CR5: u32,
	#[doc = "< PWR Pull-Up Control Register of port A,           Address offset: 0x20"]
	pub PUCRA: u32,
	#[doc = "< PWR Pull-Down Control Register of port A,         Address offset: 0x24"]
	pub PDCRA: u32,
	#[doc = "< PWR Pull-Up Control Register of port B,           Address offset: 0x28"]
	pub PUCRB: u32,
	#[doc = "< PWR Pull-Down Control Register of port B,         Address offset: 0x2C"]
	pub PDCRB: u32,
	#[doc = "< PWR Pull-Up Control Register of port C,           Address offset: 0x30"]
	pub PUCRC: u32,
	#[doc = "< PWR Pull-Down Control Register of port C,         Address offset: 0x34"]
	pub PDCRC: u32,
	#[doc = "< PWR Pull-Up Control Register of port D,           Address offset: 0x38"]
	pub PUCRD: u32,
	#[doc = "< PWR Pull-Down Control Register of port D,         Address offset: 0x3C"]
	pub PDCRD: u32,
	#[doc = "< PWR Pull-Up Control Register of port E,           Address offset: 0x40"]
	pub PUCRE: u32,
	#[doc = "< PWR Pull-Down Control Register of port E,         Address offset: 0x44"]
	pub PDCRE: u32,
	#[doc = "< Reserved,                                         Address offset: 0x48-0x54"]
	pub RESERVED0: [u32; 4usize],
	#[doc = "< PWR Pull-Up Control Register of port H,           Address offset: 0x58"]
	pub PUCRH: u32,
	#[doc = "< PWR Pull-Down Control Register of port H,         Address offset: 0x5C"]
	pub PDCRH: u32,
	#[doc = "< Reserved,                                         Address offset: 0x60-0x7C"]
	pub RESERVED1: [u32; 8usize],
	#[doc = "< PWR Power Control Register 1 for CPU2,            Address offset: 0x80"]
	pub C2CR1: u32,
	#[doc = "< PWR Power Control Register 3 for CPU2,            Address offset: 0x84"]
	pub C2CR3: u32,
	#[doc = "< PWR Power Status Reset Register for CPU2,         Address offset: 0x88"]
	pub EXTSCR: u32,
}
#[test]
fn bindgen_test_layout_PWR_TypeDef() {
	assert_eq!(
	           ::core::mem::size_of::<PWR_TypeDef>(),
	           140usize,
	           concat!("Size of: ", stringify!(PWR_TypeDef))
	);
	assert_eq!(
	           ::core::mem::align_of::<PWR_TypeDef>(),
	           4usize,
	           concat!("Alignment of ", stringify!(PWR_TypeDef))
	);
	fn test_field_CR1() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<PWR_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).CR1) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(PWR_TypeDef), "::", stringify!(CR1))
		);
	}
	test_field_CR1();
	fn test_field_CR2() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<PWR_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).CR2) as usize - ptr as usize
		           },
		           4usize,
		           concat!("Offset of field: ", stringify!(PWR_TypeDef), "::", stringify!(CR2))
		);
	}
	test_field_CR2();
	fn test_field_CR3() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<PWR_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).CR3) as usize - ptr as usize
		           },
		           8usize,
		           concat!("Offset of field: ", stringify!(PWR_TypeDef), "::", stringify!(CR3))
		);
	}
	test_field_CR3();
	fn test_field_CR4() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<PWR_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).CR4) as usize - ptr as usize
		           },
		           12usize,
		           concat!("Offset of field: ", stringify!(PWR_TypeDef), "::", stringify!(CR4))
		);
	}
	test_field_CR4();
	fn test_field_SR1() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<PWR_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).SR1) as usize - ptr as usize
		           },
		           16usize,
		           concat!("Offset of field: ", stringify!(PWR_TypeDef), "::", stringify!(SR1))
		);
	}
	test_field_SR1();
	fn test_field_SR2() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<PWR_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).SR2) as usize - ptr as usize
		           },
		           20usize,
		           concat!("Offset of field: ", stringify!(PWR_TypeDef), "::", stringify!(SR2))
		);
	}
	test_field_SR2();
	fn test_field_SCR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<PWR_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).SCR) as usize - ptr as usize
		           },
		           24usize,
		           concat!("Offset of field: ", stringify!(PWR_TypeDef), "::", stringify!(SCR))
		);
	}
	test_field_SCR();
	fn test_field_CR5() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<PWR_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).CR5) as usize - ptr as usize
		           },
		           28usize,
		           concat!("Offset of field: ", stringify!(PWR_TypeDef), "::", stringify!(CR5))
		);
	}
	test_field_CR5();
	fn test_field_PUCRA() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<PWR_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).PUCRA) as usize - ptr as usize
		           },
		           32usize,
		           concat!("Offset of field: ", stringify!(PWR_TypeDef), "::", stringify!(PUCRA))
		);
	}
	test_field_PUCRA();
	fn test_field_PDCRA() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<PWR_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).PDCRA) as usize - ptr as usize
		           },
		           36usize,
		           concat!("Offset of field: ", stringify!(PWR_TypeDef), "::", stringify!(PDCRA))
		);
	}
	test_field_PDCRA();
	fn test_field_PUCRB() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<PWR_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).PUCRB) as usize - ptr as usize
		           },
		           40usize,
		           concat!("Offset of field: ", stringify!(PWR_TypeDef), "::", stringify!(PUCRB))
		);
	}
	test_field_PUCRB();
	fn test_field_PDCRB() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<PWR_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).PDCRB) as usize - ptr as usize
		           },
		           44usize,
		           concat!("Offset of field: ", stringify!(PWR_TypeDef), "::", stringify!(PDCRB))
		);
	}
	test_field_PDCRB();
	fn test_field_PUCRC() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<PWR_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).PUCRC) as usize - ptr as usize
		           },
		           48usize,
		           concat!("Offset of field: ", stringify!(PWR_TypeDef), "::", stringify!(PUCRC))
		);
	}
	test_field_PUCRC();
	fn test_field_PDCRC() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<PWR_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).PDCRC) as usize - ptr as usize
		           },
		           52usize,
		           concat!("Offset of field: ", stringify!(PWR_TypeDef), "::", stringify!(PDCRC))
		);
	}
	test_field_PDCRC();
	fn test_field_PUCRD() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<PWR_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).PUCRD) as usize - ptr as usize
		           },
		           56usize,
		           concat!("Offset of field: ", stringify!(PWR_TypeDef), "::", stringify!(PUCRD))
		);
	}
	test_field_PUCRD();
	fn test_field_PDCRD() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<PWR_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).PDCRD) as usize - ptr as usize
		           },
		           60usize,
		           concat!("Offset of field: ", stringify!(PWR_TypeDef), "::", stringify!(PDCRD))
		);
	}
	test_field_PDCRD();
	fn test_field_PUCRE() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<PWR_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).PUCRE) as usize - ptr as usize
		           },
		           64usize,
		           concat!("Offset of field: ", stringify!(PWR_TypeDef), "::", stringify!(PUCRE))
		);
	}
	test_field_PUCRE();
	fn test_field_PDCRE() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<PWR_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).PDCRE) as usize - ptr as usize
		           },
		           68usize,
		           concat!("Offset of field: ", stringify!(PWR_TypeDef), "::", stringify!(PDCRE))
		);
	}
	test_field_PDCRE();
	fn test_field_RESERVED0() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<PWR_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).RESERVED0) as usize - ptr as usize
		           },
		           72usize,
		           concat!("Offset of field: ", stringify!(PWR_TypeDef), "::", stringify!(RESERVED0))
		);
	}
	test_field_RESERVED0();
	fn test_field_PUCRH() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<PWR_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).PUCRH) as usize - ptr as usize
		           },
		           88usize,
		           concat!("Offset of field: ", stringify!(PWR_TypeDef), "::", stringify!(PUCRH))
		);
	}
	test_field_PUCRH();
	fn test_field_PDCRH() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<PWR_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).PDCRH) as usize - ptr as usize
		           },
		           92usize,
		           concat!("Offset of field: ", stringify!(PWR_TypeDef), "::", stringify!(PDCRH))
		);
	}
	test_field_PDCRH();
	fn test_field_RESERVED1() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<PWR_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).RESERVED1) as usize - ptr as usize
		           },
		           96usize,
		           concat!("Offset of field: ", stringify!(PWR_TypeDef), "::", stringify!(RESERVED1))
		);
	}
	test_field_RESERVED1();
	fn test_field_C2CR1() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<PWR_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).C2CR1) as usize - ptr as usize
		           },
		           128usize,
		           concat!("Offset of field: ", stringify!(PWR_TypeDef), "::", stringify!(C2CR1))
		);
	}
	test_field_C2CR1();
	fn test_field_C2CR3() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<PWR_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).C2CR3) as usize - ptr as usize
		           },
		           132usize,
		           concat!("Offset of field: ", stringify!(PWR_TypeDef), "::", stringify!(C2CR3))
		);
	}
	test_field_C2CR3();
	fn test_field_EXTSCR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<PWR_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).EXTSCR) as usize - ptr as usize
		           },
		           136usize,
		           concat!("Offset of field: ", stringify!(PWR_TypeDef), "::", stringify!(EXTSCR))
		);
	}
	test_field_EXTSCR();
}
#[doc = " @brief QUAD Serial Peripheral Interface"]
#[repr(C)]
pub struct QUADSPI_TypeDef {
	#[doc = "< QUADSPI Control register,                           Address offset: 0x00"]
	pub CR: u32,
	#[doc = "< QUADSPI Device Configuration register,              Address offset: 0x04"]
	pub DCR: u32,
	#[doc = "< QUADSPI Status register,                            Address offset: 0x08"]
	pub SR: u32,
	#[doc = "< QUADSPI Flag Clear register,                        Address offset: 0x0C"]
	pub FCR: u32,
	#[doc = "< QUADSPI Data Length register,                       Address offset: 0x10"]
	pub DLR: u32,
	#[doc = "< QUADSPI Communication Configuration register,       Address offset: 0x14"]
	pub CCR: u32,
	#[doc = "< QUADSPI Address register,                           Address offset: 0x18"]
	pub AR: u32,
	#[doc = "< QUADSPI Alternate Bytes register,                   Address offset: 0x1C"]
	pub ABR: u32,
	#[doc = "< QUADSPI Data register,                              Address offset: 0x20"]
	pub DR: u32,
	#[doc = "< QUADSPI Polling Status Mask register,               Address offset: 0x24"]
	pub PSMKR: u32,
	#[doc = "< QUADSPI Polling Status Match register,              Address offset: 0x28"]
	pub PSMAR: u32,
	#[doc = "< QUADSPI Polling Interval register,                  Address offset: 0x2C"]
	pub PIR: u32,
	#[doc = "< QUADSPI Low Power Timeout register,                 Address offset: 0x30"]
	pub LPTR: u32,
}
#[test]
fn bindgen_test_layout_QUADSPI_TypeDef() {
	assert_eq!(
	           ::core::mem::size_of::<QUADSPI_TypeDef>(),
	           52usize,
	           concat!("Size of: ", stringify!(QUADSPI_TypeDef))
	);
	assert_eq!(
	           ::core::mem::align_of::<QUADSPI_TypeDef>(),
	           4usize,
	           concat!("Alignment of ", stringify!(QUADSPI_TypeDef))
	);
	fn test_field_CR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<QUADSPI_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).CR) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(QUADSPI_TypeDef), "::", stringify!(CR))
		);
	}
	test_field_CR();
	fn test_field_DCR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<QUADSPI_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).DCR) as usize - ptr as usize
		           },
		           4usize,
		           concat!("Offset of field: ", stringify!(QUADSPI_TypeDef), "::", stringify!(DCR))
		);
	}
	test_field_DCR();
	fn test_field_SR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<QUADSPI_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).SR) as usize - ptr as usize
		           },
		           8usize,
		           concat!("Offset of field: ", stringify!(QUADSPI_TypeDef), "::", stringify!(SR))
		);
	}
	test_field_SR();
	fn test_field_FCR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<QUADSPI_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).FCR) as usize - ptr as usize
		           },
		           12usize,
		           concat!("Offset of field: ", stringify!(QUADSPI_TypeDef), "::", stringify!(FCR))
		);
	}
	test_field_FCR();
	fn test_field_DLR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<QUADSPI_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).DLR) as usize - ptr as usize
		           },
		           16usize,
		           concat!("Offset of field: ", stringify!(QUADSPI_TypeDef), "::", stringify!(DLR))
		);
	}
	test_field_DLR();
	fn test_field_CCR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<QUADSPI_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).CCR) as usize - ptr as usize
		           },
		           20usize,
		           concat!("Offset of field: ", stringify!(QUADSPI_TypeDef), "::", stringify!(CCR))
		);
	}
	test_field_CCR();
	fn test_field_AR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<QUADSPI_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).AR) as usize - ptr as usize
		           },
		           24usize,
		           concat!("Offset of field: ", stringify!(QUADSPI_TypeDef), "::", stringify!(AR))
		);
	}
	test_field_AR();
	fn test_field_ABR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<QUADSPI_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).ABR) as usize - ptr as usize
		           },
		           28usize,
		           concat!("Offset of field: ", stringify!(QUADSPI_TypeDef), "::", stringify!(ABR))
		);
	}
	test_field_ABR();
	fn test_field_DR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<QUADSPI_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).DR) as usize - ptr as usize
		           },
		           32usize,
		           concat!("Offset of field: ", stringify!(QUADSPI_TypeDef), "::", stringify!(DR))
		);
	}
	test_field_DR();
	fn test_field_PSMKR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<QUADSPI_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).PSMKR) as usize - ptr as usize
		           },
		           36usize,
		           concat!("Offset of field: ", stringify!(QUADSPI_TypeDef), "::", stringify!(PSMKR))
		);
	}
	test_field_PSMKR();
	fn test_field_PSMAR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<QUADSPI_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).PSMAR) as usize - ptr as usize
		           },
		           40usize,
		           concat!("Offset of field: ", stringify!(QUADSPI_TypeDef), "::", stringify!(PSMAR))
		);
	}
	test_field_PSMAR();
	fn test_field_PIR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<QUADSPI_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).PIR) as usize - ptr as usize
		           },
		           44usize,
		           concat!("Offset of field: ", stringify!(QUADSPI_TypeDef), "::", stringify!(PIR))
		);
	}
	test_field_PIR();
	fn test_field_LPTR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<QUADSPI_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).LPTR) as usize - ptr as usize
		           },
		           48usize,
		           concat!("Offset of field: ", stringify!(QUADSPI_TypeDef), "::", stringify!(LPTR))
		);
	}
	test_field_LPTR();
}
#[doc = " @brief Reset and Clock Control"]
#[repr(C)]
pub struct RCC_TypeDef {
	#[doc = "< RCC clock  Control Register,                                                    Address offset: 0x00"]
	pub CR: u32,
	#[doc = "< RCC Internal Clock Sources Calibration Register,                                Address offset: 0x04"]
	pub ICSCR: u32,
	#[doc = "< RCC Clocks Configuration Register,                                              Address offset: 0x08"]
	pub CFGR: u32,
	#[doc = "< RCC System PLL configuration Register,                                          Address offset: 0x0C"]
	pub PLLCFGR: u32,
	#[doc = "< RCC  PLL SAI1 configuration Register,                                           Address offset: 0x10"]
	pub PLLSAI1CFGR: u32,
	#[doc = "< Reserved,                                                                       Address offset: 0x14"]
	pub RESERVED0: u32,
	#[doc = "< RCC Clock Interrupt Enable Register,                                            Address offset: 0x18"]
	pub CIER: u32,
	#[doc = "< RCC Clock Interrupt Flag Register,                                              Address offset: 0x1C"]
	pub CIFR: u32,
	#[doc = "< RCC Clock Interrupt Clear Register,                                             Address offset: 0x20"]
	pub CICR: u32,
	#[doc = "< RCC SMPS step-down converter control register,                                  Address offset: 0x24"]
	pub SMPSCR: u32,
	#[doc = "< RCC AHB1 peripheral reset register,                                             Address offset: 0x28"]
	pub AHB1RSTR: u32,
	#[doc = "< RCC AHB2 peripheral reset register,                                             Address offset: 0x2C"]
	pub AHB2RSTR: u32,
	#[doc = "< RCC AHB3 & AHB4 peripheral reset register,                                      Address offset: 0x30"]
	pub AHB3RSTR: u32,
	#[doc = "< Reserved,                                                                       Address offset: 0x34"]
	pub RESERVED1: u32,
	#[doc = "< RCC APB1 peripheral reset register 1,                                           Address offset: 0x38"]
	pub APB1RSTR1: u32,
	#[doc = "< RCC APB1 peripheral reset register 2,                                           Address offset: 0x3C"]
	pub APB1RSTR2: u32,
	#[doc = "< RCC APB2 peripheral reset register,                                             Address offset: 0x40"]
	pub APB2RSTR: u32,
	#[doc = "< RCC APB3 peripheral reset register,                                             Address offset: 0x44"]
	pub APB3RSTR: u32,
	#[doc = "< RCC AHB1 peripheral clocks enable register,                                     Address offset: 0x48"]
	pub AHB1ENR: u32,
	#[doc = "< RCC AHB2 peripheral clocks enable register,                                     Address offset: 0x4C"]
	pub AHB2ENR: u32,
	#[doc = "< RCC AHB3 & AHB4 peripheral clocks enable register,                              Address offset: 0x50"]
	pub AHB3ENR: u32,
	#[doc = "< Reserved,                                                                       Address offset: 0x54"]
	pub RESERVED2: u32,
	#[doc = "< RCC APB1 peripheral clocks enable register 1,                                   Address offset: 0x58"]
	pub APB1ENR1: u32,
	#[doc = "< RCC APB1 peripheral clocks enable register 2,                                   Address offset: 0x5C"]
	pub APB1ENR2: u32,
	#[doc = "< RCC APB2 peripheral clocks enable register,                                     Address offset: 0x60"]
	pub APB2ENR: u32,
	#[doc = "< Reserved,                                                                       Address offset: 0x64"]
	pub RESERVED3: u32,
	#[doc = "< RCC AHB1 peripheral clocks enable in sleep and stop modes register,             Address offset: 0x68"]
	pub AHB1SMENR: u32,
	#[doc = "< RCC AHB2 peripheral clocks enable in sleep and stop modes register,             Address offset: 0x6C"]
	pub AHB2SMENR: u32,
	#[doc = "< RCC AHB3 & AHB4 peripheral clocks enable in sleep and stop modes register,      Address offset: 0x70"]
	pub AHB3SMENR: u32,
	#[doc = "< Reserved,                                                                       Address offset: 0x74"]
	pub RESERVED4: u32,
	#[doc = "< RCC APB1 peripheral clocks enable in sleep mode and stop modes register 1,      Address offset: 0x78"]
	pub APB1SMENR1: u32,
	#[doc = "< RCC APB1 peripheral clocks enable in sleep mode and stop modes register 2,      Address offset: 0x7C"]
	pub APB1SMENR2: u32,
	#[doc = "< RCC APB2 peripheral clocks enable in sleep mode and stop modes register,        Address offset: 0x80"]
	pub APB2SMENR: u32,
	#[doc = "< Reserved,                                                                       Address offset: 0x84"]
	pub RESERVED5: u32,
	#[doc = "< RCC Peripherals Clock Configuration Independent Register,                       Address offset: 0x88"]
	pub CCIPR: u32,
	#[doc = "< Reserved,                                                                       Address offset: 0x8C"]
	pub RESERVED6: u32,
	#[doc = "< RCC Backup Domain Control Register,                                             Address offset: 0x90"]
	pub BDCR: u32,
	#[doc = "< RCC Control and Status Register,                                                Address offset: 0x94"]
	pub CSR: u32,
	#[doc = "< RCC Clock Recovery RC Register,                                                 Address offset: 0x98"]
	pub CRRCR: u32,
	#[doc = "< RCC HSE Clock Register,                                                         Address offset: 0x9C"]
	pub HSECR: u32,
	#[doc = "< Reserved,                                                                       Address offset: 0xA0-0x104"]
	pub RESERVED7: [u32; 26usize],
	#[doc = "< RCC Extended Clock Recovery Register,                                           Address offset: 0x108"]
	pub EXTCFGR: u32,
	#[doc = "< Reserved,                                                                       Address offset: 0x10C-0x144"]
	pub RESERVED8: [u32; 15usize],
	#[doc = "< RRCC AHB1 peripheral CPU2 clocks enable register,                               Address offset: 0x148"]
	pub C2AHB1ENR: u32,
	#[doc = "< RCC AHB2 peripheral CPU2 clocks enable register,                                Address offset: 0x14C"]
	pub C2AHB2ENR: u32,
	#[doc = "< RCC AHB3 & AHB4 peripheral CPU2 clocks enable register,,                        Address offset: 0x150"]
	pub C2AHB3ENR: u32,
	#[doc = "< Reserved,                                                                       Address offset: 0x154"]
	pub RESERVED9: u32,
	#[doc = "< RCC APB1 peripheral CPU2 clocks enable register 1,                              Address offset: 0x158"]
	pub C2APB1ENR1: u32,
	#[doc = "< RCC APB1 peripheral CPU2 clocks enable register 2,                              Address offset: 0x15C"]
	pub C2APB1ENR2: u32,
	#[doc = "< RCC APB2 peripheral CPU2 clocks enable register 1,                              Address offset: 0x160"]
	pub C2APB2ENR: u32,
	#[doc = "< RCC APB3 peripheral CPU2 clocks enable register 1,                              Address offset: 0x164"]
	pub C2APB3ENR: u32,
	#[doc = "< RCC AHB1 peripheral CPU2 clocks enable in sleep and stop modes register,        Address offset: 0x168"]
	pub C2AHB1SMENR: u32,
	#[doc = "< RCC AHB2 peripheral CPU2 clocks enable in sleep and stop modes register,        Address offset: 0x16C"]
	pub C2AHB2SMENR: u32,
	#[doc = "< RCC AHB3 & AHB4 peripheral CPU2 clocks enable in sleep and stop modes register, Address offset: 0x170"]
	pub C2AHB3SMENR: u32,
	#[doc = "< Reserved,"]
	pub RESERVED10: u32,
	#[doc = "< RCC APB1 peripheral CPU2 clocks enable in sleep mode and stop modes register 1, Address offset: 0x178"]
	pub C2APB1SMENR1: u32,
	#[doc = "< RCC APB1 peripheral CPU2 clocks enable in sleep mode and stop modes register 2, Address offset: 0x17C"]
	pub C2APB1SMENR2: u32,
	#[doc = "< RCC APB2 peripheral CPU2 clocks enable in sleep mode and stop modes register,   Address offset: 0x180"]
	pub C2APB2SMENR: u32,
	#[doc = "< RCC APB3 peripheral CPU2 clocks enable in sleep mode and stop modes register,   Address offset: 0x184"]
	pub C2APB3SMENR: u32,
}
#[test]
fn bindgen_test_layout_RCC_TypeDef() {
	assert_eq!(
	           ::core::mem::size_of::<RCC_TypeDef>(),
	           392usize,
	           concat!("Size of: ", stringify!(RCC_TypeDef))
	);
	assert_eq!(
	           ::core::mem::align_of::<RCC_TypeDef>(),
	           4usize,
	           concat!("Alignment of ", stringify!(RCC_TypeDef))
	);
	fn test_field_CR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<RCC_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).CR) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(RCC_TypeDef), "::", stringify!(CR))
		);
	}
	test_field_CR();
	fn test_field_ICSCR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<RCC_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).ICSCR) as usize - ptr as usize
		           },
		           4usize,
		           concat!("Offset of field: ", stringify!(RCC_TypeDef), "::", stringify!(ICSCR))
		);
	}
	test_field_ICSCR();
	fn test_field_CFGR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<RCC_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).CFGR) as usize - ptr as usize
		           },
		           8usize,
		           concat!("Offset of field: ", stringify!(RCC_TypeDef), "::", stringify!(CFGR))
		);
	}
	test_field_CFGR();
	fn test_field_PLLCFGR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<RCC_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).PLLCFGR) as usize - ptr as usize
		           },
		           12usize,
		           concat!("Offset of field: ", stringify!(RCC_TypeDef), "::", stringify!(PLLCFGR))
		);
	}
	test_field_PLLCFGR();
	fn test_field_PLLSAI1CFGR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<RCC_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).PLLSAI1CFGR) as usize - ptr as usize
		           },
		           16usize,
		           concat!("Offset of field: ", stringify!(RCC_TypeDef), "::", stringify!(PLLSAI1CFGR))
		);
	}
	test_field_PLLSAI1CFGR();
	fn test_field_RESERVED0() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<RCC_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).RESERVED0) as usize - ptr as usize
		           },
		           20usize,
		           concat!("Offset of field: ", stringify!(RCC_TypeDef), "::", stringify!(RESERVED0))
		);
	}
	test_field_RESERVED0();
	fn test_field_CIER() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<RCC_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).CIER) as usize - ptr as usize
		           },
		           24usize,
		           concat!("Offset of field: ", stringify!(RCC_TypeDef), "::", stringify!(CIER))
		);
	}
	test_field_CIER();
	fn test_field_CIFR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<RCC_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).CIFR) as usize - ptr as usize
		           },
		           28usize,
		           concat!("Offset of field: ", stringify!(RCC_TypeDef), "::", stringify!(CIFR))
		);
	}
	test_field_CIFR();
	fn test_field_CICR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<RCC_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).CICR) as usize - ptr as usize
		           },
		           32usize,
		           concat!("Offset of field: ", stringify!(RCC_TypeDef), "::", stringify!(CICR))
		);
	}
	test_field_CICR();
	fn test_field_SMPSCR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<RCC_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).SMPSCR) as usize - ptr as usize
		           },
		           36usize,
		           concat!("Offset of field: ", stringify!(RCC_TypeDef), "::", stringify!(SMPSCR))
		);
	}
	test_field_SMPSCR();
	fn test_field_AHB1RSTR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<RCC_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).AHB1RSTR) as usize - ptr as usize
		           },
		           40usize,
		           concat!("Offset of field: ", stringify!(RCC_TypeDef), "::", stringify!(AHB1RSTR))
		);
	}
	test_field_AHB1RSTR();
	fn test_field_AHB2RSTR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<RCC_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).AHB2RSTR) as usize - ptr as usize
		           },
		           44usize,
		           concat!("Offset of field: ", stringify!(RCC_TypeDef), "::", stringify!(AHB2RSTR))
		);
	}
	test_field_AHB2RSTR();
	fn test_field_AHB3RSTR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<RCC_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).AHB3RSTR) as usize - ptr as usize
		           },
		           48usize,
		           concat!("Offset of field: ", stringify!(RCC_TypeDef), "::", stringify!(AHB3RSTR))
		);
	}
	test_field_AHB3RSTR();
	fn test_field_RESERVED1() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<RCC_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).RESERVED1) as usize - ptr as usize
		           },
		           52usize,
		           concat!("Offset of field: ", stringify!(RCC_TypeDef), "::", stringify!(RESERVED1))
		);
	}
	test_field_RESERVED1();
	fn test_field_APB1RSTR1() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<RCC_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).APB1RSTR1) as usize - ptr as usize
		           },
		           56usize,
		           concat!("Offset of field: ", stringify!(RCC_TypeDef), "::", stringify!(APB1RSTR1))
		);
	}
	test_field_APB1RSTR1();
	fn test_field_APB1RSTR2() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<RCC_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).APB1RSTR2) as usize - ptr as usize
		           },
		           60usize,
		           concat!("Offset of field: ", stringify!(RCC_TypeDef), "::", stringify!(APB1RSTR2))
		);
	}
	test_field_APB1RSTR2();
	fn test_field_APB2RSTR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<RCC_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).APB2RSTR) as usize - ptr as usize
		           },
		           64usize,
		           concat!("Offset of field: ", stringify!(RCC_TypeDef), "::", stringify!(APB2RSTR))
		);
	}
	test_field_APB2RSTR();
	fn test_field_APB3RSTR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<RCC_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).APB3RSTR) as usize - ptr as usize
		           },
		           68usize,
		           concat!("Offset of field: ", stringify!(RCC_TypeDef), "::", stringify!(APB3RSTR))
		);
	}
	test_field_APB3RSTR();
	fn test_field_AHB1ENR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<RCC_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).AHB1ENR) as usize - ptr as usize
		           },
		           72usize,
		           concat!("Offset of field: ", stringify!(RCC_TypeDef), "::", stringify!(AHB1ENR))
		);
	}
	test_field_AHB1ENR();
	fn test_field_AHB2ENR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<RCC_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).AHB2ENR) as usize - ptr as usize
		           },
		           76usize,
		           concat!("Offset of field: ", stringify!(RCC_TypeDef), "::", stringify!(AHB2ENR))
		);
	}
	test_field_AHB2ENR();
	fn test_field_AHB3ENR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<RCC_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).AHB3ENR) as usize - ptr as usize
		           },
		           80usize,
		           concat!("Offset of field: ", stringify!(RCC_TypeDef), "::", stringify!(AHB3ENR))
		);
	}
	test_field_AHB3ENR();
	fn test_field_RESERVED2() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<RCC_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).RESERVED2) as usize - ptr as usize
		           },
		           84usize,
		           concat!("Offset of field: ", stringify!(RCC_TypeDef), "::", stringify!(RESERVED2))
		);
	}
	test_field_RESERVED2();
	fn test_field_APB1ENR1() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<RCC_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).APB1ENR1) as usize - ptr as usize
		           },
		           88usize,
		           concat!("Offset of field: ", stringify!(RCC_TypeDef), "::", stringify!(APB1ENR1))
		);
	}
	test_field_APB1ENR1();
	fn test_field_APB1ENR2() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<RCC_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).APB1ENR2) as usize - ptr as usize
		           },
		           92usize,
		           concat!("Offset of field: ", stringify!(RCC_TypeDef), "::", stringify!(APB1ENR2))
		);
	}
	test_field_APB1ENR2();
	fn test_field_APB2ENR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<RCC_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).APB2ENR) as usize - ptr as usize
		           },
		           96usize,
		           concat!("Offset of field: ", stringify!(RCC_TypeDef), "::", stringify!(APB2ENR))
		);
	}
	test_field_APB2ENR();
	fn test_field_RESERVED3() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<RCC_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).RESERVED3) as usize - ptr as usize
		           },
		           100usize,
		           concat!("Offset of field: ", stringify!(RCC_TypeDef), "::", stringify!(RESERVED3))
		);
	}
	test_field_RESERVED3();
	fn test_field_AHB1SMENR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<RCC_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).AHB1SMENR) as usize - ptr as usize
		           },
		           104usize,
		           concat!("Offset of field: ", stringify!(RCC_TypeDef), "::", stringify!(AHB1SMENR))
		);
	}
	test_field_AHB1SMENR();
	fn test_field_AHB2SMENR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<RCC_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).AHB2SMENR) as usize - ptr as usize
		           },
		           108usize,
		           concat!("Offset of field: ", stringify!(RCC_TypeDef), "::", stringify!(AHB2SMENR))
		);
	}
	test_field_AHB2SMENR();
	fn test_field_AHB3SMENR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<RCC_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).AHB3SMENR) as usize - ptr as usize
		           },
		           112usize,
		           concat!("Offset of field: ", stringify!(RCC_TypeDef), "::", stringify!(AHB3SMENR))
		);
	}
	test_field_AHB3SMENR();
	fn test_field_RESERVED4() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<RCC_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).RESERVED4) as usize - ptr as usize
		           },
		           116usize,
		           concat!("Offset of field: ", stringify!(RCC_TypeDef), "::", stringify!(RESERVED4))
		);
	}
	test_field_RESERVED4();
	fn test_field_APB1SMENR1() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<RCC_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).APB1SMENR1) as usize - ptr as usize
		           },
		           120usize,
		           concat!("Offset of field: ", stringify!(RCC_TypeDef), "::", stringify!(APB1SMENR1))
		);
	}
	test_field_APB1SMENR1();
	fn test_field_APB1SMENR2() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<RCC_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).APB1SMENR2) as usize - ptr as usize
		           },
		           124usize,
		           concat!("Offset of field: ", stringify!(RCC_TypeDef), "::", stringify!(APB1SMENR2))
		);
	}
	test_field_APB1SMENR2();
	fn test_field_APB2SMENR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<RCC_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).APB2SMENR) as usize - ptr as usize
		           },
		           128usize,
		           concat!("Offset of field: ", stringify!(RCC_TypeDef), "::", stringify!(APB2SMENR))
		);
	}
	test_field_APB2SMENR();
	fn test_field_RESERVED5() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<RCC_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).RESERVED5) as usize - ptr as usize
		           },
		           132usize,
		           concat!("Offset of field: ", stringify!(RCC_TypeDef), "::", stringify!(RESERVED5))
		);
	}
	test_field_RESERVED5();
	fn test_field_CCIPR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<RCC_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).CCIPR) as usize - ptr as usize
		           },
		           136usize,
		           concat!("Offset of field: ", stringify!(RCC_TypeDef), "::", stringify!(CCIPR))
		);
	}
	test_field_CCIPR();
	fn test_field_RESERVED6() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<RCC_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).RESERVED6) as usize - ptr as usize
		           },
		           140usize,
		           concat!("Offset of field: ", stringify!(RCC_TypeDef), "::", stringify!(RESERVED6))
		);
	}
	test_field_RESERVED6();
	fn test_field_BDCR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<RCC_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).BDCR) as usize - ptr as usize
		           },
		           144usize,
		           concat!("Offset of field: ", stringify!(RCC_TypeDef), "::", stringify!(BDCR))
		);
	}
	test_field_BDCR();
	fn test_field_CSR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<RCC_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).CSR) as usize - ptr as usize
		           },
		           148usize,
		           concat!("Offset of field: ", stringify!(RCC_TypeDef), "::", stringify!(CSR))
		);
	}
	test_field_CSR();
	fn test_field_CRRCR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<RCC_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).CRRCR) as usize - ptr as usize
		           },
		           152usize,
		           concat!("Offset of field: ", stringify!(RCC_TypeDef), "::", stringify!(CRRCR))
		);
	}
	test_field_CRRCR();
	fn test_field_HSECR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<RCC_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).HSECR) as usize - ptr as usize
		           },
		           156usize,
		           concat!("Offset of field: ", stringify!(RCC_TypeDef), "::", stringify!(HSECR))
		);
	}
	test_field_HSECR();
	fn test_field_RESERVED7() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<RCC_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).RESERVED7) as usize - ptr as usize
		           },
		           160usize,
		           concat!("Offset of field: ", stringify!(RCC_TypeDef), "::", stringify!(RESERVED7))
		);
	}
	test_field_RESERVED7();
	fn test_field_EXTCFGR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<RCC_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).EXTCFGR) as usize - ptr as usize
		           },
		           264usize,
		           concat!("Offset of field: ", stringify!(RCC_TypeDef), "::", stringify!(EXTCFGR))
		);
	}
	test_field_EXTCFGR();
	fn test_field_RESERVED8() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<RCC_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).RESERVED8) as usize - ptr as usize
		           },
		           268usize,
		           concat!("Offset of field: ", stringify!(RCC_TypeDef), "::", stringify!(RESERVED8))
		);
	}
	test_field_RESERVED8();
	fn test_field_C2AHB1ENR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<RCC_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).C2AHB1ENR) as usize - ptr as usize
		           },
		           328usize,
		           concat!("Offset of field: ", stringify!(RCC_TypeDef), "::", stringify!(C2AHB1ENR))
		);
	}
	test_field_C2AHB1ENR();
	fn test_field_C2AHB2ENR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<RCC_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).C2AHB2ENR) as usize - ptr as usize
		           },
		           332usize,
		           concat!("Offset of field: ", stringify!(RCC_TypeDef), "::", stringify!(C2AHB2ENR))
		);
	}
	test_field_C2AHB2ENR();
	fn test_field_C2AHB3ENR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<RCC_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).C2AHB3ENR) as usize - ptr as usize
		           },
		           336usize,
		           concat!("Offset of field: ", stringify!(RCC_TypeDef), "::", stringify!(C2AHB3ENR))
		);
	}
	test_field_C2AHB3ENR();
	fn test_field_RESERVED9() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<RCC_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).RESERVED9) as usize - ptr as usize
		           },
		           340usize,
		           concat!("Offset of field: ", stringify!(RCC_TypeDef), "::", stringify!(RESERVED9))
		);
	}
	test_field_RESERVED9();
	fn test_field_C2APB1ENR1() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<RCC_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).C2APB1ENR1) as usize - ptr as usize
		           },
		           344usize,
		           concat!("Offset of field: ", stringify!(RCC_TypeDef), "::", stringify!(C2APB1ENR1))
		);
	}
	test_field_C2APB1ENR1();
	fn test_field_C2APB1ENR2() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<RCC_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).C2APB1ENR2) as usize - ptr as usize
		           },
		           348usize,
		           concat!("Offset of field: ", stringify!(RCC_TypeDef), "::", stringify!(C2APB1ENR2))
		);
	}
	test_field_C2APB1ENR2();
	fn test_field_C2APB2ENR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<RCC_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).C2APB2ENR) as usize - ptr as usize
		           },
		           352usize,
		           concat!("Offset of field: ", stringify!(RCC_TypeDef), "::", stringify!(C2APB2ENR))
		);
	}
	test_field_C2APB2ENR();
	fn test_field_C2APB3ENR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<RCC_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).C2APB3ENR) as usize - ptr as usize
		           },
		           356usize,
		           concat!("Offset of field: ", stringify!(RCC_TypeDef), "::", stringify!(C2APB3ENR))
		);
	}
	test_field_C2APB3ENR();
	fn test_field_C2AHB1SMENR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<RCC_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).C2AHB1SMENR) as usize - ptr as usize
		           },
		           360usize,
		           concat!("Offset of field: ", stringify!(RCC_TypeDef), "::", stringify!(C2AHB1SMENR))
		);
	}
	test_field_C2AHB1SMENR();
	fn test_field_C2AHB2SMENR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<RCC_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).C2AHB2SMENR) as usize - ptr as usize
		           },
		           364usize,
		           concat!("Offset of field: ", stringify!(RCC_TypeDef), "::", stringify!(C2AHB2SMENR))
		);
	}
	test_field_C2AHB2SMENR();
	fn test_field_C2AHB3SMENR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<RCC_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).C2AHB3SMENR) as usize - ptr as usize
		           },
		           368usize,
		           concat!("Offset of field: ", stringify!(RCC_TypeDef), "::", stringify!(C2AHB3SMENR))
		);
	}
	test_field_C2AHB3SMENR();
	fn test_field_RESERVED10() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<RCC_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).RESERVED10) as usize - ptr as usize
		           },
		           372usize,
		           concat!("Offset of field: ", stringify!(RCC_TypeDef), "::", stringify!(RESERVED10))
		);
	}
	test_field_RESERVED10();
	fn test_field_C2APB1SMENR1() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<RCC_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).C2APB1SMENR1) as usize - ptr as usize
		           },
		           376usize,
		           concat!("Offset of field: ", stringify!(RCC_TypeDef), "::", stringify!(C2APB1SMENR1))
		);
	}
	test_field_C2APB1SMENR1();
	fn test_field_C2APB1SMENR2() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<RCC_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).C2APB1SMENR2) as usize - ptr as usize
		           },
		           380usize,
		           concat!("Offset of field: ", stringify!(RCC_TypeDef), "::", stringify!(C2APB1SMENR2))
		);
	}
	test_field_C2APB1SMENR2();
	fn test_field_C2APB2SMENR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<RCC_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).C2APB2SMENR) as usize - ptr as usize
		           },
		           384usize,
		           concat!("Offset of field: ", stringify!(RCC_TypeDef), "::", stringify!(C2APB2SMENR))
		);
	}
	test_field_C2APB2SMENR();
	fn test_field_C2APB3SMENR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<RCC_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).C2APB3SMENR) as usize - ptr as usize
		           },
		           388usize,
		           concat!("Offset of field: ", stringify!(RCC_TypeDef), "::", stringify!(C2APB3SMENR))
		);
	}
	test_field_C2APB3SMENR();
}
#[doc = " @brief Real-Time Clock"]
#[repr(C)]
pub struct RTC_TypeDef {
	#[doc = "< RTC time register,                                         Address offset: 0x00"]
	pub TR: u32,
	#[doc = "< RTC date register,                                         Address offset: 0x04"]
	pub DR: u32,
	#[doc = "< RTC control register,                                      Address offset: 0x08"]
	pub CR: u32,
	#[doc = "< RTC initialization and status register,                    Address offset: 0x0C"]
	pub ISR: u32,
	#[doc = "< RTC prescaler register,                                    Address offset: 0x10"]
	pub PRER: u32,
	#[doc = "< RTC wakeup timer register,                                 Address offset: 0x14"]
	pub WUTR: u32,
	#[doc = "< Reserved,                                                  Address offset: 0x18"]
	pub RESERVED: u32,
	#[doc = "< RTC alarm A register,                                      Address offset: 0x1C"]
	pub ALRMAR: u32,
	#[doc = "< RTC alarm B register,                                      Address offset: 0x20"]
	pub ALRMBR: u32,
	#[doc = "< RTC write protection register,                             Address offset: 0x24"]
	pub WPR: u32,
	#[doc = "< RTC sub second register,                                   Address offset: 0x28"]
	pub SSR: u32,
	#[doc = "< RTC shift control register,                                Address offset: 0x2C"]
	pub SHIFTR: u32,
	#[doc = "< RTC time stamp time register,                              Address offset: 0x30"]
	pub TSTR: u32,
	#[doc = "< RTC time stamp date register,                              Address offset: 0x34"]
	pub TSDR: u32,
	#[doc = "< RTC time-stamp sub second register,                        Address offset: 0x38"]
	pub TSSSR: u32,
	#[doc = "< RTC calibration register,                                  Address offset: 0x3C"]
	pub CALR: u32,
	#[doc = "< RTC tamper configuration register,                         Address offset: 0x40"]
	pub TAMPCR: u32,
	#[doc = "< RTC alarm A sub second register,                           Address offset: 0x44"]
	pub ALRMASSR: u32,
	#[doc = "< RTC alarm B sub second register,                           Address offset: 0x48"]
	pub ALRMBSSR: u32,
	#[doc = "< RTC option register,                                       Address offset  0x4C"]
	pub OR: u32,
	#[doc = "< RTC backup register 0,                                     Address offset: 0x50"]
	pub BKP0R: u32,
	#[doc = "< RTC backup register 1,                                     Address offset: 0x54"]
	pub BKP1R: u32,
	#[doc = "< RTC backup register 2,                                     Address offset: 0x58"]
	pub BKP2R: u32,
	#[doc = "< RTC backup register 3,                                     Address offset: 0x5C"]
	pub BKP3R: u32,
	#[doc = "< RTC backup register 4,                                     Address offset: 0x60"]
	pub BKP4R: u32,
	#[doc = "< RTC backup register 5,                                     Address offset: 0x64"]
	pub BKP5R: u32,
	#[doc = "< RTC backup register 6,                                     Address offset: 0x68"]
	pub BKP6R: u32,
	#[doc = "< RTC backup register 7,                                     Address offset: 0x6C"]
	pub BKP7R: u32,
	#[doc = "< RTC backup register 8,                                     Address offset: 0x70"]
	pub BKP8R: u32,
	#[doc = "< RTC backup register 9,                                     Address offset: 0x74"]
	pub BKP9R: u32,
	#[doc = "< RTC backup register 10,                                    Address offset: 0x78"]
	pub BKP10R: u32,
	#[doc = "< RTC backup register 11,                                    Address offset: 0x7C"]
	pub BKP11R: u32,
	#[doc = "< RTC backup register 12,                                    Address offset: 0x80"]
	pub BKP12R: u32,
	#[doc = "< RTC backup register 13,                                    Address offset: 0x84"]
	pub BKP13R: u32,
	#[doc = "< RTC backup register 14,                                    Address offset: 0x88"]
	pub BKP14R: u32,
	#[doc = "< RTC backup register 15,                                    Address offset: 0x8C"]
	pub BKP15R: u32,
	#[doc = "< RTC backup register 16,                                    Address offset: 0x90"]
	pub BKP16R: u32,
	#[doc = "< RTC backup register 17,                                    Address offset: 0x94"]
	pub BKP17R: u32,
	#[doc = "< RTC backup register 18,                                    Address offset: 0x98"]
	pub BKP18R: u32,
	#[doc = "< RTC backup register 19,                                    Address offset: 0x9C"]
	pub BKP19R: u32,
}
#[test]
fn bindgen_test_layout_RTC_TypeDef() {
	assert_eq!(
	           ::core::mem::size_of::<RTC_TypeDef>(),
	           160usize,
	           concat!("Size of: ", stringify!(RTC_TypeDef))
	);
	assert_eq!(
	           ::core::mem::align_of::<RTC_TypeDef>(),
	           4usize,
	           concat!("Alignment of ", stringify!(RTC_TypeDef))
	);
	fn test_field_TR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<RTC_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).TR) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(RTC_TypeDef), "::", stringify!(TR))
		);
	}
	test_field_TR();
	fn test_field_DR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<RTC_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).DR) as usize - ptr as usize
		           },
		           4usize,
		           concat!("Offset of field: ", stringify!(RTC_TypeDef), "::", stringify!(DR))
		);
	}
	test_field_DR();
	fn test_field_CR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<RTC_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).CR) as usize - ptr as usize
		           },
		           8usize,
		           concat!("Offset of field: ", stringify!(RTC_TypeDef), "::", stringify!(CR))
		);
	}
	test_field_CR();
	fn test_field_ISR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<RTC_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).ISR) as usize - ptr as usize
		           },
		           12usize,
		           concat!("Offset of field: ", stringify!(RTC_TypeDef), "::", stringify!(ISR))
		);
	}
	test_field_ISR();
	fn test_field_PRER() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<RTC_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).PRER) as usize - ptr as usize
		           },
		           16usize,
		           concat!("Offset of field: ", stringify!(RTC_TypeDef), "::", stringify!(PRER))
		);
	}
	test_field_PRER();
	fn test_field_WUTR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<RTC_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).WUTR) as usize - ptr as usize
		           },
		           20usize,
		           concat!("Offset of field: ", stringify!(RTC_TypeDef), "::", stringify!(WUTR))
		);
	}
	test_field_WUTR();
	fn test_field_RESERVED() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<RTC_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).RESERVED) as usize - ptr as usize
		           },
		           24usize,
		           concat!("Offset of field: ", stringify!(RTC_TypeDef), "::", stringify!(RESERVED))
		);
	}
	test_field_RESERVED();
	fn test_field_ALRMAR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<RTC_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).ALRMAR) as usize - ptr as usize
		           },
		           28usize,
		           concat!("Offset of field: ", stringify!(RTC_TypeDef), "::", stringify!(ALRMAR))
		);
	}
	test_field_ALRMAR();
	fn test_field_ALRMBR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<RTC_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).ALRMBR) as usize - ptr as usize
		           },
		           32usize,
		           concat!("Offset of field: ", stringify!(RTC_TypeDef), "::", stringify!(ALRMBR))
		);
	}
	test_field_ALRMBR();
	fn test_field_WPR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<RTC_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).WPR) as usize - ptr as usize
		           },
		           36usize,
		           concat!("Offset of field: ", stringify!(RTC_TypeDef), "::", stringify!(WPR))
		);
	}
	test_field_WPR();
	fn test_field_SSR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<RTC_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).SSR) as usize - ptr as usize
		           },
		           40usize,
		           concat!("Offset of field: ", stringify!(RTC_TypeDef), "::", stringify!(SSR))
		);
	}
	test_field_SSR();
	fn test_field_SHIFTR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<RTC_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).SHIFTR) as usize - ptr as usize
		           },
		           44usize,
		           concat!("Offset of field: ", stringify!(RTC_TypeDef), "::", stringify!(SHIFTR))
		);
	}
	test_field_SHIFTR();
	fn test_field_TSTR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<RTC_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).TSTR) as usize - ptr as usize
		           },
		           48usize,
		           concat!("Offset of field: ", stringify!(RTC_TypeDef), "::", stringify!(TSTR))
		);
	}
	test_field_TSTR();
	fn test_field_TSDR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<RTC_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).TSDR) as usize - ptr as usize
		           },
		           52usize,
		           concat!("Offset of field: ", stringify!(RTC_TypeDef), "::", stringify!(TSDR))
		);
	}
	test_field_TSDR();
	fn test_field_TSSSR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<RTC_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).TSSSR) as usize - ptr as usize
		           },
		           56usize,
		           concat!("Offset of field: ", stringify!(RTC_TypeDef), "::", stringify!(TSSSR))
		);
	}
	test_field_TSSSR();
	fn test_field_CALR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<RTC_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).CALR) as usize - ptr as usize
		           },
		           60usize,
		           concat!("Offset of field: ", stringify!(RTC_TypeDef), "::", stringify!(CALR))
		);
	}
	test_field_CALR();
	fn test_field_TAMPCR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<RTC_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).TAMPCR) as usize - ptr as usize
		           },
		           64usize,
		           concat!("Offset of field: ", stringify!(RTC_TypeDef), "::", stringify!(TAMPCR))
		);
	}
	test_field_TAMPCR();
	fn test_field_ALRMASSR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<RTC_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).ALRMASSR) as usize - ptr as usize
		           },
		           68usize,
		           concat!("Offset of field: ", stringify!(RTC_TypeDef), "::", stringify!(ALRMASSR))
		);
	}
	test_field_ALRMASSR();
	fn test_field_ALRMBSSR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<RTC_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).ALRMBSSR) as usize - ptr as usize
		           },
		           72usize,
		           concat!("Offset of field: ", stringify!(RTC_TypeDef), "::", stringify!(ALRMBSSR))
		);
	}
	test_field_ALRMBSSR();
	fn test_field_OR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<RTC_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).OR) as usize - ptr as usize
		           },
		           76usize,
		           concat!("Offset of field: ", stringify!(RTC_TypeDef), "::", stringify!(OR))
		);
	}
	test_field_OR();
	fn test_field_BKP0R() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<RTC_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).BKP0R) as usize - ptr as usize
		           },
		           80usize,
		           concat!("Offset of field: ", stringify!(RTC_TypeDef), "::", stringify!(BKP0R))
		);
	}
	test_field_BKP0R();
	fn test_field_BKP1R() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<RTC_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).BKP1R) as usize - ptr as usize
		           },
		           84usize,
		           concat!("Offset of field: ", stringify!(RTC_TypeDef), "::", stringify!(BKP1R))
		);
	}
	test_field_BKP1R();
	fn test_field_BKP2R() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<RTC_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).BKP2R) as usize - ptr as usize
		           },
		           88usize,
		           concat!("Offset of field: ", stringify!(RTC_TypeDef), "::", stringify!(BKP2R))
		);
	}
	test_field_BKP2R();
	fn test_field_BKP3R() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<RTC_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).BKP3R) as usize - ptr as usize
		           },
		           92usize,
		           concat!("Offset of field: ", stringify!(RTC_TypeDef), "::", stringify!(BKP3R))
		);
	}
	test_field_BKP3R();
	fn test_field_BKP4R() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<RTC_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).BKP4R) as usize - ptr as usize
		           },
		           96usize,
		           concat!("Offset of field: ", stringify!(RTC_TypeDef), "::", stringify!(BKP4R))
		);
	}
	test_field_BKP4R();
	fn test_field_BKP5R() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<RTC_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).BKP5R) as usize - ptr as usize
		           },
		           100usize,
		           concat!("Offset of field: ", stringify!(RTC_TypeDef), "::", stringify!(BKP5R))
		);
	}
	test_field_BKP5R();
	fn test_field_BKP6R() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<RTC_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).BKP6R) as usize - ptr as usize
		           },
		           104usize,
		           concat!("Offset of field: ", stringify!(RTC_TypeDef), "::", stringify!(BKP6R))
		);
	}
	test_field_BKP6R();
	fn test_field_BKP7R() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<RTC_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).BKP7R) as usize - ptr as usize
		           },
		           108usize,
		           concat!("Offset of field: ", stringify!(RTC_TypeDef), "::", stringify!(BKP7R))
		);
	}
	test_field_BKP7R();
	fn test_field_BKP8R() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<RTC_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).BKP8R) as usize - ptr as usize
		           },
		           112usize,
		           concat!("Offset of field: ", stringify!(RTC_TypeDef), "::", stringify!(BKP8R))
		);
	}
	test_field_BKP8R();
	fn test_field_BKP9R() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<RTC_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).BKP9R) as usize - ptr as usize
		           },
		           116usize,
		           concat!("Offset of field: ", stringify!(RTC_TypeDef), "::", stringify!(BKP9R))
		);
	}
	test_field_BKP9R();
	fn test_field_BKP10R() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<RTC_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).BKP10R) as usize - ptr as usize
		           },
		           120usize,
		           concat!("Offset of field: ", stringify!(RTC_TypeDef), "::", stringify!(BKP10R))
		);
	}
	test_field_BKP10R();
	fn test_field_BKP11R() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<RTC_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).BKP11R) as usize - ptr as usize
		           },
		           124usize,
		           concat!("Offset of field: ", stringify!(RTC_TypeDef), "::", stringify!(BKP11R))
		);
	}
	test_field_BKP11R();
	fn test_field_BKP12R() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<RTC_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).BKP12R) as usize - ptr as usize
		           },
		           128usize,
		           concat!("Offset of field: ", stringify!(RTC_TypeDef), "::", stringify!(BKP12R))
		);
	}
	test_field_BKP12R();
	fn test_field_BKP13R() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<RTC_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).BKP13R) as usize - ptr as usize
		           },
		           132usize,
		           concat!("Offset of field: ", stringify!(RTC_TypeDef), "::", stringify!(BKP13R))
		);
	}
	test_field_BKP13R();
	fn test_field_BKP14R() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<RTC_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).BKP14R) as usize - ptr as usize
		           },
		           136usize,
		           concat!("Offset of field: ", stringify!(RTC_TypeDef), "::", stringify!(BKP14R))
		);
	}
	test_field_BKP14R();
	fn test_field_BKP15R() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<RTC_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).BKP15R) as usize - ptr as usize
		           },
		           140usize,
		           concat!("Offset of field: ", stringify!(RTC_TypeDef), "::", stringify!(BKP15R))
		);
	}
	test_field_BKP15R();
	fn test_field_BKP16R() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<RTC_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).BKP16R) as usize - ptr as usize
		           },
		           144usize,
		           concat!("Offset of field: ", stringify!(RTC_TypeDef), "::", stringify!(BKP16R))
		);
	}
	test_field_BKP16R();
	fn test_field_BKP17R() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<RTC_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).BKP17R) as usize - ptr as usize
		           },
		           148usize,
		           concat!("Offset of field: ", stringify!(RTC_TypeDef), "::", stringify!(BKP17R))
		);
	}
	test_field_BKP17R();
	fn test_field_BKP18R() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<RTC_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).BKP18R) as usize - ptr as usize
		           },
		           152usize,
		           concat!("Offset of field: ", stringify!(RTC_TypeDef), "::", stringify!(BKP18R))
		);
	}
	test_field_BKP18R();
	fn test_field_BKP19R() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<RTC_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).BKP19R) as usize - ptr as usize
		           },
		           156usize,
		           concat!("Offset of field: ", stringify!(RTC_TypeDef), "::", stringify!(BKP19R))
		);
	}
	test_field_BKP19R();
}
#[doc = " @brief Serial Peripheral Interface"]
#[repr(C)]
pub struct SPI_TypeDef {
	#[doc = "< SPI Control register 1,       Address offset: 0x00"]
	pub CR1: u32,
	#[doc = "< SPI Control register 2,       Address offset: 0x04"]
	pub CR2: u32,
	#[doc = "< SPI Status register,          Address offset: 0x08"]
	pub SR: u32,
	#[doc = "< SPI data register,            Address offset: 0x0C"]
	pub DR: u32,
	#[doc = "< SPI CRC polynomial register,  Address offset: 0x10"]
	pub CRCPR: u32,
	#[doc = "< SPI Rx CRC register,          Address offset: 0x14"]
	pub RXCRCR: u32,
	#[doc = "< SPI Tx CRC register,          Address offset: 0x18"]
	pub TXCRCR: u32,
}
#[test]
fn bindgen_test_layout_SPI_TypeDef() {
	assert_eq!(
	           ::core::mem::size_of::<SPI_TypeDef>(),
	           28usize,
	           concat!("Size of: ", stringify!(SPI_TypeDef))
	);
	assert_eq!(
	           ::core::mem::align_of::<SPI_TypeDef>(),
	           4usize,
	           concat!("Alignment of ", stringify!(SPI_TypeDef))
	);
	fn test_field_CR1() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<SPI_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).CR1) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(SPI_TypeDef), "::", stringify!(CR1))
		);
	}
	test_field_CR1();
	fn test_field_CR2() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<SPI_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).CR2) as usize - ptr as usize
		           },
		           4usize,
		           concat!("Offset of field: ", stringify!(SPI_TypeDef), "::", stringify!(CR2))
		);
	}
	test_field_CR2();
	fn test_field_SR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<SPI_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).SR) as usize - ptr as usize
		           },
		           8usize,
		           concat!("Offset of field: ", stringify!(SPI_TypeDef), "::", stringify!(SR))
		);
	}
	test_field_SR();
	fn test_field_DR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<SPI_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).DR) as usize - ptr as usize
		           },
		           12usize,
		           concat!("Offset of field: ", stringify!(SPI_TypeDef), "::", stringify!(DR))
		);
	}
	test_field_DR();
	fn test_field_CRCPR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<SPI_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).CRCPR) as usize - ptr as usize
		           },
		           16usize,
		           concat!("Offset of field: ", stringify!(SPI_TypeDef), "::", stringify!(CRCPR))
		);
	}
	test_field_CRCPR();
	fn test_field_RXCRCR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<SPI_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).RXCRCR) as usize - ptr as usize
		           },
		           20usize,
		           concat!("Offset of field: ", stringify!(SPI_TypeDef), "::", stringify!(RXCRCR))
		);
	}
	test_field_RXCRCR();
	fn test_field_TXCRCR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<SPI_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).TXCRCR) as usize - ptr as usize
		           },
		           24usize,
		           concat!("Offset of field: ", stringify!(SPI_TypeDef), "::", stringify!(TXCRCR))
		);
	}
	test_field_TXCRCR();
}
#[doc = " @brief System configuration controller"]
#[repr(C)]
pub struct SYSCFG_TypeDef {
	#[doc = "< SYSCFG memory remap register                                            Address offset: 0x00"]
	pub MEMRMP: u32,
	#[doc = "< SYSCFG configuration register 1,                                        Address offset: 0x04"]
	pub CFGR1: u32,
	#[doc = "< SYSCFG external interrupt configuration registers,                      Address offset: 0x08-0x14"]
	pub EXTICR: [u32; 4usize],
	#[doc = "< SYSCFG SRAM2 control and status register,                               Address offset: 0x18"]
	pub SCSR: u32,
	#[doc = "< SYSCFG configuration register 2,                                        Address offset: 0x1C"]
	pub CFGR2: u32,
	#[doc = "< SYSCFG SRAM2 write protection register part 1,                          Address offset: 0x20"]
	pub SWPR1: u32,
	#[doc = "< SYSCFG SRAM2 key register,                                              Address offset: 0x24"]
	pub SKR: u32,
	#[doc = "< SYSCFG write protection register part 2,                                Address offset: 0x28"]
	pub SWPR2: u32,
	#[doc = "< Reserved,                                                               Address offset: 0x2C-0xFC"]
	pub RESERVED1: [u32; 53usize],
	#[doc = "< SYSCFG CPU1 (CORTEX M4) interrupt masks control-status register part 1, Address offset: 0x100"]
	pub IMR1: u32,
	#[doc = "< SYSCFG CPU1 (CORTEX M4) interrupt masks control-status register part 2, Address offset: 0x104"]
	pub IMR2: u32,
	#[doc = "< SYSCFG CPU2 (CORTEX M0) interrupt masks control-status register part 1, Address offset: 0x108"]
	pub C2IMR1: u32,
	#[doc = "< SYSCFG CPU2 (CORTEX M0) interrupt masks control-status register part 2, Address offset: 0x10C"]
	pub C2IMR2: u32,
	#[doc = "< SYSCFG secure IP control register,                                      Address offset: 0x110"]
	pub SIPCR: u32,
}
#[test]
fn bindgen_test_layout_SYSCFG_TypeDef() {
	assert_eq!(
	           ::core::mem::size_of::<SYSCFG_TypeDef>(),
	           276usize,
	           concat!("Size of: ", stringify!(SYSCFG_TypeDef))
	);
	assert_eq!(
	           ::core::mem::align_of::<SYSCFG_TypeDef>(),
	           4usize,
	           concat!("Alignment of ", stringify!(SYSCFG_TypeDef))
	);
	fn test_field_MEMRMP() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<SYSCFG_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).MEMRMP) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(SYSCFG_TypeDef), "::", stringify!(MEMRMP))
		);
	}
	test_field_MEMRMP();
	fn test_field_CFGR1() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<SYSCFG_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).CFGR1) as usize - ptr as usize
		           },
		           4usize,
		           concat!("Offset of field: ", stringify!(SYSCFG_TypeDef), "::", stringify!(CFGR1))
		);
	}
	test_field_CFGR1();
	fn test_field_EXTICR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<SYSCFG_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).EXTICR) as usize - ptr as usize
		           },
		           8usize,
		           concat!("Offset of field: ", stringify!(SYSCFG_TypeDef), "::", stringify!(EXTICR))
		);
	}
	test_field_EXTICR();
	fn test_field_SCSR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<SYSCFG_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).SCSR) as usize - ptr as usize
		           },
		           24usize,
		           concat!("Offset of field: ", stringify!(SYSCFG_TypeDef), "::", stringify!(SCSR))
		);
	}
	test_field_SCSR();
	fn test_field_CFGR2() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<SYSCFG_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).CFGR2) as usize - ptr as usize
		           },
		           28usize,
		           concat!("Offset of field: ", stringify!(SYSCFG_TypeDef), "::", stringify!(CFGR2))
		);
	}
	test_field_CFGR2();
	fn test_field_SWPR1() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<SYSCFG_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).SWPR1) as usize - ptr as usize
		           },
		           32usize,
		           concat!("Offset of field: ", stringify!(SYSCFG_TypeDef), "::", stringify!(SWPR1))
		);
	}
	test_field_SWPR1();
	fn test_field_SKR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<SYSCFG_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).SKR) as usize - ptr as usize
		           },
		           36usize,
		           concat!("Offset of field: ", stringify!(SYSCFG_TypeDef), "::", stringify!(SKR))
		);
	}
	test_field_SKR();
	fn test_field_SWPR2() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<SYSCFG_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).SWPR2) as usize - ptr as usize
		           },
		           40usize,
		           concat!("Offset of field: ", stringify!(SYSCFG_TypeDef), "::", stringify!(SWPR2))
		);
	}
	test_field_SWPR2();
	fn test_field_RESERVED1() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<SYSCFG_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).RESERVED1) as usize - ptr as usize
		           },
		           44usize,
		           concat!("Offset of field: ", stringify!(SYSCFG_TypeDef), "::", stringify!(RESERVED1))
		);
	}
	test_field_RESERVED1();
	fn test_field_IMR1() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<SYSCFG_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).IMR1) as usize - ptr as usize
		           },
		           256usize,
		           concat!("Offset of field: ", stringify!(SYSCFG_TypeDef), "::", stringify!(IMR1))
		);
	}
	test_field_IMR1();
	fn test_field_IMR2() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<SYSCFG_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).IMR2) as usize - ptr as usize
		           },
		           260usize,
		           concat!("Offset of field: ", stringify!(SYSCFG_TypeDef), "::", stringify!(IMR2))
		);
	}
	test_field_IMR2();
	fn test_field_C2IMR1() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<SYSCFG_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).C2IMR1) as usize - ptr as usize
		           },
		           264usize,
		           concat!("Offset of field: ", stringify!(SYSCFG_TypeDef), "::", stringify!(C2IMR1))
		);
	}
	test_field_C2IMR1();
	fn test_field_C2IMR2() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<SYSCFG_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).C2IMR2) as usize - ptr as usize
		           },
		           268usize,
		           concat!("Offset of field: ", stringify!(SYSCFG_TypeDef), "::", stringify!(C2IMR2))
		);
	}
	test_field_C2IMR2();
	fn test_field_SIPCR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<SYSCFG_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).SIPCR) as usize - ptr as usize
		           },
		           272usize,
		           concat!("Offset of field: ", stringify!(SYSCFG_TypeDef), "::", stringify!(SIPCR))
		);
	}
	test_field_SIPCR();
}
#[doc = " @brief VREFBUF"]
#[repr(C)]
pub struct VREFBUF_TypeDef {
	#[doc = "< VREFBUF control and status register,         Address offset: 0x00"]
	pub CSR: u32,
	#[doc = "< VREFBUF calibration and control register,    Address offset: 0x04"]
	pub CCR: u32,
}
#[test]
fn bindgen_test_layout_VREFBUF_TypeDef() {
	assert_eq!(
	           ::core::mem::size_of::<VREFBUF_TypeDef>(),
	           8usize,
	           concat!("Size of: ", stringify!(VREFBUF_TypeDef))
	);
	assert_eq!(
	           ::core::mem::align_of::<VREFBUF_TypeDef>(),
	           4usize,
	           concat!("Alignment of ", stringify!(VREFBUF_TypeDef))
	);
	fn test_field_CSR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<VREFBUF_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).CSR) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(VREFBUF_TypeDef), "::", stringify!(CSR))
		);
	}
	test_field_CSR();
	fn test_field_CCR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<VREFBUF_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).CCR) as usize - ptr as usize
		           },
		           4usize,
		           concat!("Offset of field: ", stringify!(VREFBUF_TypeDef), "::", stringify!(CCR))
		);
	}
	test_field_CCR();
}
#[doc = " @brief TIM"]
#[repr(C)]
pub struct TIM_TypeDef {
	#[doc = "< TIM control register 1,                   Address offset: 0x00"]
	pub CR1: u32,
	#[doc = "< TIM control register 2,                   Address offset: 0x04"]
	pub CR2: u32,
	#[doc = "< TIM slave mode control register,          Address offset: 0x08"]
	pub SMCR: u32,
	#[doc = "< TIM DMA/interrupt enable register,        Address offset: 0x0C"]
	pub DIER: u32,
	#[doc = "< TIM status register,                      Address offset: 0x10"]
	pub SR: u32,
	#[doc = "< TIM event generation register,            Address offset: 0x14"]
	pub EGR: u32,
	#[doc = "< TIM capture/compare mode register 1,      Address offset: 0x18"]
	pub CCMR1: u32,
	#[doc = "< TIM capture/compare mode register 2,      Address offset: 0x1C"]
	pub CCMR2: u32,
	#[doc = "< TIM capture/compare enable register,      Address offset: 0x20"]
	pub CCER: u32,
	#[doc = "< TIM counter register,                     Address offset: 0x24"]
	pub CNT: u32,
	#[doc = "< TIM prescaler register,                   Address offset: 0x28"]
	pub PSC: u32,
	#[doc = "< TIM auto-reload register,                 Address offset: 0x2C"]
	pub ARR: u32,
	#[doc = "< TIM repetition counter register,          Address offset: 0x30"]
	pub RCR: u32,
	#[doc = "< TIM capture/compare register 1,           Address offset: 0x34"]
	pub CCR1: u32,
	#[doc = "< TIM capture/compare register 2,           Address offset: 0x38"]
	pub CCR2: u32,
	#[doc = "< TIM capture/compare register 3,           Address offset: 0x3C"]
	pub CCR3: u32,
	#[doc = "< TIM capture/compare register 4,           Address offset: 0x40"]
	pub CCR4: u32,
	#[doc = "< TIM break and dead-time register,         Address offset: 0x44"]
	pub BDTR: u32,
	#[doc = "< TIM DMA control register,                 Address offset: 0x48"]
	pub DCR: u32,
	#[doc = "< TIM DMA address for full transfer,        Address offset: 0x4C"]
	pub DMAR: u32,
	#[doc = "< TIM option register                       Address offset: 0x50"]
	pub OR: u32,
	#[doc = "< TIM capture/compare mode register 3,      Address offset: 0x54"]
	pub CCMR3: u32,
	#[doc = "< TIM capture/compare register5,            Address offset: 0x58"]
	pub CCR5: u32,
	#[doc = "< TIM capture/compare register6,            Address offset: 0x5C"]
	pub CCR6: u32,
	#[doc = "< TIM Alternate function option register 1, Address offset: 0x60"]
	pub AF1: u32,
	#[doc = "< TIM Alternate function option register 2, Address offset: 0x64"]
	pub AF2: u32,
}
#[test]
fn bindgen_test_layout_TIM_TypeDef() {
	assert_eq!(
	           ::core::mem::size_of::<TIM_TypeDef>(),
	           104usize,
	           concat!("Size of: ", stringify!(TIM_TypeDef))
	);
	assert_eq!(
	           ::core::mem::align_of::<TIM_TypeDef>(),
	           4usize,
	           concat!("Alignment of ", stringify!(TIM_TypeDef))
	);
	fn test_field_CR1() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<TIM_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).CR1) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(TIM_TypeDef), "::", stringify!(CR1))
		);
	}
	test_field_CR1();
	fn test_field_CR2() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<TIM_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).CR2) as usize - ptr as usize
		           },
		           4usize,
		           concat!("Offset of field: ", stringify!(TIM_TypeDef), "::", stringify!(CR2))
		);
	}
	test_field_CR2();
	fn test_field_SMCR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<TIM_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).SMCR) as usize - ptr as usize
		           },
		           8usize,
		           concat!("Offset of field: ", stringify!(TIM_TypeDef), "::", stringify!(SMCR))
		);
	}
	test_field_SMCR();
	fn test_field_DIER() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<TIM_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).DIER) as usize - ptr as usize
		           },
		           12usize,
		           concat!("Offset of field: ", stringify!(TIM_TypeDef), "::", stringify!(DIER))
		);
	}
	test_field_DIER();
	fn test_field_SR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<TIM_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).SR) as usize - ptr as usize
		           },
		           16usize,
		           concat!("Offset of field: ", stringify!(TIM_TypeDef), "::", stringify!(SR))
		);
	}
	test_field_SR();
	fn test_field_EGR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<TIM_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).EGR) as usize - ptr as usize
		           },
		           20usize,
		           concat!("Offset of field: ", stringify!(TIM_TypeDef), "::", stringify!(EGR))
		);
	}
	test_field_EGR();
	fn test_field_CCMR1() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<TIM_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).CCMR1) as usize - ptr as usize
		           },
		           24usize,
		           concat!("Offset of field: ", stringify!(TIM_TypeDef), "::", stringify!(CCMR1))
		);
	}
	test_field_CCMR1();
	fn test_field_CCMR2() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<TIM_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).CCMR2) as usize - ptr as usize
		           },
		           28usize,
		           concat!("Offset of field: ", stringify!(TIM_TypeDef), "::", stringify!(CCMR2))
		);
	}
	test_field_CCMR2();
	fn test_field_CCER() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<TIM_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).CCER) as usize - ptr as usize
		           },
		           32usize,
		           concat!("Offset of field: ", stringify!(TIM_TypeDef), "::", stringify!(CCER))
		);
	}
	test_field_CCER();
	fn test_field_CNT() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<TIM_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).CNT) as usize - ptr as usize
		           },
		           36usize,
		           concat!("Offset of field: ", stringify!(TIM_TypeDef), "::", stringify!(CNT))
		);
	}
	test_field_CNT();
	fn test_field_PSC() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<TIM_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).PSC) as usize - ptr as usize
		           },
		           40usize,
		           concat!("Offset of field: ", stringify!(TIM_TypeDef), "::", stringify!(PSC))
		);
	}
	test_field_PSC();
	fn test_field_ARR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<TIM_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).ARR) as usize - ptr as usize
		           },
		           44usize,
		           concat!("Offset of field: ", stringify!(TIM_TypeDef), "::", stringify!(ARR))
		);
	}
	test_field_ARR();
	fn test_field_RCR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<TIM_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).RCR) as usize - ptr as usize
		           },
		           48usize,
		           concat!("Offset of field: ", stringify!(TIM_TypeDef), "::", stringify!(RCR))
		);
	}
	test_field_RCR();
	fn test_field_CCR1() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<TIM_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).CCR1) as usize - ptr as usize
		           },
		           52usize,
		           concat!("Offset of field: ", stringify!(TIM_TypeDef), "::", stringify!(CCR1))
		);
	}
	test_field_CCR1();
	fn test_field_CCR2() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<TIM_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).CCR2) as usize - ptr as usize
		           },
		           56usize,
		           concat!("Offset of field: ", stringify!(TIM_TypeDef), "::", stringify!(CCR2))
		);
	}
	test_field_CCR2();
	fn test_field_CCR3() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<TIM_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).CCR3) as usize - ptr as usize
		           },
		           60usize,
		           concat!("Offset of field: ", stringify!(TIM_TypeDef), "::", stringify!(CCR3))
		);
	}
	test_field_CCR3();
	fn test_field_CCR4() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<TIM_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).CCR4) as usize - ptr as usize
		           },
		           64usize,
		           concat!("Offset of field: ", stringify!(TIM_TypeDef), "::", stringify!(CCR4))
		);
	}
	test_field_CCR4();
	fn test_field_BDTR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<TIM_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).BDTR) as usize - ptr as usize
		           },
		           68usize,
		           concat!("Offset of field: ", stringify!(TIM_TypeDef), "::", stringify!(BDTR))
		);
	}
	test_field_BDTR();
	fn test_field_DCR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<TIM_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).DCR) as usize - ptr as usize
		           },
		           72usize,
		           concat!("Offset of field: ", stringify!(TIM_TypeDef), "::", stringify!(DCR))
		);
	}
	test_field_DCR();
	fn test_field_DMAR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<TIM_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).DMAR) as usize - ptr as usize
		           },
		           76usize,
		           concat!("Offset of field: ", stringify!(TIM_TypeDef), "::", stringify!(DMAR))
		);
	}
	test_field_DMAR();
	fn test_field_OR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<TIM_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).OR) as usize - ptr as usize
		           },
		           80usize,
		           concat!("Offset of field: ", stringify!(TIM_TypeDef), "::", stringify!(OR))
		);
	}
	test_field_OR();
	fn test_field_CCMR3() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<TIM_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).CCMR3) as usize - ptr as usize
		           },
		           84usize,
		           concat!("Offset of field: ", stringify!(TIM_TypeDef), "::", stringify!(CCMR3))
		);
	}
	test_field_CCMR3();
	fn test_field_CCR5() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<TIM_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).CCR5) as usize - ptr as usize
		           },
		           88usize,
		           concat!("Offset of field: ", stringify!(TIM_TypeDef), "::", stringify!(CCR5))
		);
	}
	test_field_CCR5();
	fn test_field_CCR6() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<TIM_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).CCR6) as usize - ptr as usize
		           },
		           92usize,
		           concat!("Offset of field: ", stringify!(TIM_TypeDef), "::", stringify!(CCR6))
		);
	}
	test_field_CCR6();
	fn test_field_AF1() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<TIM_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).AF1) as usize - ptr as usize
		           },
		           96usize,
		           concat!("Offset of field: ", stringify!(TIM_TypeDef), "::", stringify!(AF1))
		);
	}
	test_field_AF1();
	fn test_field_AF2() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<TIM_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).AF2) as usize - ptr as usize
		           },
		           100usize,
		           concat!("Offset of field: ", stringify!(TIM_TypeDef), "::", stringify!(AF2))
		);
	}
	test_field_AF2();
}
#[doc = " @brief Universal Synchronous Asynchronous Receiver Transmitter"]
#[repr(C)]
pub struct USART_TypeDef {
	#[doc = "< USART Control register 1,                 Address offset: 0x00"]
	pub CR1: u32,
	#[doc = "< USART Control register 2,                 Address offset: 0x04"]
	pub CR2: u32,
	#[doc = "< USART Control register 3,                 Address offset: 0x08"]
	pub CR3: u32,
	#[doc = "< USART Baud rate register,                 Address offset: 0x0C"]
	pub BRR: u32,
	#[doc = "< USART Guard time and prescaler register,  Address offset: 0x10"]
	pub GTPR: u32,
	#[doc = "< USART Receiver Time Out register,         Address offset: 0x14"]
	pub RTOR: u32,
	#[doc = "< USART Request register,                   Address offset: 0x18"]
	pub RQR: u32,
	#[doc = "< USART Interrupt and status register,      Address offset: 0x1C"]
	pub ISR: u32,
	#[doc = "< USART Interrupt flag Clear register,      Address offset: 0x20"]
	pub ICR: u32,
	#[doc = "< USART Receive Data register,              Address offset: 0x24"]
	pub RDR: u32,
	#[doc = "< USART Transmit Data register,             Address offset: 0x28"]
	pub TDR: u32,
	#[doc = "< USART Prescaler register,                 Address offset: 0x2C"]
	pub PRESC: u32,
}
#[test]
fn bindgen_test_layout_USART_TypeDef() {
	assert_eq!(
	           ::core::mem::size_of::<USART_TypeDef>(),
	           48usize,
	           concat!("Size of: ", stringify!(USART_TypeDef))
	);
	assert_eq!(
	           ::core::mem::align_of::<USART_TypeDef>(),
	           4usize,
	           concat!("Alignment of ", stringify!(USART_TypeDef))
	);
	fn test_field_CR1() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<USART_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).CR1) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(USART_TypeDef), "::", stringify!(CR1))
		);
	}
	test_field_CR1();
	fn test_field_CR2() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<USART_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).CR2) as usize - ptr as usize
		           },
		           4usize,
		           concat!("Offset of field: ", stringify!(USART_TypeDef), "::", stringify!(CR2))
		);
	}
	test_field_CR2();
	fn test_field_CR3() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<USART_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).CR3) as usize - ptr as usize
		           },
		           8usize,
		           concat!("Offset of field: ", stringify!(USART_TypeDef), "::", stringify!(CR3))
		);
	}
	test_field_CR3();
	fn test_field_BRR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<USART_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).BRR) as usize - ptr as usize
		           },
		           12usize,
		           concat!("Offset of field: ", stringify!(USART_TypeDef), "::", stringify!(BRR))
		);
	}
	test_field_BRR();
	fn test_field_GTPR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<USART_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).GTPR) as usize - ptr as usize
		           },
		           16usize,
		           concat!("Offset of field: ", stringify!(USART_TypeDef), "::", stringify!(GTPR))
		);
	}
	test_field_GTPR();
	fn test_field_RTOR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<USART_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).RTOR) as usize - ptr as usize
		           },
		           20usize,
		           concat!("Offset of field: ", stringify!(USART_TypeDef), "::", stringify!(RTOR))
		);
	}
	test_field_RTOR();
	fn test_field_RQR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<USART_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).RQR) as usize - ptr as usize
		           },
		           24usize,
		           concat!("Offset of field: ", stringify!(USART_TypeDef), "::", stringify!(RQR))
		);
	}
	test_field_RQR();
	fn test_field_ISR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<USART_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).ISR) as usize - ptr as usize
		           },
		           28usize,
		           concat!("Offset of field: ", stringify!(USART_TypeDef), "::", stringify!(ISR))
		);
	}
	test_field_ISR();
	fn test_field_ICR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<USART_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).ICR) as usize - ptr as usize
		           },
		           32usize,
		           concat!("Offset of field: ", stringify!(USART_TypeDef), "::", stringify!(ICR))
		);
	}
	test_field_ICR();
	fn test_field_RDR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<USART_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).RDR) as usize - ptr as usize
		           },
		           36usize,
		           concat!("Offset of field: ", stringify!(USART_TypeDef), "::", stringify!(RDR))
		);
	}
	test_field_RDR();
	fn test_field_TDR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<USART_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).TDR) as usize - ptr as usize
		           },
		           40usize,
		           concat!("Offset of field: ", stringify!(USART_TypeDef), "::", stringify!(TDR))
		);
	}
	test_field_TDR();
	fn test_field_PRESC() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<USART_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).PRESC) as usize - ptr as usize
		           },
		           44usize,
		           concat!("Offset of field: ", stringify!(USART_TypeDef), "::", stringify!(PRESC))
		);
	}
	test_field_PRESC();
}
#[doc = " @brief Window WATCHDOG"]
#[repr(C)]
pub struct WWDG_TypeDef {
	#[doc = "< WWDG Control register,       Address offset: 0x00"]
	pub CR: u32,
	#[doc = "< WWDG Configuration register, Address offset: 0x04"]
	pub CFR: u32,
	#[doc = "< WWDG Status register,        Address offset: 0x08"]
	pub SR: u32,
}
#[test]
fn bindgen_test_layout_WWDG_TypeDef() {
	assert_eq!(
	           ::core::mem::size_of::<WWDG_TypeDef>(),
	           12usize,
	           concat!("Size of: ", stringify!(WWDG_TypeDef))
	);
	assert_eq!(
	           ::core::mem::align_of::<WWDG_TypeDef>(),
	           4usize,
	           concat!("Alignment of ", stringify!(WWDG_TypeDef))
	);
	fn test_field_CR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<WWDG_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).CR) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(WWDG_TypeDef), "::", stringify!(CR))
		);
	}
	test_field_CR();
	fn test_field_CFR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<WWDG_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).CFR) as usize - ptr as usize
		           },
		           4usize,
		           concat!("Offset of field: ", stringify!(WWDG_TypeDef), "::", stringify!(CFR))
		);
	}
	test_field_CFR();
	fn test_field_SR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<WWDG_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).SR) as usize - ptr as usize
		           },
		           8usize,
		           concat!("Offset of field: ", stringify!(WWDG_TypeDef), "::", stringify!(SR))
		);
	}
	test_field_SR();
}
#[doc = " @brief AES hardware accelerator"]
#[repr(C)]
pub struct AES_TypeDef {
	#[doc = "< AES control register,                        Address offset: 0x00"]
	pub CR: u32,
	#[doc = "< AES status register,                         Address offset: 0x04"]
	pub SR: u32,
	#[doc = "< AES data input register,                     Address offset: 0x08"]
	pub DINR: u32,
	#[doc = "< AES data output register,                    Address offset: 0x0C"]
	pub DOUTR: u32,
	#[doc = "< AES key register 0,                          Address offset: 0x10"]
	pub KEYR0: u32,
	#[doc = "< AES key register 1,                          Address offset: 0x14"]
	pub KEYR1: u32,
	#[doc = "< AES key register 2,                          Address offset: 0x18"]
	pub KEYR2: u32,
	#[doc = "< AES key register 3,                          Address offset: 0x1C"]
	pub KEYR3: u32,
	#[doc = "< AES initialization vector register 0,        Address offset: 0x20"]
	pub IVR0: u32,
	#[doc = "< AES initialization vector register 1,        Address offset: 0x24"]
	pub IVR1: u32,
	#[doc = "< AES initialization vector register 2,        Address offset: 0x28"]
	pub IVR2: u32,
	#[doc = "< AES initialization vector register 3,        Address offset: 0x2C"]
	pub IVR3: u32,
	#[doc = "< AES key register 4,                          Address offset: 0x30"]
	pub KEYR4: u32,
	#[doc = "< AES key register 5,                          Address offset: 0x34"]
	pub KEYR5: u32,
	#[doc = "< AES key register 6,                          Address offset: 0x38"]
	pub KEYR6: u32,
	#[doc = "< AES key register 7,                          Address offset: 0x3C"]
	pub KEYR7: u32,
	#[doc = "< AES Suspend register 0,                      Address offset: 0x40"]
	pub SUSP0R: u32,
	#[doc = "< AES Suspend register 1,                      Address offset: 0x44"]
	pub SUSP1R: u32,
	#[doc = "< AES Suspend register 2,                      Address offset: 0x48"]
	pub SUSP2R: u32,
	#[doc = "< AES Suspend register 3,                      Address offset: 0x4C"]
	pub SUSP3R: u32,
	#[doc = "< AES Suspend register 4,                      Address offset: 0x50"]
	pub SUSP4R: u32,
	#[doc = "< AES Suspend register 5,                      Address offset: 0x54"]
	pub SUSP5R: u32,
	#[doc = "< AES Suspend register 6,                      Address offset: 0x58"]
	pub SUSP6R: u32,
	#[doc = "< AES Suspend register 7,                      Address offset: 0x6C"]
	pub SUSP7R: u32,
}
#[test]
fn bindgen_test_layout_AES_TypeDef() {
	assert_eq!(
	           ::core::mem::size_of::<AES_TypeDef>(),
	           96usize,
	           concat!("Size of: ", stringify!(AES_TypeDef))
	);
	assert_eq!(
	           ::core::mem::align_of::<AES_TypeDef>(),
	           4usize,
	           concat!("Alignment of ", stringify!(AES_TypeDef))
	);
	fn test_field_CR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<AES_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).CR) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(AES_TypeDef), "::", stringify!(CR))
		);
	}
	test_field_CR();
	fn test_field_SR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<AES_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).SR) as usize - ptr as usize
		           },
		           4usize,
		           concat!("Offset of field: ", stringify!(AES_TypeDef), "::", stringify!(SR))
		);
	}
	test_field_SR();
	fn test_field_DINR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<AES_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).DINR) as usize - ptr as usize
		           },
		           8usize,
		           concat!("Offset of field: ", stringify!(AES_TypeDef), "::", stringify!(DINR))
		);
	}
	test_field_DINR();
	fn test_field_DOUTR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<AES_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).DOUTR) as usize - ptr as usize
		           },
		           12usize,
		           concat!("Offset of field: ", stringify!(AES_TypeDef), "::", stringify!(DOUTR))
		);
	}
	test_field_DOUTR();
	fn test_field_KEYR0() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<AES_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).KEYR0) as usize - ptr as usize
		           },
		           16usize,
		           concat!("Offset of field: ", stringify!(AES_TypeDef), "::", stringify!(KEYR0))
		);
	}
	test_field_KEYR0();
	fn test_field_KEYR1() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<AES_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).KEYR1) as usize - ptr as usize
		           },
		           20usize,
		           concat!("Offset of field: ", stringify!(AES_TypeDef), "::", stringify!(KEYR1))
		);
	}
	test_field_KEYR1();
	fn test_field_KEYR2() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<AES_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).KEYR2) as usize - ptr as usize
		           },
		           24usize,
		           concat!("Offset of field: ", stringify!(AES_TypeDef), "::", stringify!(KEYR2))
		);
	}
	test_field_KEYR2();
	fn test_field_KEYR3() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<AES_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).KEYR3) as usize - ptr as usize
		           },
		           28usize,
		           concat!("Offset of field: ", stringify!(AES_TypeDef), "::", stringify!(KEYR3))
		);
	}
	test_field_KEYR3();
	fn test_field_IVR0() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<AES_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).IVR0) as usize - ptr as usize
		           },
		           32usize,
		           concat!("Offset of field: ", stringify!(AES_TypeDef), "::", stringify!(IVR0))
		);
	}
	test_field_IVR0();
	fn test_field_IVR1() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<AES_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).IVR1) as usize - ptr as usize
		           },
		           36usize,
		           concat!("Offset of field: ", stringify!(AES_TypeDef), "::", stringify!(IVR1))
		);
	}
	test_field_IVR1();
	fn test_field_IVR2() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<AES_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).IVR2) as usize - ptr as usize
		           },
		           40usize,
		           concat!("Offset of field: ", stringify!(AES_TypeDef), "::", stringify!(IVR2))
		);
	}
	test_field_IVR2();
	fn test_field_IVR3() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<AES_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).IVR3) as usize - ptr as usize
		           },
		           44usize,
		           concat!("Offset of field: ", stringify!(AES_TypeDef), "::", stringify!(IVR3))
		);
	}
	test_field_IVR3();
	fn test_field_KEYR4() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<AES_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).KEYR4) as usize - ptr as usize
		           },
		           48usize,
		           concat!("Offset of field: ", stringify!(AES_TypeDef), "::", stringify!(KEYR4))
		);
	}
	test_field_KEYR4();
	fn test_field_KEYR5() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<AES_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).KEYR5) as usize - ptr as usize
		           },
		           52usize,
		           concat!("Offset of field: ", stringify!(AES_TypeDef), "::", stringify!(KEYR5))
		);
	}
	test_field_KEYR5();
	fn test_field_KEYR6() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<AES_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).KEYR6) as usize - ptr as usize
		           },
		           56usize,
		           concat!("Offset of field: ", stringify!(AES_TypeDef), "::", stringify!(KEYR6))
		);
	}
	test_field_KEYR6();
	fn test_field_KEYR7() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<AES_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).KEYR7) as usize - ptr as usize
		           },
		           60usize,
		           concat!("Offset of field: ", stringify!(AES_TypeDef), "::", stringify!(KEYR7))
		);
	}
	test_field_KEYR7();
	fn test_field_SUSP0R() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<AES_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).SUSP0R) as usize - ptr as usize
		           },
		           64usize,
		           concat!("Offset of field: ", stringify!(AES_TypeDef), "::", stringify!(SUSP0R))
		);
	}
	test_field_SUSP0R();
	fn test_field_SUSP1R() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<AES_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).SUSP1R) as usize - ptr as usize
		           },
		           68usize,
		           concat!("Offset of field: ", stringify!(AES_TypeDef), "::", stringify!(SUSP1R))
		);
	}
	test_field_SUSP1R();
	fn test_field_SUSP2R() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<AES_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).SUSP2R) as usize - ptr as usize
		           },
		           72usize,
		           concat!("Offset of field: ", stringify!(AES_TypeDef), "::", stringify!(SUSP2R))
		);
	}
	test_field_SUSP2R();
	fn test_field_SUSP3R() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<AES_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).SUSP3R) as usize - ptr as usize
		           },
		           76usize,
		           concat!("Offset of field: ", stringify!(AES_TypeDef), "::", stringify!(SUSP3R))
		);
	}
	test_field_SUSP3R();
	fn test_field_SUSP4R() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<AES_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).SUSP4R) as usize - ptr as usize
		           },
		           80usize,
		           concat!("Offset of field: ", stringify!(AES_TypeDef), "::", stringify!(SUSP4R))
		);
	}
	test_field_SUSP4R();
	fn test_field_SUSP5R() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<AES_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).SUSP5R) as usize - ptr as usize
		           },
		           84usize,
		           concat!("Offset of field: ", stringify!(AES_TypeDef), "::", stringify!(SUSP5R))
		);
	}
	test_field_SUSP5R();
	fn test_field_SUSP6R() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<AES_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).SUSP6R) as usize - ptr as usize
		           },
		           88usize,
		           concat!("Offset of field: ", stringify!(AES_TypeDef), "::", stringify!(SUSP6R))
		);
	}
	test_field_SUSP6R();
	fn test_field_SUSP7R() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<AES_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).SUSP7R) as usize - ptr as usize
		           },
		           92usize,
		           concat!("Offset of field: ", stringify!(AES_TypeDef), "::", stringify!(SUSP7R))
		);
	}
	test_field_SUSP7R();
}
#[doc = " @brief RNG"]
#[repr(C)]
pub struct RNG_TypeDef {
	#[doc = "< RNG control register, Address offset: 0x00"]
	pub CR: u32,
	#[doc = "< RNG status register,  Address offset: 0x04"]
	pub SR: u32,
	#[doc = "< RNG data register,    Address offset: 0x08"]
	pub DR: u32,
}
#[test]
fn bindgen_test_layout_RNG_TypeDef() {
	assert_eq!(
	           ::core::mem::size_of::<RNG_TypeDef>(),
	           12usize,
	           concat!("Size of: ", stringify!(RNG_TypeDef))
	);
	assert_eq!(
	           ::core::mem::align_of::<RNG_TypeDef>(),
	           4usize,
	           concat!("Alignment of ", stringify!(RNG_TypeDef))
	);
	fn test_field_CR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<RNG_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).CR) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(RNG_TypeDef), "::", stringify!(CR))
		);
	}
	test_field_CR();
	fn test_field_SR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<RNG_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).SR) as usize - ptr as usize
		           },
		           4usize,
		           concat!("Offset of field: ", stringify!(RNG_TypeDef), "::", stringify!(SR))
		);
	}
	test_field_SR();
	fn test_field_DR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<RNG_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).DR) as usize - ptr as usize
		           },
		           8usize,
		           concat!("Offset of field: ", stringify!(RNG_TypeDef), "::", stringify!(DR))
		);
	}
	test_field_DR();
}
#[doc = " @brief Touch Sensing Controller (TSC)"]
#[repr(C)]
pub struct TSC_TypeDef {
	#[doc = "< TSC control register,                     Address offset: 0x00"]
	pub CR: u32,
	#[doc = "< TSC interrupt enable register,            Address offset: 0x04"]
	pub IER: u32,
	#[doc = "< TSC interrupt clear register,             Address offset: 0x08"]
	pub ICR: u32,
	#[doc = "< TSC interrupt status register,            Address offset: 0x0C"]
	pub ISR: u32,
	#[doc = "< TSC I/O hysteresis control register,      Address offset: 0x10"]
	pub IOHCR: u32,
	#[doc = "< Reserved,                                 Address offset: 0x14"]
	pub RESERVED1: u32,
	#[doc = "< TSC I/O analog switch control register,   Address offset: 0x18"]
	pub IOASCR: u32,
	#[doc = "< Reserved,                                 Address offset: 0x1C"]
	pub RESERVED2: u32,
	#[doc = "< TSC I/O sampling control register,        Address offset: 0x20"]
	pub IOSCR: u32,
	#[doc = "< Reserved,                                 Address offset: 0x24"]
	pub RESERVED3: u32,
	#[doc = "< TSC I/O channel control register,         Address offset: 0x28"]
	pub IOCCR: u32,
	#[doc = "< Reserved,                                 Address offset: 0x2C"]
	pub RESERVED4: u32,
	#[doc = "< TSC I/O group control status register,    Address offset: 0x30"]
	pub IOGCSR: u32,
	#[doc = "< TSC I/O group x counter register,         Address offset: 0x34-4C"]
	pub IOGXCR: [u32; 7usize],
}
#[test]
fn bindgen_test_layout_TSC_TypeDef() {
	assert_eq!(
	           ::core::mem::size_of::<TSC_TypeDef>(),
	           80usize,
	           concat!("Size of: ", stringify!(TSC_TypeDef))
	);
	assert_eq!(
	           ::core::mem::align_of::<TSC_TypeDef>(),
	           4usize,
	           concat!("Alignment of ", stringify!(TSC_TypeDef))
	);
	fn test_field_CR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<TSC_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).CR) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(TSC_TypeDef), "::", stringify!(CR))
		);
	}
	test_field_CR();
	fn test_field_IER() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<TSC_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).IER) as usize - ptr as usize
		           },
		           4usize,
		           concat!("Offset of field: ", stringify!(TSC_TypeDef), "::", stringify!(IER))
		);
	}
	test_field_IER();
	fn test_field_ICR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<TSC_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).ICR) as usize - ptr as usize
		           },
		           8usize,
		           concat!("Offset of field: ", stringify!(TSC_TypeDef), "::", stringify!(ICR))
		);
	}
	test_field_ICR();
	fn test_field_ISR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<TSC_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).ISR) as usize - ptr as usize
		           },
		           12usize,
		           concat!("Offset of field: ", stringify!(TSC_TypeDef), "::", stringify!(ISR))
		);
	}
	test_field_ISR();
	fn test_field_IOHCR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<TSC_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).IOHCR) as usize - ptr as usize
		           },
		           16usize,
		           concat!("Offset of field: ", stringify!(TSC_TypeDef), "::", stringify!(IOHCR))
		);
	}
	test_field_IOHCR();
	fn test_field_RESERVED1() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<TSC_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).RESERVED1) as usize - ptr as usize
		           },
		           20usize,
		           concat!("Offset of field: ", stringify!(TSC_TypeDef), "::", stringify!(RESERVED1))
		);
	}
	test_field_RESERVED1();
	fn test_field_IOASCR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<TSC_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).IOASCR) as usize - ptr as usize
		           },
		           24usize,
		           concat!("Offset of field: ", stringify!(TSC_TypeDef), "::", stringify!(IOASCR))
		);
	}
	test_field_IOASCR();
	fn test_field_RESERVED2() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<TSC_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).RESERVED2) as usize - ptr as usize
		           },
		           28usize,
		           concat!("Offset of field: ", stringify!(TSC_TypeDef), "::", stringify!(RESERVED2))
		);
	}
	test_field_RESERVED2();
	fn test_field_IOSCR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<TSC_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).IOSCR) as usize - ptr as usize
		           },
		           32usize,
		           concat!("Offset of field: ", stringify!(TSC_TypeDef), "::", stringify!(IOSCR))
		);
	}
	test_field_IOSCR();
	fn test_field_RESERVED3() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<TSC_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).RESERVED3) as usize - ptr as usize
		           },
		           36usize,
		           concat!("Offset of field: ", stringify!(TSC_TypeDef), "::", stringify!(RESERVED3))
		);
	}
	test_field_RESERVED3();
	fn test_field_IOCCR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<TSC_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).IOCCR) as usize - ptr as usize
		           },
		           40usize,
		           concat!("Offset of field: ", stringify!(TSC_TypeDef), "::", stringify!(IOCCR))
		);
	}
	test_field_IOCCR();
	fn test_field_RESERVED4() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<TSC_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).RESERVED4) as usize - ptr as usize
		           },
		           44usize,
		           concat!("Offset of field: ", stringify!(TSC_TypeDef), "::", stringify!(RESERVED4))
		);
	}
	test_field_RESERVED4();
	fn test_field_IOGCSR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<TSC_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).IOGCSR) as usize - ptr as usize
		           },
		           48usize,
		           concat!("Offset of field: ", stringify!(TSC_TypeDef), "::", stringify!(IOGCSR))
		);
	}
	test_field_IOGCSR();
	fn test_field_IOGXCR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<TSC_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).IOGXCR) as usize - ptr as usize
		           },
		           52usize,
		           concat!("Offset of field: ", stringify!(TSC_TypeDef), "::", stringify!(IOGXCR))
		);
	}
	test_field_IOGXCR();
}
#[doc = " @brief LCD"]
#[repr(C)]
pub struct LCD_TypeDef {
	#[doc = "< LCD control register,              Address offset: 0x00"]
	pub CR: u32,
	#[doc = "< LCD frame control register,        Address offset: 0x04"]
	pub FCR: u32,
	#[doc = "< LCD status register,               Address offset: 0x08"]
	pub SR: u32,
	#[doc = "< LCD clear register,                Address offset: 0x0C"]
	pub CLR: u32,
	#[doc = "< Reserved,                          Address offset: 0x10"]
	pub RESERVED: u32,
	#[doc = "< LCD display memory,           Address offset: 0x14-0x50"]
	pub RAM: [u32; 16usize],
}
#[test]
fn bindgen_test_layout_LCD_TypeDef() {
	assert_eq!(
	           ::core::mem::size_of::<LCD_TypeDef>(),
	           84usize,
	           concat!("Size of: ", stringify!(LCD_TypeDef))
	);
	assert_eq!(
	           ::core::mem::align_of::<LCD_TypeDef>(),
	           4usize,
	           concat!("Alignment of ", stringify!(LCD_TypeDef))
	);
	fn test_field_CR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LCD_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).CR) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(LCD_TypeDef), "::", stringify!(CR))
		);
	}
	test_field_CR();
	fn test_field_FCR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LCD_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).FCR) as usize - ptr as usize
		           },
		           4usize,
		           concat!("Offset of field: ", stringify!(LCD_TypeDef), "::", stringify!(FCR))
		);
	}
	test_field_FCR();
	fn test_field_SR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LCD_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).SR) as usize - ptr as usize
		           },
		           8usize,
		           concat!("Offset of field: ", stringify!(LCD_TypeDef), "::", stringify!(SR))
		);
	}
	test_field_SR();
	fn test_field_CLR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LCD_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).CLR) as usize - ptr as usize
		           },
		           12usize,
		           concat!("Offset of field: ", stringify!(LCD_TypeDef), "::", stringify!(CLR))
		);
	}
	test_field_CLR();
	fn test_field_RESERVED() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LCD_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).RESERVED) as usize - ptr as usize
		           },
		           16usize,
		           concat!("Offset of field: ", stringify!(LCD_TypeDef), "::", stringify!(RESERVED))
		);
	}
	test_field_RESERVED();
	fn test_field_RAM() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LCD_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).RAM) as usize - ptr as usize
		           },
		           20usize,
		           concat!("Offset of field: ", stringify!(LCD_TypeDef), "::", stringify!(RAM))
		);
	}
	test_field_RAM();
}
#[doc = " @brief Universal Serial Bus Full Speed Device"]
#[repr(C)]
pub struct USB_TypeDef {
	#[doc = "< USB Endpoint 0 register,                Address offset: 0x00"]
	pub EP0R: u16,
	#[doc = "< Reserved"]
	pub RESERVED0: u16,
	#[doc = "< USB Endpoint 1 register,                Address offset: 0x04"]
	pub EP1R: u16,
	#[doc = "< Reserved"]
	pub RESERVED1: u16,
	#[doc = "< USB Endpoint 2 register,                Address offset: 0x08"]
	pub EP2R: u16,
	#[doc = "< Reserved"]
	pub RESERVED2: u16,
	#[doc = "< USB Endpoint 3 register,                Address offset: 0x0C"]
	pub EP3R: u16,
	#[doc = "< Reserved"]
	pub RESERVED3: u16,
	#[doc = "< USB Endpoint 4 register,                Address offset: 0x10"]
	pub EP4R: u16,
	#[doc = "< Reserved"]
	pub RESERVED4: u16,
	#[doc = "< USB Endpoint 5 register,                Address offset: 0x14"]
	pub EP5R: u16,
	#[doc = "< Reserved"]
	pub RESERVED5: u16,
	#[doc = "< USB Endpoint 6 register,                Address offset: 0x18"]
	pub EP6R: u16,
	#[doc = "< Reserved"]
	pub RESERVED6: u16,
	#[doc = "< USB Endpoint 7 register,                Address offset: 0x1C"]
	pub EP7R: u16,
	#[doc = "< Reserved"]
	pub RESERVED7: [u16; 17usize],
	#[doc = "< Control register,                       Address offset: 0x40"]
	pub CNTR: u16,
	#[doc = "< Reserved"]
	pub RESERVED8: u16,
	#[doc = "< Interrupt status register,              Address offset: 0x44"]
	pub ISTR: u16,
	#[doc = "< Reserved"]
	pub RESERVED9: u16,
	#[doc = "< Frame number register,                  Address offset: 0x48"]
	pub FNR: u16,
	#[doc = "< Reserved"]
	pub RESERVEDA: u16,
	#[doc = "< Device address register,                Address offset: 0x4C"]
	pub DADDR: u16,
	#[doc = "< Reserved"]
	pub RESERVEDB: u16,
	#[doc = "< Buffer Table address register,          Address offset: 0x50"]
	pub BTABLE: u16,
	#[doc = "< Reserved"]
	pub RESERVEDC: u16,
	#[doc = "< LPM Control and Status register,        Address offset: 0x54"]
	pub LPMCSR: u16,
	#[doc = "< Reserved"]
	pub RESERVEDD: u16,
	#[doc = "< Battery Charging detector register,     Address offset: 0x58"]
	pub BCDR: u16,
	#[doc = "< Reserved"]
	pub RESERVEDE: u16,
}
#[test]
fn bindgen_test_layout_USB_TypeDef() {
	assert_eq!(
	           ::core::mem::size_of::<USB_TypeDef>(),
	           92usize,
	           concat!("Size of: ", stringify!(USB_TypeDef))
	);
	assert_eq!(
	           ::core::mem::align_of::<USB_TypeDef>(),
	           2usize,
	           concat!("Alignment of ", stringify!(USB_TypeDef))
	);
	fn test_field_EP0R() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<USB_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).EP0R) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(USB_TypeDef), "::", stringify!(EP0R))
		);
	}
	test_field_EP0R();
	fn test_field_RESERVED0() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<USB_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).RESERVED0) as usize - ptr as usize
		           },
		           2usize,
		           concat!("Offset of field: ", stringify!(USB_TypeDef), "::", stringify!(RESERVED0))
		);
	}
	test_field_RESERVED0();
	fn test_field_EP1R() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<USB_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).EP1R) as usize - ptr as usize
		           },
		           4usize,
		           concat!("Offset of field: ", stringify!(USB_TypeDef), "::", stringify!(EP1R))
		);
	}
	test_field_EP1R();
	fn test_field_RESERVED1() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<USB_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).RESERVED1) as usize - ptr as usize
		           },
		           6usize,
		           concat!("Offset of field: ", stringify!(USB_TypeDef), "::", stringify!(RESERVED1))
		);
	}
	test_field_RESERVED1();
	fn test_field_EP2R() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<USB_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).EP2R) as usize - ptr as usize
		           },
		           8usize,
		           concat!("Offset of field: ", stringify!(USB_TypeDef), "::", stringify!(EP2R))
		);
	}
	test_field_EP2R();
	fn test_field_RESERVED2() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<USB_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).RESERVED2) as usize - ptr as usize
		           },
		           10usize,
		           concat!("Offset of field: ", stringify!(USB_TypeDef), "::", stringify!(RESERVED2))
		);
	}
	test_field_RESERVED2();
	fn test_field_EP3R() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<USB_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).EP3R) as usize - ptr as usize
		           },
		           12usize,
		           concat!("Offset of field: ", stringify!(USB_TypeDef), "::", stringify!(EP3R))
		);
	}
	test_field_EP3R();
	fn test_field_RESERVED3() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<USB_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).RESERVED3) as usize - ptr as usize
		           },
		           14usize,
		           concat!("Offset of field: ", stringify!(USB_TypeDef), "::", stringify!(RESERVED3))
		);
	}
	test_field_RESERVED3();
	fn test_field_EP4R() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<USB_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).EP4R) as usize - ptr as usize
		           },
		           16usize,
		           concat!("Offset of field: ", stringify!(USB_TypeDef), "::", stringify!(EP4R))
		);
	}
	test_field_EP4R();
	fn test_field_RESERVED4() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<USB_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).RESERVED4) as usize - ptr as usize
		           },
		           18usize,
		           concat!("Offset of field: ", stringify!(USB_TypeDef), "::", stringify!(RESERVED4))
		);
	}
	test_field_RESERVED4();
	fn test_field_EP5R() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<USB_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).EP5R) as usize - ptr as usize
		           },
		           20usize,
		           concat!("Offset of field: ", stringify!(USB_TypeDef), "::", stringify!(EP5R))
		);
	}
	test_field_EP5R();
	fn test_field_RESERVED5() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<USB_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).RESERVED5) as usize - ptr as usize
		           },
		           22usize,
		           concat!("Offset of field: ", stringify!(USB_TypeDef), "::", stringify!(RESERVED5))
		);
	}
	test_field_RESERVED5();
	fn test_field_EP6R() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<USB_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).EP6R) as usize - ptr as usize
		           },
		           24usize,
		           concat!("Offset of field: ", stringify!(USB_TypeDef), "::", stringify!(EP6R))
		);
	}
	test_field_EP6R();
	fn test_field_RESERVED6() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<USB_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).RESERVED6) as usize - ptr as usize
		           },
		           26usize,
		           concat!("Offset of field: ", stringify!(USB_TypeDef), "::", stringify!(RESERVED6))
		);
	}
	test_field_RESERVED6();
	fn test_field_EP7R() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<USB_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).EP7R) as usize - ptr as usize
		           },
		           28usize,
		           concat!("Offset of field: ", stringify!(USB_TypeDef), "::", stringify!(EP7R))
		);
	}
	test_field_EP7R();
	fn test_field_RESERVED7() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<USB_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).RESERVED7) as usize - ptr as usize
		           },
		           30usize,
		           concat!("Offset of field: ", stringify!(USB_TypeDef), "::", stringify!(RESERVED7))
		);
	}
	test_field_RESERVED7();
	fn test_field_CNTR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<USB_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).CNTR) as usize - ptr as usize
		           },
		           64usize,
		           concat!("Offset of field: ", stringify!(USB_TypeDef), "::", stringify!(CNTR))
		);
	}
	test_field_CNTR();
	fn test_field_RESERVED8() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<USB_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).RESERVED8) as usize - ptr as usize
		           },
		           66usize,
		           concat!("Offset of field: ", stringify!(USB_TypeDef), "::", stringify!(RESERVED8))
		);
	}
	test_field_RESERVED8();
	fn test_field_ISTR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<USB_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).ISTR) as usize - ptr as usize
		           },
		           68usize,
		           concat!("Offset of field: ", stringify!(USB_TypeDef), "::", stringify!(ISTR))
		);
	}
	test_field_ISTR();
	fn test_field_RESERVED9() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<USB_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).RESERVED9) as usize - ptr as usize
		           },
		           70usize,
		           concat!("Offset of field: ", stringify!(USB_TypeDef), "::", stringify!(RESERVED9))
		);
	}
	test_field_RESERVED9();
	fn test_field_FNR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<USB_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).FNR) as usize - ptr as usize
		           },
		           72usize,
		           concat!("Offset of field: ", stringify!(USB_TypeDef), "::", stringify!(FNR))
		);
	}
	test_field_FNR();
	fn test_field_RESERVEDA() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<USB_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).RESERVEDA) as usize - ptr as usize
		           },
		           74usize,
		           concat!("Offset of field: ", stringify!(USB_TypeDef), "::", stringify!(RESERVEDA))
		);
	}
	test_field_RESERVEDA();
	fn test_field_DADDR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<USB_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).DADDR) as usize - ptr as usize
		           },
		           76usize,
		           concat!("Offset of field: ", stringify!(USB_TypeDef), "::", stringify!(DADDR))
		);
	}
	test_field_DADDR();
	fn test_field_RESERVEDB() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<USB_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).RESERVEDB) as usize - ptr as usize
		           },
		           78usize,
		           concat!("Offset of field: ", stringify!(USB_TypeDef), "::", stringify!(RESERVEDB))
		);
	}
	test_field_RESERVEDB();
	fn test_field_BTABLE() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<USB_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).BTABLE) as usize - ptr as usize
		           },
		           80usize,
		           concat!("Offset of field: ", stringify!(USB_TypeDef), "::", stringify!(BTABLE))
		);
	}
	test_field_BTABLE();
	fn test_field_RESERVEDC() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<USB_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).RESERVEDC) as usize - ptr as usize
		           },
		           82usize,
		           concat!("Offset of field: ", stringify!(USB_TypeDef), "::", stringify!(RESERVEDC))
		);
	}
	test_field_RESERVEDC();
	fn test_field_LPMCSR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<USB_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).LPMCSR) as usize - ptr as usize
		           },
		           84usize,
		           concat!("Offset of field: ", stringify!(USB_TypeDef), "::", stringify!(LPMCSR))
		);
	}
	test_field_LPMCSR();
	fn test_field_RESERVEDD() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<USB_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).RESERVEDD) as usize - ptr as usize
		           },
		           86usize,
		           concat!("Offset of field: ", stringify!(USB_TypeDef), "::", stringify!(RESERVEDD))
		);
	}
	test_field_RESERVEDD();
	fn test_field_BCDR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<USB_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).BCDR) as usize - ptr as usize
		           },
		           88usize,
		           concat!("Offset of field: ", stringify!(USB_TypeDef), "::", stringify!(BCDR))
		);
	}
	test_field_BCDR();
	fn test_field_RESERVEDE() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<USB_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).RESERVEDE) as usize - ptr as usize
		           },
		           90usize,
		           concat!("Offset of field: ", stringify!(USB_TypeDef), "::", stringify!(RESERVEDE))
		);
	}
	test_field_RESERVEDE();
}
#[doc = " @brief Clock Recovery System"]
#[repr(C)]
pub struct CRS_TypeDef {
	#[doc = "< CRS control register,               Address offset: 0x00"]
	pub CR: u32,
	#[doc = "< CRS configuration register,         Address offset: 0x04"]
	pub CFGR: u32,
	#[doc = "< CRS interrupt and status register,  Address offset: 0x08"]
	pub ISR: u32,
	#[doc = "< CRS interrupt flag clear register,  Address offset: 0x0C"]
	pub ICR: u32,
}
#[test]
fn bindgen_test_layout_CRS_TypeDef() {
	assert_eq!(
	           ::core::mem::size_of::<CRS_TypeDef>(),
	           16usize,
	           concat!("Size of: ", stringify!(CRS_TypeDef))
	);
	assert_eq!(
	           ::core::mem::align_of::<CRS_TypeDef>(),
	           4usize,
	           concat!("Alignment of ", stringify!(CRS_TypeDef))
	);
	fn test_field_CR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<CRS_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).CR) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(CRS_TypeDef), "::", stringify!(CR))
		);
	}
	test_field_CR();
	fn test_field_CFGR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<CRS_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).CFGR) as usize - ptr as usize
		           },
		           4usize,
		           concat!("Offset of field: ", stringify!(CRS_TypeDef), "::", stringify!(CFGR))
		);
	}
	test_field_CFGR();
	fn test_field_ISR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<CRS_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).ISR) as usize - ptr as usize
		           },
		           8usize,
		           concat!("Offset of field: ", stringify!(CRS_TypeDef), "::", stringify!(ISR))
		);
	}
	test_field_ISR();
	fn test_field_ICR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<CRS_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).ICR) as usize - ptr as usize
		           },
		           12usize,
		           concat!("Offset of field: ", stringify!(CRS_TypeDef), "::", stringify!(ICR))
		);
	}
	test_field_ICR();
}
#[doc = " @brief Inter-Processor Communication"]
#[repr(C)]
pub struct IPCC_TypeDef {
	#[doc = "< Inter-Processor Communication: C1 control register,                  Address offset: 0x000"]
	pub C1CR: u32,
	#[doc = "< Inter-Processor Communication: C1 mask register,                     Address offset: 0x004"]
	pub C1MR: u32,
	#[doc = "< Inter-Processor Communication: C1 status set clear register,         Address offset: 0x008"]
	pub C1SCR: u32,
	#[doc = "< Inter-Processor Communication: C1 to processor M4  status register,  Address offset: 0x00C"]
	pub C1TOC2SR: u32,
	#[doc = "< Inter-Processor Communication: C2 control register,                  Address offset: 0x010"]
	pub C2CR: u32,
	#[doc = "< Inter-Processor Communication: C2 mask register,                     Address offset: 0x014"]
	pub C2MR: u32,
	#[doc = "< Inter-Processor Communication: C2 status set clear register,         Address offset: 0x018"]
	pub C2SCR: u32,
	#[doc = "< Inter-Processor Communication: C2 to processor M4 status register,   Address offset: 0x01C"]
	pub C2TOC1SR: u32,
}
#[test]
fn bindgen_test_layout_IPCC_TypeDef() {
	assert_eq!(
	           ::core::mem::size_of::<IPCC_TypeDef>(),
	           32usize,
	           concat!("Size of: ", stringify!(IPCC_TypeDef))
	);
	assert_eq!(
	           ::core::mem::align_of::<IPCC_TypeDef>(),
	           4usize,
	           concat!("Alignment of ", stringify!(IPCC_TypeDef))
	);
	fn test_field_C1CR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<IPCC_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).C1CR) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(IPCC_TypeDef), "::", stringify!(C1CR))
		);
	}
	test_field_C1CR();
	fn test_field_C1MR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<IPCC_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).C1MR) as usize - ptr as usize
		           },
		           4usize,
		           concat!("Offset of field: ", stringify!(IPCC_TypeDef), "::", stringify!(C1MR))
		);
	}
	test_field_C1MR();
	fn test_field_C1SCR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<IPCC_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).C1SCR) as usize - ptr as usize
		           },
		           8usize,
		           concat!("Offset of field: ", stringify!(IPCC_TypeDef), "::", stringify!(C1SCR))
		);
	}
	test_field_C1SCR();
	fn test_field_C1TOC2SR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<IPCC_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).C1TOC2SR) as usize - ptr as usize
		           },
		           12usize,
		           concat!("Offset of field: ", stringify!(IPCC_TypeDef), "::", stringify!(C1TOC2SR))
		);
	}
	test_field_C1TOC2SR();
	fn test_field_C2CR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<IPCC_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).C2CR) as usize - ptr as usize
		           },
		           16usize,
		           concat!("Offset of field: ", stringify!(IPCC_TypeDef), "::", stringify!(C2CR))
		);
	}
	test_field_C2CR();
	fn test_field_C2MR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<IPCC_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).C2MR) as usize - ptr as usize
		           },
		           20usize,
		           concat!("Offset of field: ", stringify!(IPCC_TypeDef), "::", stringify!(C2MR))
		);
	}
	test_field_C2MR();
	fn test_field_C2SCR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<IPCC_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).C2SCR) as usize - ptr as usize
		           },
		           24usize,
		           concat!("Offset of field: ", stringify!(IPCC_TypeDef), "::", stringify!(C2SCR))
		);
	}
	test_field_C2SCR();
	fn test_field_C2TOC1SR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<IPCC_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).C2TOC1SR) as usize - ptr as usize
		           },
		           28usize,
		           concat!("Offset of field: ", stringify!(IPCC_TypeDef), "::", stringify!(C2TOC1SR))
		);
	}
	test_field_C2TOC1SR();
}
#[repr(C)]
pub struct IPCC_CommonTypeDef {
	#[doc = "< Control register,                                                    Address offset: 0x000"]
	pub CR: u32,
	#[doc = "< Mask register,                                                       Address offset: 0x004"]
	pub MR: u32,
	#[doc = "< Status set clear register,                                           Address offset: 0x008"]
	pub SCR: u32,
	#[doc = "< Status register,                                                     Address offset: 0x00C"]
	pub SR: u32,
}
#[test]
fn bindgen_test_layout_IPCC_CommonTypeDef() {
	assert_eq!(
	           ::core::mem::size_of::<IPCC_CommonTypeDef>(),
	           16usize,
	           concat!("Size of: ", stringify!(IPCC_CommonTypeDef))
	);
	assert_eq!(
	           ::core::mem::align_of::<IPCC_CommonTypeDef>(),
	           4usize,
	           concat!("Alignment of ", stringify!(IPCC_CommonTypeDef))
	);
	fn test_field_CR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<IPCC_CommonTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).CR) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(IPCC_CommonTypeDef), "::", stringify!(CR))
		);
	}
	test_field_CR();
	fn test_field_MR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<IPCC_CommonTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).MR) as usize - ptr as usize
		           },
		           4usize,
		           concat!("Offset of field: ", stringify!(IPCC_CommonTypeDef), "::", stringify!(MR))
		);
	}
	test_field_MR();
	fn test_field_SCR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<IPCC_CommonTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).SCR) as usize - ptr as usize
		           },
		           8usize,
		           concat!("Offset of field: ", stringify!(IPCC_CommonTypeDef), "::", stringify!(SCR))
		);
	}
	test_field_SCR();
	fn test_field_SR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<IPCC_CommonTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).SR) as usize - ptr as usize
		           },
		           12usize,
		           concat!("Offset of field: ", stringify!(IPCC_CommonTypeDef), "::", stringify!(SR))
		);
	}
	test_field_SR();
}
#[doc = " @brief Async Interrupts and Events Controller"]
#[repr(C)]
pub struct EXTI_TypeDef {
	#[doc = "< EXTI rising trigger selection register [31:0],            Address offset: 0x00"]
	pub RTSR1: u32,
	#[doc = "< EXTI falling trigger selection register [31:0],           Address offset: 0x04"]
	pub FTSR1: u32,
	#[doc = "< EXTI software interrupt event register [31:0],            Address offset: 0x08"]
	pub SWIER1: u32,
	#[doc = "< EXTI pending register [31:0],                             Address offset: 0x0C"]
	pub PR1: u32,
	#[doc = "< Reserved,                                                 Address offset: 0x10 - 0x1C"]
	pub RESERVED1: [u32; 4usize],
	#[doc = "< EXTI rising trigger selection register [31:0],            Address offset: 0x20"]
	pub RTSR2: u32,
	#[doc = "< EXTI falling trigger selection register [31:0],           Address offset: 0x24"]
	pub FTSR2: u32,
	#[doc = "< EXTI software interrupt event register [31:0],            Address offset: 0x28"]
	pub SWIER2: u32,
	#[doc = "< EXTI pending register [31:0],                             Address offset: 0x2C"]
	pub PR2: u32,
	#[doc = "< Reserved,                                                 Address offset: 0x30 - 0x3C"]
	pub RESERVED2: [u32; 4usize],
	#[doc = "< Reserved,                                                 Address offset: 0x40 - 0x5C"]
	pub RESERVED3: [u32; 8usize],
	#[doc = "< Reserved,                                                 Address offset: 0x60 - 0x7C"]
	pub RESERVED4: [u32; 8usize],
	#[doc = "< EXTI wakeup with interrupt mask register for cpu1 [31:0], Address offset: 0x80"]
	pub IMR1: u32,
	#[doc = "< EXTI wakeup with event mask register for cpu1 [31:0],     Address offset: 0x84"]
	pub EMR1: u32,
	#[doc = "< Reserved,                                                 Address offset: 0x88 - 0x8C"]
	pub RESERVED5: [u32; 2usize],
	#[doc = "< EXTI wakeup with interrupt mask register for cpu1 [31:0], Address offset: 0x90"]
	pub IMR2: u32,
	#[doc = "< EXTI wakeup with event mask register for cpu1 [31:0],     Address offset: 0x94"]
	pub EMR2: u32,
	#[doc = "< Reserved,                                                 Address offset: 0x98 - 0xBC"]
	pub RESERVED8: [u32; 10usize],
	#[doc = "< EXTI wakeup with interrupt mask register for cpu2 [31:0], Address offset: 0xC0"]
	pub C2IMR1: u32,
	#[doc = "< EXTI wakeup with event mask register for cpu2 [31:0],     Address offset: 0xC4"]
	pub C2EMR1: u32,
	#[doc = "< Reserved,                                                 Address offset: 0xC8 - 0xCC"]
	pub RESERVED9: [u32; 2usize],
	#[doc = "< EXTI wakeup with interrupt mask register for cpu2 [31:0], Address offset: 0xD0"]
	pub C2IMR2: u32,
	#[doc = "< EXTI wakeup with event mask register for cpu2 [31:0],     Address offset: 0xD4"]
	pub C2EMR2: u32,
}
#[test]
fn bindgen_test_layout_EXTI_TypeDef() {
	assert_eq!(
	           ::core::mem::size_of::<EXTI_TypeDef>(),
	           216usize,
	           concat!("Size of: ", stringify!(EXTI_TypeDef))
	);
	assert_eq!(
	           ::core::mem::align_of::<EXTI_TypeDef>(),
	           4usize,
	           concat!("Alignment of ", stringify!(EXTI_TypeDef))
	);
	fn test_field_RTSR1() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<EXTI_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).RTSR1) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(EXTI_TypeDef), "::", stringify!(RTSR1))
		);
	}
	test_field_RTSR1();
	fn test_field_FTSR1() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<EXTI_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).FTSR1) as usize - ptr as usize
		           },
		           4usize,
		           concat!("Offset of field: ", stringify!(EXTI_TypeDef), "::", stringify!(FTSR1))
		);
	}
	test_field_FTSR1();
	fn test_field_SWIER1() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<EXTI_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).SWIER1) as usize - ptr as usize
		           },
		           8usize,
		           concat!("Offset of field: ", stringify!(EXTI_TypeDef), "::", stringify!(SWIER1))
		);
	}
	test_field_SWIER1();
	fn test_field_PR1() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<EXTI_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).PR1) as usize - ptr as usize
		           },
		           12usize,
		           concat!("Offset of field: ", stringify!(EXTI_TypeDef), "::", stringify!(PR1))
		);
	}
	test_field_PR1();
	fn test_field_RESERVED1() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<EXTI_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).RESERVED1) as usize - ptr as usize
		           },
		           16usize,
		           concat!("Offset of field: ", stringify!(EXTI_TypeDef), "::", stringify!(RESERVED1))
		);
	}
	test_field_RESERVED1();
	fn test_field_RTSR2() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<EXTI_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).RTSR2) as usize - ptr as usize
		           },
		           32usize,
		           concat!("Offset of field: ", stringify!(EXTI_TypeDef), "::", stringify!(RTSR2))
		);
	}
	test_field_RTSR2();
	fn test_field_FTSR2() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<EXTI_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).FTSR2) as usize - ptr as usize
		           },
		           36usize,
		           concat!("Offset of field: ", stringify!(EXTI_TypeDef), "::", stringify!(FTSR2))
		);
	}
	test_field_FTSR2();
	fn test_field_SWIER2() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<EXTI_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).SWIER2) as usize - ptr as usize
		           },
		           40usize,
		           concat!("Offset of field: ", stringify!(EXTI_TypeDef), "::", stringify!(SWIER2))
		);
	}
	test_field_SWIER2();
	fn test_field_PR2() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<EXTI_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).PR2) as usize - ptr as usize
		           },
		           44usize,
		           concat!("Offset of field: ", stringify!(EXTI_TypeDef), "::", stringify!(PR2))
		);
	}
	test_field_PR2();
	fn test_field_RESERVED2() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<EXTI_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).RESERVED2) as usize - ptr as usize
		           },
		           48usize,
		           concat!("Offset of field: ", stringify!(EXTI_TypeDef), "::", stringify!(RESERVED2))
		);
	}
	test_field_RESERVED2();
	fn test_field_RESERVED3() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<EXTI_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).RESERVED3) as usize - ptr as usize
		           },
		           64usize,
		           concat!("Offset of field: ", stringify!(EXTI_TypeDef), "::", stringify!(RESERVED3))
		);
	}
	test_field_RESERVED3();
	fn test_field_RESERVED4() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<EXTI_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).RESERVED4) as usize - ptr as usize
		           },
		           96usize,
		           concat!("Offset of field: ", stringify!(EXTI_TypeDef), "::", stringify!(RESERVED4))
		);
	}
	test_field_RESERVED4();
	fn test_field_IMR1() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<EXTI_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).IMR1) as usize - ptr as usize
		           },
		           128usize,
		           concat!("Offset of field: ", stringify!(EXTI_TypeDef), "::", stringify!(IMR1))
		);
	}
	test_field_IMR1();
	fn test_field_EMR1() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<EXTI_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).EMR1) as usize - ptr as usize
		           },
		           132usize,
		           concat!("Offset of field: ", stringify!(EXTI_TypeDef), "::", stringify!(EMR1))
		);
	}
	test_field_EMR1();
	fn test_field_RESERVED5() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<EXTI_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).RESERVED5) as usize - ptr as usize
		           },
		           136usize,
		           concat!("Offset of field: ", stringify!(EXTI_TypeDef), "::", stringify!(RESERVED5))
		);
	}
	test_field_RESERVED5();
	fn test_field_IMR2() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<EXTI_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).IMR2) as usize - ptr as usize
		           },
		           144usize,
		           concat!("Offset of field: ", stringify!(EXTI_TypeDef), "::", stringify!(IMR2))
		);
	}
	test_field_IMR2();
	fn test_field_EMR2() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<EXTI_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).EMR2) as usize - ptr as usize
		           },
		           148usize,
		           concat!("Offset of field: ", stringify!(EXTI_TypeDef), "::", stringify!(EMR2))
		);
	}
	test_field_EMR2();
	fn test_field_RESERVED8() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<EXTI_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).RESERVED8) as usize - ptr as usize
		           },
		           152usize,
		           concat!("Offset of field: ", stringify!(EXTI_TypeDef), "::", stringify!(RESERVED8))
		);
	}
	test_field_RESERVED8();
	fn test_field_C2IMR1() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<EXTI_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).C2IMR1) as usize - ptr as usize
		           },
		           192usize,
		           concat!("Offset of field: ", stringify!(EXTI_TypeDef), "::", stringify!(C2IMR1))
		);
	}
	test_field_C2IMR1();
	fn test_field_C2EMR1() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<EXTI_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).C2EMR1) as usize - ptr as usize
		           },
		           196usize,
		           concat!("Offset of field: ", stringify!(EXTI_TypeDef), "::", stringify!(C2EMR1))
		);
	}
	test_field_C2EMR1();
	fn test_field_RESERVED9() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<EXTI_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).RESERVED9) as usize - ptr as usize
		           },
		           200usize,
		           concat!("Offset of field: ", stringify!(EXTI_TypeDef), "::", stringify!(RESERVED9))
		);
	}
	test_field_RESERVED9();
	fn test_field_C2IMR2() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<EXTI_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).C2IMR2) as usize - ptr as usize
		           },
		           208usize,
		           concat!("Offset of field: ", stringify!(EXTI_TypeDef), "::", stringify!(C2IMR2))
		);
	}
	test_field_C2IMR2();
	fn test_field_C2EMR2() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<EXTI_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).C2EMR2) as usize - ptr as usize
		           },
		           212usize,
		           concat!("Offset of field: ", stringify!(EXTI_TypeDef), "::", stringify!(C2EMR2))
		);
	}
	test_field_C2EMR2();
}
#[doc = " @brief Serial Audio Interface"]
#[repr(C)]
pub struct SAI_TypeDef {
	#[doc = "< SAI global configuration register,        Address offset: 0x00"]
	pub GCR: u32,
	#[doc = "< Reserved,                         Address offset: 0x04 to 0x40"]
	pub RESERVED: [u32; 16usize],
	#[doc = "< SAI PDM control register,                 Address offset: 0x44"]
	pub PDMCR: u32,
	#[doc = "< SAI PDM delay register,                   Address offset: 0x48"]
	pub PDMDLY: u32,
}
#[test]
fn bindgen_test_layout_SAI_TypeDef() {
	assert_eq!(
	           ::core::mem::size_of::<SAI_TypeDef>(),
	           76usize,
	           concat!("Size of: ", stringify!(SAI_TypeDef))
	);
	assert_eq!(
	           ::core::mem::align_of::<SAI_TypeDef>(),
	           4usize,
	           concat!("Alignment of ", stringify!(SAI_TypeDef))
	);
	fn test_field_GCR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<SAI_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).GCR) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(SAI_TypeDef), "::", stringify!(GCR))
		);
	}
	test_field_GCR();
	fn test_field_RESERVED() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<SAI_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).RESERVED) as usize - ptr as usize
		           },
		           4usize,
		           concat!("Offset of field: ", stringify!(SAI_TypeDef), "::", stringify!(RESERVED))
		);
	}
	test_field_RESERVED();
	fn test_field_PDMCR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<SAI_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).PDMCR) as usize - ptr as usize
		           },
		           68usize,
		           concat!("Offset of field: ", stringify!(SAI_TypeDef), "::", stringify!(PDMCR))
		);
	}
	test_field_PDMCR();
	fn test_field_PDMDLY() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<SAI_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).PDMDLY) as usize - ptr as usize
		           },
		           72usize,
		           concat!("Offset of field: ", stringify!(SAI_TypeDef), "::", stringify!(PDMDLY))
		);
	}
	test_field_PDMDLY();
}
#[repr(C)]
pub struct SAI_Block_TypeDef {
	#[doc = "< SAI block x configuration register 1,     Address offset: 0x04"]
	pub CR1: u32,
	#[doc = "< SAI block x configuration register 2,     Address offset: 0x08"]
	pub CR2: u32,
	#[doc = "< SAI block x frame configuration register, Address offset: 0x0C"]
	pub FRCR: u32,
	#[doc = "< SAI block x slot register,                Address offset: 0x10"]
	pub SLOTR: u32,
	#[doc = "< SAI block x interrupt mask register,      Address offset: 0x14"]
	pub IMR: u32,
	#[doc = "< SAI block x status register,              Address offset: 0x18"]
	pub SR: u32,
	#[doc = "< SAI block x clear flag register,          Address offset: 0x1C"]
	pub CLRFR: u32,
	#[doc = "< SAI block x data register,                Address offset: 0x20"]
	pub DR: u32,
}
#[test]
fn bindgen_test_layout_SAI_Block_TypeDef() {
	assert_eq!(
	           ::core::mem::size_of::<SAI_Block_TypeDef>(),
	           32usize,
	           concat!("Size of: ", stringify!(SAI_Block_TypeDef))
	);
	assert_eq!(
	           ::core::mem::align_of::<SAI_Block_TypeDef>(),
	           4usize,
	           concat!("Alignment of ", stringify!(SAI_Block_TypeDef))
	);
	fn test_field_CR1() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<SAI_Block_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).CR1) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(SAI_Block_TypeDef), "::", stringify!(CR1))
		);
	}
	test_field_CR1();
	fn test_field_CR2() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<SAI_Block_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).CR2) as usize - ptr as usize
		           },
		           4usize,
		           concat!("Offset of field: ", stringify!(SAI_Block_TypeDef), "::", stringify!(CR2))
		);
	}
	test_field_CR2();
	fn test_field_FRCR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<SAI_Block_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).FRCR) as usize - ptr as usize
		           },
		           8usize,
		           concat!("Offset of field: ", stringify!(SAI_Block_TypeDef), "::", stringify!(FRCR))
		);
	}
	test_field_FRCR();
	fn test_field_SLOTR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<SAI_Block_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).SLOTR) as usize - ptr as usize
		           },
		           12usize,
		           concat!("Offset of field: ", stringify!(SAI_Block_TypeDef), "::", stringify!(SLOTR))
		);
	}
	test_field_SLOTR();
	fn test_field_IMR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<SAI_Block_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).IMR) as usize - ptr as usize
		           },
		           16usize,
		           concat!("Offset of field: ", stringify!(SAI_Block_TypeDef), "::", stringify!(IMR))
		);
	}
	test_field_IMR();
	fn test_field_SR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<SAI_Block_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).SR) as usize - ptr as usize
		           },
		           20usize,
		           concat!("Offset of field: ", stringify!(SAI_Block_TypeDef), "::", stringify!(SR))
		);
	}
	test_field_SR();
	fn test_field_CLRFR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<SAI_Block_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).CLRFR) as usize - ptr as usize
		           },
		           24usize,
		           concat!("Offset of field: ", stringify!(SAI_Block_TypeDef), "::", stringify!(CLRFR))
		);
	}
	test_field_CLRFR();
	fn test_field_DR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<SAI_Block_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).DR) as usize - ptr as usize
		           },
		           28usize,
		           concat!("Offset of field: ", stringify!(SAI_Block_TypeDef), "::", stringify!(DR))
		);
	}
	test_field_DR();
}
#[doc = " @brief Public Key Accelerator (PKA)"]
#[repr(C)]
pub struct PKA_TypeDef {
	#[doc = "< PKA control register,                 Address offset: 0x00"]
	pub CR: u32,
	#[doc = "< PKA status register,                  Address offset: 0x04"]
	pub SR: u32,
	#[doc = "< PKA clear flag register,              Address offset: 0x08"]
	pub CLRFR: u32,
	#[doc = "< Reserved                              Address offset: 0x000C-0x03FC"]
	pub Reserved1: [u32; 253usize],
	#[doc = "< PKA RAM,                              Address offset: 0x0400-0x11F4"]
	pub RAM: [u32; 894usize],
}
#[test]
fn bindgen_test_layout_PKA_TypeDef() {
	assert_eq!(
	           ::core::mem::size_of::<PKA_TypeDef>(),
	           4600usize,
	           concat!("Size of: ", stringify!(PKA_TypeDef))
	);
	assert_eq!(
	           ::core::mem::align_of::<PKA_TypeDef>(),
	           4usize,
	           concat!("Alignment of ", stringify!(PKA_TypeDef))
	);
	fn test_field_CR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<PKA_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).CR) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(PKA_TypeDef), "::", stringify!(CR))
		);
	}
	test_field_CR();
	fn test_field_SR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<PKA_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).SR) as usize - ptr as usize
		           },
		           4usize,
		           concat!("Offset of field: ", stringify!(PKA_TypeDef), "::", stringify!(SR))
		);
	}
	test_field_SR();
	fn test_field_CLRFR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<PKA_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).CLRFR) as usize - ptr as usize
		           },
		           8usize,
		           concat!("Offset of field: ", stringify!(PKA_TypeDef), "::", stringify!(CLRFR))
		);
	}
	test_field_CLRFR();
	fn test_field_Reserved1() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<PKA_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).Reserved1) as usize - ptr as usize
		           },
		           12usize,
		           concat!("Offset of field: ", stringify!(PKA_TypeDef), "::", stringify!(Reserved1))
		);
	}
	test_field_Reserved1();
	fn test_field_RAM() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<PKA_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).RAM) as usize - ptr as usize
		           },
		           1024usize,
		           concat!("Offset of field: ", stringify!(PKA_TypeDef), "::", stringify!(RAM))
		);
	}
	test_field_RAM();
}
#[doc = " @brief HW Semaphore HSEM"]
#[repr(C)]
pub struct HSEM_TypeDef {
	#[doc = "< HSEM 2-step write lock and read back registers, Address offset: 00h-7Ch"]
	pub R: [u32; 32usize],
	#[doc = "< HSEM 1-step read lock registers,                Address offset: 80h-FCh"]
	pub RLR: [u32; 32usize],
	#[doc = "< HSEM CPU1 interrupt enable register ,           Address offset: 100h"]
	pub C1IER: u32,
	#[doc = "< HSEM CPU1 interrupt clear register ,            Address offset: 104h"]
	pub C1ICR: u32,
	#[doc = "< HSEM CPU1 interrupt status register ,           Address offset: 108h"]
	pub C1ISR: u32,
	#[doc = "< HSEM CPU1 masked interrupt status register ,    Address offset: 10Ch"]
	pub C1MISR: u32,
	#[doc = "< HSEM CPU2 interrupt enable register ,           Address offset: 110h"]
	pub C2IER: u32,
	#[doc = "< HSEM CPU2 interrupt clear register ,            Address offset: 114h"]
	pub C2ICR: u32,
	#[doc = "< HSEM CPU2 interrupt status register ,           Address offset: 118h"]
	pub C2ISR: u32,
	#[doc = "< HSEM CPU2 masked interrupt status register ,    Address offset: 11Ch"]
	pub C2MISR: u32,
	#[doc = "< Reserved                                        Address offset: 120h-13Ch"]
	pub Reserved: [u32; 8usize],
	#[doc = "< HSEM Semaphore clear register ,                 Address offset: 140h"]
	pub CR: u32,
	#[doc = "< HSEM Semaphore clear key register ,             Address offset: 144h"]
	pub KEYR: u32,
}
#[test]
fn bindgen_test_layout_HSEM_TypeDef() {
	assert_eq!(
	           ::core::mem::size_of::<HSEM_TypeDef>(),
	           328usize,
	           concat!("Size of: ", stringify!(HSEM_TypeDef))
	);
	assert_eq!(
	           ::core::mem::align_of::<HSEM_TypeDef>(),
	           4usize,
	           concat!("Alignment of ", stringify!(HSEM_TypeDef))
	);
	fn test_field_R() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<HSEM_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).R) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(HSEM_TypeDef), "::", stringify!(R))
		);
	}
	test_field_R();
	fn test_field_RLR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<HSEM_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).RLR) as usize - ptr as usize
		           },
		           128usize,
		           concat!("Offset of field: ", stringify!(HSEM_TypeDef), "::", stringify!(RLR))
		);
	}
	test_field_RLR();
	fn test_field_C1IER() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<HSEM_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).C1IER) as usize - ptr as usize
		           },
		           256usize,
		           concat!("Offset of field: ", stringify!(HSEM_TypeDef), "::", stringify!(C1IER))
		);
	}
	test_field_C1IER();
	fn test_field_C1ICR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<HSEM_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).C1ICR) as usize - ptr as usize
		           },
		           260usize,
		           concat!("Offset of field: ", stringify!(HSEM_TypeDef), "::", stringify!(C1ICR))
		);
	}
	test_field_C1ICR();
	fn test_field_C1ISR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<HSEM_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).C1ISR) as usize - ptr as usize
		           },
		           264usize,
		           concat!("Offset of field: ", stringify!(HSEM_TypeDef), "::", stringify!(C1ISR))
		);
	}
	test_field_C1ISR();
	fn test_field_C1MISR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<HSEM_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).C1MISR) as usize - ptr as usize
		           },
		           268usize,
		           concat!("Offset of field: ", stringify!(HSEM_TypeDef), "::", stringify!(C1MISR))
		);
	}
	test_field_C1MISR();
	fn test_field_C2IER() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<HSEM_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).C2IER) as usize - ptr as usize
		           },
		           272usize,
		           concat!("Offset of field: ", stringify!(HSEM_TypeDef), "::", stringify!(C2IER))
		);
	}
	test_field_C2IER();
	fn test_field_C2ICR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<HSEM_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).C2ICR) as usize - ptr as usize
		           },
		           276usize,
		           concat!("Offset of field: ", stringify!(HSEM_TypeDef), "::", stringify!(C2ICR))
		);
	}
	test_field_C2ICR();
	fn test_field_C2ISR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<HSEM_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).C2ISR) as usize - ptr as usize
		           },
		           280usize,
		           concat!("Offset of field: ", stringify!(HSEM_TypeDef), "::", stringify!(C2ISR))
		);
	}
	test_field_C2ISR();
	fn test_field_C2MISR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<HSEM_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).C2MISR) as usize - ptr as usize
		           },
		           284usize,
		           concat!("Offset of field: ", stringify!(HSEM_TypeDef), "::", stringify!(C2MISR))
		);
	}
	test_field_C2MISR();
	fn test_field_Reserved() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<HSEM_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).Reserved) as usize - ptr as usize
		           },
		           288usize,
		           concat!("Offset of field: ", stringify!(HSEM_TypeDef), "::", stringify!(Reserved))
		);
	}
	test_field_Reserved();
	fn test_field_CR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<HSEM_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).CR) as usize - ptr as usize
		           },
		           320usize,
		           concat!("Offset of field: ", stringify!(HSEM_TypeDef), "::", stringify!(CR))
		);
	}
	test_field_CR();
	fn test_field_KEYR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<HSEM_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).KEYR) as usize - ptr as usize
		           },
		           324usize,
		           concat!("Offset of field: ", stringify!(HSEM_TypeDef), "::", stringify!(KEYR))
		);
	}
	test_field_KEYR();
}
#[repr(C)]
pub struct HSEM_Common_TypeDef {
	#[doc = "< HSEM interrupt enable register ,                Address offset:   0h"]
	pub IER: u32,
	#[doc = "< HSEM interrupt clear register ,                 Address offset:   4h"]
	pub ICR: u32,
	#[doc = "< HSEM interrupt status register ,                Address offset:   8h"]
	pub ISR: u32,
	#[doc = "< HSEM masked interrupt status register ,         Address offset:   Ch"]
	pub MISR: u32,
}
#[test]
fn bindgen_test_layout_HSEM_Common_TypeDef() {
	assert_eq!(
	           ::core::mem::size_of::<HSEM_Common_TypeDef>(),
	           16usize,
	           concat!("Size of: ", stringify!(HSEM_Common_TypeDef))
	);
	assert_eq!(
	           ::core::mem::align_of::<HSEM_Common_TypeDef>(),
	           4usize,
	           concat!("Alignment of ", stringify!(HSEM_Common_TypeDef))
	);
	fn test_field_IER() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<HSEM_Common_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).IER) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(HSEM_Common_TypeDef), "::", stringify!(IER))
		);
	}
	test_field_IER();
	fn test_field_ICR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<HSEM_Common_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).ICR) as usize - ptr as usize
		           },
		           4usize,
		           concat!("Offset of field: ", stringify!(HSEM_Common_TypeDef), "::", stringify!(ICR))
		);
	}
	test_field_ICR();
	fn test_field_ISR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<HSEM_Common_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).ISR) as usize - ptr as usize
		           },
		           8usize,
		           concat!("Offset of field: ", stringify!(HSEM_Common_TypeDef), "::", stringify!(ISR))
		);
	}
	test_field_ISR();
	fn test_field_MISR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<HSEM_Common_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).MISR) as usize - ptr as usize
		           },
		           12usize,
		           concat!("Offset of field: ", stringify!(HSEM_Common_TypeDef), "::", stringify!(MISR))
		);
	}
	test_field_MISR();
}
#[repr(u32)]
#[non_exhaustive]
#[doc = " @addtogroup Exported_types"]
#[doc = " @{"]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum FlagStatus {
	RESET = 0,
	SET = 1,
}
#[doc = " @addtogroup Exported_types"]
#[doc = " @{"]
pub use self::FlagStatus as ITStatus;
#[repr(u32)]
#[non_exhaustive]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum FunctionalState {
	DISABLE = 0,
	ENABLE = 1,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum ErrorStatus {
	SUCCESS = 0,
	ERROR = 1,
}
#[doc = " @brief LL GPIO Init Structure definition"]
#[repr(C)]
pub struct LL_GPIO_InitTypeDef {
	#[doc = "< Specifies the GPIO pins to be configured."]
	#[doc = "This parameter can be any value of @ref GPIO_LL_EC_PIN"]
	pub Pin: u32,
	#[doc = "< Specifies the operating mode for the selected pins."]
	#[doc = "This parameter can be a value of @ref GPIO_LL_EC_MODE."]
	#[doc = ""]
	#[doc = "GPIO HW configuration can be modified afterwards using unitary function @ref LL_GPIO_SetPinMode()."]
	pub Mode: u32,
	#[doc = "< Specifies the speed for the selected pins."]
	#[doc = "This parameter can be a value of @ref GPIO_LL_EC_SPEED."]
	#[doc = ""]
	#[doc = "GPIO HW configuration can be modified afterwards using unitary function @ref LL_GPIO_SetPinSpeed()."]
	pub Speed: u32,
	#[doc = "< Specifies the operating output type for the selected pins."]
	#[doc = "This parameter can be a value of @ref GPIO_LL_EC_OUTPUT."]
	#[doc = ""]
	#[doc = "GPIO HW configuration can be modified afterwards using unitary function @ref LL_GPIO_SetPinOutputType()."]
	pub OutputType: u32,
	#[doc = "< Specifies the operating Pull-up/Pull down for the selected pins."]
	#[doc = "This parameter can be a value of @ref GPIO_LL_EC_PULL."]
	#[doc = ""]
	#[doc = "GPIO HW configuration can be modified afterwards using unitary function @ref LL_GPIO_SetPinPull()."]
	pub Pull: u32,
	#[doc = "< Specifies the Peripheral to be connected to the selected pins."]
	#[doc = "This parameter can be a value of @ref GPIO_LL_EC_AF."]
	#[doc = ""]
	#[doc = "GPIO HW configuration can be modified afterwards using unitary function @ref LL_GPIO_SetAFPin_0_7() and LL_GPIO_SetAFPin_8_15()."]
	pub Alternate: u32,
}
#[test]
fn bindgen_test_layout_LL_GPIO_InitTypeDef() {
	assert_eq!(
	           ::core::mem::size_of::<LL_GPIO_InitTypeDef>(),
	           24usize,
	           concat!("Size of: ", stringify!(LL_GPIO_InitTypeDef))
	);
	assert_eq!(
	           ::core::mem::align_of::<LL_GPIO_InitTypeDef>(),
	           4usize,
	           concat!("Alignment of ", stringify!(LL_GPIO_InitTypeDef))
	);
	fn test_field_Pin() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_GPIO_InitTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).Pin) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(LL_GPIO_InitTypeDef), "::", stringify!(Pin))
		);
	}
	test_field_Pin();
	fn test_field_Mode() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_GPIO_InitTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).Mode) as usize - ptr as usize
		           },
		           4usize,
		           concat!("Offset of field: ", stringify!(LL_GPIO_InitTypeDef), "::", stringify!(Mode))
		);
	}
	test_field_Mode();
	fn test_field_Speed() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_GPIO_InitTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).Speed) as usize - ptr as usize
		           },
		           8usize,
		           concat!("Offset of field: ", stringify!(LL_GPIO_InitTypeDef), "::", stringify!(Speed))
		);
	}
	test_field_Speed();
	fn test_field_OutputType() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_GPIO_InitTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).OutputType) as usize - ptr as usize
		           },
		           12usize,
		           concat!(
			"Offset of field: ",
			stringify!(LL_GPIO_InitTypeDef),
			"::",
			stringify!(OutputType)
		)
		);
	}
	test_field_OutputType();
	fn test_field_Pull() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_GPIO_InitTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).Pull) as usize - ptr as usize
		           },
		           16usize,
		           concat!("Offset of field: ", stringify!(LL_GPIO_InitTypeDef), "::", stringify!(Pull))
		);
	}
	test_field_Pull();
	fn test_field_Alternate() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_GPIO_InitTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).Alternate) as usize - ptr as usize
		           },
		           20usize,
		           concat!(
			"Offset of field: ",
			stringify!(LL_GPIO_InitTypeDef),
			"::",
			stringify!(Alternate)
		)
		);
	}
	test_field_Alternate();
}
extern "C" {
	#[doc = " @defgroup GPIO_LL_EF_Init Initialization and de-initialization functions"]
	#[doc = " @{"]
	pub fn LL_GPIO_DeInit(GPIOx: *mut GPIO_TypeDef) -> ErrorStatus;
}
extern "C" {
	pub fn LL_GPIO_Init(GPIOx: *mut GPIO_TypeDef, GPIO_InitStruct: *mut LL_GPIO_InitTypeDef) -> ErrorStatus;
}
extern "C" {
	pub fn LL_GPIO_StructInit(GPIO_InitStruct: *mut LL_GPIO_InitTypeDef);
}
#[doc = " @defgroup EXTI_LL_ES_INIT EXTI Exported Init structure"]
#[doc = " @{"]
#[repr(C)]
pub struct LL_EXTI_InitTypeDef {
	#[doc = "< Specifies the EXTI lines to be enabled or disabled for Lines in range 0 to 31"]
	#[doc = "This parameter can be any combination of @ref EXTI_LL_EC_LINE"]
	pub Line_0_31: u32,
	#[doc = "< Specifies the EXTI lines to be enabled or disabled for Lines in range 32 to 63"]
	#[doc = "This parameter can be any combination of @ref EXTI_LL_EC_LINE"]
	pub Line_32_63: u32,
	#[doc = "< Specifies the new state of the selected EXTI lines."]
	#[doc = "This parameter can be set either to ENABLE or DISABLE"]
	pub LineCommand: FunctionalState,
	#[doc = "< Specifies the mode for the EXTI lines."]
	#[doc = "This parameter can be a value of @ref EXTI_LL_EC_MODE."]
	pub Mode: u8,
	#[doc = "< Specifies the trigger signal active edge for the EXTI lines."]
	#[doc = "This parameter can be a value of @ref EXTI_LL_EC_TRIGGER."]
	pub Trigger: u8,
}
#[test]
fn bindgen_test_layout_LL_EXTI_InitTypeDef() {
	assert_eq!(
	           ::core::mem::size_of::<LL_EXTI_InitTypeDef>(),
	           16usize,
	           concat!("Size of: ", stringify!(LL_EXTI_InitTypeDef))
	);
	assert_eq!(
	           ::core::mem::align_of::<LL_EXTI_InitTypeDef>(),
	           4usize,
	           concat!("Alignment of ", stringify!(LL_EXTI_InitTypeDef))
	);
	fn test_field_Line_0_31() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_EXTI_InitTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).Line_0_31) as usize - ptr as usize
		           },
		           0usize,
		           concat!(
			"Offset of field: ",
			stringify!(LL_EXTI_InitTypeDef),
			"::",
			stringify!(Line_0_31)
		)
		);
	}
	test_field_Line_0_31();
	fn test_field_Line_32_63() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_EXTI_InitTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).Line_32_63) as usize - ptr as usize
		           },
		           4usize,
		           concat!(
			"Offset of field: ",
			stringify!(LL_EXTI_InitTypeDef),
			"::",
			stringify!(Line_32_63)
		)
		);
	}
	test_field_Line_32_63();
	fn test_field_LineCommand() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_EXTI_InitTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).LineCommand) as usize - ptr as usize
		           },
		           8usize,
		           concat!(
			"Offset of field: ",
			stringify!(LL_EXTI_InitTypeDef),
			"::",
			stringify!(LineCommand)
		)
		);
	}
	test_field_LineCommand();
	fn test_field_Mode() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_EXTI_InitTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).Mode) as usize - ptr as usize
		           },
		           12usize,
		           concat!("Offset of field: ", stringify!(LL_EXTI_InitTypeDef), "::", stringify!(Mode))
		);
	}
	test_field_Mode();
	fn test_field_Trigger() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_EXTI_InitTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).Trigger) as usize - ptr as usize
		           },
		           13usize,
		           concat!(
			"Offset of field: ",
			stringify!(LL_EXTI_InitTypeDef),
			"::",
			stringify!(Trigger)
		)
		);
	}
	test_field_Trigger();
}
extern "C" {
	#[doc = " @defgroup EXTI_LL_EF_Init Initialization and de-initialization functions"]
	#[doc = " @{"]
	pub fn LL_EXTI_Init(EXTI_InitStruct: *mut LL_EXTI_InitTypeDef) -> ErrorStatus;
}
extern "C" {
	pub fn LL_EXTI_DeInit() -> ErrorStatus;
}
extern "C" {
	pub fn LL_EXTI_StructInit(EXTI_InitStruct: *mut LL_EXTI_InitTypeDef);
}
#[doc = " Interrupt callback prototype"]
pub type GpioExtiCallback = ::core::option::Option<unsafe extern "C" fn(ctx: *mut core::ffi::c_void)>;
#[doc = " Gpio interrupt type"]
#[repr(C)]
pub struct GpioInterrupt {
	pub callback: GpioExtiCallback,
	pub context: *mut core::ffi::c_void,
	pub ready: bool,
}
#[test]
fn bindgen_test_layout_GpioInterrupt() {
	assert_eq!(
	           ::core::mem::size_of::<GpioInterrupt>(),
	           12usize,
	           concat!("Size of: ", stringify!(GpioInterrupt))
	);
	assert_eq!(
	           ::core::mem::align_of::<GpioInterrupt>(),
	           4usize,
	           concat!("Alignment of ", stringify!(GpioInterrupt))
	);
	fn test_field_callback() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<GpioInterrupt>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).callback) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(GpioInterrupt), "::", stringify!(callback))
		);
	}
	test_field_callback();
	fn test_field_context() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<GpioInterrupt>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).context) as usize - ptr as usize
		           },
		           4usize,
		           concat!("Offset of field: ", stringify!(GpioInterrupt), "::", stringify!(context))
		);
	}
	test_field_context();
	fn test_field_ready() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<GpioInterrupt>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).ready) as usize - ptr as usize
		           },
		           8usize,
		           concat!("Offset of field: ", stringify!(GpioInterrupt), "::", stringify!(ready))
		);
	}
	test_field_ready();
}
#[repr(u32)]
#[non_exhaustive]
#[doc = " Gpio modes"]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum GpioMode {
	GpioModeInput = 0,
	GpioModeOutputPushPull = 1,
	GpioModeOutputOpenDrain = 2,
	GpioModeAltFunctionPushPull = 3,
	GpioModeAltFunctionOpenDrain = 4,
	GpioModeAnalog = 5,
	GpioModeInterruptRise = 6,
	GpioModeInterruptFall = 7,
	GpioModeInterruptRiseFall = 8,
	GpioModeEventRise = 9,
	GpioModeEventFall = 10,
	GpioModeEventRiseFall = 11,
}
#[repr(u32)]
#[non_exhaustive]
#[doc = " Gpio pull modes"]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum GpioPull {
	GpioPullNo = 0,
	GpioPullUp = 1,
	GpioPullDown = 2,
}
#[repr(u32)]
#[non_exhaustive]
#[doc = " Gpio speed modes"]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum GpioSpeed {
	GpioSpeedLow = 0,
	GpioSpeedMedium = 1,
	GpioSpeedHigh = 2,
	GpioSpeedVeryHigh = 3,
}
impl GpioAltFn {
	pub const GpioAltFn0LSCO: GpioAltFn = GpioAltFn::GpioAltFn0MCO;
}
impl GpioAltFn {
	pub const GpioAltFn0JTMS_SWDIO: GpioAltFn = GpioAltFn::GpioAltFn0MCO;
}
impl GpioAltFn {
	pub const GpioAltFn0JTCK_SWCLK: GpioAltFn = GpioAltFn::GpioAltFn0MCO;
}
impl GpioAltFn {
	pub const GpioAltFn0JTDI: GpioAltFn = GpioAltFn::GpioAltFn0MCO;
}
impl GpioAltFn {
	pub const GpioAltFn0RTC_OUT: GpioAltFn = GpioAltFn::GpioAltFn0MCO;
}
impl GpioAltFn {
	pub const GpioAltFn0JTD_TRACE: GpioAltFn = GpioAltFn::GpioAltFn0MCO;
}
impl GpioAltFn {
	pub const GpioAltFn0NJTRST: GpioAltFn = GpioAltFn::GpioAltFn0MCO;
}
impl GpioAltFn {
	pub const GpioAltFn0RTC_REFIN: GpioAltFn = GpioAltFn::GpioAltFn0MCO;
}
impl GpioAltFn {
	pub const GpioAltFn0TRACED0: GpioAltFn = GpioAltFn::GpioAltFn0MCO;
}
impl GpioAltFn {
	pub const GpioAltFn0TRACED1: GpioAltFn = GpioAltFn::GpioAltFn0MCO;
}
impl GpioAltFn {
	pub const GpioAltFn0TRACED2: GpioAltFn = GpioAltFn::GpioAltFn0MCO;
}
impl GpioAltFn {
	pub const GpioAltFn0TRACED3: GpioAltFn = GpioAltFn::GpioAltFn0MCO;
}
impl GpioAltFn {
	pub const GpioAltFn0TRIG_INOUT: GpioAltFn = GpioAltFn::GpioAltFn0MCO;
}
impl GpioAltFn {
	pub const GpioAltFn0TRACECK: GpioAltFn = GpioAltFn::GpioAltFn0MCO;
}
impl GpioAltFn {
	pub const GpioAltFn0SYS: GpioAltFn = GpioAltFn::GpioAltFn0MCO;
}
impl GpioAltFn {
	pub const GpioAltFn1TIM2: GpioAltFn = GpioAltFn::GpioAltFn1TIM1;
}
impl GpioAltFn {
	pub const GpioAltFn1LPTIM1: GpioAltFn = GpioAltFn::GpioAltFn1TIM1;
}
impl GpioAltFn {
	pub const GpioAltFn2TIM1: GpioAltFn = GpioAltFn::GpioAltFn2TIM2;
}
impl GpioAltFn {
	pub const GpioAltFn3SPI2: GpioAltFn = GpioAltFn::GpioAltFn3SAI1;
}
impl GpioAltFn {
	pub const GpioAltFn3TIM1: GpioAltFn = GpioAltFn::GpioAltFn3SAI1;
}
impl GpioAltFn {
	pub const GpioAltFn4I2C3: GpioAltFn = GpioAltFn::GpioAltFn4I2C1;
}
impl GpioAltFn {
	pub const GpioAltFn5SPI2: GpioAltFn = GpioAltFn::GpioAltFn5SPI1;
}
impl GpioAltFn {
	pub const GpioAltFn6LSCO: GpioAltFn = GpioAltFn::GpioAltFn6MCO;
}
impl GpioAltFn {
	pub const GpioAltFn6RF_DTB0: GpioAltFn = GpioAltFn::GpioAltFn6MCO;
}
impl GpioAltFn {
	pub const GpioAltFn6RF_DTB1: GpioAltFn = GpioAltFn::GpioAltFn6MCO;
}
impl GpioAltFn {
	pub const GpioAltFn6RF_DTB2: GpioAltFn = GpioAltFn::GpioAltFn6MCO;
}
impl GpioAltFn {
	pub const GpioAltFn6RF_DTB3: GpioAltFn = GpioAltFn::GpioAltFn6MCO;
}
impl GpioAltFn {
	pub const GpioAltFn6RF_DTB4: GpioAltFn = GpioAltFn::GpioAltFn6MCO;
}
impl GpioAltFn {
	pub const GpioAltFn6RF_DTB5: GpioAltFn = GpioAltFn::GpioAltFn6MCO;
}
impl GpioAltFn {
	pub const GpioAltFn6RF_DTB6: GpioAltFn = GpioAltFn::GpioAltFn6MCO;
}
impl GpioAltFn {
	pub const GpioAltFn6RF_DTB7: GpioAltFn = GpioAltFn::GpioAltFn6MCO;
}
impl GpioAltFn {
	pub const GpioAltFn6RF_DTB8: GpioAltFn = GpioAltFn::GpioAltFn6MCO;
}
impl GpioAltFn {
	pub const GpioAltFn6RF_DTB9: GpioAltFn = GpioAltFn::GpioAltFn6MCO;
}
impl GpioAltFn {
	pub const GpioAltFn6RF_DTB10: GpioAltFn = GpioAltFn::GpioAltFn6MCO;
}
impl GpioAltFn {
	pub const GpioAltFn6RF_DTB11: GpioAltFn = GpioAltFn::GpioAltFn6MCO;
}
impl GpioAltFn {
	pub const GpioAltFn6RF_DTB12: GpioAltFn = GpioAltFn::GpioAltFn6MCO;
}
impl GpioAltFn {
	pub const GpioAltFn6RF_DTB13: GpioAltFn = GpioAltFn::GpioAltFn6MCO;
}
impl GpioAltFn {
	pub const GpioAltFn6RF_DTB14: GpioAltFn = GpioAltFn::GpioAltFn6MCO;
}
impl GpioAltFn {
	pub const GpioAltFn6RF_DTB15: GpioAltFn = GpioAltFn::GpioAltFn6MCO;
}
impl GpioAltFn {
	pub const GpioAltFn6RF_DTB16: GpioAltFn = GpioAltFn::GpioAltFn6MCO;
}
impl GpioAltFn {
	pub const GpioAltFn6RF_DTB17: GpioAltFn = GpioAltFn::GpioAltFn6MCO;
}
impl GpioAltFn {
	pub const GpioAltFn6RF_DTB18: GpioAltFn = GpioAltFn::GpioAltFn6MCO;
}
impl GpioAltFn {
	pub const GpioAltFn6RF_MISO: GpioAltFn = GpioAltFn::GpioAltFn6MCO;
}
impl GpioAltFn {
	pub const GpioAltFn6RF_MOSI: GpioAltFn = GpioAltFn::GpioAltFn6MCO;
}
impl GpioAltFn {
	pub const GpioAltFn6RF_SCK: GpioAltFn = GpioAltFn::GpioAltFn6MCO;
}
impl GpioAltFn {
	pub const GpioAltFn6RF_NSS: GpioAltFn = GpioAltFn::GpioAltFn6MCO;
}
impl GpioAltFn {
	pub const GpioAltFn8IR: GpioAltFn = GpioAltFn::GpioAltFn8LPUART1;
}
impl GpioAltFn {
	pub const GpioAltFn10USB: GpioAltFn = GpioAltFn::GpioAltFn10QUADSPI;
}
impl GpioAltFn {
	pub const GpioAltFn12COMP2: GpioAltFn = GpioAltFn::GpioAltFn12COMP1;
}
impl GpioAltFn {
	pub const GpioAltFn12TIM1: GpioAltFn = GpioAltFn::GpioAltFn12COMP1;
}
impl GpioAltFn {
	pub const GpioAltFn14TIM16: GpioAltFn = GpioAltFn::GpioAltFn14TIM2;
}
impl GpioAltFn {
	pub const GpioAltFn14TIM17: GpioAltFn = GpioAltFn::GpioAltFn14TIM2;
}
impl GpioAltFn {
	pub const GpioAltFn14LPTIM2: GpioAltFn = GpioAltFn::GpioAltFn14TIM2;
}
#[repr(u32)]
#[non_exhaustive]
#[doc = " Gpio alternate functions"]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum GpioAltFn {
	#[doc = "< MCO Alternate Function mapping"]
	GpioAltFn0MCO = 0,
	#[doc = "< TIM1 Alternate Function mapping"]
	GpioAltFn1TIM1 = 1,
	#[doc = "< TIM2 Alternate Function mapping"]
	GpioAltFn2TIM2 = 2,
	#[doc = "< SAI1_CK1 Alternate Function mapping"]
	GpioAltFn3SAI1 = 3,
	#[doc = "< I2C1 Alternate Function mapping"]
	GpioAltFn4I2C1 = 4,
	#[doc = "< SPI1 Alternate Function mapping"]
	GpioAltFn5SPI1 = 5,
	#[doc = "< MCO Alternate Function mapping"]
	GpioAltFn6MCO = 6,
	#[doc = "< USART1 Alternate Function mapping"]
	GpioAltFn7USART1 = 7,
	#[doc = "< LPUART1 Alternate Function mapping"]
	GpioAltFn8LPUART1 = 8,
	#[doc = "< TSC Alternate Function mapping"]
	GpioAltFn9TSC = 9,
	#[doc = "< QUADSPI Alternate Function mapping"]
	GpioAltFn10QUADSPI = 10,
	#[doc = "< LCD Alternate Function mapping"]
	GpioAltFn11LCD = 11,
	#[doc = "< COMP1 Alternate Function mapping"]
	GpioAltFn12COMP1 = 12,
	#[doc = "< SAI1 Alternate Function mapping"]
	GpioAltFn13SAI1 = 13,
	#[doc = "< TIM2 Alternate Function mapping"]
	GpioAltFn14TIM2 = 14,
	#[doc = "< EVENTOUT Alternate Function mapping"]
	GpioAltFn15EVENTOUT = 15,
	#[doc = "< just dummy value"]
	GpioAltFnUnused = 16,
}
#[doc = " Gpio structure"]
#[repr(C)]
pub struct GpioPin {
	pub port: *mut GPIO_TypeDef,
	pub pin: u16,
}
#[test]
fn bindgen_test_layout_GpioPin() {
	assert_eq!(
	           ::core::mem::size_of::<GpioPin>(),
	           8usize,
	           concat!("Size of: ", stringify!(GpioPin))
	);
	assert_eq!(
	           ::core::mem::align_of::<GpioPin>(),
	           4usize,
	           concat!("Alignment of ", stringify!(GpioPin))
	);
	fn test_field_port() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<GpioPin>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).port) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(GpioPin), "::", stringify!(port))
		);
	}
	test_field_port();
	fn test_field_pin() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<GpioPin>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).pin) as usize - ptr as usize
		           },
		           4usize,
		           concat!("Offset of field: ", stringify!(GpioPin), "::", stringify!(pin))
		);
	}
	test_field_pin();
}
extern "C" {
	#[doc = " GPIO initialization function, simple version"]
	#[doc = " @param gpio  GpioPin"]
	#[doc = " @param mode  GpioMode"]
	pub fn furi_hal_gpio_init_simple(gpio: *const GpioPin, mode: GpioMode);
}
extern "C" {
	#[doc = " GPIO initialization function, normal version"]
	#[doc = " @param gpio  GpioPin"]
	#[doc = " @param mode  GpioMode"]
	#[doc = " @param pull  GpioPull"]
	#[doc = " @param speed GpioSpeed"]
	pub fn furi_hal_gpio_init(gpio: *const GpioPin, mode: GpioMode, pull: GpioPull, speed: GpioSpeed);
}
extern "C" {
	#[doc = " GPIO initialization function, extended version"]
	#[doc = " @param gpio  GpioPin"]
	#[doc = " @param mode  GpioMode"]
	#[doc = " @param pull  GpioPull"]
	#[doc = " @param speed GpioSpeed"]
	#[doc = " @param alt_fn GpioAltFn"]
	pub fn furi_hal_gpio_init_ex(gpio: *const GpioPin, mode: GpioMode, pull: GpioPull, speed: GpioSpeed, alt_fn: GpioAltFn);
}
extern "C" {
	#[doc = " Add and enable interrupt"]
	#[doc = " @param gpio GpioPin"]
	#[doc = " @param cb   GpioExtiCallback"]
	#[doc = " @param ctx  context for callback"]
	pub fn furi_hal_gpio_add_int_callback(gpio: *const GpioPin, cb: GpioExtiCallback, ctx: *mut core::ffi::c_void);
}
extern "C" {
	#[doc = " Enable interrupt"]
	#[doc = " @param gpio GpioPin"]
	pub fn furi_hal_gpio_enable_int_callback(gpio: *const GpioPin);
}
extern "C" {
	#[doc = " Disable interrupt"]
	#[doc = " @param gpio GpioPin"]
	pub fn furi_hal_gpio_disable_int_callback(gpio: *const GpioPin);
}
extern "C" {
	#[doc = " Remove interrupt"]
	#[doc = " @param gpio GpioPin"]
	pub fn furi_hal_gpio_remove_int_callback(gpio: *const GpioPin);
}
#[doc = " Type by which software timers are referenced.  For example, a call to"]
#[doc = " xTimerCreate() returns an TimerHandle_t variable that can then be used to"]
#[doc = " reference the subject timer in calls to other software timer API functions"]
#[doc = " (for example, xTimerStart(), xTimerReset(), etc.)."]
#[repr(C)]
pub struct tmrTimerControl {
	_unused: [u8; 0],
}
pub type TimerHandle_t = *mut tmrTimerControl;
pub type TimerCallbackFunction_t = ::core::option::Option<unsafe extern "C" fn(xTimer: TimerHandle_t)>;
pub type PendedFunction_t = ::core::option::Option<unsafe extern "C" fn(arg1: *mut core::ffi::c_void, arg2: u32)>;
extern "C" {
	pub fn xTimerCreate(pcTimerName: *const core::ffi::c_char,
	                    xTimerPeriodInTicks: TickType_t,
	                    uxAutoReload: UBaseType_t,
	                    pvTimerID: *mut core::ffi::c_void,
	                    pxCallbackFunction: TimerCallbackFunction_t)
	                    -> TimerHandle_t;
}
extern "C" {
	pub fn xTimerCreateStatic(pcTimerName: *const core::ffi::c_char,
	                          xTimerPeriodInTicks: TickType_t,
	                          uxAutoReload: UBaseType_t,
	                          pvTimerID: *mut core::ffi::c_void,
	                          pxCallbackFunction: TimerCallbackFunction_t,
	                          pxTimerBuffer: *mut StaticTimer_t)
	                          -> TimerHandle_t;
}
extern "C" {
	#[doc = " void *pvTimerGetTimerID( TimerHandle_t xTimer );"]
	#[doc = ""]
	#[doc = " Returns the ID assigned to the timer."]
	#[doc = ""]
	#[doc = " IDs are assigned to timers using the pvTimerID parameter of the call to"]
	#[doc = " xTimerCreated() that was used to create the timer, and by calling the"]
	#[doc = " vTimerSetTimerID() API function."]
	#[doc = ""]
	#[doc = " If the same callback function is assigned to multiple timers then the timer"]
	#[doc = " ID can be used as time specific (timer local) storage."]
	#[doc = ""]
	#[doc = " @param xTimer The timer being queried."]
	#[doc = ""]
	#[doc = " @return The ID assigned to the timer being queried."]
	#[doc = ""]
	#[doc = " Example usage:"]
	#[doc = ""]
	#[doc = " See the xTimerCreate() API function example usage scenario."]
	pub fn pvTimerGetTimerID(xTimer: TimerHandle_t) -> *mut core::ffi::c_void;
}
extern "C" {
	#[doc = " void vTimerSetTimerID( TimerHandle_t xTimer, void *pvNewID );"]
	#[doc = ""]
	#[doc = " Sets the ID assigned to the timer."]
	#[doc = ""]
	#[doc = " IDs are assigned to timers using the pvTimerID parameter of the call to"]
	#[doc = " xTimerCreated() that was used to create the timer."]
	#[doc = ""]
	#[doc = " If the same callback function is assigned to multiple timers then the timer"]
	#[doc = " ID can be used as time specific (timer local) storage."]
	#[doc = ""]
	#[doc = " @param xTimer The timer being updated."]
	#[doc = ""]
	#[doc = " @param pvNewID The ID to assign to the timer."]
	#[doc = ""]
	#[doc = " Example usage:"]
	#[doc = ""]
	#[doc = " See the xTimerCreate() API function example usage scenario."]
	pub fn vTimerSetTimerID(xTimer: TimerHandle_t, pvNewID: *mut core::ffi::c_void);
}
extern "C" {
	#[doc = " BaseType_t xTimerIsTimerActive( TimerHandle_t xTimer );"]
	#[doc = ""]
	#[doc = " Queries a timer to see if it is active or dormant."]
	#[doc = ""]
	#[doc = " A timer will be dormant if:"]
	#[doc = "     1) It has been created but not started, or"]
	#[doc = "     2) It is an expired one-shot timer that has not been restarted."]
	#[doc = ""]
	#[doc = " Timers are created in the dormant state.  The xTimerStart(), xTimerReset(),"]
	#[doc = " xTimerStartFromISR(), xTimerResetFromISR(), xTimerChangePeriod() and"]
	#[doc = " xTimerChangePeriodFromISR() API functions can all be used to transition a timer into the"]
	#[doc = " active state."]
	#[doc = ""]
	#[doc = " @param xTimer The timer being queried."]
	#[doc = ""]
	#[doc = " @return pdFALSE will be returned if the timer is dormant.  A value other than"]
	#[doc = " pdFALSE will be returned if the timer is active."]
	#[doc = ""]
	#[doc = " Example usage:"]
	#[doc = " @verbatim"]
	#[doc = " // This function assumes xTimer has already been created."]
	#[doc = " void vAFunction( TimerHandle_t xTimer )"]
	#[doc = " {"]
	#[doc = "     if( xTimerIsTimerActive( xTimer ) != pdFALSE ) // or more simply and equivalently \"if( xTimerIsTimerActive( xTimer ) )\""]
	#[doc = "     {"]
	#[doc = "         // xTimer is active, do something."]
	#[doc = "     }"]
	#[doc = "     else"]
	#[doc = "     {"]
	#[doc = "         // xTimer is not active, do something else."]
	#[doc = "     }"]
	#[doc = " }"]
	#[doc = " @endverbatim"]
	pub fn xTimerIsTimerActive(xTimer: TimerHandle_t) -> BaseType_t;
}
extern "C" {
	#[doc = " TaskHandle_t xTimerGetTimerDaemonTaskHandle( void );"]
	#[doc = ""]
	#[doc = " Simply returns the handle of the timer service/daemon task.  It it not valid"]
	#[doc = " to call xTimerGetTimerDaemonTaskHandle() before the scheduler has been started."]
	pub fn xTimerGetTimerDaemonTaskHandle() -> TaskHandle_t;
}
extern "C" {
	#[doc = " BaseType_t xTimerPendFunctionCallFromISR( PendedFunction_t xFunctionToPend,"]
	#[doc = "                                          void *pvParameter1,"]
	#[doc = "                                          uint32_t ulParameter2,"]
	#[doc = "                                          BaseType_t *pxHigherPriorityTaskWoken );"]
	#[doc = ""]
	#[doc = ""]
	#[doc = " Used from application interrupt service routines to defer the execution of a"]
	#[doc = " function to the RTOS daemon task (the timer service task, hence this function"]
	#[doc = " is implemented in timers.c and is prefixed with 'Timer')."]
	#[doc = ""]
	#[doc = " Ideally an interrupt service routine (ISR) is kept as short as possible, but"]
	#[doc = " sometimes an ISR either has a lot of processing to do, or needs to perform"]
	#[doc = " processing that is not deterministic.  In these cases"]
	#[doc = " xTimerPendFunctionCallFromISR() can be used to defer processing of a function"]
	#[doc = " to the RTOS daemon task."]
	#[doc = ""]
	#[doc = " A mechanism is provided that allows the interrupt to return directly to the"]
	#[doc = " task that will subsequently execute the pended callback function.  This"]
	#[doc = " allows the callback function to execute contiguously in time with the"]
	#[doc = " interrupt - just as if the callback had executed in the interrupt itself."]
	#[doc = ""]
	#[doc = " @param xFunctionToPend The function to execute from the timer service/"]
	#[doc = " daemon task.  The function must conform to the PendedFunction_t"]
	#[doc = " prototype."]
	#[doc = ""]
	#[doc = " @param pvParameter1 The value of the callback function's first parameter."]
	#[doc = " The parameter has a void * type to allow it to be used to pass any type."]
	#[doc = " For example, unsigned longs can be cast to a void *, or the void * can be"]
	#[doc = " used to point to a structure."]
	#[doc = ""]
	#[doc = " @param ulParameter2 The value of the callback function's second parameter."]
	#[doc = ""]
	#[doc = " @param pxHigherPriorityTaskWoken As mentioned above, calling this function"]
	#[doc = " will result in a message being sent to the timer daemon task.  If the"]
	#[doc = " priority of the timer daemon task (which is set using"]
	#[doc = " configTIMER_TASK_PRIORITY in FreeRTOSConfig.h) is higher than the priority of"]
	#[doc = " the currently running task (the task the interrupt interrupted) then"]
	#[doc = " *pxHigherPriorityTaskWoken will be set to pdTRUE within"]
	#[doc = " xTimerPendFunctionCallFromISR(), indicating that a context switch should be"]
	#[doc = " requested before the interrupt exits.  For that reason"]
	#[doc = " *pxHigherPriorityTaskWoken must be initialised to pdFALSE.  See the"]
	#[doc = " example code below."]
	#[doc = ""]
	#[doc = " @return pdPASS is returned if the message was successfully sent to the"]
	#[doc = " timer daemon task, otherwise pdFALSE is returned."]
	#[doc = ""]
	#[doc = " Example usage:"]
	#[doc = " @verbatim"]
	#[doc = ""]
	#[doc = "  // The callback function that will execute in the context of the daemon task."]
	#[doc = "  // Note callback functions must all use this same prototype."]
	#[doc = "  void vProcessInterface( void *pvParameter1, uint32_t ulParameter2 )"]
	#[doc = "  {"]
	#[doc = "      BaseType_t xInterfaceToService;"]
	#[doc = ""]
	#[doc = "      // The interface that requires servicing is passed in the second"]
	#[doc = "      // parameter.  The first parameter is not used in this case."]
	#[doc = "      xInterfaceToService = ( BaseType_t ) ulParameter2;"]
	#[doc = ""]
	#[doc = "      // ...Perform the processing here..."]
	#[doc = "  }"]
	#[doc = ""]
	#[doc = "  // An ISR that receives data packets from multiple interfaces"]
	#[doc = "  void vAnISR( void )"]
	#[doc = "  {"]
	#[doc = "      BaseType_t xInterfaceToService, xHigherPriorityTaskWoken;"]
	#[doc = ""]
	#[doc = "      // Query the hardware to determine which interface needs processing."]
	#[doc = "      xInterfaceToService = prvCheckInterfaces();"]
	#[doc = ""]
	#[doc = "      // The actual processing is to be deferred to a task.  Request the"]
	#[doc = "      // vProcessInterface() callback function is executed, passing in the"]
	#[doc = "      // number of the interface that needs processing.  The interface to"]
	#[doc = "      // service is passed in the second parameter.  The first parameter is"]
	#[doc = "      // not used in this case."]
	#[doc = "      xHigherPriorityTaskWoken = pdFALSE;"]
	#[doc = "      xTimerPendFunctionCallFromISR( vProcessInterface, NULL, ( uint32_t ) xInterfaceToService, &xHigherPriorityTaskWoken );"]
	#[doc = ""]
	#[doc = "      // If xHigherPriorityTaskWoken is now set to pdTRUE then a context"]
	#[doc = "      // switch should be requested.  The macro used is port specific and will"]
	#[doc = "      // be either portYIELD_FROM_ISR() or portEND_SWITCHING_ISR() - refer to"]
	#[doc = "      // the documentation page for the port being used."]
	#[doc = "      portYIELD_FROM_ISR( xHigherPriorityTaskWoken );"]
	#[doc = ""]
	#[doc = "  }"]
	#[doc = " @endverbatim"]
	pub fn xTimerPendFunctionCallFromISR(xFunctionToPend: PendedFunction_t,
	                                     pvParameter1: *mut core::ffi::c_void,
	                                     ulParameter2: u32,
	                                     pxHigherPriorityTaskWoken: *mut BaseType_t)
	                                     -> BaseType_t;
}
extern "C" {
	#[doc = " BaseType_t xTimerPendFunctionCall( PendedFunction_t xFunctionToPend,"]
	#[doc = "                                    void *pvParameter1,"]
	#[doc = "                                    uint32_t ulParameter2,"]
	#[doc = "                                    TickType_t xTicksToWait );"]
	#[doc = ""]
	#[doc = ""]
	#[doc = " Used to defer the execution of a function to the RTOS daemon task (the timer"]
	#[doc = " service task, hence this function is implemented in timers.c and is prefixed"]
	#[doc = " with 'Timer')."]
	#[doc = ""]
	#[doc = " @param xFunctionToPend The function to execute from the timer service/"]
	#[doc = " daemon task.  The function must conform to the PendedFunction_t"]
	#[doc = " prototype."]
	#[doc = ""]
	#[doc = " @param pvParameter1 The value of the callback function's first parameter."]
	#[doc = " The parameter has a void * type to allow it to be used to pass any type."]
	#[doc = " For example, unsigned longs can be cast to a void *, or the void * can be"]
	#[doc = " used to point to a structure."]
	#[doc = ""]
	#[doc = " @param ulParameter2 The value of the callback function's second parameter."]
	#[doc = ""]
	#[doc = " @param xTicksToWait Calling this function will result in a message being"]
	#[doc = " sent to the timer daemon task on a queue.  xTicksToWait is the amount of"]
	#[doc = " time the calling task should remain in the Blocked state (so not using any"]
	#[doc = " processing time) for space to become available on the timer queue if the"]
	#[doc = " queue is found to be full."]
	#[doc = ""]
	#[doc = " @return pdPASS is returned if the message was successfully sent to the"]
	#[doc = " timer daemon task, otherwise pdFALSE is returned."]
	#[doc = ""]
	pub fn xTimerPendFunctionCall(xFunctionToPend: PendedFunction_t,
	                              pvParameter1: *mut core::ffi::c_void,
	                              ulParameter2: u32,
	                              xTicksToWait: TickType_t)
	                              -> BaseType_t;
}
extern "C" {
	#[doc = " const char * const pcTimerGetName( TimerHandle_t xTimer );"]
	#[doc = ""]
	#[doc = " Returns the name that was assigned to a timer when the timer was created."]
	#[doc = ""]
	#[doc = " @param xTimer The handle of the timer being queried."]
	#[doc = ""]
	#[doc = " @return The name assigned to the timer specified by the xTimer parameter."]
	pub fn pcTimerGetName(xTimer: TimerHandle_t) -> *const core::ffi::c_char;
}
extern "C" {
	#[doc = " void vTimerSetReloadMode( TimerHandle_t xTimer, const UBaseType_t uxAutoReload );"]
	#[doc = ""]
	#[doc = " Updates a timer to be either an auto-reload timer, in which case the timer"]
	#[doc = " automatically resets itself each time it expires, or a one-shot timer, in"]
	#[doc = " which case the timer will only expire once unless it is manually restarted."]
	#[doc = ""]
	#[doc = " @param xTimer The handle of the timer being updated."]
	#[doc = ""]
	#[doc = " @param uxAutoReload If uxAutoReload is set to pdTRUE then the timer will"]
	#[doc = " expire repeatedly with a frequency set by the timer's period (see the"]
	#[doc = " xTimerPeriodInTicks parameter of the xTimerCreate() API function).  If"]
	#[doc = " uxAutoReload is set to pdFALSE then the timer will be a one-shot timer and"]
	#[doc = " enter the dormant state after it expires."]
	pub fn vTimerSetReloadMode(xTimer: TimerHandle_t, uxAutoReload: UBaseType_t);
}
extern "C" {
	#[doc = " UBaseType_t uxTimerGetReloadMode( TimerHandle_t xTimer );"]
	#[doc = ""]
	#[doc = " Queries a timer to determine if it is an auto-reload timer, in which case the timer"]
	#[doc = " automatically resets itself each time it expires, or a one-shot timer, in"]
	#[doc = " which case the timer will only expire once unless it is manually restarted."]
	#[doc = ""]
	#[doc = " @param xTimer The handle of the timer being queried."]
	#[doc = ""]
	#[doc = " @return If the timer is an auto-reload timer then pdTRUE is returned, otherwise"]
	#[doc = " pdFALSE is returned."]
	pub fn uxTimerGetReloadMode(xTimer: TimerHandle_t) -> UBaseType_t;
}
extern "C" {
	#[doc = " TickType_t xTimerGetPeriod( TimerHandle_t xTimer );"]
	#[doc = ""]
	#[doc = " Returns the period of a timer."]
	#[doc = ""]
	#[doc = " @param xTimer The handle of the timer being queried."]
	#[doc = ""]
	#[doc = " @return The period of the timer in ticks."]
	pub fn xTimerGetPeriod(xTimer: TimerHandle_t) -> TickType_t;
}
extern "C" {
	#[doc = " TickType_t xTimerGetExpiryTime( TimerHandle_t xTimer );"]
	#[doc = ""]
	#[doc = " Returns the time in ticks at which the timer will expire.  If this is less"]
	#[doc = " than the current tick count then the expiry time has overflowed from the"]
	#[doc = " current time."]
	#[doc = ""]
	#[doc = " @param xTimer The handle of the timer being queried."]
	#[doc = ""]
	#[doc = " @return If the timer is running then the time in ticks at which the timer"]
	#[doc = " will next expire is returned.  If the timer is not running then the return"]
	#[doc = " value is undefined."]
	pub fn xTimerGetExpiryTime(xTimer: TimerHandle_t) -> TickType_t;
}
extern "C" {
	pub fn xTimerCreateTimerTask() -> BaseType_t;
}
extern "C" {
	pub fn xTimerGenericCommand(xTimer: TimerHandle_t,
	                            xCommandID: BaseType_t,
	                            xOptionalValue: TickType_t,
	                            pxHigherPriorityTaskWoken: *mut BaseType_t,
	                            xTicksToWait: TickType_t)
	                            -> BaseType_t;
}
extern "C" {
	pub fn vTimerSetTimerNumber(xTimer: TimerHandle_t, uxTimerNumber: UBaseType_t);
}
extern "C" {
	pub fn uxTimerGetTimerNumber(xTimer: TimerHandle_t) -> UBaseType_t;
}
extern "C" {
	#[doc = " task.h"]
	#[doc = " @code{c}"]
	#[doc = " void vApplicationGetTimerTaskMemory( StaticTask_t ** ppxTimerTaskTCBBuffer, StackType_t ** ppxTimerTaskStackBuffer, uint32_t *pulTimerTaskStackSize )"]
	#[doc = " @endcode"]
	#[doc = ""]
	#[doc = " This function is used to provide a statically allocated block of memory to FreeRTOS to hold the Timer Task TCB.  This function is required when"]
	#[doc = " configSUPPORT_STATIC_ALLOCATION is set.  For more information see this URI: https://www.FreeRTOS.org/a00110.html#configSUPPORT_STATIC_ALLOCATION"]
	#[doc = ""]
	#[doc = " @param ppxTimerTaskTCBBuffer   A handle to a statically allocated TCB buffer"]
	#[doc = " @param ppxTimerTaskStackBuffer A handle to a statically allocated Stack buffer for thie idle task"]
	#[doc = " @param pulTimerTaskStackSize   A pointer to the number of elements that will fit in the allocated stack buffer"]
	pub fn vApplicationGetTimerTaskMemory(ppxTimerTaskTCBBuffer: *mut *mut StaticTask_t,
	                                      ppxTimerTaskStackBuffer: *mut *mut StackType_t,
	                                      pulTimerTaskStackSize: *mut u32);
}
extern "C" {
	pub fn furi_init();
}
extern "C" {
	pub fn furi_run();
}
#[repr(C)]
pub struct Icon {
	_unused: [u8; 0],
}
extern "C" {
	#[doc = " Get icon width"]
	#[doc = ""]
	#[doc = " @param[in]  instance  pointer to Icon data"]
	#[doc = ""]
	#[doc = " @return     width in pixels"]
	pub fn icon_get_width(instance: *const Icon) -> u8;
}
extern "C" {
	#[doc = " Get icon height"]
	#[doc = ""]
	#[doc = " @param[in]  instance  pointer to Icon data"]
	#[doc = ""]
	#[doc = " @return     height in pixels"]
	pub fn icon_get_height(instance: *const Icon) -> u8;
}
extern "C" {
	#[doc = " Get Icon XBM bitmap data"]
	#[doc = ""]
	#[doc = " @param[in]  instance  pointer to Icon data"]
	#[doc = ""]
	#[doc = " @return     pointer to XBM bitmap data"]
	pub fn icon_get_data(instance: *const Icon) -> *const u8;
}
extern "C" {
	pub static A_125khz_14: Icon;
}
extern "C" {
	pub static A_BadUsb_14: Icon;
}
extern "C" {
	pub static A_Debug_14: Icon;
}
extern "C" {
	pub static A_FileManager_14: Icon;
}
extern "C" {
	pub static A_GPIO_14: Icon;
}
extern "C" {
	pub static A_Infrared_14: Icon;
}
extern "C" {
	pub static A_Levelup1_128x64: Icon;
}
extern "C" {
	pub static A_Levelup2_128x64: Icon;
}
extern "C" {
	pub static A_Loading_24: Icon;
}
extern "C" {
	pub static A_NFC_14: Icon;
}
extern "C" {
	pub static A_Plugins_14: Icon;
}
extern "C" {
	pub static A_Round_loader_8x8: Icon;
}
extern "C" {
	pub static A_Settings_14: Icon;
}
extern "C" {
	pub static A_Sub1ghz_14: Icon;
}
extern "C" {
	pub static A_U2F_14: Icon;
}
extern "C" {
	pub static A_iButton_14: Icon;
}
extern "C" {
	pub static I_125_10px: Icon;
}
extern "C" {
	pub static I_ActiveConnection_50x64: Icon;
}
extern "C" {
	pub static I_ArrowC_1_36x36: Icon;
}
extern "C" {
	pub static I_ArrowDownEmpty_14x15: Icon;
}
extern "C" {
	pub static I_ArrowDownFilled_14x15: Icon;
}
extern "C" {
	pub static I_ArrowUpEmpty_14x15: Icon;
}
extern "C" {
	pub static I_ArrowUpFilled_14x15: Icon;
}
extern "C" {
	pub static I_Attention_5x8: Icon;
}
extern "C" {
	pub static I_Auth_62x31: Icon;
}
extern "C" {
	pub static I_BLE_Pairing_128x64: Icon;
}
extern "C" {
	pub static I_Background_128x11: Icon;
}
extern "C" {
	pub static I_BatteryBody_52x28: Icon;
}
extern "C" {
	pub static I_Battery_16x16: Icon;
}
extern "C" {
	pub static I_Battery_26x8: Icon;
}
extern "C" {
	pub static I_Ble_connected_15x15: Icon;
}
extern "C" {
	pub static I_Ble_disconnected_15x15: Icon;
}
extern "C" {
	pub static I_Bluetooth_Connected_16x8: Icon;
}
extern "C" {
	pub static I_Bluetooth_Idle_5x8: Icon;
}
extern "C" {
	pub static I_ButtonCenter_7x7: Icon;
}
extern "C" {
	pub static I_ButtonDown_7x4: Icon;
}
extern "C" {
	pub static I_ButtonLeftSmall_3x5: Icon;
}
extern "C" {
	pub static I_ButtonLeft_4x7: Icon;
}
extern "C" {
	pub static I_ButtonRightSmall_3x5: Icon;
}
extern "C" {
	pub static I_ButtonRight_4x7: Icon;
}
extern "C" {
	pub static I_ButtonUp_7x4: Icon;
}
extern "C" {
	pub static I_Button_18x18: Icon;
}
extern "C" {
	pub static I_Certification1_103x56: Icon;
}
extern "C" {
	pub static I_Certification2_98x33: Icon;
}
extern "C" {
	pub static I_Charging_lightning_9x10: Icon;
}
extern "C" {
	pub static I_Charging_lightning_mask_9x10: Icon;
}
extern "C" {
	pub static I_Circles_47x47: Icon;
}
extern "C" {
	pub static I_Clock_18x18: Icon;
}
extern "C" {
	pub static I_Connect_me_62x31: Icon;
}
extern "C" {
	pub static I_Connected_62x31: Icon;
}
extern "C" {
	pub static I_CoolHi_25x27: Icon;
}
extern "C" {
	pub static I_CoolHi_hvr_25x27: Icon;
}
extern "C" {
	pub static I_CoolLo_25x27: Icon;
}
extern "C" {
	pub static I_CoolLo_hvr_25x27: Icon;
}
extern "C" {
	pub static I_Cry_dolph_55x52: Icon;
}
extern "C" {
	pub static I_DFU_128x50: Icon;
}
extern "C" {
	pub static I_Dehumidify_25x27: Icon;
}
extern "C" {
	pub static I_Dehumidify_hvr_25x27: Icon;
}
extern "C" {
	pub static I_Detailed_chip_17x13: Icon;
}
extern "C" {
	pub static I_DolphinCommon_56x48: Icon;
}
extern "C" {
	pub static I_DolphinMafia_115x62: Icon;
}
extern "C" {
	pub static I_DolphinNice_96x59: Icon;
}
extern "C" {
	pub static I_DolphinReadingSuccess_59x63: Icon;
}
extern "C" {
	pub static I_DolphinWait_61x59: Icon;
}
extern "C" {
	pub static I_DoorLeft_70x55: Icon;
}
extern "C" {
	pub static I_DoorRight_70x55: Icon;
}
extern "C" {
	pub static I_Down_25x27: Icon;
}
extern "C" {
	pub static I_Down_hvr_25x27: Icon;
}
extern "C" {
	pub static I_Drive_112x35: Icon;
}
extern "C" {
	pub static I_Error_18x18: Icon;
}
extern "C" {
	pub static I_Error_62x31: Icon;
}
extern "C" {
	pub static I_EviSmile1_18x21: Icon;
}
extern "C" {
	pub static I_EviSmile2_18x21: Icon;
}
extern "C" {
	pub static I_EviWaiting1_18x21: Icon;
}
extern "C" {
	pub static I_EviWaiting2_18x21: Icon;
}
extern "C" {
	pub static I_FaceCharging_29x14: Icon;
}
extern "C" {
	pub static I_FaceConfused_29x14: Icon;
}
extern "C" {
	pub static I_FaceNopower_29x14: Icon;
}
extern "C" {
	pub static I_FaceNormal_29x14: Icon;
}
extern "C" {
	pub static I_GameMode_11x8: Icon;
}
extern "C" {
	pub static I_Health_16x16: Icon;
}
extern "C" {
	pub static I_HeatHi_25x27: Icon;
}
extern "C" {
	pub static I_HeatHi_hvr_25x27: Icon;
}
extern "C" {
	pub static I_HeatLo_25x27: Icon;
}
extern "C" {
	pub static I_HeatLo_hvr_25x27: Icon;
}
extern "C" {
	pub static I_InfraredArrowDown_4x8: Icon;
}
extern "C" {
	pub static I_InfraredArrowUp_4x8: Icon;
}
extern "C" {
	pub static I_InfraredLearnShort_128x31: Icon;
}
extern "C" {
	pub static I_KeyBackspaceSelected_16x9: Icon;
}
extern "C" {
	pub static I_KeyBackspace_16x9: Icon;
}
extern "C" {
	pub static I_KeySaveSelected_24x11: Icon;
}
extern "C" {
	pub static I_KeySave_24x11: Icon;
}
extern "C" {
	pub static I_Keychain_39x36: Icon;
}
extern "C" {
	pub static I_Left_mouse_icon_9x9: Icon;
}
extern "C" {
	pub static I_Lock_7x8: Icon;
}
extern "C" {
	pub static I_Lock_8x8: Icon;
}
extern "C" {
	pub static I_MHz_25x11: Icon;
}
extern "C" {
	pub static I_Medium_chip_22x21: Icon;
}
extern "C" {
	pub static I_Mute_25x27: Icon;
}
extern "C" {
	pub static I_Mute_hvr_25x27: Icon;
}
extern "C" {
	pub static I_NFC_manual_60x50: Icon;
}
extern "C" {
	pub static I_Nfc_10px: Icon;
}
extern "C" {
	pub static I_Off_25x27: Icon;
}
extern "C" {
	pub static I_Off_hvr_25x27: Icon;
}
extern "C" {
	pub static I_Ok_btn_9x9: Icon;
}
extern "C" {
	pub static I_Ok_btn_pressed_13x13: Icon;
}
extern "C" {
	pub static I_Percent_10x14: Icon;
}
extern "C" {
	pub static I_Pin_arrow_down_7x9: Icon;
}
extern "C" {
	pub static I_Pin_arrow_left_9x7: Icon;
}
extern "C" {
	pub static I_Pin_arrow_right_9x7: Icon;
}
extern "C" {
	pub static I_Pin_arrow_up_7x9: Icon;
}
extern "C" {
	pub static I_Pin_attention_dpad_29x29: Icon;
}
extern "C" {
	pub static I_Pin_back_arrow_10x8: Icon;
}
extern "C" {
	pub static I_Pin_back_full_40x8: Icon;
}
extern "C" {
	pub static I_Pin_pointer_5x3: Icon;
}
extern "C" {
	pub static I_Pin_star_7x7: Icon;
}
extern "C" {
	pub static I_Power_25x27: Icon;
}
extern "C" {
	pub static I_Power_hvr_25x27: Icon;
}
extern "C" {
	pub static I_Pressed_Button_13x13: Icon;
}
extern "C" {
	pub static I_Quest_7x8: Icon;
}
extern "C" {
	pub static I_RFIDBigChip_37x36: Icon;
}
extern "C" {
	pub static I_RFIDDolphinReceive_97x61: Icon;
}
extern "C" {
	pub static I_RFIDDolphinSend_97x61: Icon;
}
extern "C" {
	pub static I_RFIDDolphinSuccess_108x57: Icon;
}
extern "C" {
	pub static I_Reader_detect_43x40: Icon;
}
extern "C" {
	pub static I_Restoring_38x32: Icon;
}
extern "C" {
	pub static I_Right_mouse_icon_9x9: Icon;
}
extern "C" {
	pub static I_SDQuestion_35x43: Icon;
}
extern "C" {
	pub static I_SDcardFail_11x8: Icon;
}
extern "C" {
	pub static I_SDcardMounted_11x8: Icon;
}
extern "C" {
	pub static I_Scanning_123x52: Icon;
}
extern "C" {
	pub static I_SmallArrowDown_4x7: Icon;
}
extern "C" {
	pub static I_SmallArrowUp_4x7: Icon;
}
extern "C" {
	pub static I_Smile_18x18: Icon;
}
extern "C" {
	pub static I_Space_65x18: Icon;
}
extern "C" {
	pub static I_Tap_reader_36x38: Icon;
}
extern "C" {
	pub static I_Temperature_16x16: Icon;
}
extern "C" {
	pub static I_Unlock_7x8: Icon;
}
extern "C" {
	pub static I_Unplug_bg_bottom_128x10: Icon;
}
extern "C" {
	pub static I_Unplug_bg_top_128x14: Icon;
}
extern "C" {
	pub static I_Up_25x27: Icon;
}
extern "C" {
	pub static I_Up_hvr_25x27: Icon;
}
extern "C" {
	pub static I_Updating_32x40: Icon;
}
extern "C" {
	pub static I_UsbTree_48x22: Icon;
}
extern "C" {
	pub static I_Vol_down_25x27: Icon;
}
extern "C" {
	pub static I_Vol_down_hvr_25x27: Icon;
}
extern "C" {
	pub static I_Vol_up_25x27: Icon;
}
extern "C" {
	pub static I_Vol_up_hvr_25x27: Icon;
}
extern "C" {
	pub static I_Voldwn_6x6: Icon;
}
extern "C" {
	pub static I_Voltage_16x16: Icon;
}
extern "C" {
	pub static I_Volup_8x6: Icon;
}
extern "C" {
	pub static I_WarningDolphin_45x42: Icon;
}
extern "C" {
	pub static I_Warning_30x23: Icon;
}
extern "C" {
	pub static I_back_10px: Icon;
}
extern "C" {
	pub static I_badusb_10px: Icon;
}
extern "C" {
	pub static I_dir_10px: Icon;
}
extern "C" {
	pub static I_iButtonDolphinVerySuccess_108x52: Icon;
}
extern "C" {
	pub static I_iButtonKey_49x44: Icon;
}
extern "C" {
	pub static I_ibutt_10px: Icon;
}
extern "C" {
	pub static I_ir_10px: Icon;
}
extern "C" {
	pub static I_loading_10px: Icon;
}
extern "C" {
	pub static I_music_10px: Icon;
}
extern "C" {
	pub static I_passport_bad1_46x49: Icon;
}
extern "C" {
	pub static I_passport_bad2_46x49: Icon;
}
extern "C" {
	pub static I_passport_bad3_46x49: Icon;
}
extern "C" {
	pub static I_passport_bottom_128x18: Icon;
}
extern "C" {
	pub static I_passport_happy1_46x49: Icon;
}
extern "C" {
	pub static I_passport_happy2_46x49: Icon;
}
extern "C" {
	pub static I_passport_happy3_46x49: Icon;
}
extern "C" {
	pub static I_passport_left_6x46: Icon;
}
extern "C" {
	pub static I_passport_okay1_46x49: Icon;
}
extern "C" {
	pub static I_passport_okay2_46x49: Icon;
}
extern "C" {
	pub static I_passport_okay3_46x49: Icon;
}
extern "C" {
	pub static I_sub1_10px: Icon;
}
extern "C" {
	pub static I_u2f_10px: Icon;
}
extern "C" {
	pub static I_unknown_10px: Icon;
}
extern "C" {
	pub static I_update_10px: Icon;
}
#[repr(C)]
pub struct IconAnimation {
	_unused: [u8; 0],
}
#[doc = " Icon Animation Callback. Used for update notification"]
pub type IconAnimationCallback =
	::core::option::Option<unsafe extern "C" fn(instance: *mut IconAnimation, context: *mut core::ffi::c_void)>;
extern "C" {
	#[doc = " Allocate icon animation instance with const icon data."]
	#[doc = ""]
	#[doc = " always returns Icon or stops system if not enough memory"]
	#[doc = ""]
	#[doc = " @param[in]  icon  pointer to Icon data"]
	#[doc = ""]
	#[doc = " @return     IconAnimation instance"]
	pub fn icon_animation_alloc(icon: *const Icon) -> *mut IconAnimation;
}
extern "C" {
	#[doc = " Release icon animation instance"]
	#[doc = ""]
	#[doc = " @param      instance  IconAnimation instance"]
	pub fn icon_animation_free(instance: *mut IconAnimation);
}
extern "C" {
	#[doc = " Set IconAnimation update callback"]
	#[doc = ""]
	#[doc = " Normally you do not need to use this function, use view_tie_icon_animation"]
	#[doc = " instead."]
	#[doc = ""]
	#[doc = " @param      instance  IconAnimation instance"]
	#[doc = " @param[in]  callback  IconAnimationCallback"]
	#[doc = " @param      context   callback context"]
	pub fn icon_animation_set_update_callback(instance: *mut IconAnimation,
	                                          callback: IconAnimationCallback,
	                                          context: *mut core::ffi::c_void);
}
extern "C" {
	#[doc = " Get icon animation width"]
	#[doc = ""]
	#[doc = " @param      instance  IconAnimation instance"]
	#[doc = ""]
	#[doc = " @return     width in pixels"]
	pub fn icon_animation_get_width(instance: *mut IconAnimation) -> u8;
}
extern "C" {
	#[doc = " Get icon animation height"]
	#[doc = ""]
	#[doc = " @param      instance  IconAnimation instance"]
	#[doc = ""]
	#[doc = " @return     height in pixels"]
	pub fn icon_animation_get_height(instance: *mut IconAnimation) -> u8;
}
extern "C" {
	#[doc = " Start icon animation"]
	#[doc = ""]
	#[doc = " @param      instance  IconAnimation instance"]
	pub fn icon_animation_start(instance: *mut IconAnimation);
}
extern "C" {
	#[doc = " Stop icon animation"]
	#[doc = ""]
	#[doc = " @param      instance  IconAnimation instance"]
	pub fn icon_animation_stop(instance: *mut IconAnimation);
}
extern "C" {
	#[doc = " Returns true if current frame is a last one"]
	#[doc = ""]
	#[doc = " @param      instance  IconAnimation instance"]
	#[doc = ""]
	#[doc = " @return     true if last frame"]
	pub fn icon_animation_is_last_frame(instance: *mut IconAnimation) -> bool;
}
#[repr(u32)]
#[non_exhaustive]
#[doc = " Color enumeration"]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum Color {
	ColorWhite = 0,
	ColorBlack = 1,
}
#[repr(u32)]
#[non_exhaustive]
#[doc = " Fonts enumeration"]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum Font {
	FontPrimary = 0,
	FontSecondary = 1,
	FontKeyboard = 2,
	FontBigNumbers = 3,
	FontTotalNumber = 4,
}
#[repr(u32)]
#[non_exhaustive]
#[doc = " Alignment enumeration"]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum Align {
	AlignLeft = 0,
	AlignRight = 1,
	AlignTop = 2,
	AlignBottom = 3,
	AlignCenter = 4,
}
#[repr(u32)]
#[non_exhaustive]
#[doc = " Canvas Orientation"]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum CanvasOrientation {
	CanvasOrientationHorizontal = 0,
	CanvasOrientationVertical = 1,
}
#[repr(u32)]
#[non_exhaustive]
#[doc = " Font Direction"]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum CanvasDirection {
	CanvasDirectionLeftToRight = 0,
	CanvasDirectionTopToBottom = 1,
	CanvasDirectionRightToLeft = 2,
	CanvasDirectionBottomToTop = 3,
}
#[doc = " Font parameters"]
#[repr(C)]
pub struct CanvasFontParameters {
	pub leading_default: u8,
	pub leading_min: u8,
	pub height: u8,
	pub descender: u8,
}
#[test]
fn bindgen_test_layout_CanvasFontParameters() {
	assert_eq!(
	           ::core::mem::size_of::<CanvasFontParameters>(),
	           4usize,
	           concat!("Size of: ", stringify!(CanvasFontParameters))
	);
	assert_eq!(
	           ::core::mem::align_of::<CanvasFontParameters>(),
	           1usize,
	           concat!("Alignment of ", stringify!(CanvasFontParameters))
	);
	fn test_field_leading_default() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<CanvasFontParameters>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).leading_default) as usize - ptr as usize
		           },
		           0usize,
		           concat!(
			"Offset of field: ",
			stringify!(CanvasFontParameters),
			"::",
			stringify!(leading_default)
		)
		);
	}
	test_field_leading_default();
	fn test_field_leading_min() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<CanvasFontParameters>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).leading_min) as usize - ptr as usize
		           },
		           1usize,
		           concat!(
			"Offset of field: ",
			stringify!(CanvasFontParameters),
			"::",
			stringify!(leading_min)
		)
		);
	}
	test_field_leading_min();
	fn test_field_height() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<CanvasFontParameters>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).height) as usize - ptr as usize
		           },
		           2usize,
		           concat!(
			"Offset of field: ",
			stringify!(CanvasFontParameters),
			"::",
			stringify!(height)
		)
		);
	}
	test_field_height();
	fn test_field_descender() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<CanvasFontParameters>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).descender) as usize - ptr as usize
		           },
		           3usize,
		           concat!(
			"Offset of field: ",
			stringify!(CanvasFontParameters),
			"::",
			stringify!(descender)
		)
		);
	}
	test_field_descender();
}
#[repr(C)]
pub struct Canvas {
	_unused: [u8; 0],
}
extern "C" {
	#[doc = " Get Canvas width"]
	#[doc = ""]
	#[doc = " @param      canvas  Canvas instance"]
	#[doc = ""]
	#[doc = " @return     width in pixels."]
	pub fn canvas_width(canvas: *mut Canvas) -> u8;
}
extern "C" {
	#[doc = " Get Canvas height"]
	#[doc = ""]
	#[doc = " @param      canvas  Canvas instance"]
	#[doc = ""]
	#[doc = " @return     height in pixels."]
	pub fn canvas_height(canvas: *mut Canvas) -> u8;
}
extern "C" {
	#[doc = " Get current font height"]
	#[doc = ""]
	#[doc = " @param      canvas  Canvas instance"]
	#[doc = ""]
	#[doc = " @return     height in pixels."]
	pub fn canvas_current_font_height(canvas: *mut Canvas) -> u8;
}
extern "C" {
	#[doc = " Get font parameters"]
	#[doc = ""]
	#[doc = " @param      canvas  Canvas instance"]
	#[doc = " @param      font    Font"]
	#[doc = ""]
	#[doc = " @return     pointer to CanvasFontParameters structure"]
	pub fn canvas_get_font_params(canvas: *mut Canvas, font: Font) -> *mut CanvasFontParameters;
}
extern "C" {
	#[doc = " Clear canvas"]
	#[doc = ""]
	#[doc = " @param      canvas  Canvas instance"]
	pub fn canvas_clear(canvas: *mut Canvas);
}
extern "C" {
	#[doc = " Set drawing color"]
	#[doc = ""]
	#[doc = " @param      canvas  Canvas instance"]
	#[doc = " @param      color   Color"]
	pub fn canvas_set_color(canvas: *mut Canvas, color: Color);
}
extern "C" {
	#[doc = " Set font swap"]
	#[doc = " Argument String Rotation Description"]
	#[doc = ""]
	#[doc = " @param      canvas  Canvas instance"]
	#[doc = " @param      dir     Direction font"]
	pub fn canvas_set_font_direction(canvas: *mut Canvas, dir: CanvasDirection);
}
extern "C" {
	#[doc = " Invert drawing color"]
	#[doc = ""]
	#[doc = " @param      canvas  Canvas instance"]
	pub fn canvas_invert_color(canvas: *mut Canvas);
}
extern "C" {
	#[doc = " Set drawing font"]
	#[doc = ""]
	#[doc = " @param      canvas  Canvas instance"]
	#[doc = " @param      font    Font"]
	pub fn canvas_set_font(canvas: *mut Canvas, font: Font);
}
extern "C" {
	#[doc = " Draw string at position of baseline defined by x, y."]
	#[doc = ""]
	#[doc = " @param      canvas  Canvas instance"]
	#[doc = " @param      x       anchor point x coordinate"]
	#[doc = " @param      y       anchor point y coordinate"]
	#[doc = " @param      str     C-string"]
	pub fn canvas_draw_str(canvas: *mut Canvas, x: u8, y: u8, str_: *const core::ffi::c_char);
}
extern "C" {
	#[doc = " Draw aligned string defined by x, y."]
	#[doc = ""]
	#[doc = " Align calculated from position of baseline, string width and ascent (height"]
	#[doc = " of the glyphs above the baseline)"]
	#[doc = ""]
	#[doc = " @param      canvas      Canvas instance"]
	#[doc = " @param      x           anchor point x coordinate"]
	#[doc = " @param      y           anchor point y coordinate"]
	#[doc = " @param      horizontal  horizontal alignment"]
	#[doc = " @param      vertical    vertical alignment"]
	#[doc = " @param      str         C-string"]
	pub fn canvas_draw_str_aligned(canvas: *mut Canvas,
	                               x: u8,
	                               y: u8,
	                               horizontal: Align,
	                               vertical: Align,
	                               str_: *const core::ffi::c_char);
}
extern "C" {
	#[doc = " Get string width"]
	#[doc = ""]
	#[doc = " @param      canvas  Canvas instance"]
	#[doc = " @param      str     C-string"]
	#[doc = ""]
	#[doc = " @return     width in pixels."]
	pub fn canvas_string_width(canvas: *mut Canvas, str_: *const core::ffi::c_char) -> u16;
}
extern "C" {
	#[doc = " Get glyph width"]
	#[doc = ""]
	#[doc = " @param      canvas  Canvas instance"]
	#[doc = " @param[in]  symbol  character"]
	#[doc = ""]
	#[doc = " @return     width in pixels"]
	pub fn canvas_glyph_width(canvas: *mut Canvas, symbol: core::ffi::c_char) -> u8;
}
extern "C" {
	#[doc = " Draw bitmap picture at position defined by x,y."]
	#[doc = ""]
	#[doc = " @param      canvas                   Canvas instance"]
	#[doc = " @param      x                        x coordinate"]
	#[doc = " @param      y                        y coordinate"]
	#[doc = " @param      width                    width of bitmap"]
	#[doc = " @param      height                   height of bitmap"]
	#[doc = " @param      compressed_bitmap_data   compressed bitmap data"]
	pub fn canvas_draw_bitmap(canvas: *mut Canvas, x: u8, y: u8, width: u8, height: u8, compressed_bitmap_data: *const u8);
}
extern "C" {
	#[doc = " Draw animation at position defined by x,y."]
	#[doc = ""]
	#[doc = " @param      canvas          Canvas instance"]
	#[doc = " @param      x               x coordinate"]
	#[doc = " @param      y               y coordinate"]
	#[doc = " @param      icon_animation  IconAnimation instance"]
	pub fn canvas_draw_icon_animation(canvas: *mut Canvas, x: u8, y: u8, icon_animation: *mut IconAnimation);
}
extern "C" {
	#[doc = " Draw icon at position defined by x,y."]
	#[doc = ""]
	#[doc = " @param      canvas  Canvas instance"]
	#[doc = " @param      x       x coordinate"]
	#[doc = " @param      y       y coordinate"]
	#[doc = " @param      icon    Icon instance"]
	pub fn canvas_draw_icon(canvas: *mut Canvas, x: u8, y: u8, icon: *const Icon);
}
extern "C" {
	#[doc = " Draw XBM bitmap"]
	#[doc = ""]
	#[doc = " @param      canvas  Canvas instance"]
	#[doc = " @param      x       x coordinate"]
	#[doc = " @param      y       y coordinate"]
	#[doc = " @param      w       bitmap width"]
	#[doc = " @param      h       bitmap height"]
	#[doc = " @param      bitmap  pointer to XBM bitmap data"]
	pub fn canvas_draw_xbm(canvas: *mut Canvas, x: u8, y: u8, w: u8, h: u8, bitmap: *const u8);
}
extern "C" {
	#[doc = " Draw dot at x,y"]
	#[doc = ""]
	#[doc = " @param      canvas  Canvas instance"]
	#[doc = " @param      x       x coordinate"]
	#[doc = " @param      y       y coordinate"]
	pub fn canvas_draw_dot(canvas: *mut Canvas, x: u8, y: u8);
}
extern "C" {
	#[doc = " Draw box of width, height at x,y"]
	#[doc = ""]
	#[doc = " @param      canvas  Canvas instance"]
	#[doc = " @param      x       x coordinate"]
	#[doc = " @param      y       y coordinate"]
	#[doc = " @param      width   box width"]
	#[doc = " @param      height  box height"]
	pub fn canvas_draw_box(canvas: *mut Canvas, x: u8, y: u8, width: u8, height: u8);
}
extern "C" {
	#[doc = " Draw frame of width, height at x,y"]
	#[doc = ""]
	#[doc = " @param      canvas  Canvas instance"]
	#[doc = " @param      x       x coordinate"]
	#[doc = " @param      y       y coordinate"]
	#[doc = " @param      width   frame width"]
	#[doc = " @param      height  frame height"]
	pub fn canvas_draw_frame(canvas: *mut Canvas, x: u8, y: u8, width: u8, height: u8);
}
extern "C" {
	#[doc = " Draw line from x1,y1 to x2,y2"]
	#[doc = ""]
	#[doc = " @param      canvas  Canvas instance"]
	#[doc = " @param      x1      x1 coordinate"]
	#[doc = " @param      y1      y1 coordinate"]
	#[doc = " @param      x2      x2 coordinate"]
	#[doc = " @param      y2      y2 coordinate"]
	pub fn canvas_draw_line(canvas: *mut Canvas, x1: u8, y1: u8, x2: u8, y2: u8);
}
extern "C" {
	#[doc = " Draw circle at x,y with radius r"]
	#[doc = ""]
	#[doc = " @param      canvas  Canvas instance"]
	#[doc = " @param      x       x coordinate"]
	#[doc = " @param      y       y coordinate"]
	#[doc = " @param      r       radius"]
	pub fn canvas_draw_circle(canvas: *mut Canvas, x: u8, y: u8, r: u8);
}
extern "C" {
	#[doc = " Draw disc at x,y with radius r"]
	#[doc = ""]
	#[doc = " @param      canvas  Canvas instance"]
	#[doc = " @param      x       x coordinate"]
	#[doc = " @param      y       y coordinate"]
	#[doc = " @param      r       radius"]
	pub fn canvas_draw_disc(canvas: *mut Canvas, x: u8, y: u8, r: u8);
}
extern "C" {
	#[doc = " Draw triangle with given base and height lengths and their intersection coordinate"]
	#[doc = ""]
	#[doc = " @param       canvas  Canvas instance"]
	#[doc = " @param       x       x coordinate of base and height intersection"]
	#[doc = " @param       y       y coordinate of base and height intersection"]
	#[doc = " @param       base    length of triangle side"]
	#[doc = " @param       height  length of triangle height"]
	#[doc = " @param       dir     CanvasDirection triangle orientation"]
	pub fn canvas_draw_triangle(canvas: *mut Canvas, x: u8, y: u8, base: u8, height: u8, dir: CanvasDirection);
}
extern "C" {
	#[doc = " Draw glyph"]
	#[doc = ""]
	#[doc = " @param      canvas  Canvas instance"]
	#[doc = " @param      x       x coordinate"]
	#[doc = " @param      y       y coordinate"]
	#[doc = " @param      ch      character"]
	pub fn canvas_draw_glyph(canvas: *mut Canvas, x: u8, y: u8, ch: u16);
}
extern "C" {
	#[doc = " Set transparency mode"]
	#[doc = ""]
	#[doc = " @param      canvas  Canvas instance"]
	#[doc = " @param      alpha   transparency mode"]
	pub fn canvas_set_bitmap_mode(canvas: *mut Canvas, alpha: bool);
}
extern "C" {
	#[doc = " Draw rounded-corner frame of width, height at x,y, with round value radius"]
	#[doc = ""]
	#[doc = " @param      canvas  Canvas instance"]
	#[doc = " @param      x       x coordinate"]
	#[doc = " @param      y       y coordinate"]
	#[doc = " @param      width   frame width"]
	#[doc = " @param      height  frame height"]
	#[doc = " @param      radius  frame corner radius"]
	pub fn canvas_draw_rframe(canvas: *mut Canvas, x: u8, y: u8, width: u8, height: u8, radius: u8);
}
extern "C" {
	#[doc = " Draw rounded-corner box of width, height at x,y, with round value raduis"]
	#[doc = ""]
	#[doc = " @param      canvas  Canvas instance"]
	#[doc = " @param      x       x coordinate"]
	#[doc = " @param      y       y coordinate"]
	#[doc = " @param      width   box width"]
	#[doc = " @param      height  box height"]
	#[doc = " @param      radius  box corner radius"]
	pub fn canvas_draw_rbox(canvas: *mut Canvas, x: u8, y: u8, width: u8, height: u8, radius: u8);
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum InputKey {
	InputKeyUp = 0,
	InputKeyDown = 1,
	InputKeyRight = 2,
	InputKeyLeft = 3,
	InputKeyOk = 4,
	InputKeyBack = 5,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum Light {
	LightRed = 1,
	LightGreen = 2,
	LightBlue = 4,
	LightBacklight = 8,
}
#[repr(C)]
pub struct InputPin {
	pub gpio: *const GpioPin,
	pub key: InputKey,
	pub inverted: bool,
	pub name: *const core::ffi::c_char,
}
#[test]
fn bindgen_test_layout_InputPin() {
	assert_eq!(
	           ::core::mem::size_of::<InputPin>(),
	           16usize,
	           concat!("Size of: ", stringify!(InputPin))
	);
	assert_eq!(
	           ::core::mem::align_of::<InputPin>(),
	           4usize,
	           concat!("Alignment of ", stringify!(InputPin))
	);
	fn test_field_gpio() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<InputPin>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).gpio) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(InputPin), "::", stringify!(gpio))
		);
	}
	test_field_gpio();
	fn test_field_key() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<InputPin>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).key) as usize - ptr as usize
		           },
		           4usize,
		           concat!("Offset of field: ", stringify!(InputPin), "::", stringify!(key))
		);
	}
	test_field_key();
	fn test_field_inverted() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<InputPin>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).inverted) as usize - ptr as usize
		           },
		           8usize,
		           concat!("Offset of field: ", stringify!(InputPin), "::", stringify!(inverted))
		);
	}
	test_field_inverted();
	fn test_field_name() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<InputPin>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).name) as usize - ptr as usize
		           },
		           12usize,
		           concat!("Offset of field: ", stringify!(InputPin), "::", stringify!(name))
		);
	}
	test_field_name();
}
extern "C" {
	pub static mut input_pins: [InputPin; 0usize];
}
extern "C" {
	pub static input_pins_count: usize;
}
extern "C" {
	pub static vibro_gpio: GpioPin;
}
extern "C" {
	pub static ibutton_gpio: GpioPin;
}
extern "C" {
	pub static gpio_cc1101_g0: GpioPin;
}
extern "C" {
	pub static gpio_rf_sw_0: GpioPin;
}
extern "C" {
	pub static gpio_subghz_cs: GpioPin;
}
extern "C" {
	pub static gpio_display_cs: GpioPin;
}
extern "C" {
	pub static gpio_display_rst_n: GpioPin;
}
extern "C" {
	pub static gpio_display_di: GpioPin;
}
extern "C" {
	pub static gpio_sdcard_cs: GpioPin;
}
extern "C" {
	pub static gpio_sdcard_cd: GpioPin;
}
extern "C" {
	pub static gpio_nfc_cs: GpioPin;
}
extern "C" {
	pub static gpio_button_up: GpioPin;
}
extern "C" {
	pub static gpio_button_down: GpioPin;
}
extern "C" {
	pub static gpio_button_right: GpioPin;
}
extern "C" {
	pub static gpio_button_left: GpioPin;
}
extern "C" {
	pub static gpio_button_ok: GpioPin;
}
extern "C" {
	pub static gpio_button_back: GpioPin;
}
extern "C" {
	pub static gpio_spi_d_miso: GpioPin;
}
extern "C" {
	pub static gpio_spi_d_mosi: GpioPin;
}
extern "C" {
	pub static gpio_spi_d_sck: GpioPin;
}
extern "C" {
	pub static gpio_spi_r_miso: GpioPin;
}
extern "C" {
	pub static gpio_spi_r_mosi: GpioPin;
}
extern "C" {
	pub static gpio_spi_r_sck: GpioPin;
}
extern "C" {
	pub static gpio_ext_pc0: GpioPin;
}
extern "C" {
	pub static gpio_ext_pc1: GpioPin;
}
extern "C" {
	pub static gpio_ext_pc3: GpioPin;
}
extern "C" {
	pub static gpio_ext_pb2: GpioPin;
}
extern "C" {
	pub static gpio_ext_pb3: GpioPin;
}
extern "C" {
	pub static gpio_ext_pa4: GpioPin;
}
extern "C" {
	pub static gpio_ext_pa6: GpioPin;
}
extern "C" {
	pub static gpio_ext_pa7: GpioPin;
}
extern "C" {
	pub static gpio_nfc_irq_rfid_pull: GpioPin;
}
extern "C" {
	pub static gpio_rfid_carrier_out: GpioPin;
}
extern "C" {
	pub static gpio_rfid_data_in: GpioPin;
}
extern "C" {
	pub static gpio_rfid_carrier: GpioPin;
}
extern "C" {
	pub static gpio_infrared_rx: GpioPin;
}
extern "C" {
	pub static gpio_infrared_tx: GpioPin;
}
extern "C" {
	pub static gpio_usart_tx: GpioPin;
}
extern "C" {
	pub static gpio_usart_rx: GpioPin;
}
extern "C" {
	pub static gpio_i2c_power_sda: GpioPin;
}
extern "C" {
	pub static gpio_i2c_power_scl: GpioPin;
}
extern "C" {
	pub static gpio_speaker: GpioPin;
}
extern "C" {
	pub static periph_power: GpioPin;
}
extern "C" {
	pub static gpio_usb_dm: GpioPin;
}
extern "C" {
	pub static gpio_usb_dp: GpioPin;
}
extern "C" {
	pub fn furi_hal_resources_init_early();
}
extern "C" {
	pub fn furi_hal_resources_deinit_early();
}
extern "C" {
	pub fn furi_hal_resources_init();
}
#[repr(u32)]
#[non_exhaustive]
#[doc = " Input Types"]
#[doc = " Some of them are physical events and some logical"]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum InputType {
	#[doc = "< Press event, emitted after debounce"]
	InputTypePress = 0,
	#[doc = "< Release event, emitted after debounce"]
	InputTypeRelease = 1,
	#[doc = "< Short event, emitted after InputTypeRelease done withing INPUT_LONG_PRESS interval"]
	InputTypeShort = 2,
	#[doc = "< Long event, emmited after INPUT_LONG_PRESS interval, asynchronouse to InputTypeRelease"]
	InputTypeLong = 3,
	#[doc = "< Repeat event, emmited with INPUT_REPEATE_PRESS period after InputTypeLong event"]
	InputTypeRepeat = 4,
}
#[doc = " Input Event, dispatches with FuriPubSub"]
#[repr(C)]
pub struct InputEvent {
	pub sequence: u32,
	pub key: InputKey,
	pub type_: InputType,
}
#[test]
fn bindgen_test_layout_InputEvent() {
	assert_eq!(
	           ::core::mem::size_of::<InputEvent>(),
	           12usize,
	           concat!("Size of: ", stringify!(InputEvent))
	);
	assert_eq!(
	           ::core::mem::align_of::<InputEvent>(),
	           4usize,
	           concat!("Alignment of ", stringify!(InputEvent))
	);
	fn test_field_sequence() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<InputEvent>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).sequence) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(InputEvent), "::", stringify!(sequence))
		);
	}
	test_field_sequence();
	fn test_field_key() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<InputEvent>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).key) as usize - ptr as usize
		           },
		           4usize,
		           concat!("Offset of field: ", stringify!(InputEvent), "::", stringify!(key))
		);
	}
	test_field_key();
	fn test_field_type() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<InputEvent>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize
		           },
		           8usize,
		           concat!("Offset of field: ", stringify!(InputEvent), "::", stringify!(type_))
		);
	}
	test_field_type();
}
extern "C" {
	#[doc = " Get human readable input key name"]
	#[doc = " @param key - InputKey"]
	#[doc = " @return string"]
	pub fn input_get_key_name(key: InputKey) -> *const core::ffi::c_char;
}
extern "C" {
	#[doc = " Get human readable input type name"]
	#[doc = " @param type - InputType"]
	#[doc = " @return string"]
	pub fn input_get_type_name(type_: InputType) -> *const core::ffi::c_char;
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum ViewOrientation {
	ViewOrientationHorizontal = 0,
	ViewOrientationVertical = 1,
}
#[repr(C)]
pub struct View {
	_unused: [u8; 0],
}
#[doc = " View Draw callback"]
#[doc = " @param      canvas,      pointer to canvas"]
#[doc = " @param      view_model,  pointer to context"]
#[doc = " @warning    called from GUI thread"]
pub type ViewDrawCallback = ::core::option::Option<unsafe extern "C" fn(canvas: *mut Canvas, model: *mut core::ffi::c_void)>;
#[doc = " View Input callback"]
#[doc = " @param      event,    pointer to input event data"]
#[doc = " @param      context,  pointer to context"]
#[doc = " @return     true if event handled, false if event ignored"]
#[doc = " @warning    called from GUI thread"]
pub type ViewInputCallback =
	::core::option::Option<unsafe extern "C" fn(event: *mut InputEvent, context: *mut core::ffi::c_void) -> bool>;
#[doc = " View Custom callback"]
#[doc = " @param      event,    number of custom event"]
#[doc = " @param      context,  pointer to context"]
#[doc = " @return     true if event handled, false if event ignored"]
pub type ViewCustomCallback = ::core::option::Option<unsafe extern "C" fn(event: u32, context: *mut core::ffi::c_void) -> bool>;
#[doc = " View navigation callback"]
#[doc = " @param      context,  pointer to context"]
#[doc = " @return     next view id"]
#[doc = " @warning    called from GUI thread"]
pub type ViewNavigationCallback = ::core::option::Option<unsafe extern "C" fn(context: *mut core::ffi::c_void) -> u32>;
#[doc = " View callback"]
#[doc = " @param      context,  pointer to context"]
#[doc = " @warning    called from GUI thread"]
pub type ViewCallback = ::core::option::Option<unsafe extern "C" fn(context: *mut core::ffi::c_void)>;
#[doc = " View Update Callback Called upon model change, need to be propagated to GUI"]
#[doc = " throw ViewPort update"]
#[doc = " @param      view,     pointer to view"]
#[doc = " @param      context,  pointer to context"]
#[doc = " @warning    called from GUI thread"]
pub type ViewUpdateCallback = ::core::option::Option<unsafe extern "C" fn(view: *mut View, context: *mut core::ffi::c_void)>;
#[repr(u32)]
#[non_exhaustive]
#[doc = " View model types"]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum ViewModelType {
	#[doc = " Model is not allocated"]
	ViewModelTypeNone = 0,
	#[doc = " Model consist of atomic types and/or partial update is not critical for rendering."]
	#[doc = " Lock free."]
	ViewModelTypeLockFree = 1,
	#[doc = " Model access is guarded with mutex."]
	#[doc = " Locking gui thread."]
	ViewModelTypeLocking = 2,
}
extern "C" {
	#[doc = " Allocate and init View"]
	#[doc = " @return View instance"]
	pub fn view_alloc() -> *mut View;
}
extern "C" {
	#[doc = " Free View"]
	#[doc = ""]
	#[doc = " @param      view  instance"]
	pub fn view_free(view: *mut View);
}
extern "C" {
	#[doc = " Tie IconAnimation with View"]
	#[doc = ""]
	#[doc = " @param      view            View instance"]
	#[doc = " @param      icon_animation  IconAnimation instance"]
	pub fn view_tie_icon_animation(view: *mut View, icon_animation: *mut IconAnimation);
}
extern "C" {
	#[doc = " Set View Draw callback"]
	#[doc = ""]
	#[doc = " @param      view      View instance"]
	#[doc = " @param      callback  draw callback"]
	pub fn view_set_draw_callback(view: *mut View, callback: ViewDrawCallback);
}
extern "C" {
	#[doc = " Set View Input callback"]
	#[doc = ""]
	#[doc = " @param      view      View instance"]
	#[doc = " @param      callback  input callback"]
	pub fn view_set_input_callback(view: *mut View, callback: ViewInputCallback);
}
extern "C" {
	#[doc = " Set View Custom callback"]
	#[doc = ""]
	#[doc = " @param      view      View instance"]
	#[doc = " @param      callback  input callback"]
	pub fn view_set_custom_callback(view: *mut View, callback: ViewCustomCallback);
}
extern "C" {
	#[doc = " Set Navigation Previous callback"]
	#[doc = ""]
	#[doc = " @param      view      View instance"]
	#[doc = " @param      callback  input callback"]
	pub fn view_set_previous_callback(view: *mut View, callback: ViewNavigationCallback);
}
extern "C" {
	#[doc = " Set Enter callback"]
	#[doc = ""]
	#[doc = " @param      view      View instance"]
	#[doc = " @param      callback  callback"]
	pub fn view_set_enter_callback(view: *mut View, callback: ViewCallback);
}
extern "C" {
	#[doc = " Set Exit callback"]
	#[doc = ""]
	#[doc = " @param      view      View instance"]
	#[doc = " @param      callback  callback"]
	pub fn view_set_exit_callback(view: *mut View, callback: ViewCallback);
}
extern "C" {
	#[doc = " Set Update callback"]
	#[doc = ""]
	#[doc = " @param      view      View instance"]
	#[doc = " @param      callback  callback"]
	pub fn view_set_update_callback(view: *mut View, callback: ViewUpdateCallback);
}
extern "C" {
	#[doc = " Set View Draw callback"]
	#[doc = ""]
	#[doc = " @param      view     View instance"]
	#[doc = " @param      context  context for callbacks"]
	pub fn view_set_update_callback_context(view: *mut View, context: *mut core::ffi::c_void);
}
extern "C" {
	#[doc = " Set View Draw callback"]
	#[doc = ""]
	#[doc = " @param      view     View instance"]
	#[doc = " @param      context  context for callbacks"]
	pub fn view_set_context(view: *mut View, context: *mut core::ffi::c_void);
}
extern "C" {
	#[doc = " Set View Orientation"]
	#[doc = ""]
	#[doc = " @param      view         View instance"]
	#[doc = " @param      orientation  either vertical or horizontal"]
	pub fn view_set_orientation(view: *mut View, orientation: ViewOrientation);
}
extern "C" {
	#[doc = " Allocate view model."]
	#[doc = ""]
	#[doc = " @param      view  View instance"]
	#[doc = " @param      type  View Model Type"]
	#[doc = " @param      size  size"]
	pub fn view_allocate_model(view: *mut View, type_: ViewModelType, size: usize);
}
extern "C" {
	#[doc = " Free view model data memory."]
	#[doc = ""]
	#[doc = " @param      view  View instance"]
	pub fn view_free_model(view: *mut View);
}
extern "C" {
	#[doc = " Get view model data"]
	#[doc = ""]
	#[doc = " @param      view  View instance"]
	#[doc = ""]
	#[doc = " @return     pointer to model data"]
	#[doc = " @warning    Don't forget to commit model changes"]
	pub fn view_get_model(view: *mut View) -> *mut core::ffi::c_void;
}
extern "C" {
	#[doc = " Commit view model"]
	#[doc = ""]
	#[doc = " @param      view    View instance"]
	#[doc = " @param      update  true if you want to emit view update, false otherwise"]
	pub fn view_commit_model(view: *mut View, update: bool);
}
#[repr(C)]
pub struct FileBrowser {
	_unused: [u8; 0],
}
pub type FileBrowserCallback = ::core::option::Option<unsafe extern "C" fn(context: *mut core::ffi::c_void)>;
pub type FileBrowserLoadItemCallback = ::core::option::Option<unsafe extern "C" fn(path: *mut string_t,
                                                                                   context: *mut core::ffi::c_void,
                                                                                   icon: *mut *mut u8,
                                                                                   item_name: *mut string_t)
                                                                                   -> bool>;
extern "C" {
	pub fn file_browser_alloc(result_path: string_ptr) -> *mut FileBrowser;
}
extern "C" {
	pub fn file_browser_free(browser: *mut FileBrowser);
}
extern "C" {
	pub fn file_browser_get_view(browser: *mut FileBrowser) -> *mut View;
}
extern "C" {
	pub fn file_browser_configure(browser: *mut FileBrowser,
	                              extension: *const core::ffi::c_char,
	                              skip_assets: bool,
	                              file_icon: *const Icon,
	                              hide_ext: bool);
}
extern "C" {
	pub fn file_browser_start(browser: *mut FileBrowser, path: *mut string_t);
}
extern "C" {
	pub fn file_browser_stop(browser: *mut FileBrowser);
}
extern "C" {
	pub fn file_browser_set_callback(browser: *mut FileBrowser, callback: FileBrowserCallback, context: *mut core::ffi::c_void);
}
extern "C" {
	pub fn file_browser_set_item_callback(browser: *mut FileBrowser,
	                                      callback: FileBrowserLoadItemCallback,
	                                      context: *mut core::ffi::c_void);
}
#[repr(C)]
pub struct DialogsApp {
	_unused: [u8; 0],
}
#[doc = " File browser dialog extra options"]
#[doc = " @param extension file extension to be offered for selection"]
#[doc = " @param skip_assets true - do not show assets folders"]
#[doc = " @param icon file icon pointer, NULL for default icon"]
#[doc = " @param hide_ext true - hide extensions for files"]
#[doc = " @param item_loader_callback callback function for providing custom icon & entry name"]
#[doc = " @param hide_ext callback context"]
#[repr(C)]
pub struct DialogsFileBrowserOptions {
	pub extension: *const core::ffi::c_char,
	pub skip_assets: bool,
	pub icon: *const Icon,
	pub hide_ext: bool,
	pub item_loader_callback: FileBrowserLoadItemCallback,
	pub item_loader_context: *mut core::ffi::c_void,
}
#[test]
fn bindgen_test_layout_DialogsFileBrowserOptions() {
	assert_eq!(
	           ::core::mem::size_of::<DialogsFileBrowserOptions>(),
	           24usize,
	           concat!("Size of: ", stringify!(DialogsFileBrowserOptions))
	);
	assert_eq!(
	           ::core::mem::align_of::<DialogsFileBrowserOptions>(),
	           4usize,
	           concat!("Alignment of ", stringify!(DialogsFileBrowserOptions))
	);
	fn test_field_extension() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<DialogsFileBrowserOptions>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).extension) as usize - ptr as usize
		           },
		           0usize,
		           concat!(
			"Offset of field: ",
			stringify!(DialogsFileBrowserOptions),
			"::",
			stringify!(extension)
		)
		);
	}
	test_field_extension();
	fn test_field_skip_assets() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<DialogsFileBrowserOptions>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).skip_assets) as usize - ptr as usize
		           },
		           4usize,
		           concat!(
			"Offset of field: ",
			stringify!(DialogsFileBrowserOptions),
			"::",
			stringify!(skip_assets)
		)
		);
	}
	test_field_skip_assets();
	fn test_field_icon() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<DialogsFileBrowserOptions>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).icon) as usize - ptr as usize
		           },
		           8usize,
		           concat!(
			"Offset of field: ",
			stringify!(DialogsFileBrowserOptions),
			"::",
			stringify!(icon)
		)
		);
	}
	test_field_icon();
	fn test_field_hide_ext() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<DialogsFileBrowserOptions>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).hide_ext) as usize - ptr as usize
		           },
		           12usize,
		           concat!(
			"Offset of field: ",
			stringify!(DialogsFileBrowserOptions),
			"::",
			stringify!(hide_ext)
		)
		);
	}
	test_field_hide_ext();
	fn test_field_item_loader_callback() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<DialogsFileBrowserOptions>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).item_loader_callback) as usize - ptr as usize
		           },
		           16usize,
		           concat!(
			"Offset of field: ",
			stringify!(DialogsFileBrowserOptions),
			"::",
			stringify!(item_loader_callback)
		)
		);
	}
	test_field_item_loader_callback();
	fn test_field_item_loader_context() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<DialogsFileBrowserOptions>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).item_loader_context) as usize - ptr as usize
		           },
		           20usize,
		           concat!(
			"Offset of field: ",
			stringify!(DialogsFileBrowserOptions),
			"::",
			stringify!(item_loader_context)
		)
		);
	}
	test_field_item_loader_context();
}
extern "C" {
	#[doc = " Initialize file browser dialog options"]
	#[doc = " and set default values"]
	#[doc = " @param options pointer to options structure"]
	#[doc = " @param extension file extension to filter"]
	#[doc = " @param icon file icon pointer, NULL for default icon"]
	pub fn dialog_file_browser_set_basic_options(options: *mut DialogsFileBrowserOptions,
	                                             extension: *const core::ffi::c_char,
	                                             icon: *const Icon);
}
extern "C" {
	#[doc = " Shows and processes the file browser dialog"]
	#[doc = " @param context api pointer"]
	#[doc = " @param result_path selected file path string pointer"]
	#[doc = " @param path preselected file path string pointer"]
	#[doc = " @param options file browser dialog extra options, may be null"]
	#[doc = " @return bool whether a file was selected"]
	pub fn dialog_file_browser_show(context: *mut DialogsApp,
	                                result_path: string_ptr,
	                                path: string_ptr,
	                                options: *const DialogsFileBrowserOptions)
	                                -> bool;
}
#[repr(u32)]
#[non_exhaustive]
#[doc = " Message result type"]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum DialogMessageButton {
	DialogMessageButtonBack = 0,
	DialogMessageButtonLeft = 1,
	DialogMessageButtonCenter = 2,
	DialogMessageButtonRight = 3,
}
#[repr(C)]
pub struct DialogMessage {
	_unused: [u8; 0],
}
extern "C" {
	#[doc = " Allocate and fill message"]
	#[doc = " @return DialogMessage*"]
	pub fn dialog_message_alloc() -> *mut DialogMessage;
}
extern "C" {
	#[doc = " Free message struct"]
	#[doc = " @param message message pointer"]
	pub fn dialog_message_free(message: *mut DialogMessage);
}
extern "C" {
	#[doc = " Set message text"]
	#[doc = " @param message message pointer"]
	#[doc = " @param text text, can be NULL if you don't want to display the text"]
	#[doc = " @param x x position"]
	#[doc = " @param y y position"]
	#[doc = " @param horizontal horizontal alignment"]
	#[doc = " @param vertical vertical alignment"]
	pub fn dialog_message_set_text(message: *mut DialogMessage,
	                               text: *const core::ffi::c_char,
	                               x: u8,
	                               y: u8,
	                               horizontal: Align,
	                               vertical: Align);
}
extern "C" {
	#[doc = " Set message header"]
	#[doc = " @param message message pointer"]
	#[doc = " @param text text, can be NULL if you don't want to display the header"]
	#[doc = " @param x x position"]
	#[doc = " @param y y position"]
	#[doc = " @param horizontal horizontal alignment"]
	#[doc = " @param vertical vertical alignment"]
	pub fn dialog_message_set_header(message: *mut DialogMessage,
	                                 text: *const core::ffi::c_char,
	                                 x: u8,
	                                 y: u8,
	                                 horizontal: Align,
	                                 vertical: Align);
}
extern "C" {
	#[doc = " Set message icon"]
	#[doc = " @param message message pointer"]
	#[doc = " @param icon icon pointer, can be NULL if you don't want to display the icon"]
	#[doc = " @param x x position"]
	#[doc = " @param y y position"]
	pub fn dialog_message_set_icon(message: *mut DialogMessage, icon: *const Icon, x: u8, y: u8);
}
extern "C" {
	#[doc = " Set message buttons text, button text can be NULL if you don't want to display and process some buttons"]
	#[doc = " @param message message pointer"]
	#[doc = " @param left left button text, can be NULL if you don't want to display the left button"]
	#[doc = " @param center center button text, can be NULL if you don't want to display the center button"]
	#[doc = " @param right right button text, can be NULL if you don't want to display the right button"]
	pub fn dialog_message_set_buttons(message: *mut DialogMessage,
	                                  left: *const core::ffi::c_char,
	                                  center: *const core::ffi::c_char,
	                                  right: *const core::ffi::c_char);
}
extern "C" {
	#[doc = " Show message from filled struct"]
	#[doc = " @param context api pointer"]
	#[doc = " @param message message struct pointer to be shown"]
	#[doc = " @return DialogMessageButton type"]
	pub fn dialog_message_show(context: *mut DialogsApp, message: *const DialogMessage) -> DialogMessageButton;
}
extern "C" {
	#[doc = " Show SD error message (with question sign)"]
	#[doc = " @param context"]
	#[doc = " @param error_text"]
	pub fn dialog_message_show_storage_error(context: *mut DialogsApp, error_text: *const core::ffi::c_char);
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum DolphinApp {
	DolphinAppSubGhz = 0,
	DolphinAppRfid = 1,
	DolphinAppNfc = 2,
	DolphinAppIr = 3,
	DolphinAppIbutton = 4,
	DolphinAppBadusb = 5,
	DolphinAppU2f = 6,
	DolphinAppMAX = 7,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum DolphinDeed {
	DolphinDeedSubGhzReceiverInfo = 0,
	DolphinDeedSubGhzSave = 1,
	DolphinDeedSubGhzRawRec = 2,
	DolphinDeedSubGhzAddManually = 3,
	DolphinDeedSubGhzSend = 4,
	DolphinDeedSubGhzFrequencyAnalyzer = 5,
	DolphinDeedRfidRead = 6,
	DolphinDeedRfidReadSuccess = 7,
	DolphinDeedRfidSave = 8,
	DolphinDeedRfidEmulate = 9,
	DolphinDeedRfidAdd = 10,
	DolphinDeedNfcRead = 11,
	DolphinDeedNfcReadSuccess = 12,
	DolphinDeedNfcSave = 13,
	DolphinDeedNfcEmulate = 14,
	DolphinDeedNfcAdd = 15,
	DolphinDeedIrSend = 16,
	DolphinDeedIrLearnSuccess = 17,
	DolphinDeedIrSave = 18,
	DolphinDeedIrBruteForce = 19,
	DolphinDeedIbuttonRead = 20,
	DolphinDeedIbuttonReadSuccess = 21,
	DolphinDeedIbuttonSave = 22,
	DolphinDeedIbuttonEmulate = 23,
	DolphinDeedIbuttonAdd = 24,
	DolphinDeedBadUsbPlayScript = 25,
	DolphinDeedU2fAuthorized = 26,
	DolphinDeedMAX = 27,
	DolphinDeedTestLeft = 28,
	DolphinDeedTestRight = 29,
}
#[repr(C)]
pub struct DolphinDeedWeight {
	pub icounter: u8,
	pub app: DolphinApp,
}
#[test]
fn bindgen_test_layout_DolphinDeedWeight() {
	assert_eq!(
	           ::core::mem::size_of::<DolphinDeedWeight>(),
	           8usize,
	           concat!("Size of: ", stringify!(DolphinDeedWeight))
	);
	assert_eq!(
	           ::core::mem::align_of::<DolphinDeedWeight>(),
	           4usize,
	           concat!("Alignment of ", stringify!(DolphinDeedWeight))
	);
	fn test_field_icounter() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<DolphinDeedWeight>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).icounter) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(DolphinDeedWeight), "::", stringify!(icounter))
		);
	}
	test_field_icounter();
	fn test_field_app() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<DolphinDeedWeight>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).app) as usize - ptr as usize
		           },
		           4usize,
		           concat!("Offset of field: ", stringify!(DolphinDeedWeight), "::", stringify!(app))
		);
	}
	test_field_app();
}
#[repr(C)]
pub struct DolphinDeedLimits {
	pub app: DolphinApp,
	pub icounter_limit: u8,
}
#[test]
fn bindgen_test_layout_DolphinDeedLimits() {
	assert_eq!(
	           ::core::mem::size_of::<DolphinDeedLimits>(),
	           8usize,
	           concat!("Size of: ", stringify!(DolphinDeedLimits))
	);
	assert_eq!(
	           ::core::mem::align_of::<DolphinDeedLimits>(),
	           4usize,
	           concat!("Alignment of ", stringify!(DolphinDeedLimits))
	);
	fn test_field_app() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<DolphinDeedLimits>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).app) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(DolphinDeedLimits), "::", stringify!(app))
		);
	}
	test_field_app();
	fn test_field_icounter_limit() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<DolphinDeedLimits>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).icounter_limit) as usize - ptr as usize
		           },
		           4usize,
		           concat!(
			"Offset of field: ",
			stringify!(DolphinDeedLimits),
			"::",
			stringify!(icounter_limit)
		)
		);
	}
	test_field_icounter_limit();
}
extern "C" {
	pub fn dolphin_deed_get_app(deed: DolphinDeed) -> DolphinApp;
}
extern "C" {
	pub fn dolphin_deed_get_app_limit(app: DolphinApp) -> u8;
}
extern "C" {
	pub fn dolphin_deed_get_weight(deed: DolphinDeed) -> u8;
}
#[repr(C)]
pub struct Dolphin {
	_unused: [u8; 0],
}
#[repr(C)]
pub struct DolphinStats {
	pub icounter: u32,
	pub butthurt: u32,
	pub timestamp: u64,
	pub level: u8,
	pub level_up_is_pending: bool,
}
#[test]
fn bindgen_test_layout_DolphinStats() {
	assert_eq!(
	           ::core::mem::size_of::<DolphinStats>(),
	           24usize,
	           concat!("Size of: ", stringify!(DolphinStats))
	);
	assert_eq!(
	           ::core::mem::align_of::<DolphinStats>(),
	           8usize,
	           concat!("Alignment of ", stringify!(DolphinStats))
	);
	fn test_field_icounter() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<DolphinStats>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).icounter) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(DolphinStats), "::", stringify!(icounter))
		);
	}
	test_field_icounter();
	fn test_field_butthurt() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<DolphinStats>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).butthurt) as usize - ptr as usize
		           },
		           4usize,
		           concat!("Offset of field: ", stringify!(DolphinStats), "::", stringify!(butthurt))
		);
	}
	test_field_butthurt();
	fn test_field_timestamp() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<DolphinStats>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).timestamp) as usize - ptr as usize
		           },
		           8usize,
		           concat!("Offset of field: ", stringify!(DolphinStats), "::", stringify!(timestamp))
		);
	}
	test_field_timestamp();
	fn test_field_level() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<DolphinStats>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).level) as usize - ptr as usize
		           },
		           16usize,
		           concat!("Offset of field: ", stringify!(DolphinStats), "::", stringify!(level))
		);
	}
	test_field_level();
	fn test_field_level_up_is_pending() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<DolphinStats>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).level_up_is_pending) as usize - ptr as usize
		           },
		           17usize,
		           concat!(
			"Offset of field: ",
			stringify!(DolphinStats),
			"::",
			stringify!(level_up_is_pending)
		)
		);
	}
	test_field_level_up_is_pending();
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum DolphinPubsubEvent {
	DolphinPubsubEventUpdate = 0,
}
extern "C" {
	#[doc = " Deed complete notification. Call it on deed completion."]
	#[doc = " See dolphin_deed.h for available deeds. In futures it will become part of assets."]
	#[doc = " Thread safe, async"]
	pub fn dolphin_deed(dolphin: *mut Dolphin, deed: DolphinDeed);
}
extern "C" {
	#[doc = " Retrieve dolphin stats"]
	#[doc = " Thread safe, blocking"]
	pub fn dolphin_stats(dolphin: *mut Dolphin) -> DolphinStats;
}
extern "C" {
	#[doc = " Flush dolphin queue and save state"]
	#[doc = " Thread safe, blocking"]
	pub fn dolphin_flush(dolphin: *mut Dolphin);
}
extern "C" {
	pub fn dolphin_upgrade_level(dolphin: *mut Dolphin);
}
extern "C" {
	pub fn dolphin_get_pubsub(dolphin: *mut Dolphin) -> *mut FuriPubSub;
}
extern "C" {
	#[doc = " Draw progress bar."]
	#[doc = ""]
	#[doc = " @param   canvas      Canvas instance"]
	#[doc = " @param   x           progress bar position on X axis"]
	#[doc = " @param   y           progress bar position on Y axis"]
	#[doc = " @param   width       progress bar width"]
	#[doc = " @param   progress    progress (0.0 - 1.0)"]
	pub fn elements_progress_bar(canvas: *mut Canvas, x: u8, y: u8, width: u8, progress: core::ffi::c_float);
}
extern "C" {
	#[doc = " Draw scrollbar on canvas at specific position."]
	#[doc = ""]
	#[doc = " @param   canvas  Canvas instance"]
	#[doc = " @param   x       scrollbar position on X axis"]
	#[doc = " @param   y       scrollbar position on Y axis"]
	#[doc = " @param   height  scrollbar height"]
	#[doc = " @param   pos     current element"]
	#[doc = " @param   total   total elements"]
	pub fn elements_scrollbar_pos(canvas: *mut Canvas, x: u8, y: u8, height: u8, pos: u16, total: u16);
}
extern "C" {
	#[doc = " Draw scrollbar on canvas."]
	#[doc = " @note    width 3px, height equal to canvas height"]
	#[doc = ""]
	#[doc = " @param   canvas  Canvas instance"]
	#[doc = " @param   pos     current element of total elements"]
	#[doc = " @param   total   total elements"]
	pub fn elements_scrollbar(canvas: *mut Canvas, pos: u16, total: u16);
}
extern "C" {
	#[doc = " Draw rounded frame"]
	#[doc = ""]
	#[doc = " @param   canvas          Canvas instance"]
	#[doc = " @param   x, y            top left corner coordinates"]
	#[doc = " @param   width, height   frame width and height"]
	pub fn elements_frame(canvas: *mut Canvas, x: u8, y: u8, width: u8, height: u8);
}
extern "C" {
	#[doc = " Draw button in left corner"]
	#[doc = ""]
	#[doc = " @param   canvas  Canvas instance"]
	#[doc = " @param   str     button text"]
	pub fn elements_button_left(canvas: *mut Canvas, str_: *const core::ffi::c_char);
}
extern "C" {
	#[doc = " Draw button in right corner"]
	#[doc = ""]
	#[doc = " @param   canvas  Canvas instance"]
	#[doc = " @param   str     button text"]
	pub fn elements_button_right(canvas: *mut Canvas, str_: *const core::ffi::c_char);
}
extern "C" {
	#[doc = " Draw button in center"]
	#[doc = ""]
	#[doc = " @param   canvas  Canvas instance"]
	#[doc = " @param   str     button text"]
	pub fn elements_button_center(canvas: *mut Canvas, str_: *const core::ffi::c_char);
}
extern "C" {
	#[doc = " Draw aligned multiline text"]
	#[doc = ""]
	#[doc = " @param   canvas                  Canvas instance"]
	#[doc = " @param   x, y                    coordinates based on align param"]
	#[doc = " @param   horizontal, vertical    aligment of multiline text"]
	#[doc = " @param   text                    string (possible multiline)"]
	pub fn elements_multiline_text_aligned(canvas: *mut Canvas,
	                                       x: u8,
	                                       y: u8,
	                                       horizontal: Align,
	                                       vertical: Align,
	                                       text: *const core::ffi::c_char);
}
extern "C" {
	#[doc = " Draw multiline text"]
	#[doc = ""]
	#[doc = " @param   canvas  Canvas instance"]
	#[doc = " @param   x, y    top left corner coordinates"]
	#[doc = " @param   text    string (possible multiline)"]
	pub fn elements_multiline_text(canvas: *mut Canvas, x: u8, y: u8, text: *const core::ffi::c_char);
}
extern "C" {
	#[doc = " Draw framed multiline text"]
	#[doc = ""]
	#[doc = " @param   canvas  Canvas instance"]
	#[doc = " @param   x, y    top left corner coordinates"]
	#[doc = " @param   text    string (possible multiline)"]
	pub fn elements_multiline_text_framed(canvas: *mut Canvas, x: u8, y: u8, text: *const core::ffi::c_char);
}
extern "C" {
	#[doc = " Draw slightly rounded frame"]
	#[doc = ""]
	#[doc = " @param   canvas          Canvas instance"]
	#[doc = " @param   x, y            top left corner coordinates"]
	#[doc = " @param   width, height   size of frame"]
	pub fn elements_slightly_rounded_frame(canvas: *mut Canvas, x: u8, y: u8, width: u8, height: u8);
}
extern "C" {
	#[doc = " Draw slightly rounded box"]
	#[doc = ""]
	#[doc = " @param   canvas          Canvas instance"]
	#[doc = " @param   x, y            top left corner coordinates"]
	#[doc = " @param   width, height   size of box"]
	pub fn elements_slightly_rounded_box(canvas: *mut Canvas, x: u8, y: u8, width: u8, height: u8);
}
extern "C" {
	#[doc = " Draw bold rounded frame"]
	#[doc = ""]
	#[doc = " @param   canvas          Canvas instance"]
	#[doc = " @param   x, y            top left corner coordinates"]
	#[doc = " @param   width, height   size of frame"]
	pub fn elements_bold_rounded_frame(canvas: *mut Canvas, x: u8, y: u8, width: u8, height: u8);
}
extern "C" {
	#[doc = " Draw bubble frame for text"]
	#[doc = ""]
	#[doc = " @param   canvas  Canvas instance"]
	#[doc = " @param   x       left x coordinates"]
	#[doc = " @param   y       top y coordinate"]
	#[doc = " @param   width   bubble width"]
	#[doc = " @param   height  bubble height"]
	pub fn elements_bubble(canvas: *mut Canvas, x: u8, y: u8, width: u8, height: u8);
}
extern "C" {
	#[doc = " Draw bubble frame for text with corner"]
	#[doc = ""]
	#[doc = " @param   canvas      Canvas instance"]
	#[doc = " @param   x           left x coordinates"]
	#[doc = " @param   y           top y coordinate"]
	#[doc = " @param   width       bubble width"]
	#[doc = " @param   height      bubble height"]
	#[doc = " @param   horizontal  horizontal aligning"]
	#[doc = " @param   vertical    aligning"]
	pub fn elements_bubble_str(canvas: *mut Canvas, x: u8, y: u8, text: *const core::ffi::c_char, horizontal: Align, vertical: Align);
}
extern "C" {
	#[doc = " Trim string buffer to fit width in pixels"]
	#[doc = ""]
	#[doc = " @param   canvas  Canvas instance"]
	#[doc = " @param   string  string to trim"]
	#[doc = " @param   width   max width"]
	pub fn elements_string_fit_width(canvas: *mut Canvas, string: *mut string_t, width: u8);
}
extern "C" {
	#[doc = " Draw text box element"]
	#[doc = ""]
	#[doc = " @param       canvas          Canvas instance"]
	#[doc = " @param       x               x coordinate"]
	#[doc = " @param       y               y coordinate"]
	#[doc = " @param       width           width to fit text"]
	#[doc = " @param       height          height to fit text"]
	#[doc = " @param       horizontal      Align instance"]
	#[doc = " @param       vertical        Align instance"]
	#[doc = " @param[in]   text            Formatted text. The following formats are available:"]
	#[doc = "                              \"\\e#Bold text\\e#\" - bold font is used"]
	#[doc = "                              \"\\e*Monospaced text\\e*\" - monospaced font is used"]
	#[doc = "                              \"\\e!Inversed text\\e!\" - white text on black background"]
	#[doc = " @param      strip_to_dots    Strip text to ... if does not fit to width"]
	pub fn elements_text_box(canvas: *mut Canvas,
	                         x: u8,
	                         y: u8,
	                         width: u8,
	                         height: u8,
	                         horizontal: Align,
	                         vertical: Align,
	                         text: *const core::ffi::c_char,
	                         strip_to_dots: bool);
}
#[repr(C)]
pub struct ViewPort {
	_unused: [u8; 0],
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum ViewPortOrientation {
	ViewPortOrientationHorizontal = 0,
	ViewPortOrientationVertical = 1,
}
#[doc = " ViewPort Draw callback"]
#[doc = " @warning    called from GUI thread"]
pub type ViewPortDrawCallback = ::core::option::Option<unsafe extern "C" fn(canvas: *mut Canvas, context: *mut core::ffi::c_void)>;
#[doc = " ViewPort Input callback"]
#[doc = " @warning    called from GUI thread"]
pub type ViewPortInputCallback =
	::core::option::Option<unsafe extern "C" fn(event: *mut InputEvent, context: *mut core::ffi::c_void)>;
extern "C" {
	#[doc = " ViewPort allocator"]
	#[doc = ""]
	#[doc = " always returns view_port or stops system if not enough memory."]
	#[doc = ""]
	#[doc = " @return     ViewPort instance"]
	pub fn view_port_alloc() -> *mut ViewPort;
}
extern "C" {
	#[doc = " ViewPort deallocator"]
	#[doc = ""]
	#[doc = " Ensure that view_port was unregistered in GUI system before use."]
	#[doc = ""]
	#[doc = " @param      view_port  ViewPort instance"]
	pub fn view_port_free(view_port: *mut ViewPort);
}
extern "C" {
	#[doc = " Set view_port width."]
	#[doc = ""]
	#[doc = " Will be used to limit canvas drawing area and autolayout feature."]
	#[doc = ""]
	#[doc = " @param      view_port  ViewPort instance"]
	#[doc = " @param      width      wanted width, 0 - auto."]
	pub fn view_port_set_width(view_port: *mut ViewPort, width: u8);
}
extern "C" {
	pub fn view_port_get_width(view_port: *mut ViewPort) -> u8;
}
extern "C" {
	#[doc = " Set view_port height."]
	#[doc = ""]
	#[doc = " Will be used to limit canvas drawing area and autolayout feature."]
	#[doc = ""]
	#[doc = " @param      view_port  ViewPort instance"]
	#[doc = " @param      height     wanted height, 0 - auto."]
	pub fn view_port_set_height(view_port: *mut ViewPort, height: u8);
}
extern "C" {
	pub fn view_port_get_height(view_port: *mut ViewPort) -> u8;
}
extern "C" {
	#[doc = " Enable or disable view_port rendering."]
	#[doc = ""]
	#[doc = " @param      view_port  ViewPort instance"]
	#[doc = " @param      enabled    Indicates if enabled"]
	#[doc = " @warning    automatically dispatches update event"]
	pub fn view_port_enabled_set(view_port: *mut ViewPort, enabled: bool);
}
extern "C" {
	pub fn view_port_is_enabled(view_port: *mut ViewPort) -> bool;
}
extern "C" {
	#[doc = " ViewPort event callbacks"]
	#[doc = ""]
	#[doc = " @param      view_port  ViewPort instance"]
	#[doc = " @param      callback   appropriate callback function"]
	#[doc = " @param      context    context to pass to callback"]
	pub fn view_port_draw_callback_set(view_port: *mut ViewPort, callback: ViewPortDrawCallback, context: *mut core::ffi::c_void);
}
extern "C" {
	pub fn view_port_input_callback_set(view_port: *mut ViewPort, callback: ViewPortInputCallback, context: *mut core::ffi::c_void);
}
extern "C" {
	#[doc = " Emit update signal to GUI system."]
	#[doc = ""]
	#[doc = " Rendering will happen later after GUI system process signal."]
	#[doc = ""]
	#[doc = " @param      view_port  ViewPort instance"]
	pub fn view_port_update(view_port: *mut ViewPort);
}
extern "C" {
	#[doc = " Set ViewPort orientation."]
	#[doc = ""]
	#[doc = " @param      view_port    ViewPort instance"]
	#[doc = " @param      orientation  display orientation, horizontal or vertical."]
	pub fn view_port_set_orientation(view_port: *mut ViewPort, orientation: ViewPortOrientation);
}
extern "C" {
	pub fn view_port_get_orientation(view_port: *const ViewPort) -> ViewPortOrientation;
}
#[repr(u32)]
#[non_exhaustive]
#[doc = " Gui layers"]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum GuiLayer {
	#[doc = "< Desktop layer for internal use. Like fullscreen but with status bar"]
	GuiLayerDesktop = 0,
	#[doc = "< Window layer, status bar is shown"]
	GuiLayerWindow = 1,
	#[doc = "< Status bar left-side layer, auto-layout"]
	GuiLayerStatusBarLeft = 2,
	#[doc = "< Status bar right-side layer, auto-layout"]
	GuiLayerStatusBarRight = 3,
	#[doc = "< Fullscreen layer, no status bar"]
	GuiLayerFullscreen = 4,
	#[doc = "< Don't use or move, special value"]
	GuiLayerMAX = 5,
}
#[doc = " Gui Canvas Commit Callback"]
pub type GuiCanvasCommitCallback =
	::core::option::Option<unsafe extern "C" fn(data: *mut u8, size: usize, context: *mut core::ffi::c_void)>;
#[repr(C)]
pub struct Gui {
	_unused: [u8; 0],
}
extern "C" {
	#[doc = " Add view_port to view_port tree"]
	#[doc = ""]
	#[doc = " @remark     thread safe"]
	#[doc = ""]
	#[doc = " @param      gui        Gui instance"]
	#[doc = " @param      view_port  ViewPort instance"]
	#[doc = " @param[in]  layer      GuiLayer where to place view_port"]
	pub fn gui_add_view_port(gui: *mut Gui, view_port: *mut ViewPort, layer: GuiLayer);
}
extern "C" {
	#[doc = " Remove view_port from rendering tree"]
	#[doc = ""]
	#[doc = " @remark     thread safe"]
	#[doc = ""]
	#[doc = " @param      gui        Gui instance"]
	#[doc = " @param      view_port  ViewPort instance"]
	pub fn gui_remove_view_port(gui: *mut Gui, view_port: *mut ViewPort);
}
extern "C" {
	#[doc = " Send ViewPort to the front"]
	#[doc = ""]
	#[doc = " Places selected ViewPort to the top of the drawing stack"]
	#[doc = ""]
	#[doc = " @param      gui        Gui instance"]
	#[doc = " @param      view_port  ViewPort instance"]
	pub fn gui_view_port_send_to_front(gui: *mut Gui, view_port: *mut ViewPort);
}
extern "C" {
	#[doc = " Send ViewPort to the back"]
	#[doc = ""]
	#[doc = " Places selected ViewPort to the bottom of the drawing stack"]
	#[doc = ""]
	#[doc = " @param      gui        Gui instance"]
	#[doc = " @param      view_port  ViewPort instance"]
	pub fn gui_view_port_send_to_back(gui: *mut Gui, view_port: *mut ViewPort);
}
extern "C" {
	#[doc = " Add gui canvas commit callback"]
	#[doc = ""]
	#[doc = " This callback will be called upon Canvas commit Callback dispatched from GUI"]
	#[doc = " thread and is time critical"]
	#[doc = ""]
	#[doc = " @param      gui       Gui instance"]
	#[doc = " @param      callback  GuiCanvasCommitCallback"]
	#[doc = " @param      context   GuiCanvasCommitCallback context"]
	pub fn gui_add_framebuffer_callback(gui: *mut Gui, callback: GuiCanvasCommitCallback, context: *mut core::ffi::c_void);
}
extern "C" {
	#[doc = " Remove gui canvas commit callback"]
	#[doc = ""]
	#[doc = " @param      gui       Gui instance"]
	#[doc = " @param      callback  GuiCanvasCommitCallback"]
	#[doc = " @param      context   GuiCanvasCommitCallback context"]
	pub fn gui_remove_framebuffer_callback(gui: *mut Gui, callback: GuiCanvasCommitCallback, context: *mut core::ffi::c_void);
}
extern "C" {
	#[doc = " Get gui canvas frame buffer size"]
	#[doc = " *"]
	#[doc = " @param      gui       Gui instance"]
	#[doc = " @return     size_t    size of frame buffer in bytes"]
	pub fn gui_get_framebuffer_size(gui: *mut Gui) -> usize;
}
extern "C" {
	#[doc = " Set lockdown mode"]
	#[doc = ""]
	#[doc = " When lockdown mode is enabled, only GuiLayerDesktop is shown."]
	#[doc = " This feature prevents services from showing sensitive information when flipper is locked."]
	#[doc = ""]
	#[doc = " @param      gui       Gui instance"]
	#[doc = " @param      lockdown  bool, true if enabled"]
	pub fn gui_set_lockdown(gui: *mut Gui, lockdown: bool);
}
#[repr(C)]
pub struct ButtonMenu {
	_unused: [u8; 0],
}
#[repr(C)]
pub struct ButtonMenuItem {
	_unused: [u8; 0],
}
#[doc = " Callback for any button menu actions"]
pub type ButtonMenuItemCallback =
	::core::option::Option<unsafe extern "C" fn(context: *mut core::ffi::c_void, index: i32, type_: InputType)>;
#[repr(u32)]
#[non_exhaustive]
#[doc = " Type of button. Difference in drawing buttons."]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum ButtonMenuItemType {
	ButtonMenuItemTypeCommon = 0,
	ButtonMenuItemTypeControl = 1,
}
extern "C" {
	#[doc = " Get button menu view"]
	#[doc = ""]
	#[doc = " @param      button_menu  ButtonMenu instance"]
	#[doc = ""]
	#[doc = " @return     View instance that can be used for embedding"]
	pub fn button_menu_get_view(button_menu: *mut ButtonMenu) -> *mut View;
}
extern "C" {
	#[doc = " Clean button menu"]
	#[doc = ""]
	#[doc = " @param      button_menu  ButtonMenu instance"]
	pub fn button_menu_reset(button_menu: *mut ButtonMenu);
}
extern "C" {
	#[doc = " Add item to button menu instance"]
	#[doc = ""]
	#[doc = " @param      button_menu       ButtonMenu instance"]
	#[doc = " @param      label             text inside new button"]
	#[doc = " @param      index             value to distinct between buttons inside"]
	#[doc = "                               ButtonMenuItemCallback"]
	#[doc = " @param      callback          The callback"]
	#[doc = " @param      type              type of button to create. Differ by button"]
	#[doc = "                               drawing. Control buttons have no frames, and"]
	#[doc = "                               have more squared borders."]
	#[doc = " @param      callback_context  The callback context"]
	#[doc = ""]
	#[doc = " @return     pointer to just-created item"]
	pub fn button_menu_add_item(button_menu: *mut ButtonMenu,
	                            label: *const core::ffi::c_char,
	                            index: i32,
	                            callback: ButtonMenuItemCallback,
	                            type_: ButtonMenuItemType,
	                            callback_context: *mut core::ffi::c_void)
	                            -> *mut ButtonMenuItem;
}
extern "C" {
	#[doc = " Allocate and initialize new instance of ButtonMenu model"]
	#[doc = ""]
	#[doc = " @return     just-created ButtonMenu model"]
	pub fn button_menu_alloc() -> *mut ButtonMenu;
}
extern "C" {
	#[doc = " Free ButtonMenu element"]
	#[doc = ""]
	#[doc = " @param      button_menu  ButtonMenu instance"]
	pub fn button_menu_free(button_menu: *mut ButtonMenu);
}
extern "C" {
	#[doc = " Set ButtonMenu header on top of canvas"]
	#[doc = ""]
	#[doc = " @param      button_menu  ButtonMenu instance"]
	#[doc = " @param      header       header on the top of button menu"]
	pub fn button_menu_set_header(button_menu: *mut ButtonMenu, header: *const core::ffi::c_char);
}
extern "C" {
	#[doc = " Set selected item"]
	#[doc = ""]
	#[doc = " @param      button_menu  ButtonMenu instance"]
	#[doc = " @param      index        index of ButtonMenu to be selected"]
	pub fn button_menu_set_selected_item(button_menu: *mut ButtonMenu, index: u32);
}
#[repr(C)]
pub struct ButtonPanel {
	_unused: [u8; 0],
}
#[doc = " Callback type to call for handling selecting button_panel items"]
pub type ButtonItemCallback = ::core::option::Option<unsafe extern "C" fn(context: *mut core::ffi::c_void, index: u32)>;
extern "C" {
	#[doc = " Allocate new button_panel module."]
	#[doc = ""]
	#[doc = " @return     ButtonPanel instance"]
	pub fn button_panel_alloc() -> *mut ButtonPanel;
}
extern "C" {
	#[doc = " Free button_panel module."]
	#[doc = ""]
	#[doc = " @param      button_panel  ButtonPanel instance"]
	pub fn button_panel_free(button_panel: *mut ButtonPanel);
}
extern "C" {
	#[doc = " Free items from button_panel module. Preallocated matrix stays unchanged."]
	#[doc = ""]
	#[doc = " @param      button_panel  ButtonPanel instance"]
	pub fn button_panel_reset(button_panel: *mut ButtonPanel);
}
extern "C" {
	#[doc = " Reserve space for adding items."]
	#[doc = ""]
	#[doc = " One does not simply use button_panel_add_item() without this function. It"]
	#[doc = " should be allocated space for it first."]
	#[doc = ""]
	#[doc = " @param      button_panel  ButtonPanel instance"]
	#[doc = " @param      reserve_x     number of columns in button_panel"]
	#[doc = " @param      reserve_y     number of rows in button_panel"]
	pub fn button_panel_reserve(button_panel: *mut ButtonPanel, reserve_x: usize, reserve_y: usize);
}
extern "C" {
	#[doc = " Add item to button_panel module."]
	#[doc = ""]
	#[doc = " Have to set element in bounds of allocated size by X and by Y."]
	#[doc = ""]
	#[doc = " @param      button_panel        ButtonPanel instance"]
	#[doc = " @param      index               value to pass to callback"]
	#[doc = " @param      matrix_place_x      coordinates by x-axis on virtual grid, it"]
	#[doc = "                                 is only used for navigation"]
	#[doc = " @param      matrix_place_y      coordinates by y-axis on virtual grid, it"]
	#[doc = "                                 is only used for naviagation"]
	#[doc = " @param      x                   x-coordinate to draw icon on"]
	#[doc = " @param      y                   y-coordinate to draw icon on"]
	#[doc = " @param      icon_name           name of the icon to draw"]
	#[doc = " @param      icon_name_selected  name of the icon to draw when current"]
	#[doc = "                                 element is selected"]
	#[doc = " @param      callback            function to call when specific element is"]
	#[doc = "                                 selected (pressed Ok on selected item)"]
	#[doc = " @param      callback_context    context to pass to callback"]
	pub fn button_panel_add_item(button_panel: *mut ButtonPanel,
	                             index: u32,
	                             matrix_place_x: u16,
	                             matrix_place_y: u16,
	                             x: u16,
	                             y: u16,
	                             icon_name: *const Icon,
	                             icon_name_selected: *const Icon,
	                             callback: ButtonItemCallback,
	                             callback_context: *mut core::ffi::c_void);
}
extern "C" {
	#[doc = " Get button_panel view."]
	#[doc = ""]
	#[doc = " @param      button_panel  ButtonPanel instance"]
	#[doc = ""]
	#[doc = " @return     acquired view"]
	pub fn button_panel_get_view(button_panel: *mut ButtonPanel) -> *mut View;
}
extern "C" {
	#[doc = " Add label to button_panel module."]
	#[doc = ""]
	#[doc = " @param      button_panel  ButtonPanel instance"]
	#[doc = " @param      x             x-coordinate to place label"]
	#[doc = " @param      y             y-coordinate to place label"]
	#[doc = " @param      font          font to write label with"]
	#[doc = " @param      label_str     string label to write"]
	pub fn button_panel_add_label(button_panel: *mut ButtonPanel, x: u16, y: u16, font: Font, label_str: *const core::ffi::c_char);
}
#[repr(C)]
pub struct ByteInput {
	_unused: [u8; 0],
}
#[doc = " callback that is executed on save button press"]
pub type ByteInputCallback = ::core::option::Option<unsafe extern "C" fn(context: *mut core::ffi::c_void)>;
#[doc = " callback that is executed when byte buffer is changed"]
pub type ByteChangedCallback = ::core::option::Option<unsafe extern "C" fn(context: *mut core::ffi::c_void)>;
extern "C" {
	#[doc = " Allocate and initialize byte input. This byte input is used to enter bytes."]
	#[doc = ""]
	#[doc = " @return     ByteInput instance pointer"]
	pub fn byte_input_alloc() -> *mut ByteInput;
}
extern "C" {
	#[doc = " Deinitialize and free byte input"]
	#[doc = ""]
	#[doc = " @param      byte_input  Byte input instance"]
	pub fn byte_input_free(byte_input: *mut ByteInput);
}
extern "C" {
	#[doc = " Get byte input view"]
	#[doc = ""]
	#[doc = " @param      byte_input  byte input instance"]
	#[doc = ""]
	#[doc = " @return     View instance that can be used for embedding"]
	pub fn byte_input_get_view(byte_input: *mut ByteInput) -> *mut View;
}
extern "C" {
	#[doc = " Set byte input result callback"]
	#[doc = ""]
	#[doc = " @param      byte_input        byte input instance"]
	#[doc = " @param      input_callback    input callback fn"]
	#[doc = " @param      changed_callback  changed callback fn"]
	#[doc = " @param      callback_context  callback context"]
	#[doc = " @param      bytes             buffer to use"]
	#[doc = " @param      bytes_count       buffer length"]
	pub fn byte_input_set_result_callback(byte_input: *mut ByteInput,
	                                      input_callback: ByteInputCallback,
	                                      changed_callback: ByteChangedCallback,
	                                      callback_context: *mut core::ffi::c_void,
	                                      bytes: *mut u8,
	                                      bytes_count: u8);
}
extern "C" {
	#[doc = " Set byte input header text"]
	#[doc = ""]
	#[doc = " @param      byte_input  byte input instance"]
	#[doc = " @param      text        text to be shown"]
	pub fn byte_input_set_header_text(byte_input: *mut ByteInput, text: *const core::ffi::c_char);
}
#[repr(C)]
pub struct DialogEx {
	_unused: [u8; 0],
}
#[repr(u32)]
#[non_exhaustive]
#[doc = " DialogEx result"]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum DialogExResult {
	DialogExResultLeft = 0,
	DialogExResultCenter = 1,
	DialogExResultRight = 2,
	DialogExPressLeft = 3,
	DialogExPressCenter = 4,
	DialogExPressRight = 5,
	DialogExReleaseLeft = 6,
	DialogExReleaseCenter = 7,
	DialogExReleaseRight = 8,
}
#[doc = " DialogEx result callback type"]
#[doc = " @warning comes from GUI thread"]
pub type DialogExResultCallback =
	::core::option::Option<unsafe extern "C" fn(result: DialogExResult, context: *mut core::ffi::c_void)>;
extern "C" {
	#[doc = " Allocate and initialize dialog"]
	#[doc = ""]
	#[doc = " This dialog used to ask simple questions"]
	#[doc = ""]
	#[doc = " @return     DialogEx instance"]
	pub fn dialog_ex_alloc() -> *mut DialogEx;
}
extern "C" {
	#[doc = " Deinitialize and free dialog"]
	#[doc = ""]
	#[doc = " @param      dialog_ex  DialogEx instance"]
	pub fn dialog_ex_free(dialog_ex: *mut DialogEx);
}
extern "C" {
	#[doc = " Get dialog view"]
	#[doc = ""]
	#[doc = " @param      dialog_ex  DialogEx instance"]
	#[doc = ""]
	#[doc = " @return     View instance that can be used for embedding"]
	pub fn dialog_ex_get_view(dialog_ex: *mut DialogEx) -> *mut View;
}
extern "C" {
	#[doc = " Set dialog result callback"]
	#[doc = ""]
	#[doc = " @param      dialog_ex  DialogEx instance"]
	#[doc = " @param      callback   result callback function"]
	pub fn dialog_ex_set_result_callback(dialog_ex: *mut DialogEx, callback: DialogExResultCallback);
}
extern "C" {
	#[doc = " Set dialog context"]
	#[doc = ""]
	#[doc = " @param      dialog_ex  DialogEx instance"]
	#[doc = " @param      context    context pointer, will be passed to result callback"]
	pub fn dialog_ex_set_context(dialog_ex: *mut DialogEx, context: *mut core::ffi::c_void);
}
extern "C" {
	#[doc = " Set dialog header text"]
	#[doc = ""]
	#[doc = " If text is null, dialog header will not be rendered"]
	#[doc = ""]
	#[doc = " @param      dialog_ex   DialogEx instance"]
	#[doc = " @param      text        text to be shown, can be multiline"]
	#[doc = " @param      x           x position"]
	#[doc = " @param      y           y position"]
	#[doc = " @param      horizontal  horizontal text aligment"]
	#[doc = " @param      vertical    vertical text aligment"]
	pub fn dialog_ex_set_header(dialog_ex: *mut DialogEx,
	                            text: *const core::ffi::c_char,
	                            x: u8,
	                            y: u8,
	                            horizontal: Align,
	                            vertical: Align);
}
extern "C" {
	#[doc = " Set dialog text"]
	#[doc = ""]
	#[doc = " If text is null, dialog text will not be rendered"]
	#[doc = ""]
	#[doc = " @param      dialog_ex   DialogEx instance"]
	#[doc = " @param      text        text to be shown, can be multiline"]
	#[doc = " @param      x           x position"]
	#[doc = " @param      y           y position"]
	#[doc = " @param      horizontal  horizontal text aligment"]
	#[doc = " @param      vertical    vertical text aligment"]
	pub fn dialog_ex_set_text(dialog_ex: *mut DialogEx,
	                          text: *const core::ffi::c_char,
	                          x: u8,
	                          y: u8,
	                          horizontal: Align,
	                          vertical: Align);
}
extern "C" {
	#[doc = " Set dialog icon"]
	#[doc = ""]
	#[doc = " If x or y is negative, dialog icon will not be rendered"]
	#[doc = ""]
	#[doc = " @param      dialog_ex  DialogEx instance"]
	#[doc = " @param      x          x position"]
	#[doc = " @param      y          y position"]
	#[doc = " @param      icon       The icon"]
	#[doc = " @param      name  icon to be shown"]
	pub fn dialog_ex_set_icon(dialog_ex: *mut DialogEx, x: u8, y: u8, icon: *const Icon);
}
extern "C" {
	#[doc = " Set left button text"]
	#[doc = ""]
	#[doc = " If text is null, left button will not be rendered and processed"]
	#[doc = ""]
	#[doc = " @param      dialog_ex  DialogEx instance"]
	#[doc = " @param      text       text to be shown"]
	pub fn dialog_ex_set_left_button_text(dialog_ex: *mut DialogEx, text: *const core::ffi::c_char);
}
extern "C" {
	#[doc = " Set center button text"]
	#[doc = ""]
	#[doc = " If text is null, center button will not be rendered and processed"]
	#[doc = ""]
	#[doc = " @param      dialog_ex  DialogEx instance"]
	#[doc = " @param      text       text to be shown"]
	pub fn dialog_ex_set_center_button_text(dialog_ex: *mut DialogEx, text: *const core::ffi::c_char);
}
extern "C" {
	#[doc = " Set right button text"]
	#[doc = ""]
	#[doc = " If text is null, right button will not be rendered and processed"]
	#[doc = ""]
	#[doc = " @param      dialog_ex  DialogEx instance"]
	#[doc = " @param      text       text to be shown"]
	pub fn dialog_ex_set_right_button_text(dialog_ex: *mut DialogEx, text: *const core::ffi::c_char);
}
extern "C" {
	#[doc = " Clean dialog"]
	#[doc = ""]
	#[doc = " @param      dialog_ex  DialogEx instance"]
	pub fn dialog_ex_reset(dialog_ex: *mut DialogEx);
}
extern "C" {
	#[doc = " Enable press/release events"]
	#[doc = ""]
	#[doc = " @param      dialog_ex  DialogEx instance"]
	pub fn dialog_ex_enable_extended_events(dialog_ex: *mut DialogEx);
}
extern "C" {
	#[doc = " Disable press/release events"]
	#[doc = ""]
	#[doc = " @param      dialog_ex  DialogEx instance"]
	pub fn dialog_ex_disable_extended_events(dialog_ex: *mut DialogEx);
}
#[repr(C)]
pub struct EmptyScreen {
	_unused: [u8; 0],
}
extern "C" {
	#[doc = " Allocate and initialize empty screen"]
	#[doc = ""]
	#[doc = " This empty screen used to ask simple questions like Yes/"]
	#[doc = ""]
	#[doc = " @return     EmptyScreen instance"]
	pub fn empty_screen_alloc() -> *mut EmptyScreen;
}
extern "C" {
	#[doc = " Deinitialize and free empty screen"]
	#[doc = ""]
	#[doc = " @param      empty_screen  Empty screen instance"]
	pub fn empty_screen_free(empty_screen: *mut EmptyScreen);
}
extern "C" {
	#[doc = " Get empty screen view"]
	#[doc = ""]
	#[doc = " @param      empty_screen  Empty screen instance"]
	#[doc = ""]
	#[doc = " @return     View instance that can be used for embedding"]
	pub fn empty_screen_get_view(empty_screen: *mut EmptyScreen) -> *mut View;
}
#[repr(C)]
pub struct BrowserWorker {
	_unused: [u8; 0],
}
pub type BrowserWorkerFolderOpenCallback =
	::core::option::Option<unsafe extern "C" fn(context: *mut core::ffi::c_void, item_cnt: u32, file_idx: i32, is_root: bool)>;
pub type BrowserWorkerListLoadCallback =
	::core::option::Option<unsafe extern "C" fn(context: *mut core::ffi::c_void, list_load_offset: u32)>;
pub type BrowserWorkerListItemCallback = ::core::option::Option<unsafe extern "C" fn(context: *mut core::ffi::c_void,
                                                                                     item_path: *mut string_t,
                                                                                     is_folder: bool,
                                                                                     is_last: bool)>;
pub type BrowserWorkerLongLoadCallback = ::core::option::Option<unsafe extern "C" fn(context: *mut core::ffi::c_void)>;
extern "C" {
	pub fn file_browser_worker_alloc(path: *mut string_t,
	                                 filter_ext: *const core::ffi::c_char,
	                                 skip_assets: bool)
	                                 -> *mut BrowserWorker;
}
extern "C" {
	pub fn file_browser_worker_free(browser: *mut BrowserWorker);
}
extern "C" {
	pub fn file_browser_worker_set_callback_context(browser: *mut BrowserWorker, context: *mut core::ffi::c_void);
}
extern "C" {
	pub fn file_browser_worker_set_folder_callback(browser: *mut BrowserWorker, cb: BrowserWorkerFolderOpenCallback);
}
extern "C" {
	pub fn file_browser_worker_set_list_callback(browser: *mut BrowserWorker, cb: BrowserWorkerListLoadCallback);
}
extern "C" {
	pub fn file_browser_worker_set_item_callback(browser: *mut BrowserWorker, cb: BrowserWorkerListItemCallback);
}
extern "C" {
	pub fn file_browser_worker_set_long_load_callback(browser: *mut BrowserWorker, cb: BrowserWorkerLongLoadCallback);
}
extern "C" {
	pub fn file_browser_worker_set_config(browser: *mut BrowserWorker,
	                                      path: *mut string_t,
	                                      filter_ext: *const core::ffi::c_char,
	                                      skip_assets: bool);
}
extern "C" {
	pub fn file_browser_worker_folder_enter(browser: *mut BrowserWorker, path: *mut string_t, item_idx: i32);
}
extern "C" {
	pub fn file_browser_worker_folder_exit(browser: *mut BrowserWorker);
}
extern "C" {
	pub fn file_browser_worker_folder_refresh(browser: *mut BrowserWorker, item_idx: i32);
}
extern "C" {
	pub fn file_browser_worker_load(browser: *mut BrowserWorker, offset: u32, count: u32);
}
#[repr(C)]
pub struct Loading {
	_unused: [u8; 0],
}
extern "C" {
	#[doc = " Allocate and initialize"]
	#[doc = ""]
	#[doc = " This View used to show system is doing some processing"]
	#[doc = ""]
	#[doc = " @return     Loading View instance"]
	pub fn loading_alloc() -> *mut Loading;
}
extern "C" {
	#[doc = " Deinitialize and free Loading View"]
	#[doc = ""]
	#[doc = " @param      instance  Loading instance"]
	pub fn loading_free(instance: *mut Loading);
}
extern "C" {
	#[doc = " Get Loading view"]
	#[doc = ""]
	#[doc = " @param      instance  Loading instance"]
	#[doc = ""]
	#[doc = " @return     View instance that can be used for embedding"]
	pub fn loading_get_view(instance: *mut Loading) -> *mut View;
}
#[repr(C)]
pub struct Menu {
	_unused: [u8; 0],
}
#[doc = " Menu Item Callback"]
pub type MenuItemCallback = ::core::option::Option<unsafe extern "C" fn(context: *mut core::ffi::c_void, index: u32)>;
extern "C" {
	#[doc = " Menu allocation and initialization"]
	#[doc = ""]
	#[doc = " @return     Menu instance"]
	pub fn menu_alloc() -> *mut Menu;
}
extern "C" {
	#[doc = " Free menu"]
	#[doc = ""]
	#[doc = " @param      menu  Menu instance"]
	pub fn menu_free(menu: *mut Menu);
}
extern "C" {
	#[doc = " Get Menu view"]
	#[doc = ""]
	#[doc = " @param      menu  Menu instance"]
	#[doc = ""]
	#[doc = " @return     View instance"]
	pub fn menu_get_view(menu: *mut Menu) -> *mut View;
}
extern "C" {
	#[doc = " Add item to menu"]
	#[doc = ""]
	#[doc = " @param      menu      Menu instance"]
	#[doc = " @param      label     menu item string label"]
	#[doc = " @param      icon      IconAnimation instance"]
	#[doc = " @param      index     menu item index"]
	#[doc = " @param      callback  MenuItemCallback instance"]
	#[doc = " @param      context   pointer to context"]
	pub fn menu_add_item(menu: *mut Menu,
	                     label: *const core::ffi::c_char,
	                     icon: *const Icon,
	                     index: u32,
	                     callback: MenuItemCallback,
	                     context: *mut core::ffi::c_void);
}
extern "C" {
	#[doc = " Clean menu"]
	#[doc = " @note       this function does not free menu instance"]
	#[doc = ""]
	#[doc = " @param      menu  Menu instance"]
	pub fn menu_reset(menu: *mut Menu);
}
extern "C" {
	#[doc = " Set current menu item"]
	#[doc = ""]
	#[doc = " @param      menu   Menu instance"]
	#[doc = " @param      index  The index"]
	pub fn menu_set_selected_item(menu: *mut Menu, index: u32);
}
#[repr(C)]
pub struct Popup {
	_unused: [u8; 0],
}
#[doc = " Popup result callback type"]
#[doc = " @warning    comes from GUI thread"]
pub type PopupCallback = ::core::option::Option<unsafe extern "C" fn(context: *mut core::ffi::c_void)>;
extern "C" {
	#[doc = " Allocate and initialize popup"]
	#[doc = ""]
	#[doc = " This popup used to ask simple questions like Yes/"]
	#[doc = ""]
	#[doc = " @return     Popup instance"]
	pub fn popup_alloc() -> *mut Popup;
}
extern "C" {
	#[doc = " Deinitialize and free popup"]
	#[doc = ""]
	#[doc = " @param      popup  Popup instance"]
	pub fn popup_free(popup: *mut Popup);
}
extern "C" {
	#[doc = " Get popup view"]
	#[doc = ""]
	#[doc = " @param      popup  Popup instance"]
	#[doc = ""]
	#[doc = " @return     View instance that can be used for embedding"]
	pub fn popup_get_view(popup: *mut Popup) -> *mut View;
}
extern "C" {
	#[doc = " Set popup header text"]
	#[doc = ""]
	#[doc = " @param      popup     Popup instance"]
	#[doc = " @param      callback  PopupCallback"]
	pub fn popup_set_callback(popup: *mut Popup, callback: PopupCallback);
}
extern "C" {
	#[doc = " Set popup context"]
	#[doc = ""]
	#[doc = " @param      popup    Popup instance"]
	#[doc = " @param      context  context pointer, will be passed to result callback"]
	pub fn popup_set_context(popup: *mut Popup, context: *mut core::ffi::c_void);
}
extern "C" {
	#[doc = " Set popup header text"]
	#[doc = ""]
	#[doc = " If text is null, popup header will not be rendered"]
	#[doc = ""]
	#[doc = " @param      popup       Popup instance"]
	#[doc = " @param      text        text to be shown, can be multiline"]
	#[doc = " @param      x           x position"]
	#[doc = " @param      y           y position"]
	#[doc = " @param      horizontal  horizontal alignment"]
	#[doc = " @param      vertical    vertical aligment"]
	pub fn popup_set_header(popup: *mut Popup, text: *const core::ffi::c_char, x: u8, y: u8, horizontal: Align, vertical: Align);
}
extern "C" {
	#[doc = " Set popup text"]
	#[doc = ""]
	#[doc = " If text is null, popup text will not be rendered"]
	#[doc = ""]
	#[doc = " @param      popup       Popup instance"]
	#[doc = " @param      text        text to be shown, can be multiline"]
	#[doc = " @param      x           x position"]
	#[doc = " @param      y           y position"]
	#[doc = " @param      horizontal  horizontal alignment"]
	#[doc = " @param      vertical    vertical aligment"]
	pub fn popup_set_text(popup: *mut Popup, text: *const core::ffi::c_char, x: u8, y: u8, horizontal: Align, vertical: Align);
}
extern "C" {
	#[doc = " Set popup icon"]
	#[doc = ""]
	#[doc = " If icon position is negative, popup icon will not be rendered"]
	#[doc = ""]
	#[doc = " @param      popup  Popup instance"]
	#[doc = " @param      x      x position"]
	#[doc = " @param      y      y position"]
	#[doc = " @param      icon   pointer to Icon data"]
	pub fn popup_set_icon(popup: *mut Popup, x: u8, y: u8, icon: *const Icon);
}
extern "C" {
	#[doc = " Set popup timeout"]
	#[doc = ""]
	#[doc = " @param      popup          Popup instance"]
	#[doc = " @param      timeout_in_ms  popup timeout value in milliseconds"]
	pub fn popup_set_timeout(popup: *mut Popup, timeout_in_ms: u32);
}
extern "C" {
	#[doc = " Enable popup timeout"]
	#[doc = ""]
	#[doc = " @param      popup  Popup instance"]
	pub fn popup_enable_timeout(popup: *mut Popup);
}
extern "C" {
	#[doc = " Disable popup timeout"]
	#[doc = ""]
	#[doc = " @param      popup  Popup instance"]
	pub fn popup_disable_timeout(popup: *mut Popup);
}
extern "C" {
	#[doc = " Reset popup instance state"]
	#[doc = ""]
	#[doc = " @param       popup Popup instance"]
	pub fn popup_reset(popup: *mut Popup);
}
#[repr(C)]
pub struct Submenu {
	_unused: [u8; 0],
}
pub type SubmenuItemCallback = ::core::option::Option<unsafe extern "C" fn(context: *mut core::ffi::c_void, index: u32)>;
extern "C" {
	#[doc = " Allocate and initialize submenu"]
	#[doc = ""]
	#[doc = " This submenu is used to select one option"]
	#[doc = ""]
	#[doc = " @return     Submenu instance"]
	pub fn submenu_alloc() -> *mut Submenu;
}
extern "C" {
	#[doc = " Deinitialize and free submenu"]
	#[doc = ""]
	#[doc = " @param      submenu  Submenu instance"]
	pub fn submenu_free(submenu: *mut Submenu);
}
extern "C" {
	#[doc = " Get submenu view"]
	#[doc = ""]
	#[doc = " @param      submenu  Submenu instance"]
	#[doc = ""]
	#[doc = " @return     View instance that can be used for embedding"]
	pub fn submenu_get_view(submenu: *mut Submenu) -> *mut View;
}
extern "C" {
	#[doc = " Add item to submenu"]
	#[doc = ""]
	#[doc = " @param      submenu           Submenu instance"]
	#[doc = " @param      label             menu item label"]
	#[doc = " @param      index             menu item index, used for callback, may be"]
	#[doc = "                               the same with other items"]
	#[doc = " @param      callback          menu item callback"]
	#[doc = " @param      callback_context  menu item callback context"]
	pub fn submenu_add_item(submenu: *mut Submenu,
	                        label: *const core::ffi::c_char,
	                        index: u32,
	                        callback: SubmenuItemCallback,
	                        callback_context: *mut core::ffi::c_void);
}
extern "C" {
	#[doc = " Remove all items from submenu"]
	#[doc = ""]
	#[doc = " @param      submenu  Submenu instance"]
	pub fn submenu_reset(submenu: *mut Submenu);
}
extern "C" {
	#[doc = " Set submenu item selector"]
	#[doc = ""]
	#[doc = " @param      submenu  Submenu instance"]
	#[doc = " @param      index    The index"]
	pub fn submenu_set_selected_item(submenu: *mut Submenu, index: u32);
}
extern "C" {
	#[doc = " Set optional header for submenu"]
	#[doc = ""]
	#[doc = " @param      submenu  Submenu instance"]
	#[doc = " @param      header   header to set"]
	pub fn submenu_set_header(submenu: *mut Submenu, header: *const core::ffi::c_char);
}
#[repr(C)]
pub struct TextBox {
	_unused: [u8; 0],
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum TextBoxFont {
	TextBoxFontText = 0,
	TextBoxFontHex = 1,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum TextBoxFocus {
	TextBoxFocusStart = 0,
	TextBoxFocusEnd = 1,
}
extern "C" {
	#[doc = " Allocate and initialize text_box"]
	#[doc = ""]
	#[doc = " @return     TextBox instance"]
	pub fn text_box_alloc() -> *mut TextBox;
}
extern "C" {
	#[doc = " Deinitialize and free text_box"]
	#[doc = ""]
	#[doc = " @param      text_box  text_box instance"]
	pub fn text_box_free(text_box: *mut TextBox);
}
extern "C" {
	#[doc = " Get text_box view"]
	#[doc = ""]
	#[doc = " @param      text_box  TextBox instance"]
	#[doc = ""]
	#[doc = " @return     View instance that can be used for embedding"]
	pub fn text_box_get_view(text_box: *mut TextBox) -> *mut View;
}
extern "C" {
	#[doc = " Clean text_box"]
	#[doc = ""]
	#[doc = " @param      text_box  TextBox instance"]
	pub fn text_box_reset(text_box: *mut TextBox);
}
extern "C" {
	#[doc = " Set text for text_box"]
	#[doc = ""]
	#[doc = " @param      text_box  TextBox instance"]
	#[doc = " @param      text      text to set"]
	pub fn text_box_set_text(text_box: *mut TextBox, text: *const core::ffi::c_char);
}
extern "C" {
	#[doc = " Set TextBox font"]
	#[doc = ""]
	#[doc = " @param      text_box  TextBox instance"]
	#[doc = " @param      font      TextBoxFont instance"]
	pub fn text_box_set_font(text_box: *mut TextBox, font: TextBoxFont);
}
extern "C" {
	#[doc = " Set TextBox focus"]
	#[doc = " @note Use to display from start or from end"]
	#[doc = ""]
	#[doc = " @param      text_box  TextBox instance"]
	#[doc = " @param      focus     TextBoxFocus instance"]
	pub fn text_box_set_focus(text_box: *mut TextBox, focus: TextBoxFocus);
}
#[repr(C)]
pub struct ValidatorIsFile {
	_unused: [u8; 0],
}
extern "C" {
	pub fn validator_is_file_alloc_init(app_path_folder: *const core::ffi::c_char,
	                                    app_extension: *const core::ffi::c_char,
	                                    current_name: *const core::ffi::c_char)
	                                    -> *mut ValidatorIsFile;
}
extern "C" {
	pub fn validator_is_file_free(instance: *mut ValidatorIsFile);
}
extern "C" {
	pub fn validator_is_file_callback(text: *const core::ffi::c_char, error: *mut string_t, context: *mut core::ffi::c_void) -> bool;
}
#[repr(C)]
pub struct TextInput {
	_unused: [u8; 0],
}
pub type TextInputCallback = ::core::option::Option<unsafe extern "C" fn(context: *mut core::ffi::c_void)>;
pub type TextInputValidatorCallback = ::core::option::Option<unsafe extern "C" fn(text: *const core::ffi::c_char,
                                                                                  error: *mut string_t,
                                                                                  context: *mut core::ffi::c_void)
                                                                                  -> bool>;
extern "C" {
	#[doc = " Allocate and initialize text input"]
	#[doc = ""]
	#[doc = " This text input is used to enter string"]
	#[doc = ""]
	#[doc = " @return     TextInput instance"]
	pub fn text_input_alloc() -> *mut TextInput;
}
extern "C" {
	#[doc = " Deinitialize and free text input"]
	#[doc = ""]
	#[doc = " @param      text_input  TextInput instance"]
	pub fn text_input_free(text_input: *mut TextInput);
}
extern "C" {
	#[doc = " Clean text input view Note: this function does not free memory"]
	#[doc = ""]
	#[doc = " @param      text_input  Text input instance"]
	pub fn text_input_reset(text_input: *mut TextInput);
}
extern "C" {
	#[doc = " Get text input view"]
	#[doc = ""]
	#[doc = " @param      text_input  TextInput instance"]
	#[doc = ""]
	#[doc = " @return     View instance that can be used for embedding"]
	pub fn text_input_get_view(text_input: *mut TextInput) -> *mut View;
}
extern "C" {
	#[doc = " Set text input result callback"]
	#[doc = ""]
	#[doc = " @param      text_input          TextInput instance"]
	#[doc = " @param      callback            callback fn"]
	#[doc = " @param      callback_context    callback context"]
	#[doc = " @param      text_buffer         pointer to YOUR text buffer, that we going"]
	#[doc = "                                 to modify"]
	#[doc = " @param      text_buffer_size    YOUR text buffer size in bytes. Max string"]
	#[doc = "                                 length will be text_buffer_size-1."]
	#[doc = " @param      clear_default_text  clear text from text_buffer on first OK"]
	#[doc = "                                 event"]
	pub fn text_input_set_result_callback(text_input: *mut TextInput,
	                                      callback: TextInputCallback,
	                                      callback_context: *mut core::ffi::c_void,
	                                      text_buffer: *mut core::ffi::c_char,
	                                      text_buffer_size: usize,
	                                      clear_default_text: bool);
}
extern "C" {
	pub fn text_input_set_validator(text_input: *mut TextInput,
	                                callback: TextInputValidatorCallback,
	                                callback_context: *mut core::ffi::c_void);
}
extern "C" {
	pub fn text_input_get_validator_callback(text_input: *mut TextInput) -> TextInputValidatorCallback;
}
extern "C" {
	pub fn text_input_get_validator_callback_context(text_input: *mut TextInput) -> *mut core::ffi::c_void;
}
extern "C" {
	#[doc = " Set text input header text"]
	#[doc = ""]
	#[doc = " @param      text_input  TextInput instance"]
	#[doc = " @param      text        text to be shown"]
	pub fn text_input_set_header_text(text_input: *mut TextInput, text: *const core::ffi::c_char);
}
#[repr(C)]
pub struct VariableItemList {
	_unused: [u8; 0],
}
#[repr(C)]
pub struct VariableItem {
	_unused: [u8; 0],
}
pub type VariableItemChangeCallback = ::core::option::Option<unsafe extern "C" fn(item: *mut VariableItem)>;
pub type VariableItemListEnterCallback = ::core::option::Option<unsafe extern "C" fn(context: *mut core::ffi::c_void, index: u32)>;
extern "C" {
	#[doc = " Allocate and initialize VariableItemList"]
	#[doc = ""]
	#[doc = " @return     VariableItemList*"]
	pub fn variable_item_list_alloc() -> *mut VariableItemList;
}
extern "C" {
	#[doc = " Deinitialize and free VariableItemList"]
	#[doc = ""]
	#[doc = " @param      variable_item_list  VariableItemList instance"]
	pub fn variable_item_list_free(variable_item_list: *mut VariableItemList);
}
extern "C" {
	#[doc = " Clear all elements from list"]
	#[doc = ""]
	#[doc = " @param      variable_item_list  VariableItemList instance"]
	pub fn variable_item_list_reset(variable_item_list: *mut VariableItemList);
}
extern "C" {
	#[doc = " Get VariableItemList View instance"]
	#[doc = ""]
	#[doc = " @param      variable_item_list  VariableItemList instance"]
	#[doc = ""]
	#[doc = " @return     View instance"]
	pub fn variable_item_list_get_view(variable_item_list: *mut VariableItemList) -> *mut View;
}
extern "C" {
	#[doc = " Add item to VariableItemList"]
	#[doc = ""]
	#[doc = " @param      variable_item_list  VariableItemList instance"]
	#[doc = " @param      label               item name"]
	#[doc = " @param      values_count        item values count"]
	#[doc = " @param      change_callback     called on value change in gui"]
	#[doc = " @param      context             item context"]
	#[doc = ""]
	#[doc = " @return     VariableItem* item instance"]
	pub fn variable_item_list_add(variable_item_list: *mut VariableItemList,
	                              label: *const core::ffi::c_char,
	                              values_count: u8,
	                              change_callback: VariableItemChangeCallback,
	                              context: *mut core::ffi::c_void)
	                              -> *mut VariableItem;
}
extern "C" {
	#[doc = " Set enter callback"]
	#[doc = ""]
	#[doc = " @param      variable_item_list  VariableItemList instance"]
	#[doc = " @param      callback            VariableItemListEnterCallback instance"]
	#[doc = " @param      context             pointer to context"]
	pub fn variable_item_list_set_enter_callback(variable_item_list: *mut VariableItemList,
	                                             callback: VariableItemListEnterCallback,
	                                             context: *mut core::ffi::c_void);
}
extern "C" {
	pub fn variable_item_list_set_selected_item(variable_item_list: *mut VariableItemList, index: u8);
}
extern "C" {
	pub fn variable_item_list_get_selected_item_index(variable_item_list: *mut VariableItemList) -> u8;
}
extern "C" {
	#[doc = " Set item current selected index"]
	#[doc = ""]
	#[doc = " @param      item                 VariableItem* instance"]
	#[doc = " @param      current_value_index  The current value index"]
	pub fn variable_item_set_current_value_index(item: *mut VariableItem, current_value_index: u8);
}
extern "C" {
	#[doc = " Set item current selected text"]
	#[doc = ""]
	#[doc = " @param      item                VariableItem* instance"]
	#[doc = " @param      current_value_text  The current value text"]
	pub fn variable_item_set_current_value_text(item: *mut VariableItem, current_value_text: *const core::ffi::c_char);
}
extern "C" {
	#[doc = " Get item current selected index"]
	#[doc = ""]
	#[doc = " @param      item  VariableItem* instance"]
	#[doc = ""]
	#[doc = " @return     uint8_t current selected index"]
	pub fn variable_item_get_current_value_index(item: *mut VariableItem) -> u8;
}
extern "C" {
	#[doc = " Get item context"]
	#[doc = ""]
	#[doc = " @param      item  VariableItem* instance"]
	#[doc = ""]
	#[doc = " @return     void* item context"]
	pub fn variable_item_get_context(item: *mut VariableItem) -> *mut core::ffi::c_void;
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum GuiButtonType {
	GuiButtonTypeLeft = 0,
	GuiButtonTypeCenter = 1,
	GuiButtonTypeRight = 2,
}
pub type ButtonCallback =
	::core::option::Option<unsafe extern "C" fn(result: GuiButtonType, type_: InputType, context: *mut core::ffi::c_void)>;
#[repr(C)]
pub struct Widget {
	_unused: [u8; 0],
}
#[repr(C)]
pub struct WidgetElement {
	_unused: [u8; 0],
}
extern "C" {
	#[doc = " Allocate Widget that holds Widget Elements"]
	#[doc = ""]
	#[doc = " @return     Widget instance"]
	pub fn widget_alloc() -> *mut Widget;
}
extern "C" {
	#[doc = " Free Widget"]
	#[doc = " @note       this function free allocated Widget Elements"]
	#[doc = ""]
	#[doc = " @param      widget  Widget instance"]
	pub fn widget_free(widget: *mut Widget);
}
extern "C" {
	#[doc = " Reset Widget"]
	#[doc = ""]
	#[doc = " @param      widget  Widget instance"]
	pub fn widget_reset(widget: *mut Widget);
}
extern "C" {
	#[doc = " Get Widget view"]
	#[doc = ""]
	#[doc = " @param      widget  Widget instance"]
	#[doc = ""]
	#[doc = " @return     View instance"]
	pub fn widget_get_view(widget: *mut Widget) -> *mut View;
}
extern "C" {
	#[doc = " Add Multi String Element"]
	#[doc = ""]
	#[doc = " @param      widget      Widget instance"]
	#[doc = " @param      x           x coordinate"]
	#[doc = " @param      y           y coordinate"]
	#[doc = " @param      horizontal  Align instance"]
	#[doc = " @param      vertical    Align instance"]
	#[doc = " @param      font        Font instance"]
	#[doc = " @param[in]  text        The text"]
	pub fn widget_add_string_multiline_element(widget: *mut Widget,
	                                           x: u8,
	                                           y: u8,
	                                           horizontal: Align,
	                                           vertical: Align,
	                                           font: Font,
	                                           text: *const core::ffi::c_char);
}
extern "C" {
	#[doc = " Add String Element"]
	#[doc = ""]
	#[doc = " @param      widget      Widget instance"]
	#[doc = " @param      x           x coordinate"]
	#[doc = " @param      y           y coordinate"]
	#[doc = " @param      horizontal  Align instance"]
	#[doc = " @param      vertical    Align instance"]
	#[doc = " @param      font        Font instance"]
	#[doc = " @param[in]  text        The text"]
	pub fn widget_add_string_element(widget: *mut Widget,
	                                 x: u8,
	                                 y: u8,
	                                 horizontal: Align,
	                                 vertical: Align,
	                                 font: Font,
	                                 text: *const core::ffi::c_char);
}
extern "C" {
	#[doc = " Add Text Box Element"]
	#[doc = ""]
	#[doc = " @param      widget           Widget instance"]
	#[doc = " @param      x                x coordinate"]
	#[doc = " @param      y                y coordinate"]
	#[doc = " @param      width            width to fit text"]
	#[doc = " @param      height           height to fit text"]
	#[doc = " @param      horizontal       Align instance"]
	#[doc = " @param      vertical         Align instance"]
	#[doc = " @param[in]  text             Formatted text. The following formats are available:"]
	#[doc = "                               \"\\e#Bold text\\e#\" - bold font is used"]
	#[doc = "                               \"\\e*Monospaced text\\e*\" - monospaced font is used"]
	#[doc = "                               \"\\e#Inversed text\\e#\" - white text on black background"]
	#[doc = " @param      strip_to_dots    Strip text to ... if does not fit to width"]
	pub fn widget_add_text_box_element(widget: *mut Widget,
	                                   x: u8,
	                                   y: u8,
	                                   width: u8,
	                                   height: u8,
	                                   horizontal: Align,
	                                   vertical: Align,
	                                   text: *const core::ffi::c_char,
	                                   strip_to_dots: bool);
}
extern "C" {
	#[doc = " Add Text Scroll Element"]
	#[doc = ""]
	#[doc = " @param      widget           Widget instance"]
	#[doc = " @param      x                x coordinate"]
	#[doc = " @param      y                y coordinate"]
	#[doc = " @param      width            width to fit text"]
	#[doc = " @param      height           height to fit text"]
	#[doc = " @param[in]  text             Formatted text. Default format: align left, Secondary font."]
	#[doc = "                              The following formats are available:"]
	#[doc = "                               \"\\e#Bold text\" - sets bold font before until next '\\n' symbol"]
	#[doc = "                               \"\\ecCenter-aligned text\" - sets center horizontal align until the next '\\n' symbol"]
	#[doc = "                               \"\\erRight-aligned text\" - sets right horizontal align until the next '\\n' symbol"]
	pub fn widget_add_text_scroll_element(widget: *mut Widget, x: u8, y: u8, width: u8, height: u8, text: *const core::ffi::c_char);
}
extern "C" {
	#[doc = " Add Button Element"]
	#[doc = ""]
	#[doc = " @param      widget       Widget instance"]
	#[doc = " @param      button_type  GuiButtonType instance"]
	#[doc = " @param      text         text on allocated button"]
	#[doc = " @param      callback     ButtonCallback instance"]
	#[doc = " @param      context      pointer to context"]
	pub fn widget_add_button_element(widget: *mut Widget,
	                                 button_type: GuiButtonType,
	                                 text: *const core::ffi::c_char,
	                                 callback: ButtonCallback,
	                                 context: *mut core::ffi::c_void);
}
extern "C" {
	#[doc = " Add Icon Element"]
	#[doc = ""]
	#[doc = " @param      widget  Widget instance"]
	#[doc = " @param      x       top left x coordinate"]
	#[doc = " @param      y       top left y coordinate"]
	#[doc = " @param      icon    Icon instance"]
	pub fn widget_add_icon_element(widget: *mut Widget, x: u8, y: u8, icon: *const Icon);
}
extern "C" {
	#[doc = " Add Frame Element"]
	#[doc = ""]
	#[doc = " @param      widget  Widget instance"]
	#[doc = " @param      x       top left x coordinate"]
	#[doc = " @param      y       top left y coordinate"]
	#[doc = " @param      width   frame width"]
	#[doc = " @param      height  frame height"]
	#[doc = " @param      radius  frame radius"]
	pub fn widget_add_frame_element(widget: *mut Widget, x: u8, y: u8, width: u8, height: u8, radius: u8);
}
#[repr(u32)]
#[non_exhaustive]
#[doc = " Scene Manager events type"]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum SceneManagerEventType {
	SceneManagerEventTypeCustom = 0,
	SceneManagerEventTypeBack = 1,
	SceneManagerEventTypeTick = 2,
}
#[doc = " Scene Manager event"]
#[repr(C)]
pub struct SceneManagerEvent {
	pub type_: SceneManagerEventType,
	pub event: u32,
}
#[test]
fn bindgen_test_layout_SceneManagerEvent() {
	assert_eq!(
	           ::core::mem::size_of::<SceneManagerEvent>(),
	           8usize,
	           concat!("Size of: ", stringify!(SceneManagerEvent))
	);
	assert_eq!(
	           ::core::mem::align_of::<SceneManagerEvent>(),
	           4usize,
	           concat!("Alignment of ", stringify!(SceneManagerEvent))
	);
	fn test_field_type() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<SceneManagerEvent>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(SceneManagerEvent), "::", stringify!(type_))
		);
	}
	test_field_type();
	fn test_field_event() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<SceneManagerEvent>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).event) as usize - ptr as usize
		           },
		           4usize,
		           concat!("Offset of field: ", stringify!(SceneManagerEvent), "::", stringify!(event))
		);
	}
	test_field_event();
}
#[doc = " Prototype for Scene on_enter handler"]
pub type AppSceneOnEnterCallback = ::core::option::Option<unsafe extern "C" fn(context: *mut core::ffi::c_void)>;
#[doc = " Prototype for Scene on_event handler"]
pub type AppSceneOnEventCallback =
	::core::option::Option<unsafe extern "C" fn(context: *mut core::ffi::c_void, event: SceneManagerEvent) -> bool>;
#[doc = " Prototype for Scene on_exit handler"]
pub type AppSceneOnExitCallback = ::core::option::Option<unsafe extern "C" fn(context: *mut core::ffi::c_void)>;
#[doc = " Scene Manager configuration structure"]
#[doc = " Contains array of Scene handlers"]
#[repr(C)]
pub struct SceneManagerHandlers {
	pub on_enter_handlers: *const AppSceneOnEnterCallback,
	pub on_event_handlers: *const AppSceneOnEventCallback,
	pub on_exit_handlers: *const AppSceneOnExitCallback,
	pub scene_num: u32,
}
#[test]
fn bindgen_test_layout_SceneManagerHandlers() {
	assert_eq!(
	           ::core::mem::size_of::<SceneManagerHandlers>(),
	           16usize,
	           concat!("Size of: ", stringify!(SceneManagerHandlers))
	);
	assert_eq!(
	           ::core::mem::align_of::<SceneManagerHandlers>(),
	           4usize,
	           concat!("Alignment of ", stringify!(SceneManagerHandlers))
	);
	fn test_field_on_enter_handlers() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<SceneManagerHandlers>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).on_enter_handlers) as usize - ptr as usize
		           },
		           0usize,
		           concat!(
			"Offset of field: ",
			stringify!(SceneManagerHandlers),
			"::",
			stringify!(on_enter_handlers)
		)
		);
	}
	test_field_on_enter_handlers();
	fn test_field_on_event_handlers() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<SceneManagerHandlers>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).on_event_handlers) as usize - ptr as usize
		           },
		           4usize,
		           concat!(
			"Offset of field: ",
			stringify!(SceneManagerHandlers),
			"::",
			stringify!(on_event_handlers)
		)
		);
	}
	test_field_on_event_handlers();
	fn test_field_on_exit_handlers() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<SceneManagerHandlers>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).on_exit_handlers) as usize - ptr as usize
		           },
		           8usize,
		           concat!(
			"Offset of field: ",
			stringify!(SceneManagerHandlers),
			"::",
			stringify!(on_exit_handlers)
		)
		);
	}
	test_field_on_exit_handlers();
	fn test_field_scene_num() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<SceneManagerHandlers>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).scene_num) as usize - ptr as usize
		           },
		           12usize,
		           concat!(
			"Offset of field: ",
			stringify!(SceneManagerHandlers),
			"::",
			stringify!(scene_num)
		)
		);
	}
	test_field_scene_num();
}
#[repr(C)]
pub struct SceneManager {
	_unused: [u8; 0],
}
extern "C" {
	#[doc = " Set Scene state"]
	#[doc = ""]
	#[doc = " @param      scene_manager  SceneManager instance"]
	#[doc = " @param      scene_id       Scene ID"]
	#[doc = " @param      state          Scene new state"]
	pub fn scene_manager_set_scene_state(scene_manager: *mut SceneManager, scene_id: u32, state: u32);
}
extern "C" {
	#[doc = " Get Scene state"]
	#[doc = ""]
	#[doc = " @param      scene_manager  SceneManager instance"]
	#[doc = " @param      scene_id       Scene ID"]
	#[doc = ""]
	#[doc = " @return     Scene state"]
	pub fn scene_manager_get_scene_state(scene_manager: *mut SceneManager, scene_id: u32) -> u32;
}
extern "C" {
	#[doc = " Scene Manager allocation and configuration"]
	#[doc = ""]
	#[doc = " Scene Manager allocates all scenes internally"]
	#[doc = ""]
	#[doc = " @param      app_scene_handlers  SceneManagerHandlers instance"]
	#[doc = " @param      context             context to be set on Scene handlers calls"]
	#[doc = ""]
	#[doc = " @return     SceneManager instance"]
	pub fn scene_manager_alloc(app_scene_handlers: *const SceneManagerHandlers, context: *mut core::ffi::c_void) -> *mut SceneManager;
}
extern "C" {
	#[doc = " Free Scene Manager with allocated Scenes"]
	#[doc = ""]
	#[doc = " @param      scene_manager  SceneManager instance"]
	pub fn scene_manager_free(scene_manager: *mut SceneManager);
}
extern "C" {
	#[doc = " Custom event handler"]
	#[doc = ""]
	#[doc = " Calls Scene event handler with Custom event parameter"]
	#[doc = ""]
	#[doc = " @param      scene_manager  SceneManager instance"]
	#[doc = " @param      custom_event   Custom event code"]
	#[doc = ""]
	#[doc = " @return     true if event was consumed, false otherwise"]
	pub fn scene_manager_handle_custom_event(scene_manager: *mut SceneManager, custom_event: u32) -> bool;
}
extern "C" {
	#[doc = " Back event handler"]
	#[doc = ""]
	#[doc = " Calls Scene event handler with Back event parameter"]
	#[doc = ""]
	#[doc = " @param      scene_manager  SceneManager instance"]
	#[doc = ""]
	#[doc = " @return     true if event was consumed, false otherwise"]
	pub fn scene_manager_handle_back_event(scene_manager: *mut SceneManager) -> bool;
}
extern "C" {
	#[doc = " Tick event handler"]
	#[doc = ""]
	#[doc = " Calls Scene event handler with Tick event parameter"]
	#[doc = ""]
	#[doc = " @param      scene_manager  SceneManager instance"]
	#[doc = " @return     true if event was consumed, false otherwise"]
	pub fn scene_manager_handle_tick_event(scene_manager: *mut SceneManager);
}
extern "C" {
	#[doc = " Add and run next Scene"]
	#[doc = ""]
	#[doc = " @param      scene_manager  SceneManager instance"]
	#[doc = " @param      next_scene_id  next Scene ID"]
	pub fn scene_manager_next_scene(scene_manager: *mut SceneManager, next_scene_id: u32);
}
extern "C" {
	#[doc = " Run previous Scene"]
	#[doc = ""]
	#[doc = " @param      scene_manager  SceneManager instance"]
	#[doc = ""]
	#[doc = " @return     true if previous scene was found, false otherwise"]
	pub fn scene_manager_previous_scene(scene_manager: *mut SceneManager) -> bool;
}
extern "C" {
	#[doc = " Search previous Scene"]
	#[doc = ""]
	#[doc = " @param      scene_manager  SceneManager instance"]
	#[doc = " @param      scene_id       Scene ID"]
	#[doc = ""]
	#[doc = " @return     true if previous scene was found, false otherwise"]
	pub fn scene_manager_has_previous_scene(scene_manager: *mut SceneManager, scene_id: u32) -> bool;
}
extern "C" {
	#[doc = " Search and switch to previous Scene"]
	#[doc = ""]
	#[doc = " @param      scene_manager  SceneManager instance"]
	#[doc = " @param      scene_id       Scene ID"]
	#[doc = ""]
	#[doc = " @return     true if previous scene was found, false otherwise"]
	pub fn scene_manager_search_and_switch_to_previous_scene(scene_manager: *mut SceneManager, scene_id: u32) -> bool;
}
extern "C" {
	#[doc = " Search and switch to previous Scene, multiple choice"]
	#[doc = ""]
	#[doc = " @param      scene_manager    SceneManager instance"]
	#[doc = " @param      scene_ids        Array of scene IDs"]
	#[doc = " @param      scene_ids_size   Array of scene IDs size"]
	#[doc = ""]
	#[doc = " @return     true if one of previous scenes was found, false otherwise"]
	pub fn scene_manager_search_and_switch_to_previous_scene_one_of(scene_manager: *mut SceneManager,
	                                                                scene_ids: *const u32,
	                                                                scene_ids_size: usize)
	                                                                -> bool;
}
extern "C" {
	#[doc = " Clear Scene stack and switch to another Scene"]
	#[doc = ""]
	#[doc = " @param      scene_manager  SceneManager instance"]
	#[doc = " @param      scene_id       Scene ID"]
	#[doc = ""]
	#[doc = " @return     true if previous scene was found, false otherwise"]
	pub fn scene_manager_search_and_switch_to_another_scene(scene_manager: *mut SceneManager, scene_id: u32) -> bool;
}
extern "C" {
	#[doc = " Exit from current scene"]
	#[doc = ""]
	#[doc = " @param      scene_manager  SceneManager instance"]
	pub fn scene_manager_stop(scene_manager: *mut SceneManager);
}
#[repr(u32)]
#[non_exhaustive]
#[doc = " ViewDispatcher view_port placement"]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum ViewDispatcherType {
	#[doc = "< Desktop layer: fullscreen with status bar on top of it. For internal usage."]
	ViewDispatcherTypeDesktop = 0,
	#[doc = "< Window layer: with status bar"]
	ViewDispatcherTypeWindow = 1,
	#[doc = "< Fullscreen layer: without status bar"]
	ViewDispatcherTypeFullscreen = 2,
}
#[repr(C)]
pub struct ViewDispatcher {
	_unused: [u8; 0],
}
#[doc = " Prototype for custom event callback"]
pub type ViewDispatcherCustomEventCallback =
	::core::option::Option<unsafe extern "C" fn(context: *mut core::ffi::c_void, event: u32) -> bool>;
#[doc = " Prototype for navigation event callback"]
pub type ViewDispatcherNavigationEventCallback =
	::core::option::Option<unsafe extern "C" fn(context: *mut core::ffi::c_void) -> bool>;
#[doc = " Prototype for tick event callback"]
pub type ViewDispatcherTickEventCallback = ::core::option::Option<unsafe extern "C" fn(context: *mut core::ffi::c_void)>;
extern "C" {
	#[doc = " Allocate ViewDispatcher instance"]
	#[doc = ""]
	#[doc = " @return     pointer to ViewDispatcher instance"]
	pub fn view_dispatcher_alloc() -> *mut ViewDispatcher;
}
extern "C" {
	#[doc = " Free ViewDispatcher instance"]
	#[doc = ""]
	#[doc = " @param      view_dispatcher  pointer to ViewDispatcher"]
	pub fn view_dispatcher_free(view_dispatcher: *mut ViewDispatcher);
}
extern "C" {
	#[doc = " Enable queue support"]
	#[doc = ""]
	#[doc = " If queue enabled all input and custom events will be dispatched throw"]
	#[doc = " internal queue"]
	#[doc = ""]
	#[doc = " @param      view_dispatcher  ViewDispatcher instance"]
	pub fn view_dispatcher_enable_queue(view_dispatcher: *mut ViewDispatcher);
}
extern "C" {
	#[doc = " Send custom event"]
	#[doc = ""]
	#[doc = " @param      view_dispatcher  ViewDispatcher instance"]
	#[doc = " @param[in]  event            The event"]
	pub fn view_dispatcher_send_custom_event(view_dispatcher: *mut ViewDispatcher, event: u32);
}
extern "C" {
	#[doc = " Set custom event handler"]
	#[doc = ""]
	#[doc = " Called on Custom Event, if it is not consumed by view"]
	#[doc = ""]
	#[doc = " @param      view_dispatcher  ViewDispatcher instance"]
	#[doc = " @param      callback         ViewDispatcherCustomEventCallback instance"]
	pub fn view_dispatcher_set_custom_event_callback(view_dispatcher: *mut ViewDispatcher,
	                                                 callback: ViewDispatcherCustomEventCallback);
}
extern "C" {
	#[doc = " Set navigation event handler"]
	#[doc = ""]
	#[doc = " Called on Input Short Back Event, if it is not consumed by view"]
	#[doc = ""]
	#[doc = " @param      view_dispatcher  ViewDispatcher instance"]
	#[doc = " @param      callback         ViewDispatcherNavigationEventCallback instance"]
	pub fn view_dispatcher_set_navigation_event_callback(view_dispatcher: *mut ViewDispatcher,
	                                                     callback: ViewDispatcherNavigationEventCallback);
}
extern "C" {
	#[doc = " Set tick event handler"]
	#[doc = ""]
	#[doc = " @param      view_dispatcher  ViewDispatcher instance"]
	#[doc = " @param      callback         ViewDispatcherTickEventCallback"]
	#[doc = " @param      tick_period      callback call period"]
	pub fn view_dispatcher_set_tick_event_callback(view_dispatcher: *mut ViewDispatcher,
	                                               callback: ViewDispatcherTickEventCallback,
	                                               tick_period: u32);
}
extern "C" {
	#[doc = " Set event callback context"]
	#[doc = ""]
	#[doc = " @param      view_dispatcher  ViewDispatcher instance"]
	#[doc = " @param      context          pointer to context"]
	pub fn view_dispatcher_set_event_callback_context(view_dispatcher: *mut ViewDispatcher, context: *mut core::ffi::c_void);
}
extern "C" {
	#[doc = " Run ViewDispatcher"]
	#[doc = ""]
	#[doc = " Use only after queue enabled"]
	#[doc = ""]
	#[doc = " @param      view_dispatcher  ViewDispatcher instance"]
	pub fn view_dispatcher_run(view_dispatcher: *mut ViewDispatcher);
}
extern "C" {
	#[doc = " Stop ViewDispatcher"]
	#[doc = ""]
	#[doc = " Use only after queue enabled"]
	#[doc = ""]
	#[doc = " @param      view_dispatcher  ViewDispatcher instance"]
	pub fn view_dispatcher_stop(view_dispatcher: *mut ViewDispatcher);
}
extern "C" {
	#[doc = " Add view to ViewDispatcher"]
	#[doc = ""]
	#[doc = " @param      view_dispatcher  ViewDispatcher instance"]
	#[doc = " @param      view_id          View id to register"]
	#[doc = " @param      view             View instance"]
	pub fn view_dispatcher_add_view(view_dispatcher: *mut ViewDispatcher, view_id: u32, view: *mut View);
}
extern "C" {
	#[doc = " Remove view from ViewDispatcher"]
	#[doc = ""]
	#[doc = " @param      view_dispatcher  ViewDispatcher instance"]
	#[doc = " @param      view_id          View id to remove"]
	pub fn view_dispatcher_remove_view(view_dispatcher: *mut ViewDispatcher, view_id: u32);
}
extern "C" {
	#[doc = " Switch to View"]
	#[doc = ""]
	#[doc = " @param      view_dispatcher  ViewDispatcher instance"]
	#[doc = " @param      view_id          View id to register"]
	#[doc = " @warning    switching may be delayed till input events complementarity"]
	#[doc = "             reached"]
	pub fn view_dispatcher_switch_to_view(view_dispatcher: *mut ViewDispatcher, view_id: u32);
}
extern "C" {
	#[doc = " Send ViewPort of this ViewDispatcher instance to front"]
	#[doc = ""]
	#[doc = " @param      view_dispatcher  ViewDispatcher instance"]
	pub fn view_dispatcher_send_to_front(view_dispatcher: *mut ViewDispatcher);
}
extern "C" {
	#[doc = " Send ViewPort of this ViewDispatcher instance to back"]
	#[doc = ""]
	#[doc = " @param      view_dispatcher  ViewDispatcher instance"]
	pub fn view_dispatcher_send_to_back(view_dispatcher: *mut ViewDispatcher);
}
extern "C" {
	#[doc = " Attach ViewDispatcher to GUI"]
	#[doc = ""]
	#[doc = " @param      view_dispatcher  ViewDispatcher instance"]
	#[doc = " @param      gui              GUI instance to attach to"]
	#[doc = " @param[in]  type             The type"]
	pub fn view_dispatcher_attach_to_gui(view_dispatcher: *mut ViewDispatcher, gui: *mut Gui, type_: ViewDispatcherType);
}
#[repr(C)]
pub struct ViewStack {
	_unused: [u8; 0],
}
extern "C" {
	#[doc = " Allocate and init ViewStack"]
	#[doc = ""]
	#[doc = " @return      ViewStack instance"]
	pub fn view_stack_alloc() -> *mut ViewStack;
}
extern "C" {
	#[doc = " Free ViewStack instance"]
	#[doc = ""]
	#[doc = " @param       view_stack  instance"]
	pub fn view_stack_free(view_stack: *mut ViewStack);
}
extern "C" {
	#[doc = " Get View of ViewStack."]
	#[doc = " Should this View to any view manager such as"]
	#[doc = " ViewDispatcher or ViewHolder."]
	#[doc = ""]
	#[doc = " @param       view_stack  instance"]
	pub fn view_stack_get_view(view_stack: *mut ViewStack) -> *mut View;
}
extern "C" {
	#[doc = " Add View to ViewStack."]
	#[doc = " Adds View on top of ViewStack."]
	#[doc = ""]
	#[doc = " @param       view_stack  instance"]
	#[doc = " @view        view        view to add"]
	pub fn view_stack_add_view(view_stack: *mut ViewStack, view: *mut View);
}
extern "C" {
	#[doc = " Remove any View in ViewStack."]
	#[doc = " If no View to remove found - ignore."]
	#[doc = ""]
	#[doc = " @param       view_stack  instance"]
	#[doc = " @view        view        view to remove"]
	pub fn view_stack_remove_view(view_stack: *mut ViewStack, view: *mut View);
}
#[repr(C)]
pub struct Loader {
	_unused: [u8; 0],
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum LoaderStatus {
	LoaderStatusOk = 0,
	LoaderStatusErrorAppStarted = 1,
	LoaderStatusErrorUnknownApp = 2,
	LoaderStatusErrorInternal = 3,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum LoaderEventType {
	LoaderEventTypeApplicationStarted = 0,
	LoaderEventTypeApplicationStopped = 1,
}
#[repr(C)]
pub struct LoaderEvent {
	pub type_: LoaderEventType,
}
#[test]
fn bindgen_test_layout_LoaderEvent() {
	assert_eq!(
	           ::core::mem::size_of::<LoaderEvent>(),
	           4usize,
	           concat!("Size of: ", stringify!(LoaderEvent))
	);
	assert_eq!(
	           ::core::mem::align_of::<LoaderEvent>(),
	           4usize,
	           concat!("Alignment of ", stringify!(LoaderEvent))
	);
	fn test_field_type() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LoaderEvent>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(LoaderEvent), "::", stringify!(type_))
		);
	}
	test_field_type();
}
extern "C" {
	#[doc = " Start application"]
	#[doc = " @param name - application name"]
	#[doc = " @param args - application arguments"]
	#[doc = " @retval true on success"]
	pub fn loader_start(instance: *mut Loader, name: *const core::ffi::c_char, args: *const core::ffi::c_char) -> LoaderStatus;
}
extern "C" {
	#[doc = " Lock application start"]
	#[doc = " @retval true on success"]
	pub fn loader_lock(instance: *mut Loader) -> bool;
}
extern "C" {
	#[doc = " Unlock application start"]
	pub fn loader_unlock(instance: *mut Loader);
}
extern "C" {
	#[doc = " Get loader lock status"]
	pub fn loader_is_locked(instance: *mut Loader) -> bool;
}
extern "C" {
	#[doc = " Show primary loader"]
	pub fn loader_show_menu();
}
extern "C" {
	#[doc = " Show primary loader"]
	pub fn loader_update_menu();
}
extern "C" {
	#[doc = " Show primary loader"]
	pub fn loader_get_pubsub(instance: *mut Loader) -> *mut FuriPubSub;
}
#[repr(C)]
pub struct NotificationApp {
	_unused: [u8; 0],
}
#[repr(C)]
pub struct NotificationMessageDataSound {
	pub frequency: core::ffi::c_float,
	pub volume: core::ffi::c_float,
}
#[test]
fn bindgen_test_layout_NotificationMessageDataSound() {
	assert_eq!(
	           ::core::mem::size_of::<NotificationMessageDataSound>(),
	           8usize,
	           concat!("Size of: ", stringify!(NotificationMessageDataSound))
	);
	assert_eq!(
	           ::core::mem::align_of::<NotificationMessageDataSound>(),
	           4usize,
	           concat!("Alignment of ", stringify!(NotificationMessageDataSound))
	);
	fn test_field_frequency() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<NotificationMessageDataSound>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).frequency) as usize - ptr as usize
		           },
		           0usize,
		           concat!(
			"Offset of field: ",
			stringify!(NotificationMessageDataSound),
			"::",
			stringify!(frequency)
		)
		);
	}
	test_field_frequency();
	fn test_field_volume() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<NotificationMessageDataSound>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).volume) as usize - ptr as usize
		           },
		           4usize,
		           concat!(
			"Offset of field: ",
			stringify!(NotificationMessageDataSound),
			"::",
			stringify!(volume)
		)
		);
	}
	test_field_volume();
}
#[repr(C)]
pub struct NotificationMessageDataLed {
	pub value: u8,
}
#[test]
fn bindgen_test_layout_NotificationMessageDataLed() {
	assert_eq!(
	           ::core::mem::size_of::<NotificationMessageDataLed>(),
	           1usize,
	           concat!("Size of: ", stringify!(NotificationMessageDataLed))
	);
	assert_eq!(
	           ::core::mem::align_of::<NotificationMessageDataLed>(),
	           1usize,
	           concat!("Alignment of ", stringify!(NotificationMessageDataLed))
	);
	fn test_field_value() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<NotificationMessageDataLed>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).value) as usize - ptr as usize
		           },
		           0usize,
		           concat!(
			"Offset of field: ",
			stringify!(NotificationMessageDataLed),
			"::",
			stringify!(value)
		)
		);
	}
	test_field_value();
}
#[repr(C)]
pub struct NotificationMessageDataVibro {
	pub on: bool,
}
#[test]
fn bindgen_test_layout_NotificationMessageDataVibro() {
	assert_eq!(
	           ::core::mem::size_of::<NotificationMessageDataVibro>(),
	           1usize,
	           concat!("Size of: ", stringify!(NotificationMessageDataVibro))
	);
	assert_eq!(
	           ::core::mem::align_of::<NotificationMessageDataVibro>(),
	           1usize,
	           concat!("Alignment of ", stringify!(NotificationMessageDataVibro))
	);
	fn test_field_on() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<NotificationMessageDataVibro>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).on) as usize - ptr as usize
		           },
		           0usize,
		           concat!(
			"Offset of field: ",
			stringify!(NotificationMessageDataVibro),
			"::",
			stringify!(on)
		)
		);
	}
	test_field_on();
}
#[repr(C)]
pub struct NotificationMessageDataDelay {
	pub length: u32,
}
#[test]
fn bindgen_test_layout_NotificationMessageDataDelay() {
	assert_eq!(
	           ::core::mem::size_of::<NotificationMessageDataDelay>(),
	           4usize,
	           concat!("Size of: ", stringify!(NotificationMessageDataDelay))
	);
	assert_eq!(
	           ::core::mem::align_of::<NotificationMessageDataDelay>(),
	           4usize,
	           concat!("Alignment of ", stringify!(NotificationMessageDataDelay))
	);
	fn test_field_length() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<NotificationMessageDataDelay>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).length) as usize - ptr as usize
		           },
		           0usize,
		           concat!(
			"Offset of field: ",
			stringify!(NotificationMessageDataDelay),
			"::",
			stringify!(length)
		)
		);
	}
	test_field_length();
}
#[repr(C)]
pub struct NotificationMessageDataForcedSettings {
	pub speaker_volume: core::ffi::c_float,
	pub vibro: bool,
	pub display_brightness: core::ffi::c_float,
}
#[test]
fn bindgen_test_layout_NotificationMessageDataForcedSettings() {
	assert_eq!(
	           ::core::mem::size_of::<NotificationMessageDataForcedSettings>(),
	           12usize,
	           concat!("Size of: ", stringify!(NotificationMessageDataForcedSettings))
	);
	assert_eq!(
	           ::core::mem::align_of::<NotificationMessageDataForcedSettings>(),
	           4usize,
	           concat!("Alignment of ", stringify!(NotificationMessageDataForcedSettings))
	);
	fn test_field_speaker_volume() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<NotificationMessageDataForcedSettings>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).speaker_volume) as usize - ptr as usize
		           },
		           0usize,
		           concat!(
			"Offset of field: ",
			stringify!(NotificationMessageDataForcedSettings),
			"::",
			stringify!(speaker_volume)
		)
		);
	}
	test_field_speaker_volume();
	fn test_field_vibro() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<NotificationMessageDataForcedSettings>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).vibro) as usize - ptr as usize
		           },
		           4usize,
		           concat!(
			"Offset of field: ",
			stringify!(NotificationMessageDataForcedSettings),
			"::",
			stringify!(vibro)
		)
		);
	}
	test_field_vibro();
	fn test_field_display_brightness() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<NotificationMessageDataForcedSettings>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).display_brightness) as usize - ptr as usize
		           },
		           8usize,
		           concat!(
			"Offset of field: ",
			stringify!(NotificationMessageDataForcedSettings),
			"::",
			stringify!(display_brightness)
		)
		);
	}
	test_field_display_brightness();
}
#[repr(C)]
pub struct NotificationMessageDataLedBlink {
	pub on_time: u16,
	pub period: u16,
	pub color: Light,
}
#[test]
fn bindgen_test_layout_NotificationMessageDataLedBlink() {
	assert_eq!(
	           ::core::mem::size_of::<NotificationMessageDataLedBlink>(),
	           8usize,
	           concat!("Size of: ", stringify!(NotificationMessageDataLedBlink))
	);
	assert_eq!(
	           ::core::mem::align_of::<NotificationMessageDataLedBlink>(),
	           4usize,
	           concat!("Alignment of ", stringify!(NotificationMessageDataLedBlink))
	);
	fn test_field_on_time() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<NotificationMessageDataLedBlink>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).on_time) as usize - ptr as usize
		           },
		           0usize,
		           concat!(
			"Offset of field: ",
			stringify!(NotificationMessageDataLedBlink),
			"::",
			stringify!(on_time)
		)
		);
	}
	test_field_on_time();
	fn test_field_period() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<NotificationMessageDataLedBlink>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).period) as usize - ptr as usize
		           },
		           2usize,
		           concat!(
			"Offset of field: ",
			stringify!(NotificationMessageDataLedBlink),
			"::",
			stringify!(period)
		)
		);
	}
	test_field_period();
	fn test_field_color() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<NotificationMessageDataLedBlink>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).color) as usize - ptr as usize
		           },
		           4usize,
		           concat!(
			"Offset of field: ",
			stringify!(NotificationMessageDataLedBlink),
			"::",
			stringify!(color)
		)
		);
	}
	test_field_color();
}
#[repr(C)]
pub struct NotificationMessageData {
	pub sound: __BindgenUnionField<NotificationMessageDataSound>,
	pub led: __BindgenUnionField<NotificationMessageDataLed>,
	pub led_blink: __BindgenUnionField<NotificationMessageDataLedBlink>,
	pub vibro: __BindgenUnionField<NotificationMessageDataVibro>,
	pub delay: __BindgenUnionField<NotificationMessageDataDelay>,
	pub forced_settings: __BindgenUnionField<NotificationMessageDataForcedSettings>,
	pub bindgen_union_field: [u32; 3usize],
}
#[test]
fn bindgen_test_layout_NotificationMessageData() {
	assert_eq!(
	           ::core::mem::size_of::<NotificationMessageData>(),
	           12usize,
	           concat!("Size of: ", stringify!(NotificationMessageData))
	);
	assert_eq!(
	           ::core::mem::align_of::<NotificationMessageData>(),
	           4usize,
	           concat!("Alignment of ", stringify!(NotificationMessageData))
	);
	fn test_field_sound() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<NotificationMessageData>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).sound) as usize - ptr as usize
		           },
		           0usize,
		           concat!(
			"Offset of field: ",
			stringify!(NotificationMessageData),
			"::",
			stringify!(sound)
		)
		);
	}
	test_field_sound();
	fn test_field_led() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<NotificationMessageData>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).led) as usize - ptr as usize
		           },
		           0usize,
		           concat!(
			"Offset of field: ",
			stringify!(NotificationMessageData),
			"::",
			stringify!(led)
		)
		);
	}
	test_field_led();
	fn test_field_led_blink() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<NotificationMessageData>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).led_blink) as usize - ptr as usize
		           },
		           0usize,
		           concat!(
			"Offset of field: ",
			stringify!(NotificationMessageData),
			"::",
			stringify!(led_blink)
		)
		);
	}
	test_field_led_blink();
	fn test_field_vibro() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<NotificationMessageData>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).vibro) as usize - ptr as usize
		           },
		           0usize,
		           concat!(
			"Offset of field: ",
			stringify!(NotificationMessageData),
			"::",
			stringify!(vibro)
		)
		);
	}
	test_field_vibro();
	fn test_field_delay() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<NotificationMessageData>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).delay) as usize - ptr as usize
		           },
		           0usize,
		           concat!(
			"Offset of field: ",
			stringify!(NotificationMessageData),
			"::",
			stringify!(delay)
		)
		);
	}
	test_field_delay();
	fn test_field_forced_settings() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<NotificationMessageData>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).forced_settings) as usize - ptr as usize
		           },
		           0usize,
		           concat!(
			"Offset of field: ",
			stringify!(NotificationMessageData),
			"::",
			stringify!(forced_settings)
		)
		);
	}
	test_field_forced_settings();
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum NotificationMessageType {
	NotificationMessageTypeVibro = 0,
	NotificationMessageTypeSoundOn = 1,
	NotificationMessageTypeSoundOff = 2,
	NotificationMessageTypeLedRed = 3,
	NotificationMessageTypeLedGreen = 4,
	NotificationMessageTypeLedBlue = 5,
	NotificationMessageTypeLedBlinkStart = 6,
	NotificationMessageTypeLedBlinkStop = 7,
	NotificationMessageTypeLedBlinkColor = 8,
	NotificationMessageTypeDelay = 9,
	NotificationMessageTypeLedDisplayBacklight = 10,
	NotificationMessageTypeLedDisplayBacklightEnforceOn = 11,
	NotificationMessageTypeLedDisplayBacklightEnforceAuto = 12,
	NotificationMessageTypeDoNotReset = 13,
	NotificationMessageTypeForceSpeakerVolumeSetting = 14,
	NotificationMessageTypeForceVibroSetting = 15,
	NotificationMessageTypeForceDisplayBrightnessSetting = 16,
	NotificationMessageTypeLedBrightnessSettingApply = 17,
}
#[repr(C)]
pub struct NotificationMessage {
	pub type_: NotificationMessageType,
	pub data: NotificationMessageData,
}
#[test]
fn bindgen_test_layout_NotificationMessage() {
	assert_eq!(
	           ::core::mem::size_of::<NotificationMessage>(),
	           16usize,
	           concat!("Size of: ", stringify!(NotificationMessage))
	);
	assert_eq!(
	           ::core::mem::align_of::<NotificationMessage>(),
	           4usize,
	           concat!("Alignment of ", stringify!(NotificationMessage))
	);
	fn test_field_type() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<NotificationMessage>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(NotificationMessage), "::", stringify!(type_))
		);
	}
	test_field_type();
	fn test_field_data() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<NotificationMessage>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).data) as usize - ptr as usize
		           },
		           4usize,
		           concat!("Offset of field: ", stringify!(NotificationMessage), "::", stringify!(data))
		);
	}
	test_field_data();
}
pub type NotificationSequence = [*const NotificationMessage; 0usize];
extern "C" {
	pub fn notification_message(app: *mut NotificationApp, sequence: *const NotificationSequence);
}
extern "C" {
	pub fn notification_message_block(app: *mut NotificationApp, sequence: *const NotificationSequence);
}
extern "C" {
	#[doc = " @brief Send internal (apply to permanent layer) notification message. Think twice before use."]
	#[doc = ""]
	#[doc = " @param app notification record content"]
	#[doc = " @param sequence notification sequence"]
	pub fn notification_internal_message(app: *mut NotificationApp, sequence: *const NotificationSequence);
}
extern "C" {
	#[doc = " @brief Send internal (apply to permanent layer) notification message and wait for notification end. Think twice before use."]
	#[doc = ""]
	#[doc = " @param app notification record content"]
	#[doc = " @param sequence notification sequence"]
	pub fn notification_internal_message_block(app: *mut NotificationApp, sequence: *const NotificationSequence);
}
extern "C" {
	pub static message_click: NotificationMessage;
}
extern "C" {
	pub static message_note_c0: NotificationMessage;
}
extern "C" {
	pub static message_note_cs0: NotificationMessage;
}
extern "C" {
	pub static message_note_d0: NotificationMessage;
}
extern "C" {
	pub static message_note_ds0: NotificationMessage;
}
extern "C" {
	pub static message_note_e0: NotificationMessage;
}
extern "C" {
	pub static message_note_f0: NotificationMessage;
}
extern "C" {
	pub static message_note_fs0: NotificationMessage;
}
extern "C" {
	pub static message_note_g0: NotificationMessage;
}
extern "C" {
	pub static message_note_gs0: NotificationMessage;
}
extern "C" {
	pub static message_note_a0: NotificationMessage;
}
extern "C" {
	pub static message_note_as0: NotificationMessage;
}
extern "C" {
	pub static message_note_b0: NotificationMessage;
}
extern "C" {
	pub static message_note_c1: NotificationMessage;
}
extern "C" {
	pub static message_note_cs1: NotificationMessage;
}
extern "C" {
	pub static message_note_d1: NotificationMessage;
}
extern "C" {
	pub static message_note_ds1: NotificationMessage;
}
extern "C" {
	pub static message_note_e1: NotificationMessage;
}
extern "C" {
	pub static message_note_f1: NotificationMessage;
}
extern "C" {
	pub static message_note_fs1: NotificationMessage;
}
extern "C" {
	pub static message_note_g1: NotificationMessage;
}
extern "C" {
	pub static message_note_gs1: NotificationMessage;
}
extern "C" {
	pub static message_note_a1: NotificationMessage;
}
extern "C" {
	pub static message_note_as1: NotificationMessage;
}
extern "C" {
	pub static message_note_b1: NotificationMessage;
}
extern "C" {
	pub static message_note_c2: NotificationMessage;
}
extern "C" {
	pub static message_note_cs2: NotificationMessage;
}
extern "C" {
	pub static message_note_d2: NotificationMessage;
}
extern "C" {
	pub static message_note_ds2: NotificationMessage;
}
extern "C" {
	pub static message_note_e2: NotificationMessage;
}
extern "C" {
	pub static message_note_f2: NotificationMessage;
}
extern "C" {
	pub static message_note_fs2: NotificationMessage;
}
extern "C" {
	pub static message_note_g2: NotificationMessage;
}
extern "C" {
	pub static message_note_gs2: NotificationMessage;
}
extern "C" {
	pub static message_note_a2: NotificationMessage;
}
extern "C" {
	pub static message_note_as2: NotificationMessage;
}
extern "C" {
	pub static message_note_b2: NotificationMessage;
}
extern "C" {
	pub static message_note_c3: NotificationMessage;
}
extern "C" {
	pub static message_note_cs3: NotificationMessage;
}
extern "C" {
	pub static message_note_d3: NotificationMessage;
}
extern "C" {
	pub static message_note_ds3: NotificationMessage;
}
extern "C" {
	pub static message_note_e3: NotificationMessage;
}
extern "C" {
	pub static message_note_f3: NotificationMessage;
}
extern "C" {
	pub static message_note_fs3: NotificationMessage;
}
extern "C" {
	pub static message_note_g3: NotificationMessage;
}
extern "C" {
	pub static message_note_gs3: NotificationMessage;
}
extern "C" {
	pub static message_note_a3: NotificationMessage;
}
extern "C" {
	pub static message_note_as3: NotificationMessage;
}
extern "C" {
	pub static message_note_b3: NotificationMessage;
}
extern "C" {
	pub static message_note_c4: NotificationMessage;
}
extern "C" {
	pub static message_note_cs4: NotificationMessage;
}
extern "C" {
	pub static message_note_d4: NotificationMessage;
}
extern "C" {
	pub static message_note_ds4: NotificationMessage;
}
extern "C" {
	pub static message_note_e4: NotificationMessage;
}
extern "C" {
	pub static message_note_f4: NotificationMessage;
}
extern "C" {
	pub static message_note_fs4: NotificationMessage;
}
extern "C" {
	pub static message_note_g4: NotificationMessage;
}
extern "C" {
	pub static message_note_gs4: NotificationMessage;
}
extern "C" {
	pub static message_note_a4: NotificationMessage;
}
extern "C" {
	pub static message_note_as4: NotificationMessage;
}
extern "C" {
	pub static message_note_b4: NotificationMessage;
}
extern "C" {
	pub static message_note_c5: NotificationMessage;
}
extern "C" {
	pub static message_note_cs5: NotificationMessage;
}
extern "C" {
	pub static message_note_d5: NotificationMessage;
}
extern "C" {
	pub static message_note_ds5: NotificationMessage;
}
extern "C" {
	pub static message_note_e5: NotificationMessage;
}
extern "C" {
	pub static message_note_f5: NotificationMessage;
}
extern "C" {
	pub static message_note_fs5: NotificationMessage;
}
extern "C" {
	pub static message_note_g5: NotificationMessage;
}
extern "C" {
	pub static message_note_gs5: NotificationMessage;
}
extern "C" {
	pub static message_note_a5: NotificationMessage;
}
extern "C" {
	pub static message_note_as5: NotificationMessage;
}
extern "C" {
	pub static message_note_b5: NotificationMessage;
}
extern "C" {
	pub static message_note_c6: NotificationMessage;
}
extern "C" {
	pub static message_note_cs6: NotificationMessage;
}
extern "C" {
	pub static message_note_d6: NotificationMessage;
}
extern "C" {
	pub static message_note_ds6: NotificationMessage;
}
extern "C" {
	pub static message_note_e6: NotificationMessage;
}
extern "C" {
	pub static message_note_f6: NotificationMessage;
}
extern "C" {
	pub static message_note_fs6: NotificationMessage;
}
extern "C" {
	pub static message_note_g6: NotificationMessage;
}
extern "C" {
	pub static message_note_gs6: NotificationMessage;
}
extern "C" {
	pub static message_note_a6: NotificationMessage;
}
extern "C" {
	pub static message_note_as6: NotificationMessage;
}
extern "C" {
	pub static message_note_b6: NotificationMessage;
}
extern "C" {
	pub static message_note_c7: NotificationMessage;
}
extern "C" {
	pub static message_note_cs7: NotificationMessage;
}
extern "C" {
	pub static message_note_d7: NotificationMessage;
}
extern "C" {
	pub static message_note_ds7: NotificationMessage;
}
extern "C" {
	pub static message_note_e7: NotificationMessage;
}
extern "C" {
	pub static message_note_f7: NotificationMessage;
}
extern "C" {
	pub static message_note_fs7: NotificationMessage;
}
extern "C" {
	pub static message_note_g7: NotificationMessage;
}
extern "C" {
	pub static message_note_gs7: NotificationMessage;
}
extern "C" {
	pub static message_note_a7: NotificationMessage;
}
extern "C" {
	pub static message_note_as7: NotificationMessage;
}
extern "C" {
	pub static message_note_b7: NotificationMessage;
}
extern "C" {
	pub static message_note_c8: NotificationMessage;
}
extern "C" {
	pub static message_note_cs8: NotificationMessage;
}
extern "C" {
	pub static message_note_d8: NotificationMessage;
}
extern "C" {
	pub static message_note_ds8: NotificationMessage;
}
extern "C" {
	pub static message_note_e8: NotificationMessage;
}
extern "C" {
	pub static message_note_f8: NotificationMessage;
}
extern "C" {
	pub static message_note_fs8: NotificationMessage;
}
extern "C" {
	pub static message_note_g8: NotificationMessage;
}
extern "C" {
	pub static message_note_gs8: NotificationMessage;
}
extern "C" {
	pub static message_note_a8: NotificationMessage;
}
extern "C" {
	pub static message_note_as8: NotificationMessage;
}
extern "C" {
	pub static message_note_b8: NotificationMessage;
}
extern "C" {
	#[doc = " Messages"]
	pub static message_display_backlight_on: NotificationMessage;
}
extern "C" {
	pub static message_display_backlight_off: NotificationMessage;
}
extern "C" {
	pub static message_display_backlight_enforce_on: NotificationMessage;
}
extern "C" {
	pub static message_display_backlight_enforce_auto: NotificationMessage;
}
extern "C" {
	pub static message_red_255: NotificationMessage;
}
extern "C" {
	pub static message_green_255: NotificationMessage;
}
extern "C" {
	pub static message_blue_255: NotificationMessage;
}
extern "C" {
	pub static message_red_0: NotificationMessage;
}
extern "C" {
	pub static message_green_0: NotificationMessage;
}
extern "C" {
	pub static message_blue_0: NotificationMessage;
}
extern "C" {
	pub static message_blink_start_10: NotificationMessage;
}
extern "C" {
	pub static message_blink_start_100: NotificationMessage;
}
extern "C" {
	pub static message_blink_stop: NotificationMessage;
}
extern "C" {
	pub static message_blink_set_color_red: NotificationMessage;
}
extern "C" {
	pub static message_blink_set_color_green: NotificationMessage;
}
extern "C" {
	pub static message_blink_set_color_blue: NotificationMessage;
}
extern "C" {
	pub static message_blink_set_color_cyan: NotificationMessage;
}
extern "C" {
	pub static message_blink_set_color_magenta: NotificationMessage;
}
extern "C" {
	pub static message_blink_set_color_yellow: NotificationMessage;
}
extern "C" {
	pub static message_blink_set_color_white: NotificationMessage;
}
extern "C" {
	pub static message_delay_1: NotificationMessage;
}
extern "C" {
	pub static message_delay_10: NotificationMessage;
}
extern "C" {
	pub static message_delay_25: NotificationMessage;
}
extern "C" {
	pub static message_delay_50: NotificationMessage;
}
extern "C" {
	pub static message_delay_100: NotificationMessage;
}
extern "C" {
	pub static message_delay_250: NotificationMessage;
}
extern "C" {
	pub static message_delay_500: NotificationMessage;
}
extern "C" {
	pub static message_delay_1000: NotificationMessage;
}
extern "C" {
	pub static message_sound_off: NotificationMessage;
}
extern "C" {
	pub static message_vibro_on: NotificationMessage;
}
extern "C" {
	pub static message_vibro_off: NotificationMessage;
}
extern "C" {
	pub static message_do_not_reset: NotificationMessage;
}
extern "C" {
	pub static message_force_speaker_volume_setting_1f: NotificationMessage;
}
extern "C" {
	pub static message_force_vibro_setting_on: NotificationMessage;
}
extern "C" {
	pub static message_force_vibro_setting_off: NotificationMessage;
}
extern "C" {
	pub static message_force_display_brightness_setting_1f: NotificationMessage;
}
extern "C" {
	#[doc = " Message sequences"]
	pub static sequence_reset_red: NotificationSequence;
}
extern "C" {
	pub static sequence_reset_green: NotificationSequence;
}
extern "C" {
	pub static sequence_reset_blue: NotificationSequence;
}
extern "C" {
	pub static sequence_reset_rgb: NotificationSequence;
}
extern "C" {
	pub static sequence_reset_display: NotificationSequence;
}
extern "C" {
	pub static sequence_reset_sound: NotificationSequence;
}
extern "C" {
	pub static sequence_reset_vibro: NotificationSequence;
}
extern "C" {
	pub static sequence_set_vibro_on: NotificationSequence;
}
extern "C" {
	#[doc = " Display: backlight wakeup"]
	pub static sequence_display_backlight_on: NotificationSequence;
}
extern "C" {
	#[doc = " Display: backlight force off"]
	pub static sequence_display_backlight_off: NotificationSequence;
}
extern "C" {
	#[doc = " Display: backlight force off after a delay of 1000ms"]
	pub static sequence_display_backlight_off_delay_1000: NotificationSequence;
}
extern "C" {
	#[doc = " Display: backlight always on lock"]
	pub static sequence_display_backlight_enforce_on: NotificationSequence;
}
extern "C" {
	#[doc = " Display: backlight always on unlock"]
	pub static sequence_display_backlight_enforce_auto: NotificationSequence;
}
extern "C" {
	pub static sequence_charging: NotificationSequence;
}
extern "C" {
	pub static sequence_charged: NotificationSequence;
}
extern "C" {
	pub static sequence_not_charging: NotificationSequence;
}
extern "C" {
	pub static sequence_set_only_red_255: NotificationSequence;
}
extern "C" {
	pub static sequence_set_only_green_255: NotificationSequence;
}
extern "C" {
	pub static sequence_set_only_blue_255: NotificationSequence;
}
extern "C" {
	pub static sequence_set_red_255: NotificationSequence;
}
extern "C" {
	pub static sequence_set_green_255: NotificationSequence;
}
extern "C" {
	pub static sequence_set_blue_255: NotificationSequence;
}
extern "C" {
	pub static sequence_solid_yellow: NotificationSequence;
}
extern "C" {
	pub static sequence_blink_blue_10: NotificationSequence;
}
extern "C" {
	pub static sequence_blink_red_10: NotificationSequence;
}
extern "C" {
	pub static sequence_blink_green_10: NotificationSequence;
}
extern "C" {
	pub static sequence_blink_yellow_10: NotificationSequence;
}
extern "C" {
	pub static sequence_blink_cyan_10: NotificationSequence;
}
extern "C" {
	pub static sequence_blink_magenta_10: NotificationSequence;
}
extern "C" {
	pub static sequence_blink_red_100: NotificationSequence;
}
extern "C" {
	pub static sequence_blink_green_100: NotificationSequence;
}
extern "C" {
	pub static sequence_blink_blue_100: NotificationSequence;
}
extern "C" {
	pub static sequence_blink_yellow_100: NotificationSequence;
}
extern "C" {
	pub static sequence_blink_cyan_100: NotificationSequence;
}
extern "C" {
	pub static sequence_blink_magenta_100: NotificationSequence;
}
extern "C" {
	pub static sequence_blink_white_100: NotificationSequence;
}
extern "C" {
	pub static sequence_blink_start_blue: NotificationSequence;
}
extern "C" {
	pub static sequence_blink_start_red: NotificationSequence;
}
extern "C" {
	pub static sequence_blink_start_green: NotificationSequence;
}
extern "C" {
	pub static sequence_blink_start_yellow: NotificationSequence;
}
extern "C" {
	pub static sequence_blink_start_cyan: NotificationSequence;
}
extern "C" {
	pub static sequence_blink_start_magenta: NotificationSequence;
}
extern "C" {
	pub static sequence_blink_stop: NotificationSequence;
}
extern "C" {
	pub static sequence_single_vibro: NotificationSequence;
}
extern "C" {
	pub static sequence_double_vibro: NotificationSequence;
}
extern "C" {
	pub static sequence_success: NotificationSequence;
}
extern "C" {
	pub static sequence_error: NotificationSequence;
}
extern "C" {
	pub static sequence_audiovisual_alert: NotificationSequence;
}
#[repr(C)]
pub struct Power {
	_unused: [u8; 0],
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum PowerBootMode {
	PowerBootModeNormal = 0,
	PowerBootModeDfu = 1,
	PowerBootModeUpdateStart = 2,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum PowerEventType {
	PowerEventTypeStopCharging = 0,
	PowerEventTypeStartCharging = 1,
	PowerEventTypeFullyCharged = 2,
	PowerEventTypeBatteryLevelChanged = 3,
}
#[repr(C)]
pub struct PowerEventData {
	pub battery_level: __BindgenUnionField<u8>,
	pub bindgen_union_field: u8,
}
#[test]
fn bindgen_test_layout_PowerEventData() {
	assert_eq!(
	           ::core::mem::size_of::<PowerEventData>(),
	           1usize,
	           concat!("Size of: ", stringify!(PowerEventData))
	);
	assert_eq!(
	           ::core::mem::align_of::<PowerEventData>(),
	           1usize,
	           concat!("Alignment of ", stringify!(PowerEventData))
	);
	fn test_field_battery_level() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<PowerEventData>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).battery_level) as usize - ptr as usize
		           },
		           0usize,
		           concat!(
			"Offset of field: ",
			stringify!(PowerEventData),
			"::",
			stringify!(battery_level)
		)
		);
	}
	test_field_battery_level();
}
#[repr(C)]
pub struct PowerEvent {
	pub type_: PowerEventType,
	pub data: PowerEventData,
}
#[test]
fn bindgen_test_layout_PowerEvent() {
	assert_eq!(
	           ::core::mem::size_of::<PowerEvent>(),
	           8usize,
	           concat!("Size of: ", stringify!(PowerEvent))
	);
	assert_eq!(
	           ::core::mem::align_of::<PowerEvent>(),
	           4usize,
	           concat!("Alignment of ", stringify!(PowerEvent))
	);
	fn test_field_type() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<PowerEvent>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(PowerEvent), "::", stringify!(type_))
		);
	}
	test_field_type();
	fn test_field_data() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<PowerEvent>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).data) as usize - ptr as usize
		           },
		           4usize,
		           concat!("Offset of field: ", stringify!(PowerEvent), "::", stringify!(data))
		);
	}
	test_field_data();
}
#[repr(C)]
pub struct PowerInfo {
	pub gauge_is_ok: bool,
	pub is_charging: bool,
	pub current_charger: core::ffi::c_float,
	pub current_gauge: core::ffi::c_float,
	pub voltage_charger: core::ffi::c_float,
	pub voltage_gauge: core::ffi::c_float,
	pub voltage_vbus: core::ffi::c_float,
	pub capacity_remaining: u32,
	pub capacity_full: u32,
	pub temperature_charger: core::ffi::c_float,
	pub temperature_gauge: core::ffi::c_float,
	pub charge: u8,
	pub health: u8,
}
#[test]
fn bindgen_test_layout_PowerInfo() {
	assert_eq!(
	           ::core::mem::size_of::<PowerInfo>(),
	           44usize,
	           concat!("Size of: ", stringify!(PowerInfo))
	);
	assert_eq!(
	           ::core::mem::align_of::<PowerInfo>(),
	           4usize,
	           concat!("Alignment of ", stringify!(PowerInfo))
	);
	fn test_field_gauge_is_ok() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<PowerInfo>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).gauge_is_ok) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(PowerInfo), "::", stringify!(gauge_is_ok))
		);
	}
	test_field_gauge_is_ok();
	fn test_field_is_charging() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<PowerInfo>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).is_charging) as usize - ptr as usize
		           },
		           1usize,
		           concat!("Offset of field: ", stringify!(PowerInfo), "::", stringify!(is_charging))
		);
	}
	test_field_is_charging();
	fn test_field_current_charger() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<PowerInfo>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).current_charger) as usize - ptr as usize
		           },
		           4usize,
		           concat!("Offset of field: ", stringify!(PowerInfo), "::", stringify!(current_charger))
		);
	}
	test_field_current_charger();
	fn test_field_current_gauge() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<PowerInfo>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).current_gauge) as usize - ptr as usize
		           },
		           8usize,
		           concat!("Offset of field: ", stringify!(PowerInfo), "::", stringify!(current_gauge))
		);
	}
	test_field_current_gauge();
	fn test_field_voltage_charger() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<PowerInfo>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).voltage_charger) as usize - ptr as usize
		           },
		           12usize,
		           concat!("Offset of field: ", stringify!(PowerInfo), "::", stringify!(voltage_charger))
		);
	}
	test_field_voltage_charger();
	fn test_field_voltage_gauge() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<PowerInfo>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).voltage_gauge) as usize - ptr as usize
		           },
		           16usize,
		           concat!("Offset of field: ", stringify!(PowerInfo), "::", stringify!(voltage_gauge))
		);
	}
	test_field_voltage_gauge();
	fn test_field_voltage_vbus() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<PowerInfo>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).voltage_vbus) as usize - ptr as usize
		           },
		           20usize,
		           concat!("Offset of field: ", stringify!(PowerInfo), "::", stringify!(voltage_vbus))
		);
	}
	test_field_voltage_vbus();
	fn test_field_capacity_remaining() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<PowerInfo>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).capacity_remaining) as usize - ptr as usize
		           },
		           24usize,
		           concat!(
			"Offset of field: ",
			stringify!(PowerInfo),
			"::",
			stringify!(capacity_remaining)
		)
		);
	}
	test_field_capacity_remaining();
	fn test_field_capacity_full() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<PowerInfo>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).capacity_full) as usize - ptr as usize
		           },
		           28usize,
		           concat!("Offset of field: ", stringify!(PowerInfo), "::", stringify!(capacity_full))
		);
	}
	test_field_capacity_full();
	fn test_field_temperature_charger() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<PowerInfo>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).temperature_charger) as usize - ptr as usize
		           },
		           32usize,
		           concat!(
			"Offset of field: ",
			stringify!(PowerInfo),
			"::",
			stringify!(temperature_charger)
		)
		);
	}
	test_field_temperature_charger();
	fn test_field_temperature_gauge() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<PowerInfo>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).temperature_gauge) as usize - ptr as usize
		           },
		           36usize,
		           concat!(
			"Offset of field: ",
			stringify!(PowerInfo),
			"::",
			stringify!(temperature_gauge)
		)
		);
	}
	test_field_temperature_gauge();
	fn test_field_charge() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<PowerInfo>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).charge) as usize - ptr as usize
		           },
		           40usize,
		           concat!("Offset of field: ", stringify!(PowerInfo), "::", stringify!(charge))
		);
	}
	test_field_charge();
	fn test_field_health() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<PowerInfo>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).health) as usize - ptr as usize
		           },
		           41usize,
		           concat!("Offset of field: ", stringify!(PowerInfo), "::", stringify!(health))
		);
	}
	test_field_health();
}
extern "C" {
	#[doc = " Power off device"]
	pub fn power_off(power: *mut Power);
}
extern "C" {
	#[doc = " Reboot device"]
	#[doc = ""]
	#[doc = " @param mode      PowerBootMode"]
	pub fn power_reboot(mode: PowerBootMode);
}
extern "C" {
	#[doc = " Get power info"]
	#[doc = ""]
	#[doc = " @param power     Power instance"]
	#[doc = " @param info      PowerInfo instance"]
	pub fn power_get_info(power: *mut Power, info: *mut PowerInfo);
}
extern "C" {
	#[doc = " Get power event pubsub handler"]
	#[doc = ""]
	#[doc = " @param power     Power instance"]
	#[doc = ""]
	#[doc = " @return          FuriPubSub instance"]
	pub fn power_get_pubsub(power: *mut Power) -> *mut FuriPubSub;
}
extern "C" {
	#[doc = " Check battery health"]
	#[doc = ""]
	#[doc = " @return          true if battery is healthy"]
	pub fn power_is_battery_healthy(power: *mut Power) -> bool;
}
extern "C" {
	#[doc = " Enable or disable battery low level notification mesage"]
	#[doc = ""]
	#[doc = " @param power     Power instance"]
	#[doc = " @param enable    true - enable, false - disable"]
	pub fn power_enable_low_battery_level_notification(power: *mut Power, enable: bool);
}
#[repr(C)]
pub struct Rpc {
	_unused: [u8; 0],
}
#[repr(C)]
pub struct RpcSession {
	_unused: [u8; 0],
}
#[doc = " Callback to send to client any data (e.g. response to command)"]
pub type RpcSendBytesCallback =
	::core::option::Option<unsafe extern "C" fn(context: *mut core::ffi::c_void, bytes: *mut u8, bytes_len: usize)>;
#[doc = " Callback to notify client that buffer is empty"]
pub type RpcBufferIsEmptyCallback = ::core::option::Option<unsafe extern "C" fn(context: *mut core::ffi::c_void)>;
#[doc = " Callback to notify transport layer that close_session command"]
#[doc = " is received. Any other actions lays on transport layer."]
#[doc = " No destruction or session close preformed."]
pub type RpcSessionClosedCallback = ::core::option::Option<unsafe extern "C" fn(context: *mut core::ffi::c_void)>;
#[doc = " Callback to notify transport layer that session was closed"]
#[doc = " and all operations were finished"]
pub type RpcSessionTerminatedCallback = ::core::option::Option<unsafe extern "C" fn(context: *mut core::ffi::c_void)>;
extern "C" {
	#[doc = " Open RPC session"]
	#[doc = ""]
	#[doc = " USAGE:"]
	#[doc = " 1) rpc_session_open();"]
	#[doc = " 2) rpc_session_set_context();"]
	#[doc = " 3) rpc_session_set_send_bytes_callback();"]
	#[doc = " 4) rpc_session_set_close_callback();"]
	#[doc = " 5) while(1) {"]
	#[doc = "      rpc_session_feed();"]
	#[doc = "    }"]
	#[doc = " 6) rpc_session_close();"]
	#[doc = ""]
	#[doc = ""]
	#[doc = " @param   rpc     instance"]
	#[doc = " @return          pointer to RpcSession descriptor, or"]
	#[doc = "                  NULL if RPC is busy and can't open session now"]
	pub fn rpc_session_open(rpc: *mut Rpc) -> *mut RpcSession;
}
extern "C" {
	#[doc = " Close RPC session"]
	#[doc = " It is guaranteed that no callbacks will be called"]
	#[doc = " as soon as session is closed. So no need in setting"]
	#[doc = " callbacks to NULL after session close."]
	#[doc = ""]
	#[doc = " @param   session     pointer to RpcSession descriptor"]
	pub fn rpc_session_close(session: *mut RpcSession);
}
extern "C" {
	#[doc = " Set session context for callbacks to pass"]
	#[doc = ""]
	#[doc = " @param   session     pointer to RpcSession descriptor"]
	#[doc = " @param   context     context to pass to callbacks"]
	pub fn rpc_session_set_context(session: *mut RpcSession, context: *mut core::ffi::c_void);
}
extern "C" {
	#[doc = " Set callback to send bytes to client"]
	#[doc = "  WARN: It's forbidden to call RPC API within RpcSendBytesCallback"]
	#[doc = ""]
	#[doc = " @param   session     pointer to RpcSession descriptor"]
	#[doc = " @param   callback    callback to send bytes to client (can be NULL)"]
	pub fn rpc_session_set_send_bytes_callback(session: *mut RpcSession, callback: RpcSendBytesCallback);
}
extern "C" {
	#[doc = " Set callback to notify that buffer is empty"]
	#[doc = ""]
	#[doc = " @param   session     pointer to RpcSession descriptor"]
	#[doc = " @param   callback    callback to notify client that buffer is empty (can be NULL)"]
	pub fn rpc_session_set_buffer_is_empty_callback(session: *mut RpcSession, callback: RpcBufferIsEmptyCallback);
}
extern "C" {
	#[doc = " Set callback to be called when RPC command to close session is received"]
	#[doc = "  WARN: It's forbidden to call RPC API within RpcSessionClosedCallback"]
	#[doc = ""]
	#[doc = " @param   session     pointer to RpcSession descriptor"]
	#[doc = " @param   callback    callback to inform about RPC close session command (can be NULL)"]
	pub fn rpc_session_set_close_callback(session: *mut RpcSession, callback: RpcSessionClosedCallback);
}
extern "C" {
	#[doc = " Set callback to be called when RPC session is closed"]
	#[doc = ""]
	#[doc = " @param   session     pointer to RpcSession descriptor"]
	#[doc = " @param   callback    callback to inform about RPC session state"]
	pub fn rpc_session_set_terminated_callback(session: *mut RpcSession, callback: RpcSessionTerminatedCallback);
}
extern "C" {
	#[doc = " Give bytes to RPC service to decode them and perform command"]
	#[doc = ""]
	#[doc = " @param   session     pointer to RpcSession descriptor"]
	#[doc = " @param   buffer      buffer to provide to RPC service"]
	#[doc = " @param   size        size of buffer"]
	#[doc = " @param   timeout     max timeout to wait till all buffer will be consumed"]
	#[doc = ""]
	#[doc = " @return              actually consumed bytes"]
	pub fn rpc_session_feed(session: *mut RpcSession, buffer: *mut u8, size: usize, timeout: TickType_t) -> usize;
}
extern "C" {
	#[doc = " Get available size of RPC buffer"]
	#[doc = ""]
	#[doc = " @param   session     pointer to RpcSession descriptor"]
	#[doc = ""]
	#[doc = " @return              bytes available in buffer"]
	pub fn rpc_session_get_available_size(session: *mut RpcSession) -> usize;
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum RpcAppSystemEvent {
	RpcAppEventSessionClose = 0,
	RpcAppEventAppExit = 1,
	RpcAppEventLoadFile = 2,
	RpcAppEventButtonPress = 3,
	RpcAppEventButtonRelease = 4,
}
pub type RpcAppSystemCallback =
	::core::option::Option<unsafe extern "C" fn(event: RpcAppSystemEvent, context: *mut core::ffi::c_void)>;
#[repr(C)]
pub struct RpcAppSystem {
	_unused: [u8; 0],
}
extern "C" {
	pub fn rpc_system_app_set_callback(rpc_app: *mut RpcAppSystem, callback: RpcAppSystemCallback, ctx: *mut core::ffi::c_void);
}
extern "C" {
	pub fn rpc_system_app_send_started(rpc_app: *mut RpcAppSystem);
}
extern "C" {
	pub fn rpc_system_app_send_exited(rpc_app: *mut RpcAppSystem);
}
extern "C" {
	pub fn rpc_system_app_get_data(rpc_app: *mut RpcAppSystem) -> *const core::ffi::c_char;
}
extern "C" {
	pub fn rpc_system_app_confirm(rpc_app: *mut RpcAppSystem, event: RpcAppSystemEvent, result: bool);
}
#[repr(u32)]
#[non_exhaustive]
#[doc = " Access mode flags"]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum FS_AccessMode {
	#[doc = "< Read access"]
	FSAM_READ = 1,
	#[doc = "< Write access"]
	FSAM_WRITE = 2,
	#[doc = "< Read and write access"]
	FSAM_READ_WRITE = 3,
}
#[repr(u32)]
#[non_exhaustive]
#[doc = " Open mode flags"]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum FS_OpenMode {
	#[doc = "< Open file, fail if file doesn't exist"]
	FSOM_OPEN_EXISTING = 1,
	#[doc = "< Open file. Create new file if not exist"]
	FSOM_OPEN_ALWAYS = 2,
	#[doc = "< Open file. Create new file if not exist. Set R/W pointer to EOF"]
	FSOM_OPEN_APPEND = 4,
	#[doc = "< Creates a new file. Fails if the file is exist"]
	FSOM_CREATE_NEW = 8,
	#[doc = "< Creates a new file. If file exist, truncate to zero size"]
	FSOM_CREATE_ALWAYS = 16,
}
#[repr(u32)]
#[non_exhaustive]
#[doc = " API errors enumeration"]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum FS_Error {
	#[doc = "< No error"]
	FSE_OK = 0,
	#[doc = "< FS not ready"]
	FSE_NOT_READY = 1,
	#[doc = "< File/Dir alrady exist"]
	FSE_EXIST = 2,
	#[doc = "< File/Dir does not exist"]
	FSE_NOT_EXIST = 3,
	#[doc = "< Invalid API parameter"]
	FSE_INVALID_PARAMETER = 4,
	#[doc = "< Access denied"]
	FSE_DENIED = 5,
	#[doc = "< Invalid name/path"]
	FSE_INVALID_NAME = 6,
	#[doc = "< Internal error"]
	FSE_INTERNAL = 7,
	#[doc = "< Functon not implemented"]
	FSE_NOT_IMPLEMENTED = 8,
	#[doc = "< File/Dir already opened"]
	FSE_ALREADY_OPEN = 9,
}
#[repr(u32)]
#[non_exhaustive]
#[doc = " FileInfo flags"]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum FS_Flags {
	#[doc = "< Directory"]
	FSF_DIRECTORY = 1,
}
#[repr(C)]
pub struct File {
	_unused: [u8; 0],
}
#[doc = "  Structure that hold file info"]
#[repr(C)]
pub struct FileInfo {
	#[doc = "< flags from FS_Flags enum"]
	pub flags: u8,
	#[doc = "< file size"]
	pub size: u64,
}
#[test]
fn bindgen_test_layout_FileInfo() {
	assert_eq!(
	           ::core::mem::size_of::<FileInfo>(),
	           16usize,
	           concat!("Size of: ", stringify!(FileInfo))
	);
	assert_eq!(
	           ::core::mem::align_of::<FileInfo>(),
	           8usize,
	           concat!("Alignment of ", stringify!(FileInfo))
	);
	fn test_field_flags() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<FileInfo>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(FileInfo), "::", stringify!(flags))
		);
	}
	test_field_flags();
	fn test_field_size() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<FileInfo>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).size) as usize - ptr as usize
		           },
		           8usize,
		           concat!("Offset of field: ", stringify!(FileInfo), "::", stringify!(size))
		);
	}
	test_field_size();
}
extern "C" {
	#[doc = " Gets the error text from FS_Error"]
	#[doc = " @param error_id error id"]
	#[doc = " @return const char* error text"]
	pub fn filesystem_api_error_get_desc(error_id: FS_Error) -> *const core::ffi::c_char;
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum SDFsType {
	FST_UNKNOWN = 0,
	FST_FAT12 = 1,
	FST_FAT16 = 2,
	FST_FAT32 = 3,
	FST_EXFAT = 4,
}
#[repr(C)]
pub struct SDInfo {
	pub fs_type: SDFsType,
	pub kb_total: u32,
	pub kb_free: u32,
	pub cluster_size: u16,
	pub sector_size: u16,
	pub label: [core::ffi::c_char; 34usize],
	pub error: FS_Error,
}
#[test]
fn bindgen_test_layout_SDInfo() {
	assert_eq!(
	           ::core::mem::size_of::<SDInfo>(),
	           56usize,
	           concat!("Size of: ", stringify!(SDInfo))
	);
	assert_eq!(
	           ::core::mem::align_of::<SDInfo>(),
	           4usize,
	           concat!("Alignment of ", stringify!(SDInfo))
	);
	fn test_field_fs_type() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<SDInfo>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).fs_type) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(SDInfo), "::", stringify!(fs_type))
		);
	}
	test_field_fs_type();
	fn test_field_kb_total() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<SDInfo>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).kb_total) as usize - ptr as usize
		           },
		           4usize,
		           concat!("Offset of field: ", stringify!(SDInfo), "::", stringify!(kb_total))
		);
	}
	test_field_kb_total();
	fn test_field_kb_free() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<SDInfo>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).kb_free) as usize - ptr as usize
		           },
		           8usize,
		           concat!("Offset of field: ", stringify!(SDInfo), "::", stringify!(kb_free))
		);
	}
	test_field_kb_free();
	fn test_field_cluster_size() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<SDInfo>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).cluster_size) as usize - ptr as usize
		           },
		           12usize,
		           concat!("Offset of field: ", stringify!(SDInfo), "::", stringify!(cluster_size))
		);
	}
	test_field_cluster_size();
	fn test_field_sector_size() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<SDInfo>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).sector_size) as usize - ptr as usize
		           },
		           14usize,
		           concat!("Offset of field: ", stringify!(SDInfo), "::", stringify!(sector_size))
		);
	}
	test_field_sector_size();
	fn test_field_label() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<SDInfo>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).label) as usize - ptr as usize
		           },
		           16usize,
		           concat!("Offset of field: ", stringify!(SDInfo), "::", stringify!(label))
		);
	}
	test_field_label();
	fn test_field_error() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<SDInfo>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).error) as usize - ptr as usize
		           },
		           52usize,
		           concat!("Offset of field: ", stringify!(SDInfo), "::", stringify!(error))
		);
	}
	test_field_error();
}
extern "C" {
	pub fn sd_api_get_fs_type_text(fs_type: SDFsType) -> *const core::ffi::c_char;
}
#[repr(C)]
pub struct Storage {
	_unused: [u8; 0],
}
extern "C" {
	#[doc = " Allocates and initializes a file descriptor"]
	#[doc = " @return File*"]
	pub fn storage_file_alloc(storage: *mut Storage) -> *mut File;
}
extern "C" {
	#[doc = " Frees the file descriptor. Closes the file if it was open."]
	pub fn storage_file_free(file: *mut File);
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum StorageEventType {
	StorageEventTypeCardMount = 0,
	StorageEventTypeCardUnmount = 1,
	StorageEventTypeCardMountError = 2,
	StorageEventTypeFileClose = 3,
	StorageEventTypeDirClose = 4,
}
#[repr(C)]
pub struct StorageEvent {
	pub type_: StorageEventType,
}
#[test]
fn bindgen_test_layout_StorageEvent() {
	assert_eq!(
	           ::core::mem::size_of::<StorageEvent>(),
	           4usize,
	           concat!("Size of: ", stringify!(StorageEvent))
	);
	assert_eq!(
	           ::core::mem::align_of::<StorageEvent>(),
	           4usize,
	           concat!("Alignment of ", stringify!(StorageEvent))
	);
	fn test_field_type() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<StorageEvent>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(StorageEvent), "::", stringify!(type_))
		);
	}
	test_field_type();
}
extern "C" {
	#[doc = " Get storage pubsub."]
	#[doc = " Storage will send StorageEvent messages."]
	#[doc = " @param storage"]
	#[doc = " @return FuriPubSub*"]
	pub fn storage_get_pubsub(storage: *mut Storage) -> *mut FuriPubSub;
}
extern "C" {
	#[doc = " Opens an existing file or create a new one."]
	#[doc = " @param file pointer to file object."]
	#[doc = " @param path path to file"]
	#[doc = " @param access_mode access mode from FS_AccessMode"]
	#[doc = " @param open_mode open mode from FS_OpenMode"]
	#[doc = " @return success flag. You need to close the file even if the open operation failed."]
	pub fn storage_file_open(file: *mut File,
	                         path: *const core::ffi::c_char,
	                         access_mode: FS_AccessMode,
	                         open_mode: FS_OpenMode)
	                         -> bool;
}
extern "C" {
	#[doc = " Close the file."]
	#[doc = " @param file pointer to a file object, the file object will be freed."]
	#[doc = " @return success flag"]
	pub fn storage_file_close(file: *mut File) -> bool;
}
extern "C" {
	#[doc = " Tells if the file is open"]
	#[doc = " @param file pointer to a file object"]
	#[doc = " @return bool true if file is open"]
	pub fn storage_file_is_open(file: *mut File) -> bool;
}
extern "C" {
	#[doc = " Tells if the file is a directory"]
	#[doc = " @param file pointer to a file object"]
	#[doc = " @return bool true if file is a directory"]
	pub fn storage_file_is_dir(file: *mut File) -> bool;
}
extern "C" {
	#[doc = " Reads bytes from a file into a buffer"]
	#[doc = " @param file pointer to file object."]
	#[doc = " @param buff pointer to a buffer, for reading"]
	#[doc = " @param bytes_to_read how many bytes to read. Must be less than or equal to the size of the buffer."]
	#[doc = " @return uint16_t how many bytes were actually read"]
	pub fn storage_file_read(file: *mut File, buff: *mut core::ffi::c_void, bytes_to_read: u16) -> u16;
}
extern "C" {
	#[doc = " Writes bytes from a buffer to a file"]
	#[doc = " @param file pointer to file object."]
	#[doc = " @param buff pointer to buffer, for writing"]
	#[doc = " @param bytes_to_write how many bytes to write. Must be less than or equal to the size of the buffer."]
	#[doc = " @return uint16_t how many bytes were actually written"]
	pub fn storage_file_write(file: *mut File, buff: *const core::ffi::c_void, bytes_to_write: u16) -> u16;
}
extern "C" {
	#[doc = " Moves the r/w pointer"]
	#[doc = " @param file pointer to file object."]
	#[doc = " @param offset offset to move the r/w pointer"]
	#[doc = " @param from_start set an offset from the start or from the current position"]
	#[doc = " @return success flag"]
	pub fn storage_file_seek(file: *mut File, offset: u32, from_start: bool) -> bool;
}
extern "C" {
	#[doc = " Gets the position of the r/w pointer"]
	#[doc = " @param file pointer to file object."]
	#[doc = " @return uint64_t position of the r/w pointer"]
	pub fn storage_file_tell(file: *mut File) -> u64;
}
extern "C" {
	#[doc = " Truncates the file size to the current position of the r/w pointer"]
	#[doc = " @param file pointer to file object."]
	#[doc = " @return bool success flag"]
	pub fn storage_file_truncate(file: *mut File) -> bool;
}
extern "C" {
	#[doc = " Gets the size of the file"]
	#[doc = " @param file pointer to file object."]
	#[doc = " @return uint64_t size of the file"]
	pub fn storage_file_size(file: *mut File) -> u64;
}
extern "C" {
	#[doc = " Writes file cache to storage"]
	#[doc = " @param file pointer to file object."]
	#[doc = " @return bool success flag"]
	pub fn storage_file_sync(file: *mut File) -> bool;
}
extern "C" {
	#[doc = " Checks that the r/w pointer is at the end of the file"]
	#[doc = " @param file pointer to file object."]
	#[doc = " @return bool success flag"]
	pub fn storage_file_eof(file: *mut File) -> bool;
}
extern "C" {
	#[doc = " @brief Check that file exists"]
	#[doc = ""]
	#[doc = " @param storage"]
	#[doc = " @param path"]
	#[doc = " @return true if file exists"]
	pub fn storage_file_exists(storage: *mut Storage, path: *const core::ffi::c_char) -> bool;
}
extern "C" {
	#[doc = " Opens a directory to get objects from it"]
	#[doc = " @param app pointer to the api"]
	#[doc = " @param file pointer to file object."]
	#[doc = " @param path path to directory"]
	#[doc = " @return bool success flag. You need to close the directory even if the open operation failed."]
	pub fn storage_dir_open(file: *mut File, path: *const core::ffi::c_char) -> bool;
}
extern "C" {
	#[doc = " Close the directory. Also free file handle structure and point it to the NULL."]
	#[doc = " @param file pointer to a file object."]
	#[doc = " @return bool success flag"]
	pub fn storage_dir_close(file: *mut File) -> bool;
}
extern "C" {
	#[doc = " Reads the next object in the directory"]
	#[doc = " @param file pointer to file object."]
	#[doc = " @param fileinfo pointer to the read FileInfo, may be NULL"]
	#[doc = " @param name pointer to name buffer, may be NULL"]
	#[doc = " @param name_length name buffer length"]
	#[doc = " @return success flag (if the next object does not exist, it also returns false and sets the file error id to FSE_NOT_EXIST)"]
	pub fn storage_dir_read(file: *mut File, fileinfo: *mut FileInfo, name: *mut core::ffi::c_char, name_length: u16) -> bool;
}
extern "C" {
	#[doc = " Rewinds the read pointer to first item in the directory"]
	#[doc = " @param file pointer to file object."]
	#[doc = " @return bool success flag"]
	pub fn storage_dir_rewind(file: *mut File) -> bool;
}
extern "C" {
	#[doc = " Retrieves information about a file/directory"]
	#[doc = " @param app pointer to the api"]
	#[doc = " @param path path to file/directory"]
	#[doc = " @param fileinfo pointer to the read FileInfo, may be NULL"]
	#[doc = " @return FS_Error operation result"]
	pub fn storage_common_stat(storage: *mut Storage, path: *const core::ffi::c_char, fileinfo: *mut FileInfo) -> FS_Error;
}
extern "C" {
	#[doc = " Removes a file/directory from the repository, the directory must be empty and the file/directory must not be open"]
	#[doc = " @param app pointer to the api"]
	#[doc = " @param path"]
	#[doc = " @return FS_Error operation result"]
	pub fn storage_common_remove(storage: *mut Storage, path: *const core::ffi::c_char) -> FS_Error;
}
extern "C" {
	#[doc = " Renames file/directory, file/directory must not be open"]
	#[doc = " @param app pointer to the api"]
	#[doc = " @param old_path old path"]
	#[doc = " @param new_path new path"]
	#[doc = " @return FS_Error operation result"]
	pub fn storage_common_rename(storage: *mut Storage,
	                             old_path: *const core::ffi::c_char,
	                             new_path: *const core::ffi::c_char)
	                             -> FS_Error;
}
extern "C" {
	#[doc = " Copy file, file must not be open"]
	#[doc = " @param app pointer to the api"]
	#[doc = " @param old_path old path"]
	#[doc = " @param new_path new path"]
	#[doc = " @return FS_Error operation result"]
	pub fn storage_common_copy(storage: *mut Storage,
	                           old_path: *const core::ffi::c_char,
	                           new_path: *const core::ffi::c_char)
	                           -> FS_Error;
}
extern "C" {
	#[doc = " Copy one folder contents into another with rename of all conflicting files"]
	#[doc = " @param app pointer to the api"]
	#[doc = " @param old_path old path"]
	#[doc = " @param new_path new path"]
	#[doc = " @return FS_Error operation result"]
	pub fn storage_common_merge(storage: *mut Storage,
	                            old_path: *const core::ffi::c_char,
	                            new_path: *const core::ffi::c_char)
	                            -> FS_Error;
}
extern "C" {
	#[doc = " Creates a directory"]
	#[doc = " @param app pointer to the api"]
	#[doc = " @param path directory path"]
	#[doc = " @return FS_Error operation result"]
	pub fn storage_common_mkdir(storage: *mut Storage, path: *const core::ffi::c_char) -> FS_Error;
}
extern "C" {
	#[doc = " Gets general information about the storage"]
	#[doc = " @param app pointer to the api"]
	#[doc = " @param fs_path the path to the storage of interest"]
	#[doc = " @param total_space pointer to total space record, will be filled"]
	#[doc = " @param free_space pointer to free space record, will be filled"]
	#[doc = " @return FS_Error operation result"]
	pub fn storage_common_fs_info(storage: *mut Storage,
	                              fs_path: *const core::ffi::c_char,
	                              total_space: *mut u64,
	                              free_space: *mut u64)
	                              -> FS_Error;
}
extern "C" {
	#[doc = " Retrieves the error text from the error id"]
	#[doc = " @param error_id error id"]
	#[doc = " @return const char* error text"]
	pub fn storage_error_get_desc(error_id: FS_Error) -> *const core::ffi::c_char;
}
extern "C" {
	#[doc = " Retrieves the error id from the file object"]
	#[doc = " @param file pointer to file object. Pointer must not point to NULL. YOU CANNOT RETREIVE THE ERROR ID IF THE FILE HAS BEEN CLOSED"]
	#[doc = " @return FS_Error error id"]
	pub fn storage_file_get_error(file: *mut File) -> FS_Error;
}
extern "C" {
	#[doc = " Retrieves the internal (storage-specific) error id from the file object"]
	#[doc = " @param file pointer to file object. Pointer must not point to NULL. YOU CANNOT RETREIVE THE INTERNAL ERROR ID IF THE FILE HAS BEEN CLOSED"]
	#[doc = " @return FS_Error error id"]
	pub fn storage_file_get_internal_error(file: *mut File) -> i32;
}
extern "C" {
	#[doc = " Retrieves the error text from the file object"]
	#[doc = " @param file pointer to file object. Pointer must not point to NULL. YOU CANNOT RETREIVE THE ERROR TEXT IF THE FILE HAS BEEN CLOSED"]
	#[doc = " @return const char* error text"]
	pub fn storage_file_get_error_desc(file: *mut File) -> *const core::ffi::c_char;
}
extern "C" {
	#[doc = " Formats SD Card"]
	#[doc = " @param api pointer to the api"]
	#[doc = " @return FS_Error operation result"]
	pub fn storage_sd_format(api: *mut Storage) -> FS_Error;
}
extern "C" {
	#[doc = " Will unmount the SD card"]
	#[doc = " @param api pointer to the api"]
	#[doc = " @return FS_Error operation result"]
	pub fn storage_sd_unmount(api: *mut Storage) -> FS_Error;
}
extern "C" {
	#[doc = " Retrieves SD card information"]
	#[doc = " @param api pointer to the api"]
	#[doc = " @param info pointer to the info"]
	#[doc = " @return FS_Error operation result"]
	pub fn storage_sd_info(api: *mut Storage, info: *mut SDInfo) -> FS_Error;
}
extern "C" {
	#[doc = " Retrieves SD card status"]
	#[doc = " @param api pointer to the api"]
	#[doc = " @return FS_Error operation result"]
	pub fn storage_sd_status(api: *mut Storage) -> FS_Error;
}
#[doc = " Internal LFS Functions"]
pub type Storage_name_converter = ::core::option::Option<unsafe extern "C" fn(arg1: *mut string_t)>;
extern "C" {
	#[doc = " Backs up internal storage to a tar archive"]
	#[doc = " @param api pointer to the api"]
	#[doc = " @param dstmane destination archive path"]
	#[doc = " @return FS_Error operation result"]
	pub fn storage_int_backup(api: *mut Storage, dstname: *const core::ffi::c_char) -> FS_Error;
}
extern "C" {
	#[doc = " Restores internal storage from a tar archive"]
	#[doc = " @param api pointer to the api"]
	#[doc = " @param dstmane archive path"]
	#[doc = " @param converter pointer to filename conversion function, may be NULL"]
	#[doc = " @return FS_Error operation result"]
	pub fn storage_int_restore(api: *mut Storage, dstname: *const core::ffi::c_char, converter: Storage_name_converter) -> FS_Error;
}
extern "C" {
	#[doc = " Removes a file/directory, the directory must be empty and the file/directory must not be open"]
	#[doc = " @param storage pointer to the api"]
	#[doc = " @param path"]
	#[doc = " @return true on success or if file/dir is not exist"]
	pub fn storage_simply_remove(storage: *mut Storage, path: *const core::ffi::c_char) -> bool;
}
extern "C" {
	#[doc = " Recursively removes a file/directory, the directory can be not empty"]
	#[doc = " @param storage pointer to the api"]
	#[doc = " @param path"]
	#[doc = " @return true on success or if file/dir is not exist"]
	pub fn storage_simply_remove_recursive(storage: *mut Storage, path: *const core::ffi::c_char) -> bool;
}
extern "C" {
	#[doc = " Creates a directory"]
	#[doc = " @param storage"]
	#[doc = " @param path"]
	#[doc = " @return true on success or if directory is already exist"]
	pub fn storage_simply_mkdir(storage: *mut Storage, path: *const core::ffi::c_char) -> bool;
}
extern "C" {
	#[doc = " @brief Get next free filename."]
	#[doc = ""]
	#[doc = " @param storage"]
	#[doc = " @param dirname"]
	#[doc = " @param filename"]
	#[doc = " @param fileextension"]
	#[doc = " @param nextfilename return name"]
	#[doc = " @param max_len  max len name"]
	pub fn storage_get_next_filename(storage: *mut Storage,
	                                 dirname: *const core::ffi::c_char,
	                                 filename: *const core::ffi::c_char,
	                                 fileextension: *const core::ffi::c_char,
	                                 nextfilename: *mut string_t,
	                                 max_len: u8);
}
#[doc = " @brief  RCC Clocks Frequency Structure"]
#[repr(C)]
pub struct LL_RCC_ClocksTypeDef {
	#[doc = "< SYSCLK clock frequency"]
	pub SYSCLK_Frequency: u32,
	#[doc = "< HCLK1 clock frequency"]
	pub HCLK1_Frequency: u32,
	#[doc = "< HCLK2 clock frequency"]
	pub HCLK2_Frequency: u32,
	#[doc = "< HCLK4 clock frequency"]
	pub HCLK4_Frequency: u32,
	#[doc = "< HCLK5 clock frequency"]
	pub HCLK5_Frequency: u32,
	#[doc = "< PCLK1 clock frequency"]
	pub PCLK1_Frequency: u32,
	#[doc = "< PCLK2 clock frequency"]
	pub PCLK2_Frequency: u32,
}
#[test]
fn bindgen_test_layout_LL_RCC_ClocksTypeDef() {
	assert_eq!(
	           ::core::mem::size_of::<LL_RCC_ClocksTypeDef>(),
	           28usize,
	           concat!("Size of: ", stringify!(LL_RCC_ClocksTypeDef))
	);
	assert_eq!(
	           ::core::mem::align_of::<LL_RCC_ClocksTypeDef>(),
	           4usize,
	           concat!("Alignment of ", stringify!(LL_RCC_ClocksTypeDef))
	);
	fn test_field_SYSCLK_Frequency() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_RCC_ClocksTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).SYSCLK_Frequency) as usize - ptr as usize
		           },
		           0usize,
		           concat!(
			"Offset of field: ",
			stringify!(LL_RCC_ClocksTypeDef),
			"::",
			stringify!(SYSCLK_Frequency)
		)
		);
	}
	test_field_SYSCLK_Frequency();
	fn test_field_HCLK1_Frequency() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_RCC_ClocksTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).HCLK1_Frequency) as usize - ptr as usize
		           },
		           4usize,
		           concat!(
			"Offset of field: ",
			stringify!(LL_RCC_ClocksTypeDef),
			"::",
			stringify!(HCLK1_Frequency)
		)
		);
	}
	test_field_HCLK1_Frequency();
	fn test_field_HCLK2_Frequency() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_RCC_ClocksTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).HCLK2_Frequency) as usize - ptr as usize
		           },
		           8usize,
		           concat!(
			"Offset of field: ",
			stringify!(LL_RCC_ClocksTypeDef),
			"::",
			stringify!(HCLK2_Frequency)
		)
		);
	}
	test_field_HCLK2_Frequency();
	fn test_field_HCLK4_Frequency() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_RCC_ClocksTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).HCLK4_Frequency) as usize - ptr as usize
		           },
		           12usize,
		           concat!(
			"Offset of field: ",
			stringify!(LL_RCC_ClocksTypeDef),
			"::",
			stringify!(HCLK4_Frequency)
		)
		);
	}
	test_field_HCLK4_Frequency();
	fn test_field_HCLK5_Frequency() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_RCC_ClocksTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).HCLK5_Frequency) as usize - ptr as usize
		           },
		           16usize,
		           concat!(
			"Offset of field: ",
			stringify!(LL_RCC_ClocksTypeDef),
			"::",
			stringify!(HCLK5_Frequency)
		)
		);
	}
	test_field_HCLK5_Frequency();
	fn test_field_PCLK1_Frequency() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_RCC_ClocksTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).PCLK1_Frequency) as usize - ptr as usize
		           },
		           20usize,
		           concat!(
			"Offset of field: ",
			stringify!(LL_RCC_ClocksTypeDef),
			"::",
			stringify!(PCLK1_Frequency)
		)
		);
	}
	test_field_PCLK1_Frequency();
	fn test_field_PCLK2_Frequency() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_RCC_ClocksTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).PCLK2_Frequency) as usize - ptr as usize
		           },
		           24usize,
		           concat!(
			"Offset of field: ",
			stringify!(LL_RCC_ClocksTypeDef),
			"::",
			stringify!(PCLK2_Frequency)
		)
		);
	}
	test_field_PCLK2_Frequency();
}
extern "C" {
	#[doc = " @defgroup RCC_LL_EF_Init De-initialization function"]
	#[doc = " @{"]
	pub fn LL_RCC_DeInit() -> ErrorStatus;
}
extern "C" {
	#[doc = " @defgroup RCC_LL_EF_Get_Freq Get system and peripherals clocks frequency functions"]
	#[doc = " @{"]
	pub fn LL_RCC_GetSystemClocksFreq(RCC_Clocks: *mut LL_RCC_ClocksTypeDef);
}
extern "C" {
	pub fn LL_RCC_GetSMPSClockFreq() -> u32;
}
extern "C" {
	pub fn LL_RCC_GetUSARTClockFreq(USARTxSource: u32) -> u32;
}
extern "C" {
	pub fn LL_RCC_GetI2CClockFreq(I2CxSource: u32) -> u32;
}
extern "C" {
	pub fn LL_RCC_GetLPUARTClockFreq(LPUARTxSource: u32) -> u32;
}
extern "C" {
	pub fn LL_RCC_GetLPTIMClockFreq(LPTIMxSource: u32) -> u32;
}
extern "C" {
	pub fn LL_RCC_GetSAIClockFreq(SAIxSource: u32) -> u32;
}
extern "C" {
	pub fn LL_RCC_GetCLK48ClockFreq(CLK48xSource: u32) -> u32;
}
extern "C" {
	pub fn LL_RCC_GetRNGClockFreq(RNGxSource: u32) -> u32;
}
extern "C" {
	pub fn LL_RCC_GetUSBClockFreq(USBxSource: u32) -> u32;
}
extern "C" {
	pub fn LL_RCC_GetADCClockFreq(ADCxSource: u32) -> u32;
}
extern "C" {
	pub fn LL_RCC_GetRTCClockFreq() -> u32;
}
extern "C" {
	pub fn LL_RCC_GetRFWKPClockFreq() -> u32;
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum FuriHalClockMcoSourceId {
	FuriHalClockMcoLse = 0,
	FuriHalClockMcoSysclk = 1,
	FuriHalClockMcoMsi100k = 2,
	FuriHalClockMcoMsi200k = 3,
	FuriHalClockMcoMsi400k = 4,
	FuriHalClockMcoMsi800k = 5,
	FuriHalClockMcoMsi1m = 6,
	FuriHalClockMcoMsi2m = 7,
	FuriHalClockMcoMsi4m = 8,
	FuriHalClockMcoMsi8m = 9,
	FuriHalClockMcoMsi16m = 10,
	FuriHalClockMcoMsi24m = 11,
	FuriHalClockMcoMsi32m = 12,
	FuriHalClockMcoMsi48m = 13,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum FuriHalClockMcoDivisorId {
	FuriHalClockMcoDiv1 = 0,
	FuriHalClockMcoDiv2 = 268435456,
	FuriHalClockMcoDiv4 = 536870912,
	FuriHalClockMcoDiv8 = 805306368,
	FuriHalClockMcoDiv16 = 1073741824,
}
extern "C" {
	#[doc = " Early initialization"]
	pub fn furi_hal_clock_init_early();
}
extern "C" {
	#[doc = " Early deinitialization"]
	pub fn furi_hal_clock_deinit_early();
}
extern "C" {
	#[doc = " Initialize clocks"]
	pub fn furi_hal_clock_init();
}
extern "C" {
	#[doc = " Switch to HSI clock"]
	pub fn furi_hal_clock_switch_to_hsi();
}
extern "C" {
	#[doc = " Switch to PLL clock"]
	pub fn furi_hal_clock_switch_to_pll();
}
extern "C" {
	#[doc = " Stop SysTick counter without resetting"]
	pub fn furi_hal_clock_suspend_tick();
}
extern "C" {
	#[doc = " Continue SysTick counter operation"]
	pub fn furi_hal_clock_resume_tick();
}
extern "C" {
	#[doc = " Enable clock output on MCO pin"]
	#[doc = ""]
	#[doc = " @param      source  MCO clock source"]
	#[doc = " @param      div     MCO clock division"]
	pub fn furi_hal_clock_mco_enable(source: FuriHalClockMcoSourceId, div: FuriHalClockMcoDivisorId);
}
extern "C" {
	#[doc = " Disable clock output on MCO pin"]
	pub fn furi_hal_clock_mco_disable();
}
pub type FuriHalConsoleTxCallback =
	::core::option::Option<unsafe extern "C" fn(buffer: *const u8, size: usize, context: *mut core::ffi::c_void)>;
extern "C" {
	pub fn furi_hal_console_init();
}
extern "C" {
	pub fn furi_hal_console_enable();
}
extern "C" {
	pub fn furi_hal_console_disable();
}
extern "C" {
	pub fn furi_hal_console_set_tx_callback(callback: FuriHalConsoleTxCallback, context: *mut core::ffi::c_void);
}
extern "C" {
	pub fn furi_hal_console_tx(buffer: *const u8, buffer_size: usize);
}
extern "C" {
	pub fn furi_hal_console_tx_with_new_line(buffer: *const u8, buffer_size: usize);
}
extern "C" {
	#[doc = " Printf-like plain uart interface"]
	#[doc = " @warning Will not work in ISR context"]
	#[doc = " @param format"]
	#[doc = " @param ..."]
	pub fn furi_hal_console_printf(format: *const [core::ffi::c_char; 0usize], ...);
}
extern "C" {
	pub fn furi_hal_console_puts(data: *const core::ffi::c_char);
}
#[repr(C)]
pub struct FuriHalFlashRawOptionByteData {
	pub bytes: __BindgenUnionField<[u8; 128usize]>,
	pub obs: __BindgenUnionField<[FuriHalFlashRawOptionByteData__bindgen_ty_1; 16usize]>,
	pub bindgen_union_field: [u64; 16usize],
}
#[repr(C)]
pub struct FuriHalFlashRawOptionByteData__bindgen_ty_1 {
	pub values: __BindgenUnionField<FuriHalFlashRawOptionByteData__bindgen_ty_1__bindgen_ty_1>,
	pub dword: __BindgenUnionField<u64>,
	pub bindgen_union_field: u64,
}
#[repr(C)]
pub struct FuriHalFlashRawOptionByteData__bindgen_ty_1__bindgen_ty_1 {
	pub base: u32,
	pub complementary_value: u32,
}
#[test]
fn bindgen_test_layout_FuriHalFlashRawOptionByteData__bindgen_ty_1__bindgen_ty_1() {
	assert_eq!(
	           ::core::mem::size_of::<FuriHalFlashRawOptionByteData__bindgen_ty_1__bindgen_ty_1>(),
	           8usize,
	           concat!(
		"Size of: ",
		stringify!(FuriHalFlashRawOptionByteData__bindgen_ty_1__bindgen_ty_1)
	)
	);
	assert_eq!(
	           ::core::mem::align_of::<FuriHalFlashRawOptionByteData__bindgen_ty_1__bindgen_ty_1>(),
	           4usize,
	           concat!(
		"Alignment of ",
		stringify!(FuriHalFlashRawOptionByteData__bindgen_ty_1__bindgen_ty_1)
	)
	);
	fn test_field_base() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<FuriHalFlashRawOptionByteData__bindgen_ty_1__bindgen_ty_1>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).base) as usize - ptr as usize
		           },
		           0usize,
		           concat!(
			"Offset of field: ",
			stringify!(FuriHalFlashRawOptionByteData__bindgen_ty_1__bindgen_ty_1),
			"::",
			stringify!(base)
		)
		);
	}
	test_field_base();
	fn test_field_complementary_value() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<FuriHalFlashRawOptionByteData__bindgen_ty_1__bindgen_ty_1>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).complementary_value) as usize - ptr as usize
		           },
		           4usize,
		           concat!(
			"Offset of field: ",
			stringify!(FuriHalFlashRawOptionByteData__bindgen_ty_1__bindgen_ty_1),
			"::",
			stringify!(complementary_value)
		)
		);
	}
	test_field_complementary_value();
}
#[test]
fn bindgen_test_layout_FuriHalFlashRawOptionByteData__bindgen_ty_1() {
	assert_eq!(
	           ::core::mem::size_of::<FuriHalFlashRawOptionByteData__bindgen_ty_1>(),
	           8usize,
	           concat!("Size of: ", stringify!(FuriHalFlashRawOptionByteData__bindgen_ty_1))
	);
	assert_eq!(
	           ::core::mem::align_of::<FuriHalFlashRawOptionByteData__bindgen_ty_1>(),
	           8usize,
	           concat!("Alignment of ", stringify!(FuriHalFlashRawOptionByteData__bindgen_ty_1))
	);
	fn test_field_values() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<FuriHalFlashRawOptionByteData__bindgen_ty_1>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).values) as usize - ptr as usize
		           },
		           0usize,
		           concat!(
			"Offset of field: ",
			stringify!(FuriHalFlashRawOptionByteData__bindgen_ty_1),
			"::",
			stringify!(values)
		)
		);
	}
	test_field_values();
	fn test_field_dword() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<FuriHalFlashRawOptionByteData__bindgen_ty_1>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).dword) as usize - ptr as usize
		           },
		           0usize,
		           concat!(
			"Offset of field: ",
			stringify!(FuriHalFlashRawOptionByteData__bindgen_ty_1),
			"::",
			stringify!(dword)
		)
		);
	}
	test_field_dword();
}
#[test]
fn bindgen_test_layout_FuriHalFlashRawOptionByteData() {
	assert_eq!(
	           ::core::mem::size_of::<FuriHalFlashRawOptionByteData>(),
	           128usize,
	           concat!("Size of: ", stringify!(FuriHalFlashRawOptionByteData))
	);
	assert_eq!(
	           ::core::mem::align_of::<FuriHalFlashRawOptionByteData>(),
	           8usize,
	           concat!("Alignment of ", stringify!(FuriHalFlashRawOptionByteData))
	);
	fn test_field_bytes() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<FuriHalFlashRawOptionByteData>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).bytes) as usize - ptr as usize
		           },
		           0usize,
		           concat!(
			"Offset of field: ",
			stringify!(FuriHalFlashRawOptionByteData),
			"::",
			stringify!(bytes)
		)
		);
	}
	test_field_bytes();
	fn test_field_obs() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<FuriHalFlashRawOptionByteData>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).obs) as usize - ptr as usize
		           },
		           0usize,
		           concat!(
			"Offset of field: ",
			stringify!(FuriHalFlashRawOptionByteData),
			"::",
			stringify!(obs)
		)
		);
	}
	test_field_obs();
}
extern "C" {
	#[doc = " Init flash, applying necessary workarounds"]
	pub fn furi_hal_flash_init();
}
extern "C" {
	#[doc = " Get flash base address"]
	#[doc = ""]
	#[doc = " @return     pointer to flash base"]
	pub fn furi_hal_flash_get_base() -> usize;
}
extern "C" {
	#[doc = " Get flash read block size"]
	#[doc = ""]
	#[doc = " @return     size in bytes"]
	pub fn furi_hal_flash_get_read_block_size() -> usize;
}
extern "C" {
	#[doc = " Get flash write block size"]
	#[doc = ""]
	#[doc = " @return     size in bytes"]
	pub fn furi_hal_flash_get_write_block_size() -> usize;
}
extern "C" {
	#[doc = " Get flash page size"]
	#[doc = ""]
	#[doc = " @return     size in bytes"]
	pub fn furi_hal_flash_get_page_size() -> usize;
}
extern "C" {
	#[doc = " Get expected flash cycles count"]
	#[doc = ""]
	#[doc = " @return     count of erase-write operations"]
	pub fn furi_hal_flash_get_cycles_count() -> usize;
}
extern "C" {
	#[doc = " Get free flash start address"]
	#[doc = ""]
	#[doc = " @return     pointer to free region start"]
	pub fn furi_hal_flash_get_free_start_address() -> *const core::ffi::c_void;
}
extern "C" {
	#[doc = " Get free flash end address"]
	#[doc = ""]
	#[doc = " @return     pointer to free region end"]
	pub fn furi_hal_flash_get_free_end_address() -> *const core::ffi::c_void;
}
extern "C" {
	#[doc = " Get first free page start address"]
	#[doc = ""]
	#[doc = " @return     first free page memory address"]
	pub fn furi_hal_flash_get_free_page_start_address() -> usize;
}
extern "C" {
	#[doc = " Get free page count"]
	#[doc = ""]
	#[doc = " @return     free page count"]
	pub fn furi_hal_flash_get_free_page_count() -> usize;
}
extern "C" {
	#[doc = " Erase Flash"]
	#[doc = ""]
	#[doc = " @warning    locking operation with critical section, stalls execution"]
	#[doc = ""]
	#[doc = " @param      page  The page to erase"]
	pub fn furi_hal_flash_erase(page: u8);
}
extern "C" {
	#[doc = " Write double word (64 bits)"]
	#[doc = ""]
	#[doc = " @warning locking operation with critical section, stalls execution"]
	#[doc = ""]
	#[doc = " @param      address  destination address, must be double word aligned."]
	#[doc = " @param      data     data to write"]
	pub fn furi_hal_flash_write_dword(address: usize, data: u64);
}
extern "C" {
	#[doc = " Write aligned page data (up to page size)"]
	#[doc = ""]
	#[doc = " @warning locking operation with critical section, stalls execution"]
	#[doc = ""]
	#[doc = " @param      address  destination address, must be page aligned."]
	#[doc = " @param      data     data to write"]
	#[doc = " @param      length   data length"]
	pub fn furi_hal_flash_program_page(page: u8, data: *const u8, length: u16);
}
extern "C" {
	#[doc = " Get flash page number for address"]
	#[doc = ""]
	#[doc = " @return     page number, -1 for invalid address"]
	pub fn furi_hal_flash_get_page_number(address: usize) -> i16;
}
extern "C" {
	#[doc = " Writes OB word, using non-compl. index of register in Flash, OPTION_BYTE_BASE"]
	#[doc = ""]
	#[doc = " @warning locking operation with critical section, stalls execution"]
	#[doc = ""]
	#[doc = " @param      word_idx  OB word number"]
	#[doc = " @param      value    data to write"]
	#[doc = " @return     true if value was written, false for read-only word"]
	pub fn furi_hal_flash_ob_set_word(word_idx: usize, value: u32) -> bool;
}
extern "C" {
	#[doc = " Forces a reload of OB data from flash to registers"]
	#[doc = ""]
	#[doc = " @warning Initializes system restart"]
	#[doc = ""]
	pub fn furi_hal_flash_ob_apply();
}
extern "C" {
	#[doc = " Get raw OB storage data"]
	#[doc = ""]
	#[doc = " @return     pointer to read-only data of OB (raw + complementary values)"]
	pub fn furi_hal_flash_ob_get_raw_ptr() -> *const FuriHalFlashRawOptionByteData;
}
#[doc = " @defgroup I2C_LL_ES_INIT I2C Exported Init structure"]
#[doc = " @{"]
#[repr(C)]
pub struct LL_I2C_InitTypeDef {
	#[doc = "< Specifies the peripheral mode."]
	#[doc = "This parameter can be a value of @ref I2C_LL_EC_PERIPHERAL_MODE."]
	#[doc = ""]
	#[doc = "This feature can be modified afterwards using unitary function"]
	#[doc = "@ref LL_I2C_SetMode()."]
	pub PeripheralMode: u32,
	#[doc = "< Specifies the SDA setup, hold time and the SCL high, low period values."]
	#[doc = "This parameter must be set by referring to the STM32CubeMX Tool and"]
	#[doc = "the helper macro @ref __LL_I2C_CONVERT_TIMINGS()."]
	#[doc = ""]
	#[doc = "This feature can be modified afterwards using unitary function"]
	#[doc = "@ref LL_I2C_SetTiming()."]
	pub Timing: u32,
	#[doc = "< Enables or disables analog noise filter."]
	#[doc = "This parameter can be a value of @ref I2C_LL_EC_ANALOGFILTER_SELECTION."]
	#[doc = ""]
	#[doc = "This feature can be modified afterwards using unitary functions"]
	#[doc = "@ref LL_I2C_EnableAnalogFilter() or LL_I2C_DisableAnalogFilter()."]
	pub AnalogFilter: u32,
	#[doc = "< Configures the digital noise filter."]
	#[doc = "This parameter can be a number between Min_Data = 0x00 and Max_Data = 0x0F."]
	#[doc = ""]
	#[doc = "This feature can be modified afterwards using unitary function"]
	#[doc = "@ref LL_I2C_SetDigitalFilter()."]
	pub DigitalFilter: u32,
	#[doc = "< Specifies the device own address 1."]
	#[doc = "This parameter must be a value between Min_Data = 0x00 and Max_Data = 0x3FF."]
	#[doc = ""]
	#[doc = "This feature can be modified afterwards using unitary function"]
	#[doc = "@ref LL_I2C_SetOwnAddress1()."]
	pub OwnAddress1: u32,
	#[doc = "< Specifies the ACKnowledge or Non ACKnowledge condition after the address receive"]
	#[doc = "match code or next received byte."]
	#[doc = "This parameter can be a value of @ref I2C_LL_EC_I2C_ACKNOWLEDGE."]
	#[doc = ""]
	#[doc = "This feature can be modified afterwards using unitary function"]
	#[doc = "@ref LL_I2C_AcknowledgeNextData()."]
	pub TypeAcknowledge: u32,
	#[doc = "< Specifies the device own address 1 size (7-bit or 10-bit)."]
	#[doc = "This parameter can be a value of @ref I2C_LL_EC_OWNADDRESS1."]
	#[doc = ""]
	#[doc = "This feature can be modified afterwards using unitary function"]
	#[doc = "@ref LL_I2C_SetOwnAddress1()."]
	pub OwnAddrSize: u32,
}
#[test]
fn bindgen_test_layout_LL_I2C_InitTypeDef() {
	assert_eq!(
	           ::core::mem::size_of::<LL_I2C_InitTypeDef>(),
	           28usize,
	           concat!("Size of: ", stringify!(LL_I2C_InitTypeDef))
	);
	assert_eq!(
	           ::core::mem::align_of::<LL_I2C_InitTypeDef>(),
	           4usize,
	           concat!("Alignment of ", stringify!(LL_I2C_InitTypeDef))
	);
	fn test_field_PeripheralMode() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_I2C_InitTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).PeripheralMode) as usize - ptr as usize
		           },
		           0usize,
		           concat!(
			"Offset of field: ",
			stringify!(LL_I2C_InitTypeDef),
			"::",
			stringify!(PeripheralMode)
		)
		);
	}
	test_field_PeripheralMode();
	fn test_field_Timing() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_I2C_InitTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).Timing) as usize - ptr as usize
		           },
		           4usize,
		           concat!("Offset of field: ", stringify!(LL_I2C_InitTypeDef), "::", stringify!(Timing))
		);
	}
	test_field_Timing();
	fn test_field_AnalogFilter() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_I2C_InitTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).AnalogFilter) as usize - ptr as usize
		           },
		           8usize,
		           concat!(
			"Offset of field: ",
			stringify!(LL_I2C_InitTypeDef),
			"::",
			stringify!(AnalogFilter)
		)
		);
	}
	test_field_AnalogFilter();
	fn test_field_DigitalFilter() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_I2C_InitTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).DigitalFilter) as usize - ptr as usize
		           },
		           12usize,
		           concat!(
			"Offset of field: ",
			stringify!(LL_I2C_InitTypeDef),
			"::",
			stringify!(DigitalFilter)
		)
		);
	}
	test_field_DigitalFilter();
	fn test_field_OwnAddress1() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_I2C_InitTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).OwnAddress1) as usize - ptr as usize
		           },
		           16usize,
		           concat!(
			"Offset of field: ",
			stringify!(LL_I2C_InitTypeDef),
			"::",
			stringify!(OwnAddress1)
		)
		);
	}
	test_field_OwnAddress1();
	fn test_field_TypeAcknowledge() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_I2C_InitTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).TypeAcknowledge) as usize - ptr as usize
		           },
		           20usize,
		           concat!(
			"Offset of field: ",
			stringify!(LL_I2C_InitTypeDef),
			"::",
			stringify!(TypeAcknowledge)
		)
		);
	}
	test_field_TypeAcknowledge();
	fn test_field_OwnAddrSize() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_I2C_InitTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).OwnAddrSize) as usize - ptr as usize
		           },
		           24usize,
		           concat!(
			"Offset of field: ",
			stringify!(LL_I2C_InitTypeDef),
			"::",
			stringify!(OwnAddrSize)
		)
		);
	}
	test_field_OwnAddrSize();
}
extern "C" {
	#[doc = " @defgroup I2C_LL_EF_Init Initialization and de-initialization functions"]
	#[doc = " @{"]
	pub fn LL_I2C_Init(I2Cx: *mut I2C_TypeDef, I2C_InitStruct: *mut LL_I2C_InitTypeDef) -> ErrorStatus;
}
extern "C" {
	pub fn LL_I2C_DeInit(I2Cx: *mut I2C_TypeDef) -> ErrorStatus;
}
extern "C" {
	pub fn LL_I2C_StructInit(I2C_InitStruct: *mut LL_I2C_InitTypeDef);
}
#[repr(u32)]
#[non_exhaustive]
#[doc = " FuriHal i2c bus states"]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum FuriHalI2cBusEvent {
	#[doc = "< Bus initialization event, called on system start"]
	FuriHalI2cBusEventInit = 0,
	#[doc = "< Bus deinitialization event, called on system stop"]
	FuriHalI2cBusEventDeinit = 1,
	#[doc = "< Bus lock event, called before activation"]
	FuriHalI2cBusEventLock = 2,
	#[doc = "< Bus unlock event, called after deactivation"]
	FuriHalI2cBusEventUnlock = 3,
	#[doc = "< Bus activation event, called before handle activation"]
	FuriHalI2cBusEventActivate = 4,
	#[doc = "< Bus deactivation event, called after handle deactivation"]
	FuriHalI2cBusEventDeactivate = 5,
}
#[doc = " FuriHal i2c bus event callback"]
pub type FuriHalI2cBusEventCallback =
	::core::option::Option<unsafe extern "C" fn(bus: *mut FuriHalI2cBus, event: FuriHalI2cBusEvent)>;
#[doc = " FuriHal i2c bus"]
#[repr(C)]
pub struct FuriHalI2cBus {
	pub i2c: *mut I2C_TypeDef,
	pub current_handle: *mut FuriHalI2cBusHandle,
	pub callback: FuriHalI2cBusEventCallback,
}
#[test]
fn bindgen_test_layout_FuriHalI2cBus() {
	assert_eq!(
	           ::core::mem::size_of::<FuriHalI2cBus>(),
	           12usize,
	           concat!("Size of: ", stringify!(FuriHalI2cBus))
	);
	assert_eq!(
	           ::core::mem::align_of::<FuriHalI2cBus>(),
	           4usize,
	           concat!("Alignment of ", stringify!(FuriHalI2cBus))
	);
	fn test_field_i2c() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<FuriHalI2cBus>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).i2c) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(FuriHalI2cBus), "::", stringify!(i2c))
		);
	}
	test_field_i2c();
	fn test_field_current_handle() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<FuriHalI2cBus>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).current_handle) as usize - ptr as usize
		           },
		           4usize,
		           concat!(
			"Offset of field: ",
			stringify!(FuriHalI2cBus),
			"::",
			stringify!(current_handle)
		)
		);
	}
	test_field_current_handle();
	fn test_field_callback() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<FuriHalI2cBus>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).callback) as usize - ptr as usize
		           },
		           8usize,
		           concat!("Offset of field: ", stringify!(FuriHalI2cBus), "::", stringify!(callback))
		);
	}
	test_field_callback();
}
#[repr(u32)]
#[non_exhaustive]
#[doc = " FuriHal i2c handle states"]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum FuriHalI2cBusHandleEvent {
	#[doc = "< Handle activate: connect gpio and apply bus config"]
	FuriHalI2cBusHandleEventActivate = 0,
	#[doc = "< Handle deactivate: disconnect gpio and reset bus config"]
	FuriHalI2cBusHandleEventDeactivate = 1,
}
#[doc = " FuriHal i2c handle event callback"]
pub type FuriHalI2cBusHandleEventCallback =
	::core::option::Option<unsafe extern "C" fn(handle: *mut FuriHalI2cBusHandle, event: FuriHalI2cBusHandleEvent)>;
#[doc = " FuriHal i2c handle"]
#[repr(C)]
pub struct FuriHalI2cBusHandle {
	pub bus: *mut FuriHalI2cBus,
	pub callback: FuriHalI2cBusHandleEventCallback,
}
#[test]
fn bindgen_test_layout_FuriHalI2cBusHandle() {
	assert_eq!(
	           ::core::mem::size_of::<FuriHalI2cBusHandle>(),
	           8usize,
	           concat!("Size of: ", stringify!(FuriHalI2cBusHandle))
	);
	assert_eq!(
	           ::core::mem::align_of::<FuriHalI2cBusHandle>(),
	           4usize,
	           concat!("Alignment of ", stringify!(FuriHalI2cBusHandle))
	);
	fn test_field_bus() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<FuriHalI2cBusHandle>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).bus) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(FuriHalI2cBusHandle), "::", stringify!(bus))
		);
	}
	test_field_bus();
	fn test_field_callback() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<FuriHalI2cBusHandle>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).callback) as usize - ptr as usize
		           },
		           4usize,
		           concat!(
			"Offset of field: ",
			stringify!(FuriHalI2cBusHandle),
			"::",
			stringify!(callback)
		)
		);
	}
	test_field_callback();
}
extern "C" {
	#[doc = " Internal(power) i2c bus, I2C1, under reset when not used"]
	pub static mut furi_hal_i2c_bus_power: FuriHalI2cBus;
}
extern "C" {
	#[doc = " External i2c bus, I2C3, under reset when not used"]
	pub static mut furi_hal_i2c_bus_external: FuriHalI2cBus;
}
extern "C" {
	#[doc = " Handle for internal(power) i2c bus"]
	#[doc = " Bus: furi_hal_i2c_bus_external"]
	#[doc = " Pins: PA9(SCL) / PA10(SDA), float on release"]
	#[doc = " Params: 400khz"]
	pub static mut furi_hal_i2c_handle_power: FuriHalI2cBusHandle;
}
extern "C" {
	#[doc = " Handle for external i2c bus"]
	#[doc = " Bus: furi_hal_i2c_bus_external"]
	#[doc = " Pins: PC0(SCL) / PC1(SDA), float on release"]
	#[doc = " Params: 100khz"]
	pub static mut furi_hal_i2c_handle_external: FuriHalI2cBusHandle;
}
#[doc = " @brief  LPTIM Init structure definition"]
#[repr(C)]
pub struct LL_LPTIM_InitTypeDef {
	#[doc = "< Specifies the source of the clock used by the LPTIM instance."]
	#[doc = "This parameter can be a value of @ref LPTIM_LL_EC_CLK_SOURCE."]
	#[doc = ""]
	#[doc = "This feature can be modified afterwards using unitary"]
	#[doc = "function @ref LL_LPTIM_SetClockSource()."]
	pub ClockSource: u32,
	#[doc = "< Specifies the prescaler division ratio."]
	#[doc = "This parameter can be a value of @ref LPTIM_LL_EC_PRESCALER."]
	#[doc = ""]
	#[doc = "This feature can be modified afterwards using using unitary"]
	#[doc = "function @ref LL_LPTIM_SetPrescaler()."]
	pub Prescaler: u32,
	#[doc = "< Specifies the waveform shape."]
	#[doc = "This parameter can be a value of @ref LPTIM_LL_EC_OUTPUT_WAVEFORM."]
	#[doc = ""]
	#[doc = "This feature can be modified afterwards using unitary"]
	#[doc = "function @ref LL_LPTIM_ConfigOutput()."]
	pub Waveform: u32,
	#[doc = "< Specifies waveform polarity."]
	#[doc = "This parameter can be a value of @ref LPTIM_LL_EC_OUTPUT_POLARITY."]
	#[doc = ""]
	#[doc = "This feature can be modified afterwards using unitary"]
	#[doc = "function @ref LL_LPTIM_ConfigOutput()."]
	pub Polarity: u32,
}
#[test]
fn bindgen_test_layout_LL_LPTIM_InitTypeDef() {
	assert_eq!(
	           ::core::mem::size_of::<LL_LPTIM_InitTypeDef>(),
	           16usize,
	           concat!("Size of: ", stringify!(LL_LPTIM_InitTypeDef))
	);
	assert_eq!(
	           ::core::mem::align_of::<LL_LPTIM_InitTypeDef>(),
	           4usize,
	           concat!("Alignment of ", stringify!(LL_LPTIM_InitTypeDef))
	);
	fn test_field_ClockSource() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_LPTIM_InitTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).ClockSource) as usize - ptr as usize
		           },
		           0usize,
		           concat!(
			"Offset of field: ",
			stringify!(LL_LPTIM_InitTypeDef),
			"::",
			stringify!(ClockSource)
		)
		);
	}
	test_field_ClockSource();
	fn test_field_Prescaler() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_LPTIM_InitTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).Prescaler) as usize - ptr as usize
		           },
		           4usize,
		           concat!(
			"Offset of field: ",
			stringify!(LL_LPTIM_InitTypeDef),
			"::",
			stringify!(Prescaler)
		)
		);
	}
	test_field_Prescaler();
	fn test_field_Waveform() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_LPTIM_InitTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).Waveform) as usize - ptr as usize
		           },
		           8usize,
		           concat!(
			"Offset of field: ",
			stringify!(LL_LPTIM_InitTypeDef),
			"::",
			stringify!(Waveform)
		)
		);
	}
	test_field_Waveform();
	fn test_field_Polarity() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_LPTIM_InitTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).Polarity) as usize - ptr as usize
		           },
		           12usize,
		           concat!(
			"Offset of field: ",
			stringify!(LL_LPTIM_InitTypeDef),
			"::",
			stringify!(Polarity)
		)
		);
	}
	test_field_Polarity();
}
extern "C" {
	#[doc = " @defgroup LPTIM_LL_EF_Init Initialisation and deinitialisation functions"]
	#[doc = " @{"]
	pub fn LL_LPTIM_DeInit(LPTIMx: *mut LPTIM_TypeDef) -> ErrorStatus;
}
extern "C" {
	pub fn LL_LPTIM_StructInit(LPTIM_InitStruct: *mut LL_LPTIM_InitTypeDef);
}
extern "C" {
	pub fn LL_LPTIM_Init(LPTIMx: *mut LPTIM_TypeDef, LPTIM_InitStruct: *mut LL_LPTIM_InitTypeDef) -> ErrorStatus;
}
extern "C" {
	pub fn LL_LPTIM_Disable(LPTIMx: *mut LPTIM_TypeDef);
}
extern "C" {
	#[doc = " @defgroup TIM_LL_Private_Variables TIM Private Variables"]
	#[doc = " @{"]
	pub static OFFSET_TAB_CCMRx: [u8; 9usize];
}
extern "C" {
	pub static SHIFT_TAB_OCxx: [u8; 9usize];
}
extern "C" {
	pub static SHIFT_TAB_ICxx: [u8; 9usize];
}
extern "C" {
	pub static SHIFT_TAB_CCxP: [u8; 9usize];
}
extern "C" {
	pub static SHIFT_TAB_OISx: [u8; 9usize];
}
#[doc = " @brief  TIM Time Base configuration structure definition."]
#[repr(C)]
pub struct LL_TIM_InitTypeDef {
	#[doc = "< Specifies the prescaler value used to divide the TIM clock."]
	#[doc = "This parameter can be a number between Min_Data=0x0000 and Max_Data=0xFFFF."]
	#[doc = ""]
	#[doc = "This feature can be modified afterwards using unitary function"]
	#[doc = "@ref LL_TIM_SetPrescaler()."]
	pub Prescaler: u16,
	#[doc = "< Specifies the counter mode."]
	#[doc = "This parameter can be a value of @ref TIM_LL_EC_COUNTERMODE."]
	#[doc = ""]
	#[doc = "This feature can be modified afterwards using unitary function"]
	#[doc = "@ref LL_TIM_SetCounterMode()."]
	pub CounterMode: u32,
	#[doc = "< Specifies the auto reload value to be loaded into the active"]
	#[doc = "Auto-Reload Register at the next update event."]
	#[doc = "This parameter must be a number between Min_Data=0x0000 and Max_Data=0xFFFF."]
	#[doc = "Some timer instances may support 32 bits counters. In that case this parameter must"]
	#[doc = "be a number between 0x0000 and 0xFFFFFFFF."]
	#[doc = ""]
	#[doc = "This feature can be modified afterwards using unitary function"]
	#[doc = "@ref LL_TIM_SetAutoReload()."]
	pub Autoreload: u32,
	#[doc = "< Specifies the clock division."]
	#[doc = "This parameter can be a value of @ref TIM_LL_EC_CLOCKDIVISION."]
	#[doc = ""]
	#[doc = "This feature can be modified afterwards using unitary function"]
	#[doc = "@ref LL_TIM_SetClockDivision()."]
	pub ClockDivision: u32,
	#[doc = "< Specifies the repetition counter value. Each time the RCR downcounter"]
	#[doc = "reaches zero, an update event is generated and counting restarts"]
	#[doc = "from the RCR value (N)."]
	#[doc = "This means in PWM mode that (N+1) corresponds to:"]
	#[doc = "- the number of PWM periods in edge-aligned mode"]
	#[doc = "- the number of half PWM period in center-aligned mode"]
	#[doc = "GP timers: this parameter must be a number between Min_Data = 0x00 and"]
	#[doc = "Max_Data = 0xFF."]
	#[doc = "Advanced timers: this parameter must be a number between Min_Data = 0x0000 and"]
	#[doc = "Max_Data = 0xFFFF."]
	#[doc = ""]
	#[doc = "This feature can be modified afterwards using unitary function"]
	#[doc = "@ref LL_TIM_SetRepetitionCounter()."]
	pub RepetitionCounter: u32,
}
#[test]
fn bindgen_test_layout_LL_TIM_InitTypeDef() {
	assert_eq!(
	           ::core::mem::size_of::<LL_TIM_InitTypeDef>(),
	           20usize,
	           concat!("Size of: ", stringify!(LL_TIM_InitTypeDef))
	);
	assert_eq!(
	           ::core::mem::align_of::<LL_TIM_InitTypeDef>(),
	           4usize,
	           concat!("Alignment of ", stringify!(LL_TIM_InitTypeDef))
	);
	fn test_field_Prescaler() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_TIM_InitTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).Prescaler) as usize - ptr as usize
		           },
		           0usize,
		           concat!(
			"Offset of field: ",
			stringify!(LL_TIM_InitTypeDef),
			"::",
			stringify!(Prescaler)
		)
		);
	}
	test_field_Prescaler();
	fn test_field_CounterMode() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_TIM_InitTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).CounterMode) as usize - ptr as usize
		           },
		           4usize,
		           concat!(
			"Offset of field: ",
			stringify!(LL_TIM_InitTypeDef),
			"::",
			stringify!(CounterMode)
		)
		);
	}
	test_field_CounterMode();
	fn test_field_Autoreload() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_TIM_InitTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).Autoreload) as usize - ptr as usize
		           },
		           8usize,
		           concat!(
			"Offset of field: ",
			stringify!(LL_TIM_InitTypeDef),
			"::",
			stringify!(Autoreload)
		)
		);
	}
	test_field_Autoreload();
	fn test_field_ClockDivision() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_TIM_InitTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).ClockDivision) as usize - ptr as usize
		           },
		           12usize,
		           concat!(
			"Offset of field: ",
			stringify!(LL_TIM_InitTypeDef),
			"::",
			stringify!(ClockDivision)
		)
		);
	}
	test_field_ClockDivision();
	fn test_field_RepetitionCounter() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_TIM_InitTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).RepetitionCounter) as usize - ptr as usize
		           },
		           16usize,
		           concat!(
			"Offset of field: ",
			stringify!(LL_TIM_InitTypeDef),
			"::",
			stringify!(RepetitionCounter)
		)
		);
	}
	test_field_RepetitionCounter();
}
#[doc = " @brief  TIM Output Compare configuration structure definition."]
#[repr(C)]
pub struct LL_TIM_OC_InitTypeDef {
	#[doc = "< Specifies the output mode."]
	#[doc = "This parameter can be a value of @ref TIM_LL_EC_OCMODE."]
	#[doc = ""]
	#[doc = "This feature can be modified afterwards using unitary function"]
	#[doc = "@ref LL_TIM_OC_SetMode()."]
	pub OCMode: u32,
	#[doc = "< Specifies the TIM Output Compare state."]
	#[doc = "This parameter can be a value of @ref TIM_LL_EC_OCSTATE."]
	#[doc = ""]
	#[doc = "This feature can be modified afterwards using unitary functions"]
	#[doc = "@ref LL_TIM_CC_EnableChannel() or @ref LL_TIM_CC_DisableChannel()."]
	pub OCState: u32,
	#[doc = "< Specifies the TIM complementary Output Compare state."]
	#[doc = "This parameter can be a value of @ref TIM_LL_EC_OCSTATE."]
	#[doc = ""]
	#[doc = "This feature can be modified afterwards using unitary functions"]
	#[doc = "@ref LL_TIM_CC_EnableChannel() or @ref LL_TIM_CC_DisableChannel()."]
	pub OCNState: u32,
	#[doc = "< Specifies the Compare value to be loaded into the Capture Compare Register."]
	#[doc = "This parameter can be a number between Min_Data=0x0000 and Max_Data=0xFFFF."]
	#[doc = ""]
	#[doc = "This feature can be modified afterwards using unitary function"]
	#[doc = "LL_TIM_OC_SetCompareCHx (x=1..6)."]
	pub CompareValue: u32,
	#[doc = "< Specifies the output polarity."]
	#[doc = "This parameter can be a value of @ref TIM_LL_EC_OCPOLARITY."]
	#[doc = ""]
	#[doc = "This feature can be modified afterwards using unitary function"]
	#[doc = "@ref LL_TIM_OC_SetPolarity()."]
	pub OCPolarity: u32,
	#[doc = "< Specifies the complementary output polarity."]
	#[doc = "This parameter can be a value of @ref TIM_LL_EC_OCPOLARITY."]
	#[doc = ""]
	#[doc = "This feature can be modified afterwards using unitary function"]
	#[doc = "@ref LL_TIM_OC_SetPolarity()."]
	pub OCNPolarity: u32,
	#[doc = "< Specifies the TIM Output Compare pin state during Idle state."]
	#[doc = "This parameter can be a value of @ref TIM_LL_EC_OCIDLESTATE."]
	#[doc = ""]
	#[doc = "This feature can be modified afterwards using unitary function"]
	#[doc = "@ref LL_TIM_OC_SetIdleState()."]
	pub OCIdleState: u32,
	#[doc = "< Specifies the TIM Output Compare pin state during Idle state."]
	#[doc = "This parameter can be a value of @ref TIM_LL_EC_OCIDLESTATE."]
	#[doc = ""]
	#[doc = "This feature can be modified afterwards using unitary function"]
	#[doc = "@ref LL_TIM_OC_SetIdleState()."]
	pub OCNIdleState: u32,
}
#[test]
fn bindgen_test_layout_LL_TIM_OC_InitTypeDef() {
	assert_eq!(
	           ::core::mem::size_of::<LL_TIM_OC_InitTypeDef>(),
	           32usize,
	           concat!("Size of: ", stringify!(LL_TIM_OC_InitTypeDef))
	);
	assert_eq!(
	           ::core::mem::align_of::<LL_TIM_OC_InitTypeDef>(),
	           4usize,
	           concat!("Alignment of ", stringify!(LL_TIM_OC_InitTypeDef))
	);
	fn test_field_OCMode() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_TIM_OC_InitTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).OCMode) as usize - ptr as usize
		           },
		           0usize,
		           concat!(
			"Offset of field: ",
			stringify!(LL_TIM_OC_InitTypeDef),
			"::",
			stringify!(OCMode)
		)
		);
	}
	test_field_OCMode();
	fn test_field_OCState() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_TIM_OC_InitTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).OCState) as usize - ptr as usize
		           },
		           4usize,
		           concat!(
			"Offset of field: ",
			stringify!(LL_TIM_OC_InitTypeDef),
			"::",
			stringify!(OCState)
		)
		);
	}
	test_field_OCState();
	fn test_field_OCNState() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_TIM_OC_InitTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).OCNState) as usize - ptr as usize
		           },
		           8usize,
		           concat!(
			"Offset of field: ",
			stringify!(LL_TIM_OC_InitTypeDef),
			"::",
			stringify!(OCNState)
		)
		);
	}
	test_field_OCNState();
	fn test_field_CompareValue() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_TIM_OC_InitTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).CompareValue) as usize - ptr as usize
		           },
		           12usize,
		           concat!(
			"Offset of field: ",
			stringify!(LL_TIM_OC_InitTypeDef),
			"::",
			stringify!(CompareValue)
		)
		);
	}
	test_field_CompareValue();
	fn test_field_OCPolarity() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_TIM_OC_InitTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).OCPolarity) as usize - ptr as usize
		           },
		           16usize,
		           concat!(
			"Offset of field: ",
			stringify!(LL_TIM_OC_InitTypeDef),
			"::",
			stringify!(OCPolarity)
		)
		);
	}
	test_field_OCPolarity();
	fn test_field_OCNPolarity() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_TIM_OC_InitTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).OCNPolarity) as usize - ptr as usize
		           },
		           20usize,
		           concat!(
			"Offset of field: ",
			stringify!(LL_TIM_OC_InitTypeDef),
			"::",
			stringify!(OCNPolarity)
		)
		);
	}
	test_field_OCNPolarity();
	fn test_field_OCIdleState() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_TIM_OC_InitTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).OCIdleState) as usize - ptr as usize
		           },
		           24usize,
		           concat!(
			"Offset of field: ",
			stringify!(LL_TIM_OC_InitTypeDef),
			"::",
			stringify!(OCIdleState)
		)
		);
	}
	test_field_OCIdleState();
	fn test_field_OCNIdleState() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_TIM_OC_InitTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).OCNIdleState) as usize - ptr as usize
		           },
		           28usize,
		           concat!(
			"Offset of field: ",
			stringify!(LL_TIM_OC_InitTypeDef),
			"::",
			stringify!(OCNIdleState)
		)
		);
	}
	test_field_OCNIdleState();
}
#[doc = " @brief  TIM Input Capture configuration structure definition."]
#[repr(C)]
pub struct LL_TIM_IC_InitTypeDef {
	#[doc = "< Specifies the active edge of the input signal."]
	#[doc = "This parameter can be a value of @ref TIM_LL_EC_IC_POLARITY."]
	#[doc = ""]
	#[doc = "This feature can be modified afterwards using unitary function"]
	#[doc = "@ref LL_TIM_IC_SetPolarity()."]
	pub ICPolarity: u32,
	#[doc = "< Specifies the input."]
	#[doc = "This parameter can be a value of @ref TIM_LL_EC_ACTIVEINPUT."]
	#[doc = ""]
	#[doc = "This feature can be modified afterwards using unitary function"]
	#[doc = "@ref LL_TIM_IC_SetActiveInput()."]
	pub ICActiveInput: u32,
	#[doc = "< Specifies the Input Capture Prescaler."]
	#[doc = "This parameter can be a value of @ref TIM_LL_EC_ICPSC."]
	#[doc = ""]
	#[doc = "This feature can be modified afterwards using unitary function"]
	#[doc = "@ref LL_TIM_IC_SetPrescaler()."]
	pub ICPrescaler: u32,
	#[doc = "< Specifies the input capture filter."]
	#[doc = "This parameter can be a value of @ref TIM_LL_EC_IC_FILTER."]
	#[doc = ""]
	#[doc = "This feature can be modified afterwards using unitary function"]
	#[doc = "@ref LL_TIM_IC_SetFilter()."]
	pub ICFilter: u32,
}
#[test]
fn bindgen_test_layout_LL_TIM_IC_InitTypeDef() {
	assert_eq!(
	           ::core::mem::size_of::<LL_TIM_IC_InitTypeDef>(),
	           16usize,
	           concat!("Size of: ", stringify!(LL_TIM_IC_InitTypeDef))
	);
	assert_eq!(
	           ::core::mem::align_of::<LL_TIM_IC_InitTypeDef>(),
	           4usize,
	           concat!("Alignment of ", stringify!(LL_TIM_IC_InitTypeDef))
	);
	fn test_field_ICPolarity() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_TIM_IC_InitTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).ICPolarity) as usize - ptr as usize
		           },
		           0usize,
		           concat!(
			"Offset of field: ",
			stringify!(LL_TIM_IC_InitTypeDef),
			"::",
			stringify!(ICPolarity)
		)
		);
	}
	test_field_ICPolarity();
	fn test_field_ICActiveInput() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_TIM_IC_InitTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).ICActiveInput) as usize - ptr as usize
		           },
		           4usize,
		           concat!(
			"Offset of field: ",
			stringify!(LL_TIM_IC_InitTypeDef),
			"::",
			stringify!(ICActiveInput)
		)
		);
	}
	test_field_ICActiveInput();
	fn test_field_ICPrescaler() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_TIM_IC_InitTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).ICPrescaler) as usize - ptr as usize
		           },
		           8usize,
		           concat!(
			"Offset of field: ",
			stringify!(LL_TIM_IC_InitTypeDef),
			"::",
			stringify!(ICPrescaler)
		)
		);
	}
	test_field_ICPrescaler();
	fn test_field_ICFilter() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_TIM_IC_InitTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).ICFilter) as usize - ptr as usize
		           },
		           12usize,
		           concat!(
			"Offset of field: ",
			stringify!(LL_TIM_IC_InitTypeDef),
			"::",
			stringify!(ICFilter)
		)
		);
	}
	test_field_ICFilter();
}
#[doc = " @brief  TIM Encoder interface configuration structure definition."]
#[repr(C)]
pub struct LL_TIM_ENCODER_InitTypeDef {
	#[doc = "< Specifies the encoder resolution (x2 or x4)."]
	#[doc = "This parameter can be a value of @ref TIM_LL_EC_ENCODERMODE."]
	#[doc = ""]
	#[doc = "This feature can be modified afterwards using unitary function"]
	#[doc = "@ref LL_TIM_SetEncoderMode()."]
	pub EncoderMode: u32,
	#[doc = "< Specifies the active edge of TI1 input."]
	#[doc = "This parameter can be a value of @ref TIM_LL_EC_IC_POLARITY."]
	#[doc = ""]
	#[doc = "This feature can be modified afterwards using unitary function"]
	#[doc = "@ref LL_TIM_IC_SetPolarity()."]
	pub IC1Polarity: u32,
	#[doc = "< Specifies the TI1 input source"]
	#[doc = "This parameter can be a value of @ref TIM_LL_EC_ACTIVEINPUT."]
	#[doc = ""]
	#[doc = "This feature can be modified afterwards using unitary function"]
	#[doc = "@ref LL_TIM_IC_SetActiveInput()."]
	pub IC1ActiveInput: u32,
	#[doc = "< Specifies the TI1 input prescaler value."]
	#[doc = "This parameter can be a value of @ref TIM_LL_EC_ICPSC."]
	#[doc = ""]
	#[doc = "This feature can be modified afterwards using unitary function"]
	#[doc = "@ref LL_TIM_IC_SetPrescaler()."]
	pub IC1Prescaler: u32,
	#[doc = "< Specifies the TI1 input filter."]
	#[doc = "This parameter can be a value of @ref TIM_LL_EC_IC_FILTER."]
	#[doc = ""]
	#[doc = "This feature can be modified afterwards using unitary function"]
	#[doc = "@ref LL_TIM_IC_SetFilter()."]
	pub IC1Filter: u32,
	#[doc = "< Specifies the active edge of TI2 input."]
	#[doc = "This parameter can be a value of @ref TIM_LL_EC_IC_POLARITY."]
	#[doc = ""]
	#[doc = "This feature can be modified afterwards using unitary function"]
	#[doc = "@ref LL_TIM_IC_SetPolarity()."]
	pub IC2Polarity: u32,
	#[doc = "< Specifies the TI2 input source"]
	#[doc = "This parameter can be a value of @ref TIM_LL_EC_ACTIVEINPUT."]
	#[doc = ""]
	#[doc = "This feature can be modified afterwards using unitary function"]
	#[doc = "@ref LL_TIM_IC_SetActiveInput()."]
	pub IC2ActiveInput: u32,
	#[doc = "< Specifies the TI2 input prescaler value."]
	#[doc = "This parameter can be a value of @ref TIM_LL_EC_ICPSC."]
	#[doc = ""]
	#[doc = "This feature can be modified afterwards using unitary function"]
	#[doc = "@ref LL_TIM_IC_SetPrescaler()."]
	pub IC2Prescaler: u32,
	#[doc = "< Specifies the TI2 input filter."]
	#[doc = "This parameter can be a value of @ref TIM_LL_EC_IC_FILTER."]
	#[doc = ""]
	#[doc = "This feature can be modified afterwards using unitary function"]
	#[doc = "@ref LL_TIM_IC_SetFilter()."]
	pub IC2Filter: u32,
}
#[test]
fn bindgen_test_layout_LL_TIM_ENCODER_InitTypeDef() {
	assert_eq!(
	           ::core::mem::size_of::<LL_TIM_ENCODER_InitTypeDef>(),
	           36usize,
	           concat!("Size of: ", stringify!(LL_TIM_ENCODER_InitTypeDef))
	);
	assert_eq!(
	           ::core::mem::align_of::<LL_TIM_ENCODER_InitTypeDef>(),
	           4usize,
	           concat!("Alignment of ", stringify!(LL_TIM_ENCODER_InitTypeDef))
	);
	fn test_field_EncoderMode() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_TIM_ENCODER_InitTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).EncoderMode) as usize - ptr as usize
		           },
		           0usize,
		           concat!(
			"Offset of field: ",
			stringify!(LL_TIM_ENCODER_InitTypeDef),
			"::",
			stringify!(EncoderMode)
		)
		);
	}
	test_field_EncoderMode();
	fn test_field_IC1Polarity() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_TIM_ENCODER_InitTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).IC1Polarity) as usize - ptr as usize
		           },
		           4usize,
		           concat!(
			"Offset of field: ",
			stringify!(LL_TIM_ENCODER_InitTypeDef),
			"::",
			stringify!(IC1Polarity)
		)
		);
	}
	test_field_IC1Polarity();
	fn test_field_IC1ActiveInput() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_TIM_ENCODER_InitTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).IC1ActiveInput) as usize - ptr as usize
		           },
		           8usize,
		           concat!(
			"Offset of field: ",
			stringify!(LL_TIM_ENCODER_InitTypeDef),
			"::",
			stringify!(IC1ActiveInput)
		)
		);
	}
	test_field_IC1ActiveInput();
	fn test_field_IC1Prescaler() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_TIM_ENCODER_InitTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).IC1Prescaler) as usize - ptr as usize
		           },
		           12usize,
		           concat!(
			"Offset of field: ",
			stringify!(LL_TIM_ENCODER_InitTypeDef),
			"::",
			stringify!(IC1Prescaler)
		)
		);
	}
	test_field_IC1Prescaler();
	fn test_field_IC1Filter() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_TIM_ENCODER_InitTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).IC1Filter) as usize - ptr as usize
		           },
		           16usize,
		           concat!(
			"Offset of field: ",
			stringify!(LL_TIM_ENCODER_InitTypeDef),
			"::",
			stringify!(IC1Filter)
		)
		);
	}
	test_field_IC1Filter();
	fn test_field_IC2Polarity() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_TIM_ENCODER_InitTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).IC2Polarity) as usize - ptr as usize
		           },
		           20usize,
		           concat!(
			"Offset of field: ",
			stringify!(LL_TIM_ENCODER_InitTypeDef),
			"::",
			stringify!(IC2Polarity)
		)
		);
	}
	test_field_IC2Polarity();
	fn test_field_IC2ActiveInput() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_TIM_ENCODER_InitTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).IC2ActiveInput) as usize - ptr as usize
		           },
		           24usize,
		           concat!(
			"Offset of field: ",
			stringify!(LL_TIM_ENCODER_InitTypeDef),
			"::",
			stringify!(IC2ActiveInput)
		)
		);
	}
	test_field_IC2ActiveInput();
	fn test_field_IC2Prescaler() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_TIM_ENCODER_InitTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).IC2Prescaler) as usize - ptr as usize
		           },
		           28usize,
		           concat!(
			"Offset of field: ",
			stringify!(LL_TIM_ENCODER_InitTypeDef),
			"::",
			stringify!(IC2Prescaler)
		)
		);
	}
	test_field_IC2Prescaler();
	fn test_field_IC2Filter() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_TIM_ENCODER_InitTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).IC2Filter) as usize - ptr as usize
		           },
		           32usize,
		           concat!(
			"Offset of field: ",
			stringify!(LL_TIM_ENCODER_InitTypeDef),
			"::",
			stringify!(IC2Filter)
		)
		);
	}
	test_field_IC2Filter();
}
#[doc = " @brief  TIM Hall sensor interface configuration structure definition."]
#[repr(C)]
pub struct LL_TIM_HALLSENSOR_InitTypeDef {
	#[doc = "< Specifies the active edge of TI1 input."]
	#[doc = "This parameter can be a value of @ref TIM_LL_EC_IC_POLARITY."]
	#[doc = ""]
	#[doc = "This feature can be modified afterwards using unitary function"]
	#[doc = "@ref LL_TIM_IC_SetPolarity()."]
	pub IC1Polarity: u32,
	#[doc = "< Specifies the TI1 input prescaler value."]
	#[doc = "Prescaler must be set to get a maximum counter period longer than the"]
	#[doc = "time interval between 2 consecutive changes on the Hall inputs."]
	#[doc = "This parameter can be a value of @ref TIM_LL_EC_ICPSC."]
	#[doc = ""]
	#[doc = "This feature can be modified afterwards using unitary function"]
	#[doc = "@ref LL_TIM_IC_SetPrescaler()."]
	pub IC1Prescaler: u32,
	#[doc = "< Specifies the TI1 input filter."]
	#[doc = "This parameter can be a value of"]
	#[doc = "@ref TIM_LL_EC_IC_FILTER."]
	#[doc = ""]
	#[doc = "This feature can be modified afterwards using unitary function"]
	#[doc = "@ref LL_TIM_IC_SetFilter()."]
	pub IC1Filter: u32,
	#[doc = "< Specifies the compare value to be loaded into the Capture Compare Register."]
	#[doc = "A positive pulse (TRGO event) is generated with a programmable delay every time"]
	#[doc = "a change occurs on the Hall inputs."]
	#[doc = "This parameter can be a number between Min_Data = 0x0000 and Max_Data = 0xFFFF."]
	#[doc = ""]
	#[doc = "This feature can be modified afterwards using unitary function"]
	#[doc = "@ref LL_TIM_OC_SetCompareCH2()."]
	pub CommutationDelay: u32,
}
#[test]
fn bindgen_test_layout_LL_TIM_HALLSENSOR_InitTypeDef() {
	assert_eq!(
	           ::core::mem::size_of::<LL_TIM_HALLSENSOR_InitTypeDef>(),
	           16usize,
	           concat!("Size of: ", stringify!(LL_TIM_HALLSENSOR_InitTypeDef))
	);
	assert_eq!(
	           ::core::mem::align_of::<LL_TIM_HALLSENSOR_InitTypeDef>(),
	           4usize,
	           concat!("Alignment of ", stringify!(LL_TIM_HALLSENSOR_InitTypeDef))
	);
	fn test_field_IC1Polarity() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_TIM_HALLSENSOR_InitTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).IC1Polarity) as usize - ptr as usize
		           },
		           0usize,
		           concat!(
			"Offset of field: ",
			stringify!(LL_TIM_HALLSENSOR_InitTypeDef),
			"::",
			stringify!(IC1Polarity)
		)
		);
	}
	test_field_IC1Polarity();
	fn test_field_IC1Prescaler() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_TIM_HALLSENSOR_InitTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).IC1Prescaler) as usize - ptr as usize
		           },
		           4usize,
		           concat!(
			"Offset of field: ",
			stringify!(LL_TIM_HALLSENSOR_InitTypeDef),
			"::",
			stringify!(IC1Prescaler)
		)
		);
	}
	test_field_IC1Prescaler();
	fn test_field_IC1Filter() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_TIM_HALLSENSOR_InitTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).IC1Filter) as usize - ptr as usize
		           },
		           8usize,
		           concat!(
			"Offset of field: ",
			stringify!(LL_TIM_HALLSENSOR_InitTypeDef),
			"::",
			stringify!(IC1Filter)
		)
		);
	}
	test_field_IC1Filter();
	fn test_field_CommutationDelay() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_TIM_HALLSENSOR_InitTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).CommutationDelay) as usize - ptr as usize
		           },
		           12usize,
		           concat!(
			"Offset of field: ",
			stringify!(LL_TIM_HALLSENSOR_InitTypeDef),
			"::",
			stringify!(CommutationDelay)
		)
		);
	}
	test_field_CommutationDelay();
}
#[doc = " @brief  BDTR (Break and Dead Time) structure definition"]
#[repr(C)]
pub struct LL_TIM_BDTR_InitTypeDef {
	#[doc = "< Specifies the Off-State selection used in Run mode."]
	#[doc = "This parameter can be a value of @ref TIM_LL_EC_OSSR"]
	#[doc = ""]
	#[doc = "This feature can be modified afterwards using unitary function"]
	#[doc = "@ref LL_TIM_SetOffStates()"]
	#[doc = ""]
	#[doc = "@note This bit-field cannot be modified as long as LOCK level 2 has been"]
	#[doc = "programmed."]
	pub OSSRState: u32,
	#[doc = "< Specifies the Off-State used in Idle state."]
	#[doc = "This parameter can be a value of @ref TIM_LL_EC_OSSI"]
	#[doc = ""]
	#[doc = "This feature can be modified afterwards using unitary function"]
	#[doc = "@ref LL_TIM_SetOffStates()"]
	#[doc = ""]
	#[doc = "@note This bit-field cannot be modified as long as LOCK level 2 has been"]
	#[doc = "programmed."]
	pub OSSIState: u32,
	#[doc = "< Specifies the LOCK level parameters."]
	#[doc = "This parameter can be a value of @ref TIM_LL_EC_LOCKLEVEL"]
	#[doc = ""]
	#[doc = "@note The LOCK bits can be written only once after the reset. Once the TIMx_BDTR"]
	#[doc = "register has been written, their content is frozen until the next reset."]
	pub LockLevel: u32,
	#[doc = "< Specifies the delay time between the switching-off and the"]
	#[doc = "switching-on of the outputs."]
	#[doc = "This parameter can be a number between Min_Data = 0x00 and Max_Data = 0xFF."]
	#[doc = ""]
	#[doc = "This feature can be modified afterwards using unitary function"]
	#[doc = "@ref LL_TIM_OC_SetDeadTime()"]
	#[doc = ""]
	#[doc = "@note This bit-field can not be modified as long as LOCK level 1, 2 or 3 has been"]
	#[doc = "programmed."]
	pub DeadTime: u8,
	#[doc = "< Specifies whether the TIM Break input is enabled or not."]
	#[doc = "This parameter can be a value of @ref TIM_LL_EC_BREAK_ENABLE"]
	#[doc = ""]
	#[doc = "This feature can be modified afterwards using unitary functions"]
	#[doc = "@ref LL_TIM_EnableBRK() or @ref LL_TIM_DisableBRK()"]
	#[doc = ""]
	#[doc = "@note This bit-field can not be modified as long as LOCK level 1 has been"]
	#[doc = "programmed."]
	pub BreakState: u16,
	#[doc = "< Specifies the TIM Break Input pin polarity."]
	#[doc = "This parameter can be a value of @ref TIM_LL_EC_BREAK_POLARITY"]
	#[doc = ""]
	#[doc = "This feature can be modified afterwards using unitary function"]
	#[doc = "@ref LL_TIM_ConfigBRK()"]
	#[doc = ""]
	#[doc = "@note This bit-field can not be modified as long as LOCK level 1 has been"]
	#[doc = "programmed."]
	pub BreakPolarity: u32,
	#[doc = "< Specifies the TIM Break Filter."]
	#[doc = "This parameter can be a value of @ref TIM_LL_EC_BREAK_FILTER"]
	#[doc = ""]
	#[doc = "This feature can be modified afterwards using unitary function"]
	#[doc = "@ref LL_TIM_ConfigBRK()"]
	#[doc = ""]
	#[doc = "@note This bit-field can not be modified as long as LOCK level 1 has been"]
	#[doc = "programmed."]
	pub BreakFilter: u32,
	#[doc = "< Specifies the alternate function mode of the break input."]
	#[doc = "This parameter can be a value of @ref TIM_LL_EC_BREAK_AFMODE"]
	#[doc = ""]
	#[doc = "This feature can be modified afterwards using unitary functions"]
	#[doc = "@ref LL_TIM_ConfigBRK()"]
	#[doc = ""]
	#[doc = "@note Bidirectional break input is only supported by advanced timers instances."]
	#[doc = ""]
	#[doc = "@note This bit-field can not be modified as long as LOCK level 1 has been"]
	#[doc = "programmed."]
	pub BreakAFMode: u32,
	#[doc = "< Specifies whether the TIM Break2 input is enabled or not."]
	#[doc = "This parameter can be a value of @ref TIM_LL_EC_BREAK2_ENABLE"]
	#[doc = ""]
	#[doc = "This feature can be modified afterwards using unitary functions"]
	#[doc = "@ref LL_TIM_EnableBRK2() or @ref LL_TIM_DisableBRK2()"]
	#[doc = ""]
	#[doc = "@note This bit-field can not be modified as long as LOCK level 1 has been"]
	#[doc = "programmed."]
	pub Break2State: u32,
	#[doc = "< Specifies the TIM Break2 Input pin polarity."]
	#[doc = "This parameter can be a value of @ref TIM_LL_EC_BREAK2_POLARITY"]
	#[doc = ""]
	#[doc = "This feature can be modified afterwards using unitary function"]
	#[doc = "@ref LL_TIM_ConfigBRK2()"]
	#[doc = ""]
	#[doc = "@note This bit-field can not be modified as long as LOCK level 1 has been"]
	#[doc = "programmed."]
	pub Break2Polarity: u32,
	#[doc = "< Specifies the TIM Break2 Filter."]
	#[doc = "This parameter can be a value of @ref TIM_LL_EC_BREAK2_FILTER"]
	#[doc = ""]
	#[doc = "This feature can be modified afterwards using unitary function"]
	#[doc = "@ref LL_TIM_ConfigBRK2()"]
	#[doc = ""]
	#[doc = "@note This bit-field can not be modified as long as LOCK level 1 has been"]
	#[doc = "programmed."]
	pub Break2Filter: u32,
	#[doc = "< Specifies the alternate function mode of the break2 input."]
	#[doc = "This parameter can be a value of @ref TIM_LL_EC_BREAK2_AFMODE"]
	#[doc = ""]
	#[doc = "This feature can be modified afterwards using unitary functions"]
	#[doc = "@ref LL_TIM_ConfigBRK2()"]
	#[doc = ""]
	#[doc = "@note Bidirectional break input is only supported by advanced timers instances."]
	#[doc = ""]
	#[doc = "@note This bit-field can not be modified as long as LOCK level 1 has been"]
	#[doc = "programmed."]
	pub Break2AFMode: u32,
	#[doc = "< Specifies whether the TIM Automatic Output feature is enabled or not."]
	#[doc = "This parameter can be a value of @ref TIM_LL_EC_AUTOMATICOUTPUT_ENABLE"]
	#[doc = ""]
	#[doc = "This feature can be modified afterwards using unitary functions"]
	#[doc = "@ref LL_TIM_EnableAutomaticOutput() or @ref LL_TIM_DisableAutomaticOutput()"]
	#[doc = ""]
	#[doc = "@note This bit-field can not be modified as long as LOCK level 1 has been"]
	#[doc = "programmed."]
	pub AutomaticOutput: u32,
}
#[test]
fn bindgen_test_layout_LL_TIM_BDTR_InitTypeDef() {
	assert_eq!(
	           ::core::mem::size_of::<LL_TIM_BDTR_InitTypeDef>(),
	           48usize,
	           concat!("Size of: ", stringify!(LL_TIM_BDTR_InitTypeDef))
	);
	assert_eq!(
	           ::core::mem::align_of::<LL_TIM_BDTR_InitTypeDef>(),
	           4usize,
	           concat!("Alignment of ", stringify!(LL_TIM_BDTR_InitTypeDef))
	);
	fn test_field_OSSRState() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_TIM_BDTR_InitTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).OSSRState) as usize - ptr as usize
		           },
		           0usize,
		           concat!(
			"Offset of field: ",
			stringify!(LL_TIM_BDTR_InitTypeDef),
			"::",
			stringify!(OSSRState)
		)
		);
	}
	test_field_OSSRState();
	fn test_field_OSSIState() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_TIM_BDTR_InitTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).OSSIState) as usize - ptr as usize
		           },
		           4usize,
		           concat!(
			"Offset of field: ",
			stringify!(LL_TIM_BDTR_InitTypeDef),
			"::",
			stringify!(OSSIState)
		)
		);
	}
	test_field_OSSIState();
	fn test_field_LockLevel() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_TIM_BDTR_InitTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).LockLevel) as usize - ptr as usize
		           },
		           8usize,
		           concat!(
			"Offset of field: ",
			stringify!(LL_TIM_BDTR_InitTypeDef),
			"::",
			stringify!(LockLevel)
		)
		);
	}
	test_field_LockLevel();
	fn test_field_DeadTime() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_TIM_BDTR_InitTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).DeadTime) as usize - ptr as usize
		           },
		           12usize,
		           concat!(
			"Offset of field: ",
			stringify!(LL_TIM_BDTR_InitTypeDef),
			"::",
			stringify!(DeadTime)
		)
		);
	}
	test_field_DeadTime();
	fn test_field_BreakState() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_TIM_BDTR_InitTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).BreakState) as usize - ptr as usize
		           },
		           14usize,
		           concat!(
			"Offset of field: ",
			stringify!(LL_TIM_BDTR_InitTypeDef),
			"::",
			stringify!(BreakState)
		)
		);
	}
	test_field_BreakState();
	fn test_field_BreakPolarity() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_TIM_BDTR_InitTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).BreakPolarity) as usize - ptr as usize
		           },
		           16usize,
		           concat!(
			"Offset of field: ",
			stringify!(LL_TIM_BDTR_InitTypeDef),
			"::",
			stringify!(BreakPolarity)
		)
		);
	}
	test_field_BreakPolarity();
	fn test_field_BreakFilter() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_TIM_BDTR_InitTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).BreakFilter) as usize - ptr as usize
		           },
		           20usize,
		           concat!(
			"Offset of field: ",
			stringify!(LL_TIM_BDTR_InitTypeDef),
			"::",
			stringify!(BreakFilter)
		)
		);
	}
	test_field_BreakFilter();
	fn test_field_BreakAFMode() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_TIM_BDTR_InitTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).BreakAFMode) as usize - ptr as usize
		           },
		           24usize,
		           concat!(
			"Offset of field: ",
			stringify!(LL_TIM_BDTR_InitTypeDef),
			"::",
			stringify!(BreakAFMode)
		)
		);
	}
	test_field_BreakAFMode();
	fn test_field_Break2State() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_TIM_BDTR_InitTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).Break2State) as usize - ptr as usize
		           },
		           28usize,
		           concat!(
			"Offset of field: ",
			stringify!(LL_TIM_BDTR_InitTypeDef),
			"::",
			stringify!(Break2State)
		)
		);
	}
	test_field_Break2State();
	fn test_field_Break2Polarity() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_TIM_BDTR_InitTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).Break2Polarity) as usize - ptr as usize
		           },
		           32usize,
		           concat!(
			"Offset of field: ",
			stringify!(LL_TIM_BDTR_InitTypeDef),
			"::",
			stringify!(Break2Polarity)
		)
		);
	}
	test_field_Break2Polarity();
	fn test_field_Break2Filter() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_TIM_BDTR_InitTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).Break2Filter) as usize - ptr as usize
		           },
		           36usize,
		           concat!(
			"Offset of field: ",
			stringify!(LL_TIM_BDTR_InitTypeDef),
			"::",
			stringify!(Break2Filter)
		)
		);
	}
	test_field_Break2Filter();
	fn test_field_Break2AFMode() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_TIM_BDTR_InitTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).Break2AFMode) as usize - ptr as usize
		           },
		           40usize,
		           concat!(
			"Offset of field: ",
			stringify!(LL_TIM_BDTR_InitTypeDef),
			"::",
			stringify!(Break2AFMode)
		)
		);
	}
	test_field_Break2AFMode();
	fn test_field_AutomaticOutput() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_TIM_BDTR_InitTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).AutomaticOutput) as usize - ptr as usize
		           },
		           44usize,
		           concat!(
			"Offset of field: ",
			stringify!(LL_TIM_BDTR_InitTypeDef),
			"::",
			stringify!(AutomaticOutput)
		)
		);
	}
	test_field_AutomaticOutput();
}
extern "C" {
	#[doc = " @defgroup TIM_LL_EF_Init Initialisation and deinitialisation functions"]
	#[doc = " @{"]
	pub fn LL_TIM_DeInit(TIMx: *mut TIM_TypeDef) -> ErrorStatus;
}
extern "C" {
	pub fn LL_TIM_StructInit(TIM_InitStruct: *mut LL_TIM_InitTypeDef);
}
extern "C" {
	pub fn LL_TIM_Init(TIMx: *mut TIM_TypeDef, TIM_InitStruct: *mut LL_TIM_InitTypeDef) -> ErrorStatus;
}
extern "C" {
	pub fn LL_TIM_OC_StructInit(TIM_OC_InitStruct: *mut LL_TIM_OC_InitTypeDef);
}
extern "C" {
	pub fn LL_TIM_OC_Init(TIMx: *mut TIM_TypeDef, Channel: u32, TIM_OC_InitStruct: *mut LL_TIM_OC_InitTypeDef) -> ErrorStatus;
}
extern "C" {
	pub fn LL_TIM_IC_StructInit(TIM_ICInitStruct: *mut LL_TIM_IC_InitTypeDef);
}
extern "C" {
	pub fn LL_TIM_IC_Init(TIMx: *mut TIM_TypeDef, Channel: u32, TIM_IC_InitStruct: *mut LL_TIM_IC_InitTypeDef) -> ErrorStatus;
}
extern "C" {
	pub fn LL_TIM_ENCODER_StructInit(TIM_EncoderInitStruct: *mut LL_TIM_ENCODER_InitTypeDef);
}
extern "C" {
	pub fn LL_TIM_ENCODER_Init(TIMx: *mut TIM_TypeDef, TIM_EncoderInitStruct: *mut LL_TIM_ENCODER_InitTypeDef) -> ErrorStatus;
}
extern "C" {
	pub fn LL_TIM_HALLSENSOR_StructInit(TIM_HallSensorInitStruct: *mut LL_TIM_HALLSENSOR_InitTypeDef);
}
extern "C" {
	pub fn LL_TIM_HALLSENSOR_Init(TIMx: *mut TIM_TypeDef, TIM_HallSensorInitStruct: *mut LL_TIM_HALLSENSOR_InitTypeDef)
	                              -> ErrorStatus;
}
extern "C" {
	pub fn LL_TIM_BDTR_StructInit(TIM_BDTRInitStruct: *mut LL_TIM_BDTR_InitTypeDef);
}
extern "C" {
	pub fn LL_TIM_BDTR_Init(TIMx: *mut TIM_TypeDef, TIM_BDTRInitStruct: *mut LL_TIM_BDTR_InitTypeDef) -> ErrorStatus;
}
#[doc = " Timer ISR"]
pub type FuriHalInterruptISR = ::core::option::Option<unsafe extern "C" fn(context: *mut core::ffi::c_void)>;
#[repr(u32)]
#[non_exhaustive]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum FuriHalInterruptId {
	FuriHalInterruptIdTim1TrgComTim17 = 0,
	FuriHalInterruptIdTim1Cc = 1,
	FuriHalInterruptIdTim1UpTim16 = 2,
	FuriHalInterruptIdTIM2 = 3,
	FuriHalInterruptIdDma1Ch1 = 4,
	FuriHalInterruptIdDma1Ch2 = 5,
	FuriHalInterruptIdDma1Ch3 = 6,
	FuriHalInterruptIdDma1Ch4 = 7,
	FuriHalInterruptIdDma1Ch5 = 8,
	FuriHalInterruptIdDma1Ch6 = 9,
	FuriHalInterruptIdDma1Ch7 = 10,
	FuriHalInterruptIdDma2Ch1 = 11,
	FuriHalInterruptIdDma2Ch2 = 12,
	FuriHalInterruptIdDma2Ch3 = 13,
	FuriHalInterruptIdDma2Ch4 = 14,
	FuriHalInterruptIdDma2Ch5 = 15,
	FuriHalInterruptIdDma2Ch6 = 16,
	FuriHalInterruptIdDma2Ch7 = 17,
	FuriHalInterruptIdRcc = 18,
	FuriHalInterruptIdCOMP = 19,
	FuriHalInterruptIdHsem = 20,
	FuriHalInterruptIdLpTim1 = 21,
	FuriHalInterruptIdLpTim2 = 22,
	FuriHalInterruptIdMax = 23,
}
extern "C" {
	#[doc = " Initialize interrupt subsystem"]
	pub fn furi_hal_interrupt_init();
}
extern "C" {
	#[doc = " Set ISR and enable interrupt with default priority"]
	#[doc = " We don't clear interrupt flags for you, do it by your self."]
	#[doc = " @param index - interrupt ID"]
	#[doc = " @param isr - your interrupt service routine or use NULL to clear"]
	#[doc = " @param context - isr context"]
	pub fn furi_hal_interrupt_set_isr(index: FuriHalInterruptId, isr: FuriHalInterruptISR, context: *mut core::ffi::c_void);
}
extern "C" {
	#[doc = " Set ISR and enable interrupt with custom priority"]
	#[doc = " We don't clear interrupt flags for you, do it by your self."]
	#[doc = " @param index - interrupt ID"]
	#[doc = " @param priority - 0 to 15, 0 highest"]
	#[doc = " @param isr - your interrupt service routine or use NULL to clear"]
	#[doc = " @param context - isr context"]
	pub fn furi_hal_interrupt_set_isr_ex(index: FuriHalInterruptId,
	                                     priority: u16,
	                                     isr: FuriHalInterruptISR,
	                                     context: *mut core::ffi::c_void);
}
extern "C" {
	pub fn furi_hal_os_init();
}
extern "C" {
	pub fn furi_hal_os_tick();
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum FuriHalPwmOutputId {
	FuriHalPwmOutputIdTim1PA7 = 0,
	FuriHalPwmOutputIdLptim2PA4 = 1,
}
extern "C" {
	#[doc = " Enable PWM channel and set parameters"]
	#[doc = ""]
	#[doc = " @param[in]  channel  PWM channel (FuriHalPwmOutputId)"]
	#[doc = " @param[in]  freq  Frequency in Hz"]
	#[doc = " @param[in]  duty  Duty cycle value in %"]
	pub fn furi_hal_pwm_start(channel: FuriHalPwmOutputId, freq: u32, duty: u8);
}
extern "C" {
	#[doc = " Disable PWM channel"]
	#[doc = ""]
	#[doc = " @param[in]  channel  PWM channel (FuriHalPwmOutputId)"]
	pub fn furi_hal_pwm_stop(channel: FuriHalPwmOutputId);
}
extern "C" {
	#[doc = " Set PWM channel parameters"]
	#[doc = ""]
	#[doc = " @param[in]  channel  PWM channel (FuriHalPwmOutputId)"]
	#[doc = " @param[in]  freq  Frequency in Hz"]
	#[doc = " @param[in]  duty  Duty cycle value in %"]
	pub fn furi_hal_pwm_set_params(channel: FuriHalPwmOutputId, freq: u32, duty: u8);
}
#[doc = " @brief  SPI Init structures definition"]
#[repr(C)]
pub struct LL_SPI_InitTypeDef {
	#[doc = "< Specifies the SPI unidirectional or bidirectional data mode."]
	#[doc = "This parameter can be a value of @ref SPI_LL_EC_TRANSFER_MODE."]
	#[doc = ""]
	#[doc = "This feature can be modified afterwards using unitary function @ref LL_SPI_SetTransferDirection()."]
	pub TransferDirection: u32,
	#[doc = "< Specifies the SPI mode (Master/Slave)."]
	#[doc = "This parameter can be a value of @ref SPI_LL_EC_MODE."]
	#[doc = ""]
	#[doc = "This feature can be modified afterwards using unitary function @ref LL_SPI_SetMode()."]
	pub Mode: u32,
	#[doc = "< Specifies the SPI data width."]
	#[doc = "This parameter can be a value of @ref SPI_LL_EC_DATAWIDTH."]
	#[doc = ""]
	#[doc = "This feature can be modified afterwards using unitary function @ref LL_SPI_SetDataWidth()."]
	pub DataWidth: u32,
	#[doc = "< Specifies the serial clock steady state."]
	#[doc = "This parameter can be a value of @ref SPI_LL_EC_POLARITY."]
	#[doc = ""]
	#[doc = "This feature can be modified afterwards using unitary function @ref LL_SPI_SetClockPolarity()."]
	pub ClockPolarity: u32,
	#[doc = "< Specifies the clock active edge for the bit capture."]
	#[doc = "This parameter can be a value of @ref SPI_LL_EC_PHASE."]
	#[doc = ""]
	#[doc = "This feature can be modified afterwards using unitary function @ref LL_SPI_SetClockPhase()."]
	pub ClockPhase: u32,
	#[doc = "< Specifies whether the NSS signal is managed by hardware (NSS pin) or by software using the SSI bit."]
	#[doc = "This parameter can be a value of @ref SPI_LL_EC_NSS_MODE."]
	#[doc = ""]
	#[doc = "This feature can be modified afterwards using unitary function @ref LL_SPI_SetNSSMode()."]
	pub NSS: u32,
	#[doc = "< Specifies the BaudRate prescaler value which will be used to configure the transmit and receive SCK clock."]
	#[doc = "This parameter can be a value of @ref SPI_LL_EC_BAUDRATEPRESCALER."]
	#[doc = "@note The communication clock is derived from the master clock. The slave clock does not need to be set."]
	#[doc = ""]
	#[doc = "This feature can be modified afterwards using unitary function @ref LL_SPI_SetBaudRatePrescaler()."]
	pub BaudRate: u32,
	#[doc = "< Specifies whether data transfers start from MSB or LSB bit."]
	#[doc = "This parameter can be a value of @ref SPI_LL_EC_BIT_ORDER."]
	#[doc = ""]
	#[doc = "This feature can be modified afterwards using unitary function @ref LL_SPI_SetTransferBitOrder()."]
	pub BitOrder: u32,
	#[doc = "< Specifies if the CRC calculation is enabled or not."]
	#[doc = "This parameter can be a value of @ref SPI_LL_EC_CRC_CALCULATION."]
	#[doc = ""]
	#[doc = "This feature can be modified afterwards using unitary functions @ref LL_SPI_EnableCRC() and @ref LL_SPI_DisableCRC()."]
	pub CRCCalculation: u32,
	#[doc = "< Specifies the polynomial used for the CRC calculation."]
	#[doc = "This parameter must be a number between Min_Data = 0x00 and Max_Data = 0xFFFF."]
	#[doc = ""]
	#[doc = "This feature can be modified afterwards using unitary function @ref LL_SPI_SetCRCPolynomial()."]
	pub CRCPoly: u32,
}
#[test]
fn bindgen_test_layout_LL_SPI_InitTypeDef() {
	assert_eq!(
	           ::core::mem::size_of::<LL_SPI_InitTypeDef>(),
	           40usize,
	           concat!("Size of: ", stringify!(LL_SPI_InitTypeDef))
	);
	assert_eq!(
	           ::core::mem::align_of::<LL_SPI_InitTypeDef>(),
	           4usize,
	           concat!("Alignment of ", stringify!(LL_SPI_InitTypeDef))
	);
	fn test_field_TransferDirection() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_SPI_InitTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).TransferDirection) as usize - ptr as usize
		           },
		           0usize,
		           concat!(
			"Offset of field: ",
			stringify!(LL_SPI_InitTypeDef),
			"::",
			stringify!(TransferDirection)
		)
		);
	}
	test_field_TransferDirection();
	fn test_field_Mode() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_SPI_InitTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).Mode) as usize - ptr as usize
		           },
		           4usize,
		           concat!("Offset of field: ", stringify!(LL_SPI_InitTypeDef), "::", stringify!(Mode))
		);
	}
	test_field_Mode();
	fn test_field_DataWidth() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_SPI_InitTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).DataWidth) as usize - ptr as usize
		           },
		           8usize,
		           concat!(
			"Offset of field: ",
			stringify!(LL_SPI_InitTypeDef),
			"::",
			stringify!(DataWidth)
		)
		);
	}
	test_field_DataWidth();
	fn test_field_ClockPolarity() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_SPI_InitTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).ClockPolarity) as usize - ptr as usize
		           },
		           12usize,
		           concat!(
			"Offset of field: ",
			stringify!(LL_SPI_InitTypeDef),
			"::",
			stringify!(ClockPolarity)
		)
		);
	}
	test_field_ClockPolarity();
	fn test_field_ClockPhase() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_SPI_InitTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).ClockPhase) as usize - ptr as usize
		           },
		           16usize,
		           concat!(
			"Offset of field: ",
			stringify!(LL_SPI_InitTypeDef),
			"::",
			stringify!(ClockPhase)
		)
		);
	}
	test_field_ClockPhase();
	fn test_field_NSS() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_SPI_InitTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).NSS) as usize - ptr as usize
		           },
		           20usize,
		           concat!("Offset of field: ", stringify!(LL_SPI_InitTypeDef), "::", stringify!(NSS))
		);
	}
	test_field_NSS();
	fn test_field_BaudRate() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_SPI_InitTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).BaudRate) as usize - ptr as usize
		           },
		           24usize,
		           concat!(
			"Offset of field: ",
			stringify!(LL_SPI_InitTypeDef),
			"::",
			stringify!(BaudRate)
		)
		);
	}
	test_field_BaudRate();
	fn test_field_BitOrder() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_SPI_InitTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).BitOrder) as usize - ptr as usize
		           },
		           28usize,
		           concat!(
			"Offset of field: ",
			stringify!(LL_SPI_InitTypeDef),
			"::",
			stringify!(BitOrder)
		)
		);
	}
	test_field_BitOrder();
	fn test_field_CRCCalculation() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_SPI_InitTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).CRCCalculation) as usize - ptr as usize
		           },
		           32usize,
		           concat!(
			"Offset of field: ",
			stringify!(LL_SPI_InitTypeDef),
			"::",
			stringify!(CRCCalculation)
		)
		);
	}
	test_field_CRCCalculation();
	fn test_field_CRCPoly() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_SPI_InitTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).CRCPoly) as usize - ptr as usize
		           },
		           36usize,
		           concat!("Offset of field: ", stringify!(LL_SPI_InitTypeDef), "::", stringify!(CRCPoly))
		);
	}
	test_field_CRCPoly();
}
extern "C" {
	#[doc = " @defgroup SPI_LL_EF_Init Initialization and de-initialization functions"]
	#[doc = " @{"]
	pub fn LL_SPI_DeInit(SPIx: *mut SPI_TypeDef) -> ErrorStatus;
}
extern "C" {
	pub fn LL_SPI_Init(SPIx: *mut SPI_TypeDef, SPI_InitStruct: *mut LL_SPI_InitTypeDef) -> ErrorStatus;
}
extern "C" {
	pub fn LL_SPI_StructInit(SPI_InitStruct: *mut LL_SPI_InitTypeDef);
}
#[repr(u32)]
#[non_exhaustive]
#[doc = " FuriHal spi bus states"]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum FuriHalSpiBusEvent {
	#[doc = "< Bus initialization event, called on system start"]
	FuriHalSpiBusEventInit = 0,
	#[doc = "< Bus deinitialization event, called on system stop"]
	FuriHalSpiBusEventDeinit = 1,
	#[doc = "< Bus lock event, called before activation"]
	FuriHalSpiBusEventLock = 2,
	#[doc = "< Bus unlock event, called after deactivation"]
	FuriHalSpiBusEventUnlock = 3,
	#[doc = "< Bus activation event, called before handle activation"]
	FuriHalSpiBusEventActivate = 4,
	#[doc = "< Bus deactivation event, called after handle deactivation"]
	FuriHalSpiBusEventDeactivate = 5,
}
#[doc = " FuriHal spi bus event callback"]
pub type FuriHalSpiBusEventCallback =
	::core::option::Option<unsafe extern "C" fn(bus: *mut FuriHalSpiBus, event: FuriHalSpiBusEvent)>;
#[doc = " FuriHal spi bus"]
#[repr(C)]
pub struct FuriHalSpiBus {
	pub spi: *mut SPI_TypeDef,
	pub callback: FuriHalSpiBusEventCallback,
	pub current_handle: *mut FuriHalSpiBusHandle,
}
#[test]
fn bindgen_test_layout_FuriHalSpiBus() {
	assert_eq!(
	           ::core::mem::size_of::<FuriHalSpiBus>(),
	           12usize,
	           concat!("Size of: ", stringify!(FuriHalSpiBus))
	);
	assert_eq!(
	           ::core::mem::align_of::<FuriHalSpiBus>(),
	           4usize,
	           concat!("Alignment of ", stringify!(FuriHalSpiBus))
	);
	fn test_field_spi() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<FuriHalSpiBus>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).spi) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(FuriHalSpiBus), "::", stringify!(spi))
		);
	}
	test_field_spi();
	fn test_field_callback() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<FuriHalSpiBus>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).callback) as usize - ptr as usize
		           },
		           4usize,
		           concat!("Offset of field: ", stringify!(FuriHalSpiBus), "::", stringify!(callback))
		);
	}
	test_field_callback();
	fn test_field_current_handle() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<FuriHalSpiBus>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).current_handle) as usize - ptr as usize
		           },
		           8usize,
		           concat!(
			"Offset of field: ",
			stringify!(FuriHalSpiBus),
			"::",
			stringify!(current_handle)
		)
		);
	}
	test_field_current_handle();
}
#[repr(u32)]
#[non_exhaustive]
#[doc = " FuriHal spi handle states"]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum FuriHalSpiBusHandleEvent {
	#[doc = "< Handle init, called on system start, initialize gpio for idle state"]
	FuriHalSpiBusHandleEventInit = 0,
	#[doc = "< Handle deinit, called on system stop, deinitialize gpio for default state"]
	FuriHalSpiBusHandleEventDeinit = 1,
	#[doc = "< Handle activate: connect gpio and apply bus config"]
	FuriHalSpiBusHandleEventActivate = 2,
	#[doc = "< Handle deactivate: disconnect gpio and reset bus config"]
	FuriHalSpiBusHandleEventDeactivate = 3,
}
#[doc = " FuriHal spi handle event callback"]
pub type FuriHalSpiBusHandleEventCallback =
	::core::option::Option<unsafe extern "C" fn(handle: *mut FuriHalSpiBusHandle, event: FuriHalSpiBusHandleEvent)>;
#[doc = " FuriHal spi handle"]
#[repr(C)]
pub struct FuriHalSpiBusHandle {
	pub bus: *mut FuriHalSpiBus,
	pub callback: FuriHalSpiBusHandleEventCallback,
	pub miso: *const GpioPin,
	pub mosi: *const GpioPin,
	pub sck: *const GpioPin,
	pub cs: *const GpioPin,
}
#[test]
fn bindgen_test_layout_FuriHalSpiBusHandle() {
	assert_eq!(
	           ::core::mem::size_of::<FuriHalSpiBusHandle>(),
	           24usize,
	           concat!("Size of: ", stringify!(FuriHalSpiBusHandle))
	);
	assert_eq!(
	           ::core::mem::align_of::<FuriHalSpiBusHandle>(),
	           4usize,
	           concat!("Alignment of ", stringify!(FuriHalSpiBusHandle))
	);
	fn test_field_bus() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<FuriHalSpiBusHandle>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).bus) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(FuriHalSpiBusHandle), "::", stringify!(bus))
		);
	}
	test_field_bus();
	fn test_field_callback() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<FuriHalSpiBusHandle>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).callback) as usize - ptr as usize
		           },
		           4usize,
		           concat!(
			"Offset of field: ",
			stringify!(FuriHalSpiBusHandle),
			"::",
			stringify!(callback)
		)
		);
	}
	test_field_callback();
	fn test_field_miso() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<FuriHalSpiBusHandle>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).miso) as usize - ptr as usize
		           },
		           8usize,
		           concat!("Offset of field: ", stringify!(FuriHalSpiBusHandle), "::", stringify!(miso))
		);
	}
	test_field_miso();
	fn test_field_mosi() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<FuriHalSpiBusHandle>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).mosi) as usize - ptr as usize
		           },
		           12usize,
		           concat!("Offset of field: ", stringify!(FuriHalSpiBusHandle), "::", stringify!(mosi))
		);
	}
	test_field_mosi();
	fn test_field_sck() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<FuriHalSpiBusHandle>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).sck) as usize - ptr as usize
		           },
		           16usize,
		           concat!("Offset of field: ", stringify!(FuriHalSpiBusHandle), "::", stringify!(sck))
		);
	}
	test_field_sck();
	fn test_field_cs() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<FuriHalSpiBusHandle>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).cs) as usize - ptr as usize
		           },
		           20usize,
		           concat!("Offset of field: ", stringify!(FuriHalSpiBusHandle), "::", stringify!(cs))
		);
	}
	test_field_cs();
}
extern "C" {
	#[doc = " Preset for ST25R916"]
	pub static furi_hal_spi_preset_2edge_low_8m: LL_SPI_InitTypeDef;
}
extern "C" {
	#[doc = " Preset for CC1101"]
	pub static furi_hal_spi_preset_1edge_low_8m: LL_SPI_InitTypeDef;
}
extern "C" {
	#[doc = " Preset for ST7567 (Display)"]
	pub static furi_hal_spi_preset_1edge_low_4m: LL_SPI_InitTypeDef;
}
extern "C" {
	#[doc = " Preset for SdCard in fast mode"]
	pub static furi_hal_spi_preset_1edge_low_16m: LL_SPI_InitTypeDef;
}
extern "C" {
	#[doc = " Preset for SdCard in slow mode"]
	pub static furi_hal_spi_preset_1edge_low_2m: LL_SPI_InitTypeDef;
}
extern "C" {
	#[doc = " Furi Hal Spi Bus R (Radio: CC1101, Nfc, External)"]
	pub static mut furi_hal_spi_bus_r: FuriHalSpiBus;
}
extern "C" {
	#[doc = " Furi Hal Spi Bus D (Display, SdCard)"]
	pub static mut furi_hal_spi_bus_d: FuriHalSpiBus;
}
extern "C" {
	#[doc = " CC1101 on `furi_hal_spi_bus_r`"]
	pub static mut furi_hal_spi_bus_handle_subghz: FuriHalSpiBusHandle;
}
extern "C" {
	#[doc = " ST25R3916 on `furi_hal_spi_bus_r`"]
	pub static mut furi_hal_spi_bus_handle_nfc: FuriHalSpiBusHandle;
}
extern "C" {
	#[doc = " External on `furi_hal_spi_bus_r`"]
	#[doc = " Preset: `furi_hal_spi_preset_1edge_low_2m`"]
	#[doc = ""]
	#[doc = " miso: pa6"]
	#[doc = " mosi: pa7"]
	#[doc = " sck: pb3"]
	#[doc = " cs:  pa4 (software controlled)"]
	#[doc = ""]
	#[doc = " @warning not initialized by default, call `furi_hal_spi_bus_handle_init` to initialize"]
	#[doc = " Bus pins are floating on inactive state, CS high after initialization"]
	#[doc = ""]
	pub static mut furi_hal_spi_bus_handle_external: FuriHalSpiBusHandle;
}
extern "C" {
	#[doc = " ST7567(Display) on `furi_hal_spi_bus_d`"]
	pub static mut furi_hal_spi_bus_handle_display: FuriHalSpiBusHandle;
}
extern "C" {
	#[doc = " SdCard in fast mode on `furi_hal_spi_bus_d`"]
	pub static mut furi_hal_spi_bus_handle_sd_fast: FuriHalSpiBusHandle;
}
extern "C" {
	#[doc = " SdCard in slow mode on `furi_hal_spi_bus_d`"]
	pub static mut furi_hal_spi_bus_handle_sd_slow: FuriHalSpiBusHandle;
}
#[repr(u32)]
#[non_exhaustive]
#[doc = " IOCFG inversion"]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum CC1101Iocfg {
	CC1101IocfgRxFifoThreshold = 0,
	CC1101IocfgRxFifoThresholdOrPacket = 1,
	CC1101IocfgTxFifoThreshold = 2,
	CC1101IocfgTxFifoFull = 3,
	CC1101IocfgRxOverflow = 4,
	CC1101IocfgTxUnderflow = 5,
	CC1101IocfgSyncWord = 6,
	CC1101IocfgPacket = 7,
	CC1101IocfgPreamble = 8,
	CC1101IocfgClearChannel = 9,
	CC1101IocfgLockDetector = 10,
	CC1101IocfgSerialClock = 11,
	CC1101IocfgSerialSynchronousDataOutput = 12,
	CC1101IocfgSerialDataOutput = 13,
	CC1101IocfgCarrierSense = 14,
	CC1101IocfgCrcOk = 15,
	CC1101IocfgRxHardData1 = 22,
	CC1101IocfgRxHardData0 = 23,
	CC1101IocfgPaPd = 27,
	CC1101IocfgLnaPd = 28,
	CC1101IocfgRxSymbolTick = 29,
	CC1101IocfgWorEvnt0 = 36,
	CC1101IocfgWorEvnt1 = 37,
	CC1101IocfgClk256 = 38,
	CC1101IocfgClk32k = 39,
	CC1101IocfgChpRdyN = 41,
	CC1101IocfgXoscStable = 43,
	CC1101IocfgHighImpedance = 46,
	CC1101IocfgHW = 47,
	CC1101IocfgClkXosc1 = 48,
	CC1101IocfgClkXosc1_5 = 49,
	CC1101IocfgClkXosc2 = 50,
	CC1101IocfgClkXosc3 = 51,
	CC1101IocfgClkXosc4 = 52,
	CC1101IocfgClkXosc6 = 53,
	CC1101IocfgClkXosc8 = 54,
	CC1101IocfgClkXosc12 = 55,
	CC1101IocfgClkXosc16 = 56,
	CC1101IocfgClkXosc24 = 57,
	CC1101IocfgClkXosc32 = 58,
	CC1101IocfgClkXosc48 = 59,
	CC1101IocfgClkXosc64 = 60,
	CC1101IocfgClkXosc96 = 61,
	CC1101IocfgClkXosc128 = 62,
	CC1101IocfgClkXosc192 = 63,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum CC1101State {
	CC1101StateIDLE = 0,
	#[doc = " IDLE state"]
	CC1101StateRX = 1,
	#[doc = " Receive mode"]
	CC1101StateTX = 2,
	#[doc = " Transmit mode"]
	CC1101StateFSTXON = 3,
	#[doc = " Fast TX ready"]
	CC1101StateCALIBRATE = 4,
	#[doc = " Frequency synthesizer calibration is running"]
	CC1101StateSETTLING = 5,
	#[doc = " PLL is settling"]
	CC1101StateRXFIFO_OVERFLOW = 6,
	#[doc = " RX FIFO has overflowed. Read out any useful data, then flush the FIFO with SFRX"]
	CC1101StateTXFIFO_UNDERFLOW = 7,
}
#[repr(C)]
#[repr(align(4))]
pub struct CC1101Status {
	pub _bitfield_align_1: [u8; 0],
	pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
	pub __bindgen_padding_0: [u8; 3usize],
}
#[test]
fn bindgen_test_layout_CC1101Status() {
	assert_eq!(
	           ::core::mem::size_of::<CC1101Status>(),
	           4usize,
	           concat!("Size of: ", stringify!(CC1101Status))
	);
	assert_eq!(
	           ::core::mem::align_of::<CC1101Status>(),
	           4usize,
	           concat!("Alignment of ", stringify!(CC1101Status))
	);
}
impl CC1101Status {
	#[inline]
	pub fn FIFO_BYTES_AVAILABLE(&self) -> u8 { unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u8) } }
	#[inline]
	pub fn set_FIFO_BYTES_AVAILABLE(&mut self, val: u8) {
		unsafe {
			let val: u8 = ::core::mem::transmute(val);
			self._bitfield_1.set(0usize, 4u8, val as u64)
		}
	}
	#[inline]
	pub fn STATE(&self) -> CC1101State { unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 3u8) as u32) } }
	#[inline]
	pub fn set_STATE(&mut self, val: CC1101State) {
		unsafe {
			let val: u32 = ::core::mem::transmute(val);
			self._bitfield_1.set(4usize, 3u8, val as u64)
		}
	}
	#[inline]
	pub fn CHIP_RDYn(&self) -> bool { unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) } }
	#[inline]
	pub fn set_CHIP_RDYn(&mut self, val: bool) {
		unsafe {
			let val: u8 = ::core::mem::transmute(val);
			self._bitfield_1.set(7usize, 1u8, val as u64)
		}
	}
	#[inline]
	pub fn new_bitfield_1(FIFO_BYTES_AVAILABLE: u8, STATE: CC1101State, CHIP_RDYn: bool) -> __BindgenBitfieldUnit<[u8; 1usize]> {
		let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
		__bindgen_bitfield_unit.set(0usize, 4u8, {
			                       let FIFO_BYTES_AVAILABLE: u8 = unsafe { ::core::mem::transmute(FIFO_BYTES_AVAILABLE) };
			                       FIFO_BYTES_AVAILABLE as u64
		                       });
		__bindgen_bitfield_unit.set(4usize, 3u8, {
			                       let STATE: u32 = unsafe { ::core::mem::transmute(STATE) };
			                       STATE as u64
		                       });
		__bindgen_bitfield_unit.set(7usize, 1u8, {
			                       let CHIP_RDYn: u8 = unsafe { ::core::mem::transmute(CHIP_RDYn) };
			                       CHIP_RDYn as u64
		                       });
		__bindgen_bitfield_unit
	}
}
#[repr(C)]
pub struct CC1101StatusRaw {
	pub status: __BindgenUnionField<CC1101Status>,
	pub status_raw: __BindgenUnionField<u8>,
	pub bindgen_union_field: u32,
}
#[test]
fn bindgen_test_layout_CC1101StatusRaw() {
	assert_eq!(
	           ::core::mem::size_of::<CC1101StatusRaw>(),
	           4usize,
	           concat!("Size of: ", stringify!(CC1101StatusRaw))
	);
	assert_eq!(
	           ::core::mem::align_of::<CC1101StatusRaw>(),
	           4usize,
	           concat!("Alignment of ", stringify!(CC1101StatusRaw))
	);
	fn test_field_status() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<CC1101StatusRaw>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).status) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(CC1101StatusRaw), "::", stringify!(status))
		);
	}
	test_field_status();
	fn test_field_status_raw() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<CC1101StatusRaw>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).status_raw) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(CC1101StatusRaw), "::", stringify!(status_raw))
		);
	}
	test_field_status_raw();
}
#[repr(C, packed)]
pub struct CC1101TxBytes {
	pub _bitfield_align_1: [u8; 0],
	pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[test]
fn bindgen_test_layout_CC1101TxBytes() {
	assert_eq!(
	           ::core::mem::size_of::<CC1101TxBytes>(),
	           1usize,
	           concat!("Size of: ", stringify!(CC1101TxBytes))
	);
	assert_eq!(
	           ::core::mem::align_of::<CC1101TxBytes>(),
	           1usize,
	           concat!("Alignment of ", stringify!(CC1101TxBytes))
	);
}
impl CC1101TxBytes {
	#[inline]
	pub fn NUM_TXBYTES(&self) -> u8 { unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 7u8) as u8) } }
	#[inline]
	pub fn set_NUM_TXBYTES(&mut self, val: u8) {
		unsafe {
			let val: u8 = ::core::mem::transmute(val);
			self._bitfield_1.set(0usize, 7u8, val as u64)
		}
	}
	#[inline]
	pub fn TXFIFO_UNDERFLOW(&self) -> bool { unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) } }
	#[inline]
	pub fn set_TXFIFO_UNDERFLOW(&mut self, val: bool) {
		unsafe {
			let val: u8 = ::core::mem::transmute(val);
			self._bitfield_1.set(7usize, 1u8, val as u64)
		}
	}
	#[inline]
	pub fn new_bitfield_1(NUM_TXBYTES: u8, TXFIFO_UNDERFLOW: bool) -> __BindgenBitfieldUnit<[u8; 1usize]> {
		let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
		__bindgen_bitfield_unit.set(0usize, 7u8, {
			                       let NUM_TXBYTES: u8 = unsafe { ::core::mem::transmute(NUM_TXBYTES) };
			                       NUM_TXBYTES as u64
		                       });
		__bindgen_bitfield_unit.set(7usize, 1u8, {
			                       let TXFIFO_UNDERFLOW: u8 = unsafe { ::core::mem::transmute(TXFIFO_UNDERFLOW) };
			                       TXFIFO_UNDERFLOW as u64
		                       });
		__bindgen_bitfield_unit
	}
}
#[repr(C, packed)]
pub struct CC1101RxBytes {
	pub _bitfield_align_1: [u8; 0],
	pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[test]
fn bindgen_test_layout_CC1101RxBytes() {
	assert_eq!(
	           ::core::mem::size_of::<CC1101RxBytes>(),
	           1usize,
	           concat!("Size of: ", stringify!(CC1101RxBytes))
	);
	assert_eq!(
	           ::core::mem::align_of::<CC1101RxBytes>(),
	           1usize,
	           concat!("Alignment of ", stringify!(CC1101RxBytes))
	);
}
impl CC1101RxBytes {
	#[inline]
	pub fn NUM_RXBYTES(&self) -> u8 { unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 7u8) as u8) } }
	#[inline]
	pub fn set_NUM_RXBYTES(&mut self, val: u8) {
		unsafe {
			let val: u8 = ::core::mem::transmute(val);
			self._bitfield_1.set(0usize, 7u8, val as u64)
		}
	}
	#[inline]
	pub fn RXFIFO_OVERFLOW(&self) -> bool { unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) } }
	#[inline]
	pub fn set_RXFIFO_OVERFLOW(&mut self, val: bool) {
		unsafe {
			let val: u8 = ::core::mem::transmute(val);
			self._bitfield_1.set(7usize, 1u8, val as u64)
		}
	}
	#[inline]
	pub fn new_bitfield_1(NUM_RXBYTES: u8, RXFIFO_OVERFLOW: bool) -> __BindgenBitfieldUnit<[u8; 1usize]> {
		let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
		__bindgen_bitfield_unit.set(0usize, 7u8, {
			                       let NUM_RXBYTES: u8 = unsafe { ::core::mem::transmute(NUM_RXBYTES) };
			                       NUM_RXBYTES as u64
		                       });
		__bindgen_bitfield_unit.set(7usize, 1u8, {
			                       let RXFIFO_OVERFLOW: u8 = unsafe { ::core::mem::transmute(RXFIFO_OVERFLOW) };
			                       RXFIFO_OVERFLOW as u64
		                       });
		__bindgen_bitfield_unit
	}
}
extern "C" {
	#[doc = " Early initialize SPI HAL"]
	pub fn furi_hal_spi_init_early();
}
extern "C" {
	#[doc = " Early deinitialize SPI HAL"]
	pub fn furi_hal_spi_deinit_early();
}
extern "C" {
	#[doc = " Initialize SPI HAL"]
	pub fn furi_hal_spi_init();
}
extern "C" {
	#[doc = " Initialize SPI Bus"]
	#[doc = ""]
	#[doc = " @param      handle  pointer to FuriHalSpiBus instance"]
	pub fn furi_hal_spi_bus_init(bus: *mut FuriHalSpiBus);
}
extern "C" {
	#[doc = " Deinitialize SPI Bus"]
	#[doc = ""]
	#[doc = " @param      handle  pointer to FuriHalSpiBus instance"]
	pub fn furi_hal_spi_bus_deinit(bus: *mut FuriHalSpiBus);
}
extern "C" {
	#[doc = " Initialize SPI Bus Handle"]
	#[doc = ""]
	#[doc = " @param      handle  pointer to FuriHalSpiBusHandle instance"]
	pub fn furi_hal_spi_bus_handle_init(handle: *mut FuriHalSpiBusHandle);
}
extern "C" {
	#[doc = " Deinitialize SPI Bus Handle"]
	#[doc = ""]
	#[doc = " @param      handle  pointer to FuriHalSpiBusHandle instance"]
	pub fn furi_hal_spi_bus_handle_deinit(handle: *mut FuriHalSpiBusHandle);
}
extern "C" {
	#[doc = " Acquire SPI bus"]
	#[doc = ""]
	#[doc = " @warning blocking, calls `furi_crash` on programming error, CS transition is up to handler event routine"]
	#[doc = ""]
	#[doc = " @param      handle  pointer to FuriHalSpiBusHandle instance"]
	pub fn furi_hal_spi_acquire(handle: *mut FuriHalSpiBusHandle);
}
extern "C" {
	#[doc = " Release SPI bus"]
	#[doc = ""]
	#[doc = " @warning calls `furi_crash` on programming error, CS transition is up to handler event routine"]
	#[doc = ""]
	#[doc = " @param      handle  pointer to FuriHalSpiBusHandle instance"]
	pub fn furi_hal_spi_release(handle: *mut FuriHalSpiBusHandle);
}
extern "C" {
	#[doc = " SPI Receive"]
	#[doc = ""]
	#[doc = " @param      handle   pointer to FuriHalSpiBusHandle instance"]
	#[doc = " @param      buffer   receive buffer"]
	#[doc = " @param      size     transaction size (buffer size)"]
	#[doc = " @param      timeout  operation timeout in ms"]
	#[doc = ""]
	#[doc = " @return     true on sucess"]
	pub fn furi_hal_spi_bus_rx(handle: *mut FuriHalSpiBusHandle, buffer: *mut u8, size: usize, timeout: u32) -> bool;
}
extern "C" {
	#[doc = " SPI Transmit"]
	#[doc = ""]
	#[doc = " @param      handle   pointer to FuriHalSpiBusHandle instance"]
	#[doc = " @param      buffer   transmit buffer"]
	#[doc = " @param      size     transaction size (buffer size)"]
	#[doc = " @param      timeout  operation timeout in ms"]
	#[doc = ""]
	#[doc = " @return     true on success"]
	pub fn furi_hal_spi_bus_tx(handle: *mut FuriHalSpiBusHandle, buffer: *mut u8, size: usize, timeout: u32) -> bool;
}
extern "C" {
	#[doc = " SPI Transmit and Receive"]
	#[doc = ""]
	#[doc = " @param      handle     pointer to FuriHalSpiBusHandle instance"]
	#[doc = " @param      tx_buffer  pointer to tx buffer"]
	#[doc = " @param      rx_buffer  pointer to rx buffer"]
	#[doc = " @param      size       transaction size (buffer size)"]
	#[doc = " @param      timeout    operation timeout in ms"]
	#[doc = ""]
	#[doc = " @return     true on success"]
	pub fn furi_hal_spi_bus_trx(handle: *mut FuriHalSpiBusHandle,
	                            tx_buffer: *mut u8,
	                            rx_buffer: *mut u8,
	                            size: usize,
	                            timeout: u32)
	                            -> bool;
}
extern "C" {
	#[doc = " Strobe command to the device"]
	#[doc = ""]
	#[doc = " @param      handle  - pointer to FuriHalSpiHandle"]
	#[doc = " @param      strobe  - command to execute"]
	#[doc = ""]
	#[doc = " @return     device status"]
	pub fn cc1101_strobe(handle: *mut FuriHalSpiBusHandle, strobe: u8) -> CC1101Status;
}
extern "C" {
	#[doc = " Write device register"]
	#[doc = ""]
	#[doc = " @param      handle  - pointer to FuriHalSpiHandle"]
	#[doc = " @param      reg     - register"]
	#[doc = " @param      data    - data to write"]
	#[doc = ""]
	#[doc = " @return     device status"]
	pub fn cc1101_write_reg(handle: *mut FuriHalSpiBusHandle, reg: u8, data: u8) -> CC1101Status;
}
extern "C" {
	#[doc = " Read device register"]
	#[doc = ""]
	#[doc = " @param      handle  - pointer to FuriHalSpiHandle"]
	#[doc = " @param      reg     - register"]
	#[doc = " @param[out] data    - pointer to data"]
	#[doc = ""]
	#[doc = " @return     device status"]
	pub fn cc1101_read_reg(handle: *mut FuriHalSpiBusHandle, reg: u8, data: *mut u8) -> CC1101Status;
}
extern "C" {
	#[doc = " Reset"]
	#[doc = ""]
	#[doc = " @param      handle  - pointer to FuriHalSpiHandle"]
	pub fn cc1101_reset(handle: *mut FuriHalSpiBusHandle);
}
extern "C" {
	#[doc = " Get status"]
	#[doc = ""]
	#[doc = " @param      handle  - pointer to FuriHalSpiHandle"]
	#[doc = ""]
	#[doc = " @return     CC1101Status structure"]
	pub fn cc1101_get_status(handle: *mut FuriHalSpiBusHandle) -> CC1101Status;
}
extern "C" {
	#[doc = " Enable shutdown mode"]
	#[doc = ""]
	#[doc = " @param      handle  - pointer to FuriHalSpiHandle"]
	pub fn cc1101_shutdown(handle: *mut FuriHalSpiBusHandle);
}
extern "C" {
	#[doc = " Get Partnumber"]
	#[doc = ""]
	#[doc = " @param      handle  - pointer to FuriHalSpiHandle"]
	#[doc = ""]
	#[doc = " @return     part number id"]
	pub fn cc1101_get_partnumber(handle: *mut FuriHalSpiBusHandle) -> u8;
}
extern "C" {
	#[doc = " Get Version"]
	#[doc = ""]
	#[doc = " @param      handle  - pointer to FuriHalSpiHandle"]
	#[doc = ""]
	#[doc = " @return     version"]
	pub fn cc1101_get_version(handle: *mut FuriHalSpiBusHandle) -> u8;
}
extern "C" {
	#[doc = " Get raw RSSI value"]
	#[doc = ""]
	#[doc = " @param      handle  - pointer to FuriHalSpiHandle"]
	#[doc = ""]
	#[doc = " @return     rssi value"]
	pub fn cc1101_get_rssi(handle: *mut FuriHalSpiBusHandle) -> u8;
}
extern "C" {
	#[doc = " Calibrate oscillator"]
	#[doc = ""]
	#[doc = " @param      handle  - pointer to FuriHalSpiHandle"]
	pub fn cc1101_calibrate(handle: *mut FuriHalSpiBusHandle);
}
extern "C" {
	#[doc = " Switch to idle"]
	#[doc = ""]
	#[doc = " @param      handle  - pointer to FuriHalSpiHandle"]
	pub fn cc1101_switch_to_idle(handle: *mut FuriHalSpiBusHandle);
}
extern "C" {
	#[doc = " Switch to RX"]
	#[doc = ""]
	#[doc = " @param      handle  - pointer to FuriHalSpiHandle"]
	pub fn cc1101_switch_to_rx(handle: *mut FuriHalSpiBusHandle);
}
extern "C" {
	#[doc = " Switch to TX"]
	#[doc = ""]
	#[doc = " @param      handle  - pointer to FuriHalSpiHandle"]
	pub fn cc1101_switch_to_tx(handle: *mut FuriHalSpiBusHandle);
}
extern "C" {
	#[doc = " Flush RX FIFO"]
	#[doc = ""]
	#[doc = " @param      handle  - pointer to FuriHalSpiHandle"]
	pub fn cc1101_flush_rx(handle: *mut FuriHalSpiBusHandle);
}
extern "C" {
	#[doc = " Flush TX FIFO"]
	#[doc = ""]
	#[doc = " @param      handle  - pointer to FuriHalSpiHandle"]
	pub fn cc1101_flush_tx(handle: *mut FuriHalSpiBusHandle);
}
extern "C" {
	#[doc = " Set Frequency"]
	#[doc = ""]
	#[doc = " @param      handle  - pointer to FuriHalSpiHandle"]
	#[doc = " @param      value   - frequency in herz"]
	#[doc = ""]
	#[doc = " @return     real frequency that were synthesized"]
	pub fn cc1101_set_frequency(handle: *mut FuriHalSpiBusHandle, value: u32) -> u32;
}
extern "C" {
	#[doc = " Set Intermediate Frequency"]
	#[doc = ""]
	#[doc = " @param      handle  - pointer to FuriHalSpiHandle"]
	#[doc = " @param      value   - frequency in herz"]
	#[doc = ""]
	#[doc = " @return     real inermediate frequency that were synthesized"]
	pub fn cc1101_set_intermediate_frequency(handle: *mut FuriHalSpiBusHandle, value: u32) -> u32;
}
extern "C" {
	#[doc = " Set Power Amplifier level table, ramp"]
	#[doc = ""]
	#[doc = " @param      handle  - pointer to FuriHalSpiHandle"]
	#[doc = " @param      value   - array of power level values"]
	pub fn cc1101_set_pa_table(handle: *mut FuriHalSpiBusHandle, value: *const [u8; 8usize]);
}
extern "C" {
	#[doc = " Write FIFO"]
	#[doc = ""]
	#[doc = " @param      handle  - pointer to FuriHalSpiHandle"]
	#[doc = " @param      data    pointer to byte array"]
	#[doc = " @param      size    write bytes count"]
	#[doc = ""]
	#[doc = " @return     size, written bytes count"]
	pub fn cc1101_write_fifo(handle: *mut FuriHalSpiBusHandle, data: *const u8, size: u8) -> u8;
}
extern "C" {
	#[doc = " Read FIFO"]
	#[doc = ""]
	#[doc = " @param      handle  - pointer to FuriHalSpiHandle"]
	#[doc = " @param      data    pointer to byte array"]
	#[doc = " @param      size    bytes to read from fifo"]
	#[doc = ""]
	#[doc = " @return     size, read bytes count"]
	pub fn cc1101_read_fifo(handle: *mut FuriHalSpiBusHandle, data: *mut u8, size: *mut u8) -> u8;
}
extern "C" {
	pub static mut furi_hal_subghz_preset_ook_270khz_async_regs: [[u8; 2usize]; 18usize];
}
extern "C" {
	pub static mut furi_hal_subghz_preset_ook_650khz_async_regs: [[u8; 2usize]; 18usize];
}
extern "C" {
	pub static mut furi_hal_subghz_preset_2fsk_dev2_38khz_async_regs: [[u8; 2usize]; 19usize];
}
extern "C" {
	pub static mut furi_hal_subghz_preset_2fsk_dev47_6khz_async_regs: [[u8; 2usize]; 19usize];
}
extern "C" {
	pub static mut furi_hal_subghz_preset_msk_99_97kb_async_regs: [[u8; 2usize]; 26usize];
}
extern "C" {
	pub static mut furi_hal_subghz_preset_gfsk_9_99kb_async_regs: [[u8; 2usize]; 19usize];
}
extern "C" {
	pub static furi_hal_subghz_preset_ook_async_patable: [u8; 8usize];
}
extern "C" {
	pub static furi_hal_subghz_preset_ook_async_patable_au: [u8; 8usize];
}
extern "C" {
	pub static furi_hal_subghz_preset_2fsk_async_patable: [u8; 8usize];
}
extern "C" {
	pub static furi_hal_subghz_preset_msk_async_patable: [u8; 8usize];
}
extern "C" {
	pub static furi_hal_subghz_preset_gfsk_async_patable: [u8; 8usize];
}
#[repr(u32)]
#[non_exhaustive]
#[doc = " UART channels"]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum FuriHalUartId {
	FuriHalUartIdUSART1 = 0,
	FuriHalUartIdLPUART1 = 1,
}
#[repr(u32)]
#[non_exhaustive]
#[doc = " UART events"]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum UartIrqEvent {
	UartIrqEventRXNE = 0,
}
extern "C" {
	#[doc = " Init UART"]
	#[doc = " Configures GPIO to UART function, сonfigures UART hardware, enables UART hardware"]
	#[doc = " @param channel UART channel"]
	#[doc = " @param baud baudrate"]
	pub fn furi_hal_uart_init(channel: FuriHalUartId, baud: u32);
}
extern "C" {
	#[doc = " Deinit UART"]
	#[doc = " Configures GPIO to analog, clears callback and callback context, disables UART hardware"]
	#[doc = " @param channel UART channel"]
	pub fn furi_hal_uart_deinit(channel: FuriHalUartId);
}
extern "C" {
	#[doc = " Suspend UART operation"]
	#[doc = " Disables UART hardware, settings and callbacks are preserved"]
	#[doc = " @param channel UART channel"]
	pub fn furi_hal_uart_suspend(channel: FuriHalUartId);
}
extern "C" {
	#[doc = " Resume UART operation"]
	#[doc = " Resumes UART hardware from suspended state"]
	#[doc = " @param channel UART channel"]
	pub fn furi_hal_uart_resume(channel: FuriHalUartId);
}
extern "C" {
	#[doc = " Changes UART baudrate"]
	#[doc = " @param channel UART channel"]
	#[doc = " @param baud baudrate"]
	pub fn furi_hal_uart_set_br(channel: FuriHalUartId, baud: u32);
}
extern "C" {
	#[doc = " Transmits data"]
	#[doc = " @param channel UART channel"]
	#[doc = " @param buffer data"]
	#[doc = " @param buffer_size data size (in bytes)"]
	pub fn furi_hal_uart_tx(channel: FuriHalUartId, buffer: *mut u8, buffer_size: usize);
}
extern "C" {
	#[doc = " Sets UART event callback"]
	#[doc = " @param channel UART channel"]
	#[doc = " @param callback callback pointer"]
	#[doc = " @param context callback context"]
	pub fn furi_hal_uart_set_irq_cb(channel: FuriHalUartId,
	                                callback: ::core::option::Option<unsafe extern "C" fn(event: UartIrqEvent,
	                                                                            data: u8,
	                                                                            context: *mut core::ffi::c_void)>,
	                                context: *mut core::ffi::c_void);
}
#[doc = "\\brief Header Functional Descriptor"]
#[doc = " \\details Header Functional Descriptor marks the beginning of the concatenated set of functional"]
#[doc = " descriptors for the interface."]
#[repr(C, packed)]
pub struct usb_cdc_header_desc {
	#[doc = "<\\brief Size of this descriptor in bytes."]
	pub bFunctionLength: u8,
	#[doc = "<\\brief CS_INTERFACE descriptor type."]
	pub bDescriptorType: u8,
	#[doc = "<\\brief Header functional descriptor subtype."]
	pub bDescriptorSubType: u8,
	#[doc = "<\\brief USB CDC Specification release number in BCD."]
	pub bcdCDC: u16,
}
#[test]
fn bindgen_test_layout_usb_cdc_header_desc() {
	assert_eq!(
	           ::core::mem::size_of::<usb_cdc_header_desc>(),
	           5usize,
	           concat!("Size of: ", stringify!(usb_cdc_header_desc))
	);
	assert_eq!(
	           ::core::mem::align_of::<usb_cdc_header_desc>(),
	           1usize,
	           concat!("Alignment of ", stringify!(usb_cdc_header_desc))
	);
	fn test_field_bFunctionLength() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<usb_cdc_header_desc>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).bFunctionLength) as usize - ptr as usize
		           },
		           0usize,
		           concat!(
			"Offset of field: ",
			stringify!(usb_cdc_header_desc),
			"::",
			stringify!(bFunctionLength)
		)
		);
	}
	test_field_bFunctionLength();
	fn test_field_bDescriptorType() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<usb_cdc_header_desc>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).bDescriptorType) as usize - ptr as usize
		           },
		           1usize,
		           concat!(
			"Offset of field: ",
			stringify!(usb_cdc_header_desc),
			"::",
			stringify!(bDescriptorType)
		)
		);
	}
	test_field_bDescriptorType();
	fn test_field_bDescriptorSubType() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<usb_cdc_header_desc>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).bDescriptorSubType) as usize - ptr as usize
		           },
		           2usize,
		           concat!(
			"Offset of field: ",
			stringify!(usb_cdc_header_desc),
			"::",
			stringify!(bDescriptorSubType)
		)
		);
	}
	test_field_bDescriptorSubType();
	fn test_field_bcdCDC() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<usb_cdc_header_desc>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).bcdCDC) as usize - ptr as usize
		           },
		           3usize,
		           concat!("Offset of field: ", stringify!(usb_cdc_header_desc), "::", stringify!(bcdCDC))
		);
	}
	test_field_bcdCDC();
}
#[doc = "\\brief Union Functional Descriptor"]
#[doc = " \\details The Union functional descriptor describes the relationship between a group of interfaces"]
#[doc = " that can be considered to form a functional unit. It can only occur within the class-specific"]
#[doc = " portion of an Interface descriptor. One of the interfaces in the group is designated as a master"]
#[doc = " or controlling interface for the group, and certain class-specific messages can be sent to this"]
#[doc = " interface to act upon the group as a whole."]
#[repr(C, packed)]
pub struct usb_cdc_union_desc {
	#[doc = "<\\brief Size of this functional descriptor, in bytes."]
	pub bFunctionLength: u8,
	#[doc = "<\\brief CS_INTERFACE descriptor type."]
	pub bDescriptorType: u8,
	#[doc = "<\\brief Union Functional Descriptor."]
	pub bDescriptorSubType: u8,
	#[doc = "<\\brief The interface number of the CDC interface designated"]
	#[doc = " as the master or controlling interface for the union."]
	pub bMasterInterface0: u8,
	#[doc = "<\\brief Interface number of first slave or associated interface"]
	#[doc = " in the union."]
	pub bSlaveInterface0: u8,
}
#[test]
fn bindgen_test_layout_usb_cdc_union_desc() {
	assert_eq!(
	           ::core::mem::size_of::<usb_cdc_union_desc>(),
	           5usize,
	           concat!("Size of: ", stringify!(usb_cdc_union_desc))
	);
	assert_eq!(
	           ::core::mem::align_of::<usb_cdc_union_desc>(),
	           1usize,
	           concat!("Alignment of ", stringify!(usb_cdc_union_desc))
	);
	fn test_field_bFunctionLength() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<usb_cdc_union_desc>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).bFunctionLength) as usize - ptr as usize
		           },
		           0usize,
		           concat!(
			"Offset of field: ",
			stringify!(usb_cdc_union_desc),
			"::",
			stringify!(bFunctionLength)
		)
		);
	}
	test_field_bFunctionLength();
	fn test_field_bDescriptorType() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<usb_cdc_union_desc>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).bDescriptorType) as usize - ptr as usize
		           },
		           1usize,
		           concat!(
			"Offset of field: ",
			stringify!(usb_cdc_union_desc),
			"::",
			stringify!(bDescriptorType)
		)
		);
	}
	test_field_bDescriptorType();
	fn test_field_bDescriptorSubType() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<usb_cdc_union_desc>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).bDescriptorSubType) as usize - ptr as usize
		           },
		           2usize,
		           concat!(
			"Offset of field: ",
			stringify!(usb_cdc_union_desc),
			"::",
			stringify!(bDescriptorSubType)
		)
		);
	}
	test_field_bDescriptorSubType();
	fn test_field_bMasterInterface0() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<usb_cdc_union_desc>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).bMasterInterface0) as usize - ptr as usize
		           },
		           3usize,
		           concat!(
			"Offset of field: ",
			stringify!(usb_cdc_union_desc),
			"::",
			stringify!(bMasterInterface0)
		)
		);
	}
	test_field_bMasterInterface0();
	fn test_field_bSlaveInterface0() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<usb_cdc_union_desc>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).bSlaveInterface0) as usize - ptr as usize
		           },
		           4usize,
		           concat!(
			"Offset of field: ",
			stringify!(usb_cdc_union_desc),
			"::",
			stringify!(bSlaveInterface0)
		)
		);
	}
	test_field_bSlaveInterface0();
}
#[doc = "\\brief Country Selection Functional Descriptor"]
#[doc = " \\details The Country Selection functional descriptor identifies the countries in which the"]
#[doc = " communication device is qualified to operate. The parameters of the network connection often vary"]
#[doc = " from one country to another, especially in Europe. Also legal requirements impose certain"]
#[doc = " restrictions on devices because of different regulations by the governing body of the network to"]
#[doc = " which the device must adhere. This descriptor can only occur within the class-specific portion of"]
#[doc = " an Interface descriptor and should only be provided to a master Communication Class interface of"]
#[doc = " a union. The country codes used in the Country Selection Functional Descriptor are not the same"]
#[doc = " as the country codes used in dialing international telephone calls. Implementers should refer to"]
#[doc = " the ISO 3166 specification for more information."]
#[repr(C, packed)]
pub struct usb_cdc_country_desc {
	#[doc = "<\\brief Size of this functional descriptor, in bytes."]
	pub bFunctionLength: u8,
	#[doc = "<\\brief CS_INTERFACE descriptor type."]
	pub bDescriptorType: u8,
	#[doc = "<\\brief Country Selection Functional Descriptor."]
	pub bDescriptorSubType: u8,
	#[doc = "<\\brief Index of a string giving the release date for the"]
	#[doc = " implemented ISO 3166 Country Codes."]
	pub iCountryCodeRelDate: u8,
	#[doc = "<\\brief Country code in hexadecimal format."]
	#[doc = " \\details As defined in ISO 3166, release date as specified"]
	#[doc = " in iCountryCodeRelDate for the first supported country."]
	pub wCountyCode0: u8,
}
#[test]
fn bindgen_test_layout_usb_cdc_country_desc() {
	assert_eq!(
	           ::core::mem::size_of::<usb_cdc_country_desc>(),
	           5usize,
	           concat!("Size of: ", stringify!(usb_cdc_country_desc))
	);
	assert_eq!(
	           ::core::mem::align_of::<usb_cdc_country_desc>(),
	           1usize,
	           concat!("Alignment of ", stringify!(usb_cdc_country_desc))
	);
	fn test_field_bFunctionLength() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<usb_cdc_country_desc>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).bFunctionLength) as usize - ptr as usize
		           },
		           0usize,
		           concat!(
			"Offset of field: ",
			stringify!(usb_cdc_country_desc),
			"::",
			stringify!(bFunctionLength)
		)
		);
	}
	test_field_bFunctionLength();
	fn test_field_bDescriptorType() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<usb_cdc_country_desc>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).bDescriptorType) as usize - ptr as usize
		           },
		           1usize,
		           concat!(
			"Offset of field: ",
			stringify!(usb_cdc_country_desc),
			"::",
			stringify!(bDescriptorType)
		)
		);
	}
	test_field_bDescriptorType();
	fn test_field_bDescriptorSubType() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<usb_cdc_country_desc>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).bDescriptorSubType) as usize - ptr as usize
		           },
		           2usize,
		           concat!(
			"Offset of field: ",
			stringify!(usb_cdc_country_desc),
			"::",
			stringify!(bDescriptorSubType)
		)
		);
	}
	test_field_bDescriptorSubType();
	fn test_field_iCountryCodeRelDate() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<usb_cdc_country_desc>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).iCountryCodeRelDate) as usize - ptr as usize
		           },
		           3usize,
		           concat!(
			"Offset of field: ",
			stringify!(usb_cdc_country_desc),
			"::",
			stringify!(iCountryCodeRelDate)
		)
		);
	}
	test_field_iCountryCodeRelDate();
	fn test_field_wCountyCode0() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<usb_cdc_country_desc>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).wCountyCode0) as usize - ptr as usize
		           },
		           4usize,
		           concat!(
			"Offset of field: ",
			stringify!(usb_cdc_country_desc),
			"::",
			stringify!(wCountyCode0)
		)
		);
	}
	test_field_wCountyCode0();
}
#[doc = "\\brief Call Management Functional Descriptor."]
#[doc = " \\details The Call Management functional descriptor describes the processing of calls for the"]
#[doc = " Communication Class interface. It can only occur within the class-specific portion of an Interface"]
#[doc = " descriptor."]
#[repr(C, packed)]
pub struct usb_cdc_call_mgmt_desc {
	#[doc = "<\\brief Size of this functional descriptor, in bytes."]
	pub bFunctionLength: u8,
	#[doc = "<\\brief CS_INTERFACE descriptor type."]
	pub bDescriptorType: u8,
	#[doc = "<\\brief Call Management functional descriptor subtype."]
	pub bDescriptorSubType: u8,
	#[doc = "<\\brief The call management capabilities that this"]
	#[doc = " configuration supports."]
	pub bmCapabilities: u8,
	#[doc = "<\\brief Interface number of Data Class interface optionally"]
	#[doc = " used for call management."]
	pub bDataInterface: u8,
}
#[test]
fn bindgen_test_layout_usb_cdc_call_mgmt_desc() {
	assert_eq!(
	           ::core::mem::size_of::<usb_cdc_call_mgmt_desc>(),
	           5usize,
	           concat!("Size of: ", stringify!(usb_cdc_call_mgmt_desc))
	);
	assert_eq!(
	           ::core::mem::align_of::<usb_cdc_call_mgmt_desc>(),
	           1usize,
	           concat!("Alignment of ", stringify!(usb_cdc_call_mgmt_desc))
	);
	fn test_field_bFunctionLength() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<usb_cdc_call_mgmt_desc>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).bFunctionLength) as usize - ptr as usize
		           },
		           0usize,
		           concat!(
			"Offset of field: ",
			stringify!(usb_cdc_call_mgmt_desc),
			"::",
			stringify!(bFunctionLength)
		)
		);
	}
	test_field_bFunctionLength();
	fn test_field_bDescriptorType() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<usb_cdc_call_mgmt_desc>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).bDescriptorType) as usize - ptr as usize
		           },
		           1usize,
		           concat!(
			"Offset of field: ",
			stringify!(usb_cdc_call_mgmt_desc),
			"::",
			stringify!(bDescriptorType)
		)
		);
	}
	test_field_bDescriptorType();
	fn test_field_bDescriptorSubType() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<usb_cdc_call_mgmt_desc>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).bDescriptorSubType) as usize - ptr as usize
		           },
		           2usize,
		           concat!(
			"Offset of field: ",
			stringify!(usb_cdc_call_mgmt_desc),
			"::",
			stringify!(bDescriptorSubType)
		)
		);
	}
	test_field_bDescriptorSubType();
	fn test_field_bmCapabilities() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<usb_cdc_call_mgmt_desc>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).bmCapabilities) as usize - ptr as usize
		           },
		           3usize,
		           concat!(
			"Offset of field: ",
			stringify!(usb_cdc_call_mgmt_desc),
			"::",
			stringify!(bmCapabilities)
		)
		);
	}
	test_field_bmCapabilities();
	fn test_field_bDataInterface() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<usb_cdc_call_mgmt_desc>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).bDataInterface) as usize - ptr as usize
		           },
		           4usize,
		           concat!(
			"Offset of field: ",
			stringify!(usb_cdc_call_mgmt_desc),
			"::",
			stringify!(bDataInterface)
		)
		);
	}
	test_field_bDataInterface();
}
#[doc = "\\brief Abstract Control Management Functional Descriptor"]
#[doc = " \\details The Abstract Control Management functional descriptor describes the commands supported"]
#[doc = " by the Communication Class interface, as defined in Section 3.6.2, with the SubClass code of"]
#[doc = " Abstract Control Model. It can only occur within the class-specific portion of an Interface"]
#[doc = " descriptor."]
#[repr(C, packed)]
pub struct usb_cdc_acm_desc {
	#[doc = "<\\brief Size of this functional descriptor, in bytes."]
	pub bFunctionLength: u8,
	#[doc = "<\\brief CS_INTERFACE descriptor type."]
	pub bDescriptorType: u8,
	#[doc = "<\\brief Abstract Control Management functional descriptor subtype."]
	pub bDescriptorSubType: u8,
	#[doc = "<\\brief The capabilities that this configuration supports."]
	pub bmCapabilities: u8,
}
#[test]
fn bindgen_test_layout_usb_cdc_acm_desc() {
	assert_eq!(
	           ::core::mem::size_of::<usb_cdc_acm_desc>(),
	           4usize,
	           concat!("Size of: ", stringify!(usb_cdc_acm_desc))
	);
	assert_eq!(
	           ::core::mem::align_of::<usb_cdc_acm_desc>(),
	           1usize,
	           concat!("Alignment of ", stringify!(usb_cdc_acm_desc))
	);
	fn test_field_bFunctionLength() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<usb_cdc_acm_desc>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).bFunctionLength) as usize - ptr as usize
		           },
		           0usize,
		           concat!(
			"Offset of field: ",
			stringify!(usb_cdc_acm_desc),
			"::",
			stringify!(bFunctionLength)
		)
		);
	}
	test_field_bFunctionLength();
	fn test_field_bDescriptorType() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<usb_cdc_acm_desc>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).bDescriptorType) as usize - ptr as usize
		           },
		           1usize,
		           concat!(
			"Offset of field: ",
			stringify!(usb_cdc_acm_desc),
			"::",
			stringify!(bDescriptorType)
		)
		);
	}
	test_field_bDescriptorType();
	fn test_field_bDescriptorSubType() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<usb_cdc_acm_desc>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).bDescriptorSubType) as usize - ptr as usize
		           },
		           2usize,
		           concat!(
			"Offset of field: ",
			stringify!(usb_cdc_acm_desc),
			"::",
			stringify!(bDescriptorSubType)
		)
		);
	}
	test_field_bDescriptorSubType();
	fn test_field_bmCapabilities() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<usb_cdc_acm_desc>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).bmCapabilities) as usize - ptr as usize
		           },
		           3usize,
		           concat!(
			"Offset of field: ",
			stringify!(usb_cdc_acm_desc),
			"::",
			stringify!(bmCapabilities)
		)
		);
	}
	test_field_bmCapabilities();
}
#[doc = "\\brief Notification structure from CDC"]
#[repr(C, packed)]
pub struct usb_cdc_notification {
	#[doc = "<\\brief This bitmapped field identifies the characteristics"]
	#[doc = " of the specific request."]
	pub bmRequestType: u8,
	#[doc = "<\\brief Notification type."]
	pub bNotificationType: u8,
	#[doc = "<\\brief Notification value."]
	pub wValue: u16,
	#[doc = "<\\brief Interface."]
	pub wIndex: u16,
	#[doc = "<\\brief Data payload length in bytes."]
	pub wLength: u16,
	#[doc = "<\\brief Data payload."]
	pub Data: __IncompleteArrayField<u8>,
}
#[test]
fn bindgen_test_layout_usb_cdc_notification() {
	assert_eq!(
	           ::core::mem::size_of::<usb_cdc_notification>(),
	           8usize,
	           concat!("Size of: ", stringify!(usb_cdc_notification))
	);
	assert_eq!(
	           ::core::mem::align_of::<usb_cdc_notification>(),
	           1usize,
	           concat!("Alignment of ", stringify!(usb_cdc_notification))
	);
	fn test_field_bmRequestType() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<usb_cdc_notification>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).bmRequestType) as usize - ptr as usize
		           },
		           0usize,
		           concat!(
			"Offset of field: ",
			stringify!(usb_cdc_notification),
			"::",
			stringify!(bmRequestType)
		)
		);
	}
	test_field_bmRequestType();
	fn test_field_bNotificationType() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<usb_cdc_notification>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).bNotificationType) as usize - ptr as usize
		           },
		           1usize,
		           concat!(
			"Offset of field: ",
			stringify!(usb_cdc_notification),
			"::",
			stringify!(bNotificationType)
		)
		);
	}
	test_field_bNotificationType();
	fn test_field_wValue() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<usb_cdc_notification>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).wValue) as usize - ptr as usize
		           },
		           2usize,
		           concat!(
			"Offset of field: ",
			stringify!(usb_cdc_notification),
			"::",
			stringify!(wValue)
		)
		);
	}
	test_field_wValue();
	fn test_field_wIndex() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<usb_cdc_notification>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).wIndex) as usize - ptr as usize
		           },
		           4usize,
		           concat!(
			"Offset of field: ",
			stringify!(usb_cdc_notification),
			"::",
			stringify!(wIndex)
		)
		);
	}
	test_field_wIndex();
	fn test_field_wLength() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<usb_cdc_notification>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).wLength) as usize - ptr as usize
		           },
		           6usize,
		           concat!(
			"Offset of field: ",
			stringify!(usb_cdc_notification),
			"::",
			stringify!(wLength)
		)
		);
	}
	test_field_wLength();
	fn test_field_Data() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<usb_cdc_notification>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).Data) as usize - ptr as usize
		           },
		           8usize,
		           concat!("Offset of field: ", stringify!(usb_cdc_notification), "::", stringify!(Data))
		);
	}
	test_field_Data();
}
#[doc = "\\brief Line Coding Structure"]
#[repr(C, packed)]
pub struct usb_cdc_line_coding {
	#[doc = "<\\brief Data terminal rate, in bits per second."]
	pub dwDTERate: u32,
	#[doc = "<\\brief Stop bits."]
	pub bCharFormat: u8,
	#[doc = "<\\brief Parity."]
	pub bParityType: u8,
	#[doc = "<\\brief Data bits (5,6,7,8 or 16)."]
	pub bDataBits: u8,
}
#[test]
fn bindgen_test_layout_usb_cdc_line_coding() {
	assert_eq!(
	           ::core::mem::size_of::<usb_cdc_line_coding>(),
	           7usize,
	           concat!("Size of: ", stringify!(usb_cdc_line_coding))
	);
	assert_eq!(
	           ::core::mem::align_of::<usb_cdc_line_coding>(),
	           1usize,
	           concat!("Alignment of ", stringify!(usb_cdc_line_coding))
	);
	fn test_field_dwDTERate() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<usb_cdc_line_coding>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).dwDTERate) as usize - ptr as usize
		           },
		           0usize,
		           concat!(
			"Offset of field: ",
			stringify!(usb_cdc_line_coding),
			"::",
			stringify!(dwDTERate)
		)
		);
	}
	test_field_dwDTERate();
	fn test_field_bCharFormat() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<usb_cdc_line_coding>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).bCharFormat) as usize - ptr as usize
		           },
		           4usize,
		           concat!(
			"Offset of field: ",
			stringify!(usb_cdc_line_coding),
			"::",
			stringify!(bCharFormat)
		)
		);
	}
	test_field_bCharFormat();
	fn test_field_bParityType() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<usb_cdc_line_coding>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).bParityType) as usize - ptr as usize
		           },
		           5usize,
		           concat!(
			"Offset of field: ",
			stringify!(usb_cdc_line_coding),
			"::",
			stringify!(bParityType)
		)
		);
	}
	test_field_bParityType();
	fn test_field_bDataBits() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<usb_cdc_line_coding>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).bDataBits) as usize - ptr as usize
		           },
		           6usize,
		           concat!(
			"Offset of field: ",
			stringify!(usb_cdc_line_coding),
			"::",
			stringify!(bDataBits)
		)
		);
	}
	test_field_bDataBits();
}
#[repr(C)]
pub struct CdcCallbacks {
	pub tx_ep_callback: ::core::option::Option<unsafe extern "C" fn(context: *mut core::ffi::c_void)>,
	pub rx_ep_callback: ::core::option::Option<unsafe extern "C" fn(context: *mut core::ffi::c_void)>,
	pub state_callback: ::core::option::Option<unsafe extern "C" fn(context: *mut core::ffi::c_void, state: u8)>,
	pub ctrl_line_callback: ::core::option::Option<unsafe extern "C" fn(context: *mut core::ffi::c_void, state: u8)>,
	pub config_callback:
		::core::option::Option<unsafe extern "C" fn(context: *mut core::ffi::c_void, config: *mut usb_cdc_line_coding)>,
}
#[test]
fn bindgen_test_layout_CdcCallbacks() {
	assert_eq!(
	           ::core::mem::size_of::<CdcCallbacks>(),
	           20usize,
	           concat!("Size of: ", stringify!(CdcCallbacks))
	);
	assert_eq!(
	           ::core::mem::align_of::<CdcCallbacks>(),
	           4usize,
	           concat!("Alignment of ", stringify!(CdcCallbacks))
	);
	fn test_field_tx_ep_callback() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<CdcCallbacks>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).tx_ep_callback) as usize - ptr as usize
		           },
		           0usize,
		           concat!(
			"Offset of field: ",
			stringify!(CdcCallbacks),
			"::",
			stringify!(tx_ep_callback)
		)
		);
	}
	test_field_tx_ep_callback();
	fn test_field_rx_ep_callback() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<CdcCallbacks>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).rx_ep_callback) as usize - ptr as usize
		           },
		           4usize,
		           concat!(
			"Offset of field: ",
			stringify!(CdcCallbacks),
			"::",
			stringify!(rx_ep_callback)
		)
		);
	}
	test_field_rx_ep_callback();
	fn test_field_state_callback() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<CdcCallbacks>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).state_callback) as usize - ptr as usize
		           },
		           8usize,
		           concat!(
			"Offset of field: ",
			stringify!(CdcCallbacks),
			"::",
			stringify!(state_callback)
		)
		);
	}
	test_field_state_callback();
	fn test_field_ctrl_line_callback() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<CdcCallbacks>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).ctrl_line_callback) as usize - ptr as usize
		           },
		           12usize,
		           concat!(
			"Offset of field: ",
			stringify!(CdcCallbacks),
			"::",
			stringify!(ctrl_line_callback)
		)
		);
	}
	test_field_ctrl_line_callback();
	fn test_field_config_callback() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<CdcCallbacks>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).config_callback) as usize - ptr as usize
		           },
		           16usize,
		           concat!(
			"Offset of field: ",
			stringify!(CdcCallbacks),
			"::",
			stringify!(config_callback)
		)
		);
	}
	test_field_config_callback();
}
extern "C" {
	pub fn furi_hal_cdc_set_callbacks(if_num: u8, cb: *mut CdcCallbacks, context: *mut core::ffi::c_void);
}
extern "C" {
	pub fn furi_hal_cdc_get_port_settings(if_num: u8) -> *mut usb_cdc_line_coding;
}
extern "C" {
	pub fn furi_hal_cdc_get_ctrl_line_state(if_num: u8) -> u8;
}
extern "C" {
	pub fn furi_hal_cdc_send(if_num: u8, buf: *mut u8, len: u16);
}
extern "C" {
	pub fn furi_hal_cdc_receive(if_num: u8, buf: *mut u8, max_len: u16) -> i32;
}
pub type error_t = core::ffi::c_int;
extern "C" {
	pub fn __errno() -> *mut core::ffi::c_int;
}
extern "C" {
	pub static mut _sys_errlist: [*const core::ffi::c_char; 0usize];
}
extern "C" {
	pub static mut _sys_nerr: core::ffi::c_int;
}
extern "C" {
	pub fn __clear_cache(arg1: *mut core::ffi::c_void, arg2: *mut core::ffi::c_void);
}
extern "C" {
	#[doc = " Early init stage for cortex"]
	pub fn furi_hal_cortex_init_early();
}
extern "C" {
	#[doc = " Microseconds delay"]
	#[doc = ""]
	#[doc = " @param[in]  microseconds  The microseconds to wait"]
	pub fn furi_hal_cortex_delay_us(microseconds: u32);
}
extern "C" {
	#[doc = " Get instructions per microsecond count"]
	#[doc = ""]
	#[doc = " @return     instructions per microsecond count"]
	pub fn furi_hal_cortex_instructions_per_microsecond() -> u32;
}
#[repr(u32)]
#[non_exhaustive]
#[doc = " FuriHalCryptoKey Type"]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum FuriHalCryptoKeyType {
	#[doc = "< Master key"]
	FuriHalCryptoKeyTypeMaster = 0,
	#[doc = "< Simple enencrypted key"]
	FuriHalCryptoKeyTypeSimple = 1,
	#[doc = "< Encrypted with Master key"]
	FuriHalCryptoKeyTypeEncrypted = 2,
}
#[repr(u32)]
#[non_exhaustive]
#[doc = " FuriHalCryptoKey Size in bits"]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum FuriHalCryptoKeySize {
	FuriHalCryptoKeySize128 = 0,
	FuriHalCryptoKeySize256 = 1,
}
#[doc = " FuriHalCryptoKey"]
#[repr(C)]
pub struct FuriHalCryptoKey {
	pub type_: FuriHalCryptoKeyType,
	pub size: FuriHalCryptoKeySize,
	pub data: *mut u8,
}
#[test]
fn bindgen_test_layout_FuriHalCryptoKey() {
	assert_eq!(
	           ::core::mem::size_of::<FuriHalCryptoKey>(),
	           12usize,
	           concat!("Size of: ", stringify!(FuriHalCryptoKey))
	);
	assert_eq!(
	           ::core::mem::align_of::<FuriHalCryptoKey>(),
	           4usize,
	           concat!("Alignment of ", stringify!(FuriHalCryptoKey))
	);
	fn test_field_type() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<FuriHalCryptoKey>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(FuriHalCryptoKey), "::", stringify!(type_))
		);
	}
	test_field_type();
	fn test_field_size() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<FuriHalCryptoKey>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).size) as usize - ptr as usize
		           },
		           4usize,
		           concat!("Offset of field: ", stringify!(FuriHalCryptoKey), "::", stringify!(size))
		);
	}
	test_field_size();
	fn test_field_data() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<FuriHalCryptoKey>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).data) as usize - ptr as usize
		           },
		           8usize,
		           concat!("Offset of field: ", stringify!(FuriHalCryptoKey), "::", stringify!(data))
		);
	}
	test_field_data();
}
extern "C" {
	#[doc = " Initialize cryptography layer This includes AES engines, PKA and RNG"]
	pub fn furi_hal_crypto_init();
}
extern "C" {
	pub fn furi_hal_crypto_verify_enclave(keys_nb: *mut u8, valid_keys_nb: *mut u8) -> bool;
}
extern "C" {
	pub fn furi_hal_crypto_verify_key(key_slot: u8) -> bool;
}
extern "C" {
	#[doc = " Store key in crypto storage"]
	#[doc = ""]
	#[doc = " @param      key   FuriHalCryptoKey to store. Only Master, Simple or"]
	#[doc = "                   Encrypted"]
	#[doc = " @param      slot  pinter to int where store slot number will be saved"]
	#[doc = ""]
	#[doc = " @return     true on success"]
	pub fn furi_hal_crypto_store_add_key(key: *mut FuriHalCryptoKey, slot: *mut u8) -> bool;
}
extern "C" {
	#[doc = " Init AES engine and load key from crypto store"]
	#[doc = ""]
	#[doc = " @param      slot  store slot number"]
	#[doc = " @param[in]  iv    pointer to 16 bytes Initialization Vector data"]
	#[doc = ""]
	#[doc = " @return     true on success"]
	pub fn furi_hal_crypto_store_load_key(slot: u8, iv: *const u8) -> bool;
}
extern "C" {
	#[doc = " Unload key engine and deinit AES engine"]
	#[doc = ""]
	#[doc = " @param      slot  store slot number"]
	#[doc = ""]
	#[doc = " @return     true on success"]
	pub fn furi_hal_crypto_store_unload_key(slot: u8) -> bool;
}
extern "C" {
	#[doc = " Encrypt data"]
	#[doc = ""]
	#[doc = " @param      input   pointer to input data"]
	#[doc = " @param      output  pointer to output data"]
	#[doc = " @param      size    input/output buffer size in bytes"]
	#[doc = ""]
	#[doc = " @return     true on success"]
	pub fn furi_hal_crypto_encrypt(input: *const u8, output: *mut u8, size: usize) -> bool;
}
extern "C" {
	#[doc = " Decrypt data"]
	#[doc = ""]
	#[doc = " @param      input   pointer to input data"]
	#[doc = " @param      output  pointer to output data"]
	#[doc = " @param      size    input/output buffer size in bytes"]
	#[doc = ""]
	#[doc = " @return     true on success"]
	pub fn furi_hal_crypto_decrypt(input: *const u8, output: *mut u8, size: usize) -> bool;
}
extern "C" {
	#[doc = " Enable MCU debug"]
	pub fn furi_hal_debug_enable();
}
extern "C" {
	#[doc = " Disable MCU debug"]
	pub fn furi_hal_debug_disable();
}
extern "C" {
	#[doc = " Init SD card detect"]
	pub fn hal_sd_detect_init();
}
extern "C" {
	#[doc = " Set SD card detect pin to low"]
	pub fn hal_sd_detect_set_low();
}
extern "C" {
	#[doc = " Get SD card status"]
	#[doc = ""]
	#[doc = " @return     true if SD card present, false if SD card not present"]
	pub fn hal_sd_detect() -> bool;
}
extern "C" {
	#[doc = " Pointer to currently used SPI Handle"]
	pub static mut furi_hal_sd_spi_handle: *mut FuriHalSpiBusHandle;
}
extern "C" {
	#[doc = " Early Init I2C"]
	pub fn furi_hal_i2c_init_early();
}
extern "C" {
	#[doc = " Early DeInit I2C"]
	pub fn furi_hal_i2c_deinit_early();
}
extern "C" {
	#[doc = " Init I2C"]
	pub fn furi_hal_i2c_init();
}
extern "C" {
	#[doc = " Acquire i2c bus handle"]
	#[doc = ""]
	#[doc = " @return     Instance of FuriHalI2cBus"]
	pub fn furi_hal_i2c_acquire(handle: *mut FuriHalI2cBusHandle);
}
extern "C" {
	#[doc = " Release i2c bus handle"]
	#[doc = ""]
	#[doc = " @param      bus   instance of FuriHalI2cBus aquired in `furi_hal_i2c_acquire`"]
	pub fn furi_hal_i2c_release(handle: *mut FuriHalI2cBusHandle);
}
extern "C" {
	#[doc = " Perform I2C tx transfer"]
	#[doc = ""]
	#[doc = " @param      handle   pointer to FuriHalI2cBusHandle instance"]
	#[doc = " @param      address  I2C slave address"]
	#[doc = " @param      data     pointer to data buffer"]
	#[doc = " @param      size     size of data buffer"]
	#[doc = " @param      timeout  timeout in ticks"]
	#[doc = ""]
	#[doc = " @return     true on successful transfer, false otherwise"]
	pub fn furi_hal_i2c_tx(handle: *mut FuriHalI2cBusHandle, address: u8, data: *const u8, size: u8, timeout: u32) -> bool;
}
extern "C" {
	#[doc = " Perform I2C rx transfer"]
	#[doc = ""]
	#[doc = " @param      handle   pointer to FuriHalI2cBusHandle instance"]
	#[doc = " @param      address  I2C slave address"]
	#[doc = " @param      data     pointer to data buffer"]
	#[doc = " @param      size     size of data buffer"]
	#[doc = " @param      timeout  timeout in ticks"]
	#[doc = ""]
	#[doc = " @return     true on successful transfer, false otherwise"]
	pub fn furi_hal_i2c_rx(handle: *mut FuriHalI2cBusHandle, address: u8, data: *mut u8, size: u8, timeout: u32) -> bool;
}
extern "C" {
	#[doc = " Perform I2C tx and rx transfers"]
	#[doc = ""]
	#[doc = " @param      handle   pointer to FuriHalI2cBusHandle instance"]
	#[doc = " @param      address  I2C slave address"]
	#[doc = " @param      tx_data  pointer to tx data buffer"]
	#[doc = " @param      tx_size  size of tx data buffer"]
	#[doc = " @param      rx_data  pointer to rx data buffer"]
	#[doc = " @param      rx_size  size of rx data buffer"]
	#[doc = " @param      timeout  timeout in ticks"]
	#[doc = ""]
	#[doc = " @return     true on successful transfer, false otherwise"]
	pub fn furi_hal_i2c_trx(handle: *mut FuriHalI2cBusHandle,
	                        address: u8,
	                        tx_data: *const u8,
	                        tx_size: u8,
	                        rx_data: *mut u8,
	                        rx_size: u8,
	                        timeout: u32)
	                        -> bool;
}
extern "C" {
	#[doc = " Check if I2C device presents on bus"]
	#[doc = ""]
	#[doc = " @param      handle   pointer to FuriHalI2cBusHandle instance"]
	#[doc = " @param      i2c_addr I2C slave address"]
	#[doc = " @param      timeout  timeout in ticks"]
	#[doc = ""]
	#[doc = " @return     true if device present and is ready, false otherwise"]
	pub fn furi_hal_i2c_is_device_ready(handle: *mut FuriHalI2cBusHandle, i2c_addr: u8, timeout: u32) -> bool;
}
extern "C" {
	#[doc = " Perform I2C device register read (8-bit)"]
	#[doc = ""]
	#[doc = " @param      handle   pointer to FuriHalI2cBusHandle instance"]
	#[doc = " @param      i2c_addr I2C slave address"]
	#[doc = " @param      reg_addr register address"]
	#[doc = " @param      data     pointer to register value"]
	#[doc = " @param      timeout  timeout in ticks"]
	#[doc = ""]
	#[doc = " @return     true on successful transfer, false otherwise"]
	pub fn furi_hal_i2c_read_reg_8(handle: *mut FuriHalI2cBusHandle, i2c_addr: u8, reg_addr: u8, data: *mut u8, timeout: u32) -> bool;
}
extern "C" {
	#[doc = " Perform I2C device register read (16-bit)"]
	#[doc = ""]
	#[doc = " @param      handle   pointer to FuriHalI2cBusHandle instance"]
	#[doc = " @param      i2c_addr I2C slave address"]
	#[doc = " @param      reg_addr register address"]
	#[doc = " @param      data     pointer to register value"]
	#[doc = " @param      timeout  timeout in ticks"]
	#[doc = ""]
	#[doc = " @return     true on successful transfer, false otherwise"]
	pub fn furi_hal_i2c_read_reg_16(handle: *mut FuriHalI2cBusHandle,
	                                i2c_addr: u8,
	                                reg_addr: u8,
	                                data: *mut u16,
	                                timeout: u32)
	                                -> bool;
}
extern "C" {
	#[doc = " Perform I2C device memory read"]
	#[doc = ""]
	#[doc = " @param      handle   pointer to FuriHalI2cBusHandle instance"]
	#[doc = " @param      i2c_addr I2C slave address"]
	#[doc = " @param      mem_addr memory start address"]
	#[doc = " @param      data     pointer to data buffer"]
	#[doc = " @param      len      size of data buffer"]
	#[doc = " @param      timeout  timeout in ticks"]
	#[doc = ""]
	#[doc = " @return     true on successful transfer, false otherwise"]
	pub fn furi_hal_i2c_read_mem(handle: *mut FuriHalI2cBusHandle,
	                             i2c_addr: u8,
	                             mem_addr: u8,
	                             data: *mut u8,
	                             len: u8,
	                             timeout: u32)
	                             -> bool;
}
extern "C" {
	#[doc = " Perform I2C device register write (8-bit)"]
	#[doc = ""]
	#[doc = " @param      handle   pointer to FuriHalI2cBusHandle instance"]
	#[doc = " @param      i2c_addr I2C slave address"]
	#[doc = " @param      reg_addr register address"]
	#[doc = " @param      data     register value"]
	#[doc = " @param      timeout  timeout in ticks"]
	#[doc = ""]
	#[doc = " @return     true on successful transfer, false otherwise"]
	pub fn furi_hal_i2c_write_reg_8(handle: *mut FuriHalI2cBusHandle, i2c_addr: u8, reg_addr: u8, data: u8, timeout: u32) -> bool;
}
extern "C" {
	#[doc = " Perform I2C device register write (16-bit)"]
	#[doc = ""]
	#[doc = " @param      handle   pointer to FuriHalI2cBusHandle instance"]
	#[doc = " @param      i2c_addr I2C slave address"]
	#[doc = " @param      reg_addr register address"]
	#[doc = " @param      data     register value"]
	#[doc = " @param      timeout  timeout in ticks"]
	#[doc = ""]
	#[doc = " @return     true on successful transfer, false otherwise"]
	pub fn furi_hal_i2c_write_reg_16(handle: *mut FuriHalI2cBusHandle, i2c_addr: u8, reg_addr: u8, data: u16, timeout: u32) -> bool;
}
extern "C" {
	#[doc = " Perform I2C device memory"]
	#[doc = ""]
	#[doc = " @param      handle   pointer to FuriHalI2cBusHandle instance"]
	#[doc = " @param      i2c_addr I2C slave address"]
	#[doc = " @param      mem_addr memory start address"]
	#[doc = " @param      data     pointer to data buffer"]
	#[doc = " @param      len      size of data buffer"]
	#[doc = " @param      timeout  timeout in ticks"]
	#[doc = ""]
	#[doc = " @return     true on successful transfer, false otherwise"]
	pub fn furi_hal_i2c_write_mem(handle: *mut FuriHalI2cBusHandle,
	                              i2c_addr: u8,
	                              mem_addr: u8,
	                              data: *mut u8,
	                              len: u8,
	                              timeout: u32)
	                              -> bool;
}
#[repr(C)]
pub struct FuriHalRegionBand {
	pub start: u32,
	pub end: u32,
	pub power_limit: i8,
	pub duty_cycle: u8,
}
#[test]
fn bindgen_test_layout_FuriHalRegionBand() {
	assert_eq!(
	           ::core::mem::size_of::<FuriHalRegionBand>(),
	           12usize,
	           concat!("Size of: ", stringify!(FuriHalRegionBand))
	);
	assert_eq!(
	           ::core::mem::align_of::<FuriHalRegionBand>(),
	           4usize,
	           concat!("Alignment of ", stringify!(FuriHalRegionBand))
	);
	fn test_field_start() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<FuriHalRegionBand>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).start) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(FuriHalRegionBand), "::", stringify!(start))
		);
	}
	test_field_start();
	fn test_field_end() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<FuriHalRegionBand>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).end) as usize - ptr as usize
		           },
		           4usize,
		           concat!("Offset of field: ", stringify!(FuriHalRegionBand), "::", stringify!(end))
		);
	}
	test_field_end();
	fn test_field_power_limit() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<FuriHalRegionBand>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).power_limit) as usize - ptr as usize
		           },
		           8usize,
		           concat!(
			"Offset of field: ",
			stringify!(FuriHalRegionBand),
			"::",
			stringify!(power_limit)
		)
		);
	}
	test_field_power_limit();
	fn test_field_duty_cycle() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<FuriHalRegionBand>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).duty_cycle) as usize - ptr as usize
		           },
		           9usize,
		           concat!(
			"Offset of field: ",
			stringify!(FuriHalRegionBand),
			"::",
			stringify!(duty_cycle)
		)
		);
	}
	test_field_duty_cycle();
}
#[repr(C)]
pub struct FuriHalRegion {
	pub country_code: [core::ffi::c_char; 4usize],
	pub bands_count: u16,
	pub bands: __IncompleteArrayField<FuriHalRegionBand>,
}
#[test]
fn bindgen_test_layout_FuriHalRegion() {
	assert_eq!(
	           ::core::mem::size_of::<FuriHalRegion>(),
	           8usize,
	           concat!("Size of: ", stringify!(FuriHalRegion))
	);
	assert_eq!(
	           ::core::mem::align_of::<FuriHalRegion>(),
	           4usize,
	           concat!("Alignment of ", stringify!(FuriHalRegion))
	);
	fn test_field_country_code() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<FuriHalRegion>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).country_code) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(FuriHalRegion), "::", stringify!(country_code))
		);
	}
	test_field_country_code();
	fn test_field_bands_count() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<FuriHalRegion>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).bands_count) as usize - ptr as usize
		           },
		           4usize,
		           concat!("Offset of field: ", stringify!(FuriHalRegion), "::", stringify!(bands_count))
		);
	}
	test_field_bands_count();
	fn test_field_bands() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<FuriHalRegion>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).bands) as usize - ptr as usize
		           },
		           8usize,
		           concat!("Offset of field: ", stringify!(FuriHalRegion), "::", stringify!(bands))
		);
	}
	test_field_bands();
}
extern "C" {
	#[doc = " Initialize region"]
	pub fn furi_hal_region_init();
}
extern "C" {
	#[doc = " Get Region Data."]
	#[doc = ""]
	#[doc = " Region data may be allocated in Flash or in RAM."]
	#[doc = " Keep in mind that we don't do memory management on our side."]
	#[doc = ""]
	#[doc = " @return     pointer to FuriHalRegion instance (in RAM or Flash, check before freeing on region update)"]
	pub fn furi_hal_region_get() -> *const FuriHalRegion;
}
extern "C" {
	#[doc = " Set device region data"]
	#[doc = ""]
	#[doc = " @param      region  pointer to the FuriHalRegion"]
	pub fn furi_hal_region_set(region: *mut FuriHalRegion);
}
extern "C" {
	#[doc = " Check if region data provisioned"]
	#[doc = ""]
	#[doc = " @return     true if provisioned, false otherwise"]
	pub fn furi_hal_region_is_provisioned() -> bool;
}
extern "C" {
	#[doc = " Get region name"]
	#[doc = ""]
	#[doc = " 2 letter Region code according to iso 3166 standard"]
	#[doc = " There are 2 extra values that we use in special cases:"]
	#[doc = " - \"00\" - developer edition, unlocked"]
	#[doc = " - \"WW\" - world wide, region provisioned by default"]
	#[doc = " - \"--\" - no provisioned region"]
	#[doc = ""]
	#[doc = " @return     Pointer to string"]
	pub fn furi_hal_region_get_name() -> *const core::ffi::c_char;
}
extern "C" {
	#[doc = " Сheck if transmission is allowed on this frequency for your flipper region"]
	#[doc = ""]
	#[doc = " @param[in]  frequency  The frequency"]
	#[doc = " @param      value  frequency in Hz"]
	#[doc = ""]
	#[doc = " @return     true if allowed"]
	pub fn furi_hal_region_is_frequency_allowed(frequency: u32) -> bool;
}
extern "C" {
	#[doc = " Get band data for frequency"]
	#[doc = ""]
	#[doc = ""]
	#[doc = ""]
	#[doc = " @param[in]  frequency  The frequency"]
	#[doc = ""]
	#[doc = " @return     { description_of_the_return_value }"]
	pub fn furi_hal_region_get_band(frequency: u32) -> *const FuriHalRegionBand;
}
#[repr(C)]
pub struct FuriHalRtcDateTime {
	#[doc = "< Hour in 24H format: 0-23"]
	pub hour: u8,
	#[doc = "< Minute: 0-59"]
	pub minute: u8,
	#[doc = "< Second: 0-59"]
	pub second: u8,
	#[doc = "< Current day: 1-31"]
	pub day: u8,
	#[doc = "< Current month: 1-12"]
	pub month: u8,
	#[doc = "< Current year: 2000-2099"]
	pub year: u16,
	#[doc = "< Current weekday: 1-7"]
	pub weekday: u8,
}
#[test]
fn bindgen_test_layout_FuriHalRtcDateTime() {
	assert_eq!(
	           ::core::mem::size_of::<FuriHalRtcDateTime>(),
	           10usize,
	           concat!("Size of: ", stringify!(FuriHalRtcDateTime))
	);
	assert_eq!(
	           ::core::mem::align_of::<FuriHalRtcDateTime>(),
	           2usize,
	           concat!("Alignment of ", stringify!(FuriHalRtcDateTime))
	);
	fn test_field_hour() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<FuriHalRtcDateTime>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).hour) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(FuriHalRtcDateTime), "::", stringify!(hour))
		);
	}
	test_field_hour();
	fn test_field_minute() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<FuriHalRtcDateTime>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).minute) as usize - ptr as usize
		           },
		           1usize,
		           concat!("Offset of field: ", stringify!(FuriHalRtcDateTime), "::", stringify!(minute))
		);
	}
	test_field_minute();
	fn test_field_second() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<FuriHalRtcDateTime>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).second) as usize - ptr as usize
		           },
		           2usize,
		           concat!("Offset of field: ", stringify!(FuriHalRtcDateTime), "::", stringify!(second))
		);
	}
	test_field_second();
	fn test_field_day() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<FuriHalRtcDateTime>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).day) as usize - ptr as usize
		           },
		           3usize,
		           concat!("Offset of field: ", stringify!(FuriHalRtcDateTime), "::", stringify!(day))
		);
	}
	test_field_day();
	fn test_field_month() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<FuriHalRtcDateTime>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).month) as usize - ptr as usize
		           },
		           4usize,
		           concat!("Offset of field: ", stringify!(FuriHalRtcDateTime), "::", stringify!(month))
		);
	}
	test_field_month();
	fn test_field_year() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<FuriHalRtcDateTime>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).year) as usize - ptr as usize
		           },
		           6usize,
		           concat!("Offset of field: ", stringify!(FuriHalRtcDateTime), "::", stringify!(year))
		);
	}
	test_field_year();
	fn test_field_weekday() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<FuriHalRtcDateTime>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).weekday) as usize - ptr as usize
		           },
		           8usize,
		           concat!("Offset of field: ", stringify!(FuriHalRtcDateTime), "::", stringify!(weekday))
		);
	}
	test_field_weekday();
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum FuriHalRtcFlag {
	FuriHalRtcFlagDebug = 1,
	FuriHalRtcFlagFactoryReset = 2,
	FuriHalRtcFlagLock = 4,
	FuriHalRtcFlagC2Update = 8,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum FuriHalRtcBootMode {
	#[doc = "< Normal boot mode, default value"]
	FuriHalRtcBootModeNormal = 0,
	#[doc = "< Boot to DFU (MCU bootloader by ST)"]
	FuriHalRtcBootModeDfu = 1,
	#[doc = "< Boot to Update, pre update"]
	FuriHalRtcBootModePreUpdate = 2,
	#[doc = "< Boot to Update, main"]
	FuriHalRtcBootModeUpdate = 3,
	#[doc = "< Boot to Update, post update"]
	FuriHalRtcBootModePostUpdate = 4,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum FuriHalRtcRegister {
	#[doc = "< RTC structure header"]
	FuriHalRtcRegisterHeader = 0,
	#[doc = "< Various system bits"]
	FuriHalRtcRegisterSystem = 1,
	#[doc = "< Pointer to Version"]
	FuriHalRtcRegisterVersion = 2,
	#[doc = "< LFS geometry fingerprint"]
	FuriHalRtcRegisterLfsFingerprint = 3,
	#[doc = "< Pointer to last fault message"]
	FuriHalRtcRegisterFaultData = 4,
	#[doc = "< Failed pins count"]
	FuriHalRtcRegisterPinFails = 5,
	FuriHalRtcRegisterUpdateFolderFSIndex = 6,
	#[doc = "< Service value, do not use"]
	FuriHalRtcRegisterMAX = 7,
}
extern "C" {
	#[doc = " Early initialization"]
	pub fn furi_hal_rtc_init_early();
}
extern "C" {
	#[doc = " Early deinitialization"]
	pub fn furi_hal_rtc_deinit_early();
}
extern "C" {
	#[doc = " Initialize RTC subsystem"]
	pub fn furi_hal_rtc_init();
}
extern "C" {
	pub fn furi_hal_rtc_get_register(reg: FuriHalRtcRegister) -> u32;
}
extern "C" {
	pub fn furi_hal_rtc_set_register(reg: FuriHalRtcRegister, value: u32);
}
extern "C" {
	pub fn furi_hal_rtc_set_log_level(level: u8);
}
extern "C" {
	pub fn furi_hal_rtc_get_log_level() -> u8;
}
extern "C" {
	pub fn furi_hal_rtc_set_flag(flag: FuriHalRtcFlag);
}
extern "C" {
	pub fn furi_hal_rtc_reset_flag(flag: FuriHalRtcFlag);
}
extern "C" {
	pub fn furi_hal_rtc_is_flag_set(flag: FuriHalRtcFlag) -> bool;
}
extern "C" {
	pub fn furi_hal_rtc_set_boot_mode(mode: FuriHalRtcBootMode);
}
extern "C" {
	pub fn furi_hal_rtc_get_boot_mode() -> FuriHalRtcBootMode;
}
extern "C" {
	pub fn furi_hal_rtc_set_datetime(datetime: *mut FuriHalRtcDateTime);
}
extern "C" {
	pub fn furi_hal_rtc_get_datetime(datetime: *mut FuriHalRtcDateTime);
}
extern "C" {
	pub fn furi_hal_rtc_validate_datetime(datetime: *mut FuriHalRtcDateTime) -> bool;
}
extern "C" {
	pub fn furi_hal_rtc_set_fault_data(value: u32);
}
extern "C" {
	pub fn furi_hal_rtc_get_fault_data() -> u32;
}
extern "C" {
	pub fn furi_hal_rtc_set_pin_fails(value: u32);
}
extern "C" {
	pub fn furi_hal_rtc_get_pin_fails() -> u32;
}
extern "C" {
	pub fn furi_hal_rtc_datetime_to_timestamp(datetime: *mut FuriHalRtcDateTime) -> u32;
}
extern "C" {
	pub fn furi_hal_speaker_init();
}
extern "C" {
	pub fn furi_hal_speaker_start(frequency: core::ffi::c_float, volume: core::ffi::c_float);
}
extern "C" {
	pub fn furi_hal_speaker_set_volume(volume: core::ffi::c_float);
}
extern "C" {
	pub fn furi_hal_speaker_stop();
}
extern "C" {
	#[doc = " Init light driver"]
	pub fn furi_hal_light_init();
}
extern "C" {
	#[doc = " Set light value"]
	#[doc = ""]
	#[doc = " @param      light  Light"]
	#[doc = " @param      value  light brightness [0-255]"]
	pub fn furi_hal_light_set(light: Light, value: u8);
}
extern "C" {
	#[doc = " Start hardware LED blinking mode"]
	#[doc = ""]
	#[doc = " @param      light  Light"]
	#[doc = " @param      brightness  light brightness [0-255]"]
	#[doc = " @param      on_time  LED on time in ms"]
	#[doc = " @param      period  LED blink period in ms"]
	pub fn furi_hal_light_blink_start(light: Light, brightness: u8, on_time: u16, period: u16);
}
extern "C" {
	#[doc = " Stop hardware LED blinking mode"]
	pub fn furi_hal_light_blink_stop();
}
extern "C" {
	#[doc = " Set color in hardware LED blinking mode"]
	#[doc = ""]
	#[doc = " @param      light  Light"]
	pub fn furi_hal_light_blink_set_color(light: Light);
}
extern "C" {
	#[doc = " Execute sequence"]
	#[doc = ""]
	#[doc = " @param      sequence  Sequence to execute"]
	pub fn furi_hal_light_sequence(sequence: *const core::ffi::c_char);
}
#[repr(u32)]
#[non_exhaustive]
#[doc = " Power IC type"]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum FuriHalPowerIC {
	FuriHalPowerICCharger = 0,
	FuriHalPowerICFuelGauge = 1,
}
extern "C" {
	#[doc = " Initialize drivers"]
	pub fn furi_hal_power_init();
}
extern "C" {
	#[doc = " Check if gauge is ok"]
	#[doc = ""]
	#[doc = " Verifies that:"]
	#[doc = " - gauge is alive"]
	#[doc = " - correct profile loaded"]
	#[doc = " - self diagnostic status is good"]
	#[doc = ""]
	#[doc = " @return true if gauge is ok"]
	pub fn furi_hal_power_gauge_is_ok() -> bool;
}
extern "C" {
	#[doc = " Get current insomnia level"]
	#[doc = ""]
	#[doc = " @return     insomnia level: 0 - no insomnia, >0 - insomnia, bearer count."]
	pub fn furi_hal_power_insomnia_level() -> u16;
}
extern "C" {
	#[doc = " Enter insomnia mode Prevents device from going to sleep"]
	#[doc = " @warning    Internally increases insomnia level Must be paired with"]
	#[doc = "             furi_hal_power_insomnia_exit"]
	pub fn furi_hal_power_insomnia_enter();
}
extern "C" {
	#[doc = " Exit insomnia mode Allow device to go to sleep"]
	#[doc = " @warning    Internally decreases insomnia level. Must be paired with"]
	#[doc = "             furi_hal_power_insomnia_enter"]
	pub fn furi_hal_power_insomnia_exit();
}
extern "C" {
	#[doc = " Check if sleep availble"]
	#[doc = ""]
	#[doc = " @return     true if available"]
	pub fn furi_hal_power_sleep_available() -> bool;
}
extern "C" {
	#[doc = " Check if deep sleep availble"]
	#[doc = ""]
	#[doc = " @return     true if available"]
	pub fn furi_hal_power_deep_sleep_available() -> bool;
}
extern "C" {
	#[doc = " Go to sleep"]
	pub fn furi_hal_power_sleep();
}
extern "C" {
	#[doc = " Get predicted remaining battery capacity in percents"]
	#[doc = ""]
	#[doc = " @return     remaining battery capacity in percents"]
	pub fn furi_hal_power_get_pct() -> u8;
}
extern "C" {
	#[doc = " Get battery health state in percents"]
	#[doc = ""]
	#[doc = " @return     health in percents"]
	pub fn furi_hal_power_get_bat_health_pct() -> u8;
}
extern "C" {
	#[doc = " Get charging status"]
	#[doc = ""]
	#[doc = " @return     true if charging"]
	pub fn furi_hal_power_is_charging() -> bool;
}
extern "C" {
	#[doc = " Get charge complete status"]
	#[doc = ""]
	#[doc = " @return     true if done charging and connected to charger"]
	pub fn furi_hal_power_is_charging_done() -> bool;
}
extern "C" {
	#[doc = " Switch MCU to SHUTDOWN"]
	pub fn furi_hal_power_shutdown();
}
extern "C" {
	#[doc = " Poweroff device"]
	pub fn furi_hal_power_off();
}
extern "C" {
	#[doc = " Reset device"]
	pub fn furi_hal_power_reset();
}
extern "C" {
	#[doc = " OTG enable"]
	pub fn furi_hal_power_enable_otg();
}
extern "C" {
	#[doc = " OTG disable"]
	pub fn furi_hal_power_disable_otg();
}
extern "C" {
	#[doc = " Check OTG status and disable it if falt happened"]
	pub fn furi_hal_power_check_otg_status();
}
extern "C" {
	#[doc = " Get OTG status"]
	#[doc = ""]
	#[doc = " @return     true if enabled"]
	pub fn furi_hal_power_is_otg_enabled() -> bool;
}
extern "C" {
	#[doc = " Get remaining battery battery capacity in mAh"]
	#[doc = ""]
	#[doc = " @return     capacity in mAh"]
	pub fn furi_hal_power_get_battery_remaining_capacity() -> u32;
}
extern "C" {
	#[doc = " Get full charge battery capacity in mAh"]
	#[doc = ""]
	#[doc = " @return     capacity in mAh"]
	pub fn furi_hal_power_get_battery_full_capacity() -> u32;
}
extern "C" {
	#[doc = " Get battery capacity in mAh from battery profile"]
	#[doc = ""]
	#[doc = " @return     capacity in mAh"]
	pub fn furi_hal_power_get_battery_design_capacity() -> u32;
}
extern "C" {
	#[doc = " Get battery voltage in V"]
	#[doc = ""]
	#[doc = " @param      ic    FuriHalPowerIc to get measurment"]
	#[doc = ""]
	#[doc = " @return     voltage in V"]
	pub fn furi_hal_power_get_battery_voltage(ic: FuriHalPowerIC) -> core::ffi::c_float;
}
extern "C" {
	#[doc = " Get battery current in A"]
	#[doc = ""]
	#[doc = " @param      ic    FuriHalPowerIc to get measurment"]
	#[doc = ""]
	#[doc = " @return     current in A"]
	pub fn furi_hal_power_get_battery_current(ic: FuriHalPowerIC) -> core::ffi::c_float;
}
extern "C" {
	#[doc = " Get temperature in C"]
	#[doc = ""]
	#[doc = " @param      ic    FuriHalPowerIc to get measurment"]
	#[doc = ""]
	#[doc = " @return     temperature in C"]
	pub fn furi_hal_power_get_battery_temperature(ic: FuriHalPowerIC) -> core::ffi::c_float;
}
extern "C" {
	#[doc = " Get USB voltage in V"]
	#[doc = ""]
	#[doc = " @return     voltage in V"]
	pub fn furi_hal_power_get_usb_voltage() -> core::ffi::c_float;
}
extern "C" {
	#[doc = " Get power system component state"]
	pub fn furi_hal_power_dump_state();
}
extern "C" {
	#[doc = " Enable 3.3v on external gpio and sd card"]
	pub fn furi_hal_power_enable_external_3_3v();
}
extern "C" {
	#[doc = " Disable 3.3v on external gpio and sd card"]
	pub fn furi_hal_power_disable_external_3_3v();
}
extern "C" {
	#[doc = " Enter supress charge mode."]
	#[doc = ""]
	#[doc = " Use this function when your application need clean power supply."]
	pub fn furi_hal_power_suppress_charge_enter();
}
extern "C" {
	#[doc = " Exit supress charge mode"]
	pub fn furi_hal_power_suppress_charge_exit();
}
#[doc = " Callback type called by furi_hal_power_info_get every time another key-value pair of information is ready"]
#[doc = ""]
#[doc = " @param      key[in]      power information type identifier"]
#[doc = " @param      value[in]    power information value"]
#[doc = " @param      last[in]     whether the passed key-value pair is the last one"]
#[doc = " @param      context[in]  to pass to callback"]
pub type FuriHalPowerInfoCallback = ::core::option::Option<unsafe extern "C" fn(key: *const core::ffi::c_char,
                                                                                value: *const core::ffi::c_char,
                                                                                last: bool,
                                                                                context: *mut core::ffi::c_void)>;
extern "C" {
	#[doc = " Get power information"]
	#[doc = ""]
	#[doc = " @param[in]  callback     callback to provide with new data"]
	#[doc = " @param[in]  context      context to pass to callback"]
	pub fn furi_hal_power_info_get(callback: FuriHalPowerInfoCallback, context: *mut core::ffi::c_void);
}
#[repr(C)]
pub struct Version {
	_unused: [u8; 0],
}
extern "C" {
	#[doc = " Get current running firmware version handle."]
	#[doc = ""]
	#[doc = " You can store it somewhere. But if you want to retrieve data, you have to use"]
	#[doc = " 'version_*_get()' set of functions. Also, 'version_*_get()' imply to use this"]
	#[doc = " handle if no handle (NULL_PTR) provided."]
	#[doc = ""]
	#[doc = " @return     pointer to Version data."]
	pub fn version_get() -> *const Version;
}
extern "C" {
	#[doc = " Get git commit hash."]
	#[doc = ""]
	#[doc = " @param      v     pointer to Version data. NULL for currently running"]
	#[doc = "                   software."]
	#[doc = ""]
	#[doc = " @return     git hash"]
	pub fn version_get_githash(v: *const Version) -> *const core::ffi::c_char;
}
extern "C" {
	#[doc = " Get git branch."]
	#[doc = ""]
	#[doc = " @param      v     pointer to Version data. NULL for currently running"]
	#[doc = "                   software."]
	#[doc = ""]
	#[doc = " @return     git branch"]
	pub fn version_get_gitbranch(v: *const Version) -> *const core::ffi::c_char;
}
extern "C" {
	#[doc = " Get number of commit in git branch."]
	#[doc = ""]
	#[doc = " @param      v     pointer to Version data. NULL for currently running"]
	#[doc = "                   software."]
	#[doc = ""]
	#[doc = " @return     number of commit"]
	pub fn version_get_gitbranchnum(v: *const Version) -> *const core::ffi::c_char;
}
extern "C" {
	#[doc = " Get build date."]
	#[doc = ""]
	#[doc = " @param      v     pointer to Version data. NULL for currently running"]
	#[doc = "                   software."]
	#[doc = ""]
	#[doc = " @return     build date"]
	pub fn version_get_builddate(v: *const Version) -> *const core::ffi::c_char;
}
extern "C" {
	#[doc = " Get build version. Build version is last tag in git history."]
	#[doc = ""]
	#[doc = " @param      v     pointer to Version data. NULL for currently running"]
	#[doc = "                   software."]
	#[doc = ""]
	#[doc = " @return     build date"]
	pub fn version_get_version(v: *const Version) -> *const core::ffi::c_char;
}
extern "C" {
	#[doc = " Get hardware target this firmware was built for"]
	#[doc = ""]
	#[doc = " @param      v     pointer to Version data. NULL for currently running"]
	#[doc = "                   software."]
	#[doc = ""]
	#[doc = " @return     build date"]
	pub fn version_get_target(v: *const Version) -> u8;
}
extern "C" {
	#[doc = " Get flag indicating if this build is \"dirty\" (source code had uncommited changes)"]
	#[doc = ""]
	#[doc = " @param      v     pointer to Version data. NULL for currently running"]
	#[doc = "                   software."]
	#[doc = ""]
	#[doc = " @return     build date"]
	pub fn version_get_dirty_flag(v: *const Version) -> bool;
}
#[repr(u32)]
#[non_exhaustive]
#[doc = " OTP Versions enum"]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum FuriHalVersionOtpVersion {
	FuriHalVersionOtpVersion0 = 0,
	FuriHalVersionOtpVersion1 = 1,
	FuriHalVersionOtpVersion2 = 2,
	FuriHalVersionOtpVersionEmpty = 4294967294,
	FuriHalVersionOtpVersionUnknown = 4294967295,
}
#[repr(u32)]
#[non_exhaustive]
#[doc = " Device Colors"]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum FuriHalVersionColor {
	FuriHalVersionColorUnknown = 0,
	FuriHalVersionColorBlack = 1,
	FuriHalVersionColorWhite = 2,
}
#[repr(u32)]
#[non_exhaustive]
#[doc = " Device Regions"]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum FuriHalVersionRegion {
	FuriHalVersionRegionUnknown = 0,
	FuriHalVersionRegionEuRu = 1,
	FuriHalVersionRegionUsCaAu = 2,
	FuriHalVersionRegionJp = 3,
	FuriHalVersionRegionWorld = 4,
}
#[repr(u32)]
#[non_exhaustive]
#[doc = " Device Display"]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum FuriHalVersionDisplay {
	FuriHalVersionDisplayUnknown = 0,
	FuriHalVersionDisplayErc = 1,
	FuriHalVersionDisplayMgg = 2,
}
extern "C" {
	#[doc = " Init flipper version"]
	pub fn furi_hal_version_init();
}
extern "C" {
	#[doc = " Check target firmware version"]
	#[doc = ""]
	#[doc = " @return     true if target and real matches"]
	pub fn furi_hal_version_do_i_belong_here() -> bool;
}
extern "C" {
	#[doc = " Get model name"]
	#[doc = ""]
	#[doc = " @return     model name C-string"]
	pub fn furi_hal_version_get_model_name() -> *const core::ffi::c_char;
}
extern "C" {
	#[doc = " Get OTP version"]
	#[doc = ""]
	#[doc = " @return     OTP Version"]
	pub fn furi_hal_version_get_otp_version() -> FuriHalVersionOtpVersion;
}
extern "C" {
	#[doc = " Get hardware version"]
	#[doc = ""]
	#[doc = " @return     Hardware Version"]
	pub fn furi_hal_version_get_hw_version() -> u8;
}
extern "C" {
	#[doc = " Get hardware target"]
	#[doc = ""]
	#[doc = " @return     Hardware Target"]
	pub fn furi_hal_version_get_hw_target() -> u8;
}
extern "C" {
	#[doc = " Get hardware body"]
	#[doc = ""]
	#[doc = " @return     Hardware Body"]
	pub fn furi_hal_version_get_hw_body() -> u8;
}
extern "C" {
	#[doc = " Get hardware body color"]
	#[doc = ""]
	#[doc = " @return     Hardware Color"]
	pub fn furi_hal_version_get_hw_color() -> FuriHalVersionColor;
}
extern "C" {
	#[doc = " Get hardware connect"]
	#[doc = ""]
	#[doc = " @return     Hardware Interconnect"]
	pub fn furi_hal_version_get_hw_connect() -> u8;
}
extern "C" {
	#[doc = " Get hardware region"]
	#[doc = ""]
	#[doc = " @return     Hardware Region"]
	pub fn furi_hal_version_get_hw_region() -> FuriHalVersionRegion;
}
extern "C" {
	#[doc = " Get hardware region name"]
	#[doc = ""]
	#[doc = " @return     Hardware Region name"]
	pub fn furi_hal_version_get_hw_region_name() -> *const core::ffi::c_char;
}
extern "C" {
	#[doc = " Get hardware display id"]
	#[doc = ""]
	#[doc = " @return     Display id"]
	pub fn furi_hal_version_get_hw_display() -> FuriHalVersionDisplay;
}
extern "C" {
	#[doc = " Get hardware timestamp"]
	#[doc = ""]
	#[doc = " @return     Hardware Manufacture timestamp"]
	pub fn furi_hal_version_get_hw_timestamp() -> u32;
}
extern "C" {
	#[doc = " Get pointer to target name"]
	#[doc = ""]
	#[doc = " @return     Hardware Name C-string"]
	pub fn furi_hal_version_get_name_ptr() -> *const core::ffi::c_char;
}
extern "C" {
	#[doc = " Get pointer to target device name"]
	#[doc = ""]
	#[doc = " @return     Hardware Device Name C-string"]
	pub fn furi_hal_version_get_device_name_ptr() -> *const core::ffi::c_char;
}
extern "C" {
	#[doc = " Get pointer to target ble local device name"]
	#[doc = ""]
	#[doc = " @return     Ble Device Name C-string"]
	pub fn furi_hal_version_get_ble_local_device_name_ptr() -> *const core::ffi::c_char;
}
extern "C" {
	#[doc = " Get BLE MAC address"]
	#[doc = ""]
	#[doc = " @return     pointer to BLE MAC address"]
	pub fn furi_hal_version_get_ble_mac() -> *const u8;
}
extern "C" {
	#[doc = " Get address of version structure of firmware."]
	#[doc = ""]
	#[doc = " @return     Address of firmware version structure."]
	pub fn furi_hal_version_get_firmware_version() -> *const Version;
}
extern "C" {
	#[doc = " Get platform UID size in bytes"]
	#[doc = ""]
	#[doc = " @return     UID size in bytes"]
	pub fn furi_hal_version_uid_size() -> usize;
}
extern "C" {
	#[doc = " Get const pointer to UID"]
	#[doc = ""]
	#[doc = " @return     pointer to UID"]
	pub fn furi_hal_version_uid() -> *const u8;
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum GapEventType {
	GapEventTypeConnected = 0,
	GapEventTypeDisconnected = 1,
	GapEventTypeStartAdvertising = 2,
	GapEventTypeStopAdvertising = 3,
	GapEventTypePinCodeShow = 4,
	GapEventTypePinCodeVerify = 5,
	GapEventTypeUpdateMTU = 6,
}
#[repr(C)]
pub struct GapEventData {
	pub pin_code: __BindgenUnionField<u32>,
	pub max_packet_size: __BindgenUnionField<u16>,
	pub bindgen_union_field: u32,
}
#[test]
fn bindgen_test_layout_GapEventData() {
	assert_eq!(
	           ::core::mem::size_of::<GapEventData>(),
	           4usize,
	           concat!("Size of: ", stringify!(GapEventData))
	);
	assert_eq!(
	           ::core::mem::align_of::<GapEventData>(),
	           4usize,
	           concat!("Alignment of ", stringify!(GapEventData))
	);
	fn test_field_pin_code() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<GapEventData>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).pin_code) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(GapEventData), "::", stringify!(pin_code))
		);
	}
	test_field_pin_code();
	fn test_field_max_packet_size() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<GapEventData>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).max_packet_size) as usize - ptr as usize
		           },
		           0usize,
		           concat!(
			"Offset of field: ",
			stringify!(GapEventData),
			"::",
			stringify!(max_packet_size)
		)
		);
	}
	test_field_max_packet_size();
}
#[repr(C)]
pub struct GapEvent {
	pub type_: GapEventType,
	pub data: GapEventData,
}
#[test]
fn bindgen_test_layout_GapEvent() {
	assert_eq!(
	           ::core::mem::size_of::<GapEvent>(),
	           8usize,
	           concat!("Size of: ", stringify!(GapEvent))
	);
	assert_eq!(
	           ::core::mem::align_of::<GapEvent>(),
	           4usize,
	           concat!("Alignment of ", stringify!(GapEvent))
	);
	fn test_field_type() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<GapEvent>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(GapEvent), "::", stringify!(type_))
		);
	}
	test_field_type();
	fn test_field_data() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<GapEvent>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).data) as usize - ptr as usize
		           },
		           4usize,
		           concat!("Offset of field: ", stringify!(GapEvent), "::", stringify!(data))
		);
	}
	test_field_data();
}
pub type GapEventCallback = ::core::option::Option<unsafe extern "C" fn(event: GapEvent, context: *mut core::ffi::c_void) -> bool>;
#[repr(u32)]
#[non_exhaustive]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum GapState {
	GapStateUninitialized = 0,
	GapStateIdle = 1,
	GapStateStartingAdv = 2,
	GapStateAdvFast = 3,
	GapStateAdvLowPower = 4,
	GapStateConnected = 5,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum GapPairing {
	GapPairingNone = 0,
	GapPairingPinCodeShow = 1,
	GapPairingPinCodeVerifyYesNo = 2,
}
#[repr(C)]
pub struct GapConnectionParams {
	pub conn_interval: u16,
	pub slave_latency: u16,
	pub supervisor_timeout: u16,
}
#[test]
fn bindgen_test_layout_GapConnectionParams() {
	assert_eq!(
	           ::core::mem::size_of::<GapConnectionParams>(),
	           6usize,
	           concat!("Size of: ", stringify!(GapConnectionParams))
	);
	assert_eq!(
	           ::core::mem::align_of::<GapConnectionParams>(),
	           2usize,
	           concat!("Alignment of ", stringify!(GapConnectionParams))
	);
	fn test_field_conn_interval() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<GapConnectionParams>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).conn_interval) as usize - ptr as usize
		           },
		           0usize,
		           concat!(
			"Offset of field: ",
			stringify!(GapConnectionParams),
			"::",
			stringify!(conn_interval)
		)
		);
	}
	test_field_conn_interval();
	fn test_field_slave_latency() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<GapConnectionParams>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).slave_latency) as usize - ptr as usize
		           },
		           2usize,
		           concat!(
			"Offset of field: ",
			stringify!(GapConnectionParams),
			"::",
			stringify!(slave_latency)
		)
		);
	}
	test_field_slave_latency();
	fn test_field_supervisor_timeout() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<GapConnectionParams>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).supervisor_timeout) as usize - ptr as usize
		           },
		           4usize,
		           concat!(
			"Offset of field: ",
			stringify!(GapConnectionParams),
			"::",
			stringify!(supervisor_timeout)
		)
		);
	}
	test_field_supervisor_timeout();
}
#[repr(C)]
pub struct GapConnectionParamsRequest {
	pub conn_int_min: u16,
	pub conn_int_max: u16,
	pub slave_latency: u16,
	pub supervisor_timeout: u16,
}
#[test]
fn bindgen_test_layout_GapConnectionParamsRequest() {
	assert_eq!(
	           ::core::mem::size_of::<GapConnectionParamsRequest>(),
	           8usize,
	           concat!("Size of: ", stringify!(GapConnectionParamsRequest))
	);
	assert_eq!(
	           ::core::mem::align_of::<GapConnectionParamsRequest>(),
	           2usize,
	           concat!("Alignment of ", stringify!(GapConnectionParamsRequest))
	);
	fn test_field_conn_int_min() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<GapConnectionParamsRequest>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).conn_int_min) as usize - ptr as usize
		           },
		           0usize,
		           concat!(
			"Offset of field: ",
			stringify!(GapConnectionParamsRequest),
			"::",
			stringify!(conn_int_min)
		)
		);
	}
	test_field_conn_int_min();
	fn test_field_conn_int_max() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<GapConnectionParamsRequest>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).conn_int_max) as usize - ptr as usize
		           },
		           2usize,
		           concat!(
			"Offset of field: ",
			stringify!(GapConnectionParamsRequest),
			"::",
			stringify!(conn_int_max)
		)
		);
	}
	test_field_conn_int_max();
	fn test_field_slave_latency() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<GapConnectionParamsRequest>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).slave_latency) as usize - ptr as usize
		           },
		           4usize,
		           concat!(
			"Offset of field: ",
			stringify!(GapConnectionParamsRequest),
			"::",
			stringify!(slave_latency)
		)
		);
	}
	test_field_slave_latency();
	fn test_field_supervisor_timeout() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<GapConnectionParamsRequest>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).supervisor_timeout) as usize - ptr as usize
		           },
		           6usize,
		           concat!(
			"Offset of field: ",
			stringify!(GapConnectionParamsRequest),
			"::",
			stringify!(supervisor_timeout)
		)
		);
	}
	test_field_supervisor_timeout();
}
#[repr(C)]
pub struct GapConfig {
	pub adv_service_uuid: u16,
	pub appearance_char: u16,
	pub bonding_mode: bool,
	pub pairing_method: GapPairing,
	pub mac_address: [u8; 6usize],
	pub adv_name: [core::ffi::c_char; 18usize],
	pub conn_param: GapConnectionParamsRequest,
}
#[test]
fn bindgen_test_layout_GapConfig() {
	assert_eq!(
	           ::core::mem::size_of::<GapConfig>(),
	           44usize,
	           concat!("Size of: ", stringify!(GapConfig))
	);
	assert_eq!(
	           ::core::mem::align_of::<GapConfig>(),
	           4usize,
	           concat!("Alignment of ", stringify!(GapConfig))
	);
	fn test_field_adv_service_uuid() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<GapConfig>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).adv_service_uuid) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(GapConfig), "::", stringify!(adv_service_uuid))
		);
	}
	test_field_adv_service_uuid();
	fn test_field_appearance_char() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<GapConfig>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).appearance_char) as usize - ptr as usize
		           },
		           2usize,
		           concat!("Offset of field: ", stringify!(GapConfig), "::", stringify!(appearance_char))
		);
	}
	test_field_appearance_char();
	fn test_field_bonding_mode() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<GapConfig>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).bonding_mode) as usize - ptr as usize
		           },
		           4usize,
		           concat!("Offset of field: ", stringify!(GapConfig), "::", stringify!(bonding_mode))
		);
	}
	test_field_bonding_mode();
	fn test_field_pairing_method() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<GapConfig>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).pairing_method) as usize - ptr as usize
		           },
		           8usize,
		           concat!("Offset of field: ", stringify!(GapConfig), "::", stringify!(pairing_method))
		);
	}
	test_field_pairing_method();
	fn test_field_mac_address() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<GapConfig>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).mac_address) as usize - ptr as usize
		           },
		           12usize,
		           concat!("Offset of field: ", stringify!(GapConfig), "::", stringify!(mac_address))
		);
	}
	test_field_mac_address();
	fn test_field_adv_name() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<GapConfig>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).adv_name) as usize - ptr as usize
		           },
		           18usize,
		           concat!("Offset of field: ", stringify!(GapConfig), "::", stringify!(adv_name))
		);
	}
	test_field_adv_name();
	fn test_field_conn_param() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<GapConfig>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).conn_param) as usize - ptr as usize
		           },
		           36usize,
		           concat!("Offset of field: ", stringify!(GapConfig), "::", stringify!(conn_param))
		);
	}
	test_field_conn_param();
}
extern "C" {
	pub fn gap_init(config: *mut GapConfig, on_event_cb: GapEventCallback, context: *mut core::ffi::c_void) -> bool;
}
extern "C" {
	pub fn gap_start_advertising();
}
extern "C" {
	pub fn gap_stop_advertising();
}
extern "C" {
	pub fn gap_get_state() -> GapState;
}
extern "C" {
	pub fn gap_thread_stop();
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum SerialServiceEventType {
	SerialServiceEventTypeDataReceived = 0,
	SerialServiceEventTypeDataSent = 1,
}
#[repr(C)]
pub struct SerialServiceData {
	pub buffer: *mut u8,
	pub size: u16,
}
#[test]
fn bindgen_test_layout_SerialServiceData() {
	assert_eq!(
	           ::core::mem::size_of::<SerialServiceData>(),
	           8usize,
	           concat!("Size of: ", stringify!(SerialServiceData))
	);
	assert_eq!(
	           ::core::mem::align_of::<SerialServiceData>(),
	           4usize,
	           concat!("Alignment of ", stringify!(SerialServiceData))
	);
	fn test_field_buffer() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<SerialServiceData>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).buffer) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(SerialServiceData), "::", stringify!(buffer))
		);
	}
	test_field_buffer();
	fn test_field_size() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<SerialServiceData>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).size) as usize - ptr as usize
		           },
		           4usize,
		           concat!("Offset of field: ", stringify!(SerialServiceData), "::", stringify!(size))
		);
	}
	test_field_size();
}
#[repr(C)]
pub struct SerialServiceEvent {
	pub event: SerialServiceEventType,
	pub data: SerialServiceData,
}
#[test]
fn bindgen_test_layout_SerialServiceEvent() {
	assert_eq!(
	           ::core::mem::size_of::<SerialServiceEvent>(),
	           12usize,
	           concat!("Size of: ", stringify!(SerialServiceEvent))
	);
	assert_eq!(
	           ::core::mem::align_of::<SerialServiceEvent>(),
	           4usize,
	           concat!("Alignment of ", stringify!(SerialServiceEvent))
	);
	fn test_field_event() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<SerialServiceEvent>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).event) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(SerialServiceEvent), "::", stringify!(event))
		);
	}
	test_field_event();
	fn test_field_data() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<SerialServiceEvent>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).data) as usize - ptr as usize
		           },
		           4usize,
		           concat!("Offset of field: ", stringify!(SerialServiceEvent), "::", stringify!(data))
		);
	}
	test_field_data();
}
pub type SerialServiceEventCallback =
	::core::option::Option<unsafe extern "C" fn(event: SerialServiceEvent, context: *mut core::ffi::c_void) -> u16>;
extern "C" {
	pub fn serial_svc_start();
}
extern "C" {
	pub fn serial_svc_set_callbacks(buff_size: u16, callback: SerialServiceEventCallback, context: *mut core::ffi::c_void);
}
extern "C" {
	pub fn serial_svc_notify_buffer_is_empty();
}
extern "C" {
	pub fn serial_svc_stop();
}
extern "C" {
	pub fn serial_svc_is_started() -> bool;
}
extern "C" {
	pub fn serial_svc_update_tx(data: *mut u8, data_len: u16) -> bool;
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum BleGlueC2Mode {
	BleGlueC2ModeUnknown = 0,
	BleGlueC2ModeFUS = 1,
	BleGlueC2ModeStack = 2,
}
#[repr(C)]
pub struct BleGlueC2Info {
	pub mode: BleGlueC2Mode,
	#[doc = " Wireless Info"]
	pub VersionMajor: u8,
	pub VersionMinor: u8,
	pub VersionSub: u8,
	pub VersionBranch: u8,
	pub VersionReleaseType: u8,
	pub MemorySizeSram2B: u8,
	pub MemorySizeSram2A: u8,
	pub MemorySizeSram1: u8,
	pub MemorySizeFlash: u8,
	pub StackType: u8,
	pub StackTypeString: [core::ffi::c_char; 20usize],
	#[doc = " Fus Info"]
	pub FusVersionMajor: u8,
	pub FusVersionMinor: u8,
	pub FusVersionSub: u8,
	pub FusMemorySizeSram2B: u8,
	pub FusMemorySizeSram2A: u8,
	pub FusMemorySizeFlash: u8,
}
#[test]
fn bindgen_test_layout_BleGlueC2Info() {
	assert_eq!(
	           ::core::mem::size_of::<BleGlueC2Info>(),
	           40usize,
	           concat!("Size of: ", stringify!(BleGlueC2Info))
	);
	assert_eq!(
	           ::core::mem::align_of::<BleGlueC2Info>(),
	           4usize,
	           concat!("Alignment of ", stringify!(BleGlueC2Info))
	);
	fn test_field_mode() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<BleGlueC2Info>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).mode) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(BleGlueC2Info), "::", stringify!(mode))
		);
	}
	test_field_mode();
	fn test_field_VersionMajor() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<BleGlueC2Info>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).VersionMajor) as usize - ptr as usize
		           },
		           4usize,
		           concat!("Offset of field: ", stringify!(BleGlueC2Info), "::", stringify!(VersionMajor))
		);
	}
	test_field_VersionMajor();
	fn test_field_VersionMinor() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<BleGlueC2Info>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).VersionMinor) as usize - ptr as usize
		           },
		           5usize,
		           concat!("Offset of field: ", stringify!(BleGlueC2Info), "::", stringify!(VersionMinor))
		);
	}
	test_field_VersionMinor();
	fn test_field_VersionSub() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<BleGlueC2Info>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).VersionSub) as usize - ptr as usize
		           },
		           6usize,
		           concat!("Offset of field: ", stringify!(BleGlueC2Info), "::", stringify!(VersionSub))
		);
	}
	test_field_VersionSub();
	fn test_field_VersionBranch() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<BleGlueC2Info>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).VersionBranch) as usize - ptr as usize
		           },
		           7usize,
		           concat!(
			"Offset of field: ",
			stringify!(BleGlueC2Info),
			"::",
			stringify!(VersionBranch)
		)
		);
	}
	test_field_VersionBranch();
	fn test_field_VersionReleaseType() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<BleGlueC2Info>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).VersionReleaseType) as usize - ptr as usize
		           },
		           8usize,
		           concat!(
			"Offset of field: ",
			stringify!(BleGlueC2Info),
			"::",
			stringify!(VersionReleaseType)
		)
		);
	}
	test_field_VersionReleaseType();
	fn test_field_MemorySizeSram2B() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<BleGlueC2Info>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).MemorySizeSram2B) as usize - ptr as usize
		           },
		           9usize,
		           concat!(
			"Offset of field: ",
			stringify!(BleGlueC2Info),
			"::",
			stringify!(MemorySizeSram2B)
		)
		);
	}
	test_field_MemorySizeSram2B();
	fn test_field_MemorySizeSram2A() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<BleGlueC2Info>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).MemorySizeSram2A) as usize - ptr as usize
		           },
		           10usize,
		           concat!(
			"Offset of field: ",
			stringify!(BleGlueC2Info),
			"::",
			stringify!(MemorySizeSram2A)
		)
		);
	}
	test_field_MemorySizeSram2A();
	fn test_field_MemorySizeSram1() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<BleGlueC2Info>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).MemorySizeSram1) as usize - ptr as usize
		           },
		           11usize,
		           concat!(
			"Offset of field: ",
			stringify!(BleGlueC2Info),
			"::",
			stringify!(MemorySizeSram1)
		)
		);
	}
	test_field_MemorySizeSram1();
	fn test_field_MemorySizeFlash() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<BleGlueC2Info>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).MemorySizeFlash) as usize - ptr as usize
		           },
		           12usize,
		           concat!(
			"Offset of field: ",
			stringify!(BleGlueC2Info),
			"::",
			stringify!(MemorySizeFlash)
		)
		);
	}
	test_field_MemorySizeFlash();
	fn test_field_StackType() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<BleGlueC2Info>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).StackType) as usize - ptr as usize
		           },
		           13usize,
		           concat!("Offset of field: ", stringify!(BleGlueC2Info), "::", stringify!(StackType))
		);
	}
	test_field_StackType();
	fn test_field_StackTypeString() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<BleGlueC2Info>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).StackTypeString) as usize - ptr as usize
		           },
		           14usize,
		           concat!(
			"Offset of field: ",
			stringify!(BleGlueC2Info),
			"::",
			stringify!(StackTypeString)
		)
		);
	}
	test_field_StackTypeString();
	fn test_field_FusVersionMajor() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<BleGlueC2Info>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).FusVersionMajor) as usize - ptr as usize
		           },
		           34usize,
		           concat!(
			"Offset of field: ",
			stringify!(BleGlueC2Info),
			"::",
			stringify!(FusVersionMajor)
		)
		);
	}
	test_field_FusVersionMajor();
	fn test_field_FusVersionMinor() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<BleGlueC2Info>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).FusVersionMinor) as usize - ptr as usize
		           },
		           35usize,
		           concat!(
			"Offset of field: ",
			stringify!(BleGlueC2Info),
			"::",
			stringify!(FusVersionMinor)
		)
		);
	}
	test_field_FusVersionMinor();
	fn test_field_FusVersionSub() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<BleGlueC2Info>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).FusVersionSub) as usize - ptr as usize
		           },
		           36usize,
		           concat!(
			"Offset of field: ",
			stringify!(BleGlueC2Info),
			"::",
			stringify!(FusVersionSub)
		)
		);
	}
	test_field_FusVersionSub();
	fn test_field_FusMemorySizeSram2B() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<BleGlueC2Info>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).FusMemorySizeSram2B) as usize - ptr as usize
		           },
		           37usize,
		           concat!(
			"Offset of field: ",
			stringify!(BleGlueC2Info),
			"::",
			stringify!(FusMemorySizeSram2B)
		)
		);
	}
	test_field_FusMemorySizeSram2B();
	fn test_field_FusMemorySizeSram2A() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<BleGlueC2Info>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).FusMemorySizeSram2A) as usize - ptr as usize
		           },
		           38usize,
		           concat!(
			"Offset of field: ",
			stringify!(BleGlueC2Info),
			"::",
			stringify!(FusMemorySizeSram2A)
		)
		);
	}
	test_field_FusMemorySizeSram2A();
	fn test_field_FusMemorySizeFlash() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<BleGlueC2Info>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).FusMemorySizeFlash) as usize - ptr as usize
		           },
		           39usize,
		           concat!(
			"Offset of field: ",
			stringify!(BleGlueC2Info),
			"::",
			stringify!(FusMemorySizeFlash)
		)
		);
	}
	test_field_FusMemorySizeFlash();
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum BleGlueStatus {
	BleGlueStatusStartup = 0,
	BleGlueStatusBroken = 1,
	BleGlueStatusC2Started = 2,
	BleGlueStatusRadioStackRunning = 3,
	BleGlueStatusRadioStackMissing = 4,
}
pub type BleGlueKeyStorageChangedCallback =
	::core::option::Option<unsafe extern "C" fn(change_addr_start: *mut u8, size: u16, context: *mut core::ffi::c_void)>;
extern "C" {
	#[doc = " Initialize start core2 and initialize transport"]
	pub fn ble_glue_init();
}
extern "C" {
	#[doc = " Start Core2 Radio stack"]
	#[doc = ""]
	#[doc = " @return     true on success"]
	pub fn ble_glue_start() -> bool;
}
extern "C" {
	#[doc = " Is core2 alive and at least FUS is running"]
	#[doc = ""]
	#[doc = " @return     true if core2 is alive"]
	pub fn ble_glue_is_alive() -> bool;
}
extern "C" {
	#[doc = " Waits for C2 to reports its mode to callback"]
	#[doc = ""]
	#[doc = " @return     true if it reported before reaching timeout"]
	pub fn ble_glue_wait_for_c2_start(timeout: i32) -> bool;
}
extern "C" {
	pub fn ble_glue_get_c2_status() -> BleGlueStatus;
}
extern "C" {
	pub fn ble_glue_get_c2_info() -> *const BleGlueC2Info;
}
extern "C" {
	#[doc = " Is core2 radio stack present and ready"]
	#[doc = ""]
	#[doc = " @return     true if present and ready"]
	pub fn ble_glue_is_radio_stack_ready() -> bool;
}
extern "C" {
	#[doc = " Set callback for NVM in RAM changes"]
	#[doc = ""]
	#[doc = " @param[in]  callback  The callback to call on NVM change"]
	#[doc = " @param      context   The context for callback"]
	pub fn ble_glue_set_key_storage_changed_callback(callback: BleGlueKeyStorageChangedCallback, context: *mut core::ffi::c_void);
}
extern "C" {
	#[doc = " Stop SHCI thread"]
	pub fn ble_glue_thread_stop();
}
extern "C" {
	pub fn ble_glue_reinit_c2() -> bool;
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum BleGlueCommandResult {
	BleGlueCommandResultUnknown = 0,
	BleGlueCommandResultOK = 1,
	BleGlueCommandResultError = 2,
	BleGlueCommandResultRestartPending = 3,
	BleGlueCommandResultOperationOngoing = 4,
}
extern "C" {
	#[doc = " Restart MCU to launch radio stack firmware if necessary"]
	#[doc = ""]
	#[doc = " @return      true on radio stack start command"]
	pub fn ble_glue_force_c2_mode(mode: BleGlueC2Mode) -> BleGlueCommandResult;
}
extern "C" {
	pub fn ble_glue_fus_stack_delete() -> BleGlueCommandResult;
}
extern "C" {
	pub fn ble_glue_fus_stack_install(src_addr: u32, dst_addr: u32) -> BleGlueCommandResult;
}
extern "C" {
	pub fn ble_glue_fus_get_status() -> BleGlueCommandResult;
}
extern "C" {
	pub fn ble_glue_fus_wait_operation() -> BleGlueCommandResult;
}
extern "C" {
	pub fn ble_app_init() -> bool;
}
extern "C" {
	pub fn ble_app_get_key_storage_buff(addr: *mut *mut u8, size: *mut u16);
}
extern "C" {
	pub fn ble_app_thread_stop();
}
#[doc = " Serial service callback type"]
pub type FuriHalBtSerialCallback = SerialServiceEventCallback;
extern "C" {
	#[doc = " Start Serial Profile"]
	pub fn furi_hal_bt_serial_start();
}
extern "C" {
	#[doc = " Stop Serial Profile"]
	pub fn furi_hal_bt_serial_stop();
}
extern "C" {
	#[doc = " Set Serial service events callback"]
	#[doc = ""]
	#[doc = " @param buffer_size   Applicaition buffer size"]
	#[doc = " @param calback       FuriHalBtSerialCallback instance"]
	#[doc = " @param context       pointer to context"]
	pub fn furi_hal_bt_serial_set_event_callback(buff_size: u16, callback: FuriHalBtSerialCallback, context: *mut core::ffi::c_void);
}
extern "C" {
	#[doc = " Notify that application buffer is empty"]
	pub fn furi_hal_bt_serial_notify_buffer_is_empty();
}
extern "C" {
	#[doc = " Send data through BLE"]
	#[doc = ""]
	#[doc = " @param data  data buffer"]
	#[doc = " @param size  data buffer size"]
	#[doc = ""]
	#[doc = " @return      true on success"]
	pub fn furi_hal_bt_serial_tx(data: *mut u8, size: u16) -> bool;
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum FuriHalBtStack {
	FuriHalBtStackUnknown = 0,
	FuriHalBtStackLight = 1,
	FuriHalBtStackFull = 2,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum FuriHalBtProfile {
	FuriHalBtProfileSerial = 0,
	FuriHalBtProfileHidKeyboard = 1,
	FuriHalBtProfileNumber = 2,
}
extern "C" {
	#[doc = " Initialize"]
	pub fn furi_hal_bt_init();
}
extern "C" {
	#[doc = " Lock core2 state transition"]
	pub fn furi_hal_bt_lock_core2();
}
extern "C" {
	#[doc = " Lock core2 state transition"]
	pub fn furi_hal_bt_unlock_core2();
}
extern "C" {
	#[doc = " Start radio stack"]
	#[doc = ""]
	#[doc = " @return  true on successfull radio stack start"]
	pub fn furi_hal_bt_start_radio_stack() -> bool;
}
extern "C" {
	#[doc = " Get radio stack type"]
	#[doc = ""]
	#[doc = " @return  FuriHalBtStack instance"]
	pub fn furi_hal_bt_get_radio_stack() -> FuriHalBtStack;
}
extern "C" {
	#[doc = " Check if radio stack supports BLE GAT/GAP"]
	#[doc = ""]
	#[doc = " @return  true if supported"]
	pub fn furi_hal_bt_is_ble_gatt_gap_supported() -> bool;
}
extern "C" {
	#[doc = " Check if radio stack supports testing"]
	#[doc = ""]
	#[doc = " @return  true if supported"]
	pub fn furi_hal_bt_is_testing_supported() -> bool;
}
extern "C" {
	#[doc = " Start BLE app"]
	#[doc = ""]
	#[doc = " @param profile   FuriHalBtProfile instance"]
	#[doc = " @param event_cb  GapEventCallback instance"]
	#[doc = " @param context   pointer to context"]
	#[doc = ""]
	#[doc = " @return          true on success"]
	pub fn furi_hal_bt_start_app(profile: FuriHalBtProfile, event_cb: GapEventCallback, context: *mut core::ffi::c_void) -> bool;
}
extern "C" {
	#[doc = " Reinitialize core2"]
	#[doc = ""]
	#[doc = " Also can be used to prepare core2 for stop modes"]
	pub fn furi_hal_bt_reinit();
}
extern "C" {
	#[doc = " Change BLE app"]
	#[doc = " Restarts 2nd core"]
	#[doc = ""]
	#[doc = " @param profile   FuriHalBtProfile instance"]
	#[doc = " @param event_cb  GapEventCallback instance"]
	#[doc = " @param context   pointer to context"]
	#[doc = ""]
	#[doc = " @return          true on success"]
	pub fn furi_hal_bt_change_app(profile: FuriHalBtProfile, event_cb: GapEventCallback, context: *mut core::ffi::c_void) -> bool;
}
extern "C" {
	#[doc = " Update battery level"]
	#[doc = ""]
	#[doc = " @param battery_level battery level"]
	pub fn furi_hal_bt_update_battery_level(battery_level: u8);
}
extern "C" {
	#[doc = " Update battery power state"]
	pub fn furi_hal_bt_update_power_state();
}
extern "C" {
	#[doc = " Checks if BLE state is active"]
	#[doc = ""]
	#[doc = " @return          true if device is connected or advertising, false otherwise"]
	pub fn furi_hal_bt_is_active() -> bool;
}
extern "C" {
	#[doc = " Start advertising"]
	pub fn furi_hal_bt_start_advertising();
}
extern "C" {
	#[doc = " Stop advertising"]
	pub fn furi_hal_bt_stop_advertising();
}
extern "C" {
	#[doc = " Get BT/BLE system component state"]
	#[doc = ""]
	#[doc = " @param[in]  buffer  string_t buffer to write to"]
	pub fn furi_hal_bt_dump_state(buffer: *mut string_t);
}
extern "C" {
	#[doc = " Get BT/BLE system component state"]
	#[doc = ""]
	#[doc = " @return     true if core2 is alive"]
	pub fn furi_hal_bt_is_alive() -> bool;
}
extern "C" {
	#[doc = " Get key storage buffer address and size"]
	#[doc = ""]
	#[doc = " @param      key_buff_addr  pointer to store buffer address"]
	#[doc = " @param      key_buff_size  pointer to store buffer size"]
	pub fn furi_hal_bt_get_key_storage_buff(key_buff_addr: *mut *mut u8, key_buff_size: *mut u16);
}
extern "C" {
	#[doc = " Get SRAM2 hardware semaphore"]
	#[doc = " @note Must be called before SRAM2 read/write operations"]
	pub fn furi_hal_bt_nvm_sram_sem_acquire();
}
extern "C" {
	#[doc = " Release SRAM2 hardware semaphore"]
	#[doc = " @note Must be called after SRAM2 read/write operations"]
	pub fn furi_hal_bt_nvm_sram_sem_release();
}
extern "C" {
	#[doc = " Clear key storage"]
	#[doc = ""]
	#[doc = " @return      true on success"]
	pub fn furi_hal_bt_clear_white_list() -> bool;
}
extern "C" {
	#[doc = " Set key storage change callback"]
	#[doc = ""]
	#[doc = " @param       callback    BleGlueKeyStorageChangedCallback instance"]
	#[doc = " @param       context     pointer to context"]
	pub fn furi_hal_bt_set_key_storage_change_callback(callback: BleGlueKeyStorageChangedCallback, context: *mut core::ffi::c_void);
}
extern "C" {
	#[doc = " Start ble tone tx at given channel and power"]
	#[doc = ""]
	#[doc = " @param[in]  channel  The channel"]
	#[doc = " @param[in]  power    The power"]
	pub fn furi_hal_bt_start_tone_tx(channel: u8, power: u8);
}
extern "C" {
	#[doc = " Stop ble tone tx"]
	pub fn furi_hal_bt_stop_tone_tx();
}
extern "C" {
	#[doc = " Start sending ble packets at a given frequency and datarate"]
	#[doc = ""]
	#[doc = " @param[in]  channel   The channel"]
	#[doc = " @param[in]  pattern   The pattern"]
	#[doc = " @param[in]  datarate  The datarate"]
	pub fn furi_hal_bt_start_packet_tx(channel: u8, pattern: u8, datarate: u8);
}
extern "C" {
	#[doc = " Stop sending ble packets"]
	#[doc = ""]
	#[doc = " @return     sent packet count"]
	pub fn furi_hal_bt_stop_packet_test() -> u16;
}
extern "C" {
	#[doc = " Start receiving packets"]
	#[doc = ""]
	#[doc = " @param[in]  channel   RX channel"]
	#[doc = " @param[in]  datarate  Datarate"]
	pub fn furi_hal_bt_start_packet_rx(channel: u8, datarate: u8);
}
extern "C" {
	#[doc = " Set up the RF to listen to a given RF channel"]
	#[doc = ""]
	#[doc = " @param[in]  channel  RX channel"]
	pub fn furi_hal_bt_start_rx(channel: u8);
}
extern "C" {
	#[doc = " Stop RF listenning"]
	pub fn furi_hal_bt_stop_rx();
}
extern "C" {
	#[doc = " Get RSSI"]
	#[doc = ""]
	#[doc = " @return     RSSI in dBm"]
	pub fn furi_hal_bt_get_rssi() -> core::ffi::c_float;
}
extern "C" {
	#[doc = " Get number of transmitted packets"]
	#[doc = ""]
	#[doc = " @return     packet count"]
	pub fn furi_hal_bt_get_transmitted_packets() -> u32;
}
extern "C" {
	#[doc = " Check & switch C2 to given mode"]
	#[doc = ""]
	#[doc = " @param[in]  mode  mode to switch into"]
	pub fn furi_hal_bt_ensure_c2_mode(mode: BleGlueC2Mode) -> bool;
}
#[repr(C)]
pub struct LevelDuration {
	pub level: u32,
	pub duration: u32,
}
#[test]
fn bindgen_test_layout_LevelDuration() {
	assert_eq!(
	           ::core::mem::size_of::<LevelDuration>(),
	           8usize,
	           concat!("Size of: ", stringify!(LevelDuration))
	);
	assert_eq!(
	           ::core::mem::align_of::<LevelDuration>(),
	           4usize,
	           concat!("Alignment of ", stringify!(LevelDuration))
	);
	fn test_field_level() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LevelDuration>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).level) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(LevelDuration), "::", stringify!(level))
		);
	}
	test_field_level();
	fn test_field_duration() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LevelDuration>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).duration) as usize - ptr as usize
		           },
		           4usize,
		           concat!("Offset of field: ", stringify!(LevelDuration), "::", stringify!(duration))
		);
	}
	test_field_duration();
}
#[repr(u32)]
#[non_exhaustive]
#[doc = " Radio Presets"]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum FuriHalSubGhzPreset {
	#[doc = "< default configuration"]
	FuriHalSubGhzPresetIDLE = 0,
	#[doc = "< OOK, bandwidth 270kHz, asynchronous"]
	FuriHalSubGhzPresetOok270Async = 1,
	#[doc = "< OOK, bandwidth 650kHz, asynchronous"]
	FuriHalSubGhzPresetOok650Async = 2,
	#[doc = "< FM, deviation 2.380371 kHz, asynchronous"]
	FuriHalSubGhzPreset2FSKDev238Async = 3,
	#[doc = "< FM, deviation 47.60742 kHz, asynchronous"]
	FuriHalSubGhzPreset2FSKDev476Async = 4,
	#[doc = "< MSK, deviation 47.60742 kHz, 99.97Kb/s, asynchronous"]
	FuriHalSubGhzPresetMSK99_97KbAsync = 5,
	#[doc = "< GFSK, deviation 19.042969 kHz, 9.996Kb/s, asynchronous"]
	FuriHalSubGhzPresetGFSK9_99KbAsync = 6,
	FuriHalSubGhzPresetCustom = 7,
}
#[repr(u32)]
#[non_exhaustive]
#[doc = " Switchable Radio Paths"]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum FuriHalSubGhzPath {
	#[doc = "< Isolate Radio from antenna"]
	FuriHalSubGhzPathIsolate = 0,
	#[doc = "< Center Frquency: 433MHz. Path 1: SW1RF1-SW2RF2, LCLCL"]
	FuriHalSubGhzPath433 = 1,
	#[doc = "< Center Frquency: 315MHz. Path 2: SW1RF2-SW2RF1, LCLCLCL"]
	FuriHalSubGhzPath315 = 2,
	#[doc = "< Center Frquency: 868MHz. Path 3: SW1RF3-SW2RF3, LCLC"]
	FuriHalSubGhzPath868 = 3,
}
#[repr(u32)]
#[non_exhaustive]
#[doc = " SubGhz state"]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum SubGhzState {
	#[doc = "< Init pending"]
	SubGhzStateInit = 0,
	#[doc = "< Idle, energy save mode"]
	SubGhzStateIdle = 1,
	#[doc = "< Async RX started"]
	SubGhzStateAsyncRx = 2,
	#[doc = "< Async TX started, DMA and timer is on"]
	SubGhzStateAsyncTx = 3,
	#[doc = "< Async TX continue, DMA completed and timer got last value to go"]
	SubGhzStateAsyncTxLast = 4,
	#[doc = "< Async TX complete, cleanup needed"]
	SubGhzStateAsyncTxEnd = 5,
}
#[repr(u32)]
#[non_exhaustive]
#[doc = " SubGhz regulation, receive transmission on the current frequency for the"]
#[doc = " region"]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum SubGhzRegulation {
	SubGhzRegulationOnlyRx = 0,
	#[doc = "only Rx"]
	SubGhzRegulationTxRx = 1,
}
extern "C" {
	#[doc = " Initialize and switch to power save mode Used by internal API-HAL"]
	#[doc = " initalization routine Can be used to reinitialize device to safe state and"]
	#[doc = " send it to sleep"]
	pub fn furi_hal_subghz_init();
}
extern "C" {
	#[doc = " Send device to sleep mode"]
	pub fn furi_hal_subghz_sleep();
}
extern "C" {
	#[doc = " Dump info to stdout"]
	pub fn furi_hal_subghz_dump_state();
}
extern "C" {
	#[doc = " Load registers from preset by preset name"]
	#[doc = ""]
	#[doc = " @param      preset  to load"]
	pub fn furi_hal_subghz_load_preset(preset: FuriHalSubGhzPreset);
}
extern "C" {
	#[doc = " Load custom registers from preset"]
	#[doc = ""]
	#[doc = " @param      preset_data   registers to load"]
	pub fn furi_hal_subghz_load_custom_preset(preset_data: *mut u8);
}
extern "C" {
	#[doc = " Load registers"]
	#[doc = ""]
	#[doc = " @param      data  Registers data"]
	pub fn furi_hal_subghz_load_registers(data: *mut u8);
}
extern "C" {
	#[doc = " Load PATABLE"]
	#[doc = ""]
	#[doc = " @param      data  8 uint8_t values"]
	pub fn furi_hal_subghz_load_patable(data: *const [u8; 8usize]);
}
extern "C" {
	#[doc = " Write packet to FIFO"]
	#[doc = ""]
	#[doc = " @param      data  bytes array"]
	#[doc = " @param      size  size"]
	pub fn furi_hal_subghz_write_packet(data: *const u8, size: u8);
}
extern "C" {
	#[doc = " Check if recieve pipe is not empty"]
	#[doc = ""]
	#[doc = " @return     true if not empty"]
	pub fn furi_hal_subghz_rx_pipe_not_empty() -> bool;
}
extern "C" {
	#[doc = " Check if recieved data crc is valid"]
	#[doc = ""]
	#[doc = " @return     true if valid"]
	pub fn furi_hal_subghz_is_rx_data_crc_valid() -> bool;
}
extern "C" {
	#[doc = " Read packet from FIFO"]
	#[doc = ""]
	#[doc = " @param      data  pointer"]
	#[doc = " @param      size  size"]
	pub fn furi_hal_subghz_read_packet(data: *mut u8, size: *mut u8);
}
extern "C" {
	#[doc = " Flush rx FIFO buffer"]
	pub fn furi_hal_subghz_flush_rx();
}
extern "C" {
	#[doc = " Flush tx FIFO buffer"]
	pub fn furi_hal_subghz_flush_tx();
}
extern "C" {
	#[doc = " Shutdown Issue spwd command"]
	#[doc = " @warning    registers content will be lost"]
	pub fn furi_hal_subghz_shutdown();
}
extern "C" {
	#[doc = " Reset Issue reset command"]
	#[doc = " @warning    registers content will be lost"]
	pub fn furi_hal_subghz_reset();
}
extern "C" {
	#[doc = " Switch to Idle"]
	pub fn furi_hal_subghz_idle();
}
extern "C" {
	#[doc = " Switch to Recieve"]
	pub fn furi_hal_subghz_rx();
}
extern "C" {
	#[doc = " Switch to Transmit"]
	#[doc = ""]
	#[doc = " @return     true if the transfer is allowed by belonging to the region"]
	pub fn furi_hal_subghz_tx() -> bool;
}
extern "C" {
	#[doc = " Get RSSI value in dBm"]
	#[doc = ""]
	#[doc = " @return     RSSI value"]
	pub fn furi_hal_subghz_get_rssi() -> core::ffi::c_float;
}
extern "C" {
	#[doc = " Get LQI"]
	#[doc = ""]
	#[doc = " @return     LQI value"]
	pub fn furi_hal_subghz_get_lqi() -> u8;
}
extern "C" {
	#[doc = " Check if frequency is in valid range"]
	#[doc = ""]
	#[doc = " @param      value  frequency in Hz"]
	#[doc = ""]
	#[doc = " @return     true if frequncy is valid, otherwise false"]
	pub fn furi_hal_subghz_is_frequency_valid(value: u32) -> bool;
}
extern "C" {
	#[doc = " Set frequency and path This function automatically selects antenna matching"]
	#[doc = " network"]
	#[doc = ""]
	#[doc = " @param      value  frequency in Hz"]
	#[doc = ""]
	#[doc = " @return     real frequency in herz"]
	pub fn furi_hal_subghz_set_frequency_and_path(value: u32) -> u32;
}
extern "C" {
	#[doc = " Set frequency"]
	#[doc = ""]
	#[doc = " @param      value  frequency in Hz"]
	#[doc = ""]
	#[doc = " @return     real frequency in herz"]
	pub fn furi_hal_subghz_set_frequency(value: u32) -> u32;
}
extern "C" {
	#[doc = " Set path"]
	#[doc = ""]
	#[doc = " @param      path  path to use"]
	pub fn furi_hal_subghz_set_path(path: FuriHalSubGhzPath);
}
#[doc = " Signal Timings Capture callback"]
pub type FuriHalSubGhzCaptureCallback =
	::core::option::Option<unsafe extern "C" fn(level: bool, duration: u32, context: *mut core::ffi::c_void)>;
extern "C" {
	#[doc = " Enable signal timings capture Initializes GPIO and TIM2 for timings capture"]
	#[doc = ""]
	#[doc = " @param      callback  FuriHalSubGhzCaptureCallback"]
	#[doc = " @param      context   callback context"]
	pub fn furi_hal_subghz_start_async_rx(callback: FuriHalSubGhzCaptureCallback, context: *mut core::ffi::c_void);
}
extern "C" {
	#[doc = " Disable signal timings capture Resets GPIO and TIM2"]
	pub fn furi_hal_subghz_stop_async_rx();
}
#[doc = " Async TX callback type"]
#[doc = " @param      context  callback context"]
#[doc = " @return     LevelDuration"]
pub type FuriHalSubGhzAsyncTxCallback =
	::core::option::Option<unsafe extern "C" fn(context: *mut core::ffi::c_void) -> LevelDuration>;
extern "C" {
	#[doc = " Start async TX Initializes GPIO, TIM2 and DMA1 for signal output"]
	#[doc = ""]
	#[doc = " @param      callback  FuriHalSubGhzAsyncTxCallback"]
	#[doc = " @param      context   callback context"]
	#[doc = ""]
	#[doc = " @return     true if the transfer is allowed by belonging to the region"]
	pub fn furi_hal_subghz_start_async_tx(callback: FuriHalSubGhzAsyncTxCallback, context: *mut core::ffi::c_void) -> bool;
}
extern "C" {
	#[doc = " Wait for async transmission to complete"]
	#[doc = ""]
	#[doc = " @return     true if TX complete"]
	pub fn furi_hal_subghz_is_async_tx_complete() -> bool;
}
extern "C" {
	#[doc = " Stop async transmission and cleanup resources Resets GPIO, TIM2, and DMA1"]
	pub fn furi_hal_subghz_stop_async_tx();
}
extern "C" {
	#[doc = " Initialize vibro"]
	pub fn furi_hal_vibro_init();
}
extern "C" {
	#[doc = " Turn on/off vibro"]
	#[doc = ""]
	#[doc = " @param[in]  value  new state"]
	pub fn furi_hal_vibro_on(value: bool);
}
pub type FuriHalIbuttonEmulateCallback = ::core::option::Option<unsafe extern "C" fn(context: *mut core::ffi::c_void)>;
extern "C" {
	#[doc = " Initialize"]
	pub fn furi_hal_ibutton_init();
}
extern "C" {
	pub fn furi_hal_ibutton_emulate_start(period: u32, callback: FuriHalIbuttonEmulateCallback, context: *mut core::ffi::c_void);
}
extern "C" {
	pub fn furi_hal_ibutton_emulate_set_next(period: u32);
}
extern "C" {
	pub fn furi_hal_ibutton_emulate_stop();
}
extern "C" {
	#[doc = " Sets the pin to normal mode (open collector), and sets it to float"]
	pub fn furi_hal_ibutton_start_drive();
}
extern "C" {
	#[doc = " Sets the pin to normal mode (open collector), and clears pin EXTI interrupt."]
	#[doc = " Used in EXTI interrupt context."]
	pub fn furi_hal_ibutton_start_drive_in_isr();
}
extern "C" {
	#[doc = " Sets the pin to interrupt mode (EXTI interrupt on rise or fall), and sets it to float"]
	pub fn furi_hal_ibutton_start_interrupt();
}
extern "C" {
	#[doc = " Sets the pin to interrupt mode (EXTI interrupt on rise or fall), and clears pin EXTI interrupt."]
	#[doc = " Used in EXTI interrupt context."]
	pub fn furi_hal_ibutton_start_interrupt_in_isr();
}
extern "C" {
	#[doc = " Sets the pin to analog mode, and sets it to float"]
	pub fn furi_hal_ibutton_stop();
}
extern "C" {
	#[doc = " Attach interrupt callback to iButton pin"]
	#[doc = " @param cb callback"]
	#[doc = " @param context context"]
	pub fn furi_hal_ibutton_add_interrupt(cb: GpioExtiCallback, context: *mut core::ffi::c_void);
}
extern "C" {
	#[doc = " Remove interrupt callback from iButton pin"]
	pub fn furi_hal_ibutton_remove_interrupt();
}
extern "C" {
	#[doc = " Sets the pin to low"]
	pub fn furi_hal_ibutton_pin_low();
}
extern "C" {
	#[doc = " Sets the pin to high (float in iButton pin modes)"]
	pub fn furi_hal_ibutton_pin_high();
}
extern "C" {
	#[doc = " Get pin level"]
	#[doc = " @return true if level is high"]
	#[doc = " @return false if level is low"]
	pub fn furi_hal_ibutton_pin_get_level() -> bool;
}
extern "C" {
	#[doc = " Initialize RFID subsystem"]
	pub fn furi_hal_rfid_init();
}
extern "C" {
	#[doc = " Config rfid pins to reset state"]
	pub fn furi_hal_rfid_pins_reset();
}
extern "C" {
	#[doc = " Config rfid pins to emulate state"]
	pub fn furi_hal_rfid_pins_emulate();
}
extern "C" {
	#[doc = " Config rfid pins to read state"]
	pub fn furi_hal_rfid_pins_read();
}
extern "C" {
	#[doc = " Release rfid pull pin"]
	pub fn furi_hal_rfid_pin_pull_release();
}
extern "C" {
	#[doc = " Pulldown rfid pull pin"]
	pub fn furi_hal_rfid_pin_pull_pulldown();
}
extern "C" {
	#[doc = " Config rfid timer to read state"]
	#[doc = ""]
	#[doc = " @param      freq        timer frequency"]
	#[doc = " @param      duty_cycle  timer duty cycle, 0.0-1.0"]
	pub fn furi_hal_rfid_tim_read(freq: core::ffi::c_float, duty_cycle: core::ffi::c_float);
}
extern "C" {
	#[doc = " Start read timer"]
	pub fn furi_hal_rfid_tim_read_start();
}
extern "C" {
	#[doc = " Stop read timer"]
	pub fn furi_hal_rfid_tim_read_stop();
}
extern "C" {
	#[doc = " Config rfid timer to emulate state"]
	#[doc = ""]
	#[doc = " @param      freq  timer frequency"]
	pub fn furi_hal_rfid_tim_emulate(freq: core::ffi::c_float);
}
pub type FuriHalRfidEmulateCallback = ::core::option::Option<unsafe extern "C" fn(context: *mut core::ffi::c_void)>;
extern "C" {
	#[doc = " Start emulation timer"]
	pub fn furi_hal_rfid_tim_emulate_start(callback: FuriHalRfidEmulateCallback, context: *mut core::ffi::c_void);
}
pub type FuriHalRfidReadCaptureCallback =
	::core::option::Option<unsafe extern "C" fn(level: bool, duration: u32, context: *mut core::ffi::c_void)>;
extern "C" {
	pub fn furi_hal_rfid_tim_read_capture_start(callback: FuriHalRfidReadCaptureCallback, context: *mut core::ffi::c_void);
}
extern "C" {
	pub fn furi_hal_rfid_tim_read_capture_stop();
}
pub type FuriHalRfidDMACallback = ::core::option::Option<unsafe extern "C" fn(half: bool, context: *mut core::ffi::c_void)>;
extern "C" {
	pub fn furi_hal_rfid_tim_emulate_dma_start(duration: *mut u32,
	                                           pulse: *mut u32,
	                                           length: usize,
	                                           callback: FuriHalRfidDMACallback,
	                                           context: *mut core::ffi::c_void);
}
extern "C" {
	pub fn furi_hal_rfid_tim_emulate_dma_stop();
}
extern "C" {
	#[doc = " Stop emulation timer"]
	pub fn furi_hal_rfid_tim_emulate_stop();
}
extern "C" {
	#[doc = " Config rfid timers to reset state"]
	pub fn furi_hal_rfid_tim_reset();
}
extern "C" {
	#[doc = " Set emulation timer period"]
	#[doc = ""]
	#[doc = " @param      period  overall duration"]
	pub fn furi_hal_rfid_set_emulate_period(period: u32);
}
extern "C" {
	#[doc = " Set emulation timer pulse"]
	#[doc = ""]
	#[doc = " @param      pulse  duration of high level"]
	pub fn furi_hal_rfid_set_emulate_pulse(pulse: u32);
}
extern "C" {
	#[doc = " Set read timer period"]
	#[doc = ""]
	#[doc = " @param      period  overall duration"]
	pub fn furi_hal_rfid_set_read_period(period: u32);
}
extern "C" {
	#[doc = " Set read timer pulse"]
	#[doc = ""]
	#[doc = " @param      pulse  duration of high level"]
	pub fn furi_hal_rfid_set_read_pulse(pulse: u32);
}
extern "C" {
	#[doc = " Сhanges the configuration of the RFID timer \"on a fly\""]
	#[doc = ""]
	#[doc = " @param      freq        new frequency"]
	#[doc = " @param      duty_cycle  new duty cycle"]
	pub fn furi_hal_rfid_change_read_config(freq: core::ffi::c_float, duty_cycle: core::ffi::c_float);
}
extern "C" {
	#[doc = " Start/Enable comparator"]
	pub fn furi_hal_rfid_comp_start();
}
extern "C" {
	#[doc = " Stop/Disable comparator"]
	pub fn furi_hal_rfid_comp_stop();
}
pub type FuriHalRfidCompCallback = ::core::option::Option<unsafe extern "C" fn(level: bool, context: *mut core::ffi::c_void)>;
extern "C" {
	#[doc = " Set comparator callback"]
	pub fn furi_hal_rfid_comp_set_callback(callback: FuriHalRfidCompCallback, context: *mut core::ffi::c_void);
}
pub type ReturnCode = u16;
pub const ERR_NONE: _bindgen_ty_1 = _bindgen_ty_1::ERR_NONE;
pub const ERR_NOMEM: _bindgen_ty_1 = _bindgen_ty_1::ERR_NOMEM;
pub const ERR_BUSY: _bindgen_ty_1 = _bindgen_ty_1::ERR_BUSY;
pub const ERR_IO: _bindgen_ty_1 = _bindgen_ty_1::ERR_IO;
pub const ERR_TIMEOUT: _bindgen_ty_1 = _bindgen_ty_1::ERR_TIMEOUT;
pub const ERR_REQUEST: _bindgen_ty_1 = _bindgen_ty_1::ERR_REQUEST;
pub const ERR_NOMSG: _bindgen_ty_1 = _bindgen_ty_1::ERR_NOMSG;
pub const ERR_PARAM: _bindgen_ty_1 = _bindgen_ty_1::ERR_PARAM;
pub const ERR_SYSTEM: _bindgen_ty_1 = _bindgen_ty_1::ERR_SYSTEM;
pub const ERR_FRAMING: _bindgen_ty_1 = _bindgen_ty_1::ERR_FRAMING;
pub const ERR_OVERRUN: _bindgen_ty_1 = _bindgen_ty_1::ERR_OVERRUN;
pub const ERR_PROTO: _bindgen_ty_1 = _bindgen_ty_1::ERR_PROTO;
pub const ERR_INTERNAL: _bindgen_ty_1 = _bindgen_ty_1::ERR_INTERNAL;
pub const ERR_AGAIN: _bindgen_ty_1 = _bindgen_ty_1::ERR_AGAIN;
pub const ERR_MEM_CORRUPT: _bindgen_ty_1 = _bindgen_ty_1::ERR_MEM_CORRUPT;
pub const ERR_NOT_IMPLEMENTED: _bindgen_ty_1 = _bindgen_ty_1::ERR_NOT_IMPLEMENTED;
pub const ERR_PC_CORRUPT: _bindgen_ty_1 = _bindgen_ty_1::ERR_PC_CORRUPT;
pub const ERR_SEND: _bindgen_ty_1 = _bindgen_ty_1::ERR_SEND;
pub const ERR_IGNORE: _bindgen_ty_1 = _bindgen_ty_1::ERR_IGNORE;
pub const ERR_SEMANTIC: _bindgen_ty_1 = _bindgen_ty_1::ERR_SEMANTIC;
pub const ERR_SYNTAX: _bindgen_ty_1 = _bindgen_ty_1::ERR_SYNTAX;
pub const ERR_CRC: _bindgen_ty_1 = _bindgen_ty_1::ERR_CRC;
pub const ERR_NOTFOUND: _bindgen_ty_1 = _bindgen_ty_1::ERR_NOTFOUND;
pub const ERR_NOTUNIQUE: _bindgen_ty_1 = _bindgen_ty_1::ERR_NOTUNIQUE;
pub const ERR_NOTSUPP: _bindgen_ty_1 = _bindgen_ty_1::ERR_NOTSUPP;
pub const ERR_WRITE: _bindgen_ty_1 = _bindgen_ty_1::ERR_WRITE;
pub const ERR_FIFO: _bindgen_ty_1 = _bindgen_ty_1::ERR_FIFO;
pub const ERR_PAR: _bindgen_ty_1 = _bindgen_ty_1::ERR_PAR;
pub const ERR_DONE: _bindgen_ty_1 = _bindgen_ty_1::ERR_DONE;
pub const ERR_RF_COLLISION: _bindgen_ty_1 = _bindgen_ty_1::ERR_RF_COLLISION;
pub const ERR_HW_OVERRUN: _bindgen_ty_1 = _bindgen_ty_1::ERR_HW_OVERRUN;
pub const ERR_RELEASE_REQ: _bindgen_ty_1 = _bindgen_ty_1::ERR_RELEASE_REQ;
pub const ERR_SLEEP_REQ: _bindgen_ty_1 = _bindgen_ty_1::ERR_SLEEP_REQ;
pub const ERR_WRONG_STATE: _bindgen_ty_1 = _bindgen_ty_1::ERR_WRONG_STATE;
pub const ERR_MAX_RERUNS: _bindgen_ty_1 = _bindgen_ty_1::ERR_MAX_RERUNS;
pub const ERR_DISABLED: _bindgen_ty_1 = _bindgen_ty_1::ERR_DISABLED;
pub const ERR_HW_MISMATCH: _bindgen_ty_1 = _bindgen_ty_1::ERR_HW_MISMATCH;
pub const ERR_LINK_LOSS: _bindgen_ty_1 = _bindgen_ty_1::ERR_LINK_LOSS;
pub const ERR_INVALID_HANDLE: _bindgen_ty_1 = _bindgen_ty_1::ERR_INVALID_HANDLE;
pub const ERR_INCOMPLETE_BYTE: _bindgen_ty_1 = _bindgen_ty_1::ERR_INCOMPLETE_BYTE;
pub const ERR_INCOMPLETE_BYTE_01: _bindgen_ty_1 = _bindgen_ty_1::ERR_INCOMPLETE_BYTE_01;
pub const ERR_INCOMPLETE_BYTE_02: _bindgen_ty_1 = _bindgen_ty_1::ERR_INCOMPLETE_BYTE_02;
pub const ERR_INCOMPLETE_BYTE_03: _bindgen_ty_1 = _bindgen_ty_1::ERR_INCOMPLETE_BYTE_03;
pub const ERR_INCOMPLETE_BYTE_04: _bindgen_ty_1 = _bindgen_ty_1::ERR_INCOMPLETE_BYTE_04;
pub const ERR_INCOMPLETE_BYTE_05: _bindgen_ty_1 = _bindgen_ty_1::ERR_INCOMPLETE_BYTE_05;
pub const ERR_INCOMPLETE_BYTE_06: _bindgen_ty_1 = _bindgen_ty_1::ERR_INCOMPLETE_BYTE_06;
pub const ERR_INCOMPLETE_BYTE_07: _bindgen_ty_1 = _bindgen_ty_1::ERR_INCOMPLETE_BYTE_07;
#[repr(u32)]
#[non_exhaustive]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum _bindgen_ty_1 {
	#[doc = "< no error occurred"]
	ERR_NONE = 0,
	#[doc = "< not enough memory to perform the requested operation"]
	ERR_NOMEM = 1,
	#[doc = "< device or resource busy"]
	ERR_BUSY = 2,
	#[doc = "< generic IO error"]
	ERR_IO = 3,
	#[doc = "< error due to timeout"]
	ERR_TIMEOUT = 4,
	#[doc = "< invalid request or requested function can't be executed at the moment"]
	ERR_REQUEST = 5,
	#[doc = "< No message of desired type"]
	ERR_NOMSG = 6,
	#[doc = "< Parameter error"]
	ERR_PARAM = 7,
	#[doc = "< System error"]
	ERR_SYSTEM = 8,
	#[doc = "< Framing error"]
	ERR_FRAMING = 9,
	#[doc = "< lost one or more received bytes"]
	ERR_OVERRUN = 10,
	#[doc = "< protocol error"]
	ERR_PROTO = 11,
	#[doc = "< Internal Error"]
	ERR_INTERNAL = 12,
	#[doc = "< Call again"]
	ERR_AGAIN = 13,
	#[doc = "< memory corruption"]
	ERR_MEM_CORRUPT = 14,
	#[doc = "< not implemented"]
	ERR_NOT_IMPLEMENTED = 15,
	ERR_PC_CORRUPT = 16,
	#[doc = "< error sending"]
	ERR_SEND = 17,
	#[doc = "< indicates error detected but to be ignored"]
	ERR_IGNORE = 18,
	#[doc = "< indicates error in state machine (unexpected cmd)"]
	ERR_SEMANTIC = 19,
	#[doc = "< indicates error in state machine (unknown cmd)"]
	ERR_SYNTAX = 20,
	#[doc = "< crc error"]
	ERR_CRC = 21,
	#[doc = "< transponder not found"]
	ERR_NOTFOUND = 22,
	#[doc = "< transponder not unique - more than one transponder in field"]
	ERR_NOTUNIQUE = 23,
	#[doc = "< requested operation not supported"]
	ERR_NOTSUPP = 24,
	#[doc = "< write error"]
	ERR_WRITE = 25,
	#[doc = "< fifo over or underflow error"]
	ERR_FIFO = 26,
	#[doc = "< parity error"]
	ERR_PAR = 27,
	#[doc = "< transfer has already finished"]
	ERR_DONE = 28,
	ERR_RF_COLLISION = 29,
	#[doc = "< lost one or more received bytes"]
	ERR_HW_OVERRUN = 30,
	#[doc = "< device requested release"]
	ERR_RELEASE_REQ = 31,
	#[doc = "< device requested sleep"]
	ERR_SLEEP_REQ = 32,
	#[doc = "< incorrent state for requested operation"]
	ERR_WRONG_STATE = 33,
	#[doc = "< blocking procedure reached maximum runs"]
	ERR_MAX_RERUNS = 34,
	#[doc = "< operation aborted due to disabled configuration"]
	ERR_DISABLED = 35,
	#[doc = "< expected hw do not match"]
	ERR_HW_MISMATCH = 36,
	ERR_LINK_LOSS = 37,
	#[doc = "< invalid or not initalized device handle"]
	ERR_INVALID_HANDLE = 38,
	#[doc = "< Incomplete byte rcvd"]
	ERR_INCOMPLETE_BYTE = 40,
	#[doc = "< Incomplete byte rcvd - 1 bit"]
	ERR_INCOMPLETE_BYTE_01 = 41,
	#[doc = "< Incomplete byte rcvd - 2 bit"]
	ERR_INCOMPLETE_BYTE_02 = 42,
	#[doc = "< Incomplete byte rcvd - 3 bit"]
	ERR_INCOMPLETE_BYTE_03 = 43,
	#[doc = "< Incomplete byte rcvd - 4 bit"]
	ERR_INCOMPLETE_BYTE_04 = 44,
	#[doc = "< Incomplete byte rcvd - 5 bit"]
	ERR_INCOMPLETE_BYTE_05 = 45,
	#[doc = "< Incomplete byte rcvd - 6 bit"]
	ERR_INCOMPLETE_BYTE_06 = 46,
	#[doc = "< Incomplete byte rcvd - 7 bit"]
	ERR_INCOMPLETE_BYTE_07 = 47,
}
extern "C" {
	#[doc = " \\brief  Calculate Timer"]
	#[doc = ""]
	#[doc = " This method calculates when the timer will be expired given the amount"]
	#[doc = " time in milliseconds /a tOut."]
	#[doc = " Once the timer has been calculated it will then be used to check when"]
	#[doc = " it expires."]
	#[doc = ""]
	#[doc = " \\see timersIsExpired"]
	#[doc = ""]
	#[doc = " \\param[in]  time : time/duration in Milliseconds for the timer"]
	#[doc = ""]
	#[doc = " \\return u32 : The new timer calculated based on the given time"]
	#[doc = ""]
	pub fn timerCalculateTimer(time: u16) -> u32;
}
extern "C" {
	#[doc = " \\brief  Checks if a Timer is Expired"]
	#[doc = ""]
	#[doc = " This method checks if a timer has already expired."]
	#[doc = " Based on the given timer previously calculated it checks if this timer"]
	#[doc = " has already elapsed"]
	#[doc = ""]
	#[doc = " \\see timersCalculateTimer"]
	#[doc = ""]
	#[doc = " \\param[in]  timer : the timer to check"]
	#[doc = ""]
	#[doc = " \\return true  : timer has already expired"]
	#[doc = " \\return false : timer is still running"]
	#[doc = ""]
	pub fn timerIsExpired(timer: u32) -> bool;
}
extern "C" {
	#[doc = " \\brief  Performs a Delay"]
	#[doc = ""]
	#[doc = " This method performs a delay for the given amount of time in Milliseconds"]
	#[doc = ""]
	#[doc = " \\param[in]  time : time/duration in Milliseconds of the delay"]
	#[doc = ""]
	#[doc = ""]
	pub fn timerDelay(time: u16);
}
extern "C" {
	#[doc = " \\brief  Stopwatch start"]
	#[doc = ""]
	#[doc = " This method initiates the stopwatch to later measure the time in ms"]
	#[doc = ""]
	#[doc = ""]
	pub fn timerStopwatchStart();
}
extern "C" {
	#[doc = " \\brief  Stopwatch Measure"]
	#[doc = ""]
	#[doc = " This method returns the elapsed time in ms since the stopwatch was initiated"]
	#[doc = ""]
	#[doc = " \\return The time in ms since the stopwatch was started"]
	#[doc = ""]
	pub fn timerStopwatchMeasure() -> u32;
}
extern "C" {
	pub fn atan(arg1: core::ffi::c_double) -> core::ffi::c_double;
}
extern "C" {
	pub fn cos(arg1: core::ffi::c_double) -> core::ffi::c_double;
}
extern "C" {
	pub fn sin(arg1: core::ffi::c_double) -> core::ffi::c_double;
}
extern "C" {
	pub fn tan(arg1: core::ffi::c_double) -> core::ffi::c_double;
}
extern "C" {
	pub fn tanh(arg1: core::ffi::c_double) -> core::ffi::c_double;
}
extern "C" {
	pub fn frexp(arg1: core::ffi::c_double, arg2: *mut core::ffi::c_int) -> core::ffi::c_double;
}
extern "C" {
	pub fn modf(arg1: core::ffi::c_double, arg2: *mut core::ffi::c_double) -> core::ffi::c_double;
}
extern "C" {
	pub fn ceil(arg1: core::ffi::c_double) -> core::ffi::c_double;
}
extern "C" {
	pub fn fabs(arg1: core::ffi::c_double) -> core::ffi::c_double;
}
extern "C" {
	pub fn floor(arg1: core::ffi::c_double) -> core::ffi::c_double;
}
extern "C" {
	pub fn acos(arg1: core::ffi::c_double) -> core::ffi::c_double;
}
extern "C" {
	pub fn asin(arg1: core::ffi::c_double) -> core::ffi::c_double;
}
extern "C" {
	pub fn atan2(arg1: core::ffi::c_double, arg2: core::ffi::c_double) -> core::ffi::c_double;
}
extern "C" {
	pub fn cosh(arg1: core::ffi::c_double) -> core::ffi::c_double;
}
extern "C" {
	pub fn sinh(arg1: core::ffi::c_double) -> core::ffi::c_double;
}
extern "C" {
	pub fn exp(arg1: core::ffi::c_double) -> core::ffi::c_double;
}
extern "C" {
	pub fn ldexp(arg1: core::ffi::c_double, arg2: core::ffi::c_int) -> core::ffi::c_double;
}
extern "C" {
	pub fn log(arg1: core::ffi::c_double) -> core::ffi::c_double;
}
extern "C" {
	pub fn log10(arg1: core::ffi::c_double) -> core::ffi::c_double;
}
extern "C" {
	pub fn pow(arg1: core::ffi::c_double, arg2: core::ffi::c_double) -> core::ffi::c_double;
}
extern "C" {
	pub fn sqrt(arg1: core::ffi::c_double) -> core::ffi::c_double;
}
extern "C" {
	pub fn fmod(arg1: core::ffi::c_double, arg2: core::ffi::c_double) -> core::ffi::c_double;
}
extern "C" {
	pub fn finite(arg1: core::ffi::c_double) -> core::ffi::c_int;
}
extern "C" {
	pub fn finitef(arg1: core::ffi::c_float) -> core::ffi::c_int;
}
extern "C" {
	pub fn finitel(arg1: f64) -> core::ffi::c_int;
}
extern "C" {
	pub fn isinff(arg1: core::ffi::c_float) -> core::ffi::c_int;
}
extern "C" {
	pub fn isnanf(arg1: core::ffi::c_float) -> core::ffi::c_int;
}
extern "C" {
	pub fn isinf(arg1: core::ffi::c_double) -> core::ffi::c_int;
}
extern "C" {
	pub fn isnan(arg1: core::ffi::c_double) -> core::ffi::c_int;
}
pub type float_t = core::ffi::c_float;
pub type double_t = core::ffi::c_double;
extern "C" {
	pub fn __isinff(arg1: core::ffi::c_float) -> core::ffi::c_int;
}
extern "C" {
	pub fn __isinfd(arg1: core::ffi::c_double) -> core::ffi::c_int;
}
extern "C" {
	pub fn __isnanf(arg1: core::ffi::c_float) -> core::ffi::c_int;
}
extern "C" {
	pub fn __isnand(arg1: core::ffi::c_double) -> core::ffi::c_int;
}
extern "C" {
	pub fn __fpclassifyf(arg1: core::ffi::c_float) -> core::ffi::c_int;
}
extern "C" {
	pub fn __fpclassifyd(arg1: core::ffi::c_double) -> core::ffi::c_int;
}
extern "C" {
	pub fn __signbitf(arg1: core::ffi::c_float) -> core::ffi::c_int;
}
extern "C" {
	pub fn __signbitd(arg1: core::ffi::c_double) -> core::ffi::c_int;
}
extern "C" {
	pub fn infinity() -> core::ffi::c_double;
}
extern "C" {
	pub fn nan(arg1: *const core::ffi::c_char) -> core::ffi::c_double;
}
extern "C" {
	pub fn copysign(arg1: core::ffi::c_double, arg2: core::ffi::c_double) -> core::ffi::c_double;
}
extern "C" {
	pub fn logb(arg1: core::ffi::c_double) -> core::ffi::c_double;
}
extern "C" {
	pub fn ilogb(arg1: core::ffi::c_double) -> core::ffi::c_int;
}
extern "C" {
	pub fn asinh(arg1: core::ffi::c_double) -> core::ffi::c_double;
}
extern "C" {
	pub fn cbrt(arg1: core::ffi::c_double) -> core::ffi::c_double;
}
extern "C" {
	pub fn nextafter(arg1: core::ffi::c_double, arg2: core::ffi::c_double) -> core::ffi::c_double;
}
extern "C" {
	pub fn rint(arg1: core::ffi::c_double) -> core::ffi::c_double;
}
extern "C" {
	pub fn scalbn(arg1: core::ffi::c_double, arg2: core::ffi::c_int) -> core::ffi::c_double;
}
extern "C" {
	pub fn exp2(arg1: core::ffi::c_double) -> core::ffi::c_double;
}
extern "C" {
	pub fn scalbln(arg1: core::ffi::c_double, arg2: core::ffi::c_long) -> core::ffi::c_double;
}
extern "C" {
	pub fn tgamma(arg1: core::ffi::c_double) -> core::ffi::c_double;
}
extern "C" {
	pub fn nearbyint(arg1: core::ffi::c_double) -> core::ffi::c_double;
}
extern "C" {
	pub fn lrint(arg1: core::ffi::c_double) -> core::ffi::c_long;
}
extern "C" {
	pub fn llrint(arg1: core::ffi::c_double) -> core::ffi::c_longlong;
}
extern "C" {
	pub fn round(arg1: core::ffi::c_double) -> core::ffi::c_double;
}
extern "C" {
	pub fn lround(arg1: core::ffi::c_double) -> core::ffi::c_long;
}
extern "C" {
	pub fn llround(arg1: core::ffi::c_double) -> core::ffi::c_longlong;
}
extern "C" {
	pub fn trunc(arg1: core::ffi::c_double) -> core::ffi::c_double;
}
extern "C" {
	pub fn remquo(arg1: core::ffi::c_double, arg2: core::ffi::c_double, arg3: *mut core::ffi::c_int) -> core::ffi::c_double;
}
extern "C" {
	pub fn fdim(arg1: core::ffi::c_double, arg2: core::ffi::c_double) -> core::ffi::c_double;
}
extern "C" {
	pub fn fmax(arg1: core::ffi::c_double, arg2: core::ffi::c_double) -> core::ffi::c_double;
}
extern "C" {
	pub fn fmin(arg1: core::ffi::c_double, arg2: core::ffi::c_double) -> core::ffi::c_double;
}
extern "C" {
	pub fn fma(arg1: core::ffi::c_double, arg2: core::ffi::c_double, arg3: core::ffi::c_double) -> core::ffi::c_double;
}
extern "C" {
	pub fn log1p(arg1: core::ffi::c_double) -> core::ffi::c_double;
}
extern "C" {
	pub fn expm1(arg1: core::ffi::c_double) -> core::ffi::c_double;
}
extern "C" {
	pub fn acosh(arg1: core::ffi::c_double) -> core::ffi::c_double;
}
extern "C" {
	pub fn atanh(arg1: core::ffi::c_double) -> core::ffi::c_double;
}
extern "C" {
	pub fn remainder(arg1: core::ffi::c_double, arg2: core::ffi::c_double) -> core::ffi::c_double;
}
extern "C" {
	pub fn gamma(arg1: core::ffi::c_double) -> core::ffi::c_double;
}
extern "C" {
	pub fn lgamma(arg1: core::ffi::c_double) -> core::ffi::c_double;
}
extern "C" {
	pub fn erf(arg1: core::ffi::c_double) -> core::ffi::c_double;
}
extern "C" {
	pub fn erfc(arg1: core::ffi::c_double) -> core::ffi::c_double;
}
extern "C" {
	pub fn log2(arg1: core::ffi::c_double) -> core::ffi::c_double;
}
extern "C" {
	pub fn hypot(arg1: core::ffi::c_double, arg2: core::ffi::c_double) -> core::ffi::c_double;
}
extern "C" {
	pub fn atanf(arg1: core::ffi::c_float) -> core::ffi::c_float;
}
extern "C" {
	pub fn cosf(arg1: core::ffi::c_float) -> core::ffi::c_float;
}
extern "C" {
	pub fn sinf(arg1: core::ffi::c_float) -> core::ffi::c_float;
}
extern "C" {
	pub fn tanf(arg1: core::ffi::c_float) -> core::ffi::c_float;
}
extern "C" {
	pub fn tanhf(arg1: core::ffi::c_float) -> core::ffi::c_float;
}
extern "C" {
	pub fn frexpf(arg1: core::ffi::c_float, arg2: *mut core::ffi::c_int) -> core::ffi::c_float;
}
extern "C" {
	pub fn modff(arg1: core::ffi::c_float, arg2: *mut core::ffi::c_float) -> core::ffi::c_float;
}
extern "C" {
	pub fn ceilf(arg1: core::ffi::c_float) -> core::ffi::c_float;
}
extern "C" {
	pub fn fabsf(arg1: core::ffi::c_float) -> core::ffi::c_float;
}
extern "C" {
	pub fn floorf(arg1: core::ffi::c_float) -> core::ffi::c_float;
}
extern "C" {
	pub fn acosf(arg1: core::ffi::c_float) -> core::ffi::c_float;
}
extern "C" {
	pub fn asinf(arg1: core::ffi::c_float) -> core::ffi::c_float;
}
extern "C" {
	pub fn atan2f(arg1: core::ffi::c_float, arg2: core::ffi::c_float) -> core::ffi::c_float;
}
extern "C" {
	pub fn coshf(arg1: core::ffi::c_float) -> core::ffi::c_float;
}
extern "C" {
	pub fn sinhf(arg1: core::ffi::c_float) -> core::ffi::c_float;
}
extern "C" {
	pub fn expf(arg1: core::ffi::c_float) -> core::ffi::c_float;
}
extern "C" {
	pub fn ldexpf(arg1: core::ffi::c_float, arg2: core::ffi::c_int) -> core::ffi::c_float;
}
extern "C" {
	pub fn logf(arg1: core::ffi::c_float) -> core::ffi::c_float;
}
extern "C" {
	pub fn log10f(arg1: core::ffi::c_float) -> core::ffi::c_float;
}
extern "C" {
	pub fn powf(arg1: core::ffi::c_float, arg2: core::ffi::c_float) -> core::ffi::c_float;
}
extern "C" {
	pub fn sqrtf(arg1: core::ffi::c_float) -> core::ffi::c_float;
}
extern "C" {
	pub fn fmodf(arg1: core::ffi::c_float, arg2: core::ffi::c_float) -> core::ffi::c_float;
}
extern "C" {
	pub fn exp2f(arg1: core::ffi::c_float) -> core::ffi::c_float;
}
extern "C" {
	pub fn scalblnf(arg1: core::ffi::c_float, arg2: core::ffi::c_long) -> core::ffi::c_float;
}
extern "C" {
	pub fn tgammaf(arg1: core::ffi::c_float) -> core::ffi::c_float;
}
extern "C" {
	pub fn nearbyintf(arg1: core::ffi::c_float) -> core::ffi::c_float;
}
extern "C" {
	pub fn lrintf(arg1: core::ffi::c_float) -> core::ffi::c_long;
}
extern "C" {
	pub fn llrintf(arg1: core::ffi::c_float) -> core::ffi::c_longlong;
}
extern "C" {
	pub fn roundf(arg1: core::ffi::c_float) -> core::ffi::c_float;
}
extern "C" {
	pub fn lroundf(arg1: core::ffi::c_float) -> core::ffi::c_long;
}
extern "C" {
	pub fn llroundf(arg1: core::ffi::c_float) -> core::ffi::c_longlong;
}
extern "C" {
	pub fn truncf(arg1: core::ffi::c_float) -> core::ffi::c_float;
}
extern "C" {
	pub fn remquof(arg1: core::ffi::c_float, arg2: core::ffi::c_float, arg3: *mut core::ffi::c_int) -> core::ffi::c_float;
}
extern "C" {
	pub fn fdimf(arg1: core::ffi::c_float, arg2: core::ffi::c_float) -> core::ffi::c_float;
}
extern "C" {
	pub fn fmaxf(arg1: core::ffi::c_float, arg2: core::ffi::c_float) -> core::ffi::c_float;
}
extern "C" {
	pub fn fminf(arg1: core::ffi::c_float, arg2: core::ffi::c_float) -> core::ffi::c_float;
}
extern "C" {
	pub fn fmaf(arg1: core::ffi::c_float, arg2: core::ffi::c_float, arg3: core::ffi::c_float) -> core::ffi::c_float;
}
extern "C" {
	pub fn infinityf() -> core::ffi::c_float;
}
extern "C" {
	pub fn nanf(arg1: *const core::ffi::c_char) -> core::ffi::c_float;
}
extern "C" {
	pub fn copysignf(arg1: core::ffi::c_float, arg2: core::ffi::c_float) -> core::ffi::c_float;
}
extern "C" {
	pub fn logbf(arg1: core::ffi::c_float) -> core::ffi::c_float;
}
extern "C" {
	pub fn ilogbf(arg1: core::ffi::c_float) -> core::ffi::c_int;
}
extern "C" {
	pub fn asinhf(arg1: core::ffi::c_float) -> core::ffi::c_float;
}
extern "C" {
	pub fn cbrtf(arg1: core::ffi::c_float) -> core::ffi::c_float;
}
extern "C" {
	pub fn nextafterf(arg1: core::ffi::c_float, arg2: core::ffi::c_float) -> core::ffi::c_float;
}
extern "C" {
	pub fn rintf(arg1: core::ffi::c_float) -> core::ffi::c_float;
}
extern "C" {
	pub fn scalbnf(arg1: core::ffi::c_float, arg2: core::ffi::c_int) -> core::ffi::c_float;
}
extern "C" {
	pub fn log1pf(arg1: core::ffi::c_float) -> core::ffi::c_float;
}
extern "C" {
	pub fn expm1f(arg1: core::ffi::c_float) -> core::ffi::c_float;
}
extern "C" {
	pub fn acoshf(arg1: core::ffi::c_float) -> core::ffi::c_float;
}
extern "C" {
	pub fn atanhf(arg1: core::ffi::c_float) -> core::ffi::c_float;
}
extern "C" {
	pub fn remainderf(arg1: core::ffi::c_float, arg2: core::ffi::c_float) -> core::ffi::c_float;
}
extern "C" {
	pub fn gammaf(arg1: core::ffi::c_float) -> core::ffi::c_float;
}
extern "C" {
	pub fn lgammaf(arg1: core::ffi::c_float) -> core::ffi::c_float;
}
extern "C" {
	pub fn erff(arg1: core::ffi::c_float) -> core::ffi::c_float;
}
extern "C" {
	pub fn erfcf(arg1: core::ffi::c_float) -> core::ffi::c_float;
}
extern "C" {
	pub fn log2f(arg1: core::ffi::c_float) -> core::ffi::c_float;
}
extern "C" {
	pub fn hypotf(arg1: core::ffi::c_float, arg2: core::ffi::c_float) -> core::ffi::c_float;
}
extern "C" {
	pub fn atanl(arg1: f64) -> f64;
}
extern "C" {
	pub fn cosl(arg1: f64) -> f64;
}
extern "C" {
	pub fn sinl(arg1: f64) -> f64;
}
extern "C" {
	pub fn tanl(arg1: f64) -> f64;
}
extern "C" {
	pub fn tanhl(arg1: f64) -> f64;
}
extern "C" {
	pub fn frexpl(arg1: f64, arg2: *mut core::ffi::c_int) -> f64;
}
extern "C" {
	pub fn modfl(arg1: f64, arg2: *mut f64) -> f64;
}
extern "C" {
	pub fn ceill(arg1: f64) -> f64;
}
extern "C" {
	pub fn fabsl(arg1: f64) -> f64;
}
extern "C" {
	pub fn floorl(arg1: f64) -> f64;
}
extern "C" {
	pub fn log1pl(arg1: f64) -> f64;
}
extern "C" {
	pub fn expm1l(arg1: f64) -> f64;
}
extern "C" {
	pub fn acosl(arg1: f64) -> f64;
}
extern "C" {
	pub fn asinl(arg1: f64) -> f64;
}
extern "C" {
	pub fn atan2l(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
	pub fn coshl(arg1: f64) -> f64;
}
extern "C" {
	pub fn sinhl(arg1: f64) -> f64;
}
extern "C" {
	pub fn expl(arg1: f64) -> f64;
}
extern "C" {
	pub fn ldexpl(arg1: f64, arg2: core::ffi::c_int) -> f64;
}
extern "C" {
	pub fn logl(arg1: f64) -> f64;
}
extern "C" {
	pub fn log10l(arg1: f64) -> f64;
}
extern "C" {
	pub fn powl(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
	pub fn sqrtl(arg1: f64) -> f64;
}
extern "C" {
	pub fn fmodl(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
	pub fn hypotl(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
	pub fn copysignl(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
	pub fn nanl(arg1: *const core::ffi::c_char) -> f64;
}
extern "C" {
	pub fn ilogbl(arg1: f64) -> core::ffi::c_int;
}
extern "C" {
	pub fn asinhl(arg1: f64) -> f64;
}
extern "C" {
	pub fn cbrtl(arg1: f64) -> f64;
}
extern "C" {
	pub fn nextafterl(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
	pub fn nexttowardf(arg1: core::ffi::c_float, arg2: f64) -> core::ffi::c_float;
}
extern "C" {
	pub fn nexttoward(arg1: core::ffi::c_double, arg2: f64) -> core::ffi::c_double;
}
extern "C" {
	pub fn nexttowardl(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
	pub fn logbl(arg1: f64) -> f64;
}
extern "C" {
	pub fn log2l(arg1: f64) -> f64;
}
extern "C" {
	pub fn rintl(arg1: f64) -> f64;
}
extern "C" {
	pub fn scalbnl(arg1: f64, arg2: core::ffi::c_int) -> f64;
}
extern "C" {
	pub fn exp2l(arg1: f64) -> f64;
}
extern "C" {
	pub fn scalblnl(arg1: f64, arg2: core::ffi::c_long) -> f64;
}
extern "C" {
	pub fn tgammal(arg1: f64) -> f64;
}
extern "C" {
	pub fn nearbyintl(arg1: f64) -> f64;
}
extern "C" {
	pub fn lrintl(arg1: f64) -> core::ffi::c_long;
}
extern "C" {
	pub fn llrintl(arg1: f64) -> core::ffi::c_longlong;
}
extern "C" {
	pub fn roundl(arg1: f64) -> f64;
}
extern "C" {
	pub fn lroundl(arg1: f64) -> core::ffi::c_long;
}
extern "C" {
	pub fn llroundl(arg1: f64) -> core::ffi::c_longlong;
}
extern "C" {
	pub fn truncl(arg1: f64) -> f64;
}
extern "C" {
	pub fn remquol(arg1: f64, arg2: f64, arg3: *mut core::ffi::c_int) -> f64;
}
extern "C" {
	pub fn fdiml(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
	pub fn fmaxl(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
	pub fn fminl(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
	pub fn fmal(arg1: f64, arg2: f64, arg3: f64) -> f64;
}
extern "C" {
	pub fn acoshl(arg1: f64) -> f64;
}
extern "C" {
	pub fn atanhl(arg1: f64) -> f64;
}
extern "C" {
	pub fn remainderl(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
	pub fn lgammal(arg1: f64) -> f64;
}
extern "C" {
	pub fn erfl(arg1: f64) -> f64;
}
extern "C" {
	pub fn erfcl(arg1: f64) -> f64;
}
extern "C" {
	pub fn drem(arg1: core::ffi::c_double, arg2: core::ffi::c_double) -> core::ffi::c_double;
}
extern "C" {
	pub fn dremf(arg1: core::ffi::c_float, arg2: core::ffi::c_float) -> core::ffi::c_float;
}
extern "C" {
	pub fn gamma_r(arg1: core::ffi::c_double, arg2: *mut core::ffi::c_int) -> core::ffi::c_double;
}
extern "C" {
	pub fn lgamma_r(arg1: core::ffi::c_double, arg2: *mut core::ffi::c_int) -> core::ffi::c_double;
}
extern "C" {
	pub fn gammaf_r(arg1: core::ffi::c_float, arg2: *mut core::ffi::c_int) -> core::ffi::c_float;
}
extern "C" {
	pub fn lgammaf_r(arg1: core::ffi::c_float, arg2: *mut core::ffi::c_int) -> core::ffi::c_float;
}
extern "C" {
	pub fn y0(arg1: core::ffi::c_double) -> core::ffi::c_double;
}
extern "C" {
	pub fn y1(arg1: core::ffi::c_double) -> core::ffi::c_double;
}
extern "C" {
	pub fn yn(arg1: core::ffi::c_int, arg2: core::ffi::c_double) -> core::ffi::c_double;
}
extern "C" {
	pub fn j0(arg1: core::ffi::c_double) -> core::ffi::c_double;
}
extern "C" {
	pub fn j1(arg1: core::ffi::c_double) -> core::ffi::c_double;
}
extern "C" {
	pub fn jn(arg1: core::ffi::c_int, arg2: core::ffi::c_double) -> core::ffi::c_double;
}
extern "C" {
	pub fn y0f(arg1: core::ffi::c_float) -> core::ffi::c_float;
}
extern "C" {
	pub fn y1f(arg1: core::ffi::c_float) -> core::ffi::c_float;
}
extern "C" {
	pub fn ynf(arg1: core::ffi::c_int, arg2: core::ffi::c_float) -> core::ffi::c_float;
}
extern "C" {
	pub fn j0f(arg1: core::ffi::c_float) -> core::ffi::c_float;
}
extern "C" {
	pub fn j1f(arg1: core::ffi::c_float) -> core::ffi::c_float;
}
extern "C" {
	pub fn jnf(arg1: core::ffi::c_int, arg2: core::ffi::c_float) -> core::ffi::c_float;
}
extern "C" {
	pub fn __signgam() -> *mut core::ffi::c_int;
}
pub type PlatformIrqCallback = ::core::option::Option<unsafe extern "C" fn()>;
extern "C" {
	pub fn platformSetIrqCallback(cb: PlatformIrqCallback);
}
extern "C" {
	pub fn platformEnableIrqCallback();
}
extern "C" {
	pub fn platformDisableIrqCallback();
}
extern "C" {
	pub fn platformSpiTxRx(txBuf: *const u8, rxBuf: *mut u8, len: u16) -> bool;
}
extern "C" {
	pub fn platformProtectST25RComm();
}
extern "C" {
	pub fn platformUnprotectST25RComm();
}
extern "C" {
	pub fn rfal_platform_spi_acquire();
}
extern "C" {
	pub fn rfal_platform_spi_release();
}
#[repr(u32)]
#[non_exhaustive]
#[doc = " RFAL modes"]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum rfalMode {
	#[doc = "< No mode selected/defined"]
	RFAL_MODE_NONE = 0,
	RFAL_MODE_POLL_NFCA = 1,
	RFAL_MODE_POLL_NFCA_T1T = 2,
	RFAL_MODE_POLL_NFCB = 3,
	RFAL_MODE_POLL_B_PRIME = 4,
	RFAL_MODE_POLL_B_CTS = 5,
	RFAL_MODE_POLL_NFCF = 6,
	RFAL_MODE_POLL_NFCV = 7,
	RFAL_MODE_POLL_PICOPASS = 8,
	RFAL_MODE_POLL_ACTIVE_P2P = 9,
	RFAL_MODE_LISTEN_NFCA = 10,
	RFAL_MODE_LISTEN_NFCB = 11,
	RFAL_MODE_LISTEN_NFCF = 12,
	RFAL_MODE_LISTEN_ACTIVE_P2P = 13,
}
#[repr(u32)]
#[non_exhaustive]
#[doc = " RFAL Bit rates"]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum rfalBitRate {
	#[doc = "< Bit Rate 106 kbit/s (fc/128)"]
	RFAL_BR_106 = 0,
	#[doc = "< Bit Rate 212 kbit/s (fc/64)"]
	RFAL_BR_212 = 1,
	#[doc = "< Bit Rate 424 kbit/s (fc/32)"]
	RFAL_BR_424 = 2,
	#[doc = "< Bit Rate 848 kbit/s (fc/16)"]
	RFAL_BR_848 = 3,
	#[doc = "< Bit Rate 1695 kbit/s (fc/8)"]
	RFAL_BR_1695 = 4,
	#[doc = "< Bit Rate 3390 kbit/s (fc/4)"]
	RFAL_BR_3390 = 5,
	#[doc = "< Bit Rate 6780 kbit/s (fc/2)"]
	RFAL_BR_6780 = 6,
	#[doc = "< Bit Rate 13560 kbit/s (fc)"]
	RFAL_BR_13560 = 7,
	#[doc = "< Bit Rate 52.97 kbit/s (fc/256) Fast Mode VICC->VCD"]
	RFAL_BR_52p97 = 235,
	#[doc = "< Bit Rate 26,48 kbit/s (fc/512) NFCV VICC->VCD & VCD->VICC 1of4"]
	RFAL_BR_26p48 = 236,
	#[doc = "< Bit Rate 1,66 kbit/s (fc/8192) NFCV VCD->VICC 1of256"]
	RFAL_BR_1p66 = 237,
	#[doc = "< Value indicating to keep the same previous bit rate"]
	RFAL_BR_KEEP = 255,
}
#[repr(u32)]
#[non_exhaustive]
#[doc = " RFAL Compliance modes for upper modules"]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum rfalComplianceMode {
	#[doc = "< Perform with NFC Forum 1.1 compliance"]
	RFAL_COMPLIANCE_MODE_NFC = 0,
	#[doc = "< Perform with EMVCo compliance"]
	RFAL_COMPLIANCE_MODE_EMV = 1,
	#[doc = "< Perform with ISO10373 compliance"]
	RFAL_COMPLIANCE_MODE_ISO = 2,
}
#[repr(u32)]
#[non_exhaustive]
#[doc = " RFAL main states flags"]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum rfalState {
	RFAL_STATE_IDLE = 0,
	RFAL_STATE_INIT = 1,
	RFAL_STATE_MODE_SET = 2,
	RFAL_STATE_TXRX = 3,
	RFAL_STATE_LM = 4,
	RFAL_STATE_WUM = 5,
}
#[repr(u32)]
#[non_exhaustive]
#[doc = " RFAL transceive states"]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum rfalTransceiveState {
	RFAL_TXRX_STATE_IDLE = 0,
	RFAL_TXRX_STATE_INIT = 1,
	RFAL_TXRX_STATE_START = 2,
	RFAL_TXRX_STATE_TX_IDLE = 11,
	RFAL_TXRX_STATE_TX_WAIT_GT = 12,
	RFAL_TXRX_STATE_TX_WAIT_FDT = 13,
	RFAL_TXRX_STATE_TX_TRANSMIT = 14,
	RFAL_TXRX_STATE_TX_WAIT_WL = 15,
	RFAL_TXRX_STATE_TX_RELOAD_FIFO = 16,
	RFAL_TXRX_STATE_TX_WAIT_TXE = 17,
	RFAL_TXRX_STATE_TX_DONE = 18,
	RFAL_TXRX_STATE_TX_FAIL = 19,
	RFAL_TXRX_STATE_RX_IDLE = 81,
	RFAL_TXRX_STATE_RX_WAIT_EON = 82,
	RFAL_TXRX_STATE_RX_WAIT_RXS = 83,
	RFAL_TXRX_STATE_RX_WAIT_RXE = 84,
	RFAL_TXRX_STATE_RX_READ_FIFO = 85,
	RFAL_TXRX_STATE_RX_ERR_CHECK = 86,
	RFAL_TXRX_STATE_RX_READ_DATA = 87,
	RFAL_TXRX_STATE_RX_WAIT_EOF = 88,
	RFAL_TXRX_STATE_RX_DONE = 89,
	RFAL_TXRX_STATE_RX_FAIL = 90,
}
pub const RFAL_TXRX_FLAGS_CRC_TX_AUTO: _bindgen_ty_2 = _bindgen_ty_2::RFAL_TXRX_FLAGS_CRC_TX_AUTO;
pub const RFAL_TXRX_FLAGS_CRC_TX_MANUAL: _bindgen_ty_2 = _bindgen_ty_2::RFAL_TXRX_FLAGS_CRC_TX_MANUAL;
pub const RFAL_TXRX_FLAGS_CRC_RX_KEEP: _bindgen_ty_2 = _bindgen_ty_2::RFAL_TXRX_FLAGS_CRC_RX_KEEP;
pub const RFAL_TXRX_FLAGS_CRC_RX_REMV: _bindgen_ty_2 = _bindgen_ty_2::RFAL_TXRX_FLAGS_CRC_TX_AUTO;
pub const RFAL_TXRX_FLAGS_NFCIP1_ON: _bindgen_ty_2 = _bindgen_ty_2::RFAL_TXRX_FLAGS_NFCIP1_ON;
pub const RFAL_TXRX_FLAGS_NFCIP1_OFF: _bindgen_ty_2 = _bindgen_ty_2::RFAL_TXRX_FLAGS_CRC_TX_AUTO;
pub const RFAL_TXRX_FLAGS_AGC_OFF: _bindgen_ty_2 = _bindgen_ty_2::RFAL_TXRX_FLAGS_AGC_OFF;
pub const RFAL_TXRX_FLAGS_AGC_ON: _bindgen_ty_2 = _bindgen_ty_2::RFAL_TXRX_FLAGS_CRC_TX_AUTO;
pub const RFAL_TXRX_FLAGS_PAR_RX_KEEP: _bindgen_ty_2 = _bindgen_ty_2::RFAL_TXRX_FLAGS_PAR_RX_KEEP;
pub const RFAL_TXRX_FLAGS_PAR_RX_REMV: _bindgen_ty_2 = _bindgen_ty_2::RFAL_TXRX_FLAGS_CRC_TX_AUTO;
pub const RFAL_TXRX_FLAGS_PAR_TX_NONE: _bindgen_ty_2 = _bindgen_ty_2::RFAL_TXRX_FLAGS_PAR_TX_NONE;
pub const RFAL_TXRX_FLAGS_PAR_TX_AUTO: _bindgen_ty_2 = _bindgen_ty_2::RFAL_TXRX_FLAGS_CRC_TX_AUTO;
pub const RFAL_TXRX_FLAGS_NFCV_FLAG_MANUAL: _bindgen_ty_2 = _bindgen_ty_2::RFAL_TXRX_FLAGS_NFCV_FLAG_MANUAL;
pub const RFAL_TXRX_FLAGS_NFCV_FLAG_AUTO: _bindgen_ty_2 = _bindgen_ty_2::RFAL_TXRX_FLAGS_CRC_TX_AUTO;
#[repr(u32)]
#[non_exhaustive]
#[doc = " RFAL transceive flags"]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum _bindgen_ty_2 {
	RFAL_TXRX_FLAGS_CRC_TX_AUTO = 0,
	RFAL_TXRX_FLAGS_CRC_TX_MANUAL = 1,
	RFAL_TXRX_FLAGS_CRC_RX_KEEP = 2,
	RFAL_TXRX_FLAGS_NFCIP1_ON = 4,
	RFAL_TXRX_FLAGS_AGC_OFF = 8,
	RFAL_TXRX_FLAGS_PAR_RX_KEEP = 16,
	RFAL_TXRX_FLAGS_PAR_TX_NONE = 32,
	RFAL_TXRX_FLAGS_NFCV_FLAG_MANUAL = 64,
}
#[repr(u32)]
#[non_exhaustive]
#[doc = " RFAL error handling"]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum rfalEHandling {
	RFAL_ERRORHANDLING_NONE = 0,
	RFAL_ERRORHANDLING_NFC = 1,
	RFAL_ERRORHANDLING_EMVCO = 2,
}
#[doc = " Struct that holds all context to be used on a Transceive"]
#[repr(C)]
pub struct rfalTransceiveContext {
	#[doc = "< (In)  Buffer where outgoing message is located"]
	pub txBuf: *mut u8,
	#[doc = "< (In)  Length of the outgoing message in bits"]
	pub txBufLen: u16,
	#[doc = "< (Out) Buffer where incoming message will be placed"]
	pub rxBuf: *mut u8,
	#[doc = "< (In)  Maximum length of the incoming message in bits"]
	pub rxBufLen: u16,
	#[doc = "< (Out) Actual received length in bits"]
	pub rxRcvdLen: *mut u16,
	#[doc = "< (In)  TransceiveFlags indication special handling"]
	pub flags: u32,
	#[doc = "< (In)  Frame Waiting Time in 1/fc"]
	pub fwt: u32,
}
#[test]
fn bindgen_test_layout_rfalTransceiveContext() {
	assert_eq!(
	           ::core::mem::size_of::<rfalTransceiveContext>(),
	           28usize,
	           concat!("Size of: ", stringify!(rfalTransceiveContext))
	);
	assert_eq!(
	           ::core::mem::align_of::<rfalTransceiveContext>(),
	           4usize,
	           concat!("Alignment of ", stringify!(rfalTransceiveContext))
	);
	fn test_field_txBuf() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalTransceiveContext>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).txBuf) as usize - ptr as usize
		           },
		           0usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalTransceiveContext),
			"::",
			stringify!(txBuf)
		)
		);
	}
	test_field_txBuf();
	fn test_field_txBufLen() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalTransceiveContext>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).txBufLen) as usize - ptr as usize
		           },
		           4usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalTransceiveContext),
			"::",
			stringify!(txBufLen)
		)
		);
	}
	test_field_txBufLen();
	fn test_field_rxBuf() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalTransceiveContext>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).rxBuf) as usize - ptr as usize
		           },
		           8usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalTransceiveContext),
			"::",
			stringify!(rxBuf)
		)
		);
	}
	test_field_rxBuf();
	fn test_field_rxBufLen() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalTransceiveContext>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).rxBufLen) as usize - ptr as usize
		           },
		           12usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalTransceiveContext),
			"::",
			stringify!(rxBufLen)
		)
		);
	}
	test_field_rxBufLen();
	fn test_field_rxRcvdLen() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalTransceiveContext>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).rxRcvdLen) as usize - ptr as usize
		           },
		           16usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalTransceiveContext),
			"::",
			stringify!(rxRcvdLen)
		)
		);
	}
	test_field_rxRcvdLen();
	fn test_field_flags() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalTransceiveContext>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize
		           },
		           20usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalTransceiveContext),
			"::",
			stringify!(flags)
		)
		);
	}
	test_field_flags();
	fn test_field_fwt() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalTransceiveContext>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).fwt) as usize - ptr as usize
		           },
		           24usize,
		           concat!("Offset of field: ", stringify!(rfalTransceiveContext), "::", stringify!(fwt))
		);
	}
	test_field_fwt();
}
#[doc = " System callback to indicate an event that requires a system reRun"]
pub type rfalUpperLayerCallback = ::core::option::Option<unsafe extern "C" fn()>;
#[doc = " Callback to be executed before a Transceive"]
pub type rfalPreTxRxCallback = ::core::option::Option<unsafe extern "C" fn(context: *mut core::ffi::c_void)>;
#[doc = " Callback to be executed after a Transceive"]
pub type rfalPostTxRxCallback = ::core::option::Option<unsafe extern "C" fn(context: *mut core::ffi::c_void)>;
#[doc = " Callback to be executed on each RFAL state change"]
pub type RfalStateChangedCallback = ::core::option::Option<unsafe extern "C" fn(context: *mut core::ffi::c_void)>;
#[repr(u32)]
#[non_exhaustive]
#[doc = " RFAL ISO 14443A Short Frame Command"]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum rfal14443AShortFrameCmd {
	#[doc = "< ISO14443A WUPA / NFC-A ALL_REQ"]
	RFAL_14443A_SHORTFRAME_CMD_WUPA = 82,
	#[doc = "< ISO14443A REQA / NFC-A SENS_REQ"]
	RFAL_14443A_SHORTFRAME_CMD_REQA = 38,
}
pub const RFAL_FELICA_POLL_RC_NO_REQUEST: _bindgen_ty_3 = _bindgen_ty_3::RFAL_FELICA_POLL_RC_NO_REQUEST;
pub const RFAL_FELICA_POLL_RC_SYSTEM_CODE: _bindgen_ty_3 = _bindgen_ty_3::RFAL_FELICA_POLL_RC_SYSTEM_CODE;
pub const RFAL_FELICA_POLL_RC_COM_PERFORMANCE: _bindgen_ty_3 = _bindgen_ty_3::RFAL_FELICA_POLL_RC_COM_PERFORMANCE;
#[repr(u32)]
#[non_exhaustive]
#[doc = " NFC-F RC (Request Code) codes  NFC Forum Digital 1.1 Table 42"]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum _bindgen_ty_3 {
	RFAL_FELICA_POLL_RC_NO_REQUEST = 0,
	RFAL_FELICA_POLL_RC_SYSTEM_CODE = 1,
	RFAL_FELICA_POLL_RC_COM_PERFORMANCE = 2,
}
#[repr(u32)]
#[non_exhaustive]
#[doc = " NFC-F TSN (Time Slot Number) codes  NFC Forum Digital 1.1 Table 43"]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum rfalFeliCaPollSlots {
	#[doc = "< TSN with number of Time Slots: 1"]
	RFAL_FELICA_1_SLOT = 0,
	#[doc = "< TSN with number of Time Slots: 2"]
	RFAL_FELICA_2_SLOTS = 1,
	#[doc = "< TSN with number of Time Slots: 4"]
	RFAL_FELICA_4_SLOTS = 3,
	#[doc = "< TSN with number of Time Slots: 8"]
	RFAL_FELICA_8_SLOTS = 7,
	#[doc = "< TSN with number of Time Slots: 16"]
	RFAL_FELICA_16_SLOTS = 15,
}
#[doc = " NFCF Poll Response  NFC Forum Digital 1.1 Table 44"]
pub type rfalFeliCaPollRes = [u8; 20usize];
#[repr(u32)]
#[non_exhaustive]
#[doc = " RFAL Listen Mode NFCID Length"]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum rfalLmNfcidLen {
	#[doc = "< Listen mode indicates  4 byte NFCID"]
	RFAL_LM_NFCID_LEN_04 = 4,
	#[doc = "< Listen mode indicates  7 byte NFCID"]
	RFAL_LM_NFCID_LEN_07 = 7,
	#[doc = "< Listen mode indicates 10 byte NFCID"]
	RFAL_LM_NFCID_LEN_10 = 10,
}
#[repr(u32)]
#[non_exhaustive]
#[doc = " RFAL Listen Mode States"]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum rfalLmState {
	#[doc = "< Not Initialized state"]
	RFAL_LM_STATE_NOT_INIT = 0,
	#[doc = "< Power Off state"]
	RFAL_LM_STATE_POWER_OFF = 1,
	#[doc = "< Idle state  Activity 1.1  5.2"]
	RFAL_LM_STATE_IDLE = 2,
	#[doc = "< Ready A state  Activity 1.1  5.3 5.4 & 5.5"]
	RFAL_LM_STATE_READY_A = 3,
	#[doc = "< Ready B state  Activity 1.1  5.11 5.12"]
	RFAL_LM_STATE_READY_B = 4,
	#[doc = "< Ready F state  Activity 1.1  5.15"]
	RFAL_LM_STATE_READY_F = 5,
	#[doc = "< Active A state  Activity 1.1  5.6"]
	RFAL_LM_STATE_ACTIVE_A = 6,
	#[doc = "< Card Emulation 4A state  Activity 1.1  5.10"]
	RFAL_LM_STATE_CARDEMU_4A = 7,
	#[doc = "< Card Emulation 4B state  Activity 1.1  5.14"]
	RFAL_LM_STATE_CARDEMU_4B = 8,
	#[doc = "< Card Emulation 3 state  Activity 1.1  5.18"]
	RFAL_LM_STATE_CARDEMU_3 = 9,
	#[doc = "< Target A state  Activity 1.1  5.9"]
	RFAL_LM_STATE_TARGET_A = 10,
	#[doc = "< Target F state  Activity 1.1  5.17"]
	RFAL_LM_STATE_TARGET_F = 11,
	#[doc = "< Sleep A state  Activity 1.1  5.7"]
	RFAL_LM_STATE_SLEEP_A = 12,
	#[doc = "< Sleep B state  Activity 1.1  5.13"]
	RFAL_LM_STATE_SLEEP_B = 13,
	#[doc = "< Ready A* state  Activity 1.1  5.3 5.4 & 5.5"]
	RFAL_LM_STATE_READY_Ax = 14,
	#[doc = "< Active A* state  Activity 1.1  5.6"]
	RFAL_LM_STATE_ACTIVE_Ax = 15,
	#[doc = "< Sleep AF state  Activity 1.1  5.19"]
	RFAL_LM_STATE_SLEEP_AF = 16,
}
#[doc = " RFAL Listen Mode Passive A configs"]
#[repr(C)]
pub struct rfalLmConfPA {
	#[doc = "< NFCID Len (4, 7 or 10 bytes)"]
	pub nfcidLen: rfalLmNfcidLen,
	#[doc = "< NFCID"]
	pub nfcid: [u8; 10usize],
	#[doc = "< NFC-106k; SENS_REQ Response"]
	pub SENS_RES: [u8; 2usize],
	#[doc = "< SEL_RES (SAK) with complete NFCID1 (UID)"]
	pub SEL_RES: u8,
}
#[test]
fn bindgen_test_layout_rfalLmConfPA() {
	assert_eq!(
	           ::core::mem::size_of::<rfalLmConfPA>(),
	           20usize,
	           concat!("Size of: ", stringify!(rfalLmConfPA))
	);
	assert_eq!(
	           ::core::mem::align_of::<rfalLmConfPA>(),
	           4usize,
	           concat!("Alignment of ", stringify!(rfalLmConfPA))
	);
	fn test_field_nfcidLen() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalLmConfPA>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).nfcidLen) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(rfalLmConfPA), "::", stringify!(nfcidLen))
		);
	}
	test_field_nfcidLen();
	fn test_field_nfcid() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalLmConfPA>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).nfcid) as usize - ptr as usize
		           },
		           4usize,
		           concat!("Offset of field: ", stringify!(rfalLmConfPA), "::", stringify!(nfcid))
		);
	}
	test_field_nfcid();
	fn test_field_SENS_RES() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalLmConfPA>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).SENS_RES) as usize - ptr as usize
		           },
		           14usize,
		           concat!("Offset of field: ", stringify!(rfalLmConfPA), "::", stringify!(SENS_RES))
		);
	}
	test_field_SENS_RES();
	fn test_field_SEL_RES() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalLmConfPA>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).SEL_RES) as usize - ptr as usize
		           },
		           16usize,
		           concat!("Offset of field: ", stringify!(rfalLmConfPA), "::", stringify!(SEL_RES))
		);
	}
	test_field_SEL_RES();
}
#[doc = " RFAL Listen Mode Passive B configs"]
#[repr(C)]
pub struct rfalLmConfPB {
	#[doc = "< SENSF_RES"]
	pub SENSB_RES: [u8; 13usize],
}
#[test]
fn bindgen_test_layout_rfalLmConfPB() {
	assert_eq!(
	           ::core::mem::size_of::<rfalLmConfPB>(),
	           13usize,
	           concat!("Size of: ", stringify!(rfalLmConfPB))
	);
	assert_eq!(
	           ::core::mem::align_of::<rfalLmConfPB>(),
	           1usize,
	           concat!("Alignment of ", stringify!(rfalLmConfPB))
	);
	fn test_field_SENSB_RES() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalLmConfPB>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).SENSB_RES) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(rfalLmConfPB), "::", stringify!(SENSB_RES))
		);
	}
	test_field_SENSB_RES();
}
#[doc = " RFAL Listen Mode Passive F configs"]
#[repr(C)]
pub struct rfalLmConfPF {
	#[doc = "< System Code to listen for"]
	pub SC: [u8; 2usize],
	#[doc = "< SENSF_RES"]
	pub SENSF_RES: [u8; 19usize],
}
#[test]
fn bindgen_test_layout_rfalLmConfPF() {
	assert_eq!(
	           ::core::mem::size_of::<rfalLmConfPF>(),
	           21usize,
	           concat!("Size of: ", stringify!(rfalLmConfPF))
	);
	assert_eq!(
	           ::core::mem::align_of::<rfalLmConfPF>(),
	           1usize,
	           concat!("Alignment of ", stringify!(rfalLmConfPF))
	);
	fn test_field_SC() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalLmConfPF>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).SC) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(rfalLmConfPF), "::", stringify!(SC))
		);
	}
	test_field_SC();
	fn test_field_SENSF_RES() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalLmConfPF>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).SENSF_RES) as usize - ptr as usize
		           },
		           2usize,
		           concat!("Offset of field: ", stringify!(rfalLmConfPF), "::", stringify!(SENSF_RES))
		);
	}
	test_field_SENSF_RES();
}
#[repr(u32)]
#[non_exhaustive]
#[doc = " RFAL Wake-Up Mode States"]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum rfalWumState {
	#[doc = "< Not Initialized state"]
	RFAL_WUM_STATE_NOT_INIT = 0,
	#[doc = "< Wake-Up mode is enabled"]
	RFAL_WUM_STATE_ENABLED = 1,
	#[doc = "< Wake-Up mode enabled and has received IRQ(s)"]
	RFAL_WUM_STATE_ENABLED_WOKE = 2,
}
#[repr(u32)]
#[non_exhaustive]
#[doc = " RFAL Wake-Up Period/Timer"]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum rfalWumPeriod {
	#[doc = "< Wake-Up timer 10ms"]
	RFAL_WUM_PERIOD_10MS = 0,
	#[doc = "< Wake-Up timer 20ms"]
	RFAL_WUM_PERIOD_20MS = 1,
	#[doc = "< Wake-Up timer 30ms"]
	RFAL_WUM_PERIOD_30MS = 2,
	#[doc = "< Wake-Up timer 40ms"]
	RFAL_WUM_PERIOD_40MS = 3,
	#[doc = "< Wake-Up timer 50ms"]
	RFAL_WUM_PERIOD_50MS = 4,
	#[doc = "< Wake-Up timer 60ms"]
	RFAL_WUM_PERIOD_60MS = 5,
	#[doc = "< Wake-Up timer 70ms"]
	RFAL_WUM_PERIOD_70MS = 6,
	#[doc = "< Wake-Up timer 80ms"]
	RFAL_WUM_PERIOD_80MS = 7,
	#[doc = "< Wake-Up timer 100ms"]
	RFAL_WUM_PERIOD_100MS = 16,
	#[doc = "< Wake-Up timer 200ms"]
	RFAL_WUM_PERIOD_200MS = 17,
	#[doc = "< Wake-Up timer 300ms"]
	RFAL_WUM_PERIOD_300MS = 18,
	#[doc = "< Wake-Up timer 400ms"]
	RFAL_WUM_PERIOD_400MS = 19,
	#[doc = "< Wake-Up timer 500ms"]
	RFAL_WUM_PERIOD_500MS = 20,
	#[doc = "< Wake-Up timer 600ms"]
	RFAL_WUM_PERIOD_600MS = 21,
	#[doc = "< Wake-Up timer 700ms"]
	RFAL_WUM_PERIOD_700MS = 22,
	#[doc = "< Wake-Up timer 800ms"]
	RFAL_WUM_PERIOD_800MS = 23,
}
#[repr(u32)]
#[non_exhaustive]
#[doc = " RFAL Wake-Up Period/Timer"]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum rfalWumAAWeight {
	#[doc = "< Wake-Up Auto Average Weight 4"]
	RFAL_WUM_AA_WEIGHT_4 = 0,
	#[doc = "< Wake-Up Auto Average Weight 8"]
	RFAL_WUM_AA_WEIGHT_8 = 1,
	#[doc = "< Wake-Up Auto Average Weight 16"]
	RFAL_WUM_AA_WEIGHT_16 = 2,
	#[doc = "< Wake-Up Auto Average Weight 32"]
	RFAL_WUM_AA_WEIGHT_32 = 3,
}
#[doc = " RFAL Wake-Up Mode configuration"]
#[repr(C)]
pub struct rfalWakeUpConfig {
	#[doc = "< Wake-Up Timer period;how often measurement(s) is performed"]
	pub period: rfalWumPeriod,
	#[doc = "< IRQ at every timeout will refresh the measurement(s)"]
	pub irqTout: bool,
	#[doc = "< Use SW Tag Detection instead of HW Wake-Up mode"]
	pub swTagDetect: bool,
	#[doc = "< Inductive Amplitude Configuration"]
	pub indAmp: rfalWakeUpConfig__bindgen_ty_1,
	#[doc = "< Inductive Phase Configuration"]
	pub indPha: rfalWakeUpConfig__bindgen_ty_2,
	#[doc = "< Capacitive Configuration"]
	pub cap: rfalWakeUpConfig__bindgen_ty_3,
}
#[repr(C)]
pub struct rfalWakeUpConfig__bindgen_ty_1 {
	#[doc = "< Inductive Amplitude measurement enabled"]
	pub enabled: bool,
	#[doc = "< Delta between the reference and measurement to wake-up"]
	pub delta: u8,
	#[doc = "< Reference to be used;RFAL_WUM_REFERENCE_AUTO sets it auto"]
	pub reference: u16,
	#[doc = "< Use the HW Auto Averaging feature"]
	pub autoAvg: bool,
	#[doc = "< When AutoAvg is enabled, include IRQ measurement"]
	pub aaInclMeas: bool,
	#[doc = "< When AutoAvg is enabled, last measure weight"]
	pub aaWeight: rfalWumAAWeight,
}
#[test]
fn bindgen_test_layout_rfalWakeUpConfig__bindgen_ty_1() {
	assert_eq!(
	           ::core::mem::size_of::<rfalWakeUpConfig__bindgen_ty_1>(),
	           12usize,
	           concat!("Size of: ", stringify!(rfalWakeUpConfig__bindgen_ty_1))
	);
	assert_eq!(
	           ::core::mem::align_of::<rfalWakeUpConfig__bindgen_ty_1>(),
	           4usize,
	           concat!("Alignment of ", stringify!(rfalWakeUpConfig__bindgen_ty_1))
	);
	fn test_field_enabled() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalWakeUpConfig__bindgen_ty_1>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).enabled) as usize - ptr as usize
		           },
		           0usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalWakeUpConfig__bindgen_ty_1),
			"::",
			stringify!(enabled)
		)
		);
	}
	test_field_enabled();
	fn test_field_delta() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalWakeUpConfig__bindgen_ty_1>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).delta) as usize - ptr as usize
		           },
		           1usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalWakeUpConfig__bindgen_ty_1),
			"::",
			stringify!(delta)
		)
		);
	}
	test_field_delta();
	fn test_field_reference() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalWakeUpConfig__bindgen_ty_1>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).reference) as usize - ptr as usize
		           },
		           2usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalWakeUpConfig__bindgen_ty_1),
			"::",
			stringify!(reference)
		)
		);
	}
	test_field_reference();
	fn test_field_autoAvg() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalWakeUpConfig__bindgen_ty_1>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).autoAvg) as usize - ptr as usize
		           },
		           4usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalWakeUpConfig__bindgen_ty_1),
			"::",
			stringify!(autoAvg)
		)
		);
	}
	test_field_autoAvg();
	fn test_field_aaInclMeas() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalWakeUpConfig__bindgen_ty_1>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).aaInclMeas) as usize - ptr as usize
		           },
		           5usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalWakeUpConfig__bindgen_ty_1),
			"::",
			stringify!(aaInclMeas)
		)
		);
	}
	test_field_aaInclMeas();
	fn test_field_aaWeight() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalWakeUpConfig__bindgen_ty_1>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).aaWeight) as usize - ptr as usize
		           },
		           8usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalWakeUpConfig__bindgen_ty_1),
			"::",
			stringify!(aaWeight)
		)
		);
	}
	test_field_aaWeight();
}
#[repr(C)]
pub struct rfalWakeUpConfig__bindgen_ty_2 {
	#[doc = "< Inductive Phase measurement enabled"]
	pub enabled: bool,
	#[doc = "< Delta between the reference and measurement to wake-up"]
	pub delta: u8,
	#[doc = "< Reference to be used;RFAL_WUM_REFERENCE_AUTO sets it auto"]
	pub reference: u16,
	#[doc = "< Use the HW Auto Averaging feature"]
	pub autoAvg: bool,
	#[doc = "< When AutoAvg is enabled, include IRQ measurement"]
	pub aaInclMeas: bool,
	#[doc = "< When AutoAvg is enabled, last measure weight"]
	pub aaWeight: rfalWumAAWeight,
}
#[test]
fn bindgen_test_layout_rfalWakeUpConfig__bindgen_ty_2() {
	assert_eq!(
	           ::core::mem::size_of::<rfalWakeUpConfig__bindgen_ty_2>(),
	           12usize,
	           concat!("Size of: ", stringify!(rfalWakeUpConfig__bindgen_ty_2))
	);
	assert_eq!(
	           ::core::mem::align_of::<rfalWakeUpConfig__bindgen_ty_2>(),
	           4usize,
	           concat!("Alignment of ", stringify!(rfalWakeUpConfig__bindgen_ty_2))
	);
	fn test_field_enabled() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalWakeUpConfig__bindgen_ty_2>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).enabled) as usize - ptr as usize
		           },
		           0usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalWakeUpConfig__bindgen_ty_2),
			"::",
			stringify!(enabled)
		)
		);
	}
	test_field_enabled();
	fn test_field_delta() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalWakeUpConfig__bindgen_ty_2>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).delta) as usize - ptr as usize
		           },
		           1usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalWakeUpConfig__bindgen_ty_2),
			"::",
			stringify!(delta)
		)
		);
	}
	test_field_delta();
	fn test_field_reference() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalWakeUpConfig__bindgen_ty_2>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).reference) as usize - ptr as usize
		           },
		           2usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalWakeUpConfig__bindgen_ty_2),
			"::",
			stringify!(reference)
		)
		);
	}
	test_field_reference();
	fn test_field_autoAvg() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalWakeUpConfig__bindgen_ty_2>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).autoAvg) as usize - ptr as usize
		           },
		           4usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalWakeUpConfig__bindgen_ty_2),
			"::",
			stringify!(autoAvg)
		)
		);
	}
	test_field_autoAvg();
	fn test_field_aaInclMeas() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalWakeUpConfig__bindgen_ty_2>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).aaInclMeas) as usize - ptr as usize
		           },
		           5usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalWakeUpConfig__bindgen_ty_2),
			"::",
			stringify!(aaInclMeas)
		)
		);
	}
	test_field_aaInclMeas();
	fn test_field_aaWeight() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalWakeUpConfig__bindgen_ty_2>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).aaWeight) as usize - ptr as usize
		           },
		           8usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalWakeUpConfig__bindgen_ty_2),
			"::",
			stringify!(aaWeight)
		)
		);
	}
	test_field_aaWeight();
}
#[repr(C)]
pub struct rfalWakeUpConfig__bindgen_ty_3 {
	#[doc = "< Capacitive measurement enabled"]
	pub enabled: bool,
	#[doc = "< Delta between the reference and measurement to wake-up"]
	pub delta: u8,
	#[doc = "< Reference to be used;RFAL_WUM_REFERENCE_AUTO sets it auto"]
	pub reference: u16,
	#[doc = "< Use the HW Auto Averaging feature"]
	pub autoAvg: bool,
	#[doc = "< When AutoAvg is enabled, include IRQ measurement"]
	pub aaInclMeas: bool,
	#[doc = "< When AutoAvg is enabled, last measure weight"]
	pub aaWeight: rfalWumAAWeight,
}
#[test]
fn bindgen_test_layout_rfalWakeUpConfig__bindgen_ty_3() {
	assert_eq!(
	           ::core::mem::size_of::<rfalWakeUpConfig__bindgen_ty_3>(),
	           12usize,
	           concat!("Size of: ", stringify!(rfalWakeUpConfig__bindgen_ty_3))
	);
	assert_eq!(
	           ::core::mem::align_of::<rfalWakeUpConfig__bindgen_ty_3>(),
	           4usize,
	           concat!("Alignment of ", stringify!(rfalWakeUpConfig__bindgen_ty_3))
	);
	fn test_field_enabled() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalWakeUpConfig__bindgen_ty_3>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).enabled) as usize - ptr as usize
		           },
		           0usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalWakeUpConfig__bindgen_ty_3),
			"::",
			stringify!(enabled)
		)
		);
	}
	test_field_enabled();
	fn test_field_delta() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalWakeUpConfig__bindgen_ty_3>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).delta) as usize - ptr as usize
		           },
		           1usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalWakeUpConfig__bindgen_ty_3),
			"::",
			stringify!(delta)
		)
		);
	}
	test_field_delta();
	fn test_field_reference() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalWakeUpConfig__bindgen_ty_3>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).reference) as usize - ptr as usize
		           },
		           2usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalWakeUpConfig__bindgen_ty_3),
			"::",
			stringify!(reference)
		)
		);
	}
	test_field_reference();
	fn test_field_autoAvg() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalWakeUpConfig__bindgen_ty_3>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).autoAvg) as usize - ptr as usize
		           },
		           4usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalWakeUpConfig__bindgen_ty_3),
			"::",
			stringify!(autoAvg)
		)
		);
	}
	test_field_autoAvg();
	fn test_field_aaInclMeas() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalWakeUpConfig__bindgen_ty_3>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).aaInclMeas) as usize - ptr as usize
		           },
		           5usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalWakeUpConfig__bindgen_ty_3),
			"::",
			stringify!(aaInclMeas)
		)
		);
	}
	test_field_aaInclMeas();
	fn test_field_aaWeight() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalWakeUpConfig__bindgen_ty_3>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).aaWeight) as usize - ptr as usize
		           },
		           8usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalWakeUpConfig__bindgen_ty_3),
			"::",
			stringify!(aaWeight)
		)
		);
	}
	test_field_aaWeight();
}
#[test]
fn bindgen_test_layout_rfalWakeUpConfig() {
	assert_eq!(
	           ::core::mem::size_of::<rfalWakeUpConfig>(),
	           44usize,
	           concat!("Size of: ", stringify!(rfalWakeUpConfig))
	);
	assert_eq!(
	           ::core::mem::align_of::<rfalWakeUpConfig>(),
	           4usize,
	           concat!("Alignment of ", stringify!(rfalWakeUpConfig))
	);
	fn test_field_period() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalWakeUpConfig>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).period) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(rfalWakeUpConfig), "::", stringify!(period))
		);
	}
	test_field_period();
	fn test_field_irqTout() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalWakeUpConfig>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).irqTout) as usize - ptr as usize
		           },
		           4usize,
		           concat!("Offset of field: ", stringify!(rfalWakeUpConfig), "::", stringify!(irqTout))
		);
	}
	test_field_irqTout();
	fn test_field_swTagDetect() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalWakeUpConfig>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).swTagDetect) as usize - ptr as usize
		           },
		           5usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalWakeUpConfig),
			"::",
			stringify!(swTagDetect)
		)
		);
	}
	test_field_swTagDetect();
	fn test_field_indAmp() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalWakeUpConfig>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).indAmp) as usize - ptr as usize
		           },
		           8usize,
		           concat!("Offset of field: ", stringify!(rfalWakeUpConfig), "::", stringify!(indAmp))
		);
	}
	test_field_indAmp();
	fn test_field_indPha() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalWakeUpConfig>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).indPha) as usize - ptr as usize
		           },
		           20usize,
		           concat!("Offset of field: ", stringify!(rfalWakeUpConfig), "::", stringify!(indPha))
		);
	}
	test_field_indPha();
	fn test_field_cap() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalWakeUpConfig>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).cap) as usize - ptr as usize
		           },
		           32usize,
		           concat!("Offset of field: ", stringify!(rfalWakeUpConfig), "::", stringify!(cap))
		);
	}
	test_field_cap();
}
extern "C" {
	#[doc = " \\brief  RFAL Initialize"]
	#[doc = ""]
	#[doc = " Initializes RFAL layer and the ST25R391x"]
	#[doc = " Ensures that ST25R391x is properly connected and returns error if any problem"]
	#[doc = " is detected"]
	#[doc = ""]
	#[doc = " \\warning rfalAnalogConfigInitialize() should be called before so that"]
	#[doc = "           the Analog config table has been previously initialized."]
	#[doc = ""]
	#[doc = " \\return ERR_HW_MISMATCH  : Expected HW do not match or communication error"]
	#[doc = " \\return ERR_NONE         : No error"]
	#[doc = ""]
	pub fn rfalInitialize() -> ReturnCode;
}
extern "C" {
	#[doc = " \\brief  RFAL Calibrate"]
	#[doc = ""]
	#[doc = " Performs necessary calibration of RF chip in case it is indicated by current"]
	#[doc = " register settings. E.g. antenna calibration and regulator calibration"]
	#[doc = ""]
	#[doc = " \\return ERR_WRONG_STATE  : RFAL not initialized"]
	#[doc = " \\return ERR_NONE         : No error"]
	#[doc = ""]
	#[doc = ""]
	pub fn rfalCalibrate() -> ReturnCode;
}
extern "C" {
	#[doc = " \\brief  RFAL Adjust Regulators"]
	#[doc = ""]
	#[doc = " Adjusts ST25R391x regulators"]
	#[doc = ""]
	#[doc = " \\param[out]  result : the result of the calibrate antenna in mV"]
	#[doc = "                       NULL if result not requested"]
	#[doc = ""]
	#[doc = " \\return ERR_WRONG_STATE  : RFAL not initialized"]
	#[doc = " \\return ERR_NONE         : No error"]
	#[doc = ""]
	#[doc = ""]
	pub fn rfalAdjustRegulators(result: *mut u16) -> ReturnCode;
}
extern "C" {
	#[doc = " \\brief RFAL Set System Callback"]
	#[doc = ""]
	#[doc = " Sets a callback for the driver to call when an event has occurred that"]
	#[doc = " may require the system to be notified"]
	#[doc = ""]
	#[doc = " \\param[in]  pFunc : method pointer for the upper layer callback"]
	#[doc = ""]
	#[doc = ""]
	pub fn rfalSetUpperLayerCallback(pFunc: rfalUpperLayerCallback);
}
extern "C" {
	#[doc = " \\brief RFAL Set Pre Tx Callback"]
	#[doc = ""]
	#[doc = " Sets a callback for the driver to call before a Transceive"]
	#[doc = ""]
	#[doc = " \\param[in]  pFunc : method pointer for the Pre Tx callback"]
	#[doc = ""]
	#[doc = ""]
	pub fn rfalSetPreTxRxCallback(pFunc: rfalPreTxRxCallback);
}
extern "C" {
	#[doc = " \\brief RFAL Set Post Tx Callback"]
	#[doc = ""]
	#[doc = " Sets a callback for the driver to call after a Transceive"]
	#[doc = ""]
	#[doc = " \\param[in]  pFunc : method pointer for the Post Tx callback"]
	#[doc = ""]
	#[doc = ""]
	pub fn rfalSetPostTxRxCallback(pFunc: rfalPostTxRxCallback);
}
extern "C" {
	#[doc = " Set RFAL state changed callback"]
	#[doc = ""]
	#[doc = " @param cb    RfalStateChangedCallback instance"]
	#[doc = " @param ctx   pointer to context"]
	pub fn rfal_set_state_changed_callback(callback: RfalStateChangedCallback);
}
extern "C" {
	#[doc = " Set callback context"]
	#[doc = ""]
	#[doc = " @param ctx pointer to context"]
	pub fn rfal_set_callback_context(context: *mut core::ffi::c_void);
}
extern "C" {
	#[doc = " \\brief  RFAL Deinitialize"]
	#[doc = ""]
	#[doc = " Deinitializes RFAL layer and the ST25R391x"]
	#[doc = ""]
	#[doc = " \\return ERR_NONE : No error"]
	#[doc = ""]
	#[doc = ""]
	pub fn rfalDeinitialize() -> ReturnCode;
}
extern "C" {
	#[doc = " \\brief  RFAL Set Mode"]
	#[doc = ""]
	#[doc = " Sets the mode that RFAL will operate on the following communications."]
	#[doc = " Proper initializations will be performed on the ST25R391x"]
	#[doc = ""]
	#[doc = " \\warning bit rate value RFAL_BR_KEEP is not allowed, only in rfalSetBitRate()"]
	#[doc = ""]
	#[doc = " \\warning the mode will be applied immediately on the RFchip regardless of"]
	#[doc = "          any ongoing operations like Transceive, ListenMode"]
	#[doc = ""]
	#[doc = " \\param[in]  mode : mode for the RFAL/RFchip to perform"]
	#[doc = " \\param[in]  txBR : transmit bit rate"]
	#[doc = " \\param[in]  rxBR : receive bit rate"]
	#[doc = ""]
	#[doc = " \\see rfalIsGTExpired"]
	#[doc = " \\see rfalMode"]
	#[doc = ""]
	#[doc = " \\return ERR_WRONG_STATE  : RFAL not initialized"]
	#[doc = " \\return ERR_PARAM        : Invalid parameter"]
	#[doc = " \\return ERR_NONE         : No error"]
	#[doc = ""]
	#[doc = ""]
	pub fn rfalSetMode(mode: rfalMode, txBR: rfalBitRate, rxBR: rfalBitRate) -> ReturnCode;
}
extern "C" {
	#[doc = " \\brief  RFAL Get Mode"]
	#[doc = ""]
	#[doc = " Gets the mode that RFAL is set to operate"]
	#[doc = ""]
	#[doc = " \\see rfalMode"]
	#[doc = ""]
	#[doc = " \\return rfalMode : The current RFAL mode"]
	#[doc = ""]
	pub fn rfalGetMode() -> rfalMode;
}
extern "C" {
	#[doc = " \\brief  RFAL Set Bit Rate"]
	#[doc = ""]
	#[doc = " Sets the Tx and Rx bit rates with the given values"]
	#[doc = " The bit rate change is applied on the RF chip remaining in the same"]
	#[doc = " mode previous defined with rfalSetMode()"]
	#[doc = ""]
	#[doc = " If no mode is defined bit rates will not be applied and an error"]
	#[doc = " is returned"]
	#[doc = ""]
	#[doc = " \\param[in]  txBR : transmit bit rate"]
	#[doc = " \\param[in]  rxBR : receive bit rate"]
	#[doc = ""]
	#[doc = " \\see rfalSetMode"]
	#[doc = " \\see rfalMode"]
	#[doc = " \\see rfalBitRate"]
	#[doc = ""]
	#[doc = " \\return ERR_WRONG_STATE     : RFAL not initialized"]
	#[doc = " \\return ERR_PARAM           : Invalid parameter"]
	#[doc = " \\return ERR_NOT_IMPLEMENTED : Mode not implemented"]
	#[doc = " \\return ERR_NONE            : No error"]
	#[doc = ""]
	#[doc = ""]
	pub fn rfalSetBitRate(txBR: rfalBitRate, rxBR: rfalBitRate) -> ReturnCode;
}
extern "C" {
	#[doc = " \\brief  RFAL Get Bit Rate"]
	#[doc = ""]
	#[doc = " Gets the Tx and Rx current bit rates"]
	#[doc = ""]
	#[doc = " If RFAL is not initialized or mode not set the bit rates return will"]
	#[doc = " be invalid RFAL_BR_KEEP"]
	#[doc = ""]
	#[doc = " \\param[out]  txBR : RFAL's current Tx Bit Rate"]
	#[doc = " \\param[out]  rxBR : RFAL's current Rx Bit Rate"]
	#[doc = ""]
	#[doc = " \\see rfalSetBitRate"]
	#[doc = " \\see rfalBitRate"]
	#[doc = ""]
	#[doc = " \\return ERR_WRONG_STATE  : RFAL not initialized or mode not set"]
	#[doc = " \\return ERR_NONE         : No error"]
	#[doc = ""]
	pub fn rfalGetBitRate(txBR: *mut rfalBitRate, rxBR: *mut rfalBitRate) -> ReturnCode;
}
extern "C" {
	#[doc = " \\brief Set Error Handling Mode"]
	#[doc = ""]
	#[doc = "  Sets the error handling mode to be used by the RFAL"]
	#[doc = ""]
	#[doc = " \\param[in]  eHandling : the error handling mode"]
	#[doc = ""]
	#[doc = ""]
	pub fn rfalSetErrorHandling(eHandling: rfalEHandling);
}
extern "C" {
	#[doc = " \\brief Get Error Handling Mode"]
	#[doc = ""]
	#[doc = "  Gets the error handling mode currently used by the RFAL"]
	#[doc = ""]
	#[doc = " \\return rfalEHandling : Current error handling mode"]
	#[doc = ""]
	pub fn rfalGetErrorHandling() -> rfalEHandling;
}
extern "C" {
	#[doc = " \\brief Set Observation Mode"]
	#[doc = ""]
	#[doc = " Sets ST25R391x observation modes for RF debug purposes"]
	#[doc = ""]
	#[doc = " \\param[in]  txMode : the observation mode to be used during transmission"]
	#[doc = " \\param[in]  rxMode : the observation mode to be used during reception"]
	#[doc = ""]
	#[doc = " \\warning The Observation Mode is an advanced feature and should be set"]
	#[doc = "          according to the documentation of the part number in use."]
	#[doc = "          Please refer to the corresponding Datasheet or Application Note(s)"]
	#[doc = ""]
	pub fn rfalSetObsvMode(txMode: u8, rxMode: u8);
}
extern "C" {
	#[doc = " \\brief Get Observation Mode"]
	#[doc = ""]
	#[doc = " Gets ST25R391x the current configured observation modes"]
	#[doc = ""]
	#[doc = " \\param[in]  txMode : the current observation mode configured for transmission"]
	#[doc = " \\param[in]  rxMode : the current observation mode configured for reception"]
	#[doc = ""]
	#[doc = ""]
	pub fn rfalGetObsvMode(txMode: *mut u8, rxMode: *mut u8);
}
extern "C" {
	#[doc = " \\brief Disable Observation Mode"]
	#[doc = ""]
	#[doc = " Disables the ST25R391x observation mode"]
	#[doc = ""]
	pub fn rfalDisableObsvMode();
}
extern "C" {
	#[doc = " \\brief  RFAL Set FDT Poll"]
	#[doc = ""]
	#[doc = " Sets the Frame Delay Time (FDT) to be used on the following"]
	#[doc = " communications."]
	#[doc = ""]
	#[doc = " FDT Poll is the minimum time following a Poll Frame during"]
	#[doc = " which no subsequent Poll Frame can be sent (without a response from"]
	#[doc = " the Listener in between)"]
	#[doc = " FDTx,PP,MIN - Digital 1.1  6.10.2  &  7.9.2  &  8.7.2"]
	#[doc = ""]
	#[doc = " \\param[in]  FDTPoll : Frame Delay Time in 1/fc cycles"]
	#[doc = ""]
	#[doc = ""]
	pub fn rfalSetFDTPoll(FDTPoll: u32);
}
extern "C" {
	#[doc = " \\brief  RFAL Set FDT Poll"]
	#[doc = ""]
	#[doc = " Gets the current Frame Delay Time (FDT)"]
	#[doc = ""]
	#[doc = " FDT Poll is the minimum time following a Poll Frame during"]
	#[doc = " which no subsequent Poll Frame can be sent (without a response from"]
	#[doc = " the Listener in between)"]
	#[doc = " FDTx,PP,MIN - Digital 1.1  6.10.2  &  7.9.2  &  8.7.2"]
	#[doc = ""]
	#[doc = " \\return FDT : current FDT value in 1/fc cycles"]
	#[doc = ""]
	#[doc = ""]
	pub fn rfalGetFDTPoll() -> u32;
}
extern "C" {
	#[doc = " \\brief  RFAL Set FDT Listen"]
	#[doc = ""]
	#[doc = " Sets the Frame Delay Time (FDT) Listen minimum to be used on the"]
	#[doc = " following communications."]
	#[doc = ""]
	#[doc = " FDT Listen is the minimum time between a Poll Frame and a Listen Frame"]
	#[doc = " FDTx,LISTEN,MIN - Digital 1.1  6.10.1  &  7.9.1  &  8.7.1"]
	#[doc = ""]
	#[doc = " \\param[in]  FDTListen : Frame Delay Time in 1/fc cycles"]
	#[doc = ""]
	#[doc = ""]
	pub fn rfalSetFDTListen(FDTListen: u32);
}
extern "C" {
	#[doc = " \\brief  RFAL Set FDT Listen"]
	#[doc = ""]
	#[doc = " Gets the Frame Delay Time (FDT) Listen minimum"]
	#[doc = ""]
	#[doc = " FDT Listen is the minimum time between a Poll Frame and a Listen Frame"]
	#[doc = " FDTx,LISTEN,MIN - Digital 1.1  6.10.1  &  7.9.1  &  8.7.1"]
	#[doc = ""]
	#[doc = " \\return FDT : current FDT value in 1/fc cycles"]
	#[doc = ""]
	#[doc = ""]
	pub fn rfalGetFDTListen() -> u32;
}
extern "C" {
	#[doc = " \\brief  RFAL Get GT"]
	#[doc = ""]
	#[doc = " Gets the current Guard Time (GT)"]
	#[doc = ""]
	#[doc = " GT is the minimum time when a device in Listen Mode is exposed to an"]
	#[doc = " unmodulated carrier"]
	#[doc = ""]
	#[doc = " \\return GT :  Guard Time in 1/fc cycles"]
	#[doc = ""]
	#[doc = ""]
	pub fn rfalGetGT() -> u32;
}
extern "C" {
	#[doc = " \\brief  RFAL Set GT"]
	#[doc = ""]
	#[doc = " Sets the Guard Time (GT) to be used on the following communications."]
	#[doc = ""]
	#[doc = " GT is the minimum time when a device in Listen Mode is exposed to an"]
	#[doc = " unmodulated carrier"]
	#[doc = ""]
	#[doc = " \\param[in]  GT : Guard Time in 1/fc cycles"]
	#[doc = "                  RFAL_GT_NONE if no GT should be applied"]
	#[doc = ""]
	#[doc = ""]
	pub fn rfalSetGT(GT: u32);
}
extern "C" {
	#[doc = " \\brief  RFAL Is GT expired"]
	#[doc = ""]
	#[doc = " Checks whether the GT timer has expired"]
	#[doc = ""]
	#[doc = " \\return true  : GT has expired or not running"]
	#[doc = " \\return false : GT is still running"]
	#[doc = ""]
	#[doc = ""]
	pub fn rfalIsGTExpired() -> bool;
}
extern "C" {
	#[doc = " \\brief  RFAL Turn Field On and Start GT"]
	#[doc = ""]
	#[doc = " Turns the Field On, performing Initial Collision Avoidance"]
	#[doc = ""]
	#[doc = " After Field On, if GT was set before, it starts the GT timer to be"]
	#[doc = " used on the following communications."]
	#[doc = ""]
	#[doc = " \\return ERR_RF_COLLISION : External field detected"]
	#[doc = " \\return ERR_NONE         : Field turned On"]
	#[doc = ""]
	#[doc = ""]
	pub fn rfalFieldOnAndStartGT() -> ReturnCode;
}
extern "C" {
	#[doc = " \\brief  RFAL Turn Field Off"]
	#[doc = ""]
	#[doc = " Turns the Field Off"]
	#[doc = ""]
	#[doc = " \\return ERR_NONE : Field turned Off"]
	#[doc = ""]
	pub fn rfalFieldOff() -> ReturnCode;
}
extern "C" {
	#[doc = " \\brief  RFAL Set transceive context"]
	#[doc = ""]
	#[doc = " Set the context that will be used for the following Transceive"]
	#[doc = " Output and input buffers have to be passed and all other details prior to"]
	#[doc = " the Transceive itself has been started"]
	#[doc = ""]
	#[doc = " This method only sets the context, once set rfalWorker has"]
	#[doc = " to be executed until is done"]
	#[doc = ""]
	#[doc = " \\param[in]  ctx : the context for the following Transceive"]
	#[doc = ""]
	#[doc = " \\see  rfalWorker"]
	#[doc = " \\see  rfalGetTransceiveStatus"]
	#[doc = ""]
	#[doc = " \\return ERR_NONE        : Done with no error"]
	#[doc = " \\return ERR_WRONG_STATE : Not initialized properly"]
	#[doc = " \\return ERR_PARAM       : Invalid parameter or configuration"]
	#[doc = ""]
	pub fn rfalStartTransceive(ctx: *const rfalTransceiveContext) -> ReturnCode;
}
extern "C" {
	#[doc = " \\brief  Get Transceive State"]
	#[doc = ""]
	#[doc = " Gets current Transceive internal State"]
	#[doc = ""]
	#[doc = " \\return rfalTransceiveState : the current Transceive internal State"]
	#[doc = ""]
	pub fn rfalGetTransceiveState() -> rfalTransceiveState;
}
extern "C" {
	#[doc = " \\brief  Get Transceive Status"]
	#[doc = ""]
	#[doc = " Gets current Transceive status"]
	#[doc = ""]
	#[doc = " \\return  ERR_NONE         : Transceive done with no error"]
	#[doc = " \\return  ERR_BUSY         : Transceive ongoing"]
	#[doc = " \\return  ERR_XXXX         : Error occurred"]
	#[doc = " \\return  ERR_TIMEOUT      : No response"]
	#[doc = " \\return  ERR_FRAMING      : Framing error detected"]
	#[doc = " \\return  ERR_PAR          : Parity error detected"]
	#[doc = " \\return  ERR_CRC          : CRC error detected"]
	#[doc = " \\return  ERR_LINK_LOSS    : Link Loss - External Field is Off"]
	#[doc = " \\return  ERR_RF_COLLISION : Collision detected"]
	#[doc = " \\return  ERR_IO           : Internal error"]
	#[doc = ""]
	pub fn rfalGetTransceiveStatus() -> ReturnCode;
}
extern "C" {
	#[doc = " \\brief  Is Transceive in Tx"]
	#[doc = ""]
	#[doc = " Checks if Transceive is in Transmission state"]
	#[doc = ""]
	#[doc = " \\return true   Transmission ongoing"]
	#[doc = " \\return false  Not in transmission state"]
	#[doc = ""]
	pub fn rfalIsTransceiveInTx() -> bool;
}
extern "C" {
	#[doc = " \\brief  Is Transceive in Rx"]
	#[doc = ""]
	#[doc = " Checks if Transceive is in Reception state"]
	#[doc = ""]
	#[doc = " \\return true   Transmission done/reception ongoing"]
	#[doc = " \\return false  Not in reception state"]
	#[doc = ""]
	pub fn rfalIsTransceiveInRx() -> bool;
}
extern "C" {
	#[doc = " \\brief  Get Transceive RSSI"]
	#[doc = ""]
	#[doc = " Gets the RSSI value of the last executed Transceive in mV"]
	#[doc = ""]
	#[doc = " \\param[out]  rssi : RSSI value"]
	#[doc = ""]
	#[doc = " \\return  ERR_NOTSUPP : Feature not supported"]
	#[doc = " \\return  ERR_PARAM   : Invalid parameter"]
	#[doc = " \\return  ERR_NONE    : No error"]
	#[doc = ""]
	pub fn rfalGetTransceiveRSSI(rssi: *mut u16) -> ReturnCode;
}
extern "C" {
	#[doc = "  \\brief RFAL Worker"]
	#[doc = ""]
	#[doc = "  This runs RFAL layer, which drives the actual Transceive procedure"]
	#[doc = "  It MUST be executed frequently in order to execute the RFAL internal"]
	#[doc = "  states and perform the requested operations"]
	#[doc = ""]
	#[doc = ""]
	pub fn rfalWorker();
}
extern "C" {
	#[doc = "  \\brief Transceives an ISO14443A ShortFrame"]
	#[doc = ""]
	#[doc = "  Sends REQA to detect if there is any PICC in the field"]
	#[doc = ""]
	#[doc = " \\param[in]  txCmd:     Command to be sent:"]
	#[doc = "                           0x52 WUPA / ALL_REQ"]
	#[doc = "                           0x26 REQA / SENS_REQ"]
	#[doc = ""]
	#[doc = " \\param[in]  txCmd    : type of short frame to be sent REQA or WUPA"]
	#[doc = " \\param[out] rxBuf    : buffer to place the response"]
	#[doc = " \\param[in]  rxBufLen : length of rxBuf"]
	#[doc = " \\param[out] rxRcvdLen: received length"]
	#[doc = " \\param[in]  fwt      : Frame Waiting Time in 1/fc"]
	#[doc = ""]
	#[doc = " \\warning If fwt is set to RFAL_FWT_NONE it will make endlessly for"]
	#[doc = "         a response, which on a blocking method may not be the"]
	#[doc = "         desired usage"]
	#[doc = ""]
	#[doc = " \\return ERR_NONE if there is response"]
	#[doc = " \\return ERR_TIMEOUT if there is no response"]
	#[doc = " \\return ERR_COLLISION collision has occurred"]
	#[doc = ""]
	#[doc = ""]
	pub fn rfalISO14443ATransceiveShortFrame(txCmd: rfal14443AShortFrameCmd,
	                                         rxBuf: *mut u8,
	                                         rxBufLen: u8,
	                                         rxRcvdLen: *mut u16,
	                                         fwt: u32)
	                                         -> ReturnCode;
}
extern "C" {
	#[doc = " \\brief Sends an ISO14443A Anticollision Frame"]
	#[doc = ""]
	#[doc = " This is use to perform ISO14443A anti-collision."]
	#[doc = " \\note Anticollision is sent without CRC"]
	#[doc = ""]
	#[doc = ""]
	#[doc = " \\param[in]   buf        : reference to ANTICOLLISION command (with known UID if any) to be sent (also out param)"]
	#[doc = "                           reception will be place on this buf after bytesToSend"]
	#[doc = " \\param[in]   bytesToSend: reference number of full bytes to be sent (including CMD byte and SEL_PAR)"]
	#[doc = "                           if a collision occurs will contain the number of clear bytes"]
	#[doc = " \\param[in]   bitsToSend : reference to number of bits (0-7) to be sent; and received (also out param)"]
	#[doc = "                           if a collision occurs will indicate the number of clear bits (also out param)"]
	#[doc = " \\param[out]  rxLength   : reference to the return the received length"]
	#[doc = " \\param[in]   fwt        : Frame Waiting Time in 1/fc"]
	#[doc = ""]
	#[doc = " \\return ERR_NONE if there is no error"]
	#[doc = ""]
	pub fn rfalISO14443ATransceiveAnticollisionFrame(buf: *mut u8,
	                                                 bytesToSend: *mut u8,
	                                                 bitsToSend: *mut u8,
	                                                 rxLength: *mut u16,
	                                                 fwt: u32)
	                                                 -> ReturnCode;
}
extern "C" {
	#[doc = " \\brief FeliCa Poll"]
	#[doc = ""]
	#[doc = " Sends a Poll Request and collects all Poll Responses according to the"]
	#[doc = " given slots"]
	#[doc = ""]
	#[doc = ""]
	#[doc = " \\param[in]   slots             : number of slots for the Poll Request"]
	#[doc = " \\param[in]   sysCode           : system code (SC) for the Poll Request"]
	#[doc = " \\param[in]   reqCode           : request code (RC) for the Poll Request"]
	#[doc = " \\param[out]  pollResList       : list of all responses"]
	#[doc = " \\param[in]   pollResListSize   : number of responses that can be placed in pollResList"]
	#[doc = " \\param[out]  devicesDetected   : number of cards found"]
	#[doc = " \\param[out]  collisionsDetected: number of collisions detected"]
	#[doc = ""]
	#[doc = " \\return ERR_NONE if there is no error"]
	#[doc = " \\return ERR_TIMEOUT if there is no response"]
	#[doc = ""]
	pub fn rfalFeliCaPoll(slots: rfalFeliCaPollSlots,
	                      sysCode: u16,
	                      reqCode: u8,
	                      pollResList: *mut rfalFeliCaPollRes,
	                      pollResListSize: u8,
	                      devicesDetected: *mut u8,
	                      collisionsDetected: *mut u8)
	                      -> ReturnCode;
}
extern "C" {
	#[doc = " \\brief Sends an ISO15693 Anticollision Frame"]
	#[doc = ""]
	#[doc = " This send the Anticollision|Inventory frame (INVENTORY_REQ)"]
	#[doc = ""]
	#[doc = " \\warning rxBuf must be able to contain the payload and CRC"]
	#[doc = ""]
	#[doc = " \\param[in]  txBuf        : Buffer where outgoing message is located"]
	#[doc = " \\param[in]  txBufLen     : Length of the outgoing message in bytes"]
	#[doc = " \\param[out] rxBuf        : Buffer where incoming message will be placed"]
	#[doc = " \\param[in]  rxBufLen     : Maximum length of the incoming message in bytes"]
	#[doc = " \\param[out] actLen       : Actual received length in bits"]
	#[doc = ""]
	#[doc = " \\return  ERR_NONE        : Transceive done with no error"]
	#[doc = " \\return  ERR_WRONG_STATE : RFAL not initialized or mode not set"]
	#[doc = " \\return  ERR_IO          : Internal error"]
	#[doc = ""]
	pub fn rfalISO15693TransceiveAnticollisionFrame(txBuf: *mut u8,
	                                                txBufLen: u8,
	                                                rxBuf: *mut u8,
	                                                rxBufLen: u8,
	                                                actLen: *mut u16)
	                                                -> ReturnCode;
}
extern "C" {
	#[doc = " \\brief Sends an ISO15693 Anticollision EOF"]
	#[doc = ""]
	#[doc = " This sends the Anticollision|Inventory EOF used as a slot marker"]
	#[doc = ""]
	#[doc = " \\warning rxBuf must be able to contain the payload and CRC"]
	#[doc = ""]
	#[doc = " \\param[out] rxBuf        : Buffer where incoming message will be placed"]
	#[doc = " \\param[in] rxBufLen      : Maximum length of the incoming message in bytes"]
	#[doc = " \\param[out] actLen       : Actual received length in bits"]
	#[doc = ""]
	#[doc = " \\return  ERR_NONE        : Transceive done with no error"]
	#[doc = " \\return  ERR_WRONG_STATE : RFAL not initialized or mode not set"]
	#[doc = " \\return  ERR_IO          : Internal error"]
	#[doc = ""]
	pub fn rfalISO15693TransceiveEOFAnticollision(rxBuf: *mut u8, rxBufLen: u8, actLen: *mut u16) -> ReturnCode;
}
extern "C" {
	#[doc = " \\brief Sends an ISO15693 EOF"]
	#[doc = ""]
	#[doc = " This is method sends an ISO15693 (EoF) used for a Write operation"]
	#[doc = ""]
	#[doc = " \\warning rxBuf must be able to contain the payload and CRC"]
	#[doc = ""]
	#[doc = " \\param[out] rxBuf        : Buffer where incoming message will be placed"]
	#[doc = " \\param[in] rxBufLen      : Maximum length of the incoming message in bytes"]
	#[doc = " \\param[out] actLen       : Actual received length in bytes"]
	#[doc = ""]
	#[doc = " \\return  ERR_NONE        : Transceive done with no error"]
	#[doc = " \\return  ERR_IO          : Internal error"]
	#[doc = ""]
	pub fn rfalISO15693TransceiveEOF(rxBuf: *mut u8, rxBufLen: u8, actLen: *mut u16) -> ReturnCode;
}
extern "C" {
	#[doc = " \\brief Transceive Blocking Tx"]
	#[doc = ""]
	#[doc = " This is method triggers a Transceive and executes it blocking until the"]
	#[doc = " Tx has been completed"]
	#[doc = ""]
	#[doc = " \\param[in]  txBuf    : Buffer where outgoing message is located"]
	#[doc = " \\param[in]  txBufLen : Length of the outgoing message in bytes"]
	#[doc = " \\param[out] rxBuf    : Buffer where incoming message will be placed"]
	#[doc = " \\param[in]  rxBufLen : Maximum length of the incoming message in bytes"]
	#[doc = " \\param[out] actLen   : Actual received length in bits"]
	#[doc = " \\param[in]  flags    : TransceiveFlags indication special handling"]
	#[doc = " \\param[in]  fwt      : Frame Waiting Time in 1/fc"]
	#[doc = ""]
	#[doc = " \\return  ERR_NONE         : Transceive done with no error"]
	#[doc = " \\return  ERR_BUSY         : Transceive ongoing"]
	#[doc = " \\return  ERR_XXXX         : Error occurred"]
	#[doc = " \\return  ERR_LINK_LOSS    : Link Loss - External Field is Off"]
	#[doc = " \\return  ERR_RF_COLLISION : Collision detected"]
	#[doc = " \\return  ERR_IO           : Internal error"]
	#[doc = ""]
	pub fn rfalTransceiveBlockingTx(txBuf: *mut u8,
	                                txBufLen: u16,
	                                rxBuf: *mut u8,
	                                rxBufLen: u16,
	                                actLen: *mut u16,
	                                flags: u32,
	                                fwt: u32)
	                                -> ReturnCode;
}
extern "C" {
	#[doc = " \\brief Transceive Blocking Rx"]
	#[doc = ""]
	#[doc = " This is method executes the reception of an ongoing Transceive triggered"]
	#[doc = " before by rfalTransceiveBlockingTx()"]
	#[doc = ""]
	#[doc = " \\return  ERR_NONE         : Transceive done with no error"]
	#[doc = " \\return  ERR_BUSY         : Transceive ongoing"]
	#[doc = " \\return  ERR_XXXX         : Error occurred"]
	#[doc = " \\return  ERR_TIMEOUT      : No response"]
	#[doc = " \\return  ERR_FRAMING      : Framing error detected"]
	#[doc = " \\return  ERR_PAR          : Parity error detected"]
	#[doc = " \\return  ERR_CRC          : CRC error detected"]
	#[doc = " \\return  ERR_LINK_LOSS    : Link Loss - External Field is Off"]
	#[doc = " \\return  ERR_RF_COLLISION : Collision detected"]
	#[doc = " \\return  ERR_IO           : Internal error"]
	#[doc = ""]
	pub fn rfalTransceiveBlockingRx() -> ReturnCode;
}
extern "C" {
	#[doc = " \\brief Transceive Blocking"]
	#[doc = ""]
	#[doc = " This is method triggers a Transceive and executes it blocking until it"]
	#[doc = " has been completed"]
	#[doc = ""]
	#[doc = " \\param[in]  txBuf    : Buffer where outgoing message is located"]
	#[doc = " \\param[in]  txBufLen : Length of the outgoing message in bytes"]
	#[doc = " \\param[out] rxBuf    : Buffer where incoming message will be placed"]
	#[doc = " \\param[in]  rxBufLen : Maximum length of the incoming message in bytes"]
	#[doc = " \\param[out] actLen   : Actual received length in bytes"]
	#[doc = " \\param[in]  flags    : TransceiveFlags indication special handling"]
	#[doc = " \\param[in]  fwt      : Frame Waiting Time in 1/fc"]
	#[doc = ""]
	#[doc = " \\return  ERR_NONE         : Transceive done with no error"]
	#[doc = " \\return  ERR_BUSY         : Transceive ongoing"]
	#[doc = " \\return  ERR_XXXX         : Error occurred"]
	#[doc = " \\return  ERR_TIMEOUT      : No response"]
	#[doc = " \\return  ERR_FRAMING      : Framing error detected"]
	#[doc = " \\return  ERR_PAR          : Parity error detected"]
	#[doc = " \\return  ERR_CRC          : CRC error detected"]
	#[doc = " \\return  ERR_LINK_LOSS    : Link Loss - External Field is Off"]
	#[doc = " \\return  ERR_RF_COLLISION : Collision detected"]
	#[doc = " \\return  ERR_IO           : Internal error"]
	#[doc = ""]
	pub fn rfalTransceiveBlockingTxRx(txBuf: *mut u8,
	                                  txBufLen: u16,
	                                  rxBuf: *mut u8,
	                                  rxBufLen: u16,
	                                  actLen: *mut u16,
	                                  flags: u32,
	                                  fwt: u32)
	                                  -> ReturnCode;
}
extern "C" {
	pub fn rfalTransceiveBitsBlockingTx(txBuf: *mut u8,
	                                    txBufLen: u16,
	                                    rxBuf: *mut u8,
	                                    rxBufLen: u16,
	                                    actLen: *mut u16,
	                                    flags: u32,
	                                    fwt: u32)
	                                    -> ReturnCode;
}
extern "C" {
	#[doc = " \\brief Is external Field On"]
	#[doc = ""]
	#[doc = " Checks if external field (other peer/device) is on/detected"]
	#[doc = ""]
	#[doc = " \\return true  External field is On"]
	#[doc = " \\return false No external field is detected"]
	#[doc = ""]
	#[doc = ""]
	pub fn rfalIsExtFieldOn() -> bool;
}
extern "C" {
	#[doc = " \\brief Listen Mode start"]
	#[doc = ""]
	#[doc = " Configures RF Chip to go into listen mode enabling the given technologies"]
	#[doc = ""]
	#[doc = ""]
	#[doc = " \\param[in]  lmMask:    mask with the enabled/disabled listen modes"]
	#[doc = "                        use: RFAL_LM_MASK_NFCA ; RFAL_LM_MASK_NFCB ;"]
	#[doc = "                             RFAL_LM_MASK_NFCF ; RFAL_LM_MASK_ACTIVE_P2P"]
	#[doc = " \\param[in]  confA:     pointer to Passive A configurations (NULL if disabled)"]
	#[doc = " \\param[in]  confB:     pointer to Passive B configurations (NULL if disabled)"]
	#[doc = " \\param[in]  confF:     pointer to Passive F configurations (NULL if disabled)"]
	#[doc = " \\param[in]  rxBuf:     buffer to place incoming data"]
	#[doc = " \\param[in]  rxBufLen:  length in bits of rxBuf"]
	#[doc = " \\param[in]  rxLen:     pointer to write the data length in bits placed into rxBuf"]
	#[doc = ""]
	#[doc = ""]
	#[doc = " \\return ERR_PARAM    Invalid parameter"]
	#[doc = " \\return ERR_REQUEST  Invalid listen mode mask"]
	#[doc = " \\return ERR_NONE     Done with no error"]
	#[doc = ""]
	#[doc = ""]
	pub fn rfalListenStart(lmMask: u32,
	                       confA: *const rfalLmConfPA,
	                       confB: *const rfalLmConfPB,
	                       confF: *const rfalLmConfPF,
	                       rxBuf: *mut u8,
	                       rxBufLen: u16,
	                       rxLen: *mut u16)
	                       -> ReturnCode;
}
extern "C" {
	#[doc = " \\brief Listen Mode start Sleeping"]
	#[doc = ""]
	#[doc = ""]
	#[doc = ""]
	pub fn rfalListenSleepStart(sleepSt: rfalLmState, rxBuf: *mut u8, rxBufLen: u16, rxLen: *mut u16) -> ReturnCode;
}
extern "C" {
	#[doc = " \\brief Listen Mode Stop"]
	#[doc = ""]
	#[doc = " Disables the listen mode on the RF Chip"]
	#[doc = ""]
	#[doc = " \\warning the listen mode will be disabled immediately on the RFchip regardless"]
	#[doc = "          of any ongoing operations like Transceive"]
	#[doc = ""]
	#[doc = " \\return ERR_NONE Done with no error"]
	#[doc = ""]
	#[doc = ""]
	pub fn rfalListenStop() -> ReturnCode;
}
extern "C" {
	#[doc = " \\brief Listen Mode get state"]
	#[doc = ""]
	#[doc = " Sets the new state of the Listen Mode and applies the necessary changes"]
	#[doc = " on the RF Chip"]
	#[doc = ""]
	#[doc = " \\param[out]  dataFlag: indicates that Listen Mode has rcvd data and caller"]
	#[doc = "                         must process it. The received message is located"]
	#[doc = "                         at the rxBuf passed on rfalListenStart()."]
	#[doc = "                         rfalListenSetState() will clear this flag"]
	#[doc = "                         if NULL output parameter will no be written/returned"]
	#[doc = " \\param[out]  lastBR:   bit rate detected  of the last initiator request"]
	#[doc = "                         if NULL output parameter will no be written/returned"]
	#[doc = ""]
	#[doc = " \\return rfalLmState  RFAL_LM_STATE_NOT_INIT : LM not initialized properly"]
	#[doc = "                      Any Other              : LM State"]
	#[doc = ""]
	#[doc = ""]
	pub fn rfalListenGetState(dataFlag: *mut bool, lastBR: *mut rfalBitRate) -> rfalLmState;
}
extern "C" {
	#[doc = " \\brief Listen Mode set state"]
	#[doc = ""]
	#[doc = " Sets the new state of the Listen Mode and applies the necessary changes"]
	#[doc = " on the RF Chip"]
	#[doc = ""]
	#[doc = " \\param[in] newSt : New state to go to"]
	#[doc = ""]
	#[doc = " \\return ERR_WRONG_STATE : Not initialized properly"]
	#[doc = " \\return ERR_PARAM       : Invalid parameter"]
	#[doc = " \\return ERR_NONE        : Done with no error"]
	#[doc = ""]
	#[doc = ""]
	pub fn rfalListenSetState(newSt: rfalLmState) -> ReturnCode;
}
extern "C" {
	#[doc = " \\brief Wake-Up Mode Start"]
	#[doc = ""]
	#[doc = " Sets the RF Chip in Low Power Wake-Up Mode according to the given"]
	#[doc = " configuration."]
	#[doc = ""]
	#[doc = " \\param[in] config       : Generic Wake-Up configuration provided by lower"]
	#[doc = "                            layers. If NULL will automatically configure the"]
	#[doc = "                            Wake-Up mode"]
	#[doc = ""]
	#[doc = " \\return ERR_WRONG_STATE : Not initialized properly"]
	#[doc = " \\return ERR_PARAM       : Invalid parameter"]
	#[doc = " \\return ERR_NONE        : Done with no error"]
	#[doc = ""]
	#[doc = ""]
	pub fn rfalWakeUpModeStart(config: *const rfalWakeUpConfig) -> ReturnCode;
}
extern "C" {
	#[doc = " \\brief Wake-Up Has Woke"]
	#[doc = ""]
	#[doc = " Returns true if the Wake-Up mode is enabled and it has already received"]
	#[doc = " the indication from the RF Chip that the surrounding environment has changed"]
	#[doc = " and flagged at least one wake-Up interrupt"]
	#[doc = ""]
	#[doc = " \\return true  : Wake-Up mode enabled and has received a wake-up IRQ"]
	#[doc = " \\return false : no Wake-Up IRQ has been received"]
	#[doc = ""]
	#[doc = ""]
	pub fn rfalWakeUpModeHasWoke() -> bool;
}
extern "C" {
	#[doc = " \\brief Wake-Up Mode Stop"]
	#[doc = ""]
	#[doc = " Stops the Wake-Up Mode"]
	#[doc = ""]
	#[doc = " \\return ERR_WRONG_STATE : Not initialized properly"]
	#[doc = " \\return ERR_PARAM       : Invalid parameter"]
	#[doc = " \\return ERR_NONE        : Done with no error"]
	#[doc = ""]
	#[doc = ""]
	pub fn rfalWakeUpModeStop() -> ReturnCode;
}
extern "C" {
	#[doc = " \\brief Low Power Mode Start"]
	#[doc = ""]
	#[doc = " Sets the RF Chip in Low Power Mode."]
	#[doc = " In this mode the RF Chip is placed in Low Power Mode, similar to Wake-up"]
	#[doc = " mode but no operation nor period measurement is performed."]
	#[doc = " Mode must be terminated by rfalLowPowerModeStop()"]
	#[doc = ""]
	#[doc = " \\return ERR_WRONG_STATE : Not initialized properly"]
	#[doc = " \\return ERR_PARAM       : Invalid parameter"]
	#[doc = " \\return ERR_NONE        : Done with no error"]
	#[doc = ""]
	#[doc = ""]
	pub fn rfalLowPowerModeStart() -> ReturnCode;
}
extern "C" {
	#[doc = " \\brief Low Power Mode Stop"]
	#[doc = ""]
	#[doc = " Stops the Low Power Mode re-enabling the device"]
	#[doc = ""]
	#[doc = " \\return ERR_WRONG_STATE : Not initialized properly"]
	#[doc = " \\return ERR_PARAM       : Invalid parameter"]
	#[doc = " \\return ERR_NONE        : Done with no error"]
	#[doc = ""]
	#[doc = ""]
	pub fn rfalLowPowerModeStop() -> ReturnCode;
}
#[repr(u32)]
#[non_exhaustive]
#[doc = " NFC-A T1T (Topaz) command set"]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum rfalT1Tcmds {
	#[doc = "< T1T Read UID"]
	RFAL_T1T_CMD_RID = 120,
	#[doc = "< T1T Read All"]
	RFAL_T1T_CMD_RALL = 0,
	#[doc = "< T1T Read"]
	RFAL_T1T_CMD_READ = 1,
	#[doc = "< T1T Write with erase (single byte)"]
	RFAL_T1T_CMD_WRITE_E = 83,
	#[doc = "< T1T Write with no erase (single byte)"]
	RFAL_T1T_CMD_WRITE_NE = 26,
}
#[doc = " NFC-A T1T (Topaz) RID_RES  Digital 1.1  10.6.2 & Table 50"]
#[repr(C)]
pub struct rfalT1TRidRes {
	#[doc = "< T1T Header ROM: HR0"]
	pub hr0: u8,
	#[doc = "< T1T Header ROM: HR1"]
	pub hr1: u8,
	#[doc = "< T1T UID"]
	pub uid: [u8; 4usize],
}
#[test]
fn bindgen_test_layout_rfalT1TRidRes() {
	assert_eq!(
	           ::core::mem::size_of::<rfalT1TRidRes>(),
	           6usize,
	           concat!("Size of: ", stringify!(rfalT1TRidRes))
	);
	assert_eq!(
	           ::core::mem::align_of::<rfalT1TRidRes>(),
	           1usize,
	           concat!("Alignment of ", stringify!(rfalT1TRidRes))
	);
	fn test_field_hr0() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalT1TRidRes>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).hr0) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(rfalT1TRidRes), "::", stringify!(hr0))
		);
	}
	test_field_hr0();
	fn test_field_hr1() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalT1TRidRes>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).hr1) as usize - ptr as usize
		           },
		           1usize,
		           concat!("Offset of field: ", stringify!(rfalT1TRidRes), "::", stringify!(hr1))
		);
	}
	test_field_hr1();
	fn test_field_uid() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalT1TRidRes>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).uid) as usize - ptr as usize
		           },
		           2usize,
		           concat!("Offset of field: ", stringify!(rfalT1TRidRes), "::", stringify!(uid))
		);
	}
	test_field_uid();
}
extern "C" {
	#[doc = " \\brief  Initialize NFC-A T1T Poller mode"]
	#[doc = ""]
	#[doc = " This methods configures RFAL RF layer to perform as a"]
	#[doc = " NFC-A T1T Poller/RW (Topaz) including all default timings"]
	#[doc = ""]
	#[doc = " \\return ERR_WRONG_STATE  : RFAL not initialized or mode not set"]
	#[doc = " \\return ERR_NONE         : No error"]
	#[doc = ""]
	pub fn rfalT1TPollerInitialize() -> ReturnCode;
}
extern "C" {
	#[doc = " \\brief  NFC-A T1T Poller RID"]
	#[doc = ""]
	#[doc = " This method reads the UID of a NFC-A T1T Listener device"]
	#[doc = ""]
	#[doc = ""]
	#[doc = " \\param[out]  ridRes : pointer to place the RID_RES"]
	#[doc = ""]
	#[doc = " \\return ERR_WRONG_STATE  : RFAL not initialized or mode not set"]
	#[doc = " \\return ERR_PARAM        : Invalid parameter"]
	#[doc = " \\return ERR_NONE         : No error"]
	#[doc = ""]
	pub fn rfalT1TPollerRid(ridRes: *mut rfalT1TRidRes) -> ReturnCode;
}
extern "C" {
	#[doc = " \\brief  NFC-A T1T Poller RALL"]
	#[doc = ""]
	#[doc = " This method send a Read All command to a NFC-A T1T Listener device"]
	#[doc = ""]
	#[doc = ""]
	#[doc = " \\param[in]   uid       : the UID of the device to read data"]
	#[doc = " \\param[out]  rxBuf     : pointer to place the read data"]
	#[doc = " \\param[in]   rxBufLen  : size of rxBuf"]
	#[doc = " \\param[out]  rxRcvdLen : actual received data"]
	#[doc = ""]
	#[doc = " \\return ERR_WRONG_STATE  : RFAL not initialized or mode not set"]
	#[doc = " \\return ERR_PARAM        : Invalid parameter"]
	#[doc = " \\return ERR_NONE         : No error"]
	#[doc = ""]
	pub fn rfalT1TPollerRall(uid: *const u8, rxBuf: *mut u8, rxBufLen: u16, rxRcvdLen: *mut u16) -> ReturnCode;
}
extern "C" {
	#[doc = " \\brief  NFC-A T1T Poller Write"]
	#[doc = ""]
	#[doc = " This method writes the given data on the address of a NFC-A T1T Listener device"]
	#[doc = ""]
	#[doc = ""]
	#[doc = " \\param[in]   uid       : the UID of the device to read data"]
	#[doc = " \\param[in]   address   : address to write the data"]
	#[doc = " \\param[in]   data      : the data to be written"]
	#[doc = ""]
	#[doc = " \\return ERR_WRONG_STATE  : RFAL not initialized or mode not set"]
	#[doc = " \\return ERR_PARAM        : Invalid parameter"]
	#[doc = " \\return ERR_NONE         : No error"]
	#[doc = ""]
	pub fn rfalT1TPollerWrite(uid: *const u8, address: u8, data: u8) -> ReturnCode;
}
#[repr(u32)]
#[non_exhaustive]
#[doc = " NFC-A Listen device types"]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum rfalNfcaListenDeviceType {
	RFAL_NFCA_T1T = 1,
	RFAL_NFCA_T2T = 0,
	RFAL_NFCA_T4T = 32,
	RFAL_NFCA_NFCDEP = 64,
	RFAL_NFCA_T4T_NFCDEP = 96,
}
#[doc = " SENS_RES (ATQA) format  Digital 1.1  6.6.3 & Table 7"]
#[repr(C)]
pub struct rfalNfcaSensRes {
	#[doc = "< SENS_RES Anticollision Information"]
	pub anticollisionInfo: u8,
	#[doc = "< SENS_RES Platform Information"]
	pub platformInfo: u8,
}
#[test]
fn bindgen_test_layout_rfalNfcaSensRes() {
	assert_eq!(
	           ::core::mem::size_of::<rfalNfcaSensRes>(),
	           2usize,
	           concat!("Size of: ", stringify!(rfalNfcaSensRes))
	);
	assert_eq!(
	           ::core::mem::align_of::<rfalNfcaSensRes>(),
	           1usize,
	           concat!("Alignment of ", stringify!(rfalNfcaSensRes))
	);
	fn test_field_anticollisionInfo() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcaSensRes>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).anticollisionInfo) as usize - ptr as usize
		           },
		           0usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalNfcaSensRes),
			"::",
			stringify!(anticollisionInfo)
		)
		);
	}
	test_field_anticollisionInfo();
	fn test_field_platformInfo() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcaSensRes>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).platformInfo) as usize - ptr as usize
		           },
		           1usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalNfcaSensRes),
			"::",
			stringify!(platformInfo)
		)
		);
	}
	test_field_platformInfo();
}
#[doc = " SDD_REQ (Anticollision) format   Digital 1.1  6.7.1 & Table 11"]
#[repr(C)]
pub struct rfalNfcaSddReq {
	#[doc = "< SDD_REQ SEL_CMD: cascade Level"]
	pub selCmd: u8,
	#[doc = "< SDD_REQ SEL_PAR: Byte Count[4b] | Bit Count[4b] (NVB: Number of Valid Bits)"]
	pub selPar: u8,
}
#[test]
fn bindgen_test_layout_rfalNfcaSddReq() {
	assert_eq!(
	           ::core::mem::size_of::<rfalNfcaSddReq>(),
	           2usize,
	           concat!("Size of: ", stringify!(rfalNfcaSddReq))
	);
	assert_eq!(
	           ::core::mem::align_of::<rfalNfcaSddReq>(),
	           1usize,
	           concat!("Alignment of ", stringify!(rfalNfcaSddReq))
	);
	fn test_field_selCmd() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcaSddReq>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).selCmd) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(rfalNfcaSddReq), "::", stringify!(selCmd))
		);
	}
	test_field_selCmd();
	fn test_field_selPar() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcaSddReq>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).selPar) as usize - ptr as usize
		           },
		           1usize,
		           concat!("Offset of field: ", stringify!(rfalNfcaSddReq), "::", stringify!(selPar))
		);
	}
	test_field_selPar();
}
#[doc = " SDD_RES (UID CLn) format   Digital 1.1  6.7.2 & Table 15"]
#[repr(C)]
pub struct rfalNfcaSddRes {
	pub nfcid1: [u8; 4usize],
	#[doc = "< BCC Exclusive-OR over first 4 bytes of SDD_RES"]
	pub bcc: u8,
}
#[test]
fn bindgen_test_layout_rfalNfcaSddRes() {
	assert_eq!(
	           ::core::mem::size_of::<rfalNfcaSddRes>(),
	           5usize,
	           concat!("Size of: ", stringify!(rfalNfcaSddRes))
	);
	assert_eq!(
	           ::core::mem::align_of::<rfalNfcaSddRes>(),
	           1usize,
	           concat!("Alignment of ", stringify!(rfalNfcaSddRes))
	);
	fn test_field_nfcid1() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcaSddRes>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).nfcid1) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(rfalNfcaSddRes), "::", stringify!(nfcid1))
		);
	}
	test_field_nfcid1();
	fn test_field_bcc() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcaSddRes>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).bcc) as usize - ptr as usize
		           },
		           4usize,
		           concat!("Offset of field: ", stringify!(rfalNfcaSddRes), "::", stringify!(bcc))
		);
	}
	test_field_bcc();
}
#[doc = " SEL_REQ (Select) format   Digital 1.1  6.8.1 & Table 17"]
#[repr(C)]
pub struct rfalNfcaSelReq {
	#[doc = "< SDD_REQ SEL_CMD: cascade Level"]
	pub selCmd: u8,
	#[doc = "< SDD_REQ SEL_PAR: Byte Count[4b] | Bit Count[4b] (NVB: Number of Valid Bits)"]
	pub selPar: u8,
	pub nfcid1: [u8; 4usize],
	#[doc = "< Checksum calculated as exclusive-OR over the 4 bytes of NFCID1 CLn"]
	pub bcc: u8,
}
#[test]
fn bindgen_test_layout_rfalNfcaSelReq() {
	assert_eq!(
	           ::core::mem::size_of::<rfalNfcaSelReq>(),
	           7usize,
	           concat!("Size of: ", stringify!(rfalNfcaSelReq))
	);
	assert_eq!(
	           ::core::mem::align_of::<rfalNfcaSelReq>(),
	           1usize,
	           concat!("Alignment of ", stringify!(rfalNfcaSelReq))
	);
	fn test_field_selCmd() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcaSelReq>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).selCmd) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(rfalNfcaSelReq), "::", stringify!(selCmd))
		);
	}
	test_field_selCmd();
	fn test_field_selPar() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcaSelReq>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).selPar) as usize - ptr as usize
		           },
		           1usize,
		           concat!("Offset of field: ", stringify!(rfalNfcaSelReq), "::", stringify!(selPar))
		);
	}
	test_field_selPar();
	fn test_field_nfcid1() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcaSelReq>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).nfcid1) as usize - ptr as usize
		           },
		           2usize,
		           concat!("Offset of field: ", stringify!(rfalNfcaSelReq), "::", stringify!(nfcid1))
		);
	}
	test_field_nfcid1();
	fn test_field_bcc() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcaSelReq>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).bcc) as usize - ptr as usize
		           },
		           6usize,
		           concat!("Offset of field: ", stringify!(rfalNfcaSelReq), "::", stringify!(bcc))
		);
	}
	test_field_bcc();
}
#[doc = " SEL_RES (SAK) format   Digital 1.1  6.8.2 & Table 19"]
#[repr(C)]
pub struct rfalNfcaSelRes {
	#[doc = "< Select Acknowledge"]
	pub sak: u8,
}
#[test]
fn bindgen_test_layout_rfalNfcaSelRes() {
	assert_eq!(
	           ::core::mem::size_of::<rfalNfcaSelRes>(),
	           1usize,
	           concat!("Size of: ", stringify!(rfalNfcaSelRes))
	);
	assert_eq!(
	           ::core::mem::align_of::<rfalNfcaSelRes>(),
	           1usize,
	           concat!("Alignment of ", stringify!(rfalNfcaSelRes))
	);
	fn test_field_sak() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcaSelRes>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).sak) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(rfalNfcaSelRes), "::", stringify!(sak))
		);
	}
	test_field_sak();
}
#[doc = " NFC-A listener device (PICC) struct"]
#[repr(C)]
pub struct rfalNfcaListenDevice {
	#[doc = "< NFC-A Listen device type"]
	pub type_: rfalNfcaListenDeviceType,
	#[doc = "< SENS_RES (ATQA)"]
	pub sensRes: rfalNfcaSensRes,
	#[doc = "< SEL_RES  (SAK)"]
	pub selRes: rfalNfcaSelRes,
	#[doc = "< NFCID1 Length"]
	pub nfcId1Len: u8,
	pub nfcId1: [u8; 10usize],
	#[doc = "< RID_RES"]
	pub ridRes: rfalT1TRidRes,
	#[doc = "< Device sleeping flag"]
	pub isSleep: bool,
}
#[test]
fn bindgen_test_layout_rfalNfcaListenDevice() {
	assert_eq!(
	           ::core::mem::size_of::<rfalNfcaListenDevice>(),
	           28usize,
	           concat!("Size of: ", stringify!(rfalNfcaListenDevice))
	);
	assert_eq!(
	           ::core::mem::align_of::<rfalNfcaListenDevice>(),
	           4usize,
	           concat!("Alignment of ", stringify!(rfalNfcaListenDevice))
	);
	fn test_field_type() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcaListenDevice>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(rfalNfcaListenDevice), "::", stringify!(type_))
		);
	}
	test_field_type();
	fn test_field_sensRes() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcaListenDevice>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).sensRes) as usize - ptr as usize
		           },
		           4usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalNfcaListenDevice),
			"::",
			stringify!(sensRes)
		)
		);
	}
	test_field_sensRes();
	fn test_field_selRes() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcaListenDevice>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).selRes) as usize - ptr as usize
		           },
		           6usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalNfcaListenDevice),
			"::",
			stringify!(selRes)
		)
		);
	}
	test_field_selRes();
	fn test_field_nfcId1Len() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcaListenDevice>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).nfcId1Len) as usize - ptr as usize
		           },
		           7usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalNfcaListenDevice),
			"::",
			stringify!(nfcId1Len)
		)
		);
	}
	test_field_nfcId1Len();
	fn test_field_nfcId1() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcaListenDevice>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).nfcId1) as usize - ptr as usize
		           },
		           8usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalNfcaListenDevice),
			"::",
			stringify!(nfcId1)
		)
		);
	}
	test_field_nfcId1();
	fn test_field_ridRes() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcaListenDevice>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).ridRes) as usize - ptr as usize
		           },
		           18usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalNfcaListenDevice),
			"::",
			stringify!(ridRes)
		)
		);
	}
	test_field_ridRes();
	fn test_field_isSleep() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcaListenDevice>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).isSleep) as usize - ptr as usize
		           },
		           24usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalNfcaListenDevice),
			"::",
			stringify!(isSleep)
		)
		);
	}
	test_field_isSleep();
}
extern "C" {
	#[doc = " \\brief  Initialize NFC-A Poller mode"]
	#[doc = ""]
	#[doc = " This methods configures RFAL RF layer to perform as a"]
	#[doc = " NFC-A Poller/RW (ISO14443A PCD) including all default timings and bit rate"]
	#[doc = " to 106 kbps"]
	#[doc = ""]
	#[doc = ""]
	#[doc = " \\return ERR_WRONG_STATE  : RFAL not initialized or mode not set"]
	#[doc = " \\return ERR_NONE         : No error"]
	#[doc = ""]
	pub fn rfalNfcaPollerInitialize() -> ReturnCode;
}
extern "C" {
	#[doc = " \\brief  NFC-A Poller Check Presence"]
	#[doc = ""]
	#[doc = " This method checks if a NFC-A Listen device (PICC) is present on the field"]
	#[doc = " by sending an ALL_REQ (WUPA) or SENS_REQ (REQA)"]
	#[doc = ""]
	#[doc = " \\param[in]  cmd     : Indicate if to send an ALL_REQ or a SENS_REQ"]
	#[doc = " \\param[out] sensRes : If received, the SENS_RES"]
	#[doc = ""]
	#[doc = " \\return ERR_WRONG_STATE  : RFAL not initialized or incorrect mode"]
	#[doc = " \\return ERR_PARAM        : Invalid parameters"]
	#[doc = " \\return ERR_IO           : Generic internal error"]
	#[doc = " \\return ERR_RF_COLLISION : Collision detected one or more device in the field"]
	#[doc = " \\return ERR_PAR          : Parity error detected, one or more device in the field"]
	#[doc = " \\return ERR_CRC          : CRC error detected, one or more device in the field"]
	#[doc = " \\return ERR_FRAMING      : Framing error detected, one or more device in the field"]
	#[doc = " \\return ERR_PROTO        : Protocol error detected, one or more device in the field"]
	#[doc = " \\return ERR_TIMEOUT      : Timeout error, no listener device detected"]
	#[doc = " \\return ERR_NONE         : No error, one or more device in the field"]
	#[doc = ""]
	pub fn rfalNfcaPollerCheckPresence(cmd: rfal14443AShortFrameCmd, sensRes: *mut rfalNfcaSensRes) -> ReturnCode;
}
extern "C" {
	#[doc = " \\brief  NFC-A Poller Select"]
	#[doc = ""]
	#[doc = " This method selects a NFC-A Listener device (PICC)"]
	#[doc = ""]
	#[doc = " \\param[in]  nfcid1   : Listener device NFCID1 to be selected"]
	#[doc = " \\param[in]  nfcidLen : Length of the NFCID1 to be selected"]
	#[doc = " \\param[out] selRes   : pointer to place the SEL_RES"]
	#[doc = ""]
	#[doc = " \\return ERR_WRONG_STATE  : RFAL not initialized or incorrect mode"]
	#[doc = " \\return ERR_PARAM        : Invalid parameters"]
	#[doc = " \\return ERR_IO           : Generic internal error"]
	#[doc = " \\return ERR_TIMEOUT      : Timeout error"]
	#[doc = " \\return ERR_PAR          : Parity error detected"]
	#[doc = " \\return ERR_CRC          : CRC error detected"]
	#[doc = " \\return ERR_FRAMING      : Framing error detected"]
	#[doc = " \\return ERR_PROTO        : Protocol error detected"]
	#[doc = " \\return ERR_NONE         : No error, SEL_RES received"]
	#[doc = ""]
	pub fn rfalNfcaPollerSelect(nfcid1: *const u8, nfcidLen: u8, selRes: *mut rfalNfcaSelRes) -> ReturnCode;
}
extern "C" {
	#[doc = " \\brief  NFC-A Poller Sleep"]
	#[doc = ""]
	#[doc = " This method sends a SLP_REQ (HLTA)"]
	#[doc = " No response is expected afterwards   Digital 1.1  6.9.2.1"]
	#[doc = ""]
	#[doc = " \\return ERR_WRONG_STATE  : RFAL not initialized or incorrect mode"]
	#[doc = " \\return ERR_PARAM        : Invalid parameters"]
	#[doc = " \\return ERR_IO           : Generic internal error"]
	#[doc = " \\return ERR_NONE         : No error"]
	#[doc = ""]
	pub fn rfalNfcaPollerSleep() -> ReturnCode;
}
extern "C" {
	#[doc = " \\brief  NFC-A Technology Detection"]
	#[doc = ""]
	#[doc = " This method performs NFC-A Technology Detection as defined in the spec"]
	#[doc = " given in the compliance mode"]
	#[doc = ""]
	#[doc = " \\param[in]  compMode  : compliance mode to be performed"]
	#[doc = " \\param[out] sensRes   : location to store the SENS_RES, if received"]
	#[doc = ""]
	#[doc = " When compMode is set to ISO compliance a SLP_REQ (HLTA) is not sent"]
	#[doc = " after detection. When set to EMV a ALL_REQ (WUPA) is sent instead of"]
	#[doc = " a SENS_REQ (REQA)"]
	#[doc = ""]
	#[doc = " \\return ERR_WRONG_STATE  : RFAL not initialized or incorrect mode"]
	#[doc = " \\return ERR_PARAM        : Invalid parameters"]
	#[doc = " \\return ERR_IO           : Generic internal error"]
	#[doc = " \\return ERR_NONE         : No error, one or more device in the field"]
	#[doc = ""]
	pub fn rfalNfcaPollerTechnologyDetection(compMode: rfalComplianceMode, sensRes: *mut rfalNfcaSensRes) -> ReturnCode;
}
extern "C" {
	#[doc = " \\brief  NFC-A Poller Collision Resolution"]
	#[doc = ""]
	#[doc = " Collision resolution for one NFC-A Listener device/card (PICC) as"]
	#[doc = " defined in Activity 2.1  9.3.4"]
	#[doc = ""]
	#[doc = " This method executes anti collision loop and select the device with higher NFCID1"]
	#[doc = ""]
	#[doc = " When devLimit = 0 it is configured to perform collision detection only. Once a collision"]
	#[doc = " is detected the collision resolution is aborted immidiatly. If only one device is found"]
	#[doc = " with no collisions, it will properly resolved."]
	#[doc = ""]
	#[doc = " \\param[in]  devLimit    : device limit value (CON_DEVICES_LIMIT)"]
	#[doc = " \\param[out] collPending : pointer to collision pending flag (INT_COLL_PEND)"]
	#[doc = " \\param[out] selRes      : location to store the last Select Response from listener device (PICC)"]
	#[doc = " \\param[out] nfcId1      : location to store the NFCID1 (UID), ensure RFAL_NFCA_CASCADE_3_UID_LEN"]
	#[doc = " \\param[out] nfcId1Len   : pointer to length of NFCID1 (UID)"]
	#[doc = ""]
	#[doc = " \\return ERR_WRONG_STATE  : RFAL not initialized or mode not set"]
	#[doc = " \\return ERR_PARAM        : Invalid parameters"]
	#[doc = " \\return ERR_IO           : Generic internal error"]
	#[doc = " \\return ERR_PROTO        : Card length invalid"]
	#[doc = " \\return ERR_IGNORE       : conDevLimit is 0 and there is a collision"]
	#[doc = " \\return ERR_NONE         : No error"]
	#[doc = ""]
	pub fn rfalNfcaPollerSingleCollisionResolution(devLimit: u8,
	                                               collPending: *mut bool,
	                                               selRes: *mut rfalNfcaSelRes,
	                                               nfcId1: *mut u8,
	                                               nfcId1Len: *mut u8)
	                                               -> ReturnCode;
}
extern "C" {
	#[doc = " \\brief  NFC-A Poller Full Collision Resolution"]
	#[doc = ""]
	#[doc = " Performs a full Collision resolution as defined in Activity 2.1  9.3.4"]
	#[doc = ""]
	#[doc = " \\param[in]  compMode    : compliance mode to be performed"]
	#[doc = " \\param[in]  devLimit    : device limit value, and size nfcaDevList"]
	#[doc = " \\param[out] nfcaDevList : NFC-A listener device info"]
	#[doc = " \\param[out] devCnt      : Devices found counter"]
	#[doc = ""]
	#[doc = " When compMode is set to ISO compliance it assumes that the device is"]
	#[doc = " not sleeping and therefore no ALL_REQ (WUPA) is sent at the beginning."]
	#[doc = " When compMode is set to NFC compliance an additional ALL_REQ (WUPA) is sent"]
	#[doc = " at the beginning."]
	#[doc = ""]
	#[doc = ""]
	#[doc = " When devLimit = 0 it is configured to perform collision detection only. Once a collision"]
	#[doc = " is detected the collision resolution is aborted immidiatly. If only one device is found"]
	#[doc = " with no collisions, it will properly resolved."]
	#[doc = ""]
	#[doc = ""]
	#[doc = " \\return ERR_WRONG_STATE  : RFAL not initialized or mode not set"]
	#[doc = " \\return ERR_PARAM        : Invalid parameters"]
	#[doc = " \\return ERR_IO           : Generic internal error"]
	#[doc = " \\return ERR_NONE         : No error"]
	#[doc = ""]
	pub fn rfalNfcaPollerFullCollisionResolution(compMode: rfalComplianceMode,
	                                             devLimit: u8,
	                                             nfcaDevList: *mut rfalNfcaListenDevice,
	                                             devCnt: *mut u8)
	                                             -> ReturnCode;
}
extern "C" {
	#[doc = " \\brief  NFC-A Poller Full Collision Resolution with Sleep"]
	#[doc = ""]
	#[doc = " Performs a full Collision resolution similar to rfalNfcaPollerFullCollisionResolution"]
	#[doc = " but an additional SLP_REQ (HLTA) -> SENS_RES (REQA) is sent regardless if there"]
	#[doc = " was a collision."]
	#[doc = " This proprietary behaviour ensures proper activation of certain devices that suffer"]
	#[doc = " from influence of Type B commands as foreseen in ISO14443-3 5.2.3 or were somehow"]
	#[doc = " not detected by the first round of collision resolution"]
	#[doc = ""]
	#[doc = " \\param[in]  devLimit    : device limit value, and size nfcaDevList"]
	#[doc = " \\param[out] nfcaDevList : NFC-A listener device info"]
	#[doc = " \\param[out] devCnt      : Devices found counter"]
	#[doc = ""]
	#[doc = ""]
	#[doc = " \\return ERR_WRONG_STATE  : RFAL not initialized or mode not set"]
	#[doc = " \\return ERR_PARAM        : Invalid parameters"]
	#[doc = " \\return ERR_IO           : Generic internal error"]
	#[doc = " \\return ERR_NONE         : No error"]
	#[doc = ""]
	pub fn rfalNfcaPollerSleepFullCollisionResolution(devLimit: u8,
	                                                  nfcaDevList: *mut rfalNfcaListenDevice,
	                                                  devCnt: *mut u8)
	                                                  -> ReturnCode;
}
extern "C" {
	#[doc = " \\brief  NFC-A Poller Start Full Collision Resolution"]
	#[doc = ""]
	#[doc = " This method starts the full Collision resolution as defined"]
	#[doc = " in Activity 1.0 or 1.1  9.3.4"]
	#[doc = ""]
	#[doc = " \\param[in]  compMode    : compliance mode to be performed"]
	#[doc = " \\param[in]  devLimit    : device limit value, and size nfcaDevList"]
	#[doc = " \\param[out] nfcaDevList : NFC-A listener device info"]
	#[doc = " \\param[out] devCnt      : Devices found counter"]
	#[doc = ""]
	#[doc = " When compMode is set to ISO compliance it assumes that the device is"]
	#[doc = " not sleeping and therefore no ALL_REQ (WUPA) is sent at the beginning."]
	#[doc = " When compMode is set to NFC compliance an additional ALL_REQ (WUPA) is sent at"]
	#[doc = " the beginning."]
	#[doc = ""]
	#[doc = ""]
	#[doc = " When devLimit = 0 it is configured to perform collision detection only. Once a collision"]
	#[doc = " is detected the collision resolution is aborted immidiatly. If only one device is found"]
	#[doc = " with no collisions, it will properly resolved."]
	#[doc = ""]
	#[doc = ""]
	#[doc = " \\return ERR_WRONG_STATE  : RFAL not initialized or mode not set"]
	#[doc = " \\return ERR_PARAM        : Invalid parameters"]
	#[doc = " \\return ERR_IO           : Generic internal error"]
	#[doc = " \\return ERR_NONE         : No error"]
	#[doc = ""]
	pub fn rfalNfcaPollerStartFullCollisionResolution(compMode: rfalComplianceMode,
	                                                  devLimit: u8,
	                                                  nfcaDevList: *mut rfalNfcaListenDevice,
	                                                  devCnt: *mut u8)
	                                                  -> ReturnCode;
}
extern "C" {
	#[doc = "  \\brief  NFC-A Get Full Collision Resolution Status"]
	#[doc = ""]
	#[doc = "  Returns the Collision Resolution status"]
	#[doc = ""]
	#[doc = "  \\return ERR_BUSY         : Operation is ongoing"]
	#[doc = "  \\return ERR_WRONG_STATE  : RFAL not initialized or incorrect mode"]
	#[doc = "  \\return ERR_PARAM        : Invalid parameters"]
	#[doc = "  \\return ERR_IO           : Generic internal error"]
	#[doc = "  \\return ERR_TIMEOUT      : Timeout error"]
	#[doc = "  \\return ERR_PAR          : Parity error detected"]
	#[doc = "  \\return ERR_CRC          : CRC error detected"]
	#[doc = "  \\return ERR_FRAMING      : Framing error detected"]
	#[doc = "  \\return ERR_PROTO        : Protocol error detected"]
	#[doc = "  \\return ERR_NONE         : No error, activation successful"]
	#[doc = ""]
	pub fn rfalNfcaPollerGetFullCollisionResolutionStatus() -> ReturnCode;
}
extern "C" {
	#[doc = " \\brief NFC-A Listener is SLP_REQ"]
	#[doc = ""]
	#[doc = " Checks if the given buffer contains valid NFC-A SLP_REQ (HALT)"]
	#[doc = ""]
	#[doc = " \\param[in] buf: buffer containing data"]
	#[doc = " \\param[in] bufLen: length of the data in buffer to be checked"]
	#[doc = ""]
	#[doc = " \\return true if data in buf contains a SLP_REQ ; false otherwise"]
	#[doc = ""]
	pub fn rfalNfcaListenerIsSleepReq(buf: *const u8, bufLen: u16) -> bool;
}
#[repr(u32)]
#[non_exhaustive]
#[doc = " SENSB_REQ and ALLB_REQ param   Digital 1.1 7.6.1"]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum rfalNfcbSensCmd {
	#[doc = "< ALLB_REQ  (WUPB)"]
	RFAL_NFCB_SENS_CMD_ALLB_REQ = 8,
	#[doc = "< SENSB_REQ (REQB)"]
	RFAL_NFCB_SENS_CMD_SENSB_REQ = 0,
}
#[repr(u32)]
#[non_exhaustive]
#[doc = " Number of Slots (NI) codes used for NFC-B anti collision  Digital 1.1 Table 26"]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum rfalNfcbSlots {
	#[doc = "< N=0 :  1 slot"]
	RFAL_NFCB_SLOT_NUM_1 = 0,
	#[doc = "< N=1 :  2 slots"]
	RFAL_NFCB_SLOT_NUM_2 = 1,
	#[doc = "< N=2 :  4 slots"]
	RFAL_NFCB_SLOT_NUM_4 = 2,
	#[doc = "< N=3 :  8 slots"]
	RFAL_NFCB_SLOT_NUM_8 = 3,
	#[doc = "< N=4 : 16 slots"]
	RFAL_NFCB_SLOT_NUM_16 = 4,
}
#[doc = " SENSB_RES (ATQB) Application Data Format   Digital 1.1 Table 28"]
#[repr(C)]
pub struct rfalNfcbSensbResAppData {
	#[doc = "< Application Family Identifier"]
	pub AFI: u8,
	#[doc = "< CRC_B of AID"]
	pub CRC_B: [u8; 2usize],
	#[doc = "< Number of Applications"]
	pub numApps: u8,
}
#[test]
fn bindgen_test_layout_rfalNfcbSensbResAppData() {
	assert_eq!(
	           ::core::mem::size_of::<rfalNfcbSensbResAppData>(),
	           4usize,
	           concat!("Size of: ", stringify!(rfalNfcbSensbResAppData))
	);
	assert_eq!(
	           ::core::mem::align_of::<rfalNfcbSensbResAppData>(),
	           1usize,
	           concat!("Alignment of ", stringify!(rfalNfcbSensbResAppData))
	);
	fn test_field_AFI() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcbSensbResAppData>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).AFI) as usize - ptr as usize
		           },
		           0usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalNfcbSensbResAppData),
			"::",
			stringify!(AFI)
		)
		);
	}
	test_field_AFI();
	fn test_field_CRC_B() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcbSensbResAppData>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).CRC_B) as usize - ptr as usize
		           },
		           1usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalNfcbSensbResAppData),
			"::",
			stringify!(CRC_B)
		)
		);
	}
	test_field_CRC_B();
	fn test_field_numApps() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcbSensbResAppData>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).numApps) as usize - ptr as usize
		           },
		           3usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalNfcbSensbResAppData),
			"::",
			stringify!(numApps)
		)
		);
	}
	test_field_numApps();
}
#[doc = " SENSB_RES Protocol Info format Digital 1.1 Table 29"]
#[repr(C)]
pub struct rfalNfcbSensbResProtocolInfo {
	#[doc = "< Bit Rate Capability"]
	pub BRC: u8,
	#[doc = "< Frame Size Card Integer [4b] | Protocol Type[4 bits]"]
	pub FsciProType: u8,
	#[doc = "< Frame Waiting Integer [4b] | Application Data Coding [2b] | Frame Options [2b]"]
	pub FwiAdcFo: u8,
	#[doc = "< Optional: Start-Up Frame Guard Time Integer[4b] | RFU [4b]"]
	pub SFGI: u8,
}
#[test]
fn bindgen_test_layout_rfalNfcbSensbResProtocolInfo() {
	assert_eq!(
	           ::core::mem::size_of::<rfalNfcbSensbResProtocolInfo>(),
	           4usize,
	           concat!("Size of: ", stringify!(rfalNfcbSensbResProtocolInfo))
	);
	assert_eq!(
	           ::core::mem::align_of::<rfalNfcbSensbResProtocolInfo>(),
	           1usize,
	           concat!("Alignment of ", stringify!(rfalNfcbSensbResProtocolInfo))
	);
	fn test_field_BRC() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcbSensbResProtocolInfo>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).BRC) as usize - ptr as usize
		           },
		           0usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalNfcbSensbResProtocolInfo),
			"::",
			stringify!(BRC)
		)
		);
	}
	test_field_BRC();
	fn test_field_FsciProType() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcbSensbResProtocolInfo>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).FsciProType) as usize - ptr as usize
		           },
		           1usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalNfcbSensbResProtocolInfo),
			"::",
			stringify!(FsciProType)
		)
		);
	}
	test_field_FsciProType();
	fn test_field_FwiAdcFo() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcbSensbResProtocolInfo>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).FwiAdcFo) as usize - ptr as usize
		           },
		           2usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalNfcbSensbResProtocolInfo),
			"::",
			stringify!(FwiAdcFo)
		)
		);
	}
	test_field_FwiAdcFo();
	fn test_field_SFGI() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcbSensbResProtocolInfo>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).SFGI) as usize - ptr as usize
		           },
		           3usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalNfcbSensbResProtocolInfo),
			"::",
			stringify!(SFGI)
		)
		);
	}
	test_field_SFGI();
}
#[doc = " SENSB_RES format   Digital 1.1  7.6.2"]
#[repr(C)]
pub struct rfalNfcbSensbRes {
	#[doc = "< SENSB_RES: 50h"]
	pub cmd: u8,
	#[doc = "< NFC Identifier (PUPI)"]
	pub nfcid0: [u8; 4usize],
	#[doc = "< Application Data"]
	pub appData: rfalNfcbSensbResAppData,
	#[doc = "< Protocol Information"]
	pub protInfo: rfalNfcbSensbResProtocolInfo,
}
#[test]
fn bindgen_test_layout_rfalNfcbSensbRes() {
	assert_eq!(
	           ::core::mem::size_of::<rfalNfcbSensbRes>(),
	           13usize,
	           concat!("Size of: ", stringify!(rfalNfcbSensbRes))
	);
	assert_eq!(
	           ::core::mem::align_of::<rfalNfcbSensbRes>(),
	           1usize,
	           concat!("Alignment of ", stringify!(rfalNfcbSensbRes))
	);
	fn test_field_cmd() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcbSensbRes>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).cmd) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(rfalNfcbSensbRes), "::", stringify!(cmd))
		);
	}
	test_field_cmd();
	fn test_field_nfcid0() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcbSensbRes>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).nfcid0) as usize - ptr as usize
		           },
		           1usize,
		           concat!("Offset of field: ", stringify!(rfalNfcbSensbRes), "::", stringify!(nfcid0))
		);
	}
	test_field_nfcid0();
	fn test_field_appData() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcbSensbRes>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).appData) as usize - ptr as usize
		           },
		           5usize,
		           concat!("Offset of field: ", stringify!(rfalNfcbSensbRes), "::", stringify!(appData))
		);
	}
	test_field_appData();
	fn test_field_protInfo() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcbSensbRes>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).protInfo) as usize - ptr as usize
		           },
		           9usize,
		           concat!("Offset of field: ", stringify!(rfalNfcbSensbRes), "::", stringify!(protInfo))
		);
	}
	test_field_protInfo();
}
#[doc = " NFC-B listener device (PICC) struct"]
#[repr(C)]
pub struct rfalNfcbListenDevice {
	#[doc = "< SENSB_RES length"]
	pub sensbResLen: u8,
	#[doc = "< SENSB_RES"]
	pub sensbRes: rfalNfcbSensbRes,
	#[doc = "< Device sleeping flag"]
	pub isSleep: bool,
}
#[test]
fn bindgen_test_layout_rfalNfcbListenDevice() {
	assert_eq!(
	           ::core::mem::size_of::<rfalNfcbListenDevice>(),
	           15usize,
	           concat!("Size of: ", stringify!(rfalNfcbListenDevice))
	);
	assert_eq!(
	           ::core::mem::align_of::<rfalNfcbListenDevice>(),
	           1usize,
	           concat!("Alignment of ", stringify!(rfalNfcbListenDevice))
	);
	fn test_field_sensbResLen() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcbListenDevice>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).sensbResLen) as usize - ptr as usize
		           },
		           0usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalNfcbListenDevice),
			"::",
			stringify!(sensbResLen)
		)
		);
	}
	test_field_sensbResLen();
	fn test_field_sensbRes() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcbListenDevice>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).sensbRes) as usize - ptr as usize
		           },
		           1usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalNfcbListenDevice),
			"::",
			stringify!(sensbRes)
		)
		);
	}
	test_field_sensbRes();
	fn test_field_isSleep() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcbListenDevice>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).isSleep) as usize - ptr as usize
		           },
		           14usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalNfcbListenDevice),
			"::",
			stringify!(isSleep)
		)
		);
	}
	test_field_isSleep();
}
extern "C" {
	#[doc = " \\brief  Initialize NFC-B Poller mode"]
	#[doc = ""]
	#[doc = " This methods configures RFAL RF layer to perform as a"]
	#[doc = " NFC-B Poller/RW (ISO14443B PCD) including all default timings"]
	#[doc = ""]
	#[doc = " It sets NFC-B parameters (AFI, PARAM) to default values"]
	#[doc = ""]
	#[doc = " \\return ERR_WRONG_STATE  : RFAL not initialized or mode not set"]
	#[doc = " \\return ERR_NONE         : No error"]
	#[doc = ""]
	pub fn rfalNfcbPollerInitialize() -> ReturnCode;
}
extern "C" {
	#[doc = " \\brief  Set NFC-B Poller parameters"]
	#[doc = ""]
	#[doc = " This methods configures RFAL RF layer to perform as a"]
	#[doc = " NFCA Poller/RW (ISO14443A PCD) including all default timings"]
	#[doc = ""]
	#[doc = " Additionally configures NFC-B specific parameters to be used on the"]
	#[doc = " following communications"]
	#[doc = ""]
	#[doc = " \\param[in]  AFI   : Application Family Identifier to be used"]
	#[doc = " \\param[in]  PARAM : PARAM to be used, it announces whether Advanced"]
	#[doc = "                     Features or Extended SENSB_RES is supported"]
	#[doc = ""]
	#[doc = " \\return ERR_WRONG_STATE  : RFAL not initialized or mode not set"]
	#[doc = " \\return ERR_NONE         : No error"]
	#[doc = ""]
	pub fn rfalNfcbPollerInitializeWithParams(AFI: u8, PARAM: u8) -> ReturnCode;
}
extern "C" {
	#[doc = " \\brief  NFC-B Poller Check Presence"]
	#[doc = ""]
	#[doc = " This method checks if a NFC-B Listen device (PICC) is present on the field"]
	#[doc = " by sending an ALLB_REQ (WUPB) or SENSB_REQ (REQB)"]
	#[doc = ""]
	#[doc = " \\param[in]  cmd         : Indicate if to send an ALL_REQ or a SENS_REQ"]
	#[doc = " \\param[in]  slots       : The number of slots to be announced"]
	#[doc = " \\param[out] sensbRes    : If received, the SENSB_RES"]
	#[doc = " \\param[out] sensbResLen : If received, the SENSB_RES length"]
	#[doc = ""]
	#[doc = ""]
	#[doc = " \\return ERR_WRONG_STATE  : RFAL not initialized or incorrect mode"]
	#[doc = " \\return ERR_PARAM        : Invalid parameters"]
	#[doc = " \\return ERR_IO           : Generic internal error"]
	#[doc = " \\return ERR_TIMEOUT      : Timeout error, no listener device detected"]
	#[doc = " \\return ERR_RF_COLLISION : Collision detected one or more device in the field"]
	#[doc = " \\return ERR_PAR          : Parity error detected, one or more device in the field"]
	#[doc = " \\return ERR_CRC          : CRC error detected, one or more device in the field"]
	#[doc = " \\return ERR_FRAMING      : Framing error detected, one or more device in the field"]
	#[doc = " \\return ERR_PROTO        : Protocol error detected, invalid SENSB_RES received"]
	#[doc = " \\return ERR_NONE         : No error, SENSB_RES received"]
	#[doc = ""]
	pub fn rfalNfcbPollerCheckPresence(cmd: rfalNfcbSensCmd,
	                                   slots: rfalNfcbSlots,
	                                   sensbRes: *mut rfalNfcbSensbRes,
	                                   sensbResLen: *mut u8)
	                                   -> ReturnCode;
}
extern "C" {
	#[doc = " \\brief  NFC-B Poller Sleep"]
	#[doc = ""]
	#[doc = " This function is used to send the SLPB_REQ (HLTB) command to put the PICC with"]
	#[doc = " the given NFCID0 to state HALT so that they do not reply to further SENSB_REQ"]
	#[doc = " commands (only to ALLB_REQ)"]
	#[doc = ""]
	#[doc = " \\param[in]  nfcid0       : NFCID of the device to be put to Sleep"]
	#[doc = ""]
	#[doc = " \\return ERR_WRONG_STATE  : RFAL not initialized or incorrect mode"]
	#[doc = " \\return ERR_PARAM        : Invalid parameters"]
	#[doc = " \\return ERR_IO           : Generic internal error"]
	#[doc = " \\return ERR_NONE         : No error"]
	#[doc = ""]
	pub fn rfalNfcbPollerSleep(nfcid0: *const u8) -> ReturnCode;
}
extern "C" {
	#[doc = " \\brief  NFC-B Poller Slot Marker"]
	#[doc = ""]
	#[doc = " This method selects a NFC-B Slot marker frame"]
	#[doc = ""]
	#[doc = " \\param[in]  slotCode     : Slot Code [1-15]"]
	#[doc = " \\param[out] sensbRes     : If received, the SENSB_RES"]
	#[doc = " \\param[out] sensbResLen  : If received, the SENSB_RES length"]
	#[doc = ""]
	#[doc = " \\return ERR_WRONG_STATE  : RFAL not initialized or incorrect mode"]
	#[doc = " \\return ERR_PARAM        : Invalid parameters"]
	#[doc = " \\return ERR_IO           : Generic internal error"]
	#[doc = " \\return ERR_TIMEOUT      : Timeout error"]
	#[doc = " \\return ERR_PAR          : Parity error detected"]
	#[doc = " \\return ERR_CRC          : CRC error detected"]
	#[doc = " \\return ERR_FRAMING      : Framing error detected"]
	#[doc = " \\return ERR_PROTO        : Protocol error detected"]
	#[doc = " \\return ERR_NONE         : No error, SEL_RES received"]
	#[doc = ""]
	pub fn rfalNfcbPollerSlotMarker(slotCode: u8, sensbRes: *mut rfalNfcbSensbRes, sensbResLen: *mut u8) -> ReturnCode;
}
extern "C" {
	#[doc = " \\brief  NFC-B Technology Detection"]
	#[doc = ""]
	#[doc = " This method performs NFC-B Technology Detection as defined in the spec"]
	#[doc = " given in the compliance mode"]
	#[doc = ""]
	#[doc = " \\param[in]  compMode    : compliance mode to be performed"]
	#[doc = " \\param[out] sensbRes    : location to store the SENSB_RES, if received"]
	#[doc = " \\param[out] sensbResLen : length of the SENSB_RES, if received"]
	#[doc = ""]
	#[doc = " \\return ERR_WRONG_STATE  : RFAL not initialized or incorrect mode"]
	#[doc = " \\return ERR_PARAM        : Invalid parameters"]
	#[doc = " \\return ERR_IO           : Generic internal error"]
	#[doc = " \\return ERR_NONE         : No error, one or more device in the field"]
	#[doc = ""]
	pub fn rfalNfcbPollerTechnologyDetection(compMode: rfalComplianceMode,
	                                         sensbRes: *mut rfalNfcbSensbRes,
	                                         sensbResLen: *mut u8)
	                                         -> ReturnCode;
}
extern "C" {
	#[doc = " \\brief  NFC-B Poller Collision Resolution"]
	#[doc = ""]
	#[doc = " NFC-B Collision resolution  Listener device/card (PICC) as"]
	#[doc = " defined in Activity 1.1  9.3.5"]
	#[doc = ""]
	#[doc = " This function is used to perform collision resolution for detection in case"]
	#[doc = " of multiple NFC Forum Devices with Technology B detected."]
	#[doc = " Target with valid SENSB_RES will be stored in devInfo and nfcbDevCount incremented."]
	#[doc = ""]
	#[doc = " \\param[in]  compMode    : compliance mode to be performed"]
	#[doc = " \\param[in]  devLimit    : device limit value, and size nfcbDevList"]
	#[doc = " \\param[out] nfcbDevList : NFC-B listener device info"]
	#[doc = " \\param[out] devCnt      : devices found counter"]
	#[doc = ""]
	#[doc = " \\return ERR_WRONG_STATE  : RFAL not initialized or mode not set"]
	#[doc = " \\return ERR_PARAM        : Invalid parameters"]
	#[doc = " \\return ERR_IO           : Generic internal error"]
	#[doc = " \\return ERR_PROTO        : Protocol error detected"]
	#[doc = " \\return ERR_NONE         : No error"]
	#[doc = ""]
	pub fn rfalNfcbPollerCollisionResolution(compMode: rfalComplianceMode,
	                                         devLimit: u8,
	                                         nfcbDevList: *mut rfalNfcbListenDevice,
	                                         devCnt: *mut u8)
	                                         -> ReturnCode;
}
extern "C" {
	#[doc = " \\brief  NFC-B Poller Collision Resolution Slotted"]
	#[doc = ""]
	#[doc = " NFC-B Collision resolution  Listener device/card (PICC). The sequence can"]
	#[doc = " be configured to be according to NFC Forum Activity 1.1  9.3.5, ISO10373"]
	#[doc = " or EMVCo"]
	#[doc = ""]
	#[doc = " This function is used to perform collision resolution for detection in case"]
	#[doc = " of multiple NFC Forum Devices with Technology B are detected."]
	#[doc = " Target with valid SENSB_RES will be stored in devInfo and nfcbDevCount incremented."]
	#[doc = ""]
	#[doc = " This method provides the means to perform a collision resolution loop with specific"]
	#[doc = " initial and end number of slots. This allows to user to start the loop already with"]
	#[doc = " greater number of slots, and or limit the end number of slots. At the end a flag"]
	#[doc = " indicating whether there were collisions pending is returned."]
	#[doc = ""]
	#[doc = " If RFAL_COMPLIANCE_MODE_ISO is used \\a initSlots must be set to RFAL_NFCB_SLOT_NUM_1"]
	#[doc = ""]
	#[doc = ""]
	#[doc = " \\param[in]  compMode    : compliance mode to be performed"]
	#[doc = " \\param[in]  devLimit    : device limit value, and size nfcbDevList"]
	#[doc = " \\param[in]  initSlots   : number of slots to open initially"]
	#[doc = " \\param[in]  endSlots    : number of slots when to stop collision resolution"]
	#[doc = " \\param[out] nfcbDevList : NFC-B listener device info"]
	#[doc = " \\param[out] devCnt      : devices found counter"]
	#[doc = " \\param[out] colPending  : flag indicating whether collision are still pending"]
	#[doc = ""]
	#[doc = " \\return ERR_WRONG_STATE  : RFAL not initialized or mode not set"]
	#[doc = " \\return ERR_PARAM        : Invalid parameters"]
	#[doc = " \\return ERR_IO           : Generic internal error"]
	#[doc = " \\return ERR_PROTO        : Protocol error detected"]
	#[doc = " \\return ERR_NONE         : No error"]
	#[doc = ""]
	pub fn rfalNfcbPollerSlottedCollisionResolution(compMode: rfalComplianceMode,
	                                                devLimit: u8,
	                                                initSlots: rfalNfcbSlots,
	                                                endSlots: rfalNfcbSlots,
	                                                nfcbDevList: *mut rfalNfcbListenDevice,
	                                                devCnt: *mut u8,
	                                                colPending: *mut bool)
	                                                -> ReturnCode;
}
extern "C" {
	#[doc = " \\brief  NFC-B TR2 code to FDT"]
	#[doc = ""]
	#[doc = "  Converts the TR2 code as defined in Digital 1.1 Table 33 Minimum"]
	#[doc = "  TR2 Coding to Frame Delay Time (FDT) in 1/Fc"]
	#[doc = ""]
	#[doc = " \\param[in]  tr2Code : TR2 code as defined in Digital 1.1 Table 33"]
	#[doc = ""]
	#[doc = " \\return FDT in 1/Fc"]
	#[doc = ""]
	pub fn rfalNfcbTR2ToFDT(tr2Code: u8) -> u32;
}
pub const RFAL_NFCF_CMD_POLLING: _bindgen_ty_4 = _bindgen_ty_4::RFAL_NFCF_CMD_POLLING;
pub const RFAL_NFCF_CMD_POLLING_RES: _bindgen_ty_4 = _bindgen_ty_4::RFAL_NFCF_CMD_POLLING_RES;
pub const RFAL_NFCF_CMD_REQUEST_SERVICE: _bindgen_ty_4 = _bindgen_ty_4::RFAL_NFCF_CMD_REQUEST_SERVICE;
pub const RFAL_NFCF_CMD_REQUEST_RESPONSE: _bindgen_ty_4 = _bindgen_ty_4::RFAL_NFCF_CMD_REQUEST_RESPONSE;
pub const RFAL_NFCF_CMD_READ_WITHOUT_ENCRYPTION: _bindgen_ty_4 = _bindgen_ty_4::RFAL_NFCF_CMD_READ_WITHOUT_ENCRYPTION;
pub const RFAL_NFCF_CMD_READ_WITHOUT_ENCRYPTION_RES: _bindgen_ty_4 = _bindgen_ty_4::RFAL_NFCF_CMD_READ_WITHOUT_ENCRYPTION_RES;
pub const RFAL_NFCF_CMD_WRITE_WITHOUT_ENCRYPTION: _bindgen_ty_4 = _bindgen_ty_4::RFAL_NFCF_CMD_WRITE_WITHOUT_ENCRYPTION;
pub const RFAL_NFCF_CMD_WRITE_WITHOUT_ENCRYPTION_RES: _bindgen_ty_4 = _bindgen_ty_4::RFAL_NFCF_CMD_WRITE_WITHOUT_ENCRYPTION_RES;
pub const RFAL_NFCF_CMD_REQUEST_SYSTEM_CODE: _bindgen_ty_4 = _bindgen_ty_4::RFAL_NFCF_CMD_REQUEST_SYSTEM_CODE;
pub const RFAL_NFCF_CMD_AUTHENTICATION1: _bindgen_ty_4 = _bindgen_ty_4::RFAL_NFCF_CMD_AUTHENTICATION1;
pub const RFAL_NFCF_CMD_AUTHENTICATION2: _bindgen_ty_4 = _bindgen_ty_4::RFAL_NFCF_CMD_AUTHENTICATION2;
pub const RFAL_NFCF_CMD_READ: _bindgen_ty_4 = _bindgen_ty_4::RFAL_NFCF_CMD_READ;
pub const RFAL_NFCF_CMD_WRITE: _bindgen_ty_4 = _bindgen_ty_4::RFAL_NFCF_CMD_WRITE;
#[repr(u32)]
#[non_exhaustive]
#[doc = " NFC-F Felica command set   JIS X6319-4  9.1"]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum _bindgen_ty_4 {
	RFAL_NFCF_CMD_POLLING = 0,
	RFAL_NFCF_CMD_POLLING_RES = 1,
	RFAL_NFCF_CMD_REQUEST_SERVICE = 2,
	RFAL_NFCF_CMD_REQUEST_RESPONSE = 4,
	RFAL_NFCF_CMD_READ_WITHOUT_ENCRYPTION = 6,
	RFAL_NFCF_CMD_READ_WITHOUT_ENCRYPTION_RES = 7,
	RFAL_NFCF_CMD_WRITE_WITHOUT_ENCRYPTION = 8,
	RFAL_NFCF_CMD_WRITE_WITHOUT_ENCRYPTION_RES = 9,
	RFAL_NFCF_CMD_REQUEST_SYSTEM_CODE = 12,
	RFAL_NFCF_CMD_AUTHENTICATION1 = 16,
	RFAL_NFCF_CMD_AUTHENTICATION2 = 18,
	RFAL_NFCF_CMD_READ = 20,
	RFAL_NFCF_CMD_WRITE = 22,
}
#[doc = " NFC-F SENSF_RES format  Digital 1.1  8.6.2"]
#[repr(C)]
pub struct rfalNfcfSensfRes {
	#[doc = "< Command Code: 01h"]
	pub CMD: u8,
	#[doc = "< NFCID2"]
	pub NFCID2: [u8; 8usize],
	#[doc = "< PAD0"]
	pub PAD0: [u8; 2usize],
	#[doc = "< PAD1"]
	pub PAD1: [u8; 2usize],
	#[doc = "< MRTIcheck"]
	pub MRTIcheck: u8,
	#[doc = "< MRTIupdate"]
	pub MRTIupdate: u8,
	#[doc = "< PAD2"]
	pub PAD2: u8,
	#[doc = "< Request Data"]
	pub RD: [u8; 2usize],
}
#[test]
fn bindgen_test_layout_rfalNfcfSensfRes() {
	assert_eq!(
	           ::core::mem::size_of::<rfalNfcfSensfRes>(),
	           18usize,
	           concat!("Size of: ", stringify!(rfalNfcfSensfRes))
	);
	assert_eq!(
	           ::core::mem::align_of::<rfalNfcfSensfRes>(),
	           1usize,
	           concat!("Alignment of ", stringify!(rfalNfcfSensfRes))
	);
	fn test_field_CMD() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcfSensfRes>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).CMD) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(rfalNfcfSensfRes), "::", stringify!(CMD))
		);
	}
	test_field_CMD();
	fn test_field_NFCID2() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcfSensfRes>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).NFCID2) as usize - ptr as usize
		           },
		           1usize,
		           concat!("Offset of field: ", stringify!(rfalNfcfSensfRes), "::", stringify!(NFCID2))
		);
	}
	test_field_NFCID2();
	fn test_field_PAD0() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcfSensfRes>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).PAD0) as usize - ptr as usize
		           },
		           9usize,
		           concat!("Offset of field: ", stringify!(rfalNfcfSensfRes), "::", stringify!(PAD0))
		);
	}
	test_field_PAD0();
	fn test_field_PAD1() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcfSensfRes>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).PAD1) as usize - ptr as usize
		           },
		           11usize,
		           concat!("Offset of field: ", stringify!(rfalNfcfSensfRes), "::", stringify!(PAD1))
		);
	}
	test_field_PAD1();
	fn test_field_MRTIcheck() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcfSensfRes>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).MRTIcheck) as usize - ptr as usize
		           },
		           13usize,
		           concat!("Offset of field: ", stringify!(rfalNfcfSensfRes), "::", stringify!(MRTIcheck))
		);
	}
	test_field_MRTIcheck();
	fn test_field_MRTIupdate() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcfSensfRes>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).MRTIupdate) as usize - ptr as usize
		           },
		           14usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalNfcfSensfRes),
			"::",
			stringify!(MRTIupdate)
		)
		);
	}
	test_field_MRTIupdate();
	fn test_field_PAD2() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcfSensfRes>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).PAD2) as usize - ptr as usize
		           },
		           15usize,
		           concat!("Offset of field: ", stringify!(rfalNfcfSensfRes), "::", stringify!(PAD2))
		);
	}
	test_field_PAD2();
	fn test_field_RD() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcfSensfRes>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).RD) as usize - ptr as usize
		           },
		           16usize,
		           concat!("Offset of field: ", stringify!(rfalNfcfSensfRes), "::", stringify!(RD))
		);
	}
	test_field_RD();
}
#[doc = " NFC-F poller device (PCD) struct"]
#[repr(C)]
pub struct rfalNfcfPollDevice {
	#[doc = "< NFCID2"]
	pub NFCID2: [u8; 8usize],
}
#[test]
fn bindgen_test_layout_rfalNfcfPollDevice() {
	assert_eq!(
	           ::core::mem::size_of::<rfalNfcfPollDevice>(),
	           8usize,
	           concat!("Size of: ", stringify!(rfalNfcfPollDevice))
	);
	assert_eq!(
	           ::core::mem::align_of::<rfalNfcfPollDevice>(),
	           1usize,
	           concat!("Alignment of ", stringify!(rfalNfcfPollDevice))
	);
	fn test_field_NFCID2() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcfPollDevice>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).NFCID2) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(rfalNfcfPollDevice), "::", stringify!(NFCID2))
		);
	}
	test_field_NFCID2();
}
#[doc = " NFC-F listener device (PICC) struct"]
#[repr(C)]
pub struct rfalNfcfListenDevice {
	#[doc = "< SENF_RES length"]
	pub sensfResLen: u8,
	#[doc = "< SENF_RES"]
	pub sensfRes: rfalNfcfSensfRes,
}
#[test]
fn bindgen_test_layout_rfalNfcfListenDevice() {
	assert_eq!(
	           ::core::mem::size_of::<rfalNfcfListenDevice>(),
	           19usize,
	           concat!("Size of: ", stringify!(rfalNfcfListenDevice))
	);
	assert_eq!(
	           ::core::mem::align_of::<rfalNfcfListenDevice>(),
	           1usize,
	           concat!("Alignment of ", stringify!(rfalNfcfListenDevice))
	);
	fn test_field_sensfResLen() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcfListenDevice>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).sensfResLen) as usize - ptr as usize
		           },
		           0usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalNfcfListenDevice),
			"::",
			stringify!(sensfResLen)
		)
		);
	}
	test_field_sensfResLen();
	fn test_field_sensfRes() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcfListenDevice>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).sensfRes) as usize - ptr as usize
		           },
		           1usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalNfcfListenDevice),
			"::",
			stringify!(sensfRes)
		)
		);
	}
	test_field_sensfRes();
}
pub type rfalNfcfServ = u16;
#[doc = " NFC-F Block List Element (2 or 3 bytes element)       T3T 1.0 5.6.1"]
#[repr(C)]
pub struct rfalNfcfBlockListElem {
	#[doc = "<  Access Mode | Serv Code List Order"]
	pub conf: u8,
	#[doc = "<  Block Number"]
	pub blockNum: u16,
}
#[test]
fn bindgen_test_layout_rfalNfcfBlockListElem() {
	assert_eq!(
	           ::core::mem::size_of::<rfalNfcfBlockListElem>(),
	           4usize,
	           concat!("Size of: ", stringify!(rfalNfcfBlockListElem))
	);
	assert_eq!(
	           ::core::mem::align_of::<rfalNfcfBlockListElem>(),
	           2usize,
	           concat!("Alignment of ", stringify!(rfalNfcfBlockListElem))
	);
	fn test_field_conf() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcfBlockListElem>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).conf) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(rfalNfcfBlockListElem), "::", stringify!(conf))
		);
	}
	test_field_conf();
	fn test_field_blockNum() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcfBlockListElem>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).blockNum) as usize - ptr as usize
		           },
		           2usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalNfcfBlockListElem),
			"::",
			stringify!(blockNum)
		)
		);
	}
	test_field_blockNum();
}
#[doc = " Check Update Service list and Block list parameter"]
#[repr(C)]
pub struct rfalNfcfServBlockListParam {
	#[doc = "< Number of Services"]
	pub numServ: u8,
	#[doc = "< Service Code List"]
	pub servList: *mut rfalNfcfServ,
	#[doc = "< Number of Blocks"]
	pub numBlock: u8,
	#[doc = "< Block Number List"]
	pub blockList: *mut rfalNfcfBlockListElem,
}
#[test]
fn bindgen_test_layout_rfalNfcfServBlockListParam() {
	assert_eq!(
	           ::core::mem::size_of::<rfalNfcfServBlockListParam>(),
	           16usize,
	           concat!("Size of: ", stringify!(rfalNfcfServBlockListParam))
	);
	assert_eq!(
	           ::core::mem::align_of::<rfalNfcfServBlockListParam>(),
	           4usize,
	           concat!("Alignment of ", stringify!(rfalNfcfServBlockListParam))
	);
	fn test_field_numServ() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcfServBlockListParam>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).numServ) as usize - ptr as usize
		           },
		           0usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalNfcfServBlockListParam),
			"::",
			stringify!(numServ)
		)
		);
	}
	test_field_numServ();
	fn test_field_servList() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcfServBlockListParam>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).servList) as usize - ptr as usize
		           },
		           4usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalNfcfServBlockListParam),
			"::",
			stringify!(servList)
		)
		);
	}
	test_field_servList();
	fn test_field_numBlock() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcfServBlockListParam>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).numBlock) as usize - ptr as usize
		           },
		           8usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalNfcfServBlockListParam),
			"::",
			stringify!(numBlock)
		)
		);
	}
	test_field_numBlock();
	fn test_field_blockList() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcfServBlockListParam>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).blockList) as usize - ptr as usize
		           },
		           12usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalNfcfServBlockListParam),
			"::",
			stringify!(blockList)
		)
		);
	}
	test_field_blockList();
}
extern "C" {
	#[doc = " \\brief  Initialize NFC-F Poller mode"]
	#[doc = ""]
	#[doc = " This methods configures RFAL RF layer to perform as a"]
	#[doc = " NFC-F Poller/RW (FeliCa PCD) including all default timings"]
	#[doc = ""]
	#[doc = " \\param[in]  bitRate      : NFC-F bitrate to be initialize (212 or 424)"]
	#[doc = ""]
	#[doc = " \\return ERR_WRONG_STATE  : RFAL not initialized or mode not set"]
	#[doc = " \\return ERR_PARAM        : Incorrect bitrate"]
	#[doc = " \\return ERR_NONE         : No error"]
	#[doc = ""]
	pub fn rfalNfcfPollerInitialize(bitRate: rfalBitRate) -> ReturnCode;
}
extern "C" {
	#[doc = "  \\brief NFC-F Poller Check Presence"]
	#[doc = ""]
	#[doc = "  This function sends a Poll/SENSF command according to NFC Activity spec"]
	#[doc = "  It detects if a NCF-F device is within range"]
	#[doc = ""]
	#[doc = " \\return ERR_WRONG_STATE  : RFAL not initialized or incorrect mode"]
	#[doc = " \\return ERR_PARAM        : Invalid parameters"]
	#[doc = " \\return ERR_IO           : Generic internal error"]
	#[doc = " \\return ERR_CRC          : CRC error detected"]
	#[doc = " \\return ERR_FRAMING      : Framing error detected"]
	#[doc = " \\return ERR_PROTO        : Protocol error detected"]
	#[doc = " \\return ERR_TIMEOUT      : Timeout error, no listener device detected"]
	#[doc = " \\return ERR_NONE         : No error and some NFC-F device was detected"]
	#[doc = ""]
	#[doc = ""]
	pub fn rfalNfcfPollerCheckPresence() -> ReturnCode;
}
extern "C" {
	#[doc = " \\brief NFC-F Poller Poll"]
	#[doc = ""]
	#[doc = " This function sends to all PICCs in field the POLL command with the given"]
	#[doc = " number of slots."]
	#[doc = ""]
	#[doc = " \\param[in]  slots      : the number of slots to be performed"]
	#[doc = " \\param[in]  sysCode    : as given in FeliCa poll command"]
	#[doc = " \\param[in]  reqCode    : FeliCa communication parameters"]
	#[doc = " \\param[out] cardList   : Parameter of type rfalFeliCaPollRes which will hold the cards found"]
	#[doc = " \\param[out] devCnt     : actual number of cards found"]
	#[doc = " \\param[out] collisions : number of collisions encountered"]
	#[doc = ""]
	#[doc = " \\warning the list cardList has to be as big as the number of slots for the Poll"]
	#[doc = ""]
	#[doc = " \\return ERR_WRONG_STATE  : RFAL not initialized or incorrect mode"]
	#[doc = " \\return ERR_PARAM        : Invalid parameters"]
	#[doc = " \\return ERR_IO           : Generic internal error"]
	#[doc = " \\return ERR_CRC          : CRC error detected"]
	#[doc = " \\return ERR_FRAMING      : Framing error detected"]
	#[doc = " \\return ERR_PROTO        : Protocol error detected"]
	#[doc = " \\return ERR_TIMEOUT      : Timeout error, no listener device detected"]
	#[doc = " \\return ERR_NONE         : No error and some NFC-F device was detected"]
	#[doc = ""]
	#[doc = ""]
	pub fn rfalNfcfPollerPoll(slots: rfalFeliCaPollSlots,
	                          sysCode: u16,
	                          reqCode: u8,
	                          cardList: *mut rfalFeliCaPollRes,
	                          devCnt: *mut u8,
	                          collisions: *mut u8)
	                          -> ReturnCode;
}
extern "C" {
	#[doc = " \\brief  NFC-F Poller Full Collision Resolution"]
	#[doc = ""]
	#[doc = " Performs a full Collision resolution as defined in Activity 1.1  9.3.4"]
	#[doc = ""]
	#[doc = " \\param[in]  compMode    : compliance mode to be performed"]
	#[doc = " \\param[in]  devLimit    : device limit value, and size nfcaDevList"]
	#[doc = " \\param[out] nfcfDevList : NFC-F listener devices list"]
	#[doc = " \\param[out] devCnt      : Devices found counter"]
	#[doc = ""]
	#[doc = " \\return ERR_WRONG_STATE  : RFAL not initialized or mode not set"]
	#[doc = " \\return ERR_PARAM        : Invalid parameters"]
	#[doc = " \\return ERR_IO           : Generic internal error"]
	#[doc = " \\return ERR_NONE         : No error"]
	#[doc = ""]
	pub fn rfalNfcfPollerCollisionResolution(compMode: rfalComplianceMode,
	                                         devLimit: u8,
	                                         nfcfDevList: *mut rfalNfcfListenDevice,
	                                         devCnt: *mut u8)
	                                         -> ReturnCode;
}
extern "C" {
	#[doc = " \\brief  NFC-F Poller Check/Read"]
	#[doc = ""]
	#[doc = " It computes a Check / Read command accoring to T3T 1.0 and JIS X6319-4 and"]
	#[doc = " sends it to PICC. If sucessfully, the rxBuf will contain the the number of"]
	#[doc = " blocks in the first byte followed by the blocks data."]
	#[doc = ""]
	#[doc = " \\param[in]  nfcid2      : nfcid2 of the device"]
	#[doc = " \\param[in]  servBlock   : parameter containing the list of Services and"]
	#[doc = "                           Blocks to be addressed by this command"]
	#[doc = " \\param[out] rxBuf       : buffer to place check/read data"]
	#[doc = " \\param[in]  rxBufLen    : size of the rxBuf"]
	#[doc = " \\param[out] rcvdLen     : length of data placed in rxBuf"]
	#[doc = ""]
	#[doc = " \\return ERR_WRONG_STATE  : RFAL not initialized or mode not set"]
	#[doc = " \\return ERR_PARAM        : Invalid parameters"]
	#[doc = " \\return ERR_IO           : Generic internal error"]
	#[doc = " \\return ERR_REQUEST      : The request was executed with error"]
	#[doc = " \\return ERR_NONE         : No error"]
	#[doc = ""]
	pub fn rfalNfcfPollerCheck(nfcid2: *const u8,
	                           servBlock: *const rfalNfcfServBlockListParam,
	                           rxBuf: *mut u8,
	                           rxBufLen: u16,
	                           rcvdLen: *mut u16)
	                           -> ReturnCode;
}
extern "C" {
	#[doc = " \\brief  NFC-F Poller Update/Write"]
	#[doc = ""]
	#[doc = " It computes a Update / Write command accoring to T3T 1.0 and JIS X6319-4 and"]
	#[doc = " sends it to PICC."]
	#[doc = ""]
	#[doc = " \\param[in]  nfcid2      : nfcid2 of the device"]
	#[doc = " \\param[in]  servBlock   : parameter containing the list of Services and"]
	#[doc = "                           Blocks to be addressed by this command"]
	#[doc = " \\param[in]  txBuf       : buffer where the request will be composed"]
	#[doc = " \\param[in]  txBufLen    : size of txBuf"]
	#[doc = " \\param[in]  blockData   : data to written on the given block(s)"]
	#[doc = " \\param[out] rxBuf       : buffer to place check/read data"]
	#[doc = " \\param[in]  rxBufLen    : size of the rxBuf"]
	#[doc = ""]
	#[doc = " \\return ERR_WRONG_STATE  : RFAL not initialized or mode not set"]
	#[doc = " \\return ERR_PARAM        : Invalid parameters"]
	#[doc = " \\return ERR_IO           : Generic internal error"]
	#[doc = " \\return ERR_REQUEST      : The request was executed with error"]
	#[doc = " \\return ERR_NONE         : No error"]
	#[doc = ""]
	pub fn rfalNfcfPollerUpdate(nfcid2: *const u8,
	                            servBlock: *const rfalNfcfServBlockListParam,
	                            txBuf: *mut u8,
	                            txBufLen: u16,
	                            blockData: *const u8,
	                            rxBuf: *mut u8,
	                            rxBufLen: u16)
	                            -> ReturnCode;
}
extern "C" {
	#[doc = " \\brief NFC-F Listener is T3T Request"]
	#[doc = ""]
	#[doc = " This method checks if the given data is a valid T3T command (Read or Write)"]
	#[doc = " and in case a valid request has been received it may output the request's NFCID2"]
	#[doc = ""]
	#[doc = " \\param[in]   buf : buffer holding Initiator's received command"]
	#[doc = " \\param[in]   bufLen : length of received command in bytes"]
	#[doc = " \\param[out]  nfcid2 : pointer to where the NFCID2 may be outputed,"]
	#[doc = "                       nfcid2 has NFCF_SENSF_NFCID2_LEN as length"]
	#[doc = "                       Pass NULL if output parameter not desired"]
	#[doc = ""]
	#[doc = " \\return true  : Valid T3T command (Read or Write) received"]
	#[doc = " \\return false : Invalid protocol request"]
	#[doc = ""]
	#[doc = ""]
	pub fn rfalNfcfListenerIsT3TReq(buf: *const u8, bufLen: u16, nfcid2: *mut u8) -> bool;
}
pub const RFAL_NFCV_REQ_FLAG_DEFAULT: _bindgen_ty_5 = _bindgen_ty_5::RFAL_NFCV_REQ_FLAG_DEFAULT;
pub const RFAL_NFCV_REQ_FLAG_SUB_CARRIER: _bindgen_ty_5 = _bindgen_ty_5::RFAL_NFCV_REQ_FLAG_SUB_CARRIER;
pub const RFAL_NFCV_REQ_FLAG_DATA_RATE: _bindgen_ty_5 = _bindgen_ty_5::RFAL_NFCV_REQ_FLAG_DEFAULT;
pub const RFAL_NFCV_REQ_FLAG_INVENTORY: _bindgen_ty_5 = _bindgen_ty_5::RFAL_NFCV_REQ_FLAG_INVENTORY;
pub const RFAL_NFCV_REQ_FLAG_PROTOCOL_EXT: _bindgen_ty_5 = _bindgen_ty_5::RFAL_NFCV_REQ_FLAG_PROTOCOL_EXT;
pub const RFAL_NFCV_REQ_FLAG_SELECT: _bindgen_ty_5 = _bindgen_ty_5::RFAL_NFCV_REQ_FLAG_SELECT;
pub const RFAL_NFCV_REQ_FLAG_ADDRESS: _bindgen_ty_5 = _bindgen_ty_5::RFAL_NFCV_REQ_FLAG_ADDRESS;
pub const RFAL_NFCV_REQ_FLAG_OPTION: _bindgen_ty_5 = _bindgen_ty_5::RFAL_NFCV_REQ_FLAG_OPTION;
pub const RFAL_NFCV_REQ_FLAG_RFU: _bindgen_ty_5 = _bindgen_ty_5::RFAL_NFCV_REQ_FLAG_RFU;
pub const RFAL_NFCV_REQ_FLAG_AFI: _bindgen_ty_5 = _bindgen_ty_5::RFAL_NFCV_REQ_FLAG_SELECT;
pub const RFAL_NFCV_REQ_FLAG_NB_SLOTS: _bindgen_ty_5 = _bindgen_ty_5::RFAL_NFCV_REQ_FLAG_ADDRESS;
#[repr(u32)]
#[non_exhaustive]
#[doc = " NFC-V RequestFlags   ISO15693 2000 7.3.1"]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum _bindgen_ty_5 {
	RFAL_NFCV_REQ_FLAG_DEFAULT = 2,
	RFAL_NFCV_REQ_FLAG_SUB_CARRIER = 1,
	RFAL_NFCV_REQ_FLAG_INVENTORY = 4,
	RFAL_NFCV_REQ_FLAG_PROTOCOL_EXT = 8,
	RFAL_NFCV_REQ_FLAG_SELECT = 16,
	RFAL_NFCV_REQ_FLAG_ADDRESS = 32,
	RFAL_NFCV_REQ_FLAG_OPTION = 64,
	RFAL_NFCV_REQ_FLAG_RFU = 128,
}
pub const RFAL_NFCV_RES_FLAG_ERROR: _bindgen_ty_6 = _bindgen_ty_6::RFAL_NFCV_RES_FLAG_ERROR;
pub const RFAL_NFCV_RES_FLAG_RFU1: _bindgen_ty_6 = _bindgen_ty_6::RFAL_NFCV_RES_FLAG_RFU1;
pub const RFAL_NFCV_RES_FLAG_RFU2: _bindgen_ty_6 = _bindgen_ty_6::RFAL_NFCV_RES_FLAG_RFU2;
pub const RFAL_NFCV_RES_FLAG_EXTENSION: _bindgen_ty_6 = _bindgen_ty_6::RFAL_NFCV_RES_FLAG_EXTENSION;
pub const RFAL_NFCV_RES_FLAG_RFU3: _bindgen_ty_6 = _bindgen_ty_6::RFAL_NFCV_RES_FLAG_RFU3;
pub const RFAL_NFCV_RES_FLAG_RFU4: _bindgen_ty_6 = _bindgen_ty_6::RFAL_NFCV_RES_FLAG_RFU4;
pub const RFAL_NFCV_RES_FLAG_RFU5: _bindgen_ty_6 = _bindgen_ty_6::RFAL_NFCV_RES_FLAG_RFU5;
pub const RFAL_NFCV_RES_FLAG_RFU6: _bindgen_ty_6 = _bindgen_ty_6::RFAL_NFCV_RES_FLAG_RFU6;
#[repr(u32)]
#[non_exhaustive]
#[doc = " NFC-V Response Flags   ISO15693 2000 7.4.1"]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum _bindgen_ty_6 {
	RFAL_NFCV_RES_FLAG_ERROR = 1,
	RFAL_NFCV_RES_FLAG_RFU1 = 2,
	RFAL_NFCV_RES_FLAG_RFU2 = 4,
	RFAL_NFCV_RES_FLAG_EXTENSION = 8,
	RFAL_NFCV_RES_FLAG_RFU3 = 16,
	RFAL_NFCV_RES_FLAG_RFU4 = 32,
	RFAL_NFCV_RES_FLAG_RFU5 = 64,
	RFAL_NFCV_RES_FLAG_RFU6 = 128,
}
pub const RFAL_NFCV_ERROR_CMD_NOT_SUPPORTED: _bindgen_ty_7 = _bindgen_ty_7::RFAL_NFCV_ERROR_CMD_NOT_SUPPORTED;
pub const RFAL_NFCV_ERROR_CMD_NOT_RECOGNIZED: _bindgen_ty_7 = _bindgen_ty_7::RFAL_NFCV_ERROR_CMD_NOT_RECOGNIZED;
pub const RFAL_NFCV_ERROR_OPTION_NOT_SUPPORTED: _bindgen_ty_7 = _bindgen_ty_7::RFAL_NFCV_ERROR_OPTION_NOT_SUPPORTED;
pub const RFAL_NFCV_ERROR_UNKNOWN: _bindgen_ty_7 = _bindgen_ty_7::RFAL_NFCV_ERROR_UNKNOWN;
pub const RFAL_NFCV_ERROR_BLOCK_NOT_AVALIABLE: _bindgen_ty_7 = _bindgen_ty_7::RFAL_NFCV_ERROR_BLOCK_NOT_AVALIABLE;
pub const RFAL_NFCV_ERROR_BLOCK_ALREDY_LOCKED: _bindgen_ty_7 = _bindgen_ty_7::RFAL_NFCV_ERROR_BLOCK_ALREDY_LOCKED;
pub const RFAL_NFCV_ERROR_BLOCK_LOCKED: _bindgen_ty_7 = _bindgen_ty_7::RFAL_NFCV_ERROR_BLOCK_LOCKED;
pub const RFAL_NFCV_ERROR_WRITE_FAILED: _bindgen_ty_7 = _bindgen_ty_7::RFAL_NFCV_ERROR_WRITE_FAILED;
pub const RFAL_NFCV_ERROR_BLOCK_FAILED: _bindgen_ty_7 = _bindgen_ty_7::RFAL_NFCV_ERROR_BLOCK_FAILED;
#[repr(u32)]
#[non_exhaustive]
#[doc = " NFC-V Error code  ISO15693 2000 7.4.2"]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum _bindgen_ty_7 {
	RFAL_NFCV_ERROR_CMD_NOT_SUPPORTED = 1,
	RFAL_NFCV_ERROR_CMD_NOT_RECOGNIZED = 2,
	RFAL_NFCV_ERROR_OPTION_NOT_SUPPORTED = 3,
	RFAL_NFCV_ERROR_UNKNOWN = 15,
	RFAL_NFCV_ERROR_BLOCK_NOT_AVALIABLE = 16,
	RFAL_NFCV_ERROR_BLOCK_ALREDY_LOCKED = 17,
	RFAL_NFCV_ERROR_BLOCK_LOCKED = 18,
	RFAL_NFCV_ERROR_WRITE_FAILED = 19,
	RFAL_NFCV_ERROR_BLOCK_FAILED = 20,
}
pub const RFAL_NFCV_CMD_INVENTORY: _bindgen_ty_8 = _bindgen_ty_8::RFAL_NFCV_CMD_INVENTORY;
pub const RFAL_NFCV_CMD_SLPV: _bindgen_ty_8 = _bindgen_ty_8::RFAL_NFCV_CMD_SLPV;
pub const RFAL_NFCV_CMD_READ_SINGLE_BLOCK: _bindgen_ty_8 = _bindgen_ty_8::RFAL_NFCV_CMD_READ_SINGLE_BLOCK;
pub const RFAL_NFCV_CMD_WRITE_SINGLE_BLOCK: _bindgen_ty_8 = _bindgen_ty_8::RFAL_NFCV_CMD_WRITE_SINGLE_BLOCK;
pub const RFAL_NFCV_CMD_LOCK_BLOCK: _bindgen_ty_8 = _bindgen_ty_8::RFAL_NFCV_CMD_LOCK_BLOCK;
pub const RFAL_NFCV_CMD_READ_MULTIPLE_BLOCKS: _bindgen_ty_8 = _bindgen_ty_8::RFAL_NFCV_CMD_READ_MULTIPLE_BLOCKS;
pub const RFAL_NFCV_CMD_WRITE_MULTIPLE_BLOCKS: _bindgen_ty_8 = _bindgen_ty_8::RFAL_NFCV_CMD_WRITE_MULTIPLE_BLOCKS;
pub const RFAL_NFCV_CMD_SELECT: _bindgen_ty_8 = _bindgen_ty_8::RFAL_NFCV_CMD_SELECT;
pub const RFAL_NFCV_CMD_RESET_TO_READY: _bindgen_ty_8 = _bindgen_ty_8::RFAL_NFCV_CMD_RESET_TO_READY;
pub const RFAL_NFCV_CMD_GET_SYS_INFO: _bindgen_ty_8 = _bindgen_ty_8::RFAL_NFCV_CMD_GET_SYS_INFO;
pub const RFAL_NFCV_CMD_EXTENDED_READ_SINGLE_BLOCK: _bindgen_ty_8 = _bindgen_ty_8::RFAL_NFCV_CMD_EXTENDED_READ_SINGLE_BLOCK;
pub const RFAL_NFCV_CMD_EXTENDED_WRITE_SINGLE_BLOCK: _bindgen_ty_8 = _bindgen_ty_8::RFAL_NFCV_CMD_EXTENDED_WRITE_SINGLE_BLOCK;
pub const RFAL_NFCV_CMD_EXTENDED_LOCK_SINGLE_BLOCK: _bindgen_ty_8 = _bindgen_ty_8::RFAL_NFCV_CMD_EXTENDED_LOCK_SINGLE_BLOCK;
pub const RFAL_NFCV_CMD_EXTENDED_READ_MULTIPLE_BLOCK: _bindgen_ty_8 = _bindgen_ty_8::RFAL_NFCV_CMD_EXTENDED_READ_MULTIPLE_BLOCK;
pub const RFAL_NFCV_CMD_EXTENDED_WRITE_MULTIPLE_BLOCK: _bindgen_ty_8 = _bindgen_ty_8::RFAL_NFCV_CMD_EXTENDED_WRITE_MULTIPLE_BLOCK;
pub const RFAL_NFCV_CMD_EXTENDED_GET_SYS_INFO: _bindgen_ty_8 = _bindgen_ty_8::RFAL_NFCV_CMD_EXTENDED_GET_SYS_INFO;
#[repr(u32)]
#[non_exhaustive]
#[doc = " NFC-V command set   ISO15693 2000 9.1"]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum _bindgen_ty_8 {
	RFAL_NFCV_CMD_INVENTORY = 1,
	RFAL_NFCV_CMD_SLPV = 2,
	RFAL_NFCV_CMD_READ_SINGLE_BLOCK = 32,
	RFAL_NFCV_CMD_WRITE_SINGLE_BLOCK = 33,
	RFAL_NFCV_CMD_LOCK_BLOCK = 34,
	RFAL_NFCV_CMD_READ_MULTIPLE_BLOCKS = 35,
	RFAL_NFCV_CMD_WRITE_MULTIPLE_BLOCKS = 36,
	RFAL_NFCV_CMD_SELECT = 37,
	RFAL_NFCV_CMD_RESET_TO_READY = 38,
	RFAL_NFCV_CMD_GET_SYS_INFO = 43,
	RFAL_NFCV_CMD_EXTENDED_READ_SINGLE_BLOCK = 48,
	RFAL_NFCV_CMD_EXTENDED_WRITE_SINGLE_BLOCK = 49,
	RFAL_NFCV_CMD_EXTENDED_LOCK_SINGLE_BLOCK = 50,
	RFAL_NFCV_CMD_EXTENDED_READ_MULTIPLE_BLOCK = 51,
	RFAL_NFCV_CMD_EXTENDED_WRITE_MULTIPLE_BLOCK = 52,
	RFAL_NFCV_CMD_EXTENDED_GET_SYS_INFO = 59,
}
pub const RFAL_NFCV_CMD_READ_CONFIGURATION: _bindgen_ty_9 = _bindgen_ty_9::RFAL_NFCV_CMD_READ_CONFIGURATION;
pub const RFAL_NFCV_CMD_WRITE_CONFIGURATION: _bindgen_ty_9 = _bindgen_ty_9::RFAL_NFCV_CMD_WRITE_CONFIGURATION;
pub const RFAL_NFCV_CMD_SET_EAS: _bindgen_ty_9 = _bindgen_ty_9::RFAL_NFCV_CMD_SET_EAS;
pub const RFAL_NFCV_CMD_RESET_EAS: _bindgen_ty_9 = _bindgen_ty_9::RFAL_NFCV_CMD_RESET_EAS;
pub const RFAL_NFCV_CMD_LOCK_EAS: _bindgen_ty_9 = _bindgen_ty_9::RFAL_NFCV_CMD_LOCK_EAS;
pub const RFAL_NFCV_CMD_ENABLE_EAS: _bindgen_ty_9 = _bindgen_ty_9::RFAL_NFCV_CMD_ENABLE_EAS;
pub const RFAL_NFCV_CMD_KILL: _bindgen_ty_9 = _bindgen_ty_9::RFAL_NFCV_CMD_KILL;
pub const RFAL_NFCV_CMD_WRITE_EAS_ID: _bindgen_ty_9 = _bindgen_ty_9::RFAL_NFCV_CMD_WRITE_EAS_ID;
pub const RFAL_NFCV_CMD_WRITE_EAS_CONFIG: _bindgen_ty_9 = _bindgen_ty_9::RFAL_NFCV_CMD_WRITE_EAS_CONFIG;
pub const RFAL_NFCV_CMD_MANAGE_GPO: _bindgen_ty_9 = _bindgen_ty_9::RFAL_NFCV_CMD_MANAGE_GPO;
pub const RFAL_NFCV_CMD_WRITE_MESSAGE: _bindgen_ty_9 = _bindgen_ty_9::RFAL_NFCV_CMD_WRITE_MESSAGE;
pub const RFAL_NFCV_CMD_READ_MESSAGE_LENGTH: _bindgen_ty_9 = _bindgen_ty_9::RFAL_NFCV_CMD_READ_MESSAGE_LENGTH;
pub const RFAL_NFCV_CMD_READ_MESSAGE: _bindgen_ty_9 = _bindgen_ty_9::RFAL_NFCV_CMD_READ_MESSAGE;
pub const RFAL_NFCV_CMD_READ_DYN_CONFIGURATION: _bindgen_ty_9 = _bindgen_ty_9::RFAL_NFCV_CMD_READ_DYN_CONFIGURATION;
pub const RFAL_NFCV_CMD_WRITE_DYN_CONFIGURATION: _bindgen_ty_9 = _bindgen_ty_9::RFAL_NFCV_CMD_WRITE_DYN_CONFIGURATION;
pub const RFAL_NFCV_CMD_WRITE_PASSWORD: _bindgen_ty_9 = _bindgen_ty_9::RFAL_NFCV_CMD_WRITE_PASSWORD;
pub const RFAL_NFCV_CMD_LOCK_KILL: _bindgen_ty_9 = _bindgen_ty_9::RFAL_NFCV_CMD_LOCK_KILL;
pub const RFAL_NFCV_CMD_PRESENT_PASSWORD: _bindgen_ty_9 = _bindgen_ty_9::RFAL_NFCV_CMD_PRESENT_PASSWORD;
pub const RFAL_NFCV_CMD_GET_RANDOM_NUMBER: _bindgen_ty_9 = _bindgen_ty_9::RFAL_NFCV_CMD_GET_RANDOM_NUMBER;
pub const RFAL_NFCV_CMD_FAST_READ_SINGLE_BLOCK: _bindgen_ty_9 = _bindgen_ty_9::RFAL_NFCV_CMD_FAST_READ_SINGLE_BLOCK;
pub const RFAL_NFCV_CMD_FAST_READ_MULTIPLE_BLOCKS: _bindgen_ty_9 = _bindgen_ty_9::RFAL_NFCV_CMD_FAST_READ_MULTIPLE_BLOCKS;
pub const RFAL_NFCV_CMD_FAST_EXTENDED_READ_SINGLE_BLOCK: _bindgen_ty_9 = _bindgen_ty_9::RFAL_NFCV_CMD_FAST_EXTENDED_READ_SINGLE_BLOCK;
pub const RFAL_NFCV_CMD_FAST_EXTENDED_READ_MULTIPLE_BLOCKS: _bindgen_ty_9 =
	_bindgen_ty_9::RFAL_NFCV_CMD_FAST_EXTENDED_READ_MULTIPLE_BLOCKS;
pub const RFAL_NFCV_CMD_FAST_WRITE_MESSAGE: _bindgen_ty_9 = _bindgen_ty_9::RFAL_NFCV_CMD_FAST_WRITE_MESSAGE;
pub const RFAL_NFCV_CMD_FAST_READ_MESSAGE_LENGTH: _bindgen_ty_9 = _bindgen_ty_9::RFAL_NFCV_CMD_FAST_READ_MESSAGE_LENGTH;
pub const RFAL_NFCV_CMD_FAST_READ_MESSAGE: _bindgen_ty_9 = _bindgen_ty_9::RFAL_NFCV_CMD_FAST_READ_MESSAGE;
pub const RFAL_NFCV_CMD_FAST_READ_DYN_CONFIGURATION: _bindgen_ty_9 = _bindgen_ty_9::RFAL_NFCV_CMD_FAST_READ_DYN_CONFIGURATION;
pub const RFAL_NFCV_CMD_FAST_WRITE_DYN_CONFIGURATION: _bindgen_ty_9 = _bindgen_ty_9::RFAL_NFCV_CMD_FAST_WRITE_DYN_CONFIGURATION;
#[repr(u32)]
#[non_exhaustive]
#[doc = " ST25TV/ST25DV command set"]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum _bindgen_ty_9 {
	RFAL_NFCV_CMD_READ_CONFIGURATION = 160,
	RFAL_NFCV_CMD_WRITE_CONFIGURATION = 161,
	RFAL_NFCV_CMD_SET_EAS = 162,
	RFAL_NFCV_CMD_RESET_EAS = 163,
	RFAL_NFCV_CMD_LOCK_EAS = 164,
	RFAL_NFCV_CMD_ENABLE_EAS = 165,
	#[doc = "< Kill command"]
	RFAL_NFCV_CMD_KILL = 166,
	RFAL_NFCV_CMD_WRITE_EAS_ID = 167,
	RFAL_NFCV_CMD_WRITE_EAS_CONFIG = 168,
	RFAL_NFCV_CMD_MANAGE_GPO = 169,
	RFAL_NFCV_CMD_WRITE_MESSAGE = 170,
	RFAL_NFCV_CMD_READ_MESSAGE_LENGTH = 171,
	RFAL_NFCV_CMD_READ_MESSAGE = 172,
	RFAL_NFCV_CMD_READ_DYN_CONFIGURATION = 173,
	RFAL_NFCV_CMD_WRITE_DYN_CONFIGURATION = 174,
	RFAL_NFCV_CMD_WRITE_PASSWORD = 177,
	RFAL_NFCV_CMD_LOCK_KILL = 178,
	RFAL_NFCV_CMD_PRESENT_PASSWORD = 179,
	RFAL_NFCV_CMD_GET_RANDOM_NUMBER = 180,
	RFAL_NFCV_CMD_FAST_READ_SINGLE_BLOCK = 192,
	RFAL_NFCV_CMD_FAST_READ_MULTIPLE_BLOCKS = 195,
	RFAL_NFCV_CMD_FAST_EXTENDED_READ_SINGLE_BLOCK = 196,
	RFAL_NFCV_CMD_FAST_EXTENDED_READ_MULTIPLE_BLOCKS = 197,
	RFAL_NFCV_CMD_FAST_WRITE_MESSAGE = 202,
	RFAL_NFCV_CMD_FAST_READ_MESSAGE_LENGTH = 203,
	RFAL_NFCV_CMD_FAST_READ_MESSAGE = 204,
	RFAL_NFCV_CMD_FAST_READ_DYN_CONFIGURATION = 205,
	RFAL_NFCV_CMD_FAST_WRITE_DYN_CONFIGURATION = 206,
}
pub const RFAL_NFCV_SYSINFO_DFSID: _bindgen_ty_10 = _bindgen_ty_10::RFAL_NFCV_SYSINFO_DFSID;
pub const RFAL_NFCV_SYSINFO_AFI: _bindgen_ty_10 = _bindgen_ty_10::RFAL_NFCV_SYSINFO_AFI;
pub const RFAL_NFCV_SYSINFO_MEMSIZE: _bindgen_ty_10 = _bindgen_ty_10::RFAL_NFCV_SYSINFO_MEMSIZE;
pub const RFAL_NFCV_SYSINFO_ICREF: _bindgen_ty_10 = _bindgen_ty_10::RFAL_NFCV_SYSINFO_ICREF;
pub const RFAL_NFCV_SYSINFO_MOI: _bindgen_ty_10 = _bindgen_ty_10::RFAL_NFCV_SYSINFO_MOI;
pub const RFAL_NFCV_SYSINFO_CMDLIST: _bindgen_ty_10 = _bindgen_ty_10::RFAL_NFCV_SYSINFO_CMDLIST;
pub const RFAL_NFCV_SYSINFO_CSI: _bindgen_ty_10 = _bindgen_ty_10::RFAL_NFCV_SYSINFO_CSI;
pub const RFAL_NFCV_SYSINFO_REQ_ALL: _bindgen_ty_10 = _bindgen_ty_10::RFAL_NFCV_SYSINFO_REQ_ALL;
#[repr(u32)]
#[non_exhaustive]
#[doc = " ISO 15693 Get System info parameter request field ISO15693 2018 Table 94"]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum _bindgen_ty_10 {
	RFAL_NFCV_SYSINFO_DFSID = 1,
	RFAL_NFCV_SYSINFO_AFI = 2,
	RFAL_NFCV_SYSINFO_MEMSIZE = 4,
	RFAL_NFCV_SYSINFO_ICREF = 8,
	RFAL_NFCV_SYSINFO_MOI = 16,
	RFAL_NFCV_SYSINFO_CMDLIST = 32,
	RFAL_NFCV_SYSINFO_CSI = 64,
	RFAL_NFCV_SYSINFO_REQ_ALL = 127,
}
#[repr(u32)]
#[non_exhaustive]
#[doc = " NFC-V Number of slots  Digital 2.0  9.6.1"]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum rfalNfcvNumSlots {
	#[doc = "< Number of slots: 1"]
	RFAL_NFCV_NUM_SLOTS_1 = 32,
	#[doc = "< Number of slots: 16"]
	RFAL_NFCV_NUM_SLOTS_16 = 0,
}
#[doc = " NFC-V INVENTORY_RES format   Digital 2.0  9.6.2"]
#[repr(C)]
pub struct rfalNfcvInventoryRes {
	#[doc = "< Response Flags"]
	pub RES_FLAG: u8,
	#[doc = "< Data Storage Format Identifier"]
	pub DSFID: u8,
	#[doc = "< NFC-V device UID"]
	pub UID: [u8; 8usize],
	#[doc = "< CRC"]
	pub crc: [u8; 2usize],
}
#[test]
fn bindgen_test_layout_rfalNfcvInventoryRes() {
	assert_eq!(
	           ::core::mem::size_of::<rfalNfcvInventoryRes>(),
	           12usize,
	           concat!("Size of: ", stringify!(rfalNfcvInventoryRes))
	);
	assert_eq!(
	           ::core::mem::align_of::<rfalNfcvInventoryRes>(),
	           1usize,
	           concat!("Alignment of ", stringify!(rfalNfcvInventoryRes))
	);
	fn test_field_RES_FLAG() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcvInventoryRes>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).RES_FLAG) as usize - ptr as usize
		           },
		           0usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalNfcvInventoryRes),
			"::",
			stringify!(RES_FLAG)
		)
		);
	}
	test_field_RES_FLAG();
	fn test_field_DSFID() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcvInventoryRes>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).DSFID) as usize - ptr as usize
		           },
		           1usize,
		           concat!("Offset of field: ", stringify!(rfalNfcvInventoryRes), "::", stringify!(DSFID))
		);
	}
	test_field_DSFID();
	fn test_field_UID() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcvInventoryRes>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).UID) as usize - ptr as usize
		           },
		           2usize,
		           concat!("Offset of field: ", stringify!(rfalNfcvInventoryRes), "::", stringify!(UID))
		);
	}
	test_field_UID();
	fn test_field_crc() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcvInventoryRes>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).crc) as usize - ptr as usize
		           },
		           10usize,
		           concat!("Offset of field: ", stringify!(rfalNfcvInventoryRes), "::", stringify!(crc))
		);
	}
	test_field_crc();
}
#[doc = " NFC-V Generic Req format"]
#[repr(C)]
pub struct rfalNfcvGenericReq {
	#[doc = "< Request Flags"]
	pub REQ_FLAG: u8,
	#[doc = "< Command code"]
	pub CMD: u8,
	#[doc = "< Payload"]
	pub payload: rfalNfcvGenericReq__bindgen_ty_1,
}
#[repr(C)]
pub struct rfalNfcvGenericReq__bindgen_ty_1 {
	#[doc = "< Mask Value"]
	pub UID: __BindgenUnionField<[u8; 8usize]>,
	#[doc = "< Data"]
	pub data: __BindgenUnionField<[u8; 41usize]>,
	pub bindgen_union_field: [u8; 41usize],
}
#[test]
fn bindgen_test_layout_rfalNfcvGenericReq__bindgen_ty_1() {
	assert_eq!(
	           ::core::mem::size_of::<rfalNfcvGenericReq__bindgen_ty_1>(),
	           41usize,
	           concat!("Size of: ", stringify!(rfalNfcvGenericReq__bindgen_ty_1))
	);
	assert_eq!(
	           ::core::mem::align_of::<rfalNfcvGenericReq__bindgen_ty_1>(),
	           1usize,
	           concat!("Alignment of ", stringify!(rfalNfcvGenericReq__bindgen_ty_1))
	);
	fn test_field_UID() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcvGenericReq__bindgen_ty_1>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).UID) as usize - ptr as usize
		           },
		           0usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalNfcvGenericReq__bindgen_ty_1),
			"::",
			stringify!(UID)
		)
		);
	}
	test_field_UID();
	fn test_field_data() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcvGenericReq__bindgen_ty_1>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).data) as usize - ptr as usize
		           },
		           0usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalNfcvGenericReq__bindgen_ty_1),
			"::",
			stringify!(data)
		)
		);
	}
	test_field_data();
}
#[test]
fn bindgen_test_layout_rfalNfcvGenericReq() {
	assert_eq!(
	           ::core::mem::size_of::<rfalNfcvGenericReq>(),
	           43usize,
	           concat!("Size of: ", stringify!(rfalNfcvGenericReq))
	);
	assert_eq!(
	           ::core::mem::align_of::<rfalNfcvGenericReq>(),
	           1usize,
	           concat!("Alignment of ", stringify!(rfalNfcvGenericReq))
	);
	fn test_field_REQ_FLAG() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcvGenericReq>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).REQ_FLAG) as usize - ptr as usize
		           },
		           0usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalNfcvGenericReq),
			"::",
			stringify!(REQ_FLAG)
		)
		);
	}
	test_field_REQ_FLAG();
	fn test_field_CMD() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcvGenericReq>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).CMD) as usize - ptr as usize
		           },
		           1usize,
		           concat!("Offset of field: ", stringify!(rfalNfcvGenericReq), "::", stringify!(CMD))
		);
	}
	test_field_CMD();
	fn test_field_payload() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcvGenericReq>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).payload) as usize - ptr as usize
		           },
		           2usize,
		           concat!("Offset of field: ", stringify!(rfalNfcvGenericReq), "::", stringify!(payload))
		);
	}
	test_field_payload();
}
#[doc = " NFC-V Generic Response format"]
#[repr(C)]
pub struct rfalNfcvGenericRes {
	#[doc = "< Response Flags"]
	pub RES_FLAG: u8,
	#[doc = "< Data"]
	pub data: [u8; 41usize],
}
#[test]
fn bindgen_test_layout_rfalNfcvGenericRes() {
	assert_eq!(
	           ::core::mem::size_of::<rfalNfcvGenericRes>(),
	           42usize,
	           concat!("Size of: ", stringify!(rfalNfcvGenericRes))
	);
	assert_eq!(
	           ::core::mem::align_of::<rfalNfcvGenericRes>(),
	           1usize,
	           concat!("Alignment of ", stringify!(rfalNfcvGenericRes))
	);
	fn test_field_RES_FLAG() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcvGenericRes>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).RES_FLAG) as usize - ptr as usize
		           },
		           0usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalNfcvGenericRes),
			"::",
			stringify!(RES_FLAG)
		)
		);
	}
	test_field_RES_FLAG();
	fn test_field_data() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcvGenericRes>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).data) as usize - ptr as usize
		           },
		           1usize,
		           concat!("Offset of field: ", stringify!(rfalNfcvGenericRes), "::", stringify!(data))
		);
	}
	test_field_data();
}
#[doc = " NFC-V listener device (VICC) struct"]
#[repr(C)]
pub struct rfalNfcvListenDevice {
	#[doc = "< INVENTORY_RES"]
	pub InvRes: rfalNfcvInventoryRes,
	#[doc = "< Device sleeping flag"]
	pub isSleep: bool,
}
#[test]
fn bindgen_test_layout_rfalNfcvListenDevice() {
	assert_eq!(
	           ::core::mem::size_of::<rfalNfcvListenDevice>(),
	           13usize,
	           concat!("Size of: ", stringify!(rfalNfcvListenDevice))
	);
	assert_eq!(
	           ::core::mem::align_of::<rfalNfcvListenDevice>(),
	           1usize,
	           concat!("Alignment of ", stringify!(rfalNfcvListenDevice))
	);
	fn test_field_InvRes() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcvListenDevice>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).InvRes) as usize - ptr as usize
		           },
		           0usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalNfcvListenDevice),
			"::",
			stringify!(InvRes)
		)
		);
	}
	test_field_InvRes();
	fn test_field_isSleep() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcvListenDevice>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).isSleep) as usize - ptr as usize
		           },
		           12usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalNfcvListenDevice),
			"::",
			stringify!(isSleep)
		)
		);
	}
	test_field_isSleep();
}
extern "C" {
	#[doc = " \\brief  Initialize NFC-V Poller mode"]
	#[doc = ""]
	#[doc = " This methods configures RFAL RF layer to perform as a"]
	#[doc = " NFC-F Poller/RW (ISO15693) including all default timings"]
	#[doc = ""]
	#[doc = " \\return ERR_WRONG_STATE  : RFAL not initialized or mode not set"]
	#[doc = " \\return ERR_PARAM        : Incorrect bitrate"]
	#[doc = " \\return ERR_NONE         : No error"]
	#[doc = ""]
	pub fn rfalNfcvPollerInitialize() -> ReturnCode;
}
extern "C" {
	#[doc = " \\brief  NFC-V Poller Check Presence"]
	#[doc = ""]
	#[doc = " This method checks if a NFC-V Listen device (VICC) is present on the field"]
	#[doc = " by sending an Inventory (INVENTORY_REQ)"]
	#[doc = ""]
	#[doc = " \\param[out] invRes : If received, the INVENTORY_RES"]
	#[doc = ""]
	#[doc = " \\return ERR_WRONG_STATE  : RFAL not initialized or incorrect mode"]
	#[doc = " \\return ERR_PARAM        : Invalid parameters"]
	#[doc = " \\return ERR_IO           : Generic internal error"]
	#[doc = " \\return ERR_TIMEOUT      : Timeout error, no listener device detectedd"]
	#[doc = " \\return ERR_NONE         : No error, one or more device in the field"]
	#[doc = ""]
	pub fn rfalNfcvPollerCheckPresence(invRes: *mut rfalNfcvInventoryRes) -> ReturnCode;
}
extern "C" {
	#[doc = " \\brief NFC-F Poller Poll"]
	#[doc = ""]
	#[doc = " This function sends to all VICCs in field the INVENTORY command with the"]
	#[doc = " given number of slots"]
	#[doc = ""]
	#[doc = " If more than one slot is used the following EOF need to be handled"]
	#[doc = " by the caller using rfalISO15693TransceiveEOFAnticollision()"]
	#[doc = ""]
	#[doc = " \\param[in]  nSlots  : Number of Slots to be sent (1 or 16)"]
	#[doc = " \\param[in]  maskLen : Number bits on the Mask value"]
	#[doc = " \\param[in]  maskVal : location of the Mask value"]
	#[doc = " \\param[out] invRes  : location to place the INVENTORY_RES"]
	#[doc = " \\param[out] rcvdLen : number of bits received (without collision)"]
	#[doc = ""]
	#[doc = " \\return ERR_WRONG_STATE  : RFAL not initialized or incorrect mode"]
	#[doc = " \\return ERR_PARAM        : Invalid parameters"]
	#[doc = " \\return ERR_IO           : Generic internal error"]
	#[doc = " \\return ERR_RF_COLLISION : Collision detected"]
	#[doc = " \\return ERR_CRC          : CRC error detected"]
	#[doc = " \\return ERR_PROTO        : Protocol error detected"]
	#[doc = " \\return ERR_NONE         : No error"]
	#[doc = ""]
	pub fn rfalNfcvPollerInventory(nSlots: rfalNfcvNumSlots,
	                               maskLen: u8,
	                               maskVal: *const u8,
	                               invRes: *mut rfalNfcvInventoryRes,
	                               rcvdLen: *mut u16)
	                               -> ReturnCode;
}
extern "C" {
	#[doc = " \\brief  NFC-V Poller Full Collision Resolution"]
	#[doc = ""]
	#[doc = " Performs a full Collision resolution as defined in Activity 2.0   9.3.7"]
	#[doc = " Once done, the devCnt will indicate how many (if any) devices have"]
	#[doc = " been identified and their details are contained on nfcvDevList"]
	#[doc = ""]
	#[doc = " \\param[in]  compMode     : compliance mode to be performed"]
	#[doc = " \\param[in]  devLimit     : device limit value, and size nfcaDevList"]
	#[doc = " \\param[out] nfcvDevList  : NFC-v listener devices list"]
	#[doc = " \\param[out] devCnt       : Devices found counter"]
	#[doc = ""]
	#[doc = " When compMode is set to ISO the function immediately goes to 16 slots improving"]
	#[doc = " chances to detect more than only one strong card."]
	#[doc = ""]
	#[doc = " \\return ERR_WRONG_STATE  : RFAL not initialized or mode not set"]
	#[doc = " \\return ERR_PARAM        : Invalid parameters"]
	#[doc = " \\return ERR_IO           : Generic internal error"]
	#[doc = " \\return ERR_NONE         : No error"]
	#[doc = ""]
	pub fn rfalNfcvPollerCollisionResolution(compMode: rfalComplianceMode,
	                                         devLimit: u8,
	                                         nfcvDevList: *mut rfalNfcvListenDevice,
	                                         devCnt: *mut u8)
	                                         -> ReturnCode;
}
extern "C" {
	#[doc = " \\brief  NFC-V Poller Full Collision Resolution With Sleep"]
	#[doc = ""]
	#[doc = " Performs a full Collision resolution which is different from Activity 2.0 9.3.7."]
	#[doc = " The implementation uses SLPV (StayQuiet) command to make sure all cards are found."]
	#[doc = " Once done, the devCnt will indicate how many (if any) devices have"]
	#[doc = " been identified and their details are contained on nfcvDevList"]
	#[doc = ""]
	#[doc = " \\param[in]  devLimit     : device limit value, and size nfcaDevList"]
	#[doc = " \\param[out] nfcvDevList  : NFC-v listener devices list"]
	#[doc = " \\param[out] devCnt       : Devices found counter"]
	#[doc = ""]
	#[doc = " \\return ERR_WRONG_STATE  : RFAL not initialized or mode not set"]
	#[doc = " \\return ERR_PARAM        : Invalid parameters"]
	#[doc = " \\return ERR_IO           : Generic internal error"]
	#[doc = " \\return ERR_NONE         : No error"]
	#[doc = ""]
	pub fn rfalNfcvPollerSleepCollisionResolution(devLimit: u8, nfcvDevList: *mut rfalNfcvListenDevice, devCnt: *mut u8)
	                                              -> ReturnCode;
}
extern "C" {
	#[doc = " \\brief  NFC-V Poller Sleep"]
	#[doc = ""]
	#[doc = " This function is used to send the SLPV_REQ (Stay Quiet) command to put the VICC"]
	#[doc = " with the given UID to state QUIET so that they do not reply to more Inventory"]
	#[doc = ""]
	#[doc = " \\param[in]  flags        : Flags to be used: Sub-carrier; Data_rate; Option"]
	#[doc = "                            for NFC-Forum use: RFAL_NFCV_REQ_FLAG_DEFAULT"]
	#[doc = " \\param[in]  uid          : UID of the device to be put to Sleep"]
	#[doc = ""]
	#[doc = " \\return ERR_WRONG_STATE  : RFAL not initialized or incorrect mode"]
	#[doc = " \\return ERR_PARAM        : Invalid parameters"]
	#[doc = " \\return ERR_IO           : Generic internal error"]
	#[doc = " \\return ERR_NONE         : No error"]
	#[doc = ""]
	pub fn rfalNfcvPollerSleep(flags: u8, uid: *const u8) -> ReturnCode;
}
extern "C" {
	#[doc = " \\brief  NFC-V Poller Select"]
	#[doc = ""]
	#[doc = " Selects a device (VICC) by its UID"]
	#[doc = ""]
	#[doc = " \\param[in]  flags        : Flags to be used: Sub-carrier; Data_rate; Option"]
	#[doc = "                            for NFC-Forum use: RFAL_NFCV_REQ_FLAG_DEFAULT"]
	#[doc = " \\param[in]  uid          : UID of the device to be put to be Selected"]
	#[doc = ""]
	#[doc = " \\return ERR_WRONG_STATE  : RFAL not initialized or incorrect mode"]
	#[doc = " \\return ERR_PARAM        : Invalid parameters"]
	#[doc = " \\return ERR_IO           : Generic internal error"]
	#[doc = " \\return ERR_CRC          : CRC error detected"]
	#[doc = " \\return ERR_FRAMING      : Framing error detected"]
	#[doc = " \\return ERR_PROTO        : Protocol error detected"]
	#[doc = " \\return ERR_TIMEOUT      : Timeout error"]
	#[doc = " \\return ERR_NONE         : No error"]
	#[doc = ""]
	pub fn rfalNfcvPollerSelect(flags: u8, uid: *const u8) -> ReturnCode;
}
extern "C" {
	#[doc = " \\brief  NFC-V Poller Read Single Block"]
	#[doc = ""]
	#[doc = " Reads a Single Block from a device (VICC)"]
	#[doc = ""]
	#[doc = " \\param[in]  flags        : Flags to be used: Sub-carrier; Data_rate; Option"]
	#[doc = "                            for NFC-Forum use: RFAL_NFCV_REQ_FLAG_DEFAULT"]
	#[doc = " \\param[in]  uid          : UID of the device to be put to be read"]
	#[doc = "                             if UID is provided Addressed mode will be used"]
	#[doc = " \\param[in]  blockNum     : Number of the block to read"]
	#[doc = " \\param[out] rxBuf        : buffer to store response (also with RES_FLAGS)"]
	#[doc = " \\param[in]  rxBufLen     : length of rxBuf"]
	#[doc = " \\param[out] rcvLen       : number of bytes received"]
	#[doc = ""]
	#[doc = " \\return ERR_WRONG_STATE  : RFAL not initialized or incorrect mode"]
	#[doc = " \\return ERR_PARAM        : Invalid parameters"]
	#[doc = " \\return ERR_IO           : Generic internal error"]
	#[doc = " \\return ERR_CRC          : CRC error detected"]
	#[doc = " \\return ERR_FRAMING      : Framing error detected"]
	#[doc = " \\return ERR_PROTO        : Protocol error detected"]
	#[doc = " \\return ERR_TIMEOUT      : Timeout error"]
	#[doc = " \\return ERR_NONE         : No error"]
	#[doc = ""]
	pub fn rfalNfcvPollerReadSingleBlock(flags: u8,
	                                     uid: *const u8,
	                                     blockNum: u8,
	                                     rxBuf: *mut u8,
	                                     rxBufLen: u16,
	                                     rcvLen: *mut u16)
	                                     -> ReturnCode;
}
extern "C" {
	#[doc = " \\brief  NFC-V Poller Write Single Block"]
	#[doc = ""]
	#[doc = " Writes a Single Block from a device (VICC)"]
	#[doc = ""]
	#[doc = " \\param[in]  flags        : Flags to be used: Sub-carrier; Data_rate; Option"]
	#[doc = "                            for NFC-Forum use: RFAL_NFCV_REQ_FLAG_DEFAULT"]
	#[doc = " \\param[in]  uid          : UID of the device to be put to be written"]
	#[doc = "                             if UID is provided Addressed mode will be used"]
	#[doc = " \\param[in]  blockNum     : Number of the block to write"]
	#[doc = " \\param[in]  wrData       : data to be written on the given block"]
	#[doc = " \\param[in]  blockLen     : number of bytes of a block"]
	#[doc = ""]
	#[doc = " \\return ERR_WRONG_STATE  : RFAL not initialized or incorrect mode"]
	#[doc = " \\return ERR_PARAM        : Invalid parameters"]
	#[doc = " \\return ERR_IO           : Generic internal error"]
	#[doc = " \\return ERR_CRC          : CRC error detected"]
	#[doc = " \\return ERR_FRAMING      : Framing error detected"]
	#[doc = " \\return ERR_PROTO        : Protocol error detected"]
	#[doc = " \\return ERR_TIMEOUT      : Timeout error"]
	#[doc = " \\return ERR_NONE         : No error"]
	#[doc = ""]
	pub fn rfalNfcvPollerWriteSingleBlock(flags: u8, uid: *const u8, blockNum: u8, wrData: *const u8, blockLen: u8) -> ReturnCode;
}
extern "C" {
	#[doc = " \\brief  NFC-V Poller Read Multiple Blocks"]
	#[doc = ""]
	#[doc = " Reads Multiple Blocks from a device (VICC)"]
	#[doc = ""]
	#[doc = " \\param[in]  flags          : Flags to be used: Sub-carrier; Data_rate; Option"]
	#[doc = "                              for NFC-Forum use: RFAL_NFCV_REQ_FLAG_DEFAULT"]
	#[doc = " \\param[in]  uid            : UID of the device to be put to be read"]
	#[doc = "                               if UID is provided Addressed mode will be used"]
	#[doc = " \\param[in]  firstBlockNum  : first block to be read"]
	#[doc = " \\param[in]  numOfBlocks    : number of block to read"]
	#[doc = " \\param[out] rxBuf          : buffer to store response (also with RES_FLAGS)"]
	#[doc = " \\param[in]  rxBufLen       : length of rxBuf"]
	#[doc = " \\param[out] rcvLen         : number of bytes received"]
	#[doc = ""]
	#[doc = " \\return ERR_WRONG_STATE    : RFAL not initialized or incorrect mode"]
	#[doc = " \\return ERR_PARAM          : Invalid parameters"]
	#[doc = " \\return ERR_IO             : Generic internal error"]
	#[doc = " \\return ERR_CRC            : CRC error detected"]
	#[doc = " \\return ERR_FRAMING        : Framing error detected"]
	#[doc = " \\return ERR_PROTO          : Protocol error detected"]
	#[doc = " \\return ERR_TIMEOUT        : Timeout error"]
	#[doc = " \\return ERR_NONE           : No error"]
	#[doc = ""]
	pub fn rfalNfcvPollerReadMultipleBlocks(flags: u8,
	                                        uid: *const u8,
	                                        firstBlockNum: u8,
	                                        numOfBlocks: u8,
	                                        rxBuf: *mut u8,
	                                        rxBufLen: u16,
	                                        rcvLen: *mut u16)
	                                        -> ReturnCode;
}
extern "C" {
	#[doc = " \\brief  NFC-V Poller Write Multiple Blocks"]
	#[doc = ""]
	#[doc = " Reads Multiple Blocks from a device (VICC)"]
	#[doc = " In order to not limit the length of the Write multiple command, a buffer"]
	#[doc = " must be provided where the request will be composed and then sent."]
	#[doc = ""]
	#[doc = " \\param[in]  flags          : Flags to be used: Sub-carrier; Data_rate; Option"]
	#[doc = "                              for NFC-Forum use: RFAL_NFCV_REQ_FLAG_DEFAULT"]
	#[doc = " \\param[in]  uid            : UID of the device to be put to be read"]
	#[doc = "                               if UID is provided Addressed mode will be used"]
	#[doc = " \\param[in]  firstBlockNum  : first block to be write"]
	#[doc = " \\param[in]  numOfBlocks    : number of consecutive blocks to write"]
	#[doc = " \\param[in]  txBuf          : buffer where the request will be composed"]
	#[doc = " \\param[in]  txBufLen       : length of txBuf"]
	#[doc = " \\param[in]  blockLen       : number of bytes of a block"]
	#[doc = " \\param[in]  wrData         : data to be written"]
	#[doc = " \\param[in]  wrDataLen      : length of the data do be written. Must be"]
	#[doc = "                              aligned with number of blocks to write and"]
	#[doc = "                              the size of a block"]
	#[doc = ""]
	#[doc = " \\return ERR_WRONG_STATE    : RFAL not initialized or incorrect mode"]
	#[doc = " \\return ERR_PARAM          : Invalid parameters"]
	#[doc = " \\return ERR_IO             : Generic internal error"]
	#[doc = " \\return ERR_CRC            : CRC error detected"]
	#[doc = " \\return ERR_FRAMING        : Framing error detected"]
	#[doc = " \\return ERR_PROTO          : Protocol error detected"]
	#[doc = " \\return ERR_TIMEOUT        : Timeout error"]
	#[doc = " \\return ERR_NONE           : No error"]
	#[doc = ""]
	pub fn rfalNfcvPollerWriteMultipleBlocks(flags: u8,
	                                         uid: *const u8,
	                                         firstBlockNum: u8,
	                                         numOfBlocks: u8,
	                                         txBuf: *mut u8,
	                                         txBufLen: u16,
	                                         blockLen: u8,
	                                         wrData: *const u8,
	                                         wrDataLen: u16)
	                                         -> ReturnCode;
}
extern "C" {
	#[doc = " \\brief  NFC-V Poller Extended Lock Single Block"]
	#[doc = ""]
	#[doc = " Blocks a Single Block from a device (VICC) supporting extended commands"]
	#[doc = ""]
	#[doc = " \\param[in]  flags        : Flags to be used: Sub-carrier; Data_rate; Option"]
	#[doc = "                            for NFC-Forum use: RFAL_NFCV_REQ_FLAG_DEFAULT"]
	#[doc = " \\param[in]  uid          : UID of the device"]
	#[doc = "                             if UID is provided Addressed mode will be used"]
	#[doc = " \\param[in]  blockNum     : Number of the block to be locked"]
	#[doc = ""]
	#[doc = " \\return ERR_WRONG_STATE  : RFAL not initialized or incorrect mode"]
	#[doc = " \\return ERR_PARAM        : Invalid parameters"]
	#[doc = " \\return ERR_IO           : Generic internal error"]
	#[doc = " \\return ERR_CRC          : CRC error detected"]
	#[doc = " \\return ERR_FRAMING      : Framing error detected"]
	#[doc = " \\return ERR_PROTO        : Protocol error detected"]
	#[doc = " \\return ERR_TIMEOUT      : Timeout error"]
	#[doc = " \\return ERR_NONE         : No error"]
	#[doc = ""]
	pub fn rfalNfcvPollerLockBlock(flags: u8, uid: *const u8, blockNum: u8) -> ReturnCode;
}
extern "C" {
	#[doc = " \\brief  NFC-V Poller Extended Lock Single Block"]
	#[doc = ""]
	#[doc = " Blocks a Single Block from a device (VICC) supporting extended commands"]
	#[doc = ""]
	#[doc = " \\param[in]  flags        : Flags to be used: Sub-carrier; Data_rate; Option"]
	#[doc = "                            for NFC-Forum use: RFAL_NFCV_REQ_FLAG_DEFAULT"]
	#[doc = " \\param[in]  uid          : UID of the device"]
	#[doc = "                             if UID is provided Addressed mode will be used"]
	#[doc = " \\param[in]  blockNum     : Number of the block to be locked (16 bits)"]
	#[doc = ""]
	#[doc = " \\return ERR_WRONG_STATE  : RFAL not initialized or incorrect mode"]
	#[doc = " \\return ERR_PARAM        : Invalid parameters"]
	#[doc = " \\return ERR_IO           : Generic internal error"]
	#[doc = " \\return ERR_CRC          : CRC error detected"]
	#[doc = " \\return ERR_FRAMING      : Framing error detected"]
	#[doc = " \\return ERR_PROTO        : Protocol error detected"]
	#[doc = " \\return ERR_TIMEOUT      : Timeout error"]
	#[doc = " \\return ERR_NONE         : No error"]
	#[doc = ""]
	pub fn rfalNfcvPollerExtendedLockSingleBlock(flags: u8, uid: *const u8, blockNum: u16) -> ReturnCode;
}
extern "C" {
	#[doc = " \\brief  NFC-V Poller Extended Read Single Block"]
	#[doc = ""]
	#[doc = " Reads a Single Block from a device (VICC) supporting extended commands"]
	#[doc = ""]
	#[doc = " \\param[in]  flags        : Flags to be used: Sub-carrier; Data_rate; Option"]
	#[doc = "                            for NFC-Forum use: RFAL_NFCV_REQ_FLAG_DEFAULT"]
	#[doc = " \\param[in]  uid          : UID of the device to be put to be read"]
	#[doc = "                             if UID is provided Addressed mode will be used"]
	#[doc = " \\param[in]  blockNum     : Number of the block to read (16 bits)"]
	#[doc = " \\param[out] rxBuf        : buffer to store response (also with RES_FLAGS)"]
	#[doc = " \\param[in]  rxBufLen     : length of rxBuf"]
	#[doc = " \\param[out] rcvLen       : number of bytes received"]
	#[doc = ""]
	#[doc = " \\return ERR_WRONG_STATE  : RFAL not initialized or incorrect mode"]
	#[doc = " \\return ERR_PARAM        : Invalid parameters"]
	#[doc = " \\return ERR_IO           : Generic internal error"]
	#[doc = " \\return ERR_CRC          : CRC error detected"]
	#[doc = " \\return ERR_FRAMING      : Framing error detected"]
	#[doc = " \\return ERR_PROTO        : Protocol error detected"]
	#[doc = " \\return ERR_TIMEOUT      : Timeout error"]
	#[doc = " \\return ERR_NONE         : No error"]
	#[doc = ""]
	pub fn rfalNfcvPollerExtendedReadSingleBlock(flags: u8,
	                                             uid: *const u8,
	                                             blockNum: u16,
	                                             rxBuf: *mut u8,
	                                             rxBufLen: u16,
	                                             rcvLen: *mut u16)
	                                             -> ReturnCode;
}
extern "C" {
	#[doc = " \\brief  NFC-V Poller Extended Write Single Block"]
	#[doc = ""]
	#[doc = " Writes a Single Block from a device (VICC) supporting extended commands"]
	#[doc = ""]
	#[doc = " \\param[in]  flags        : Flags to be used: Sub-carrier; Data_rate; Option"]
	#[doc = "                            for NFC-Forum use: RFAL_NFCV_REQ_FLAG_DEFAULT"]
	#[doc = " \\param[in]  uid          : UID of the device"]
	#[doc = "                             if UID is provided Addressed mode will be used"]
	#[doc = " \\param[in]  blockNum     : Number of the block to write (16 bits)"]
	#[doc = " \\param[in]  wrData       : data to be written on the given block"]
	#[doc = " \\param[in]  blockLen     : number of bytes of a block"]
	#[doc = ""]
	#[doc = " \\return ERR_WRONG_STATE  : RFAL not initialized or incorrect mode"]
	#[doc = " \\return ERR_PARAM        : Invalid parameters"]
	#[doc = " \\return ERR_IO           : Generic internal error"]
	#[doc = " \\return ERR_CRC          : CRC error detected"]
	#[doc = " \\return ERR_FRAMING      : Framing error detected"]
	#[doc = " \\return ERR_PROTO        : Protocol error detected"]
	#[doc = " \\return ERR_TIMEOUT      : Timeout error"]
	#[doc = " \\return ERR_NONE         : No error"]
	#[doc = ""]
	pub fn rfalNfcvPollerExtendedWriteSingleBlock(flags: u8,
	                                              uid: *const u8,
	                                              blockNum: u16,
	                                              wrData: *const u8,
	                                              blockLen: u8)
	                                              -> ReturnCode;
}
extern "C" {
	#[doc = " \\brief  NFC-V Poller Extended Read Multiple Blocks"]
	#[doc = ""]
	#[doc = " Reads Multiple Blocks from a device (VICC) supporting extended commands"]
	#[doc = ""]
	#[doc = " \\param[in]  flags          : Flags to be used: Sub-carrier; Data_rate; Option"]
	#[doc = "                              for NFC-Forum use: RFAL_NFCV_REQ_FLAG_DEFAULT"]
	#[doc = " \\param[in]  uid            : UID of the device to be put to be read"]
	#[doc = "                               if UID is provided Addressed mode will be used"]
	#[doc = " \\param[in]  firstBlockNum  : first block to be read (16 bits)"]
	#[doc = " \\param[in]  numOfBlocks    : number of consecutive blocks to read (16 bits)"]
	#[doc = " \\param[out] rxBuf          : buffer to store response (also with RES_FLAGS)"]
	#[doc = " \\param[in]  rxBufLen       : length of rxBuf"]
	#[doc = " \\param[out] rcvLen         : number of bytes received"]
	#[doc = ""]
	#[doc = " \\return ERR_WRONG_STATE    : RFAL not initialized or incorrect mode"]
	#[doc = " \\return ERR_PARAM          : Invalid parameters"]
	#[doc = " \\return ERR_IO             : Generic internal error"]
	#[doc = " \\return ERR_CRC            : CRC error detected"]
	#[doc = " \\return ERR_FRAMING        : Framing error detected"]
	#[doc = " \\return ERR_PROTO          : Protocol error detected"]
	#[doc = " \\return ERR_TIMEOUT        : Timeout error"]
	#[doc = " \\return ERR_NONE           : No error"]
	#[doc = ""]
	pub fn rfalNfcvPollerExtendedReadMultipleBlocks(flags: u8,
	                                                uid: *const u8,
	                                                firstBlockNum: u16,
	                                                numOfBlocks: u16,
	                                                rxBuf: *mut u8,
	                                                rxBufLen: u16,
	                                                rcvLen: *mut u16)
	                                                -> ReturnCode;
}
extern "C" {
	#[doc = " \\brief  NFC-V Poller Extended Write Multiple Blocks"]
	#[doc = ""]
	#[doc = " Writes Multiple Blocks from a device (VICC) supporting extended commands"]
	#[doc = " In order to not limit the length of the Write multiple command, a buffer"]
	#[doc = " must be provided where the request will be composed and then sent."]
	#[doc = ""]
	#[doc = " \\param[in]  flags          : Flags to be used: Sub-carrier; Data_rate; Option"]
	#[doc = "                              for NFC-Forum use: RFAL_NFCV_REQ_FLAG_DEFAULT"]
	#[doc = " \\param[in]  uid            : UID of the device to be put to be read"]
	#[doc = "                               if UID is provided Addressed mode will be used"]
	#[doc = " \\param[in]  firstBlockNum  : first block to be write (16 bits)"]
	#[doc = " \\param[in]  numOfBlocks    : number of consecutive blocks to write (16 bits)"]
	#[doc = " \\param[in]  txBuf          : buffer where the request will be composed"]
	#[doc = " \\param[in]  txBufLen       : length of txBuf"]
	#[doc = " \\param[in]  blockLen       : number of bytes of a block"]
	#[doc = " \\param[in]  wrData         : data to be written"]
	#[doc = " \\param[in]  wrDataLen      : length of the data do be written. Must be"]
	#[doc = "                              aligned with number of blocks to write and"]
	#[doc = "                              the size of a block"]
	#[doc = ""]
	#[doc = " \\return ERR_WRONG_STATE    : RFAL not initialized or incorrect mode"]
	#[doc = " \\return ERR_PARAM          : Invalid parameters"]
	#[doc = " \\return ERR_IO             : Generic internal error"]
	#[doc = " \\return ERR_CRC            : CRC error detected"]
	#[doc = " \\return ERR_FRAMING        : Framing error detected"]
	#[doc = " \\return ERR_PROTO          : Protocol error detected"]
	#[doc = " \\return ERR_TIMEOUT        : Timeout error"]
	#[doc = " \\return ERR_NONE           : No error"]
	#[doc = ""]
	pub fn rfalNfcvPollerExtendedWriteMultipleBlocks(flags: u8,
	                                                 uid: *const u8,
	                                                 firstBlockNum: u16,
	                                                 numOfBlocks: u16,
	                                                 txBuf: *mut u8,
	                                                 txBufLen: u16,
	                                                 blockLen: u8,
	                                                 wrData: *const u8,
	                                                 wrDataLen: u16)
	                                                 -> ReturnCode;
}
extern "C" {
	#[doc = " \\brief  NFC-V Get System Information"]
	#[doc = ""]
	#[doc = " Sends Get System Information command"]
	#[doc = ""]
	#[doc = " \\param[in]  flags          : Flags to be used: Sub-carrier; Data_rate; Option"]
	#[doc = "                              for NFC-Forum use: RFAL_NFCV_REQ_FLAG_DEFAULT"]
	#[doc = " \\param[in]  uid            : UID of the device to be put to be read"]
	#[doc = "                               if UID is provided Addressed mode will be used"]
	#[doc = " \\param[out] rxBuf          : buffer to store response (also with RES_FLAGS)"]
	#[doc = " \\param[in]  rxBufLen       : length of rxBuf"]
	#[doc = " \\param[out] rcvLen         : number of bytes received"]
	#[doc = ""]
	#[doc = " \\return ERR_WRONG_STATE    : RFAL not initialized or incorrect mode"]
	#[doc = " \\return ERR_PARAM          : Invalid parameters"]
	#[doc = " \\return ERR_IO             : Generic internal error"]
	#[doc = " \\return ERR_CRC            : CRC error detected"]
	#[doc = " \\return ERR_FRAMING        : Framing error detected"]
	#[doc = " \\return ERR_PROTO          : Protocol error detected"]
	#[doc = " \\return ERR_TIMEOUT        : Timeout error"]
	#[doc = " \\return ERR_NONE           : No error"]
	#[doc = ""]
	pub fn rfalNfcvPollerGetSystemInformation(flags: u8,
	                                          uid: *const u8,
	                                          rxBuf: *mut u8,
	                                          rxBufLen: u16,
	                                          rcvLen: *mut u16)
	                                          -> ReturnCode;
}
extern "C" {
	#[doc = " \\brief  NFC-V Extended Get System Information"]
	#[doc = ""]
	#[doc = " Sends Extended Get System Information command"]
	#[doc = ""]
	#[doc = " \\param[in]  flags          : Flags to be used: Sub-carrier; Data_rate; Option"]
	#[doc = "                              for NFC-Forum use: RFAL_NFCV_REQ_FLAG_DEFAULT"]
	#[doc = " \\param[in]  uid            : UID of the device to be put to be read"]
	#[doc = "                               if UID is provided Addressed mode will be used"]
	#[doc = " \\param[in]  requestField   : Get System info parameter request field"]
	#[doc = " \\param[out] rxBuf          : buffer to store response (also with RES_FLAGS)"]
	#[doc = " \\param[in]  rxBufLen       : length of rxBuf"]
	#[doc = " \\param[out] rcvLen         : number of bytes received"]
	#[doc = ""]
	#[doc = " \\return ERR_WRONG_STATE    : RFAL not initialized or incorrect mode"]
	#[doc = " \\return ERR_PARAM          : Invalid parameters"]
	#[doc = " \\return ERR_IO             : Generic internal error"]
	#[doc = " \\return ERR_CRC            : CRC error detected"]
	#[doc = " \\return ERR_FRAMING        : Framing error detected"]
	#[doc = " \\return ERR_PROTO          : Protocol error detected"]
	#[doc = " \\return ERR_TIMEOUT        : Timeout error"]
	#[doc = " \\return ERR_NONE           : No error"]
	#[doc = ""]
	pub fn rfalNfcvPollerExtendedGetSystemInformation(flags: u8,
	                                                  uid: *const u8,
	                                                  requestField: u8,
	                                                  rxBuf: *mut u8,
	                                                  rxBufLen: u16,
	                                                  rcvLen: *mut u16)
	                                                  -> ReturnCode;
}
extern "C" {
	#[doc = " \\brief  NFC-V Transceive Request"]
	#[doc = ""]
	#[doc = " Performs a generic transceive with an ISO15693 tag"]
	#[doc = ""]
	#[doc = " \\param[in]  cmd            : NFC-V command"]
	#[doc = " \\param[in]  flags          : Flags to be used: Sub-carrier; Data_rate; Option"]
	#[doc = "                              for NFC-Forum use: RFAL_NFCV_REQ_FLAG_DEFAULT"]
	#[doc = " \\param[in]  param          : Prepend parameter on certain proprietary requests"]
	#[doc = "                              For default commands skip: RFAL_NFCV_PARAM_SKIP"]
	#[doc = " \\param[in]  uid            : UID of the device to be put to be read"]
	#[doc = "                               if UID is provided Addressed mode will be used"]
	#[doc = " \\param[in]  data           : command parameters append after UID"]
	#[doc = " \\param[in]  dataLen        : command parameters Len"]
	#[doc = " \\param[out] rxBuf          : buffer to store response (also with RES_FLAGS)"]
	#[doc = " \\param[in]  rxBufLen       : length of rxBuf"]
	#[doc = " \\param[out] rcvLen         : number of bytes received"]
	#[doc = ""]
	#[doc = " \\return ERR_WRONG_STATE    : RFAL not initialized or incorrect mode"]
	#[doc = " \\return ERR_PARAM          : Invalid parameters"]
	#[doc = " \\return ERR_IO             : Generic internal error"]
	#[doc = " \\return ERR_CRC            : CRC error detected"]
	#[doc = " \\return ERR_FRAMING        : Framing error detected"]
	#[doc = " \\return ERR_PROTO          : Protocol error detected"]
	#[doc = " \\return ERR_TIMEOUT        : Timeout error"]
	#[doc = " \\return ERR_NONE           : No error"]
	#[doc = ""]
	pub fn rfalNfcvPollerTransceiveReq(cmd: u8,
	                                   flags: u8,
	                                   param: u8,
	                                   uid: *const u8,
	                                   data: *const u8,
	                                   dataLen: u16,
	                                   rxBuf: *mut u8,
	                                   rxBufLen: u16,
	                                   rcvLen: *mut u16)
	                                   -> ReturnCode;
}
pub type rfalSt25tbUID = [u8; 8usize];
pub type rfalSt25tbBlock = [u8; 4usize];
#[doc = " ST25TB listener device (PICC) struct"]
#[repr(C)]
pub struct rfalSt25tbListenDevice {
	#[doc = "< Device's session Chip ID"]
	pub chipID: u8,
	#[doc = "< Device's UID"]
	pub UID: rfalSt25tbUID,
	#[doc = "< Device deselect flag"]
	pub isDeselected: bool,
}
#[test]
fn bindgen_test_layout_rfalSt25tbListenDevice() {
	assert_eq!(
	           ::core::mem::size_of::<rfalSt25tbListenDevice>(),
	           10usize,
	           concat!("Size of: ", stringify!(rfalSt25tbListenDevice))
	);
	assert_eq!(
	           ::core::mem::align_of::<rfalSt25tbListenDevice>(),
	           1usize,
	           concat!("Alignment of ", stringify!(rfalSt25tbListenDevice))
	);
	fn test_field_chipID() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalSt25tbListenDevice>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).chipID) as usize - ptr as usize
		           },
		           0usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalSt25tbListenDevice),
			"::",
			stringify!(chipID)
		)
		);
	}
	test_field_chipID();
	fn test_field_UID() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalSt25tbListenDevice>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).UID) as usize - ptr as usize
		           },
		           1usize,
		           concat!("Offset of field: ", stringify!(rfalSt25tbListenDevice), "::", stringify!(UID))
		);
	}
	test_field_UID();
	fn test_field_isDeselected() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalSt25tbListenDevice>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).isDeselected) as usize - ptr as usize
		           },
		           9usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalSt25tbListenDevice),
			"::",
			stringify!(isDeselected)
		)
		);
	}
	test_field_isDeselected();
}
extern "C" {
	#[doc = " \\brief  Initialize ST25TB Poller mode"]
	#[doc = ""]
	#[doc = " This methods configures RFAL RF layer to perform as a"]
	#[doc = " ST25TB Poller/RW including all default timings"]
	#[doc = ""]
	#[doc = " \\return ERR_WRONG_STATE  : RFAL not initialized or mode not set"]
	#[doc = " \\return ERR_NONE         : No error"]
	#[doc = ""]
	pub fn rfalSt25tbPollerInitialize() -> ReturnCode;
}
extern "C" {
	#[doc = " \\brief  ST25TB Poller Check Presence"]
	#[doc = ""]
	#[doc = " This method checks if a ST25TB Listen device (PICC) is present on the field"]
	#[doc = " by sending an Initiate command"]
	#[doc = ""]
	#[doc = " \\param[out] chipId : if successfully retrieved, the device's chip ID"]
	#[doc = ""]
	#[doc = " \\return ERR_WRONG_STATE  : RFAL not initialized or incorrect mode"]
	#[doc = " \\return ERR_PARAM        : Invalid parameters"]
	#[doc = " \\return ERR_IO           : Generic internal error"]
	#[doc = " \\return ERR_TIMEOUT      : Timeout error, no listener device detected"]
	#[doc = " \\return ERR_RF_COLLISION : Collision detected one or more device in the field"]
	#[doc = " \\return ERR_PROTO        : Protocol error detected"]
	#[doc = " \\return ERR_NONE         : No error"]
	#[doc = ""]
	pub fn rfalSt25tbPollerCheckPresence(chipId: *mut u8) -> ReturnCode;
}
extern "C" {
	#[doc = " \\brief  ST25TB Poller Collision Resolution"]
	#[doc = ""]
	#[doc = " This method performs ST25TB Collision resolution, selects the each device,"]
	#[doc = " retrieves its UID and then deselects."]
	#[doc = " In case only one device is identified the ST25TB device is left in select"]
	#[doc = " state."]
	#[doc = ""]
	#[doc = " \\param[in]  devLimit      : device limit value, and size st25tbDevList"]
	#[doc = " \\param[out] st25tbDevList : ST35TB listener device info"]
	#[doc = " \\param[out] devCnt        : Devices found counter"]
	#[doc = ""]
	#[doc = " \\return ERR_WRONG_STATE  : RFAL not initialized or incorrect mode"]
	#[doc = " \\return ERR_PARAM        : Invalid parameters"]
	#[doc = " \\return ERR_IO           : Generic internal error"]
	#[doc = " \\return ERR_TIMEOUT      : Timeout error, no listener device detected"]
	#[doc = " \\return ERR_RF_COLLISION : Collision detected one or more device in the field"]
	#[doc = " \\return ERR_PROTO        : Protocol error detected"]
	#[doc = " \\return ERR_NONE         : No error"]
	#[doc = ""]
	pub fn rfalSt25tbPollerCollisionResolution(devLimit: u8,
	                                           st25tbDevList: *mut rfalSt25tbListenDevice,
	                                           devCnt: *mut u8)
	                                           -> ReturnCode;
}
extern "C" {
	#[doc = " \\brief  ST25TB Poller Initiate"]
	#[doc = ""]
	#[doc = " This method sends an Initiate command"]
	#[doc = ""]
	#[doc = " If a single device responds the chip ID will be retrieved"]
	#[doc = ""]
	#[doc = " \\param[out]  chipId      : chip ID of the device"]
	#[doc = ""]
	#[doc = " \\return ERR_WRONG_STATE  : RFAL not initialized or incorrect mode"]
	#[doc = " \\return ERR_PARAM        : Invalid parameters"]
	#[doc = " \\return ERR_IO           : Generic internal error"]
	#[doc = " \\return ERR_TIMEOUT      : Timeout error, no listener device detected"]
	#[doc = " \\return ERR_PROTO        : Protocol error detected"]
	#[doc = " \\return ERR_NONE         : No error"]
	#[doc = ""]
	pub fn rfalSt25tbPollerInitiate(chipId: *mut u8) -> ReturnCode;
}
extern "C" {
	#[doc = " \\brief  ST25TB Poller Pcall"]
	#[doc = ""]
	#[doc = " This method sends a Pcall command"]
	#[doc = " If successful the device's chip ID will be retrieved"]
	#[doc = ""]
	#[doc = " \\param[out]  chipId      : Chip ID of the device"]
	#[doc = ""]
	#[doc = " \\return ERR_WRONG_STATE  : RFAL not initialized or incorrect mode"]
	#[doc = " \\return ERR_PARAM        : Invalid parameters"]
	#[doc = " \\return ERR_IO           : Generic internal error"]
	#[doc = " \\return ERR_TIMEOUT      : Timeout error, no listener device detected"]
	#[doc = " \\return ERR_PROTO        : Protocol error detected"]
	#[doc = " \\return ERR_NONE         : No error"]
	#[doc = ""]
	pub fn rfalSt25tbPollerPcall(chipId: *mut u8) -> ReturnCode;
}
extern "C" {
	#[doc = " \\brief  ST25TB Poller Slot Marker"]
	#[doc = ""]
	#[doc = " This method sends a Slot Marker"]
	#[doc = ""]
	#[doc = " If a single device responds the chip ID will be retrieved"]
	#[doc = ""]
	#[doc = " \\param[in]  slotNum      : Slot Number"]
	#[doc = " \\param[out]  chipIdRes   : Chip ID of the device"]
	#[doc = ""]
	#[doc = " \\return ERR_WRONG_STATE  : RFAL not initialized or incorrect mode"]
	#[doc = " \\return ERR_PARAM        : Invalid parameters"]
	#[doc = " \\return ERR_IO           : Generic internal error"]
	#[doc = " \\return ERR_TIMEOUT      : Timeout error, no listener device detected"]
	#[doc = " \\return ERR_PROTO        : Protocol error detected"]
	#[doc = " \\return ERR_NONE         : No error"]
	#[doc = ""]
	pub fn rfalSt25tbPollerSlotMarker(slotNum: u8, chipIdRes: *mut u8) -> ReturnCode;
}
extern "C" {
	#[doc = " \\brief  ST25TB Poller Select"]
	#[doc = ""]
	#[doc = " This method sends a ST25TB Select command with the given chip ID."]
	#[doc = ""]
	#[doc = " If the device is already in Selected state and receives an incorrect chip"]
	#[doc = " ID, it goes into Deselected state"]
	#[doc = ""]
	#[doc = " \\param[in]  chipId       : chip ID of the device to be selected"]
	#[doc = ""]
	#[doc = " \\return ERR_WRONG_STATE  : RFAL not initialized or incorrect mode"]
	#[doc = " \\return ERR_PARAM        : Invalid parameters"]
	#[doc = " \\return ERR_IO           : Generic internal error"]
	#[doc = " \\return ERR_TIMEOUT      : Timeout error, no listener device detected"]
	#[doc = " \\return ERR_PROTO        : Protocol error detected"]
	#[doc = " \\return ERR_NONE         : No error"]
	#[doc = ""]
	pub fn rfalSt25tbPollerSelect(chipId: u8) -> ReturnCode;
}
extern "C" {
	#[doc = " \\brief  ST25TB Get UID"]
	#[doc = ""]
	#[doc = " This method sends a Get_UID command"]
	#[doc = ""]
	#[doc = " If a single device responds the chip UID will be retrieved"]
	#[doc = ""]
	#[doc = " \\param[out]  UID      : UID of the found device"]
	#[doc = ""]
	#[doc = " \\return ERR_WRONG_STATE  : RFAL not initialized or incorrect mode"]
	#[doc = " \\return ERR_PARAM        : Invalid parameters"]
	#[doc = " \\return ERR_IO           : Generic internal error"]
	#[doc = " \\return ERR_TIMEOUT      : Timeout error, no listener device detected"]
	#[doc = " \\return ERR_PROTO        : Protocol error detected"]
	#[doc = " \\return ERR_NONE         : No error"]
	#[doc = ""]
	pub fn rfalSt25tbPollerGetUID(UID: *mut rfalSt25tbUID) -> ReturnCode;
}
extern "C" {
	#[doc = " \\brief  ST25TB Poller Read Block"]
	#[doc = ""]
	#[doc = " This method reads a block of the ST25TB"]
	#[doc = ""]
	#[doc = " \\param[in]   blockAddress : address of the block to be read"]
	#[doc = " \\param[out]  blockData    : location to place the data read from block"]
	#[doc = ""]
	#[doc = " \\return ERR_WRONG_STATE  : RFAL not initialized or incorrect mode"]
	#[doc = " \\return ERR_PARAM        : Invalid parameters"]
	#[doc = " \\return ERR_IO           : Generic internal error"]
	#[doc = " \\return ERR_TIMEOUT      : Timeout error, no listener device detected"]
	#[doc = " \\return ERR_PROTO        : Protocol error detected"]
	#[doc = " \\return ERR_NONE         : No error"]
	#[doc = ""]
	pub fn rfalSt25tbPollerReadBlock(blockAddress: u8, blockData: *mut rfalSt25tbBlock) -> ReturnCode;
}
extern "C" {
	#[doc = " \\brief  ST25TB Poller Write Block"]
	#[doc = ""]
	#[doc = " This method writes a block of the ST25TB"]
	#[doc = ""]
	#[doc = " \\param[in]  blockAddress : address of the block to be written"]
	#[doc = " \\param[in]  blockData    : data to be written on the block"]
	#[doc = ""]
	#[doc = " \\return ERR_WRONG_STATE  : RFAL not initialized or incorrect mode"]
	#[doc = " \\return ERR_PARAM        : Invalid parameters"]
	#[doc = " \\return ERR_IO           : Generic internal error"]
	#[doc = " \\return ERR_TIMEOUT      : Timeout error, no listener device detected"]
	#[doc = " \\return ERR_PROTO        : Protocol error detected"]
	#[doc = " \\return ERR_NONE         : No error"]
	#[doc = ""]
	pub fn rfalSt25tbPollerWriteBlock(blockAddress: u8, blockData: *const rfalSt25tbBlock) -> ReturnCode;
}
extern "C" {
	#[doc = " \\brief  ST25TB Poller Completion"]
	#[doc = ""]
	#[doc = " This method sends a completion command to the ST25TB. After the"]
	#[doc = " completion the card no longer will reply to any command."]
	#[doc = ""]
	#[doc = " \\return ERR_WRONG_STATE  : RFAL not initialized or incorrect mode"]
	#[doc = " \\return ERR_PARAM        : Invalid parameters"]
	#[doc = " \\return ERR_IO           : Generic internal error"]
	#[doc = " \\return ERR_TIMEOUT      : Timeout error, no listener device detected"]
	#[doc = " \\return ERR_PROTO        : Protocol error detected, invalid SENSB_RES received"]
	#[doc = " \\return ERR_NONE         : No error"]
	#[doc = ""]
	pub fn rfalSt25tbPollerCompletion() -> ReturnCode;
}
extern "C" {
	#[doc = " \\brief  ST25TB Poller Reset to Inventory"]
	#[doc = ""]
	#[doc = " This method sends a Reset to Inventory command to the ST25TB."]
	#[doc = ""]
	#[doc = " \\return ERR_WRONG_STATE  : RFAL not initialized or incorrect mode"]
	#[doc = " \\return ERR_PARAM        : Invalid parameters"]
	#[doc = " \\return ERR_IO           : Generic internal error"]
	#[doc = " \\return ERR_TIMEOUT      : Timeout error, no listener device detected"]
	#[doc = " \\return ERR_PROTO        : Protocol error detected, invalid SENSB_RES received"]
	#[doc = " \\return ERR_NONE         : No error"]
	#[doc = ""]
	pub fn rfalSt25tbPollerResetToInventory() -> ReturnCode;
}
pub const RFAL_NFCDEP_Bx_NO_HIGH_BR: _bindgen_ty_11 = _bindgen_ty_11::RFAL_NFCDEP_Bx_NO_HIGH_BR;
pub const RFAL_NFCDEP_Bx_08_848: _bindgen_ty_11 = _bindgen_ty_11::RFAL_NFCDEP_Bx_08_848;
pub const RFAL_NFCDEP_Bx_16_1695: _bindgen_ty_11 = _bindgen_ty_11::RFAL_NFCDEP_Bx_16_1695;
pub const RFAL_NFCDEP_Bx_32_3390: _bindgen_ty_11 = _bindgen_ty_11::RFAL_NFCDEP_Bx_32_3390;
pub const RFAL_NFCDEP_Bx_64_6780: _bindgen_ty_11 = _bindgen_ty_11::RFAL_NFCDEP_Bx_64_6780;
#[repr(u32)]
#[non_exhaustive]
#[doc = " Enumeration of NFC-DEP bit rate in ATR    Digital 1.0 Table 93 and 94"]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum _bindgen_ty_11 {
	#[doc = "< Peer supports no high bit rates"]
	RFAL_NFCDEP_Bx_NO_HIGH_BR = 0,
	#[doc = "< Peer also supports 848"]
	RFAL_NFCDEP_Bx_08_848 = 1,
	#[doc = "< Peer also supports 1695"]
	RFAL_NFCDEP_Bx_16_1695 = 2,
	#[doc = "< Peer also supports 3390"]
	RFAL_NFCDEP_Bx_32_3390 = 4,
	#[doc = "< Peer also supports 6780"]
	RFAL_NFCDEP_Bx_64_6780 = 8,
}
pub const RFAL_NFCDEP_Dx_01_106: _bindgen_ty_12 = _bindgen_ty_12::RFAL_NFCDEP_Dx_01_106;
pub const RFAL_NFCDEP_Dx_02_212: _bindgen_ty_12 = _bindgen_ty_12::RFAL_NFCDEP_Dx_02_212;
pub const RFAL_NFCDEP_Dx_04_424: _bindgen_ty_12 = _bindgen_ty_12::RFAL_NFCDEP_Dx_04_424;
pub const RFAL_NFCDEP_Dx_08_848: _bindgen_ty_12 = _bindgen_ty_12::RFAL_NFCDEP_Dx_08_848;
pub const RFAL_NFCDEP_Dx_16_1695: _bindgen_ty_12 = _bindgen_ty_12::RFAL_NFCDEP_Dx_16_1695;
pub const RFAL_NFCDEP_Dx_32_3390: _bindgen_ty_12 = _bindgen_ty_12::RFAL_NFCDEP_Dx_32_3390;
pub const RFAL_NFCDEP_Dx_64_6780: _bindgen_ty_12 = _bindgen_ty_12::RFAL_NFCDEP_Dx_64_6780;
#[repr(u32)]
#[non_exhaustive]
#[doc = " Enumeration of NFC-DEP bit rate Dividor in PSL   Digital 1.0 Table 100"]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum _bindgen_ty_12 {
	#[doc = "< Divisor D =  1 : bit rate = 106"]
	RFAL_NFCDEP_Dx_01_106 = 0,
	#[doc = "< Divisor D =  2 : bit rate = 212"]
	RFAL_NFCDEP_Dx_02_212 = 1,
	#[doc = "< Divisor D =  4 : bit rate = 424"]
	RFAL_NFCDEP_Dx_04_424 = 2,
	#[doc = "< Divisor D =  8 : bit rate = 848"]
	RFAL_NFCDEP_Dx_08_848 = 3,
	#[doc = "< Divisor D = 16 : bit rate = 1695"]
	RFAL_NFCDEP_Dx_16_1695 = 4,
	#[doc = "< Divisor D = 32 : bit rate = 3390"]
	RFAL_NFCDEP_Dx_32_3390 = 5,
	#[doc = "< Divisor D = 64 : bit rate = 6780"]
	RFAL_NFCDEP_Dx_64_6780 = 6,
}
pub const RFAL_NFCDEP_LR_64: _bindgen_ty_13 = _bindgen_ty_13::RFAL_NFCDEP_LR_64;
pub const RFAL_NFCDEP_LR_128: _bindgen_ty_13 = _bindgen_ty_13::RFAL_NFCDEP_LR_128;
pub const RFAL_NFCDEP_LR_192: _bindgen_ty_13 = _bindgen_ty_13::RFAL_NFCDEP_LR_192;
pub const RFAL_NFCDEP_LR_254: _bindgen_ty_13 = _bindgen_ty_13::RFAL_NFCDEP_LR_254;
#[repr(u32)]
#[non_exhaustive]
#[doc = " Enumeration of  NFC-DEP Length Reduction (LR)   Digital 1.0 Table 91"]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum _bindgen_ty_13 {
	#[doc = "< Maximum payload size is  64 bytes"]
	RFAL_NFCDEP_LR_64 = 0,
	#[doc = "< Maximum payload size is 128 bytes"]
	RFAL_NFCDEP_LR_128 = 1,
	#[doc = "< Maximum payload size is 192 bytes"]
	RFAL_NFCDEP_LR_192 = 2,
	#[doc = "< Maximum payload size is 254 bytes"]
	RFAL_NFCDEP_LR_254 = 3,
}
#[doc = " NFC-DEP callback to check if upper layer has deactivation pending"]
pub type rfalNfcDepDeactCallback = ::core::option::Option<unsafe extern "C" fn() -> bool>;
#[repr(u32)]
#[non_exhaustive]
#[doc = " Enumeration of the nfcip communication modes"]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum rfalNfcDepCommMode {
	#[doc = "< Passive communication mode"]
	RFAL_NFCDEP_COMM_PASSIVE = 0,
	#[doc = "< Active communication mode"]
	RFAL_NFCDEP_COMM_ACTIVE = 1,
}
#[repr(u32)]
#[non_exhaustive]
#[doc = " Enumeration of the nfcip roles"]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum rfalNfcDepRole {
	#[doc = "< Perform as Initiator"]
	RFAL_NFCDEP_ROLE_INITIATOR = 0,
	#[doc = "< Perform as Target"]
	RFAL_NFCDEP_ROLE_TARGET = 1,
}
#[doc = " Struct that holds all NFCIP configs"]
#[repr(C)]
pub struct rfalNfcDepConfigs {
	#[doc = "< Current NFCIP role"]
	pub role: rfalNfcDepRole,
	#[doc = "< Current NFCIP communication mode"]
	pub commMode: rfalNfcDepCommMode,
	#[doc = "< Operation config similar to NCI 1.0 Table 81"]
	pub oper: u8,
	#[doc = "< Current Device ID (DID)"]
	pub did: u8,
	#[doc = "< Current Node Addressing (NAD)"]
	pub nad: u8,
	#[doc = "< Bit rate in Sending Direction"]
	pub bs: u8,
	#[doc = "< Bit rate in Receiving Direction"]
	pub br: u8,
	#[doc = "< Pointer to the NFCID to be used"]
	pub nfcid: [u8; 10usize],
	#[doc = "< Length of the given NFCID in nfcid"]
	pub nfcidLen: u8,
	#[doc = "< Pointer General Bytes (GB) to be used"]
	pub gb: [u8; 48usize],
	#[doc = "< Length of the given GB in gb"]
	pub gbLen: u8,
	#[doc = "< Length Reduction (LR) to be used"]
	pub lr: u8,
	#[doc = "< Timeout (TO)  to be used"]
	pub to: u8,
	#[doc = "< Frame Waiting Time (FWT) to be used"]
	pub fwt: u32,
	#[doc = "< Delta Frame Waiting Time (dFWT) to be used"]
	pub dFwt: u32,
}
#[test]
fn bindgen_test_layout_rfalNfcDepConfigs() {
	assert_eq!(
	           ::core::mem::size_of::<rfalNfcDepConfigs>(),
	           84usize,
	           concat!("Size of: ", stringify!(rfalNfcDepConfigs))
	);
	assert_eq!(
	           ::core::mem::align_of::<rfalNfcDepConfigs>(),
	           4usize,
	           concat!("Alignment of ", stringify!(rfalNfcDepConfigs))
	);
	fn test_field_role() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcDepConfigs>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).role) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(rfalNfcDepConfigs), "::", stringify!(role))
		);
	}
	test_field_role();
	fn test_field_commMode() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcDepConfigs>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).commMode) as usize - ptr as usize
		           },
		           4usize,
		           concat!("Offset of field: ", stringify!(rfalNfcDepConfigs), "::", stringify!(commMode))
		);
	}
	test_field_commMode();
	fn test_field_oper() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcDepConfigs>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).oper) as usize - ptr as usize
		           },
		           8usize,
		           concat!("Offset of field: ", stringify!(rfalNfcDepConfigs), "::", stringify!(oper))
		);
	}
	test_field_oper();
	fn test_field_did() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcDepConfigs>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).did) as usize - ptr as usize
		           },
		           9usize,
		           concat!("Offset of field: ", stringify!(rfalNfcDepConfigs), "::", stringify!(did))
		);
	}
	test_field_did();
	fn test_field_nad() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcDepConfigs>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).nad) as usize - ptr as usize
		           },
		           10usize,
		           concat!("Offset of field: ", stringify!(rfalNfcDepConfigs), "::", stringify!(nad))
		);
	}
	test_field_nad();
	fn test_field_bs() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcDepConfigs>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).bs) as usize - ptr as usize
		           },
		           11usize,
		           concat!("Offset of field: ", stringify!(rfalNfcDepConfigs), "::", stringify!(bs))
		);
	}
	test_field_bs();
	fn test_field_br() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcDepConfigs>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).br) as usize - ptr as usize
		           },
		           12usize,
		           concat!("Offset of field: ", stringify!(rfalNfcDepConfigs), "::", stringify!(br))
		);
	}
	test_field_br();
	fn test_field_nfcid() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcDepConfigs>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).nfcid) as usize - ptr as usize
		           },
		           13usize,
		           concat!("Offset of field: ", stringify!(rfalNfcDepConfigs), "::", stringify!(nfcid))
		);
	}
	test_field_nfcid();
	fn test_field_nfcidLen() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcDepConfigs>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).nfcidLen) as usize - ptr as usize
		           },
		           23usize,
		           concat!("Offset of field: ", stringify!(rfalNfcDepConfigs), "::", stringify!(nfcidLen))
		);
	}
	test_field_nfcidLen();
	fn test_field_gb() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcDepConfigs>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).gb) as usize - ptr as usize
		           },
		           24usize,
		           concat!("Offset of field: ", stringify!(rfalNfcDepConfigs), "::", stringify!(gb))
		);
	}
	test_field_gb();
	fn test_field_gbLen() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcDepConfigs>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).gbLen) as usize - ptr as usize
		           },
		           72usize,
		           concat!("Offset of field: ", stringify!(rfalNfcDepConfigs), "::", stringify!(gbLen))
		);
	}
	test_field_gbLen();
	fn test_field_lr() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcDepConfigs>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).lr) as usize - ptr as usize
		           },
		           73usize,
		           concat!("Offset of field: ", stringify!(rfalNfcDepConfigs), "::", stringify!(lr))
		);
	}
	test_field_lr();
	fn test_field_to() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcDepConfigs>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).to) as usize - ptr as usize
		           },
		           74usize,
		           concat!("Offset of field: ", stringify!(rfalNfcDepConfigs), "::", stringify!(to))
		);
	}
	test_field_to();
	fn test_field_fwt() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcDepConfigs>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).fwt) as usize - ptr as usize
		           },
		           76usize,
		           concat!("Offset of field: ", stringify!(rfalNfcDepConfigs), "::", stringify!(fwt))
		);
	}
	test_field_fwt();
	fn test_field_dFwt() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcDepConfigs>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).dFwt) as usize - ptr as usize
		           },
		           80usize,
		           concat!("Offset of field: ", stringify!(rfalNfcDepConfigs), "::", stringify!(dFwt))
		);
	}
	test_field_dFwt();
}
#[doc = " ATR_REQ command    Digital 1.1 16.6.2"]
#[repr(C)]
pub struct rfalNfcDepAtrReq {
	#[doc = "< Command format 0xD4"]
	pub CMD1: u8,
	#[doc = "< Command Value"]
	pub CMD2: u8,
	#[doc = "< NFCID3 value"]
	pub NFCID3: [u8; 10usize],
	#[doc = "< DID"]
	pub DID: u8,
	#[doc = "< Sending Bitrate for Initiator"]
	pub BSi: u8,
	#[doc = "< Receiving Bitrate for Initiator"]
	pub BRi: u8,
	#[doc = "< Optional Parameters presence indicator"]
	pub PPi: u8,
	#[doc = "< General Bytes"]
	pub GBi: [u8; 48usize],
}
#[test]
fn bindgen_test_layout_rfalNfcDepAtrReq() {
	assert_eq!(
	           ::core::mem::size_of::<rfalNfcDepAtrReq>(),
	           64usize,
	           concat!("Size of: ", stringify!(rfalNfcDepAtrReq))
	);
	assert_eq!(
	           ::core::mem::align_of::<rfalNfcDepAtrReq>(),
	           1usize,
	           concat!("Alignment of ", stringify!(rfalNfcDepAtrReq))
	);
	fn test_field_CMD1() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcDepAtrReq>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).CMD1) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(rfalNfcDepAtrReq), "::", stringify!(CMD1))
		);
	}
	test_field_CMD1();
	fn test_field_CMD2() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcDepAtrReq>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).CMD2) as usize - ptr as usize
		           },
		           1usize,
		           concat!("Offset of field: ", stringify!(rfalNfcDepAtrReq), "::", stringify!(CMD2))
		);
	}
	test_field_CMD2();
	fn test_field_NFCID3() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcDepAtrReq>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).NFCID3) as usize - ptr as usize
		           },
		           2usize,
		           concat!("Offset of field: ", stringify!(rfalNfcDepAtrReq), "::", stringify!(NFCID3))
		);
	}
	test_field_NFCID3();
	fn test_field_DID() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcDepAtrReq>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).DID) as usize - ptr as usize
		           },
		           12usize,
		           concat!("Offset of field: ", stringify!(rfalNfcDepAtrReq), "::", stringify!(DID))
		);
	}
	test_field_DID();
	fn test_field_BSi() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcDepAtrReq>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).BSi) as usize - ptr as usize
		           },
		           13usize,
		           concat!("Offset of field: ", stringify!(rfalNfcDepAtrReq), "::", stringify!(BSi))
		);
	}
	test_field_BSi();
	fn test_field_BRi() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcDepAtrReq>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).BRi) as usize - ptr as usize
		           },
		           14usize,
		           concat!("Offset of field: ", stringify!(rfalNfcDepAtrReq), "::", stringify!(BRi))
		);
	}
	test_field_BRi();
	fn test_field_PPi() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcDepAtrReq>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).PPi) as usize - ptr as usize
		           },
		           15usize,
		           concat!("Offset of field: ", stringify!(rfalNfcDepAtrReq), "::", stringify!(PPi))
		);
	}
	test_field_PPi();
	fn test_field_GBi() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcDepAtrReq>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).GBi) as usize - ptr as usize
		           },
		           16usize,
		           concat!("Offset of field: ", stringify!(rfalNfcDepAtrReq), "::", stringify!(GBi))
		);
	}
	test_field_GBi();
}
#[doc = " ATR_RES response    Digital 1.1 16.6.3"]
#[repr(C)]
pub struct rfalNfcDepAtrRes {
	#[doc = "< Response Byte 0xD5"]
	pub CMD1: u8,
	#[doc = "< Command Value"]
	pub CMD2: u8,
	#[doc = "< NFCID3 value"]
	pub NFCID3: [u8; 10usize],
	#[doc = "< DID"]
	pub DID: u8,
	#[doc = "< Sending Bitrate for Initiator"]
	pub BSt: u8,
	#[doc = "< Receiving Bitrate for Initiator"]
	pub BRt: u8,
	#[doc = "< Timeout"]
	pub TO: u8,
	#[doc = "< Optional Parameters presence indicator"]
	pub PPt: u8,
	#[doc = "< General Bytes"]
	pub GBt: [u8; 48usize],
}
#[test]
fn bindgen_test_layout_rfalNfcDepAtrRes() {
	assert_eq!(
	           ::core::mem::size_of::<rfalNfcDepAtrRes>(),
	           65usize,
	           concat!("Size of: ", stringify!(rfalNfcDepAtrRes))
	);
	assert_eq!(
	           ::core::mem::align_of::<rfalNfcDepAtrRes>(),
	           1usize,
	           concat!("Alignment of ", stringify!(rfalNfcDepAtrRes))
	);
	fn test_field_CMD1() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcDepAtrRes>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).CMD1) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(rfalNfcDepAtrRes), "::", stringify!(CMD1))
		);
	}
	test_field_CMD1();
	fn test_field_CMD2() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcDepAtrRes>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).CMD2) as usize - ptr as usize
		           },
		           1usize,
		           concat!("Offset of field: ", stringify!(rfalNfcDepAtrRes), "::", stringify!(CMD2))
		);
	}
	test_field_CMD2();
	fn test_field_NFCID3() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcDepAtrRes>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).NFCID3) as usize - ptr as usize
		           },
		           2usize,
		           concat!("Offset of field: ", stringify!(rfalNfcDepAtrRes), "::", stringify!(NFCID3))
		);
	}
	test_field_NFCID3();
	fn test_field_DID() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcDepAtrRes>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).DID) as usize - ptr as usize
		           },
		           12usize,
		           concat!("Offset of field: ", stringify!(rfalNfcDepAtrRes), "::", stringify!(DID))
		);
	}
	test_field_DID();
	fn test_field_BSt() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcDepAtrRes>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).BSt) as usize - ptr as usize
		           },
		           13usize,
		           concat!("Offset of field: ", stringify!(rfalNfcDepAtrRes), "::", stringify!(BSt))
		);
	}
	test_field_BSt();
	fn test_field_BRt() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcDepAtrRes>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).BRt) as usize - ptr as usize
		           },
		           14usize,
		           concat!("Offset of field: ", stringify!(rfalNfcDepAtrRes), "::", stringify!(BRt))
		);
	}
	test_field_BRt();
	fn test_field_TO() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcDepAtrRes>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).TO) as usize - ptr as usize
		           },
		           15usize,
		           concat!("Offset of field: ", stringify!(rfalNfcDepAtrRes), "::", stringify!(TO))
		);
	}
	test_field_TO();
	fn test_field_PPt() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcDepAtrRes>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).PPt) as usize - ptr as usize
		           },
		           16usize,
		           concat!("Offset of field: ", stringify!(rfalNfcDepAtrRes), "::", stringify!(PPt))
		);
	}
	test_field_PPt();
	fn test_field_GBt() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcDepAtrRes>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).GBt) as usize - ptr as usize
		           },
		           17usize,
		           concat!("Offset of field: ", stringify!(rfalNfcDepAtrRes), "::", stringify!(GBt))
		);
	}
	test_field_GBt();
}
#[doc = " Structure of transmit I-PDU Buffer format from caller"]
#[repr(C)]
pub struct rfalNfcDepBufFormat {
	#[doc = "< Prologue space for NFC-DEP header"]
	pub prologue: [u8; 5usize],
	#[doc = "< INF | Data area of the buffer"]
	pub inf: [u8; 254usize],
}
#[test]
fn bindgen_test_layout_rfalNfcDepBufFormat() {
	assert_eq!(
	           ::core::mem::size_of::<rfalNfcDepBufFormat>(),
	           259usize,
	           concat!("Size of: ", stringify!(rfalNfcDepBufFormat))
	);
	assert_eq!(
	           ::core::mem::align_of::<rfalNfcDepBufFormat>(),
	           1usize,
	           concat!("Alignment of ", stringify!(rfalNfcDepBufFormat))
	);
	fn test_field_prologue() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcDepBufFormat>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).prologue) as usize - ptr as usize
		           },
		           0usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalNfcDepBufFormat),
			"::",
			stringify!(prologue)
		)
		);
	}
	test_field_prologue();
	fn test_field_inf() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcDepBufFormat>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).inf) as usize - ptr as usize
		           },
		           5usize,
		           concat!("Offset of field: ", stringify!(rfalNfcDepBufFormat), "::", stringify!(inf))
		);
	}
	test_field_inf();
}
#[doc = " Structure of APDU Buffer format from caller"]
#[repr(C)]
pub struct rfalNfcDepPduBufFormat {
	#[doc = "< Prologue/SoD buffer"]
	pub prologue: [u8; 5usize],
	#[doc = "< Complete PDU/Payload buffer"]
	pub pdu: [u8; 512usize],
}
#[test]
fn bindgen_test_layout_rfalNfcDepPduBufFormat() {
	assert_eq!(
	           ::core::mem::size_of::<rfalNfcDepPduBufFormat>(),
	           517usize,
	           concat!("Size of: ", stringify!(rfalNfcDepPduBufFormat))
	);
	assert_eq!(
	           ::core::mem::align_of::<rfalNfcDepPduBufFormat>(),
	           1usize,
	           concat!("Alignment of ", stringify!(rfalNfcDepPduBufFormat))
	);
	fn test_field_prologue() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcDepPduBufFormat>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).prologue) as usize - ptr as usize
		           },
		           0usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalNfcDepPduBufFormat),
			"::",
			stringify!(prologue)
		)
		);
	}
	test_field_prologue();
	fn test_field_pdu() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcDepPduBufFormat>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).pdu) as usize - ptr as usize
		           },
		           5usize,
		           concat!("Offset of field: ", stringify!(rfalNfcDepPduBufFormat), "::", stringify!(pdu))
		);
	}
	test_field_pdu();
}
#[doc = " Activation info as Initiator and Target"]
#[repr(C)]
pub struct rfalNfcDepActivation {
	#[doc = "< Target"]
	pub Target: __BindgenUnionField<rfalNfcDepActivation__bindgen_ty_1>,
	#[doc = "< Initiator"]
	pub Initiator: __BindgenUnionField<rfalNfcDepActivation__bindgen_ty_2>,
	pub bindgen_union_field: [u8; 66usize],
}
#[repr(C)]
pub struct rfalNfcDepActivation__bindgen_ty_1 {
	#[doc = "< ATR RES            (Initiator mode)"]
	pub ATR_RES: rfalNfcDepAtrRes,
	#[doc = "< ATR RES length     (Initiator mode)"]
	pub ATR_RESLen: u8,
}
#[test]
fn bindgen_test_layout_rfalNfcDepActivation__bindgen_ty_1() {
	assert_eq!(
	           ::core::mem::size_of::<rfalNfcDepActivation__bindgen_ty_1>(),
	           66usize,
	           concat!("Size of: ", stringify!(rfalNfcDepActivation__bindgen_ty_1))
	);
	assert_eq!(
	           ::core::mem::align_of::<rfalNfcDepActivation__bindgen_ty_1>(),
	           1usize,
	           concat!("Alignment of ", stringify!(rfalNfcDepActivation__bindgen_ty_1))
	);
	fn test_field_ATR_RES() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcDepActivation__bindgen_ty_1>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).ATR_RES) as usize - ptr as usize
		           },
		           0usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalNfcDepActivation__bindgen_ty_1),
			"::",
			stringify!(ATR_RES)
		)
		);
	}
	test_field_ATR_RES();
	fn test_field_ATR_RESLen() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcDepActivation__bindgen_ty_1>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).ATR_RESLen) as usize - ptr as usize
		           },
		           65usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalNfcDepActivation__bindgen_ty_1),
			"::",
			stringify!(ATR_RESLen)
		)
		);
	}
	test_field_ATR_RESLen();
}
#[repr(C)]
pub struct rfalNfcDepActivation__bindgen_ty_2 {
	#[doc = "< ATR REQ            (Target mode)"]
	pub ATR_REQ: rfalNfcDepAtrReq,
	#[doc = "< ATR REQ length     (Target mode)"]
	pub ATR_REQLen: u8,
}
#[test]
fn bindgen_test_layout_rfalNfcDepActivation__bindgen_ty_2() {
	assert_eq!(
	           ::core::mem::size_of::<rfalNfcDepActivation__bindgen_ty_2>(),
	           65usize,
	           concat!("Size of: ", stringify!(rfalNfcDepActivation__bindgen_ty_2))
	);
	assert_eq!(
	           ::core::mem::align_of::<rfalNfcDepActivation__bindgen_ty_2>(),
	           1usize,
	           concat!("Alignment of ", stringify!(rfalNfcDepActivation__bindgen_ty_2))
	);
	fn test_field_ATR_REQ() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcDepActivation__bindgen_ty_2>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).ATR_REQ) as usize - ptr as usize
		           },
		           0usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalNfcDepActivation__bindgen_ty_2),
			"::",
			stringify!(ATR_REQ)
		)
		);
	}
	test_field_ATR_REQ();
	fn test_field_ATR_REQLen() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcDepActivation__bindgen_ty_2>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).ATR_REQLen) as usize - ptr as usize
		           },
		           64usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalNfcDepActivation__bindgen_ty_2),
			"::",
			stringify!(ATR_REQLen)
		)
		);
	}
	test_field_ATR_REQLen();
}
#[test]
fn bindgen_test_layout_rfalNfcDepActivation() {
	assert_eq!(
	           ::core::mem::size_of::<rfalNfcDepActivation>(),
	           66usize,
	           concat!("Size of: ", stringify!(rfalNfcDepActivation))
	);
	assert_eq!(
	           ::core::mem::align_of::<rfalNfcDepActivation>(),
	           1usize,
	           concat!("Alignment of ", stringify!(rfalNfcDepActivation))
	);
	fn test_field_Target() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcDepActivation>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).Target) as usize - ptr as usize
		           },
		           0usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalNfcDepActivation),
			"::",
			stringify!(Target)
		)
		);
	}
	test_field_Target();
	fn test_field_Initiator() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcDepActivation>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).Initiator) as usize - ptr as usize
		           },
		           0usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalNfcDepActivation),
			"::",
			stringify!(Initiator)
		)
		);
	}
	test_field_Initiator();
}
#[doc = " NFC-DEP device Info"]
#[repr(C)]
pub struct rfalNfcDepInfo {
	#[doc = "< General Bytes length"]
	pub GBLen: u8,
	#[doc = "< WT to be used (ignored in Listen Mode)"]
	pub WT: u8,
	#[doc = "< FWT to be used (1/fc)(ignored Listen Mode)"]
	pub FWT: u32,
	#[doc = "< Delta FWT to be used (1/fc)"]
	pub dFWT: u32,
	#[doc = "< Length Reduction coding the max payload"]
	pub LR: u8,
	#[doc = "< Frame Size"]
	pub FS: u16,
	#[doc = "< Bit Rate coding from Initiator  to Target"]
	pub DSI: rfalBitRate,
	#[doc = "< Bit Rate coding from Target to Initiator"]
	pub DRI: rfalBitRate,
	#[doc = "< Device ID (RFAL_NFCDEP_DID_NO if no DID)"]
	pub DID: u8,
	#[doc = "< Node ADdress (RFAL_NFCDEP_NAD_NO if no NAD)"]
	pub NAD: u8,
}
#[test]
fn bindgen_test_layout_rfalNfcDepInfo() {
	assert_eq!(
	           ::core::mem::size_of::<rfalNfcDepInfo>(),
	           28usize,
	           concat!("Size of: ", stringify!(rfalNfcDepInfo))
	);
	assert_eq!(
	           ::core::mem::align_of::<rfalNfcDepInfo>(),
	           4usize,
	           concat!("Alignment of ", stringify!(rfalNfcDepInfo))
	);
	fn test_field_GBLen() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcDepInfo>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).GBLen) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(rfalNfcDepInfo), "::", stringify!(GBLen))
		);
	}
	test_field_GBLen();
	fn test_field_WT() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcDepInfo>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).WT) as usize - ptr as usize
		           },
		           1usize,
		           concat!("Offset of field: ", stringify!(rfalNfcDepInfo), "::", stringify!(WT))
		);
	}
	test_field_WT();
	fn test_field_FWT() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcDepInfo>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).FWT) as usize - ptr as usize
		           },
		           4usize,
		           concat!("Offset of field: ", stringify!(rfalNfcDepInfo), "::", stringify!(FWT))
		);
	}
	test_field_FWT();
	fn test_field_dFWT() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcDepInfo>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).dFWT) as usize - ptr as usize
		           },
		           8usize,
		           concat!("Offset of field: ", stringify!(rfalNfcDepInfo), "::", stringify!(dFWT))
		);
	}
	test_field_dFWT();
	fn test_field_LR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcDepInfo>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).LR) as usize - ptr as usize
		           },
		           12usize,
		           concat!("Offset of field: ", stringify!(rfalNfcDepInfo), "::", stringify!(LR))
		);
	}
	test_field_LR();
	fn test_field_FS() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcDepInfo>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).FS) as usize - ptr as usize
		           },
		           14usize,
		           concat!("Offset of field: ", stringify!(rfalNfcDepInfo), "::", stringify!(FS))
		);
	}
	test_field_FS();
	fn test_field_DSI() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcDepInfo>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).DSI) as usize - ptr as usize
		           },
		           16usize,
		           concat!("Offset of field: ", stringify!(rfalNfcDepInfo), "::", stringify!(DSI))
		);
	}
	test_field_DSI();
	fn test_field_DRI() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcDepInfo>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).DRI) as usize - ptr as usize
		           },
		           20usize,
		           concat!("Offset of field: ", stringify!(rfalNfcDepInfo), "::", stringify!(DRI))
		);
	}
	test_field_DRI();
	fn test_field_DID() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcDepInfo>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).DID) as usize - ptr as usize
		           },
		           24usize,
		           concat!("Offset of field: ", stringify!(rfalNfcDepInfo), "::", stringify!(DID))
		);
	}
	test_field_DID();
	fn test_field_NAD() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcDepInfo>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).NAD) as usize - ptr as usize
		           },
		           25usize,
		           concat!("Offset of field: ", stringify!(rfalNfcDepInfo), "::", stringify!(NAD))
		);
	}
	test_field_NAD();
}
#[doc = " NFC-DEP Device structure"]
#[repr(C)]
pub struct rfalNfcDepDevice {
	#[doc = "< Activation Info"]
	pub activation: rfalNfcDepActivation,
	#[doc = "< NFC-DEP device Info"]
	pub info: rfalNfcDepInfo,
}
#[test]
fn bindgen_test_layout_rfalNfcDepDevice() {
	assert_eq!(
	           ::core::mem::size_of::<rfalNfcDepDevice>(),
	           96usize,
	           concat!("Size of: ", stringify!(rfalNfcDepDevice))
	);
	assert_eq!(
	           ::core::mem::align_of::<rfalNfcDepDevice>(),
	           4usize,
	           concat!("Alignment of ", stringify!(rfalNfcDepDevice))
	);
	fn test_field_activation() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcDepDevice>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).activation) as usize - ptr as usize
		           },
		           0usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalNfcDepDevice),
			"::",
			stringify!(activation)
		)
		);
	}
	test_field_activation();
	fn test_field_info() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcDepDevice>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).info) as usize - ptr as usize
		           },
		           68usize,
		           concat!("Offset of field: ", stringify!(rfalNfcDepDevice), "::", stringify!(info))
		);
	}
	test_field_info();
}
#[doc = " NFCIP Protocol structure for P2P Target"]
#[doc = ""]
#[doc = "   operParam : derives from NFC-Forum NCI NFC-DEP Operation Parameter"]
#[doc = "               NCI 1.1 Table 86: NFC-DEP Operation Parameter"]
#[doc = "               and it's a bit mask composed as:"]
#[doc = "                  [ 0000b"]
#[doc = "                    | Chain SHALL use max. Transport Data Byte[1b]"]
#[doc = "                    | I-PDU with no Transport Data SHALL NOT be sent [1b]"]
#[doc = "                    | NFC-DEP Target SHALL NOT send RTOX request [1b]"]
#[doc = "                  ]"]
#[doc = ""]
#[repr(C)]
pub struct rfalNfcDepAtrParam {
	#[doc = "< Initiator in Active P2P or Passive P2P"]
	pub commMode: rfalNfcDepCommMode,
	#[doc = "< NFC-DEP Operation Parameter"]
	pub operParam: u8,
	#[doc = "< Initiator's NFCID2 or NFCID3"]
	pub nfcid: *mut u8,
	#[doc = "< Initiator's NFCID length (NFCID2/3)"]
	pub nfcidLen: u8,
	#[doc = "< Initiator's Device ID DID"]
	pub DID: u8,
	#[doc = "< Initiator's Node ID NAD"]
	pub NAD: u8,
	#[doc = "< Initiator's Bit Rates supported in Tx"]
	pub BS: u8,
	#[doc = "< Initiator's Bit Rates supported in Rx"]
	pub BR: u8,
	#[doc = "< Initiator's Length reduction"]
	pub LR: u8,
	#[doc = "< Initiator's General Bytes (Gi)"]
	pub GB: *mut u8,
	#[doc = "< Initiator's General Bytes length"]
	pub GBLen: u8,
}
#[test]
fn bindgen_test_layout_rfalNfcDepAtrParam() {
	assert_eq!(
	           ::core::mem::size_of::<rfalNfcDepAtrParam>(),
	           28usize,
	           concat!("Size of: ", stringify!(rfalNfcDepAtrParam))
	);
	assert_eq!(
	           ::core::mem::align_of::<rfalNfcDepAtrParam>(),
	           4usize,
	           concat!("Alignment of ", stringify!(rfalNfcDepAtrParam))
	);
	fn test_field_commMode() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcDepAtrParam>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).commMode) as usize - ptr as usize
		           },
		           0usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalNfcDepAtrParam),
			"::",
			stringify!(commMode)
		)
		);
	}
	test_field_commMode();
	fn test_field_operParam() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcDepAtrParam>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).operParam) as usize - ptr as usize
		           },
		           4usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalNfcDepAtrParam),
			"::",
			stringify!(operParam)
		)
		);
	}
	test_field_operParam();
	fn test_field_nfcid() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcDepAtrParam>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).nfcid) as usize - ptr as usize
		           },
		           8usize,
		           concat!("Offset of field: ", stringify!(rfalNfcDepAtrParam), "::", stringify!(nfcid))
		);
	}
	test_field_nfcid();
	fn test_field_nfcidLen() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcDepAtrParam>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).nfcidLen) as usize - ptr as usize
		           },
		           12usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalNfcDepAtrParam),
			"::",
			stringify!(nfcidLen)
		)
		);
	}
	test_field_nfcidLen();
	fn test_field_DID() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcDepAtrParam>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).DID) as usize - ptr as usize
		           },
		           13usize,
		           concat!("Offset of field: ", stringify!(rfalNfcDepAtrParam), "::", stringify!(DID))
		);
	}
	test_field_DID();
	fn test_field_NAD() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcDepAtrParam>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).NAD) as usize - ptr as usize
		           },
		           14usize,
		           concat!("Offset of field: ", stringify!(rfalNfcDepAtrParam), "::", stringify!(NAD))
		);
	}
	test_field_NAD();
	fn test_field_BS() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcDepAtrParam>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).BS) as usize - ptr as usize
		           },
		           15usize,
		           concat!("Offset of field: ", stringify!(rfalNfcDepAtrParam), "::", stringify!(BS))
		);
	}
	test_field_BS();
	fn test_field_BR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcDepAtrParam>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).BR) as usize - ptr as usize
		           },
		           16usize,
		           concat!("Offset of field: ", stringify!(rfalNfcDepAtrParam), "::", stringify!(BR))
		);
	}
	test_field_BR();
	fn test_field_LR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcDepAtrParam>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).LR) as usize - ptr as usize
		           },
		           17usize,
		           concat!("Offset of field: ", stringify!(rfalNfcDepAtrParam), "::", stringify!(LR))
		);
	}
	test_field_LR();
	fn test_field_GB() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcDepAtrParam>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).GB) as usize - ptr as usize
		           },
		           20usize,
		           concat!("Offset of field: ", stringify!(rfalNfcDepAtrParam), "::", stringify!(GB))
		);
	}
	test_field_GB();
	fn test_field_GBLen() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcDepAtrParam>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).GBLen) as usize - ptr as usize
		           },
		           24usize,
		           concat!("Offset of field: ", stringify!(rfalNfcDepAtrParam), "::", stringify!(GBLen))
		);
	}
	test_field_GBLen();
}
#[doc = " Structure of parameters to be passed in for nfcDepListenStartActivation"]
#[repr(C)]
pub struct rfalNfcDepListenActvParam {
	#[doc = "< Receive Buffer struct reference"]
	pub rxBuf: *mut rfalNfcDepBufFormat,
	#[doc = "< Receive INF data length in bytes"]
	pub rxLen: *mut u16,
	#[doc = "< Received data is not complete"]
	pub isRxChaining: *mut bool,
	#[doc = "< NFC-DEP device info"]
	pub nfcDepDev: *mut rfalNfcDepDevice,
}
#[test]
fn bindgen_test_layout_rfalNfcDepListenActvParam() {
	assert_eq!(
	           ::core::mem::size_of::<rfalNfcDepListenActvParam>(),
	           16usize,
	           concat!("Size of: ", stringify!(rfalNfcDepListenActvParam))
	);
	assert_eq!(
	           ::core::mem::align_of::<rfalNfcDepListenActvParam>(),
	           4usize,
	           concat!("Alignment of ", stringify!(rfalNfcDepListenActvParam))
	);
	fn test_field_rxBuf() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcDepListenActvParam>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).rxBuf) as usize - ptr as usize
		           },
		           0usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalNfcDepListenActvParam),
			"::",
			stringify!(rxBuf)
		)
		);
	}
	test_field_rxBuf();
	fn test_field_rxLen() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcDepListenActvParam>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).rxLen) as usize - ptr as usize
		           },
		           4usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalNfcDepListenActvParam),
			"::",
			stringify!(rxLen)
		)
		);
	}
	test_field_rxLen();
	fn test_field_isRxChaining() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcDepListenActvParam>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).isRxChaining) as usize - ptr as usize
		           },
		           8usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalNfcDepListenActvParam),
			"::",
			stringify!(isRxChaining)
		)
		);
	}
	test_field_isRxChaining();
	fn test_field_nfcDepDev() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcDepListenActvParam>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).nfcDepDev) as usize - ptr as usize
		           },
		           12usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalNfcDepListenActvParam),
			"::",
			stringify!(nfcDepDev)
		)
		);
	}
	test_field_nfcDepDev();
}
#[doc = " NFCIP Protocol structure for P2P Target"]
#[doc = ""]
#[doc = "   operParam : derives from NFC-Forum NCI NFC-DEP Operation Parameter"]
#[doc = "               NCI 1.1 Table 86: NFC-DEP Operation Parameter"]
#[doc = "               and it's a bit mask composed as:"]
#[doc = "                  [ 0000b"]
#[doc = "                    | Chain SHALL use max. Transport Data Byte[1b]"]
#[doc = "                    | I-PDU with no Transport Data SHALL NOT be sent [1b]"]
#[doc = "                    | NFC-DEP Target SHALL NOT send RTOX request [1b]"]
#[doc = "                  ]"]
#[doc = ""]
#[repr(C)]
pub struct rfalNfcDepTargetParam {
	#[doc = "< Target in Active P2P or Passive P2P"]
	pub commMode: rfalNfcDepCommMode,
	#[doc = "< Target's NFCID3"]
	pub nfcid3: [u8; 10usize],
	#[doc = "< Target's Bit Rates supported in Tx"]
	pub bst: u8,
	#[doc = "< Target's Bit Rates supported in Rx"]
	pub brt: u8,
	#[doc = "< Target's timeout (TO) value"]
	pub to: u8,
	#[doc = "< Target's Presence optional Params(PPt)"]
	pub ppt: u8,
	#[doc = "< Target's General Bytes (Gt)"]
	pub GBt: [u8; 48usize],
	#[doc = "< Target's General Bytes length"]
	pub GBtLen: u8,
	#[doc = "< NFC-DEP Operation Parameter"]
	pub operParam: u8,
}
#[test]
fn bindgen_test_layout_rfalNfcDepTargetParam() {
	assert_eq!(
	           ::core::mem::size_of::<rfalNfcDepTargetParam>(),
	           68usize,
	           concat!("Size of: ", stringify!(rfalNfcDepTargetParam))
	);
	assert_eq!(
	           ::core::mem::align_of::<rfalNfcDepTargetParam>(),
	           4usize,
	           concat!("Alignment of ", stringify!(rfalNfcDepTargetParam))
	);
	fn test_field_commMode() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcDepTargetParam>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).commMode) as usize - ptr as usize
		           },
		           0usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalNfcDepTargetParam),
			"::",
			stringify!(commMode)
		)
		);
	}
	test_field_commMode();
	fn test_field_nfcid3() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcDepTargetParam>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).nfcid3) as usize - ptr as usize
		           },
		           4usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalNfcDepTargetParam),
			"::",
			stringify!(nfcid3)
		)
		);
	}
	test_field_nfcid3();
	fn test_field_bst() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcDepTargetParam>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).bst) as usize - ptr as usize
		           },
		           14usize,
		           concat!("Offset of field: ", stringify!(rfalNfcDepTargetParam), "::", stringify!(bst))
		);
	}
	test_field_bst();
	fn test_field_brt() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcDepTargetParam>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).brt) as usize - ptr as usize
		           },
		           15usize,
		           concat!("Offset of field: ", stringify!(rfalNfcDepTargetParam), "::", stringify!(brt))
		);
	}
	test_field_brt();
	fn test_field_to() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcDepTargetParam>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).to) as usize - ptr as usize
		           },
		           16usize,
		           concat!("Offset of field: ", stringify!(rfalNfcDepTargetParam), "::", stringify!(to))
		);
	}
	test_field_to();
	fn test_field_ppt() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcDepTargetParam>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).ppt) as usize - ptr as usize
		           },
		           17usize,
		           concat!("Offset of field: ", stringify!(rfalNfcDepTargetParam), "::", stringify!(ppt))
		);
	}
	test_field_ppt();
	fn test_field_GBt() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcDepTargetParam>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).GBt) as usize - ptr as usize
		           },
		           18usize,
		           concat!("Offset of field: ", stringify!(rfalNfcDepTargetParam), "::", stringify!(GBt))
		);
	}
	test_field_GBt();
	fn test_field_GBtLen() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcDepTargetParam>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).GBtLen) as usize - ptr as usize
		           },
		           66usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalNfcDepTargetParam),
			"::",
			stringify!(GBtLen)
		)
		);
	}
	test_field_GBtLen();
	fn test_field_operParam() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcDepTargetParam>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).operParam) as usize - ptr as usize
		           },
		           67usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalNfcDepTargetParam),
			"::",
			stringify!(operParam)
		)
		);
	}
	test_field_operParam();
}
#[doc = " Structure of parameters to be passed in for nfcDepStartIpduTransceive"]
#[repr(C)]
pub struct rfalNfcDepTxRxParam {
	#[doc = "< Transmit Buffer struct reference"]
	pub txBuf: *mut rfalNfcDepBufFormat,
	#[doc = "< Transmit Buffer INF field length in bytes"]
	pub txBufLen: u16,
	#[doc = "< Transmit data is not complete"]
	pub isTxChaining: bool,
	#[doc = "< Receive Buffer struct reference"]
	pub rxBuf: *mut rfalNfcDepBufFormat,
	#[doc = "< Receive INF data length"]
	pub rxLen: *mut u16,
	#[doc = "< Received data is not complete"]
	pub isRxChaining: *mut bool,
	#[doc = "< FWT to be used (ignored in Listen Mode)"]
	pub FWT: u32,
	#[doc = "< Delta FWT to be used"]
	pub dFWT: u32,
	#[doc = "< Other device Frame Size (FSD or FSC)"]
	pub FSx: u16,
	#[doc = "< Device ID (RFAL_ISODEP_NO_DID if no DID)"]
	pub DID: u8,
}
#[test]
fn bindgen_test_layout_rfalNfcDepTxRxParam() {
	assert_eq!(
	           ::core::mem::size_of::<rfalNfcDepTxRxParam>(),
	           32usize,
	           concat!("Size of: ", stringify!(rfalNfcDepTxRxParam))
	);
	assert_eq!(
	           ::core::mem::align_of::<rfalNfcDepTxRxParam>(),
	           4usize,
	           concat!("Alignment of ", stringify!(rfalNfcDepTxRxParam))
	);
	fn test_field_txBuf() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcDepTxRxParam>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).txBuf) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(rfalNfcDepTxRxParam), "::", stringify!(txBuf))
		);
	}
	test_field_txBuf();
	fn test_field_txBufLen() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcDepTxRxParam>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).txBufLen) as usize - ptr as usize
		           },
		           4usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalNfcDepTxRxParam),
			"::",
			stringify!(txBufLen)
		)
		);
	}
	test_field_txBufLen();
	fn test_field_isTxChaining() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcDepTxRxParam>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).isTxChaining) as usize - ptr as usize
		           },
		           6usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalNfcDepTxRxParam),
			"::",
			stringify!(isTxChaining)
		)
		);
	}
	test_field_isTxChaining();
	fn test_field_rxBuf() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcDepTxRxParam>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).rxBuf) as usize - ptr as usize
		           },
		           8usize,
		           concat!("Offset of field: ", stringify!(rfalNfcDepTxRxParam), "::", stringify!(rxBuf))
		);
	}
	test_field_rxBuf();
	fn test_field_rxLen() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcDepTxRxParam>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).rxLen) as usize - ptr as usize
		           },
		           12usize,
		           concat!("Offset of field: ", stringify!(rfalNfcDepTxRxParam), "::", stringify!(rxLen))
		);
	}
	test_field_rxLen();
	fn test_field_isRxChaining() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcDepTxRxParam>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).isRxChaining) as usize - ptr as usize
		           },
		           16usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalNfcDepTxRxParam),
			"::",
			stringify!(isRxChaining)
		)
		);
	}
	test_field_isRxChaining();
	fn test_field_FWT() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcDepTxRxParam>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).FWT) as usize - ptr as usize
		           },
		           20usize,
		           concat!("Offset of field: ", stringify!(rfalNfcDepTxRxParam), "::", stringify!(FWT))
		);
	}
	test_field_FWT();
	fn test_field_dFWT() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcDepTxRxParam>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).dFWT) as usize - ptr as usize
		           },
		           24usize,
		           concat!("Offset of field: ", stringify!(rfalNfcDepTxRxParam), "::", stringify!(dFWT))
		);
	}
	test_field_dFWT();
	fn test_field_FSx() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcDepTxRxParam>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).FSx) as usize - ptr as usize
		           },
		           28usize,
		           concat!("Offset of field: ", stringify!(rfalNfcDepTxRxParam), "::", stringify!(FSx))
		);
	}
	test_field_FSx();
	fn test_field_DID() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcDepTxRxParam>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).DID) as usize - ptr as usize
		           },
		           30usize,
		           concat!("Offset of field: ", stringify!(rfalNfcDepTxRxParam), "::", stringify!(DID))
		);
	}
	test_field_DID();
}
#[doc = " Structure of parameters used on NFC DEP PDU Transceive"]
#[repr(C)]
pub struct rfalNfcDepPduTxRxParam {
	#[doc = "< Transmit Buffer struct reference"]
	pub txBuf: *mut rfalNfcDepPduBufFormat,
	#[doc = "< Transmit Buffer INF field length in Bytes"]
	pub txBufLen: u16,
	#[doc = "< Receive Buffer struct reference in Bytes"]
	pub rxBuf: *mut rfalNfcDepPduBufFormat,
	#[doc = "< Received INF data length in Bytes"]
	pub rxLen: *mut u16,
	#[doc = "< Temp buffer for single PDUs (internal)"]
	pub tmpBuf: *mut rfalNfcDepBufFormat,
	#[doc = "< FWT to be used (ignored in Listen Mode)"]
	pub FWT: u32,
	#[doc = "< Delta FWT to be used"]
	pub dFWT: u32,
	#[doc = "< Other device Frame Size (FSD or FSC)"]
	pub FSx: u16,
	#[doc = "< Device ID (RFAL_ISODEP_NO_DID if no DID)"]
	pub DID: u8,
}
#[test]
fn bindgen_test_layout_rfalNfcDepPduTxRxParam() {
	assert_eq!(
	           ::core::mem::size_of::<rfalNfcDepPduTxRxParam>(),
	           32usize,
	           concat!("Size of: ", stringify!(rfalNfcDepPduTxRxParam))
	);
	assert_eq!(
	           ::core::mem::align_of::<rfalNfcDepPduTxRxParam>(),
	           4usize,
	           concat!("Alignment of ", stringify!(rfalNfcDepPduTxRxParam))
	);
	fn test_field_txBuf() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcDepPduTxRxParam>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).txBuf) as usize - ptr as usize
		           },
		           0usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalNfcDepPduTxRxParam),
			"::",
			stringify!(txBuf)
		)
		);
	}
	test_field_txBuf();
	fn test_field_txBufLen() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcDepPduTxRxParam>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).txBufLen) as usize - ptr as usize
		           },
		           4usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalNfcDepPduTxRxParam),
			"::",
			stringify!(txBufLen)
		)
		);
	}
	test_field_txBufLen();
	fn test_field_rxBuf() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcDepPduTxRxParam>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).rxBuf) as usize - ptr as usize
		           },
		           8usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalNfcDepPduTxRxParam),
			"::",
			stringify!(rxBuf)
		)
		);
	}
	test_field_rxBuf();
	fn test_field_rxLen() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcDepPduTxRxParam>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).rxLen) as usize - ptr as usize
		           },
		           12usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalNfcDepPduTxRxParam),
			"::",
			stringify!(rxLen)
		)
		);
	}
	test_field_rxLen();
	fn test_field_tmpBuf() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcDepPduTxRxParam>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).tmpBuf) as usize - ptr as usize
		           },
		           16usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalNfcDepPduTxRxParam),
			"::",
			stringify!(tmpBuf)
		)
		);
	}
	test_field_tmpBuf();
	fn test_field_FWT() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcDepPduTxRxParam>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).FWT) as usize - ptr as usize
		           },
		           20usize,
		           concat!("Offset of field: ", stringify!(rfalNfcDepPduTxRxParam), "::", stringify!(FWT))
		);
	}
	test_field_FWT();
	fn test_field_dFWT() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcDepPduTxRxParam>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).dFWT) as usize - ptr as usize
		           },
		           24usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalNfcDepPduTxRxParam),
			"::",
			stringify!(dFWT)
		)
		);
	}
	test_field_dFWT();
	fn test_field_FSx() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcDepPduTxRxParam>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).FSx) as usize - ptr as usize
		           },
		           28usize,
		           concat!("Offset of field: ", stringify!(rfalNfcDepPduTxRxParam), "::", stringify!(FSx))
		);
	}
	test_field_FSx();
	fn test_field_DID() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcDepPduTxRxParam>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).DID) as usize - ptr as usize
		           },
		           30usize,
		           concat!("Offset of field: ", stringify!(rfalNfcDepPduTxRxParam), "::", stringify!(DID))
		);
	}
	test_field_DID();
}
extern "C" {
	#[doc = " \\brief NFCIP Initialize"]
	#[doc = ""]
	#[doc = " This method resets all NFC-DEP inner states, counters and context and sets"]
	#[doc = " default values"]
	#[doc = ""]
	#[doc = ""]
	pub fn rfalNfcDepInitialize();
}
extern "C" {
	#[doc = " \\brief Set deactivating callback"]
	#[doc = ""]
	#[doc = " Sets the deactivating callback so that nfcip layer can check if upper layer"]
	#[doc = " has a deactivation pending, and not perform error recovery upon specific"]
	#[doc = " errors"]
	#[doc = ""]
	#[doc = " \\param[in] pFunc : method pointer to deactivation flag check"]
	#[doc = ""]
	pub fn rfalNfcDepSetDeactivatingCallback(pFunc: rfalNfcDepDeactCallback);
}
extern "C" {
	#[doc = " \\brief Calculate Response Waiting Time"]
	#[doc = ""]
	#[doc = " Calculates the Response Waiting Time (RWT) from the given Waiting Time (WT)"]
	#[doc = ""]
	#[doc = " \\param[in]  wt : the WT value to calculate RWT"]
	#[doc = ""]
	#[doc = " \\return RWT value in 1/fc"]
	#[doc = ""]
	pub fn rfalNfcDepCalculateRWT(wt: u8) -> u32;
}
extern "C" {
	#[doc = " \\brief NFC-DEP Initiator ATR (Attribute Request)"]
	#[doc = ""]
	#[doc = " This method configures the NFC-DEP layer with given parameters and then"]
	#[doc = " sends an ATR to the Target with and checks for a valid response response"]
	#[doc = ""]
	#[doc = " \\param[in]   param     : parameters to initialize and compose the ATR"]
	#[doc = " \\param[out]  atrRes    : location to store the ATR_RES"]
	#[doc = " \\param[out]  atrResLen : length of the ATR_RES received"]
	#[doc = ""]
	#[doc = " \\return ERR_NONE    : No error"]
	#[doc = " \\return ERR_TIMEOUT : Timeout occurred"]
	#[doc = " \\return ERR_PROTO   : Protocol error occurred"]
	#[doc = ""]
	pub fn rfalNfcDepATR(param: *const rfalNfcDepAtrParam, atrRes: *mut rfalNfcDepAtrRes, atrResLen: *mut u8) -> ReturnCode;
}
extern "C" {
	#[doc = " \\brief NFC-DEP Initiator PSL (Parameter Selection)"]
	#[doc = ""]
	#[doc = " This method sends a PSL to the Target with the given parameters and checks"]
	#[doc = " for a valid response response"]
	#[doc = ""]
	#[doc = " The parameters must be coded according to  Digital 1.1  16.7.1"]
	#[doc = ""]
	#[doc = " \\param[in] BRS : the selected Bit Rates for Initiator and Target"]
	#[doc = " \\param[in] FSL : the maximum length of Commands and Responses"]
	#[doc = ""]
	#[doc = " \\return ERR_NONE    : No error"]
	#[doc = " \\return ERR_TIMEOUT : Timeout occurred"]
	#[doc = " \\return ERR_PROTO   : Protocol error occurred"]
	#[doc = ""]
	pub fn rfalNfcDepPSL(BRS: u8, FSL: u8) -> ReturnCode;
}
extern "C" {
	#[doc = " \\brief NFC-DEP Initiator DSL (Deselect)"]
	#[doc = ""]
	#[doc = " This method checks if the NFCIP module is configured as initiator and if"]
	#[doc = " so sends a DSL REQ, waits  the target's response and checks it"]
	#[doc = ""]
	#[doc = " In case of performing as target no action is taken"]
	#[doc = ""]
	#[doc = " \\return ERR_NONE       : No error"]
	#[doc = " \\return ERR_TIMEOUT    : Timeout occurred"]
	#[doc = " \\return ERR_MAX_RERUNS : Timeout occurred"]
	#[doc = " \\return ERR_PROTO      : Protocol error occurred"]
	#[doc = ""]
	pub fn rfalNfcDepDSL() -> ReturnCode;
}
extern "C" {
	#[doc = " \\brief NFC-DEP Initiator RLS (Release)"]
	#[doc = ""]
	#[doc = " This method checks if the NFCIP module is configured as initiator and if"]
	#[doc = " so sends a RLS REQ, waits target's response and checks it"]
	#[doc = ""]
	#[doc = " In case of performing as target no action is taken"]
	#[doc = ""]
	#[doc = " \\return ERR_NONE       : No error"]
	#[doc = " \\return ERR_TIMEOUT    : Timeout occurred"]
	#[doc = " \\return ERR_MAX_RERUNS : Timeout occurred"]
	#[doc = " \\return ERR_PROTO      : Protocol error occurred"]
	#[doc = ""]
	pub fn rfalNfcDepRLS() -> ReturnCode;
}
extern "C" {
	#[doc = "  \\brief  NFC-DEP Initiator Handle  Activation"]
	#[doc = ""]
	#[doc = "  This performs a Activation into NFC-DEP layer with the given"]
	#[doc = "  parameters. It sends ATR_REQ and if the higher bit rates are supported by"]
	#[doc = "  both devices it additionally sends PSL"]
	#[doc = "  Once Activated all details of the device are provided on nfcDepDev"]
	#[doc = ""]
	#[doc = "  \\param[in]  param     : required parameters to initialize and send ATR_REQ"]
	#[doc = "  \\param[in]  desiredBR : Desired bit rate supported by the Poller"]
	#[doc = "  \\param[out] nfcDepDev : NFC-DEP information of the activated Listen device"]
	#[doc = ""]
	#[doc = "  \\return ERR_WRONG_STATE  : RFAL not initialized or incorrect mode"]
	#[doc = "  \\return ERR_PARAM        : Invalid parameters"]
	#[doc = "  \\return ERR_IO           : Generic internal error"]
	#[doc = "  \\return ERR_TIMEOUT      : Timeout error"]
	#[doc = "  \\return ERR_PAR          : Parity error detected"]
	#[doc = "  \\return ERR_CRC          : CRC error detected"]
	#[doc = "  \\return ERR_FRAMING      : Framing error detected"]
	#[doc = "  \\return ERR_PROTO        : Protocol error detected"]
	#[doc = "  \\return ERR_NONE         : No error, activation successful"]
	#[doc = ""]
	pub fn rfalNfcDepInitiatorHandleActivation(param: *mut rfalNfcDepAtrParam,
	                                           desiredBR: rfalBitRate,
	                                           nfcDepDev: *mut rfalNfcDepDevice)
	                                           -> ReturnCode;
}
extern "C" {
	#[doc = " \\brief Check if buffer contains valid ATR_REQ"]
	#[doc = ""]
	#[doc = " This method checks if the given ATR_REQ is valid"]
	#[doc = ""]
	#[doc = ""]
	#[doc = " \\param[in]  buf    : buffer holding Initiator's received request"]
	#[doc = " \\param[in]  bufLen : size of the msg contained on the buf in Bytes"]
	#[doc = " \\param[out] nfcid3 : pointer to where the NFCID3 may be outputed,"]
	#[doc = "                       nfcid3 has NFCF_SENSF_NFCID3_LEN as length"]
	#[doc = "                       Pass NULL if output parameter not desired"]
	#[doc = ""]
	#[doc = " \\return true  : Valid ATR_REQ received, the ATR_RES has been computed in txBuf"]
	#[doc = " \\return false : Invalid protocol request"]
	#[doc = ""]
	#[doc = ""]
	pub fn rfalNfcDepIsAtrReq(buf: *const u8, bufLen: u16, nfcid3: *mut u8) -> bool;
}
extern "C" {
	#[doc = " \\brief Check is Target has received ATR"]
	#[doc = ""]
	#[doc = " This method checks if the NFCIP module is configured as target and if a"]
	#[doc = " ATR REQ has been received ( whether is in activation or in data exchange)"]
	#[doc = ""]
	#[doc = " \\return true  : a ATR has already been received"]
	#[doc = " \\return false : no ATR has been received"]
	#[doc = ""]
	pub fn rfalNfcDepTargetRcvdATR() -> bool;
}
extern "C" {
	#[doc = " \\brief NFCDEP Start Listen Activation Handling"]
	#[doc = ""]
	#[doc = " Start Activation Handling and setup to receive first frame which may"]
	#[doc = " contain complete or partial DEP-REQ after activation is completed"]
	#[doc = ""]
	#[doc = " Pass in ATR_REQ for NFC-DEP to handle ATR_RES. The Activation Handling"]
	#[doc = " handles ATR_RES and PSL_RES if a PSL_REQ is received"]
	#[doc = ""]
	#[doc = " Activation is completed if PSL_RES is sent or if first I-PDU is received"]
	#[doc = ""]
	#[doc = " \\ref rfalNfcDepListenGetActivationStatus() provide status of the"]
	#[doc = "       ongoing activation"]
	#[doc = ""]
	#[doc = " \\warning nfcDepGetTransceiveStatus() shall be called right after activation"]
	#[doc = " is completed (i.e. rfalNfcDepListenGetActivationStatus() return ERR_NONE)"]
	#[doc = " to check for first received frame."]
	#[doc = ""]
	#[doc = " \\param[in]  param       : Target parameters to be used"]
	#[doc = " \\param[in]  atrReq      : reference to buffer containing ATR_REQ"]
	#[doc = " \\param[in]  atrReqLength: Length of ATR_REQ"]
	#[doc = " \\param[out] rxParam     : references to buffer, length and chaining indication"]
	#[doc = "                           for first complete LLCP to be received"]
	#[doc = ""]
	#[doc = " \\return ERR_NONE      : ATR_REQ is valid and activation ongoing"]
	#[doc = " \\return ERR_PARAM     : ATR_REQ or other params are invalid"]
	#[doc = " \\return ERR_LINK_LOSS : Remote Field is turned off"]
	#[doc = ""]
	pub fn rfalNfcDepListenStartActivation(param: *const rfalNfcDepTargetParam,
	                                       atrReq: *const u8,
	                                       atrReqLength: u16,
	                                       rxParam: rfalNfcDepListenActvParam)
	                                       -> ReturnCode;
}
extern "C" {
	#[doc = " \\brief Get the current NFC-DEP Activation Status"]
	#[doc = ""]
	#[doc = " \\return ERR_NONE      : Activation has completed successfully"]
	#[doc = " \\return ERR_BUSY      : Activation is ongoing"]
	#[doc = " \\return ERR_LINK_LOSS : Remote Field was turned off"]
	#[doc = ""]
	pub fn rfalNfcDepListenGetActivationStatus() -> ReturnCode;
}
extern "C" {
	#[doc = " \\brief Start Transceive"]
	#[doc = ""]
	#[doc = " Transceives a complete or partial DEP block"]
	#[doc = ""]
	#[doc = " The txBuf contains complete or partial of DEP to be transmitted."]
	#[doc = " The Prologue field of the I-PDU is handled internally"]
	#[doc = ""]
	#[doc = " If the buffer contains partial LLCP and is not the last block, then"]
	#[doc = " isTxChaining must be set to true"]
	#[doc = ""]
	#[doc = " \\param[in] param: reference parameters to be used for the Transceive"]
	#[doc = ""]
	#[doc = " \\return ERR_PARAM       : Bad request"]
	#[doc = " \\return ERR_WRONG_STATE : The module is not in a proper state"]
	#[doc = " \\return ERR_NONE        : The Transceive request has been started"]
	#[doc = ""]
	pub fn rfalNfcDepStartTransceive(param: *const rfalNfcDepTxRxParam) -> ReturnCode;
}
extern "C" {
	#[doc = " \\brief Return the Transceive status"]
	#[doc = ""]
	#[doc = " Returns the status of the NFC-DEP Transceive"]
	#[doc = ""]
	#[doc = " \\warning  When the other device is performing chaining once a chained"]
	#[doc = "            block is received the error ERR_AGAIN is sent. At this point"]
	#[doc = "            caller must handle the received data immediately."]
	#[doc = "            When ERR_AGAIN is returned an ACK has already been sent to"]
	#[doc = "            the other device and the next block might be incoming."]
	#[doc = "            If rfalWorker() is called frequently it will place the next"]
	#[doc = "            block on the given buffer"]
	#[doc = ""]
	#[doc = " \\return ERR_NONE      : Transceive has been completed successfully"]
	#[doc = " \\return ERR_BUSY      : Transceive is ongoing"]
	#[doc = " \\return ERR_PROTO     : Protocol error occurred"]
	#[doc = " \\return ERR_TIMEOUT   : Timeout error occurred"]
	#[doc = " \\return ERR_SLEEP_REQ : Deselect has been received and responded"]
	#[doc = " \\return ERR_NOMEM     : The received I-PDU does not fit into the"]
	#[doc = "                            receive buffer"]
	#[doc = " \\return ERR_LINK_LOSS : Communication is lost because Reader/Writer"]
	#[doc = "                            has turned off its field"]
	#[doc = " \\return ERR_AGAIN     : received one chaining block, continue to call"]
	#[doc = "                            this method to retrieve the remaining blocks"]
	#[doc = ""]
	pub fn rfalNfcDepGetTransceiveStatus() -> ReturnCode;
}
extern "C" {
	#[doc = " \\brief Start PDU Transceive"]
	#[doc = ""]
	#[doc = " This method triggers a NFC-DEP Transceive containing a complete PDU"]
	#[doc = " It transmits the given message and handles all protocol retransmitions,"]
	#[doc = " error handling and control messages"]
	#[doc = ""]
	#[doc = " The txBuf  contains a complete PDU to be transmitted"]
	#[doc = " The Prologue field will be manipulated by the Transceive"]
	#[doc = ""]
	#[doc = " \\warning the txBuf will be modified during the transmission"]
	#[doc = " \\warning the maximum RF frame which can be received is limited by param.tmpBuf"]
	#[doc = ""]
	#[doc = " \\param[in] param: reference parameters to be used for the Transceive"]
	#[doc = ""]
	#[doc = " \\return ERR_PARAM       : Bad request"]
	#[doc = " \\return ERR_WRONG_STATE : The module is not in a proper state"]
	#[doc = " \\return ERR_NONE        : The Transceive request has been started"]
	#[doc = ""]
	pub fn rfalNfcDepStartPduTransceive(param: rfalNfcDepPduTxRxParam) -> ReturnCode;
}
extern "C" {
	#[doc = " \\brief Return the PSU Transceive status"]
	#[doc = ""]
	#[doc = " Returns the status of the NFC-DEP PDU Transceive"]
	#[doc = ""]
	#[doc = ""]
	#[doc = " \\return ERR_NONE      : Transceive has been completed successfully"]
	#[doc = " \\return ERR_BUSY      : Transceive is ongoing"]
	#[doc = " \\return ERR_PROTO     : Protocol error occurred"]
	#[doc = " \\return ERR_TIMEOUT   : Timeout error occurred"]
	#[doc = " \\return ERR_SLEEP_REQ : Deselect has been received and responded"]
	#[doc = " \\return ERR_NOMEM     : The received I-PDU does not fit into the"]
	#[doc = "                            receive buffer"]
	#[doc = " \\return ERR_LINK_LOSS : Communication is lost because Reader/Writer"]
	#[doc = "                            has turned off its field"]
	#[doc = ""]
	pub fn rfalNfcDepGetPduTransceiveStatus() -> ReturnCode;
}
#[repr(u32)]
#[non_exhaustive]
#[doc = " Frame Size for Proximity Card Integer definitions"]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum rfalIsoDepFSxI {
	RFAL_ISODEP_FSXI_16 = 0,
	RFAL_ISODEP_FSXI_24 = 1,
	RFAL_ISODEP_FSXI_32 = 2,
	RFAL_ISODEP_FSXI_40 = 3,
	RFAL_ISODEP_FSXI_48 = 4,
	RFAL_ISODEP_FSXI_64 = 5,
	RFAL_ISODEP_FSXI_96 = 6,
	RFAL_ISODEP_FSXI_128 = 7,
	RFAL_ISODEP_FSXI_256 = 8,
	RFAL_ISODEP_FSXI_512 = 9,
	RFAL_ISODEP_FSXI_1024 = 10,
	RFAL_ISODEP_FSXI_2048 = 11,
	RFAL_ISODEP_FSXI_4096 = 12,
}
#[repr(u32)]
#[non_exhaustive]
#[doc = " Frame Size for Proximity Card  definitions"]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum rfalIsoDepFSx {
	RFAL_ISODEP_FSX_16 = 16,
	RFAL_ISODEP_FSX_24 = 24,
	RFAL_ISODEP_FSX_32 = 32,
	RFAL_ISODEP_FSX_40 = 40,
	RFAL_ISODEP_FSX_48 = 48,
	RFAL_ISODEP_FSX_64 = 64,
	RFAL_ISODEP_FSX_96 = 96,
	RFAL_ISODEP_FSX_128 = 128,
	RFAL_ISODEP_FSX_256 = 256,
	RFAL_ISODEP_FSX_512 = 512,
	RFAL_ISODEP_FSX_1024 = 1024,
	RFAL_ISODEP_FSX_2048 = 2048,
	RFAL_ISODEP_FSX_4096 = 4096,
}
#[doc = " RATS format  Digital 1.1 13.6.1"]
#[repr(C)]
pub struct rfalIsoDepRats {
	#[doc = "< RATS command byte: 0xE0"]
	pub CMD: u8,
	#[doc = "< Param indicating FSDI and DID"]
	pub PARAM: u8,
}
#[test]
fn bindgen_test_layout_rfalIsoDepRats() {
	assert_eq!(
	           ::core::mem::size_of::<rfalIsoDepRats>(),
	           2usize,
	           concat!("Size of: ", stringify!(rfalIsoDepRats))
	);
	assert_eq!(
	           ::core::mem::align_of::<rfalIsoDepRats>(),
	           1usize,
	           concat!("Alignment of ", stringify!(rfalIsoDepRats))
	);
	fn test_field_CMD() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalIsoDepRats>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).CMD) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(rfalIsoDepRats), "::", stringify!(CMD))
		);
	}
	test_field_CMD();
	fn test_field_PARAM() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalIsoDepRats>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).PARAM) as usize - ptr as usize
		           },
		           1usize,
		           concat!("Offset of field: ", stringify!(rfalIsoDepRats), "::", stringify!(PARAM))
		);
	}
	test_field_PARAM();
}
#[doc = " ATS response format  Digital 1.1 13.6.2"]
#[repr(C)]
pub struct rfalIsoDepAts {
	#[doc = "< Length Byte, including TL byte itself"]
	pub TL: u8,
	#[doc = "< Format Byte T0 indicating if TA, TB, TC"]
	pub T0: u8,
	#[doc = "< Interface Byte TA(1)"]
	pub TA: u8,
	#[doc = "< Interface Byte TB(1)"]
	pub TB: u8,
	#[doc = "< Interface Byte TC(1)"]
	pub TC: u8,
	#[doc = "< Historical Bytes"]
	pub HB: [u8; 15usize],
}
#[test]
fn bindgen_test_layout_rfalIsoDepAts() {
	assert_eq!(
	           ::core::mem::size_of::<rfalIsoDepAts>(),
	           20usize,
	           concat!("Size of: ", stringify!(rfalIsoDepAts))
	);
	assert_eq!(
	           ::core::mem::align_of::<rfalIsoDepAts>(),
	           1usize,
	           concat!("Alignment of ", stringify!(rfalIsoDepAts))
	);
	fn test_field_TL() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalIsoDepAts>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).TL) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(rfalIsoDepAts), "::", stringify!(TL))
		);
	}
	test_field_TL();
	fn test_field_T0() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalIsoDepAts>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).T0) as usize - ptr as usize
		           },
		           1usize,
		           concat!("Offset of field: ", stringify!(rfalIsoDepAts), "::", stringify!(T0))
		);
	}
	test_field_T0();
	fn test_field_TA() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalIsoDepAts>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).TA) as usize - ptr as usize
		           },
		           2usize,
		           concat!("Offset of field: ", stringify!(rfalIsoDepAts), "::", stringify!(TA))
		);
	}
	test_field_TA();
	fn test_field_TB() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalIsoDepAts>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).TB) as usize - ptr as usize
		           },
		           3usize,
		           concat!("Offset of field: ", stringify!(rfalIsoDepAts), "::", stringify!(TB))
		);
	}
	test_field_TB();
	fn test_field_TC() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalIsoDepAts>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).TC) as usize - ptr as usize
		           },
		           4usize,
		           concat!("Offset of field: ", stringify!(rfalIsoDepAts), "::", stringify!(TC))
		);
	}
	test_field_TC();
	fn test_field_HB() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalIsoDepAts>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).HB) as usize - ptr as usize
		           },
		           5usize,
		           concat!("Offset of field: ", stringify!(rfalIsoDepAts), "::", stringify!(HB))
		);
	}
	test_field_HB();
}
#[doc = " PPS Request format (Protocol and Parameter Selection) ISO14443-4  5.3"]
#[repr(C)]
pub struct rfalIsoDepPpsReq {
	#[doc = "< Start Byte: [ 1101b | CID[4b] ]"]
	pub PPSS: u8,
	#[doc = "< Parameter 0:[ 000b | PPS1[1n] | 0001b ]"]
	pub PPS0: u8,
	#[doc = "< Parameter 1:[ 0000b | DSI[2b] | DRI[2b] ]"]
	pub PPS1: u8,
}
#[test]
fn bindgen_test_layout_rfalIsoDepPpsReq() {
	assert_eq!(
	           ::core::mem::size_of::<rfalIsoDepPpsReq>(),
	           3usize,
	           concat!("Size of: ", stringify!(rfalIsoDepPpsReq))
	);
	assert_eq!(
	           ::core::mem::align_of::<rfalIsoDepPpsReq>(),
	           1usize,
	           concat!("Alignment of ", stringify!(rfalIsoDepPpsReq))
	);
	fn test_field_PPSS() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalIsoDepPpsReq>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).PPSS) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(rfalIsoDepPpsReq), "::", stringify!(PPSS))
		);
	}
	test_field_PPSS();
	fn test_field_PPS0() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalIsoDepPpsReq>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).PPS0) as usize - ptr as usize
		           },
		           1usize,
		           concat!("Offset of field: ", stringify!(rfalIsoDepPpsReq), "::", stringify!(PPS0))
		);
	}
	test_field_PPS0();
	fn test_field_PPS1() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalIsoDepPpsReq>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).PPS1) as usize - ptr as usize
		           },
		           2usize,
		           concat!("Offset of field: ", stringify!(rfalIsoDepPpsReq), "::", stringify!(PPS1))
		);
	}
	test_field_PPS1();
}
#[doc = " PPS Response format (Protocol and Parameter Selection) ISO14443-4  5.4"]
#[repr(C)]
pub struct rfalIsoDepPpsRes {
	#[doc = "< Start Byte:  [ 1101b | CID[4b] ]"]
	pub PPSS: u8,
}
#[test]
fn bindgen_test_layout_rfalIsoDepPpsRes() {
	assert_eq!(
	           ::core::mem::size_of::<rfalIsoDepPpsRes>(),
	           1usize,
	           concat!("Size of: ", stringify!(rfalIsoDepPpsRes))
	);
	assert_eq!(
	           ::core::mem::align_of::<rfalIsoDepPpsRes>(),
	           1usize,
	           concat!("Alignment of ", stringify!(rfalIsoDepPpsRes))
	);
	fn test_field_PPSS() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalIsoDepPpsRes>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).PPSS) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(rfalIsoDepPpsRes), "::", stringify!(PPSS))
		);
	}
	test_field_PPSS();
}
#[doc = " ATTRIB Command Format  Digital 1.1  15.6.1"]
#[repr(C)]
pub struct rfalIsoDepAttribCmd {
	#[doc = "< ATTRIB_REQ command byte"]
	pub cmd: u8,
	#[doc = "< NFCID0 of the card to be selected"]
	pub nfcid0: [u8; 4usize],
	#[doc = "< Parameter of ATTRIB command"]
	pub Param: rfalIsoDepAttribCmd__bindgen_ty_1,
	#[doc = "< Higher Layer Information"]
	pub HLInfo: [u8; 32usize],
}
#[repr(C)]
pub struct rfalIsoDepAttribCmd__bindgen_ty_1 {
	#[doc = "< PARAM1 of ATTRIB command"]
	pub PARAM1: u8,
	#[doc = "< PARAM2 of ATTRIB command"]
	pub PARAM2: u8,
	#[doc = "< PARAM3 of ATTRIB command"]
	pub PARAM3: u8,
	#[doc = "< PARAM4 of ATTRIB command"]
	pub PARAM4: u8,
}
#[test]
fn bindgen_test_layout_rfalIsoDepAttribCmd__bindgen_ty_1() {
	assert_eq!(
	           ::core::mem::size_of::<rfalIsoDepAttribCmd__bindgen_ty_1>(),
	           4usize,
	           concat!("Size of: ", stringify!(rfalIsoDepAttribCmd__bindgen_ty_1))
	);
	assert_eq!(
	           ::core::mem::align_of::<rfalIsoDepAttribCmd__bindgen_ty_1>(),
	           1usize,
	           concat!("Alignment of ", stringify!(rfalIsoDepAttribCmd__bindgen_ty_1))
	);
	fn test_field_PARAM1() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalIsoDepAttribCmd__bindgen_ty_1>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).PARAM1) as usize - ptr as usize
		           },
		           0usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalIsoDepAttribCmd__bindgen_ty_1),
			"::",
			stringify!(PARAM1)
		)
		);
	}
	test_field_PARAM1();
	fn test_field_PARAM2() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalIsoDepAttribCmd__bindgen_ty_1>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).PARAM2) as usize - ptr as usize
		           },
		           1usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalIsoDepAttribCmd__bindgen_ty_1),
			"::",
			stringify!(PARAM2)
		)
		);
	}
	test_field_PARAM2();
	fn test_field_PARAM3() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalIsoDepAttribCmd__bindgen_ty_1>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).PARAM3) as usize - ptr as usize
		           },
		           2usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalIsoDepAttribCmd__bindgen_ty_1),
			"::",
			stringify!(PARAM3)
		)
		);
	}
	test_field_PARAM3();
	fn test_field_PARAM4() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalIsoDepAttribCmd__bindgen_ty_1>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).PARAM4) as usize - ptr as usize
		           },
		           3usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalIsoDepAttribCmd__bindgen_ty_1),
			"::",
			stringify!(PARAM4)
		)
		);
	}
	test_field_PARAM4();
}
#[test]
fn bindgen_test_layout_rfalIsoDepAttribCmd() {
	assert_eq!(
	           ::core::mem::size_of::<rfalIsoDepAttribCmd>(),
	           41usize,
	           concat!("Size of: ", stringify!(rfalIsoDepAttribCmd))
	);
	assert_eq!(
	           ::core::mem::align_of::<rfalIsoDepAttribCmd>(),
	           1usize,
	           concat!("Alignment of ", stringify!(rfalIsoDepAttribCmd))
	);
	fn test_field_cmd() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalIsoDepAttribCmd>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).cmd) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(rfalIsoDepAttribCmd), "::", stringify!(cmd))
		);
	}
	test_field_cmd();
	fn test_field_nfcid0() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalIsoDepAttribCmd>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).nfcid0) as usize - ptr as usize
		           },
		           1usize,
		           concat!("Offset of field: ", stringify!(rfalIsoDepAttribCmd), "::", stringify!(nfcid0))
		);
	}
	test_field_nfcid0();
	fn test_field_Param() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalIsoDepAttribCmd>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).Param) as usize - ptr as usize
		           },
		           5usize,
		           concat!("Offset of field: ", stringify!(rfalIsoDepAttribCmd), "::", stringify!(Param))
		);
	}
	test_field_Param();
	fn test_field_HLInfo() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalIsoDepAttribCmd>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).HLInfo) as usize - ptr as usize
		           },
		           9usize,
		           concat!("Offset of field: ", stringify!(rfalIsoDepAttribCmd), "::", stringify!(HLInfo))
		);
	}
	test_field_HLInfo();
}
#[doc = " ATTRIB Response Format  Digital 1.1  15.6.2"]
#[repr(C)]
pub struct rfalIsoDepAttribRes {
	#[doc = "< Contains MBLI and DID"]
	pub mbliDid: u8,
	#[doc = "< Higher Layer Information"]
	pub HLInfo: [u8; 32usize],
}
#[test]
fn bindgen_test_layout_rfalIsoDepAttribRes() {
	assert_eq!(
	           ::core::mem::size_of::<rfalIsoDepAttribRes>(),
	           33usize,
	           concat!("Size of: ", stringify!(rfalIsoDepAttribRes))
	);
	assert_eq!(
	           ::core::mem::align_of::<rfalIsoDepAttribRes>(),
	           1usize,
	           concat!("Alignment of ", stringify!(rfalIsoDepAttribRes))
	);
	fn test_field_mbliDid() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalIsoDepAttribRes>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).mbliDid) as usize - ptr as usize
		           },
		           0usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalIsoDepAttribRes),
			"::",
			stringify!(mbliDid)
		)
		);
	}
	test_field_mbliDid();
	fn test_field_HLInfo() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalIsoDepAttribRes>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).HLInfo) as usize - ptr as usize
		           },
		           1usize,
		           concat!("Offset of field: ", stringify!(rfalIsoDepAttribRes), "::", stringify!(HLInfo))
		);
	}
	test_field_HLInfo();
}
#[doc = " S(Parameters) Command Format  ISO14443-4 (2016) Table 4"]
#[repr(C)]
pub struct rfalIsoDepSParameter {
	#[doc = "< S(PARAMETERS) Tag field"]
	pub tag: u8,
	#[doc = "< S(PARAMETERS) Length field"]
	pub length: u8,
	#[doc = "< S(PARAMETERS) Value field"]
	pub value: [u8; 16usize],
}
#[test]
fn bindgen_test_layout_rfalIsoDepSParameter() {
	assert_eq!(
	           ::core::mem::size_of::<rfalIsoDepSParameter>(),
	           18usize,
	           concat!("Size of: ", stringify!(rfalIsoDepSParameter))
	);
	assert_eq!(
	           ::core::mem::align_of::<rfalIsoDepSParameter>(),
	           1usize,
	           concat!("Alignment of ", stringify!(rfalIsoDepSParameter))
	);
	fn test_field_tag() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalIsoDepSParameter>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).tag) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(rfalIsoDepSParameter), "::", stringify!(tag))
		);
	}
	test_field_tag();
	fn test_field_length() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalIsoDepSParameter>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).length) as usize - ptr as usize
		           },
		           1usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalIsoDepSParameter),
			"::",
			stringify!(length)
		)
		);
	}
	test_field_length();
	fn test_field_value() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalIsoDepSParameter>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).value) as usize - ptr as usize
		           },
		           2usize,
		           concat!("Offset of field: ", stringify!(rfalIsoDepSParameter), "::", stringify!(value))
		);
	}
	test_field_value();
}
#[doc = " Activation info as Poller and Listener for NFC-A and NFC-B"]
#[repr(C)]
pub struct rfalIsoDepActivation {
	pub A: __BindgenUnionField<rfalIsoDepActivation__bindgen_ty_1>,
	pub B: __BindgenUnionField<rfalIsoDepActivation__bindgen_ty_2>,
	pub bindgen_union_field: [u8; 42usize],
}
#[doc = " NFC-A information"]
#[repr(C)]
pub struct rfalIsoDepActivation__bindgen_ty_1 {
	pub Listener: __BindgenUnionField<rfalIsoDepActivation__bindgen_ty_1__bindgen_ty_1>,
	pub Poller: __BindgenUnionField<rfalIsoDepActivation__bindgen_ty_1__bindgen_ty_2>,
	pub bindgen_union_field: [u8; 21usize],
}
#[repr(C)]
pub struct rfalIsoDepActivation__bindgen_ty_1__bindgen_ty_1 {
	#[doc = "< ATS response            (Poller mode)"]
	pub ATS: rfalIsoDepAts,
	#[doc = "< ATS response length     (Poller mode)"]
	pub ATSLen: u8,
}
#[test]
fn bindgen_test_layout_rfalIsoDepActivation__bindgen_ty_1__bindgen_ty_1() {
	assert_eq!(
	           ::core::mem::size_of::<rfalIsoDepActivation__bindgen_ty_1__bindgen_ty_1>(),
	           21usize,
	           concat!("Size of: ", stringify!(rfalIsoDepActivation__bindgen_ty_1__bindgen_ty_1))
	);
	assert_eq!(
	           ::core::mem::align_of::<rfalIsoDepActivation__bindgen_ty_1__bindgen_ty_1>(),
	           1usize,
	           concat!("Alignment of ", stringify!(rfalIsoDepActivation__bindgen_ty_1__bindgen_ty_1))
	);
	fn test_field_ATS() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalIsoDepActivation__bindgen_ty_1__bindgen_ty_1>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).ATS) as usize - ptr as usize
		           },
		           0usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalIsoDepActivation__bindgen_ty_1__bindgen_ty_1),
			"::",
			stringify!(ATS)
		)
		);
	}
	test_field_ATS();
	fn test_field_ATSLen() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalIsoDepActivation__bindgen_ty_1__bindgen_ty_1>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).ATSLen) as usize - ptr as usize
		           },
		           20usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalIsoDepActivation__bindgen_ty_1__bindgen_ty_1),
			"::",
			stringify!(ATSLen)
		)
		);
	}
	test_field_ATSLen();
}
#[repr(C)]
pub struct rfalIsoDepActivation__bindgen_ty_1__bindgen_ty_2 {
	#[doc = "< RATS request          (Listener mode)"]
	pub RATS: rfalIsoDepRats,
}
#[test]
fn bindgen_test_layout_rfalIsoDepActivation__bindgen_ty_1__bindgen_ty_2() {
	assert_eq!(
	           ::core::mem::size_of::<rfalIsoDepActivation__bindgen_ty_1__bindgen_ty_2>(),
	           2usize,
	           concat!("Size of: ", stringify!(rfalIsoDepActivation__bindgen_ty_1__bindgen_ty_2))
	);
	assert_eq!(
	           ::core::mem::align_of::<rfalIsoDepActivation__bindgen_ty_1__bindgen_ty_2>(),
	           1usize,
	           concat!("Alignment of ", stringify!(rfalIsoDepActivation__bindgen_ty_1__bindgen_ty_2))
	);
	fn test_field_RATS() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalIsoDepActivation__bindgen_ty_1__bindgen_ty_2>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).RATS) as usize - ptr as usize
		           },
		           0usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalIsoDepActivation__bindgen_ty_1__bindgen_ty_2),
			"::",
			stringify!(RATS)
		)
		);
	}
	test_field_RATS();
}
#[test]
fn bindgen_test_layout_rfalIsoDepActivation__bindgen_ty_1() {
	assert_eq!(
	           ::core::mem::size_of::<rfalIsoDepActivation__bindgen_ty_1>(),
	           21usize,
	           concat!("Size of: ", stringify!(rfalIsoDepActivation__bindgen_ty_1))
	);
	assert_eq!(
	           ::core::mem::align_of::<rfalIsoDepActivation__bindgen_ty_1>(),
	           1usize,
	           concat!("Alignment of ", stringify!(rfalIsoDepActivation__bindgen_ty_1))
	);
	fn test_field_Listener() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalIsoDepActivation__bindgen_ty_1>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).Listener) as usize - ptr as usize
		           },
		           0usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalIsoDepActivation__bindgen_ty_1),
			"::",
			stringify!(Listener)
		)
		);
	}
	test_field_Listener();
	fn test_field_Poller() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalIsoDepActivation__bindgen_ty_1>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).Poller) as usize - ptr as usize
		           },
		           0usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalIsoDepActivation__bindgen_ty_1),
			"::",
			stringify!(Poller)
		)
		);
	}
	test_field_Poller();
}
#[doc = " NFC-B information"]
#[repr(C)]
pub struct rfalIsoDepActivation__bindgen_ty_2 {
	pub Listener: __BindgenUnionField<rfalIsoDepActivation__bindgen_ty_2__bindgen_ty_1>,
	pub Poller: __BindgenUnionField<rfalIsoDepActivation__bindgen_ty_2__bindgen_ty_2>,
	pub bindgen_union_field: [u8; 42usize],
}
#[repr(C)]
pub struct rfalIsoDepActivation__bindgen_ty_2__bindgen_ty_1 {
	#[doc = "< ATTRIB_RES              (Poller mode)"]
	pub ATTRIB_RES: rfalIsoDepAttribRes,
	#[doc = "< ATTRIB_RES length       (Poller mode)"]
	pub ATTRIB_RESLen: u8,
}
#[test]
fn bindgen_test_layout_rfalIsoDepActivation__bindgen_ty_2__bindgen_ty_1() {
	assert_eq!(
	           ::core::mem::size_of::<rfalIsoDepActivation__bindgen_ty_2__bindgen_ty_1>(),
	           34usize,
	           concat!("Size of: ", stringify!(rfalIsoDepActivation__bindgen_ty_2__bindgen_ty_1))
	);
	assert_eq!(
	           ::core::mem::align_of::<rfalIsoDepActivation__bindgen_ty_2__bindgen_ty_1>(),
	           1usize,
	           concat!("Alignment of ", stringify!(rfalIsoDepActivation__bindgen_ty_2__bindgen_ty_1))
	);
	fn test_field_ATTRIB_RES() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalIsoDepActivation__bindgen_ty_2__bindgen_ty_1>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).ATTRIB_RES) as usize - ptr as usize
		           },
		           0usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalIsoDepActivation__bindgen_ty_2__bindgen_ty_1),
			"::",
			stringify!(ATTRIB_RES)
		)
		);
	}
	test_field_ATTRIB_RES();
	fn test_field_ATTRIB_RESLen() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalIsoDepActivation__bindgen_ty_2__bindgen_ty_1>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).ATTRIB_RESLen) as usize - ptr as usize
		           },
		           33usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalIsoDepActivation__bindgen_ty_2__bindgen_ty_1),
			"::",
			stringify!(ATTRIB_RESLen)
		)
		);
	}
	test_field_ATTRIB_RESLen();
}
#[repr(C)]
pub struct rfalIsoDepActivation__bindgen_ty_2__bindgen_ty_2 {
	#[doc = "< ATTRIB request        (Listener mode)"]
	pub ATTRIB: rfalIsoDepAttribCmd,
	#[doc = "< ATTRIB request length (Listener mode)"]
	pub ATTRIBLen: u8,
}
#[test]
fn bindgen_test_layout_rfalIsoDepActivation__bindgen_ty_2__bindgen_ty_2() {
	assert_eq!(
	           ::core::mem::size_of::<rfalIsoDepActivation__bindgen_ty_2__bindgen_ty_2>(),
	           42usize,
	           concat!("Size of: ", stringify!(rfalIsoDepActivation__bindgen_ty_2__bindgen_ty_2))
	);
	assert_eq!(
	           ::core::mem::align_of::<rfalIsoDepActivation__bindgen_ty_2__bindgen_ty_2>(),
	           1usize,
	           concat!("Alignment of ", stringify!(rfalIsoDepActivation__bindgen_ty_2__bindgen_ty_2))
	);
	fn test_field_ATTRIB() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalIsoDepActivation__bindgen_ty_2__bindgen_ty_2>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).ATTRIB) as usize - ptr as usize
		           },
		           0usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalIsoDepActivation__bindgen_ty_2__bindgen_ty_2),
			"::",
			stringify!(ATTRIB)
		)
		);
	}
	test_field_ATTRIB();
	fn test_field_ATTRIBLen() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalIsoDepActivation__bindgen_ty_2__bindgen_ty_2>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).ATTRIBLen) as usize - ptr as usize
		           },
		           41usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalIsoDepActivation__bindgen_ty_2__bindgen_ty_2),
			"::",
			stringify!(ATTRIBLen)
		)
		);
	}
	test_field_ATTRIBLen();
}
#[test]
fn bindgen_test_layout_rfalIsoDepActivation__bindgen_ty_2() {
	assert_eq!(
	           ::core::mem::size_of::<rfalIsoDepActivation__bindgen_ty_2>(),
	           42usize,
	           concat!("Size of: ", stringify!(rfalIsoDepActivation__bindgen_ty_2))
	);
	assert_eq!(
	           ::core::mem::align_of::<rfalIsoDepActivation__bindgen_ty_2>(),
	           1usize,
	           concat!("Alignment of ", stringify!(rfalIsoDepActivation__bindgen_ty_2))
	);
	fn test_field_Listener() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalIsoDepActivation__bindgen_ty_2>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).Listener) as usize - ptr as usize
		           },
		           0usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalIsoDepActivation__bindgen_ty_2),
			"::",
			stringify!(Listener)
		)
		);
	}
	test_field_Listener();
	fn test_field_Poller() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalIsoDepActivation__bindgen_ty_2>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).Poller) as usize - ptr as usize
		           },
		           0usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalIsoDepActivation__bindgen_ty_2),
			"::",
			stringify!(Poller)
		)
		);
	}
	test_field_Poller();
}
#[test]
fn bindgen_test_layout_rfalIsoDepActivation() {
	assert_eq!(
	           ::core::mem::size_of::<rfalIsoDepActivation>(),
	           42usize,
	           concat!("Size of: ", stringify!(rfalIsoDepActivation))
	);
	assert_eq!(
	           ::core::mem::align_of::<rfalIsoDepActivation>(),
	           1usize,
	           concat!("Alignment of ", stringify!(rfalIsoDepActivation))
	);
	fn test_field_A() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalIsoDepActivation>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).A) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(rfalIsoDepActivation), "::", stringify!(A))
		);
	}
	test_field_A();
	fn test_field_B() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalIsoDepActivation>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).B) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(rfalIsoDepActivation), "::", stringify!(B))
		);
	}
	test_field_B();
}
#[doc = " ISO-DEP device Info"]
#[repr(C)]
pub struct rfalIsoDepInfo {
	#[doc = "< Frame Waiting Integer"]
	pub FWI: u8,
	#[doc = "< Frame Waiting Time (1/fc)"]
	pub FWT: u32,
	#[doc = "< Delta Frame Waiting Time (1/fc)"]
	pub dFWT: u32,
	#[doc = "< Start-up Frame Guard time Integer"]
	pub SFGI: u32,
	#[doc = "< Start-up Frame Guard Time (ms)"]
	pub SFGT: u32,
	#[doc = "< Frame Size Device/Card Integer (FSDI or FSCI)"]
	pub FSxI: u8,
	#[doc = "< Frame Size Device/Card (FSD or FSC)"]
	pub FSx: u16,
	#[doc = "< Maximum Buffer Length (optional for NFC-B)"]
	pub MBL: u32,
	#[doc = "< Bit Rate coding from Listener (PICC) to Poller (PCD)"]
	pub DSI: rfalBitRate,
	#[doc = "< Bit Rate coding from Poller (PCD) to Listener (PICC)"]
	pub DRI: rfalBitRate,
	#[doc = "< Device ID"]
	pub DID: u8,
	#[doc = "< Node ADdress"]
	pub NAD: u8,
	#[doc = "< DID supported flag"]
	pub supDID: bool,
	#[doc = "< NAD supported flag"]
	pub supNAD: bool,
	#[doc = "< Advanced Features supported flag"]
	pub supAdFt: bool,
}
#[test]
fn bindgen_test_layout_rfalIsoDepInfo() {
	assert_eq!(
	           ::core::mem::size_of::<rfalIsoDepInfo>(),
	           44usize,
	           concat!("Size of: ", stringify!(rfalIsoDepInfo))
	);
	assert_eq!(
	           ::core::mem::align_of::<rfalIsoDepInfo>(),
	           4usize,
	           concat!("Alignment of ", stringify!(rfalIsoDepInfo))
	);
	fn test_field_FWI() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalIsoDepInfo>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).FWI) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(rfalIsoDepInfo), "::", stringify!(FWI))
		);
	}
	test_field_FWI();
	fn test_field_FWT() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalIsoDepInfo>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).FWT) as usize - ptr as usize
		           },
		           4usize,
		           concat!("Offset of field: ", stringify!(rfalIsoDepInfo), "::", stringify!(FWT))
		);
	}
	test_field_FWT();
	fn test_field_dFWT() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalIsoDepInfo>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).dFWT) as usize - ptr as usize
		           },
		           8usize,
		           concat!("Offset of field: ", stringify!(rfalIsoDepInfo), "::", stringify!(dFWT))
		);
	}
	test_field_dFWT();
	fn test_field_SFGI() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalIsoDepInfo>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).SFGI) as usize - ptr as usize
		           },
		           12usize,
		           concat!("Offset of field: ", stringify!(rfalIsoDepInfo), "::", stringify!(SFGI))
		);
	}
	test_field_SFGI();
	fn test_field_SFGT() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalIsoDepInfo>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).SFGT) as usize - ptr as usize
		           },
		           16usize,
		           concat!("Offset of field: ", stringify!(rfalIsoDepInfo), "::", stringify!(SFGT))
		);
	}
	test_field_SFGT();
	fn test_field_FSxI() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalIsoDepInfo>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).FSxI) as usize - ptr as usize
		           },
		           20usize,
		           concat!("Offset of field: ", stringify!(rfalIsoDepInfo), "::", stringify!(FSxI))
		);
	}
	test_field_FSxI();
	fn test_field_FSx() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalIsoDepInfo>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).FSx) as usize - ptr as usize
		           },
		           22usize,
		           concat!("Offset of field: ", stringify!(rfalIsoDepInfo), "::", stringify!(FSx))
		);
	}
	test_field_FSx();
	fn test_field_MBL() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalIsoDepInfo>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).MBL) as usize - ptr as usize
		           },
		           24usize,
		           concat!("Offset of field: ", stringify!(rfalIsoDepInfo), "::", stringify!(MBL))
		);
	}
	test_field_MBL();
	fn test_field_DSI() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalIsoDepInfo>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).DSI) as usize - ptr as usize
		           },
		           28usize,
		           concat!("Offset of field: ", stringify!(rfalIsoDepInfo), "::", stringify!(DSI))
		);
	}
	test_field_DSI();
	fn test_field_DRI() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalIsoDepInfo>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).DRI) as usize - ptr as usize
		           },
		           32usize,
		           concat!("Offset of field: ", stringify!(rfalIsoDepInfo), "::", stringify!(DRI))
		);
	}
	test_field_DRI();
	fn test_field_DID() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalIsoDepInfo>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).DID) as usize - ptr as usize
		           },
		           36usize,
		           concat!("Offset of field: ", stringify!(rfalIsoDepInfo), "::", stringify!(DID))
		);
	}
	test_field_DID();
	fn test_field_NAD() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalIsoDepInfo>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).NAD) as usize - ptr as usize
		           },
		           37usize,
		           concat!("Offset of field: ", stringify!(rfalIsoDepInfo), "::", stringify!(NAD))
		);
	}
	test_field_NAD();
	fn test_field_supDID() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalIsoDepInfo>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).supDID) as usize - ptr as usize
		           },
		           38usize,
		           concat!("Offset of field: ", stringify!(rfalIsoDepInfo), "::", stringify!(supDID))
		);
	}
	test_field_supDID();
	fn test_field_supNAD() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalIsoDepInfo>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).supNAD) as usize - ptr as usize
		           },
		           39usize,
		           concat!("Offset of field: ", stringify!(rfalIsoDepInfo), "::", stringify!(supNAD))
		);
	}
	test_field_supNAD();
	fn test_field_supAdFt() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalIsoDepInfo>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).supAdFt) as usize - ptr as usize
		           },
		           40usize,
		           concat!("Offset of field: ", stringify!(rfalIsoDepInfo), "::", stringify!(supAdFt))
		);
	}
	test_field_supAdFt();
}
#[doc = " ISO-DEP Device structure"]
#[repr(C)]
pub struct rfalIsoDepDevice {
	#[doc = "< Activation Info"]
	pub activation: rfalIsoDepActivation,
	#[doc = "< ISO-DEP (ISO14443-4) device Info"]
	pub info: rfalIsoDepInfo,
}
#[test]
fn bindgen_test_layout_rfalIsoDepDevice() {
	assert_eq!(
	           ::core::mem::size_of::<rfalIsoDepDevice>(),
	           88usize,
	           concat!("Size of: ", stringify!(rfalIsoDepDevice))
	);
	assert_eq!(
	           ::core::mem::align_of::<rfalIsoDepDevice>(),
	           4usize,
	           concat!("Alignment of ", stringify!(rfalIsoDepDevice))
	);
	fn test_field_activation() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalIsoDepDevice>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).activation) as usize - ptr as usize
		           },
		           0usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalIsoDepDevice),
			"::",
			stringify!(activation)
		)
		);
	}
	test_field_activation();
	fn test_field_info() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalIsoDepDevice>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).info) as usize - ptr as usize
		           },
		           44usize,
		           concat!("Offset of field: ", stringify!(rfalIsoDepDevice), "::", stringify!(info))
		);
	}
	test_field_info();
}
#[doc = " ATTRIB Response parameters"]
#[repr(C)]
pub struct rfalIsoDepAttribResParam {
	#[doc = "< MBLI"]
	pub mbli: u8,
	#[doc = "< Hi Layer Information"]
	pub HLInfo: [u8; 32usize],
	#[doc = "< Hi Layer Information Length"]
	pub HLInfoLen: u8,
}
#[test]
fn bindgen_test_layout_rfalIsoDepAttribResParam() {
	assert_eq!(
	           ::core::mem::size_of::<rfalIsoDepAttribResParam>(),
	           34usize,
	           concat!("Size of: ", stringify!(rfalIsoDepAttribResParam))
	);
	assert_eq!(
	           ::core::mem::align_of::<rfalIsoDepAttribResParam>(),
	           1usize,
	           concat!("Alignment of ", stringify!(rfalIsoDepAttribResParam))
	);
	fn test_field_mbli() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalIsoDepAttribResParam>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).mbli) as usize - ptr as usize
		           },
		           0usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalIsoDepAttribResParam),
			"::",
			stringify!(mbli)
		)
		);
	}
	test_field_mbli();
	fn test_field_HLInfo() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalIsoDepAttribResParam>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).HLInfo) as usize - ptr as usize
		           },
		           1usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalIsoDepAttribResParam),
			"::",
			stringify!(HLInfo)
		)
		);
	}
	test_field_HLInfo();
	fn test_field_HLInfoLen() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalIsoDepAttribResParam>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).HLInfoLen) as usize - ptr as usize
		           },
		           33usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalIsoDepAttribResParam),
			"::",
			stringify!(HLInfoLen)
		)
		);
	}
	test_field_HLInfoLen();
}
#[doc = " ATS Response parameter"]
#[repr(C)]
pub struct rfalIsoDepAtsParam {
	#[doc = "< Frame Size of Proximity Card Integer"]
	pub fsci: u8,
	#[doc = "< Frame Waiting Time Integer"]
	pub fwi: u8,
	#[doc = "< Start-Up Frame Guard Time Integer"]
	pub sfgi: u8,
	#[doc = "< DID Supported"]
	pub didSupport: bool,
	#[doc = "< Max supported bitrate both direction"]
	pub ta: u8,
	#[doc = "< Historical Bytes data"]
	pub hb: *mut u8,
	#[doc = "< Historical Bytes Length"]
	pub hbLen: u8,
}
#[test]
fn bindgen_test_layout_rfalIsoDepAtsParam() {
	assert_eq!(
	           ::core::mem::size_of::<rfalIsoDepAtsParam>(),
	           16usize,
	           concat!("Size of: ", stringify!(rfalIsoDepAtsParam))
	);
	assert_eq!(
	           ::core::mem::align_of::<rfalIsoDepAtsParam>(),
	           4usize,
	           concat!("Alignment of ", stringify!(rfalIsoDepAtsParam))
	);
	fn test_field_fsci() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalIsoDepAtsParam>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).fsci) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(rfalIsoDepAtsParam), "::", stringify!(fsci))
		);
	}
	test_field_fsci();
	fn test_field_fwi() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalIsoDepAtsParam>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).fwi) as usize - ptr as usize
		           },
		           1usize,
		           concat!("Offset of field: ", stringify!(rfalIsoDepAtsParam), "::", stringify!(fwi))
		);
	}
	test_field_fwi();
	fn test_field_sfgi() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalIsoDepAtsParam>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).sfgi) as usize - ptr as usize
		           },
		           2usize,
		           concat!("Offset of field: ", stringify!(rfalIsoDepAtsParam), "::", stringify!(sfgi))
		);
	}
	test_field_sfgi();
	fn test_field_didSupport() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalIsoDepAtsParam>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).didSupport) as usize - ptr as usize
		           },
		           3usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalIsoDepAtsParam),
			"::",
			stringify!(didSupport)
		)
		);
	}
	test_field_didSupport();
	fn test_field_ta() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalIsoDepAtsParam>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).ta) as usize - ptr as usize
		           },
		           4usize,
		           concat!("Offset of field: ", stringify!(rfalIsoDepAtsParam), "::", stringify!(ta))
		);
	}
	test_field_ta();
	fn test_field_hb() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalIsoDepAtsParam>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).hb) as usize - ptr as usize
		           },
		           8usize,
		           concat!("Offset of field: ", stringify!(rfalIsoDepAtsParam), "::", stringify!(hb))
		);
	}
	test_field_hb();
	fn test_field_hbLen() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalIsoDepAtsParam>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).hbLen) as usize - ptr as usize
		           },
		           12usize,
		           concat!("Offset of field: ", stringify!(rfalIsoDepAtsParam), "::", stringify!(hbLen))
		);
	}
	test_field_hbLen();
}
#[doc = " Structure of I-Block Buffer format from caller"]
#[repr(C)]
pub struct rfalIsoDepBufFormat {
	#[doc = "< Prologue/SoD buffer"]
	pub prologue: [u8; 3usize],
	#[doc = "< INF/Payload buffer"]
	pub inf: [u8; 256usize],
}
#[test]
fn bindgen_test_layout_rfalIsoDepBufFormat() {
	assert_eq!(
	           ::core::mem::size_of::<rfalIsoDepBufFormat>(),
	           259usize,
	           concat!("Size of: ", stringify!(rfalIsoDepBufFormat))
	);
	assert_eq!(
	           ::core::mem::align_of::<rfalIsoDepBufFormat>(),
	           1usize,
	           concat!("Alignment of ", stringify!(rfalIsoDepBufFormat))
	);
	fn test_field_prologue() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalIsoDepBufFormat>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).prologue) as usize - ptr as usize
		           },
		           0usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalIsoDepBufFormat),
			"::",
			stringify!(prologue)
		)
		);
	}
	test_field_prologue();
	fn test_field_inf() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalIsoDepBufFormat>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).inf) as usize - ptr as usize
		           },
		           3usize,
		           concat!("Offset of field: ", stringify!(rfalIsoDepBufFormat), "::", stringify!(inf))
		);
	}
	test_field_inf();
}
#[doc = " Structure of APDU Buffer format from caller"]
#[repr(C)]
pub struct rfalIsoDepApduBufFormat {
	#[doc = "< Prologue/SoD buffer"]
	pub prologue: [u8; 3usize],
	#[doc = "< APDU/Payload buffer"]
	pub apdu: [u8; 512usize],
}
#[test]
fn bindgen_test_layout_rfalIsoDepApduBufFormat() {
	assert_eq!(
	           ::core::mem::size_of::<rfalIsoDepApduBufFormat>(),
	           515usize,
	           concat!("Size of: ", stringify!(rfalIsoDepApduBufFormat))
	);
	assert_eq!(
	           ::core::mem::align_of::<rfalIsoDepApduBufFormat>(),
	           1usize,
	           concat!("Alignment of ", stringify!(rfalIsoDepApduBufFormat))
	);
	fn test_field_prologue() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalIsoDepApduBufFormat>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).prologue) as usize - ptr as usize
		           },
		           0usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalIsoDepApduBufFormat),
			"::",
			stringify!(prologue)
		)
		);
	}
	test_field_prologue();
	fn test_field_apdu() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalIsoDepApduBufFormat>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).apdu) as usize - ptr as usize
		           },
		           3usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalIsoDepApduBufFormat),
			"::",
			stringify!(apdu)
		)
		);
	}
	test_field_apdu();
}
#[doc = " Listen Activation Parameters Structure"]
#[repr(C)]
pub struct rfalIsoDepListenActvParam {
	#[doc = "< Receive Buffer struct reference"]
	pub rxBuf: *mut rfalIsoDepBufFormat,
	#[doc = "< Received INF data length in Bytes"]
	pub rxLen: *mut u16,
	#[doc = "< Received data is not complete"]
	pub isRxChaining: *mut bool,
	#[doc = "< ISO-DEP device info"]
	pub isoDepDev: *mut rfalIsoDepDevice,
}
#[test]
fn bindgen_test_layout_rfalIsoDepListenActvParam() {
	assert_eq!(
	           ::core::mem::size_of::<rfalIsoDepListenActvParam>(),
	           16usize,
	           concat!("Size of: ", stringify!(rfalIsoDepListenActvParam))
	);
	assert_eq!(
	           ::core::mem::align_of::<rfalIsoDepListenActvParam>(),
	           4usize,
	           concat!("Alignment of ", stringify!(rfalIsoDepListenActvParam))
	);
	fn test_field_rxBuf() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalIsoDepListenActvParam>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).rxBuf) as usize - ptr as usize
		           },
		           0usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalIsoDepListenActvParam),
			"::",
			stringify!(rxBuf)
		)
		);
	}
	test_field_rxBuf();
	fn test_field_rxLen() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalIsoDepListenActvParam>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).rxLen) as usize - ptr as usize
		           },
		           4usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalIsoDepListenActvParam),
			"::",
			stringify!(rxLen)
		)
		);
	}
	test_field_rxLen();
	fn test_field_isRxChaining() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalIsoDepListenActvParam>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).isRxChaining) as usize - ptr as usize
		           },
		           8usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalIsoDepListenActvParam),
			"::",
			stringify!(isRxChaining)
		)
		);
	}
	test_field_isRxChaining();
	fn test_field_isoDepDev() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalIsoDepListenActvParam>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).isoDepDev) as usize - ptr as usize
		           },
		           12usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalIsoDepListenActvParam),
			"::",
			stringify!(isoDepDev)
		)
		);
	}
	test_field_isoDepDev();
}
#[doc = " Structure of parameters used on ISO DEP Transceive"]
#[repr(C)]
pub struct rfalIsoDepTxRxParam {
	#[doc = "< Transmit Buffer struct reference"]
	pub txBuf: *mut rfalIsoDepBufFormat,
	#[doc = "< Transmit Buffer INF field length in Bytes"]
	pub txBufLen: u16,
	#[doc = "< Transmit data is not complete"]
	pub isTxChaining: bool,
	#[doc = "< Receive Buffer struct reference in Bytes"]
	pub rxBuf: *mut rfalIsoDepBufFormat,
	#[doc = "< Received INF data length in Bytes"]
	pub rxLen: *mut u16,
	#[doc = "< Received data is not complete"]
	pub isRxChaining: *mut bool,
	#[doc = "< FWT to be used (ignored in Listen Mode)"]
	pub FWT: u32,
	#[doc = "< Delta FWT to be used"]
	pub dFWT: u32,
	#[doc = "< Our device Frame Size (FSD or FSC)"]
	pub ourFSx: u16,
	#[doc = "< Other device Frame Size (FSD or FSC)"]
	pub FSx: u16,
	#[doc = "< Device ID (RFAL_ISODEP_NO_DID if no DID)"]
	pub DID: u8,
}
#[test]
fn bindgen_test_layout_rfalIsoDepTxRxParam() {
	assert_eq!(
	           ::core::mem::size_of::<rfalIsoDepTxRxParam>(),
	           36usize,
	           concat!("Size of: ", stringify!(rfalIsoDepTxRxParam))
	);
	assert_eq!(
	           ::core::mem::align_of::<rfalIsoDepTxRxParam>(),
	           4usize,
	           concat!("Alignment of ", stringify!(rfalIsoDepTxRxParam))
	);
	fn test_field_txBuf() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalIsoDepTxRxParam>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).txBuf) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(rfalIsoDepTxRxParam), "::", stringify!(txBuf))
		);
	}
	test_field_txBuf();
	fn test_field_txBufLen() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalIsoDepTxRxParam>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).txBufLen) as usize - ptr as usize
		           },
		           4usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalIsoDepTxRxParam),
			"::",
			stringify!(txBufLen)
		)
		);
	}
	test_field_txBufLen();
	fn test_field_isTxChaining() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalIsoDepTxRxParam>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).isTxChaining) as usize - ptr as usize
		           },
		           6usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalIsoDepTxRxParam),
			"::",
			stringify!(isTxChaining)
		)
		);
	}
	test_field_isTxChaining();
	fn test_field_rxBuf() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalIsoDepTxRxParam>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).rxBuf) as usize - ptr as usize
		           },
		           8usize,
		           concat!("Offset of field: ", stringify!(rfalIsoDepTxRxParam), "::", stringify!(rxBuf))
		);
	}
	test_field_rxBuf();
	fn test_field_rxLen() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalIsoDepTxRxParam>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).rxLen) as usize - ptr as usize
		           },
		           12usize,
		           concat!("Offset of field: ", stringify!(rfalIsoDepTxRxParam), "::", stringify!(rxLen))
		);
	}
	test_field_rxLen();
	fn test_field_isRxChaining() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalIsoDepTxRxParam>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).isRxChaining) as usize - ptr as usize
		           },
		           16usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalIsoDepTxRxParam),
			"::",
			stringify!(isRxChaining)
		)
		);
	}
	test_field_isRxChaining();
	fn test_field_FWT() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalIsoDepTxRxParam>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).FWT) as usize - ptr as usize
		           },
		           20usize,
		           concat!("Offset of field: ", stringify!(rfalIsoDepTxRxParam), "::", stringify!(FWT))
		);
	}
	test_field_FWT();
	fn test_field_dFWT() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalIsoDepTxRxParam>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).dFWT) as usize - ptr as usize
		           },
		           24usize,
		           concat!("Offset of field: ", stringify!(rfalIsoDepTxRxParam), "::", stringify!(dFWT))
		);
	}
	test_field_dFWT();
	fn test_field_ourFSx() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalIsoDepTxRxParam>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).ourFSx) as usize - ptr as usize
		           },
		           28usize,
		           concat!("Offset of field: ", stringify!(rfalIsoDepTxRxParam), "::", stringify!(ourFSx))
		);
	}
	test_field_ourFSx();
	fn test_field_FSx() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalIsoDepTxRxParam>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).FSx) as usize - ptr as usize
		           },
		           30usize,
		           concat!("Offset of field: ", stringify!(rfalIsoDepTxRxParam), "::", stringify!(FSx))
		);
	}
	test_field_FSx();
	fn test_field_DID() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalIsoDepTxRxParam>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).DID) as usize - ptr as usize
		           },
		           32usize,
		           concat!("Offset of field: ", stringify!(rfalIsoDepTxRxParam), "::", stringify!(DID))
		);
	}
	test_field_DID();
}
#[doc = " Structure of parameters used on ISO DEP APDU Transceive"]
#[repr(C)]
pub struct rfalIsoDepApduTxRxParam {
	#[doc = "< Transmit Buffer struct reference"]
	pub txBuf: *mut rfalIsoDepApduBufFormat,
	#[doc = "< Transmit Buffer INF field length in Bytes"]
	pub txBufLen: u16,
	#[doc = "< Receive Buffer struct reference in Bytes"]
	pub rxBuf: *mut rfalIsoDepApduBufFormat,
	#[doc = "< Received INF data length in Bytes"]
	pub rxLen: *mut u16,
	#[doc = "< Temp buffer for Rx I-Blocks (internal)"]
	pub tmpBuf: *mut rfalIsoDepBufFormat,
	#[doc = "< FWT to be used (ignored in Listen Mode)"]
	pub FWT: u32,
	#[doc = "< Delta FWT to be used"]
	pub dFWT: u32,
	#[doc = "< Other device Frame Size (FSD or FSC)"]
	pub FSx: u16,
	#[doc = "< Our device Frame Size (FSD or FSC)"]
	pub ourFSx: u16,
	#[doc = "< Device ID (RFAL_ISODEP_NO_DID if no DID)"]
	pub DID: u8,
}
#[test]
fn bindgen_test_layout_rfalIsoDepApduTxRxParam() {
	assert_eq!(
	           ::core::mem::size_of::<rfalIsoDepApduTxRxParam>(),
	           36usize,
	           concat!("Size of: ", stringify!(rfalIsoDepApduTxRxParam))
	);
	assert_eq!(
	           ::core::mem::align_of::<rfalIsoDepApduTxRxParam>(),
	           4usize,
	           concat!("Alignment of ", stringify!(rfalIsoDepApduTxRxParam))
	);
	fn test_field_txBuf() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalIsoDepApduTxRxParam>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).txBuf) as usize - ptr as usize
		           },
		           0usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalIsoDepApduTxRxParam),
			"::",
			stringify!(txBuf)
		)
		);
	}
	test_field_txBuf();
	fn test_field_txBufLen() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalIsoDepApduTxRxParam>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).txBufLen) as usize - ptr as usize
		           },
		           4usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalIsoDepApduTxRxParam),
			"::",
			stringify!(txBufLen)
		)
		);
	}
	test_field_txBufLen();
	fn test_field_rxBuf() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalIsoDepApduTxRxParam>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).rxBuf) as usize - ptr as usize
		           },
		           8usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalIsoDepApduTxRxParam),
			"::",
			stringify!(rxBuf)
		)
		);
	}
	test_field_rxBuf();
	fn test_field_rxLen() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalIsoDepApduTxRxParam>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).rxLen) as usize - ptr as usize
		           },
		           12usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalIsoDepApduTxRxParam),
			"::",
			stringify!(rxLen)
		)
		);
	}
	test_field_rxLen();
	fn test_field_tmpBuf() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalIsoDepApduTxRxParam>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).tmpBuf) as usize - ptr as usize
		           },
		           16usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalIsoDepApduTxRxParam),
			"::",
			stringify!(tmpBuf)
		)
		);
	}
	test_field_tmpBuf();
	fn test_field_FWT() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalIsoDepApduTxRxParam>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).FWT) as usize - ptr as usize
		           },
		           20usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalIsoDepApduTxRxParam),
			"::",
			stringify!(FWT)
		)
		);
	}
	test_field_FWT();
	fn test_field_dFWT() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalIsoDepApduTxRxParam>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).dFWT) as usize - ptr as usize
		           },
		           24usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalIsoDepApduTxRxParam),
			"::",
			stringify!(dFWT)
		)
		);
	}
	test_field_dFWT();
	fn test_field_FSx() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalIsoDepApduTxRxParam>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).FSx) as usize - ptr as usize
		           },
		           28usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalIsoDepApduTxRxParam),
			"::",
			stringify!(FSx)
		)
		);
	}
	test_field_FSx();
	fn test_field_ourFSx() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalIsoDepApduTxRxParam>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).ourFSx) as usize - ptr as usize
		           },
		           30usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalIsoDepApduTxRxParam),
			"::",
			stringify!(ourFSx)
		)
		);
	}
	test_field_ourFSx();
	fn test_field_DID() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalIsoDepApduTxRxParam>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).DID) as usize - ptr as usize
		           },
		           32usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalIsoDepApduTxRxParam),
			"::",
			stringify!(DID)
		)
		);
	}
	test_field_DID();
}
extern "C" {
	#[doc = " \\brief Initialize the ISO-DEP protocol"]
	#[doc = ""]
	#[doc = " Initialize the ISO-DEP protocol layer with default config"]
	#[doc = ""]
	pub fn rfalIsoDepInitialize();
}
extern "C" {
	#[doc = " \\brief Initialize the ISO-DEP protocol"]
	#[doc = ""]
	#[doc = " Initialize the ISO-DEP protocol layer with additional parameters allowing"]
	#[doc = " to customise the protocol layer for specific behaviours"]
	#[doc = ""]
	#[doc = ""]
	#[doc = "  \\param[in] compMode        : Compliance mode to be performed"]
	#[doc = "  \\param[in] maxRetriesR     : Number of retries for a R-Block"]
	#[doc = "                                Digital 2.0 B9 - nRETRY ACK/NAK: [2,5]"]
	#[doc = "  \\param[in] maxRetriesSnWTX : Number of retries for a S(WTX) (only in case"]
	#[doc = "                               of NAKs)   Digital 2.0 B9 - nRETRY WTX[2,5]"]
	#[doc = "  \\param[in] maxRetriesSWTX  : Number of overall S(WTX) retries."]
	#[doc = "                                Use RFAL_ISODEP_MAX_WTX_RETRYS_ULTD for disabling"]
	#[doc = "                                this limit check   Digital 2.0  16.2.5.2"]
	#[doc = "  \\param[in] maxRetriesSDSL  : Number of retries for a S(DESELECT)"]
	#[doc = "                                Digital 2.0 B9 - nRETRY DESELECT: [0,5]"]
	#[doc = "  \\param[in] maxRetriesI     : Number of retries for a I-Block"]
	#[doc = "                                Digital 2.0  16.2.5.4"]
	#[doc = "  \\param[in] maxRetriesRATS  : Number of retries for RATS"]
	#[doc = "                                Digital 2.0 B7 - nRETRY RATS [0,1]"]
	#[doc = ""]
	#[doc = ""]
	pub fn rfalIsoDepInitializeWithParams(compMode: rfalComplianceMode,
	                                      maxRetriesR: u8,
	                                      maxRetriesSnWTX: u8,
	                                      maxRetriesSWTX: u8,
	                                      maxRetriesSDSL: u8,
	                                      maxRetriesI: u8,
	                                      maxRetriesRATS: u8);
}
extern "C" {
	#[doc = "  \\brief  FSxI to FSx"]
	#[doc = ""]
	#[doc = "  Convert Frame Size for proximity coupling Device Integer (FSxI) to"]
	#[doc = "  Frame Size for proximity coupling Device (FSx)"]
	#[doc = ""]
	#[doc = "  FSD - maximum frame size for NFC Forum Device in Poll Mode"]
	#[doc = "  FSC - maximum frame size for NFC Forum Device in Listen Mode"]
	#[doc = ""]
	#[doc = "  FSxI = FSDI or FSCI"]
	#[doc = "  FSx  = FSD or FSC"]
	#[doc = ""]
	#[doc = "  The FSD/FSC value includes the header and CRC"]
	#[doc = ""]
	#[doc = "  \\param[in] FSxI :  Frame Size for proximity coupling Device Integer"]
	#[doc = ""]
	#[doc = "  \\return fsx : Frame Size for proximity coupling Device (FSD or FSC)"]
	#[doc = ""]
	#[doc = ""]
	pub fn rfalIsoDepFSxI2FSx(FSxI: u8) -> u16;
}
extern "C" {
	#[doc = "  \\brief  FWI to FWT"]
	#[doc = ""]
	#[doc = "  Convert Frame Waiting time Integer (FWI) to Frame Waiting Time (FWT) in"]
	#[doc = "  1/fc units"]
	#[doc = ""]
	#[doc = "  \\param[in] fwi : Frame Waiting time Integer"]
	#[doc = ""]
	#[doc = "  \\return fwt : Frame Waiting Time in 1/fc units"]
	#[doc = ""]
	#[doc = ""]
	pub fn rfalIsoDepFWI2FWT(fwi: u8) -> u32;
}
extern "C" {
	#[doc = "  \\brief  Check if the buffer data contains a valid RATS command"]
	#[doc = ""]
	#[doc = "  Check if it is a  well formed RATS command with 2 bytes"]
	#[doc = "  This function does not check the validity of FSDI and DID"]
	#[doc = ""]
	#[doc = "  \\param[in] buf    : reference to buffer containing the data to be checked"]
	#[doc = "  \\param[in] bufLen : length of data in the buffer in bytes"]
	#[doc = ""]
	#[doc = "  \\return true if the data indicates a RATS command; false otherwise"]
	#[doc = ""]
	pub fn rfalIsoDepIsRats(buf: *const u8, bufLen: u8) -> bool;
}
extern "C" {
	#[doc = "  \\brief  Check if the buffer data contains a valid ATTRIB command"]
	#[doc = ""]
	#[doc = "  Check if it is a well formed ATTRIB command, but does not check the"]
	#[doc = "  validity of the information inside"]
	#[doc = ""]
	#[doc = "  \\param[in] buf    : reference to buffer containing the data to be checked"]
	#[doc = "  \\param[in] bufLen : length of data in the buffer in bytes"]
	#[doc = ""]
	#[doc = "  \\return true if the data indicates a ATTRIB command; false otherwise"]
	#[doc = ""]
	pub fn rfalIsoDepIsAttrib(buf: *const u8, bufLen: u8) -> bool;
}
extern "C" {
	#[doc = " \\brief Start Listen Activation Handling"]
	#[doc = ""]
	#[doc = " Start Listen Activation Handling and setup to receive first I-block which may"]
	#[doc = " contain complete or partial APDU after activation is completed"]
	#[doc = ""]
	#[doc = "  Pass in RATS for T4AT, or ATTRIB for T4BT, to handle ATS or ATTRIB Response respectively"]
	#[doc = "  The Activation Handling handles ATS and ATTRIB Response; and additionally PPS Response"]
	#[doc = "  if a PPS is received for T4AT."]
	#[doc = "  The method uses the current RFAL state machine to determine if it is expecting RATS or ATTRIB"]
	#[doc = ""]
	#[doc = "  Activation is completed if PPS Response is sent or if first PDU is received in T4T-A"]
	#[doc = "  Activation is completed if ATTRIB Response is sent in T4T-B"]
	#[doc = ""]
	#[doc = "  \\ref rfalIsoDepListenGetActivationStatus provide status if activation is completed."]
	#[doc = "  \\ref rfalIsoDepStartTransceive shall be called right after activation is completed"]
	#[doc = ""]
	#[doc = "  \\param[in] atsParam       : reference to ATS parameters"]
	#[doc = "  \\param[in] attribResParam : reference to ATTRIB_RES parameters"]
	#[doc = "  \\param[in] buf            : reference to buffer containing RATS or ATTRIB"]
	#[doc = "  \\param[in] bufLen         : length in bytes of the given bufffer"]
	#[doc = "  \\param[in] actParam       : reference to incoming reception information will be placed"]
	#[doc = ""]
	#[doc = ""]
	#[doc = "  \\warning Once the Activation has been completed the method"]
	#[doc = "  rfalIsoDepGetTransceiveStatus() must be called."]
	#[doc = "  If activation has completed due to reception of a data block (not PPS) the"]
	#[doc = "  buffer owned by the caller and passed on actParam must still contain this data."]
	#[doc = "  The first data will be processed (I-Block or S-DSL) by rfalIsoDepGetTransceiveStatus()"]
	#[doc = "  inform the caller and then for the next transaction use rfalIsoDepStartTransceive()"]
	#[doc = ""]
	#[doc = "  \\return ERR_NONE    : RATS/ATTRIB is valid and activation has started"]
	#[doc = "  \\return ERR_PARAM   : Invalid parameters"]
	#[doc = "  \\return ERR_PROTO   : Invalid request"]
	#[doc = "  \\return ERR_NOTSUPP : Feature not supported"]
	#[doc = ""]
	pub fn rfalIsoDepListenStartActivation(atsParam: *mut rfalIsoDepAtsParam,
	                                       attribResParam: *const rfalIsoDepAttribResParam,
	                                       buf: *const u8,
	                                       bufLen: u16,
	                                       actParam: rfalIsoDepListenActvParam)
	                                       -> ReturnCode;
}
extern "C" {
	#[doc = "  \\brief Get the current Activation Status"]
	#[doc = ""]
	#[doc = "  \\return ERR_NONE if Activation is already completed"]
	#[doc = "  \\return ERR_BUSY if Activation is ongoing"]
	#[doc = "  \\return ERR_LINK_LOSS if Remote Field is turned off"]
	#[doc = ""]
	pub fn rfalIsoDepListenGetActivationStatus() -> ReturnCode;
}
extern "C" {
	#[doc = "  \\brief Get the ISO-DEP Communication Information"]
	#[doc = ""]
	#[doc = "  Gets the maximum INF length in bytes based on current Frame Size"]
	#[doc = "  for proximity coupling Device (FSD or FSC) excluding the header and CRC"]
	#[doc = ""]
	#[doc = "  \\return maximum INF length in bytes"]
	#[doc = ""]
	pub fn rfalIsoDepGetMaxInfLen() -> u16;
}
extern "C" {
	#[doc = "  \\brief ISO-DEP Start Transceive"]
	#[doc = ""]
	#[doc = "  This method triggers a ISO-DEP Transceive containing a complete or"]
	#[doc = "  partial APDU"]
	#[doc = "  It transmits the given message and handles all protocol retransmitions,"]
	#[doc = "  error handling and control messages"]
	#[doc = ""]
	#[doc = "  The txBuf  contains a complete or partial APDU (INF) to be transmitted"]
	#[doc = "  The Prologue field will be manipulated by the Transceive"]
	#[doc = ""]
	#[doc = "  If the buffer contains a partial APDU and is not the last block,"]
	#[doc = "  then isTxChaining must be set to true"]
	#[doc = ""]
	#[doc = "  \\param[in] param: reference parameters to be used for the Transceive"]
	#[doc = ""]
	#[doc = "  \\return ERR_PARAM       : Bad request"]
	#[doc = "  \\return ERR_WRONG_STATE : The module is not in a proper state"]
	#[doc = "  \\return ERR_NONE        : The Transceive request has been started"]
	#[doc = ""]
	pub fn rfalIsoDepStartTransceive(param: rfalIsoDepTxRxParam) -> ReturnCode;
}
extern "C" {
	#[doc = "  \\brief Get the Transceive status"]
	#[doc = ""]
	#[doc = "  Returns the status of the ISO-DEP Transceive"]
	#[doc = ""]
	#[doc = "  \\warning  When the other device is performing chaining once a chained"]
	#[doc = "            block is received the error ERR_AGAIN is sent. At this point"]
	#[doc = "            caller must handle the received data immediately."]
	#[doc = "            When ERR_AGAIN is returned an ACK has already been sent to"]
	#[doc = "            the other device and the next block might be incoming."]
	#[doc = "            If rfalWorker() is called frequently it will place the next"]
	#[doc = "            block on the given buffer"]
	#[doc = ""]
	#[doc = ""]
	#[doc = "  \\return ERR_NONE      : Transceive has been completed successfully"]
	#[doc = "  \\return ERR_BUSY      : Transceive is ongoing"]
	#[doc = "  \\return ERR_PROTO     : Protocol error occurred"]
	#[doc = "  \\return ERR_TIMEOUT   : Timeout error occurred"]
	#[doc = "  \\return ERR_SLEEP_REQ : Deselect has been received and responded"]
	#[doc = "  \\return ERR_NOMEM     : The received INF does not fit into the"]
	#[doc = "                            receive buffer"]
	#[doc = "  \\return ERR_LINK_LOSS : Communication is lost because Reader/Writer"]
	#[doc = "                            has turned off its field"]
	#[doc = "  \\return ERR_AGAIN     : received one chaining block, continue to call"]
	#[doc = "                            this method to retrieve the remaining blocks"]
	#[doc = ""]
	pub fn rfalIsoDepGetTransceiveStatus() -> ReturnCode;
}
extern "C" {
	#[doc = "  \\brief ISO-DEP Start APDU Transceive"]
	#[doc = ""]
	#[doc = "  This method triggers a ISO-DEP Transceive containing a complete APDU"]
	#[doc = "  It transmits the given message and handles all protocol retransmitions,"]
	#[doc = "  error handling and control messages"]
	#[doc = ""]
	#[doc = "  The txBuf  contains a complete APDU to be transmitted"]
	#[doc = "  The Prologue field will be manipulated by the Transceive"]
	#[doc = ""]
	#[doc = "  \\warning the txBuf will be modified during the transmission"]
	#[doc = "  \\warning the maximum RF frame which can be received is limited by param.tmpBuf"]
	#[doc = ""]
	#[doc = "  \\param[in] param: reference parameters to be used for the Transceive"]
	#[doc = ""]
	#[doc = "  \\return ERR_PARAM       : Bad request"]
	#[doc = "  \\return ERR_WRONG_STATE : The module is not in a proper state"]
	#[doc = "  \\return ERR_NONE        : The Transceive request has been started"]
	#[doc = ""]
	pub fn rfalIsoDepStartApduTransceive(param: rfalIsoDepApduTxRxParam) -> ReturnCode;
}
extern "C" {
	#[doc = "  \\brief Get the APDU Transceive status"]
	#[doc = ""]
	#[doc = "  \\return ERR_NONE      : if Transceive has been completed successfully"]
	#[doc = "  \\return ERR_BUSY      : if Transceive is ongoing"]
	#[doc = "  \\return ERR_PROTO     : if a protocol error occurred"]
	#[doc = "  \\return ERR_TIMEOUT   : if a timeout error occurred"]
	#[doc = "  \\return ERR_SLEEP_REQ : if Deselect is received and responded"]
	#[doc = "  \\return ERR_NOMEM     : if the received INF does not fit into the"]
	#[doc = "                            receive buffer"]
	#[doc = "  \\return ERR_LINK_LOSS : if communication is lost because Reader/Writer"]
	#[doc = "                            has turned off its field"]
	#[doc = ""]
	pub fn rfalIsoDepGetApduTransceiveStatus() -> ReturnCode;
}
extern "C" {
	#[doc = "  \\brief  ISO-DEP Send RATS"]
	#[doc = ""]
	#[doc = "  This sends a RATS to make a NFC-A Listen Device to enter"]
	#[doc = "  ISO-DEP layer (ISO14443-4) and checks if the received ATS is valid"]
	#[doc = ""]
	#[doc = "  \\param[in]  FSDI   : Frame Size Device Integer to be used"]
	#[doc = "  \\param[in]  DID    : Device ID to be used or RFAL_ISODEP_NO_DID for not use DID"]
	#[doc = "  \\param[out] ats    : pointer to place the ATS Response"]
	#[doc = "  \\param[out] atsLen : pointer to place the ATS length"]
	#[doc = ""]
	#[doc = "  \\return ERR_WRONG_STATE  : RFAL not initialized or incorrect mode"]
	#[doc = "  \\return ERR_PARAM        : Invalid parameters"]
	#[doc = "  \\return ERR_IO           : Generic internal error"]
	#[doc = "  \\return ERR_TIMEOUT      : Timeout error"]
	#[doc = "  \\return ERR_PAR          : Parity error detected"]
	#[doc = "  \\return ERR_CRC          : CRC error detected"]
	#[doc = "  \\return ERR_FRAMING      : Framing error detected"]
	#[doc = "  \\return ERR_PROTO        : Protocol error detected"]
	#[doc = "  \\return ERR_NONE         : No error, ATS received"]
	#[doc = ""]
	pub fn rfalIsoDepRATS(FSDI: rfalIsoDepFSxI, DID: u8, ats: *mut rfalIsoDepAts, atsLen: *mut u8) -> ReturnCode;
}
extern "C" {
	#[doc = "  \\brief  ISO-DEP Send PPS"]
	#[doc = ""]
	#[doc = "  This sends a PPS to make a NFC-A Listen Device change the communications"]
	#[doc = "  bit rate from 106kbps to one of the supported bit rates"]
	#[doc = "  Additionally checks if the received PPS response is valid"]
	#[doc = ""]
	#[doc = "  \\param[in]  DID    : Device ID"]
	#[doc = "  \\param[in]  DSI    : DSI code the divisor from Listener (PICC) to Poller (PCD)"]
	#[doc = "  \\param[in]  DRI    : DRI code the divisor from Poller (PCD) to Listener (PICC)"]
	#[doc = "  \\param[out] ppsRes : pointer to place the PPS Response"]
	#[doc = ""]
	#[doc = "  \\return ERR_WRONG_STATE  : RFAL not initialized or incorrect mode"]
	#[doc = "  \\return ERR_PARAM        : Invalid parameters"]
	#[doc = "  \\return ERR_IO           : Generic internal error"]
	#[doc = "  \\return ERR_TIMEOUT      : Timeout error"]
	#[doc = "  \\return ERR_PAR          : Parity error detected"]
	#[doc = "  \\return ERR_CRC          : CRC error detected"]
	#[doc = "  \\return ERR_FRAMING      : Framing error detected"]
	#[doc = "  \\return ERR_PROTO        : Protocol error detected"]
	#[doc = "  \\return ERR_NONE         : No error, PPS Response received"]
	#[doc = ""]
	pub fn rfalIsoDepPPS(DID: u8, DSI: rfalBitRate, DRI: rfalBitRate, ppsRes: *mut rfalIsoDepPpsRes) -> ReturnCode;
}
extern "C" {
	#[doc = "  \\brief  ISO-DEP Send ATTRIB"]
	#[doc = ""]
	#[doc = "  This sends a ATTRIB to make a NFC-B Listen Device to enter"]
	#[doc = "  ISO-DEP layer (ISO14443-4) and checks if the received ATTRIB Response is valid"]
	#[doc = ""]
	#[doc = "  \\param[in]  nfcid0    : NFCID0 to be used for the ATTRIB"]
	#[doc = "  \\param[in]  PARAM1    : ATTRIB PARAM1 byte (communication parameters)"]
	#[doc = "  \\param[in]  DSI       : DSI code the divisor from Listener (PICC) to Poller (PCD)"]
	#[doc = "  \\param[in]  DRI       : DRI code the divisor from Poller (PCD) to Listener (PICC)"]
	#[doc = "  \\param[in]  FSDI      : PCD's Frame Size to be announced on the ATTRIB"]
	#[doc = "  \\param[in]  PARAM3    : ATTRIB PARAM1 byte (protocol type)"]
	#[doc = "  \\param[in]  DID       : Device ID to be used or RFAL_ISODEP_NO_DID for not use DID"]
	#[doc = "  \\param[in]  HLInfo    : pointer to Higher layer INF (NULL if none)"]
	#[doc = "  \\param[in]  HLInfoLen : Length HLInfo"]
	#[doc = "  \\param[in]  fwt       : Frame Waiting Time to be used (from SENSB_RES)"]
	#[doc = "  \\param[out] attribRes    : pointer to place the ATTRIB Response"]
	#[doc = "  \\param[out] attribResLen : pointer to place the ATTRIB Response length"]
	#[doc = ""]
	#[doc = "  \\return ERR_WRONG_STATE  : RFAL not initialized or incorrect mode"]
	#[doc = "  \\return ERR_PARAM        : Invalid parameters"]
	#[doc = "  \\return ERR_IO           : Generic internal error"]
	#[doc = "  \\return ERR_TIMEOUT      : Timeout error"]
	#[doc = "  \\return ERR_CRC          : CRC error detected"]
	#[doc = "  \\return ERR_FRAMING      : Framing error detected"]
	#[doc = "  \\return ERR_PROTO        : Protocol error detected"]
	#[doc = "  \\return ERR_NONE         : No error, ATTRIB Response received"]
	#[doc = ""]
	pub fn rfalIsoDepATTRIB(nfcid0: *const u8,
	                        PARAM1: u8,
	                        DSI: rfalBitRate,
	                        DRI: rfalBitRate,
	                        FSDI: rfalIsoDepFSxI,
	                        PARAM3: u8,
	                        DID: u8,
	                        HLInfo: *const u8,
	                        HLInfoLen: u8,
	                        fwt: u32,
	                        attribRes: *mut rfalIsoDepAttribRes,
	                        attribResLen: *mut u8)
	                        -> ReturnCode;
}
extern "C" {
	#[doc = "  \\brief  Deselects PICC"]
	#[doc = ""]
	#[doc = "  This function sends a deselect command to PICC and waits for it`s"]
	#[doc = "  responce in a blocking way"]
	#[doc = ""]
	#[doc = "  \\return ERR_NONE   : Deselect successfully sent and acknowledged by PICC"]
	#[doc = "  \\return ERR_TIMEOUT: No response rcvd from PICC"]
	#[doc = ""]
	#[doc = ""]
	pub fn rfalIsoDepDeselect() -> ReturnCode;
}
extern "C" {
	#[doc = "  \\brief  ISO-DEP Poller Handle NFC-A Activation"]
	#[doc = ""]
	#[doc = "  This performs a NFC-A Activation into ISO-DEP layer (ISO14443-4) with the given"]
	#[doc = "  parameters. It sends RATS and if the higher bit rates are supported by"]
	#[doc = "  both devices it additionally sends PPS"]
	#[doc = "  Once Activated all details of the device are provided on isoDepDev"]
	#[doc = ""]
	#[doc = "  \\param[in]  FSDI      : Frame Size Device Integer to be used"]
	#[doc = "  \\param[in]  DID       : Device ID to be used or RFAL_ISODEP_NO_DID for not use DID"]
	#[doc = "  \\param[in]  maxBR     : Max bit rate supported by the Poller"]
	#[doc = "  \\param[out] isoDepDev : ISO-DEP information of the activated Listen device"]
	#[doc = ""]
	#[doc = "  \\return ERR_WRONG_STATE  : RFAL not initialized or incorrect mode"]
	#[doc = "  \\return ERR_PARAM        : Invalid parameters"]
	#[doc = "  \\return ERR_IO           : Generic internal error"]
	#[doc = "  \\return ERR_TIMEOUT      : Timeout error"]
	#[doc = "  \\return ERR_PAR          : Parity error detected"]
	#[doc = "  \\return ERR_CRC          : CRC error detected"]
	#[doc = "  \\return ERR_FRAMING      : Framing error detected"]
	#[doc = "  \\return ERR_PROTO        : Protocol error detected"]
	#[doc = "  \\return ERR_NONE         : No error, activation successful"]
	#[doc = ""]
	pub fn rfalIsoDepPollAHandleActivation(FSDI: rfalIsoDepFSxI,
	                                       DID: u8,
	                                       maxBR: rfalBitRate,
	                                       isoDepDev: *mut rfalIsoDepDevice)
	                                       -> ReturnCode;
}
extern "C" {
	#[doc = "  \\brief  ISO-DEP Poller Handle NFC-B Activation"]
	#[doc = ""]
	#[doc = "  This performs a NFC-B Activation into ISO-DEP layer (ISO14443-4) with the given"]
	#[doc = "  parameters. It sends ATTRIB and calculates supported higher bit rates of both"]
	#[doc = "  devices and performs activation."]
	#[doc = "  Once Activated all details of the device are provided on isoDepDev"]
	#[doc = ""]
	#[doc = "  \\param[in]  FSDI         : Frame Size Device Integer to be used"]
	#[doc = "  \\param[in]  DID          : Device ID to be used or RFAL_ISODEP_NO_DID for not use DID"]
	#[doc = "  \\param[in]  maxBR        : Max bit rate supported by the Poller"]
	#[doc = "  \\param[in]  PARAM1       : ATTRIB PARAM1 byte (communication parameters)"]
	#[doc = "  \\param[in]  nfcbDev      : pointer to the NFC-B Device containing the SENSB_RES"]
	#[doc = "  \\param[in]  HLInfo       : pointer to Higher layer INF (NULL if none)"]
	#[doc = "  \\param[in]  HLInfoLen    : Length HLInfo"]
	#[doc = "  \\param[out] isoDepDev    : ISO-DEP information of the activated Listen device"]
	#[doc = ""]
	#[doc = "  \\return ERR_WRONG_STATE  : RFAL not initialized or incorrect mode"]
	#[doc = "  \\return ERR_PARAM        : Invalid parameters"]
	#[doc = "  \\return ERR_IO           : Generic internal error"]
	#[doc = "  \\return ERR_TIMEOUT      : Timeout error"]
	#[doc = "  \\return ERR_PAR          : Parity error detected"]
	#[doc = "  \\return ERR_CRC          : CRC error detected"]
	#[doc = "  \\return ERR_FRAMING      : Framing error detected"]
	#[doc = "  \\return ERR_PROTO        : Protocol error detected"]
	#[doc = "  \\return ERR_NONE         : No error, activation successful"]
	#[doc = ""]
	pub fn rfalIsoDepPollBHandleActivation(FSDI: rfalIsoDepFSxI,
	                                       DID: u8,
	                                       maxBR: rfalBitRate,
	                                       PARAM1: u8,
	                                       nfcbDev: *const rfalNfcbListenDevice,
	                                       HLInfo: *const u8,
	                                       HLInfoLen: u8,
	                                       isoDepDev: *mut rfalIsoDepDevice)
	                                       -> ReturnCode;
}
extern "C" {
	#[doc = "  \\brief  ISO-DEP Poller Handle S(Parameters)"]
	#[doc = ""]
	#[doc = "  This checks if PICC supports S(PARAMETERS), retieves PICC's"]
	#[doc = "  capabilities and sets the Bit Rate at the highest supported by both"]
	#[doc = "  devices"]
	#[doc = ""]
	#[doc = "  \\param[out] isoDepDev    : ISO-DEP information of the activated Listen device"]
	#[doc = "  \\param[in]  maxTxBR      : Maximum Tx bit rate supported by PCD"]
	#[doc = "  \\param[in]  maxRxBR      : Maximum Rx bit rate supported by PCD"]
	#[doc = ""]
	#[doc = "  \\return ERR_WRONG_STATE  : RFAL not initialized or incorrect mode"]
	#[doc = "  \\return ERR_PARAM        : Invalid parameters"]
	#[doc = "  \\return ERR_IO           : Generic internal error"]
	#[doc = "  \\return ERR_TIMEOUT      : Timeout error"]
	#[doc = "  \\return ERR_FRAMING      : Framing error detected"]
	#[doc = "  \\return ERR_PROTO        : Protocol error detected"]
	#[doc = "  \\return ERR_NONE         : No error, S(PARAMETERS) selection successful"]
	#[doc = ""]
	pub fn rfalIsoDepPollHandleSParameters(isoDepDev: *mut rfalIsoDepDevice, maxTxBR: rfalBitRate, maxRxBR: rfalBitRate)
	                                       -> ReturnCode;
}
extern "C" {
	#[doc = "  \\brief  ISO-DEP Poller Start NFC-A Activation"]
	#[doc = ""]
	#[doc = "  This starts a NFC-A Activation into ISO-DEP layer (ISO14443-4) with the given"]
	#[doc = "  parameters. It sends RATS and if the higher bit rates are supported by"]
	#[doc = "  both devices it additionally sends PPS"]
	#[doc = "  Once Activated all details of the device are provided on isoDepDev"]
	#[doc = ""]
	#[doc = ""]
	#[doc = "  \\see rfalIsoDepPollAGetActivationStatus"]
	#[doc = ""]
	#[doc = "  \\param[in]  FSDI      : Frame Size Device Integer to be used"]
	#[doc = "  \\param[in]  DID       : Device ID to be used or RFAL_ISODEP_NO_DID for not use DID"]
	#[doc = "  \\param[in]  maxBR     : Max bit rate supported by the Poller"]
	#[doc = "  \\param[out] isoDepDev : ISO-DEP information of the activated Listen device"]
	#[doc = ""]
	#[doc = "  \\return ERR_WRONG_STATE  : RFAL not initialized or incorrect mode"]
	#[doc = "  \\return ERR_PARAM        : Invalid parameters"]
	#[doc = "  \\return ERR_IO           : Generic internal error"]
	#[doc = "  \\return ERR_TIMEOUT      : Timeout error"]
	#[doc = "  \\return ERR_PAR          : Parity error detected"]
	#[doc = "  \\return ERR_CRC          : CRC error detected"]
	#[doc = "  \\return ERR_FRAMING      : Framing error detected"]
	#[doc = "  \\return ERR_PROTO        : Protocol error detected"]
	#[doc = "  \\return ERR_NONE         : No error, start of asynchronous operation successful"]
	#[doc = ""]
	pub fn rfalIsoDepPollAStartActivation(FSDI: rfalIsoDepFSxI,
	                                      DID: u8,
	                                      maxBR: rfalBitRate,
	                                      isoDepDev: *mut rfalIsoDepDevice)
	                                      -> ReturnCode;
}
extern "C" {
	#[doc = "  \\brief  ISO-DEP Poller Get NFC-A Activation Status"]
	#[doc = ""]
	#[doc = "  Returns the activation status started by rfalIsoDepPollAStartActivation"]
	#[doc = ""]
	#[doc = "  \\see rfalIsoDepPollAStartActivation"]
	#[doc = ""]
	#[doc = "  \\return ERR_BUSY         : Operation is ongoing"]
	#[doc = "  \\return ERR_WRONG_STATE  : RFAL not initialized or incorrect mode"]
	#[doc = "  \\return ERR_PARAM        : Invalid parameters"]
	#[doc = "  \\return ERR_IO           : Generic internal error"]
	#[doc = "  \\return ERR_TIMEOUT      : Timeout error"]
	#[doc = "  \\return ERR_PAR          : Parity error detected"]
	#[doc = "  \\return ERR_CRC          : CRC error detected"]
	#[doc = "  \\return ERR_FRAMING      : Framing error detected"]
	#[doc = "  \\return ERR_PROTO        : Protocol error detected"]
	#[doc = "  \\return ERR_NONE         : No error, activation successful"]
	#[doc = ""]
	pub fn rfalIsoDepPollAGetActivationStatus() -> ReturnCode;
}
extern "C" {
	#[doc = "  \\brief  ISO-DEP Poller Start NFC-B Activation"]
	#[doc = ""]
	#[doc = "  This starts a NFC-B Activation into ISO-DEP layer (ISO14443-4) with the given"]
	#[doc = "  parameters. It will send ATTRIB and calculate supported higher bit rates of both"]
	#[doc = "  devices and perform activation."]
	#[doc = "  Once Activated all details of the device are provided on isoDepDev"]
	#[doc = ""]
	#[doc = "  \\see rfalIsoDepPollBGetActivationStatus"]
	#[doc = ""]
	#[doc = "  \\param[in]  FSDI         : Frame Size Device Integer to be used"]
	#[doc = "  \\param[in]  DID          : Device ID to be used or RFAL_ISODEP_NO_DID for not use DID"]
	#[doc = "  \\param[in]  maxBR        : Max bit rate supported by the Poller"]
	#[doc = "  \\param[in]  PARAM1       : ATTRIB PARAM1 byte (communication parameters)"]
	#[doc = "  \\param[in]  nfcbDev      : pointer to the NFC-B Device containing the SENSB_RES"]
	#[doc = "  \\param[in]  HLInfo       : pointer to Higher layer INF (NULL if none)"]
	#[doc = "  \\param[in]  HLInfoLen    : Length HLInfo"]
	#[doc = "  \\param[out] isoDepDev    : ISO-DEP information of the activated Listen device"]
	#[doc = ""]
	#[doc = "  \\return ERR_WRONG_STATE  : RFAL not initialized or incorrect mode"]
	#[doc = "  \\return ERR_PARAM        : Invalid parameters"]
	#[doc = "  \\return ERR_IO           : Generic internal error"]
	#[doc = "  \\return ERR_TIMEOUT      : Timeout error"]
	#[doc = "  \\return ERR_PAR          : Parity error detected"]
	#[doc = "  \\return ERR_CRC          : CRC error detected"]
	#[doc = "  \\return ERR_FRAMING      : Framing error detected"]
	#[doc = "  \\return ERR_PROTO        : Protocol error detected"]
	#[doc = "  \\return ERR_NONE         : No error, start of asynchronous operation successful"]
	#[doc = ""]
	pub fn rfalIsoDepPollBStartActivation(FSDI: rfalIsoDepFSxI,
	                                      DID: u8,
	                                      maxBR: rfalBitRate,
	                                      PARAM1: u8,
	                                      nfcbDev: *const rfalNfcbListenDevice,
	                                      HLInfo: *const u8,
	                                      HLInfoLen: u8,
	                                      isoDepDev: *mut rfalIsoDepDevice)
	                                      -> ReturnCode;
}
extern "C" {
	#[doc = "  \\brief  ISO-DEP Poller Get NFC-B Activation Status"]
	#[doc = ""]
	#[doc = "  Returns the activation status started by rfalIsoDepPollBStartActivation"]
	#[doc = ""]
	#[doc = "  \\see rfalIsoDepPollBStartActivation"]
	#[doc = ""]
	#[doc = "  \\return ERR_BUSY         : Operation is ongoing"]
	#[doc = "  \\return ERR_WRONG_STATE  : RFAL not initialized or incorrect mode"]
	#[doc = "  \\return ERR_PARAM        : Invalid parameters"]
	#[doc = "  \\return ERR_IO           : Generic internal error"]
	#[doc = "  \\return ERR_TIMEOUT      : Timeout error"]
	#[doc = "  \\return ERR_PAR          : Parity error detected"]
	#[doc = "  \\return ERR_CRC          : CRC error detected"]
	#[doc = "  \\return ERR_FRAMING      : Framing error detected"]
	#[doc = "  \\return ERR_PROTO        : Protocol error detected"]
	#[doc = "  \\return ERR_NONE         : No error, activation successful"]
	#[doc = ""]
	pub fn rfalIsoDepPollBGetActivationStatus() -> ReturnCode;
}
#[repr(u32)]
#[non_exhaustive]
#[doc = " Main state"]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum rfalNfcState {
	#[doc = "< Not Initialized state"]
	RFAL_NFC_STATE_NOTINIT = 0,
	#[doc = "< Initialize state"]
	RFAL_NFC_STATE_IDLE = 1,
	#[doc = "< Start Discovery loop state"]
	RFAL_NFC_STATE_START_DISCOVERY = 2,
	#[doc = "< Wake-Up state"]
	RFAL_NFC_STATE_WAKEUP_MODE = 3,
	#[doc = "< Technology Detection state"]
	RFAL_NFC_STATE_POLL_TECHDETECT = 10,
	#[doc = "< Collision Avoidance state"]
	RFAL_NFC_STATE_POLL_COLAVOIDANCE = 11,
	#[doc = "< Wait for Selection state"]
	RFAL_NFC_STATE_POLL_SELECT = 12,
	#[doc = "< Activation state"]
	RFAL_NFC_STATE_POLL_ACTIVATION = 13,
	#[doc = "< Listen Tech Detect"]
	RFAL_NFC_STATE_LISTEN_TECHDETECT = 20,
	#[doc = "< Listen Collision Avoidance"]
	RFAL_NFC_STATE_LISTEN_COLAVOIDANCE = 21,
	#[doc = "< Listen Activation state"]
	RFAL_NFC_STATE_LISTEN_ACTIVATION = 22,
	#[doc = "< Listen Sleep state"]
	RFAL_NFC_STATE_LISTEN_SLEEP = 23,
	#[doc = "< Activated state"]
	RFAL_NFC_STATE_ACTIVATED = 30,
	#[doc = "< Data Exchange Start state"]
	RFAL_NFC_STATE_DATAEXCHANGE = 31,
	#[doc = "< Data Exchange terminated"]
	RFAL_NFC_STATE_DATAEXCHANGE_DONE = 33,
	#[doc = "< Deactivation state"]
	RFAL_NFC_STATE_DEACTIVATION = 34,
}
#[repr(u32)]
#[non_exhaustive]
#[doc = " Device type"]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum rfalNfcDevType {
	#[doc = "< NFC-A Listener device type"]
	RFAL_NFC_LISTEN_TYPE_NFCA = 0,
	#[doc = "< NFC-B Listener device type"]
	RFAL_NFC_LISTEN_TYPE_NFCB = 1,
	#[doc = "< NFC-F Listener device type"]
	RFAL_NFC_LISTEN_TYPE_NFCF = 2,
	#[doc = "< NFC-V Listener device type"]
	RFAL_NFC_LISTEN_TYPE_NFCV = 3,
	#[doc = "< ST25TB Listener device type"]
	RFAL_NFC_LISTEN_TYPE_ST25TB = 4,
	#[doc = "< AP2P Listener device type"]
	RFAL_NFC_LISTEN_TYPE_AP2P = 5,
	#[doc = "< NFC-A Poller device type"]
	RFAL_NFC_POLL_TYPE_NFCA = 10,
	#[doc = "< NFC-B Poller device type"]
	RFAL_NFC_POLL_TYPE_NFCB = 11,
	#[doc = "< NFC-F Poller device type"]
	RFAL_NFC_POLL_TYPE_NFCF = 12,
	#[doc = "< NFC-V Poller device type"]
	RFAL_NFC_POLL_TYPE_NFCV = 13,
	#[doc = "< AP2P Poller device type"]
	RFAL_NFC_POLL_TYPE_AP2P = 15,
}
#[repr(u32)]
#[non_exhaustive]
#[doc = " Device interface"]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum rfalNfcRfInterface {
	#[doc = "< RF Frame interface"]
	RFAL_NFC_INTERFACE_RF = 0,
	#[doc = "< ISO-DEP interface"]
	RFAL_NFC_INTERFACE_ISODEP = 1,
	#[doc = "< NFC-DEP interface"]
	RFAL_NFC_INTERFACE_NFCDEP = 2,
}
#[doc = " Device struct containing all its details"]
#[repr(C)]
pub struct rfalNfcDevice {
	#[doc = "< Device's type"]
	pub type_: rfalNfcDevType,
	#[doc = "< Device's instance"]
	pub dev: rfalNfcDevice__bindgen_ty_1,
	#[doc = "< Device's NFCID"]
	pub nfcid: *mut u8,
	#[doc = "< Device's NFCID length"]
	pub nfcidLen: u8,
	#[doc = "< Device's interface"]
	pub rfInterface: rfalNfcRfInterface,
	#[doc = "< Device's protocol"]
	pub proto: rfalNfcDevice__bindgen_ty_2,
}
#[repr(C)]
pub struct rfalNfcDevice__bindgen_ty_1 {
	#[doc = "< NFC-A Listen Device instance"]
	pub nfca: __BindgenUnionField<rfalNfcaListenDevice>,
	#[doc = "< NFC-B Listen Device instance"]
	pub nfcb: __BindgenUnionField<rfalNfcbListenDevice>,
	#[doc = "< NFC-F Listen Device instance"]
	pub nfcf: __BindgenUnionField<rfalNfcfListenDevice>,
	#[doc = "< NFC-V Listen Device instance"]
	pub nfcv: __BindgenUnionField<rfalNfcvListenDevice>,
	#[doc = "< ST25TB Listen Device instance"]
	pub st25tb: __BindgenUnionField<rfalSt25tbListenDevice>,
	pub bindgen_union_field: [u32; 7usize],
}
#[test]
fn bindgen_test_layout_rfalNfcDevice__bindgen_ty_1() {
	assert_eq!(
	           ::core::mem::size_of::<rfalNfcDevice__bindgen_ty_1>(),
	           28usize,
	           concat!("Size of: ", stringify!(rfalNfcDevice__bindgen_ty_1))
	);
	assert_eq!(
	           ::core::mem::align_of::<rfalNfcDevice__bindgen_ty_1>(),
	           4usize,
	           concat!("Alignment of ", stringify!(rfalNfcDevice__bindgen_ty_1))
	);
	fn test_field_nfca() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcDevice__bindgen_ty_1>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).nfca) as usize - ptr as usize
		           },
		           0usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalNfcDevice__bindgen_ty_1),
			"::",
			stringify!(nfca)
		)
		);
	}
	test_field_nfca();
	fn test_field_nfcb() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcDevice__bindgen_ty_1>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).nfcb) as usize - ptr as usize
		           },
		           0usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalNfcDevice__bindgen_ty_1),
			"::",
			stringify!(nfcb)
		)
		);
	}
	test_field_nfcb();
	fn test_field_nfcf() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcDevice__bindgen_ty_1>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).nfcf) as usize - ptr as usize
		           },
		           0usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalNfcDevice__bindgen_ty_1),
			"::",
			stringify!(nfcf)
		)
		);
	}
	test_field_nfcf();
	fn test_field_nfcv() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcDevice__bindgen_ty_1>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).nfcv) as usize - ptr as usize
		           },
		           0usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalNfcDevice__bindgen_ty_1),
			"::",
			stringify!(nfcv)
		)
		);
	}
	test_field_nfcv();
	fn test_field_st25tb() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcDevice__bindgen_ty_1>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).st25tb) as usize - ptr as usize
		           },
		           0usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalNfcDevice__bindgen_ty_1),
			"::",
			stringify!(st25tb)
		)
		);
	}
	test_field_st25tb();
}
#[repr(C)]
pub struct rfalNfcDevice__bindgen_ty_2 {
	#[doc = "< ISO-DEP instance"]
	pub isoDep: __BindgenUnionField<rfalIsoDepDevice>,
	#[doc = "< NFC-DEP instance"]
	pub nfcDep: __BindgenUnionField<rfalNfcDepDevice>,
	pub bindgen_union_field: [u32; 24usize],
}
#[test]
fn bindgen_test_layout_rfalNfcDevice__bindgen_ty_2() {
	assert_eq!(
	           ::core::mem::size_of::<rfalNfcDevice__bindgen_ty_2>(),
	           96usize,
	           concat!("Size of: ", stringify!(rfalNfcDevice__bindgen_ty_2))
	);
	assert_eq!(
	           ::core::mem::align_of::<rfalNfcDevice__bindgen_ty_2>(),
	           4usize,
	           concat!("Alignment of ", stringify!(rfalNfcDevice__bindgen_ty_2))
	);
	fn test_field_isoDep() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcDevice__bindgen_ty_2>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).isoDep) as usize - ptr as usize
		           },
		           0usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalNfcDevice__bindgen_ty_2),
			"::",
			stringify!(isoDep)
		)
		);
	}
	test_field_isoDep();
	fn test_field_nfcDep() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcDevice__bindgen_ty_2>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).nfcDep) as usize - ptr as usize
		           },
		           0usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalNfcDevice__bindgen_ty_2),
			"::",
			stringify!(nfcDep)
		)
		);
	}
	test_field_nfcDep();
}
#[test]
fn bindgen_test_layout_rfalNfcDevice() {
	assert_eq!(
	           ::core::mem::size_of::<rfalNfcDevice>(),
	           140usize,
	           concat!("Size of: ", stringify!(rfalNfcDevice))
	);
	assert_eq!(
	           ::core::mem::align_of::<rfalNfcDevice>(),
	           4usize,
	           concat!("Alignment of ", stringify!(rfalNfcDevice))
	);
	fn test_field_type() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcDevice>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(rfalNfcDevice), "::", stringify!(type_))
		);
	}
	test_field_type();
	fn test_field_dev() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcDevice>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).dev) as usize - ptr as usize
		           },
		           4usize,
		           concat!("Offset of field: ", stringify!(rfalNfcDevice), "::", stringify!(dev))
		);
	}
	test_field_dev();
	fn test_field_nfcid() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcDevice>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).nfcid) as usize - ptr as usize
		           },
		           32usize,
		           concat!("Offset of field: ", stringify!(rfalNfcDevice), "::", stringify!(nfcid))
		);
	}
	test_field_nfcid();
	fn test_field_nfcidLen() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcDevice>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).nfcidLen) as usize - ptr as usize
		           },
		           36usize,
		           concat!("Offset of field: ", stringify!(rfalNfcDevice), "::", stringify!(nfcidLen))
		);
	}
	test_field_nfcidLen();
	fn test_field_rfInterface() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcDevice>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).rfInterface) as usize - ptr as usize
		           },
		           40usize,
		           concat!("Offset of field: ", stringify!(rfalNfcDevice), "::", stringify!(rfInterface))
		);
	}
	test_field_rfInterface();
	fn test_field_proto() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcDevice>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).proto) as usize - ptr as usize
		           },
		           44usize,
		           concat!("Offset of field: ", stringify!(rfalNfcDevice), "::", stringify!(proto))
		);
	}
	test_field_proto();
}
#[doc = " Discovery parameters"]
#[repr(C)]
pub struct rfalNfcDiscoverParam {
	#[doc = "< Compliancy mode to be used"]
	pub compMode: rfalComplianceMode,
	#[doc = "< Technologies to search for"]
	pub techs2Find: u16,
	#[doc = "< Duration of a whole Poll + Listen cycle"]
	pub totalDuration: u16,
	#[doc = "< Max number of devices"]
	pub devLimit: u8,
	#[doc = "< Max Bit rate to be used for communications"]
	pub maxBR: rfalBitRate,
	#[doc = "< Bit rate to poll for NFC-F"]
	pub nfcfBR: rfalBitRate,
	#[doc = "< NFCID3 to be used on the ATR_REQ/ATR_RES"]
	pub nfcid3: [u8; 10usize],
	#[doc = "< General bytes to be used on the ATR-REQ"]
	pub GB: [u8; 48usize],
	#[doc = "< Length of the General Bytes"]
	pub GBLen: u8,
	#[doc = "< Bit rate to poll for AP2P"]
	pub ap2pBR: rfalBitRate,
	#[doc = "< Configuration for Passive Listen mode NFC-A"]
	pub lmConfigPA: rfalLmConfPA,
	#[doc = "< Configuration for Passive Listen mode NFC-A"]
	pub lmConfigPF: rfalLmConfPF,
	#[doc = "< Callback to Notify upper layer"]
	pub notifyCb: ::core::option::Option<unsafe extern "C" fn(st: rfalNfcState)>,
	#[doc = "< Enable Wake-Up mode before polling"]
	pub wakeupEnabled: bool,
	#[doc = "< Wake-Up mode default configuration"]
	pub wakeupConfigDefault: bool,
	#[doc = "< Wake-Up mode configuration"]
	pub wakeupConfig: rfalWakeUpConfig,
	pub activate_after_sak: bool,
}
#[test]
fn bindgen_test_layout_rfalNfcDiscoverParam() {
	assert_eq!(
	           ::core::mem::size_of::<rfalNfcDiscoverParam>(),
	           184usize,
	           concat!("Size of: ", stringify!(rfalNfcDiscoverParam))
	);
	assert_eq!(
	           ::core::mem::align_of::<rfalNfcDiscoverParam>(),
	           4usize,
	           concat!("Alignment of ", stringify!(rfalNfcDiscoverParam))
	);
	fn test_field_compMode() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcDiscoverParam>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).compMode) as usize - ptr as usize
		           },
		           0usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalNfcDiscoverParam),
			"::",
			stringify!(compMode)
		)
		);
	}
	test_field_compMode();
	fn test_field_techs2Find() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcDiscoverParam>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).techs2Find) as usize - ptr as usize
		           },
		           4usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalNfcDiscoverParam),
			"::",
			stringify!(techs2Find)
		)
		);
	}
	test_field_techs2Find();
	fn test_field_totalDuration() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcDiscoverParam>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).totalDuration) as usize - ptr as usize
		           },
		           6usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalNfcDiscoverParam),
			"::",
			stringify!(totalDuration)
		)
		);
	}
	test_field_totalDuration();
	fn test_field_devLimit() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcDiscoverParam>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).devLimit) as usize - ptr as usize
		           },
		           8usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalNfcDiscoverParam),
			"::",
			stringify!(devLimit)
		)
		);
	}
	test_field_devLimit();
	fn test_field_maxBR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcDiscoverParam>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).maxBR) as usize - ptr as usize
		           },
		           12usize,
		           concat!("Offset of field: ", stringify!(rfalNfcDiscoverParam), "::", stringify!(maxBR))
		);
	}
	test_field_maxBR();
	fn test_field_nfcfBR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcDiscoverParam>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).nfcfBR) as usize - ptr as usize
		           },
		           16usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalNfcDiscoverParam),
			"::",
			stringify!(nfcfBR)
		)
		);
	}
	test_field_nfcfBR();
	fn test_field_nfcid3() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcDiscoverParam>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).nfcid3) as usize - ptr as usize
		           },
		           20usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalNfcDiscoverParam),
			"::",
			stringify!(nfcid3)
		)
		);
	}
	test_field_nfcid3();
	fn test_field_GB() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcDiscoverParam>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).GB) as usize - ptr as usize
		           },
		           30usize,
		           concat!("Offset of field: ", stringify!(rfalNfcDiscoverParam), "::", stringify!(GB))
		);
	}
	test_field_GB();
	fn test_field_GBLen() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcDiscoverParam>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).GBLen) as usize - ptr as usize
		           },
		           78usize,
		           concat!("Offset of field: ", stringify!(rfalNfcDiscoverParam), "::", stringify!(GBLen))
		);
	}
	test_field_GBLen();
	fn test_field_ap2pBR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcDiscoverParam>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).ap2pBR) as usize - ptr as usize
		           },
		           80usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalNfcDiscoverParam),
			"::",
			stringify!(ap2pBR)
		)
		);
	}
	test_field_ap2pBR();
	fn test_field_lmConfigPA() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcDiscoverParam>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).lmConfigPA) as usize - ptr as usize
		           },
		           84usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalNfcDiscoverParam),
			"::",
			stringify!(lmConfigPA)
		)
		);
	}
	test_field_lmConfigPA();
	fn test_field_lmConfigPF() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcDiscoverParam>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).lmConfigPF) as usize - ptr as usize
		           },
		           104usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalNfcDiscoverParam),
			"::",
			stringify!(lmConfigPF)
		)
		);
	}
	test_field_lmConfigPF();
	fn test_field_notifyCb() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcDiscoverParam>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).notifyCb) as usize - ptr as usize
		           },
		           128usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalNfcDiscoverParam),
			"::",
			stringify!(notifyCb)
		)
		);
	}
	test_field_notifyCb();
	fn test_field_wakeupEnabled() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcDiscoverParam>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).wakeupEnabled) as usize - ptr as usize
		           },
		           132usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalNfcDiscoverParam),
			"::",
			stringify!(wakeupEnabled)
		)
		);
	}
	test_field_wakeupEnabled();
	fn test_field_wakeupConfigDefault() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcDiscoverParam>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).wakeupConfigDefault) as usize - ptr as usize
		           },
		           133usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalNfcDiscoverParam),
			"::",
			stringify!(wakeupConfigDefault)
		)
		);
	}
	test_field_wakeupConfigDefault();
	fn test_field_wakeupConfig() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcDiscoverParam>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).wakeupConfig) as usize - ptr as usize
		           },
		           136usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalNfcDiscoverParam),
			"::",
			stringify!(wakeupConfig)
		)
		);
	}
	test_field_wakeupConfig();
	fn test_field_activate_after_sak() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcDiscoverParam>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).activate_after_sak) as usize - ptr as usize
		           },
		           180usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalNfcDiscoverParam),
			"::",
			stringify!(activate_after_sak)
		)
		);
	}
	test_field_activate_after_sak();
}
#[doc = " Buffer union, only one interface is used at a time"]
#[repr(C)]
pub struct rfalNfcBuffer {
	#[doc = "< RF buffer"]
	pub rfBuf: __BindgenUnionField<[u8; 256usize]>,
	#[doc = "< ISO-DEP buffer format (with header/prologue)"]
	pub isoDepBuf: __BindgenUnionField<rfalIsoDepApduBufFormat>,
	#[doc = "< NFC-DEP buffer format (with header/prologue)"]
	pub nfcDepBuf: __BindgenUnionField<rfalNfcDepPduBufFormat>,
	pub bindgen_union_field: [u8; 517usize],
}
#[test]
fn bindgen_test_layout_rfalNfcBuffer() {
	assert_eq!(
	           ::core::mem::size_of::<rfalNfcBuffer>(),
	           517usize,
	           concat!("Size of: ", stringify!(rfalNfcBuffer))
	);
	assert_eq!(
	           ::core::mem::align_of::<rfalNfcBuffer>(),
	           1usize,
	           concat!("Alignment of ", stringify!(rfalNfcBuffer))
	);
	fn test_field_rfBuf() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcBuffer>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).rfBuf) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(rfalNfcBuffer), "::", stringify!(rfBuf))
		);
	}
	test_field_rfBuf();
	fn test_field_isoDepBuf() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcBuffer>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).isoDepBuf) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(rfalNfcBuffer), "::", stringify!(isoDepBuf))
		);
	}
	test_field_isoDepBuf();
	fn test_field_nfcDepBuf() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcBuffer>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).nfcDepBuf) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(rfalNfcBuffer), "::", stringify!(nfcDepBuf))
		);
	}
	test_field_nfcDepBuf();
}
extern "C" {
	#[doc = " \\brief  RFAL NFC Worker"]
	#[doc = ""]
	#[doc = " It runs the internal state machine and runs the RFAL RF worker."]
	#[doc = ""]
	pub fn rfalNfcWorker();
}
extern "C" {
	#[doc = " \\brief  RFAL NFC Initialize"]
	#[doc = ""]
	#[doc = " It initializes this module and its dependencies"]
	#[doc = ""]
	#[doc = " \\return ERR_WRONG_STATE  : Incorrect state for this operation"]
	#[doc = " \\return ERR_IO           : Generic internal error"]
	#[doc = " \\return ERR_NONE         : No error"]
	#[doc = ""]
	pub fn rfalNfcInitialize() -> ReturnCode;
}
extern "C" {
	#[doc = " \\brief  RFAL NFC Discovery"]
	#[doc = ""]
	#[doc = " It set the device in Discovery state."]
	#[doc = " In discovery it will Poll and/or Listen for the technologies configured,"]
	#[doc = " and perform Wake-up mode if configured to do so."]
	#[doc = ""]
	#[doc = " The device list passed on disParams must not be empty."]
	#[doc = " The number of devices on the list is indicated by the devLimit and shall"]
	#[doc = " be at >= 1."]
	#[doc = ""]
	#[doc = " \\param[in]  disParams    : discovery configuration parameters"]
	#[doc = ""]
	#[doc = " \\return ERR_WRONG_STATE  : Incorrect state for this operation"]
	#[doc = " \\return ERR_PARAM        : Invalid parameters"]
	#[doc = " \\return ERR_NONE         : No error"]
	#[doc = ""]
	pub fn rfalNfcDiscover(disParams: *const rfalNfcDiscoverParam) -> ReturnCode;
}
extern "C" {
	#[doc = " \\brief  RFAL NFC Get State"]
	#[doc = ""]
	#[doc = " It returns the current state"]
	#[doc = ""]
	#[doc = " \\return rfalNfcState : the current state"]
	#[doc = ""]
	pub fn rfalNfcGetState() -> rfalNfcState;
}
extern "C" {
	#[doc = " \\brief  RFAL NFC Get Devices Found"]
	#[doc = ""]
	#[doc = " It returns the location of the device list and the number of"]
	#[doc = " devices found."]
	#[doc = ""]
	#[doc = " \\param[out]  devList     : device list location"]
	#[doc = " \\param[out]  devCnt      : number of devices found"]
	#[doc = ""]
	#[doc = " \\return ERR_WRONG_STATE  : Incorrect state for this operation"]
	#[doc = "                            Discovery still ongoing"]
	#[doc = " \\return ERR_PARAM        : Invalid parameters"]
	#[doc = " \\return ERR_NONE         : No error"]
	#[doc = ""]
	pub fn rfalNfcGetDevicesFound(devList: *mut *mut rfalNfcDevice, devCnt: *mut u8) -> ReturnCode;
}
extern "C" {
	#[doc = " \\brief  RFAL NFC Get Active Device"]
	#[doc = ""]
	#[doc = " It returns the location of the device current Active device"]
	#[doc = ""]
	#[doc = " \\param[out]  dev           : device info location"]
	#[doc = ""]
	#[doc = " \\return ERR_WRONG_STATE    : Incorrect state for this operation"]
	#[doc = "                              No device activated"]
	#[doc = " \\return ERR_PARAM          : Invalid parameters"]
	#[doc = " \\return ERR_NONE           : No error"]
	#[doc = ""]
	pub fn rfalNfcGetActiveDevice(dev: *mut *mut rfalNfcDevice) -> ReturnCode;
}
extern "C" {
	#[doc = " \\brief  RFAL NFC Select Device"]
	#[doc = ""]
	#[doc = " It selects the device to be activated."]
	#[doc = " It shall be called when more than one device has been identified to"]
	#[doc = " indiacte which device shall be actived"]
	#[doc = ""]
	#[doc = " \\param[in]  devIdx       : device index to be activated"]
	#[doc = ""]
	#[doc = " \\return ERR_WRONG_STATE  : Incorrect state for this operation"]
	#[doc = "                            Not in select state"]
	#[doc = " \\return ERR_PARAM        : Invalid parameters"]
	#[doc = " \\return ERR_NONE         : No error"]
	#[doc = ""]
	pub fn rfalNfcSelect(devIdx: u8) -> ReturnCode;
}
extern "C" {
	#[doc = " \\brief  RFAL NFC Start Data Exchange"]
	#[doc = ""]
	#[doc = " After a device has been activated, it starts a data exchange."]
	#[doc = " It handles automatically which interface/protocol to be used and acts accordingly."]
	#[doc = ""]
	#[doc = " In Listen mode the first frame/data shall be sent by the Reader/Initiator"]
	#[doc = " therefore this method must be called first with txDataLen set to zero"]
	#[doc = " to retrieve the rxData and rcvLen locations."]
	#[doc = ""]
	#[doc = ""]
	#[doc = " \\param[in]  txData       : data to be transmitted"]
	#[doc = " \\param[in]  txDataLen    : size of the data to be transmitted"]
	#[doc = " \\param[out] rxData       : location of the received data after operation is completed"]
	#[doc = " \\param[out] rvdLen       : location of thelength of the received data"]
	#[doc = " \\param[in]  fwt          : FWT to be used in case of RF interface."]
	#[doc = "                            If ISO-DEP or NFC-DEP interface is used, this will be ignored"]
	#[doc = ""]
	#[doc = " \\return ERR_WRONG_STATE  : Incorrect state for this operation"]
	#[doc = " \\return ERR_PARAM        : Invalid parameters"]
	#[doc = " \\return ERR_NONE         : No error"]
	#[doc = ""]
	pub fn rfalNfcDataExchangeStart(txData: *mut u8,
	                                txDataLen: u16,
	                                rxData: *mut *mut u8,
	                                rvdLen: *mut *mut u16,
	                                fwt: u32,
	                                tx_flag: u32)
	                                -> ReturnCode;
}
extern "C" {
	pub fn rfalNfcDataExchangeCustomStart(txData: *mut u8,
	                                      txDataLen: u16,
	                                      rxData: *mut *mut u8,
	                                      rvdLen: *mut *mut u16,
	                                      fwt: u32,
	                                      flags: u32)
	                                      -> ReturnCode;
}
extern "C" {
	#[doc = " \\brief  RFAL NFC Get Data Exchange Status"]
	#[doc = ""]
	#[doc = " Gets current Data Exchange status"]
	#[doc = ""]
	#[doc = " \\return  ERR_NONE         : Transceive done with no error"]
	#[doc = " \\return  ERR_BUSY         : Transceive ongoing"]
	#[doc = "  \\return ERR_AGAIN        : received one chaining block, copy received data"]
	#[doc = "                             and continue to call this method to retrieve the"]
	#[doc = "                             remaining blocks"]
	#[doc = " \\return  ERR_XXXX         : Error occurred"]
	#[doc = " \\return  ERR_TIMEOUT      : No response"]
	#[doc = " \\return  ERR_FRAMING      : Framing error detected"]
	#[doc = " \\return  ERR_PAR          : Parity error detected"]
	#[doc = " \\return  ERR_CRC          : CRC error detected"]
	#[doc = " \\return  ERR_LINK_LOSS    : Link Loss - External Field is Off"]
	#[doc = " \\return  ERR_RF_COLLISION : Collision detected"]
	#[doc = " \\return  ERR_IO           : Internal error"]
	#[doc = ""]
	pub fn rfalNfcDataExchangeGetStatus() -> ReturnCode;
}
extern "C" {
	#[doc = " \\brief  RFAL NFC Deactivate"]
	#[doc = ""]
	#[doc = " It triggers the deactivation procedure to terminate communications with"]
	#[doc = " remote device. At the end the field will be turned off."]
	#[doc = ""]
	#[doc = " \\param[in]  discovery    : TRUE if after deactivation go back into discovery"]
	#[doc = "                          : FALSE if after deactivation remain in idle"]
	#[doc = ""]
	#[doc = " \\return ERR_WRONG_STATE  : Incorrect state for this operation"]
	#[doc = " \\return ERR_NONE         : No error"]
	#[doc = ""]
	pub fn rfalNfcDeactivate(discovery: bool) -> ReturnCode;
}
#[repr(C)]
pub struct DigitalSignal {
	pub start_level: bool,
	pub edge_cnt: u32,
	pub edges_max_cnt: u32,
	pub edge_timings: *mut u32,
	pub reload_reg_buff: *mut u32,
}
#[test]
fn bindgen_test_layout_DigitalSignal() {
	assert_eq!(
	           ::core::mem::size_of::<DigitalSignal>(),
	           20usize,
	           concat!("Size of: ", stringify!(DigitalSignal))
	);
	assert_eq!(
	           ::core::mem::align_of::<DigitalSignal>(),
	           4usize,
	           concat!("Alignment of ", stringify!(DigitalSignal))
	);
	fn test_field_start_level() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<DigitalSignal>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).start_level) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(DigitalSignal), "::", stringify!(start_level))
		);
	}
	test_field_start_level();
	fn test_field_edge_cnt() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<DigitalSignal>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).edge_cnt) as usize - ptr as usize
		           },
		           4usize,
		           concat!("Offset of field: ", stringify!(DigitalSignal), "::", stringify!(edge_cnt))
		);
	}
	test_field_edge_cnt();
	fn test_field_edges_max_cnt() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<DigitalSignal>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).edges_max_cnt) as usize - ptr as usize
		           },
		           8usize,
		           concat!(
			"Offset of field: ",
			stringify!(DigitalSignal),
			"::",
			stringify!(edges_max_cnt)
		)
		);
	}
	test_field_edges_max_cnt();
	fn test_field_edge_timings() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<DigitalSignal>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).edge_timings) as usize - ptr as usize
		           },
		           12usize,
		           concat!("Offset of field: ", stringify!(DigitalSignal), "::", stringify!(edge_timings))
		);
	}
	test_field_edge_timings();
	fn test_field_reload_reg_buff() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<DigitalSignal>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).reload_reg_buff) as usize - ptr as usize
		           },
		           16usize,
		           concat!(
			"Offset of field: ",
			stringify!(DigitalSignal),
			"::",
			stringify!(reload_reg_buff)
		)
		);
	}
	test_field_reload_reg_buff();
}
extern "C" {
	pub fn digital_signal_alloc(max_edges_cnt: u32) -> *mut DigitalSignal;
}
extern "C" {
	pub fn digital_signal_free(signal: *mut DigitalSignal);
}
extern "C" {
	pub fn digital_signal_append(signal_a: *mut DigitalSignal, signal_b: *mut DigitalSignal) -> bool;
}
extern "C" {
	pub fn digital_signal_prepare_arr(signal: *mut DigitalSignal);
}
extern "C" {
	pub fn digital_signal_get_start_level(signal: *mut DigitalSignal) -> bool;
}
extern "C" {
	pub fn digital_signal_get_edges_cnt(signal: *mut DigitalSignal) -> u32;
}
extern "C" {
	pub fn digital_signal_get_edge(signal: *mut DigitalSignal, edge_num: u32) -> u32;
}
extern "C" {
	pub fn digital_signal_send(signal: *mut DigitalSignal, gpio: *const GpioPin);
}
#[repr(C)]
pub struct NfcaSignal {
	pub one: *mut DigitalSignal,
	pub zero: *mut DigitalSignal,
	pub tx_signal: *mut DigitalSignal,
}
#[test]
fn bindgen_test_layout_NfcaSignal() {
	assert_eq!(
	           ::core::mem::size_of::<NfcaSignal>(),
	           12usize,
	           concat!("Size of: ", stringify!(NfcaSignal))
	);
	assert_eq!(
	           ::core::mem::align_of::<NfcaSignal>(),
	           4usize,
	           concat!("Alignment of ", stringify!(NfcaSignal))
	);
	fn test_field_one() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<NfcaSignal>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).one) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(NfcaSignal), "::", stringify!(one))
		);
	}
	test_field_one();
	fn test_field_zero() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<NfcaSignal>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).zero) as usize - ptr as usize
		           },
		           4usize,
		           concat!("Offset of field: ", stringify!(NfcaSignal), "::", stringify!(zero))
		);
	}
	test_field_zero();
	fn test_field_tx_signal() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<NfcaSignal>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).tx_signal) as usize - ptr as usize
		           },
		           8usize,
		           concat!("Offset of field: ", stringify!(NfcaSignal), "::", stringify!(tx_signal))
		);
	}
	test_field_tx_signal();
}
extern "C" {
	pub fn nfca_get_crc16(buff: *mut u8, len: u16) -> u16;
}
extern "C" {
	pub fn nfca_append_crc16(buff: *mut u8, len: u16);
}
extern "C" {
	pub fn nfca_emulation_handler(buff_rx: *mut u8, buff_rx_len: u16, buff_tx: *mut u8, buff_tx_len: *mut u16) -> bool;
}
extern "C" {
	pub fn nfca_signal_alloc() -> *mut NfcaSignal;
}
extern "C" {
	pub fn nfca_signal_free(nfca_signal: *mut NfcaSignal);
}
extern "C" {
	pub fn nfca_signal_encode(nfca_signal: *mut NfcaSignal, data: *mut u8, bits: u16, parity: *mut u8);
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum FuriHalNfcTxRxType {
	FuriHalNfcTxRxTypeDefault = 0,
	FuriHalNfcTxRxTypeRxNoCrc = 1,
	FuriHalNfcTxRxTypeRxKeepPar = 2,
	FuriHalNfcTxRxTypeRaw = 3,
	FuriHalNfcTxRxTypeRxRaw = 4,
	FuriHalNfcTxRxTransparent = 5,
}
pub type FuriHalNfcEmulateCallback = ::core::option::Option<unsafe extern "C" fn(buff_rx: *mut u8,
                                                                                 buff_rx_len: u16,
                                                                                 buff_tx: *mut u8,
                                                                                 buff_tx_len: *mut u16,
                                                                                 flags: *mut u32,
                                                                                 context: *mut core::ffi::c_void)
                                                                                 -> bool>;
#[repr(u32)]
#[non_exhaustive]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum FuriHalNfcType {
	FuriHalNfcTypeA = 0,
	FuriHalNfcTypeB = 1,
	FuriHalNfcTypeF = 2,
	FuriHalNfcTypeV = 3,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum FuriHalNfcInterface {
	FuriHalNfcInterfaceRf = 0,
	FuriHalNfcInterfaceIsoDep = 1,
	FuriHalNfcInterfaceNfcDep = 2,
}
#[repr(C)]
pub struct FuriHalNfcDevData {
	pub type_: FuriHalNfcType,
	pub interface: FuriHalNfcInterface,
	pub uid_len: u8,
	pub uid: [u8; 10usize],
	pub cuid: u32,
	pub atqa: [u8; 2usize],
	pub sak: u8,
}
#[test]
fn bindgen_test_layout_FuriHalNfcDevData() {
	assert_eq!(
	           ::core::mem::size_of::<FuriHalNfcDevData>(),
	           28usize,
	           concat!("Size of: ", stringify!(FuriHalNfcDevData))
	);
	assert_eq!(
	           ::core::mem::align_of::<FuriHalNfcDevData>(),
	           4usize,
	           concat!("Alignment of ", stringify!(FuriHalNfcDevData))
	);
	fn test_field_type() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<FuriHalNfcDevData>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(FuriHalNfcDevData), "::", stringify!(type_))
		);
	}
	test_field_type();
	fn test_field_interface() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<FuriHalNfcDevData>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).interface) as usize - ptr as usize
		           },
		           4usize,
		           concat!(
			"Offset of field: ",
			stringify!(FuriHalNfcDevData),
			"::",
			stringify!(interface)
		)
		);
	}
	test_field_interface();
	fn test_field_uid_len() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<FuriHalNfcDevData>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).uid_len) as usize - ptr as usize
		           },
		           8usize,
		           concat!("Offset of field: ", stringify!(FuriHalNfcDevData), "::", stringify!(uid_len))
		);
	}
	test_field_uid_len();
	fn test_field_uid() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<FuriHalNfcDevData>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).uid) as usize - ptr as usize
		           },
		           9usize,
		           concat!("Offset of field: ", stringify!(FuriHalNfcDevData), "::", stringify!(uid))
		);
	}
	test_field_uid();
	fn test_field_cuid() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<FuriHalNfcDevData>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).cuid) as usize - ptr as usize
		           },
		           20usize,
		           concat!("Offset of field: ", stringify!(FuriHalNfcDevData), "::", stringify!(cuid))
		);
	}
	test_field_cuid();
	fn test_field_atqa() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<FuriHalNfcDevData>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).atqa) as usize - ptr as usize
		           },
		           24usize,
		           concat!("Offset of field: ", stringify!(FuriHalNfcDevData), "::", stringify!(atqa))
		);
	}
	test_field_atqa();
	fn test_field_sak() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<FuriHalNfcDevData>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).sak) as usize - ptr as usize
		           },
		           26usize,
		           concat!("Offset of field: ", stringify!(FuriHalNfcDevData), "::", stringify!(sak))
		);
	}
	test_field_sak();
}
pub type FuriHalNfcTxRxSniffCallback =
	::core::option::Option<unsafe extern "C" fn(data: *mut u8, bits: u16, crc_dropped: bool, context: *mut core::ffi::c_void)>;
#[repr(C)]
pub struct FuriHalNfcTxRxContext {
	pub tx_data: [u8; 512usize],
	pub tx_parity: [u8; 64usize],
	pub tx_bits: u16,
	pub rx_data: [u8; 512usize],
	pub rx_parity: [u8; 64usize],
	pub rx_bits: u16,
	pub tx_rx_type: FuriHalNfcTxRxType,
	pub nfca_signal: *mut NfcaSignal,
	pub sniff_tx: FuriHalNfcTxRxSniffCallback,
	pub sniff_rx: FuriHalNfcTxRxSniffCallback,
	pub sniff_context: *mut core::ffi::c_void,
}
#[test]
fn bindgen_test_layout_FuriHalNfcTxRxContext() {
	assert_eq!(
	           ::core::mem::size_of::<FuriHalNfcTxRxContext>(),
	           1176usize,
	           concat!("Size of: ", stringify!(FuriHalNfcTxRxContext))
	);
	assert_eq!(
	           ::core::mem::align_of::<FuriHalNfcTxRxContext>(),
	           4usize,
	           concat!("Alignment of ", stringify!(FuriHalNfcTxRxContext))
	);
	fn test_field_tx_data() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<FuriHalNfcTxRxContext>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).tx_data) as usize - ptr as usize
		           },
		           0usize,
		           concat!(
			"Offset of field: ",
			stringify!(FuriHalNfcTxRxContext),
			"::",
			stringify!(tx_data)
		)
		);
	}
	test_field_tx_data();
	fn test_field_tx_parity() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<FuriHalNfcTxRxContext>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).tx_parity) as usize - ptr as usize
		           },
		           512usize,
		           concat!(
			"Offset of field: ",
			stringify!(FuriHalNfcTxRxContext),
			"::",
			stringify!(tx_parity)
		)
		);
	}
	test_field_tx_parity();
	fn test_field_tx_bits() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<FuriHalNfcTxRxContext>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).tx_bits) as usize - ptr as usize
		           },
		           576usize,
		           concat!(
			"Offset of field: ",
			stringify!(FuriHalNfcTxRxContext),
			"::",
			stringify!(tx_bits)
		)
		);
	}
	test_field_tx_bits();
	fn test_field_rx_data() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<FuriHalNfcTxRxContext>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).rx_data) as usize - ptr as usize
		           },
		           578usize,
		           concat!(
			"Offset of field: ",
			stringify!(FuriHalNfcTxRxContext),
			"::",
			stringify!(rx_data)
		)
		);
	}
	test_field_rx_data();
	fn test_field_rx_parity() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<FuriHalNfcTxRxContext>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).rx_parity) as usize - ptr as usize
		           },
		           1090usize,
		           concat!(
			"Offset of field: ",
			stringify!(FuriHalNfcTxRxContext),
			"::",
			stringify!(rx_parity)
		)
		);
	}
	test_field_rx_parity();
	fn test_field_rx_bits() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<FuriHalNfcTxRxContext>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).rx_bits) as usize - ptr as usize
		           },
		           1154usize,
		           concat!(
			"Offset of field: ",
			stringify!(FuriHalNfcTxRxContext),
			"::",
			stringify!(rx_bits)
		)
		);
	}
	test_field_rx_bits();
	fn test_field_tx_rx_type() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<FuriHalNfcTxRxContext>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).tx_rx_type) as usize - ptr as usize
		           },
		           1156usize,
		           concat!(
			"Offset of field: ",
			stringify!(FuriHalNfcTxRxContext),
			"::",
			stringify!(tx_rx_type)
		)
		);
	}
	test_field_tx_rx_type();
	fn test_field_nfca_signal() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<FuriHalNfcTxRxContext>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).nfca_signal) as usize - ptr as usize
		           },
		           1160usize,
		           concat!(
			"Offset of field: ",
			stringify!(FuriHalNfcTxRxContext),
			"::",
			stringify!(nfca_signal)
		)
		);
	}
	test_field_nfca_signal();
	fn test_field_sniff_tx() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<FuriHalNfcTxRxContext>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).sniff_tx) as usize - ptr as usize
		           },
		           1164usize,
		           concat!(
			"Offset of field: ",
			stringify!(FuriHalNfcTxRxContext),
			"::",
			stringify!(sniff_tx)
		)
		);
	}
	test_field_sniff_tx();
	fn test_field_sniff_rx() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<FuriHalNfcTxRxContext>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).sniff_rx) as usize - ptr as usize
		           },
		           1168usize,
		           concat!(
			"Offset of field: ",
			stringify!(FuriHalNfcTxRxContext),
			"::",
			stringify!(sniff_rx)
		)
		);
	}
	test_field_sniff_rx();
	fn test_field_sniff_context() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<FuriHalNfcTxRxContext>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).sniff_context) as usize - ptr as usize
		           },
		           1172usize,
		           concat!(
			"Offset of field: ",
			stringify!(FuriHalNfcTxRxContext),
			"::",
			stringify!(sniff_context)
		)
		);
	}
	test_field_sniff_context();
}
extern "C" {
	#[doc = " Init nfc"]
	pub fn furi_hal_nfc_init();
}
extern "C" {
	#[doc = " Check if nfc worker is busy"]
	#[doc = ""]
	#[doc = " @return     true if busy"]
	pub fn furi_hal_nfc_is_busy() -> bool;
}
extern "C" {
	#[doc = " Check if nfc is initialized"]
	#[doc = ""]
	#[doc = " @return     true if initialized"]
	pub fn furi_hal_nfc_is_init() -> bool;
}
extern "C" {
	#[doc = " NFC field on"]
	pub fn furi_hal_nfc_field_on();
}
extern "C" {
	#[doc = " NFC field off"]
	pub fn furi_hal_nfc_field_off();
}
extern "C" {
	#[doc = " NFC start sleep"]
	pub fn furi_hal_nfc_start_sleep();
}
extern "C" {
	pub fn furi_hal_nfc_stop_cmd();
}
extern "C" {
	#[doc = " NFC stop sleep"]
	pub fn furi_hal_nfc_exit_sleep();
}
extern "C" {
	#[doc = " NFC poll"]
	#[doc = ""]
	#[doc = " @param      dev_list    pointer to rfalNfcDevice buffer"]
	#[doc = " @param      dev_cnt     pointer device count"]
	#[doc = " @param      timeout     timeout in ms"]
	#[doc = " @param      deactivate  deactivate flag"]
	#[doc = ""]
	#[doc = " @return     true on success"]
	pub fn furi_hal_nfc_detect(nfc_data: *mut FuriHalNfcDevData, timeout: u32) -> bool;
}
extern "C" {
	#[doc = " Activate NFC-A tag"]
	#[doc = ""]
	#[doc = " @param      timeout      timeout in ms"]
	#[doc = " @param      cuid         pointer to 32bit uid"]
	#[doc = ""]
	#[doc = " @return     true on succeess"]
	pub fn furi_hal_nfc_activate_nfca(timeout: u32, cuid: *mut u32) -> bool;
}
extern "C" {
	#[doc = " NFC listen"]
	#[doc = ""]
	#[doc = " @param      uid                 pointer to uid buffer"]
	#[doc = " @param      uid_len             uid length"]
	#[doc = " @param      atqa                pointer to atqa"]
	#[doc = " @param      sak                 sak"]
	#[doc = " @param      activate_after_sak  activate after sak flag"]
	#[doc = " @param      timeout             timeout in ms"]
	#[doc = ""]
	#[doc = " @return     true on success"]
	pub fn furi_hal_nfc_listen(uid: *mut u8, uid_len: u8, atqa: *mut u8, sak: u8, activate_after_sak: bool, timeout: u32) -> bool;
}
extern "C" {
	#[doc = " Start Target Listen mode"]
	#[doc = " @note RFAL free implementation"]
	#[doc = ""]
	#[doc = " @param       nfc_data            FuriHalNfcDevData instance"]
	pub fn furi_hal_nfc_listen_start(nfc_data: *mut FuriHalNfcDevData);
}
extern "C" {
	#[doc = " Read data in Target Listen mode"]
	#[doc = " @note Must be called only after furi_hal_nfc_listen_start()"]
	#[doc = ""]
	#[doc = " @param       tx_rx               FuriHalNfcTxRxContext instance"]
	#[doc = " @param       timeout_ms          timeout im ms"]
	#[doc = ""]
	#[doc = " @return      true on not empty receive"]
	pub fn furi_hal_nfc_listen_rx(tx_rx: *mut FuriHalNfcTxRxContext, timeout_ms: u32) -> bool;
}
extern "C" {
	#[doc = " Set Target in Sleep state"]
	pub fn furi_hal_nfc_listen_sleep();
}
extern "C" {
	#[doc = " Emulate NFC-A Target"]
	#[doc = " @note RFAL based implementation"]
	#[doc = ""]
	#[doc = " @param       uid                 NFC-A UID"]
	#[doc = " @param       uid_len             NFC-A UID length"]
	#[doc = " @param       atqa                NFC-A ATQA"]
	#[doc = " @param       sak                 NFC-A SAK"]
	#[doc = " @param       callback            FuriHalNfcEmulateCallback instance"]
	#[doc = " @param       context             pointer to context for callback"]
	#[doc = " @param       timeout             timeout in ms"]
	#[doc = ""]
	#[doc = " @return      true on success"]
	pub fn furi_hal_nfc_emulate_nfca(uid: *mut u8,
	                                 uid_len: u8,
	                                 atqa: *mut u8,
	                                 sak: u8,
	                                 callback: FuriHalNfcEmulateCallback,
	                                 context: *mut core::ffi::c_void,
	                                 timeout: u32)
	                                 -> bool;
}
extern "C" {
	#[doc = " NFC data exchange"]
	#[doc = ""]
	#[doc = " @param       tx_rx_ctx   FuriHalNfcTxRxContext instance"]
	#[doc = ""]
	#[doc = " @return      true on success"]
	pub fn furi_hal_nfc_tx_rx(tx_rx: *mut FuriHalNfcTxRxContext, timeout_ms: u16) -> bool;
}
extern "C" {
	#[doc = " NFC data full exhange"]
	#[doc = ""]
	#[doc = " @param       tx_rx_ctx   FuriHalNfcTxRxContext instance"]
	#[doc = ""]
	#[doc = " @return      true on success"]
	pub fn furi_hal_nfc_tx_rx_full(tx_rx: *mut FuriHalNfcTxRxContext) -> bool;
}
extern "C" {
	#[doc = " NFC deactivate and start sleep"]
	pub fn furi_hal_nfc_sleep();
}
extern "C" {
	pub fn furi_hal_nfc_stop();
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum FuriHalNfcReturn {
	#[doc = "< no error occurred"]
	FuriHalNfcReturnOk = 0,
	#[doc = "< not enough memory to perform the requested operation"]
	FuriHalNfcReturnNomem = 1,
	#[doc = "< device or resource busy"]
	FuriHalNfcReturnBusy = 2,
	#[doc = "< generic IO error"]
	FuriHalNfcReturnIo = 3,
	#[doc = "< error due to timeout"]
	FuriHalNfcReturnTimeout = 4,
	#[doc = "< invalid request or requested function can't be executed at the moment"]
	FuriHalNfcReturnRequest = 5,
	#[doc = "< No message of desired type"]
	FuriHalNfcReturnNomsg = 6,
	#[doc = "< Parameter error"]
	FuriHalNfcReturnParam = 7,
	#[doc = "< System error"]
	FuriHalNfcReturnSystem = 8,
	#[doc = "< Framing error"]
	FuriHalNfcReturnFraming = 9,
	#[doc = "< lost one or more received bytes"]
	FuriHalNfcReturnOverrun = 10,
	#[doc = "< protocol error"]
	FuriHalNfcReturnProto = 11,
	#[doc = "< Internal Error"]
	FuriHalNfcReturnInternal = 12,
	#[doc = "< Call again"]
	FuriHalNfcReturnAgain = 13,
	#[doc = "< memory corruption"]
	FuriHalNfcReturnMemCorrupt = 14,
	#[doc = "< not implemented"]
	FuriHalNfcReturnNotImplemented = 15,
	#[doc = "< Program Counter has been manipulated or spike/noise trigger illegal operation"]
	FuriHalNfcReturnPcCorrupt = 16,
	#[doc = "< error sending"]
	FuriHalNfcReturnSend = 17,
	#[doc = "< indicates error detected but to be ignored"]
	FuriHalNfcReturnIgnore = 18,
	#[doc = "< indicates error in state machine (unexpected cmd)"]
	FuriHalNfcReturnSemantic = 19,
	#[doc = "< indicates error in state machine (unknown cmd)"]
	FuriHalNfcReturnSyntax = 20,
	#[doc = "< crc error"]
	FuriHalNfcReturnCrc = 21,
	#[doc = "< transponder not found"]
	FuriHalNfcReturnNotfound = 22,
	#[doc = "< transponder not unique - more than one transponder in field"]
	FuriHalNfcReturnNotunique = 23,
	#[doc = "< requested operation not supported"]
	FuriHalNfcReturnNotsupp = 24,
	#[doc = "< write error"]
	FuriHalNfcReturnWrite = 25,
	#[doc = "< fifo over or underflow error"]
	FuriHalNfcReturnFifo = 26,
	#[doc = "< parity error"]
	FuriHalNfcReturnPar = 27,
	#[doc = "< transfer has already finished"]
	FuriHalNfcReturnDone = 28,
	#[doc = "< collision error (Bit Collision or during RF Collision avoidance )"]
	FuriHalNfcReturnRfCollision = 29,
	#[doc = "< lost one or more received bytes"]
	FuriHalNfcReturnHwOverrun = 30,
	#[doc = "< device requested release"]
	FuriHalNfcReturnReleaseReq = 31,
	#[doc = "< device requested sleep"]
	FuriHalNfcReturnSleepReq = 32,
	#[doc = "< incorrent state for requested operation"]
	FuriHalNfcReturnWrongState = 33,
	#[doc = "< blocking procedure reached maximum runs"]
	FuriHalNfcReturnMaxReruns = 34,
	#[doc = "< operation aborted due to disabled configuration"]
	FuriHalNfcReturnDisabled = 35,
	#[doc = "< expected hw do not match"]
	FuriHalNfcReturnHwMismatch = 36,
	#[doc = "< Other device's field didn't behave as expected: turned off by Initiator in Passive mode, or AP2P did not turn on field"]
	FuriHalNfcReturnLinkLoss = 37,
	#[doc = "< invalid or not initalized device handle"]
	FuriHalNfcReturnInvalidHandle = 38,
	#[doc = "< Incomplete byte rcvd"]
	FuriHalNfcReturnIncompleteByte = 40,
	#[doc = "< Incomplete byte rcvd - 1 bit"]
	FuriHalNfcReturnIncompleteByte01 = 41,
	#[doc = "< Incomplete byte rcvd - 2 bit"]
	FuriHalNfcReturnIncompleteByte02 = 42,
	#[doc = "< Incomplete byte rcvd - 3 bit"]
	FuriHalNfcReturnIncompleteByte03 = 43,
	#[doc = "< Incomplete byte rcvd - 4 bit"]
	FuriHalNfcReturnIncompleteByte04 = 44,
	#[doc = "< Incomplete byte rcvd - 5 bit"]
	FuriHalNfcReturnIncompleteByte05 = 45,
	#[doc = "< Incomplete byte rcvd - 6 bit"]
	FuriHalNfcReturnIncompleteByte06 = 46,
	#[doc = "< Incomplete byte rcvd - 7 bit"]
	FuriHalNfcReturnIncompleteByte07 = 47,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum FuriHalNfcMode {
	#[doc = "< No mode selected/defined"]
	FuriHalNfcModeNone = 0,
	#[doc = "< Mode to perform as NFCA (ISO14443A) Poller (PCD)"]
	FuriHalNfcModePollNfca = 1,
	#[doc = "< Mode to perform as NFCA T1T (Topaz) Poller (PCD)"]
	FuriHalNfcModePollNfcaT1t = 2,
	#[doc = "< Mode to perform as NFCB (ISO14443B) Poller (PCD)"]
	FuriHalNfcModePollNfcb = 3,
	#[doc = "< Mode to perform as B' Calypso (Innovatron) (PCD)"]
	FuriHalNfcModePollBPrime = 4,
	#[doc = "< Mode to perform as CTS Poller (PCD)"]
	FuriHalNfcModePollBCts = 5,
	#[doc = "< Mode to perform as NFCF (FeliCa) Poller (PCD)"]
	FuriHalNfcModePollNfcf = 6,
	#[doc = "< Mode to perform as NFCV (ISO15963) Poller (PCD)"]
	FuriHalNfcModePollNfcv = 7,
	#[doc = "< Mode to perform as PicoPass / iClass Poller (PCD)"]
	FuriHalNfcModePollPicopass = 8,
	#[doc = "< Mode to perform as Active P2P (ISO18092) Initiator"]
	FuriHalNfcModePollActiveP2p = 9,
	#[doc = "< Mode to perform as NFCA (ISO14443A) Listener (PICC)"]
	FuriHalNfcModeListenNfca = 10,
	#[doc = "< Mode to perform as NFCA (ISO14443B) Listener (PICC)"]
	FuriHalNfcModeListenNfcb = 11,
	#[doc = "< Mode to perform as NFCA (ISO15963) Listener (PICC)"]
	FuriHalNfcModeListenNfcf = 12,
	#[doc = "< Mode to perform as Active P2P (ISO18092) Target"]
	FuriHalNfcModeListenActiveP2p = 13,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum FuriHalNfcBitrate {
	#[doc = "< Bit Rate 106 kbit/s (fc/128)"]
	FuriHalNfcBitrate106 = 0,
	#[doc = "< Bit Rate 212 kbit/s (fc/64)"]
	FuriHalNfcBitrate212 = 1,
	#[doc = "< Bit Rate 424 kbit/s (fc/32)"]
	FuriHalNfcBitrate424 = 2,
	#[doc = "< Bit Rate 848 kbit/s (fc/16)"]
	FuriHalNfcBitrate848 = 3,
	#[doc = "< Bit Rate 1695 kbit/s (fc/8)"]
	FuriHalNfcBitrate1695 = 4,
	#[doc = "< Bit Rate 3390 kbit/s (fc/4)"]
	FuriHalNfcBitrate3390 = 5,
	#[doc = "< Bit Rate 6780 kbit/s (fc/2)"]
	FuriHalNfcBitrate6780 = 6,
	#[doc = "< Bit Rate 13560 kbit/s (fc)"]
	FuriHalNfcBitrate13560 = 7,
	#[doc = "< Bit Rate 52.97 kbit/s (fc/256) Fast Mode VICC->VCD"]
	FuriHalNfcBitrate52p97 = 235,
	#[doc = "< Bit Rate 26,48 kbit/s (fc/512) NFCV VICC->VCD & VCD->VICC 1of4"]
	FuriHalNfcBitrate26p48 = 236,
	#[doc = "< Bit Rate 1,66 kbit/s (fc/8192) NFCV VCD->VICC 1of256"]
	FuriHalNfcBitrate1p66 = 237,
	#[doc = "< Value indicating to keep the same previous bit rate"]
	FuriHalNfcBitrateKeep = 255,
}
extern "C" {
	pub fn furi_hal_nfc_ll_set_mode(mode: FuriHalNfcMode, txBR: FuriHalNfcBitrate, rxBR: FuriHalNfcBitrate) -> FuriHalNfcReturn;
}
extern "C" {
	pub fn furi_hal_nfc_ll_set_guard_time(cycles: u32);
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum FuriHalNfcErrorHandling {
	#[doc = "< No special error handling will be performed"]
	FuriHalNfcErrorHandlingNone = 0,
	#[doc = "< Error handling set to perform as NFC compliant device"]
	FuriHalNfcErrorHandlingNfc = 1,
	#[doc = "< Error handling set to perform as EMVCo compliant device"]
	FuriHalNfcErrorHandlingEmvco = 2,
}
extern "C" {
	pub fn furi_hal_nfc_ll_set_error_handling(eHandling: FuriHalNfcErrorHandling);
}
extern "C" {
	pub fn furi_hal_nfc_ll_set_fdt_listen(cycles: u32);
}
extern "C" {
	pub fn furi_hal_nfc_ll_set_fdt_poll(FDTPoll: u32);
}
extern "C" {
	pub fn furi_hal_nfc_ll_txrx_on();
}
extern "C" {
	pub fn furi_hal_nfc_ll_txrx_off();
}
extern "C" {
	pub fn furi_hal_nfc_ll_txrx(txBuf: *mut u8,
	                            txBufLen: u16,
	                            rxBuf: *mut u8,
	                            rxBufLen: u16,
	                            actLen: *mut u16,
	                            flags: u32,
	                            fwt: u32)
	                            -> FuriHalNfcReturn;
}
extern "C" {
	pub fn furi_hal_nfc_ll_poll();
}
#[repr(u32)]
#[non_exhaustive]
#[doc = " @brief USB device machine states"]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum usbd_machine_state {
	usbd_state_disabled = 0,
	usbd_state_disconnected = 1,
	#[doc = "< Default."]
	usbd_state_default = 2,
	#[doc = "< Addressed."]
	usbd_state_addressed = 3,
	#[doc = "< Configured."]
	usbd_state_configured = 4,
}
#[repr(u32)]
#[non_exhaustive]
#[doc = "\\brief USB device control endpoint machine state."]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum usbd_ctl_state {
	#[doc = "<\\brief Idle stage. Awaiting for SETUP packet."]
	usbd_ctl_idle = 0,
	#[doc = "<\\brief RX stage. Receiving DATA-OUT payload."]
	usbd_ctl_rxdata = 1,
	#[doc = "<\\brief TX stage. Transmitting DATA-IN payload."]
	usbd_ctl_txdata = 2,
	#[doc = "<\\brief TX stage. Transmitting DATA-IN payload. Zero length"]
	#[doc = " packet maybe required.."]
	usbd_ctl_ztxdata = 3,
	#[doc = "<\\brief TX stage. Last DATA-IN packed passed to buffer. Awaiting"]
	#[doc = " for the TX completion."]
	usbd_ctl_lastdata = 4,
	#[doc = "<\\brief STATUS-IN stage."]
	usbd_ctl_statusin = 5,
	#[doc = "<\\brief STATUS-OUT stage."]
	usbd_ctl_statusout = 6,
}
#[repr(u32)]
#[non_exhaustive]
#[doc = "\\brief Reporting status results."]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum _usbd_respond {
	#[doc = "<\\brief Function has an error, STALLPID will be issued."]
	usbd_fail = 0,
	#[doc = "<\\brief Function completes request accepted ZLP or data will be send."]
	usbd_ack = 1,
	#[doc = "<\\brief Function is busy. NAK handshake."]
	usbd_nak = 2,
}
#[doc = "\\brief Reporting status results."]
pub use self::_usbd_respond as usbd_respond;
#[doc = "\\brief Represents a USB device data."]
pub type usbd_device = _usbd_device;
#[doc = "\\brief Represents generic USB control request."]
#[repr(C)]
pub struct usbd_ctlreq {
	#[doc = "<\\brief This bitmapped field identifies the characteristics of"]
	#[doc = " the specific request."]
	pub bmRequestType: u8,
	#[doc = "<\\brief This field specifies the particular request."]
	pub bRequest: u8,
	#[doc = "<\\brief It is used to pass a parameter to the device, specific to"]
	#[doc = " the request."]
	pub wValue: u16,
	#[doc = "<\\brief It is used to pass a parameter to the device, specific to"]
	#[doc = " the request."]
	pub wIndex: u16,
	#[doc = "<\\brief This field specifies the length of the data transferred"]
	#[doc = " during the second phase of the control transfer."]
	pub wLength: u16,
	#[doc = "<\\brief Data payload."]
	pub data: __IncompleteArrayField<u8>,
}
#[test]
fn bindgen_test_layout_usbd_ctlreq() {
	assert_eq!(
	           ::core::mem::size_of::<usbd_ctlreq>(),
	           8usize,
	           concat!("Size of: ", stringify!(usbd_ctlreq))
	);
	assert_eq!(
	           ::core::mem::align_of::<usbd_ctlreq>(),
	           2usize,
	           concat!("Alignment of ", stringify!(usbd_ctlreq))
	);
	fn test_field_bmRequestType() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<usbd_ctlreq>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).bmRequestType) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(usbd_ctlreq), "::", stringify!(bmRequestType))
		);
	}
	test_field_bmRequestType();
	fn test_field_bRequest() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<usbd_ctlreq>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).bRequest) as usize - ptr as usize
		           },
		           1usize,
		           concat!("Offset of field: ", stringify!(usbd_ctlreq), "::", stringify!(bRequest))
		);
	}
	test_field_bRequest();
	fn test_field_wValue() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<usbd_ctlreq>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).wValue) as usize - ptr as usize
		           },
		           2usize,
		           concat!("Offset of field: ", stringify!(usbd_ctlreq), "::", stringify!(wValue))
		);
	}
	test_field_wValue();
	fn test_field_wIndex() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<usbd_ctlreq>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).wIndex) as usize - ptr as usize
		           },
		           4usize,
		           concat!("Offset of field: ", stringify!(usbd_ctlreq), "::", stringify!(wIndex))
		);
	}
	test_field_wIndex();
	fn test_field_wLength() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<usbd_ctlreq>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).wLength) as usize - ptr as usize
		           },
		           6usize,
		           concat!("Offset of field: ", stringify!(usbd_ctlreq), "::", stringify!(wLength))
		);
	}
	test_field_wLength();
	fn test_field_data() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<usbd_ctlreq>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).data) as usize - ptr as usize
		           },
		           8usize,
		           concat!("Offset of field: ", stringify!(usbd_ctlreq), "::", stringify!(data))
		);
	}
	test_field_data();
}
#[doc = " USB device status data."]
#[repr(C)]
pub struct usbd_status {
	#[doc = "<\\brief Pointer to data buffer used for control requests."]
	pub data_buf: *mut core::ffi::c_void,
	#[doc = "<\\brief Pointer to current data for control request."]
	pub data_ptr: *mut core::ffi::c_void,
	#[doc = "<\\brief Count remained data for control request."]
	pub data_count: u16,
	#[doc = "<\\brief Size of the data buffer for control requests."]
	pub data_maxsize: u16,
	#[doc = "<\\brief Size of the control endpoint."]
	pub ep0size: u8,
	#[doc = "<\\brief Current device configuration number."]
	pub device_cfg: u8,
	#[doc = "<\\brief Current \\ref usbd_machine_state."]
	pub device_state: u8,
	#[doc = "<\\brief Current \\ref usbd_ctl_state."]
	pub control_state: u8,
}
#[test]
fn bindgen_test_layout_usbd_status() {
	assert_eq!(
	           ::core::mem::size_of::<usbd_status>(),
	           16usize,
	           concat!("Size of: ", stringify!(usbd_status))
	);
	assert_eq!(
	           ::core::mem::align_of::<usbd_status>(),
	           4usize,
	           concat!("Alignment of ", stringify!(usbd_status))
	);
	fn test_field_data_buf() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<usbd_status>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).data_buf) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(usbd_status), "::", stringify!(data_buf))
		);
	}
	test_field_data_buf();
	fn test_field_data_ptr() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<usbd_status>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).data_ptr) as usize - ptr as usize
		           },
		           4usize,
		           concat!("Offset of field: ", stringify!(usbd_status), "::", stringify!(data_ptr))
		);
	}
	test_field_data_ptr();
	fn test_field_data_count() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<usbd_status>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).data_count) as usize - ptr as usize
		           },
		           8usize,
		           concat!("Offset of field: ", stringify!(usbd_status), "::", stringify!(data_count))
		);
	}
	test_field_data_count();
	fn test_field_data_maxsize() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<usbd_status>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).data_maxsize) as usize - ptr as usize
		           },
		           10usize,
		           concat!("Offset of field: ", stringify!(usbd_status), "::", stringify!(data_maxsize))
		);
	}
	test_field_data_maxsize();
	fn test_field_ep0size() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<usbd_status>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).ep0size) as usize - ptr as usize
		           },
		           12usize,
		           concat!("Offset of field: ", stringify!(usbd_status), "::", stringify!(ep0size))
		);
	}
	test_field_ep0size();
	fn test_field_device_cfg() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<usbd_status>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).device_cfg) as usize - ptr as usize
		           },
		           13usize,
		           concat!("Offset of field: ", stringify!(usbd_status), "::", stringify!(device_cfg))
		);
	}
	test_field_device_cfg();
	fn test_field_device_state() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<usbd_status>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).device_state) as usize - ptr as usize
		           },
		           14usize,
		           concat!("Offset of field: ", stringify!(usbd_status), "::", stringify!(device_state))
		);
	}
	test_field_device_state();
	fn test_field_control_state() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<usbd_status>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).control_state) as usize - ptr as usize
		           },
		           15usize,
		           concat!("Offset of field: ", stringify!(usbd_status), "::", stringify!(control_state))
		);
	}
	test_field_control_state();
}
#[doc = "\\brief Generic USB device event callback for events and endpoints processing"]
#[doc = " \\param[in] dev pointer to USB device"]
#[doc = " \\param event \\ref USB_EVENTS \"USB event\""]
#[doc = " \\param ep active endpoint number"]
#[doc = " \\note endpoints with same indexes i.e. 0x01 and 0x81 shares same callback."]
pub type usbd_evt_callback = ::core::option::Option<unsafe extern "C" fn(dev: *mut usbd_device, event: u8, ep: u8)>;
#[doc = "\\brief USB control transfer completed callback function."]
#[doc = " \\param[in] dev pointer to USB device"]
#[doc = " \\param[in] req pointer to usb request structure"]
#[doc = " \\note usbd_device->complete_callback will be set to NULL after this callback completion."]
pub type usbd_rqc_callback = ::core::option::Option<unsafe extern "C" fn(dev: *mut usbd_device, req: *mut usbd_ctlreq)>;
#[doc = "\\brief USB control callback function."]
#[doc = " \\details Uses for the control request processing."]
#[doc = "          Some requests will be handled by core if callback don't process it (returns FALSE)."]
#[doc = "            If request was not processed STALL PID will be issued."]
#[doc = "          - GET_CONFIGURATION"]
#[doc = "          - SET_CONFIGURATION (passes to \\ref usbd_cfg_callback)"]
#[doc = "          - GET_DESCRIPTOR (passes to \\ref usbd_dsc_callback)"]
#[doc = "          - GET_STATUS"]
#[doc = "          - SET_FEATURE, CLEAR_FEATURE (endpoints only)"]
#[doc = "          - SET_ADDRESS"]
#[doc = " \\param[in] dev points to USB device"]
#[doc = " \\param[in] req points to usb control request"]
#[doc = " \\param[out] *callback USB control transfer completion callback, default is NULL (no callback)"]
#[doc = " \\return usbd_respond status."]
pub type usbd_ctl_callback = ::core::option::Option<unsafe extern "C" fn(dev: *mut usbd_device,
                                                                         req: *mut usbd_ctlreq,
                                                                         callback: *mut usbd_rqc_callback)
                                                                         -> usbd_respond>;
#[doc = "\\brief USB get descriptor callback function"]
#[doc = " \\details Called when GET_DESCRIPTOR request issued"]
#[doc = " \\param[in] req pointer to usb control request structure"]
#[doc = " \\param[in,out] address pointer to the descriptor in memory. Points to req->data by default. You"]
#[doc = " can use this buffer."]
#[doc = " \\param[in,out] dsize descriptor size. maximum buffer size by default."]
#[doc = " \\return usbd_ack if you passed the correct descriptor, usbd_fail otherwise."]
pub type usbd_dsc_callback = ::core::option::Option<unsafe extern "C" fn(req: *mut usbd_ctlreq,
                                                                         address: *mut *mut core::ffi::c_void,
                                                                         dsize: *mut u16)
                                                                         -> usbd_respond>;
#[doc = "\\brief USB set configuration callback function"]
#[doc = " \\details called when SET_CONFIGURATION request issued"]
#[doc = " \\param[in] dev pointer to USB device"]
#[doc = " \\param[in] cfg configuration number."]
#[doc = " \\note if config is 0 device endpoints should be de-configured"]
#[doc = " \\return TRUE if success"]
pub type usbd_cfg_callback = ::core::option::Option<unsafe extern "C" fn(dev: *mut usbd_device, cfg: u8) -> usbd_respond>;
#[doc = "\\addtogroup USBD_HW"]
#[doc = " @{ */"]
#[doc = " \\return Hardware status and capabilities \\ref USBD_HW_CAPS"]
pub type usbd_hw_getinfo = ::core::option::Option<unsafe extern "C" fn() -> u32>;
#[doc = "\\brief Enables or disables USB hardware"]
#[doc = " \\param enable Enables USB when TRUE disables otherwise."]
pub type usbd_hw_enable = ::core::option::Option<unsafe extern "C" fn(enable: bool)>;
#[doc = " Connects or disconnects USB hardware to/from usb host"]
#[doc = " \\param connect Connects USB to host if TRUE, disconnects otherwise"]
#[doc = " \\return lanes connection status."]
pub type usbd_hw_connect = ::core::option::Option<unsafe extern "C" fn(connect: bool) -> u8>;
#[doc = "\\brief Sets USB hardware address"]
#[doc = " \\param address USB address"]
pub type usbd_hw_setaddr = ::core::option::Option<unsafe extern "C" fn(address: u8)>;
#[doc = "\\brief Configures endpoint"]
#[doc = " \\param ep endpoint address. Use USB_EPDIR_ macros to set endpoint direction"]
#[doc = " \\param eptype endpoint type. Use USB_EPTYPE_* macros."]
#[doc = " \\param epsize endpoint size in bytes"]
#[doc = " \\return TRUE if success"]
pub type usbd_hw_ep_config = ::core::option::Option<unsafe extern "C" fn(ep: u8, eptype: u8, epsize: u16) -> bool>;
#[doc = "\\brief De-configures, cleans and disables endpoint"]
#[doc = " \\param ep endpoint index"]
#[doc = " \\note if you have two one-direction single-buffered endpoints with same index (i.e. 0x02 and 0x82)"]
#[doc = " both will be deconfigured."]
pub type usbd_hw_ep_deconfig = ::core::option::Option<unsafe extern "C" fn(ep: u8)>;
#[doc = "\\brief Reads data from OUT or control endpoint"]
#[doc = " \\param ep endpoint index, should belong to OUT or CONTROL endpoint."]
#[doc = " \\param buf pointer to read buffer"]
#[doc = " \\param blen size of the read buffer in bytes"]
#[doc = " \\return size of the actually received data, -1 on error."]
#[doc = " \\note if data does not fit buffer it will be truncated"]
pub type usbd_hw_ep_read = ::core::option::Option<unsafe extern "C" fn(ep: u8, buf: *mut core::ffi::c_void, blen: u16) -> i32>;
#[doc = "\\brief Writes data to IN or control endpoint"]
#[doc = " \\param ep endpoint index, hould belong to IN or CONTROL endpoint"]
#[doc = " \\param buf pointer to data buffer"]
#[doc = " \\param blen size of data will be written"]
#[doc = " \\return number of written bytes"]
pub type usbd_hw_ep_write = ::core::option::Option<unsafe extern "C" fn(ep: u8, buf: *mut core::ffi::c_void, blen: u16) -> i32>;
#[doc = " Stalls and unstalls endpoint"]
#[doc = " \\param ep endpoint address"]
#[doc = " \\param stall endpoint will be stalled if TRUE and unstalled otherwise."]
#[doc = " \\note Has no effect on inactive endpoints."]
pub type usbd_hw_ep_setstall = ::core::option::Option<unsafe extern "C" fn(ep: u8, stall: bool)>;
#[doc = "\\brief Checks endpoint for stalled state"]
#[doc = " \\param ep endpoint address"]
#[doc = " \\return TRUE if endpoint is stalled"]
pub type usbd_hw_ep_isstalled = ::core::option::Option<unsafe extern "C" fn(ep: u8) -> bool>;
#[doc = "\\brief Polls USB hardware for the events"]
#[doc = " \\param[in] dev pointer to usb device structure"]
#[doc = " \\param callback callback to event processing subroutine"]
pub type usbd_hw_poll = ::core::option::Option<unsafe extern "C" fn(dev: *mut usbd_device, callback: usbd_evt_callback)>;
#[doc = "\\brief Gets frame number from usb hardware."]
pub type usbd_hw_get_frameno = ::core::option::Option<unsafe extern "C" fn() -> u16>;
#[doc = "\\brief Makes a string descriptor contains unique serial number from hardware ID's"]
#[doc = " \\param[in] buffer pointer to buffer for the descriptor"]
#[doc = " \\return of the descriptor in bytes"]
pub type usbd_hw_get_serialno = ::core::option::Option<unsafe extern "C" fn(buffer: *mut core::ffi::c_void) -> u16>;
#[doc = "\\brief Represents a hardware USB driver call table."]
#[repr(C)]
pub struct usbd_driver {
	#[doc = "<\\copybrief usbd_hw_getinfo"]
	pub getinfo: usbd_hw_getinfo,
	#[doc = "<\\copybrief usbd_hw_enable"]
	pub enable: usbd_hw_enable,
	#[doc = "<\\copybrief usbd_hw_connect"]
	pub connect: usbd_hw_connect,
	#[doc = "<\\copybrief usbd_hw_setaddr"]
	pub setaddr: usbd_hw_setaddr,
	#[doc = "<\\copybrief usbd_hw_ep_config"]
	pub ep_config: usbd_hw_ep_config,
	#[doc = "<\\copybrief usbd_hw_ep_deconfig"]
	pub ep_deconfig: usbd_hw_ep_deconfig,
	#[doc = "<\\copybrief usbd_hw_ep_read"]
	pub ep_read: usbd_hw_ep_read,
	#[doc = "<\\copybrief usbd_hw_ep_write"]
	pub ep_write: usbd_hw_ep_write,
	#[doc = "<\\copybrief usbd_hw_ep_setstall"]
	pub ep_setstall: usbd_hw_ep_setstall,
	#[doc = "<\\copybrief usbd_hw_ep_isstalled"]
	pub ep_isstalled: usbd_hw_ep_isstalled,
	#[doc = "<\\copybrief usbd_hw_poll"]
	pub poll: usbd_hw_poll,
	#[doc = "<\\copybrief usbd_hw_get_frameno"]
	pub frame_no: usbd_hw_get_frameno,
	#[doc = "<\\copybrief usbd_hw_get_serialno"]
	pub get_serialno_desc: usbd_hw_get_serialno,
}
#[test]
fn bindgen_test_layout_usbd_driver() {
	assert_eq!(
	           ::core::mem::size_of::<usbd_driver>(),
	           52usize,
	           concat!("Size of: ", stringify!(usbd_driver))
	);
	assert_eq!(
	           ::core::mem::align_of::<usbd_driver>(),
	           4usize,
	           concat!("Alignment of ", stringify!(usbd_driver))
	);
	fn test_field_getinfo() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<usbd_driver>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).getinfo) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(usbd_driver), "::", stringify!(getinfo))
		);
	}
	test_field_getinfo();
	fn test_field_enable() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<usbd_driver>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).enable) as usize - ptr as usize
		           },
		           4usize,
		           concat!("Offset of field: ", stringify!(usbd_driver), "::", stringify!(enable))
		);
	}
	test_field_enable();
	fn test_field_connect() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<usbd_driver>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).connect) as usize - ptr as usize
		           },
		           8usize,
		           concat!("Offset of field: ", stringify!(usbd_driver), "::", stringify!(connect))
		);
	}
	test_field_connect();
	fn test_field_setaddr() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<usbd_driver>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).setaddr) as usize - ptr as usize
		           },
		           12usize,
		           concat!("Offset of field: ", stringify!(usbd_driver), "::", stringify!(setaddr))
		);
	}
	test_field_setaddr();
	fn test_field_ep_config() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<usbd_driver>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).ep_config) as usize - ptr as usize
		           },
		           16usize,
		           concat!("Offset of field: ", stringify!(usbd_driver), "::", stringify!(ep_config))
		);
	}
	test_field_ep_config();
	fn test_field_ep_deconfig() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<usbd_driver>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).ep_deconfig) as usize - ptr as usize
		           },
		           20usize,
		           concat!("Offset of field: ", stringify!(usbd_driver), "::", stringify!(ep_deconfig))
		);
	}
	test_field_ep_deconfig();
	fn test_field_ep_read() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<usbd_driver>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).ep_read) as usize - ptr as usize
		           },
		           24usize,
		           concat!("Offset of field: ", stringify!(usbd_driver), "::", stringify!(ep_read))
		);
	}
	test_field_ep_read();
	fn test_field_ep_write() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<usbd_driver>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).ep_write) as usize - ptr as usize
		           },
		           28usize,
		           concat!("Offset of field: ", stringify!(usbd_driver), "::", stringify!(ep_write))
		);
	}
	test_field_ep_write();
	fn test_field_ep_setstall() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<usbd_driver>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).ep_setstall) as usize - ptr as usize
		           },
		           32usize,
		           concat!("Offset of field: ", stringify!(usbd_driver), "::", stringify!(ep_setstall))
		);
	}
	test_field_ep_setstall();
	fn test_field_ep_isstalled() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<usbd_driver>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).ep_isstalled) as usize - ptr as usize
		           },
		           36usize,
		           concat!("Offset of field: ", stringify!(usbd_driver), "::", stringify!(ep_isstalled))
		);
	}
	test_field_ep_isstalled();
	fn test_field_poll() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<usbd_driver>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).poll) as usize - ptr as usize
		           },
		           40usize,
		           concat!("Offset of field: ", stringify!(usbd_driver), "::", stringify!(poll))
		);
	}
	test_field_poll();
	fn test_field_frame_no() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<usbd_driver>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).frame_no) as usize - ptr as usize
		           },
		           44usize,
		           concat!("Offset of field: ", stringify!(usbd_driver), "::", stringify!(frame_no))
		);
	}
	test_field_frame_no();
	fn test_field_get_serialno_desc() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<usbd_driver>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).get_serialno_desc) as usize - ptr as usize
		           },
		           48usize,
		           concat!(
			"Offset of field: ",
			stringify!(usbd_driver),
			"::",
			stringify!(get_serialno_desc)
		)
		);
	}
	test_field_get_serialno_desc();
}
#[doc = "\\brief Represents a USB device data."]
#[repr(C)]
pub struct _usbd_device {
	#[doc = "<\\copybrief usbd_driver"]
	pub driver: *const usbd_driver,
	#[doc = "<\\copybrief usbd_ctl_callback"]
	pub control_callback: usbd_ctl_callback,
	#[doc = "<\\copybrief usbd_rqc_callback"]
	pub complete_callback: usbd_rqc_callback,
	#[doc = "<\\copybrief usbd_cfg_callback"]
	pub config_callback: usbd_cfg_callback,
	#[doc = "<\\copybrief usbd_dsc_callback"]
	pub descriptor_callback: usbd_dsc_callback,
	#[doc = "<\\brief array of the event callbacks."]
	pub events: [usbd_evt_callback; 8usize],
	#[doc = "<\\brief array of the endpoint callbacks."]
	pub endpoint: [usbd_evt_callback; 8usize],
	#[doc = "<\\copybrief usbd_status"]
	pub status: usbd_status,
}
#[test]
fn bindgen_test_layout__usbd_device() {
	assert_eq!(
	           ::core::mem::size_of::<_usbd_device>(),
	           100usize,
	           concat!("Size of: ", stringify!(_usbd_device))
	);
	assert_eq!(
	           ::core::mem::align_of::<_usbd_device>(),
	           4usize,
	           concat!("Alignment of ", stringify!(_usbd_device))
	);
	fn test_field_driver() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<_usbd_device>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).driver) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(_usbd_device), "::", stringify!(driver))
		);
	}
	test_field_driver();
	fn test_field_control_callback() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<_usbd_device>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).control_callback) as usize - ptr as usize
		           },
		           4usize,
		           concat!(
			"Offset of field: ",
			stringify!(_usbd_device),
			"::",
			stringify!(control_callback)
		)
		);
	}
	test_field_control_callback();
	fn test_field_complete_callback() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<_usbd_device>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).complete_callback) as usize - ptr as usize
		           },
		           8usize,
		           concat!(
			"Offset of field: ",
			stringify!(_usbd_device),
			"::",
			stringify!(complete_callback)
		)
		);
	}
	test_field_complete_callback();
	fn test_field_config_callback() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<_usbd_device>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).config_callback) as usize - ptr as usize
		           },
		           12usize,
		           concat!(
			"Offset of field: ",
			stringify!(_usbd_device),
			"::",
			stringify!(config_callback)
		)
		);
	}
	test_field_config_callback();
	fn test_field_descriptor_callback() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<_usbd_device>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).descriptor_callback) as usize - ptr as usize
		           },
		           16usize,
		           concat!(
			"Offset of field: ",
			stringify!(_usbd_device),
			"::",
			stringify!(descriptor_callback)
		)
		);
	}
	test_field_descriptor_callback();
	fn test_field_events() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<_usbd_device>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).events) as usize - ptr as usize
		           },
		           20usize,
		           concat!("Offset of field: ", stringify!(_usbd_device), "::", stringify!(events))
		);
	}
	test_field_events();
	fn test_field_endpoint() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<_usbd_device>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).endpoint) as usize - ptr as usize
		           },
		           52usize,
		           concat!("Offset of field: ", stringify!(_usbd_device), "::", stringify!(endpoint))
		);
	}
	test_field_endpoint();
	fn test_field_status() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<_usbd_device>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).status) as usize - ptr as usize
		           },
		           84usize,
		           concat!("Offset of field: ", stringify!(_usbd_device), "::", stringify!(status))
		);
	}
	test_field_status();
}
extern "C" {
	#[doc = "\\brief Polls USB for events"]
	#[doc = " \\param dev Pointer to device structure"]
	#[doc = " \\note can be called as from main routine as from USB interrupt"]
	pub fn usbd_poll(dev: *mut usbd_device);
}
#[doc = "\\brief common USB descriptor header"]
#[repr(C, packed)]
pub struct usb_header_descriptor {
	#[doc = "<\\brief Size of the descriptor, in bytes."]
	pub bLength: u8,
	#[doc = "<\\brief Type of the descriptor."]
	pub bDescriptorType: u8,
}
#[test]
fn bindgen_test_layout_usb_header_descriptor() {
	assert_eq!(
	           ::core::mem::size_of::<usb_header_descriptor>(),
	           2usize,
	           concat!("Size of: ", stringify!(usb_header_descriptor))
	);
	assert_eq!(
	           ::core::mem::align_of::<usb_header_descriptor>(),
	           1usize,
	           concat!("Alignment of ", stringify!(usb_header_descriptor))
	);
	fn test_field_bLength() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<usb_header_descriptor>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).bLength) as usize - ptr as usize
		           },
		           0usize,
		           concat!(
			"Offset of field: ",
			stringify!(usb_header_descriptor),
			"::",
			stringify!(bLength)
		)
		);
	}
	test_field_bLength();
	fn test_field_bDescriptorType() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<usb_header_descriptor>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).bDescriptorType) as usize - ptr as usize
		           },
		           1usize,
		           concat!(
			"Offset of field: ",
			stringify!(usb_header_descriptor),
			"::",
			stringify!(bDescriptorType)
		)
		);
	}
	test_field_bDescriptorType();
}
#[doc = "\\brief Represents a USB device descriptor"]
#[doc = " \\details A device descriptor describes general information about a USB device. It includes"]
#[doc = " information that applies globally to the device and all of the device’s configurations. A USB"]
#[doc = " device has only one device descriptor. A high-speed capable device that has different device"]
#[doc = " information for full-speed and high-speed must also  have a \\ref usb_qualifier_descriptor."]
#[repr(C, packed)]
pub struct usb_device_descriptor {
	#[doc = "<\\brief Size of the descriptor, in bytes."]
	pub bLength: u8,
	#[doc = "<\\brief \\ref USB_DTYPE_DEVICE Device descriptor."]
	pub bDescriptorType: u8,
	#[doc = "<\\brief BCD of the supported USB specification."]
	pub bcdUSB: u16,
	#[doc = "<\\brief USB device class."]
	pub bDeviceClass: u8,
	#[doc = "<\\brief USB device subclass."]
	pub bDeviceSubClass: u8,
	#[doc = "<\\brief USB device protocol."]
	pub bDeviceProtocol: u8,
	#[doc = "<\\brief Size of the control endpoint's bank in bytes."]
	pub bMaxPacketSize0: u8,
	#[doc = "<\\brief Vendor ID for the USB product."]
	pub idVendor: u16,
	#[doc = "<\\brief Unique product ID for the USB product."]
	pub idProduct: u16,
	#[doc = "<\\brief Product release (version) number."]
	pub bcdDevice: u16,
	#[doc = "<\\brief String index for the manufacturer's name."]
	pub iManufacturer: u8,
	#[doc = "<\\brief String index for the product name/details."]
	pub iProduct: u8,
	#[doc = "<\\brief String index for the product serial number."]
	pub iSerialNumber: u8,
	#[doc = "<\\brief Total number of configurations supported by the device."]
	pub bNumConfigurations: u8,
}
#[test]
fn bindgen_test_layout_usb_device_descriptor() {
	assert_eq!(
	           ::core::mem::size_of::<usb_device_descriptor>(),
	           18usize,
	           concat!("Size of: ", stringify!(usb_device_descriptor))
	);
	assert_eq!(
	           ::core::mem::align_of::<usb_device_descriptor>(),
	           1usize,
	           concat!("Alignment of ", stringify!(usb_device_descriptor))
	);
	fn test_field_bLength() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<usb_device_descriptor>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).bLength) as usize - ptr as usize
		           },
		           0usize,
		           concat!(
			"Offset of field: ",
			stringify!(usb_device_descriptor),
			"::",
			stringify!(bLength)
		)
		);
	}
	test_field_bLength();
	fn test_field_bDescriptorType() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<usb_device_descriptor>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).bDescriptorType) as usize - ptr as usize
		           },
		           1usize,
		           concat!(
			"Offset of field: ",
			stringify!(usb_device_descriptor),
			"::",
			stringify!(bDescriptorType)
		)
		);
	}
	test_field_bDescriptorType();
	fn test_field_bcdUSB() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<usb_device_descriptor>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).bcdUSB) as usize - ptr as usize
		           },
		           2usize,
		           concat!(
			"Offset of field: ",
			stringify!(usb_device_descriptor),
			"::",
			stringify!(bcdUSB)
		)
		);
	}
	test_field_bcdUSB();
	fn test_field_bDeviceClass() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<usb_device_descriptor>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).bDeviceClass) as usize - ptr as usize
		           },
		           4usize,
		           concat!(
			"Offset of field: ",
			stringify!(usb_device_descriptor),
			"::",
			stringify!(bDeviceClass)
		)
		);
	}
	test_field_bDeviceClass();
	fn test_field_bDeviceSubClass() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<usb_device_descriptor>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).bDeviceSubClass) as usize - ptr as usize
		           },
		           5usize,
		           concat!(
			"Offset of field: ",
			stringify!(usb_device_descriptor),
			"::",
			stringify!(bDeviceSubClass)
		)
		);
	}
	test_field_bDeviceSubClass();
	fn test_field_bDeviceProtocol() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<usb_device_descriptor>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).bDeviceProtocol) as usize - ptr as usize
		           },
		           6usize,
		           concat!(
			"Offset of field: ",
			stringify!(usb_device_descriptor),
			"::",
			stringify!(bDeviceProtocol)
		)
		);
	}
	test_field_bDeviceProtocol();
	fn test_field_bMaxPacketSize0() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<usb_device_descriptor>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).bMaxPacketSize0) as usize - ptr as usize
		           },
		           7usize,
		           concat!(
			"Offset of field: ",
			stringify!(usb_device_descriptor),
			"::",
			stringify!(bMaxPacketSize0)
		)
		);
	}
	test_field_bMaxPacketSize0();
	fn test_field_idVendor() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<usb_device_descriptor>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).idVendor) as usize - ptr as usize
		           },
		           8usize,
		           concat!(
			"Offset of field: ",
			stringify!(usb_device_descriptor),
			"::",
			stringify!(idVendor)
		)
		);
	}
	test_field_idVendor();
	fn test_field_idProduct() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<usb_device_descriptor>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).idProduct) as usize - ptr as usize
		           },
		           10usize,
		           concat!(
			"Offset of field: ",
			stringify!(usb_device_descriptor),
			"::",
			stringify!(idProduct)
		)
		);
	}
	test_field_idProduct();
	fn test_field_bcdDevice() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<usb_device_descriptor>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).bcdDevice) as usize - ptr as usize
		           },
		           12usize,
		           concat!(
			"Offset of field: ",
			stringify!(usb_device_descriptor),
			"::",
			stringify!(bcdDevice)
		)
		);
	}
	test_field_bcdDevice();
	fn test_field_iManufacturer() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<usb_device_descriptor>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).iManufacturer) as usize - ptr as usize
		           },
		           14usize,
		           concat!(
			"Offset of field: ",
			stringify!(usb_device_descriptor),
			"::",
			stringify!(iManufacturer)
		)
		);
	}
	test_field_iManufacturer();
	fn test_field_iProduct() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<usb_device_descriptor>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).iProduct) as usize - ptr as usize
		           },
		           15usize,
		           concat!(
			"Offset of field: ",
			stringify!(usb_device_descriptor),
			"::",
			stringify!(iProduct)
		)
		);
	}
	test_field_iProduct();
	fn test_field_iSerialNumber() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<usb_device_descriptor>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).iSerialNumber) as usize - ptr as usize
		           },
		           16usize,
		           concat!(
			"Offset of field: ",
			stringify!(usb_device_descriptor),
			"::",
			stringify!(iSerialNumber)
		)
		);
	}
	test_field_iSerialNumber();
	fn test_field_bNumConfigurations() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<usb_device_descriptor>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).bNumConfigurations) as usize - ptr as usize
		           },
		           17usize,
		           concat!(
			"Offset of field: ",
			stringify!(usb_device_descriptor),
			"::",
			stringify!(bNumConfigurations)
		)
		);
	}
	test_field_bNumConfigurations();
}
#[doc = "\\brief USB device qualifier descriptor"]
#[doc = " \\details The device_qualifier descriptor describes information about a high-speed capable device"]
#[doc = " that would change if the device were operating at the other speed. For example, if the device is"]
#[doc = " currently operating at full-speed, the device qualifier returns information about how it would"]
#[doc = " operate at high-speed and vice-versa."]
#[repr(C, packed)]
pub struct usb_qualifier_descriptor {
	#[doc = "<\\brief Size of the descriptor, in bytes."]
	pub bLength: u8,
	#[doc = "<\\brief Qualifier descriptor."]
	pub bDescriptorType: u8,
	#[doc = "<\\brief BCD of the supported USB specification."]
	pub bcdUSB: u16,
	#[doc = "<\\brief USB device class."]
	pub bDeviceClass: u8,
	#[doc = "<\\brief USB device subclass."]
	pub bDeviceSubClass: u8,
	#[doc = "<\\brief USB device protocol."]
	pub bDeviceProtocol: u8,
	#[doc = "<\\brief Size of the control endpoint's bank in bytes."]
	pub bMaxPacketSize0: u8,
	#[doc = "<\\brief Total number of configurations supported by the device."]
	pub bNumConfigurations: u8,
	#[doc = "<\\brief Reserved for future use, must be 0."]
	pub bReserved: u8,
}
#[test]
fn bindgen_test_layout_usb_qualifier_descriptor() {
	assert_eq!(
	           ::core::mem::size_of::<usb_qualifier_descriptor>(),
	           10usize,
	           concat!("Size of: ", stringify!(usb_qualifier_descriptor))
	);
	assert_eq!(
	           ::core::mem::align_of::<usb_qualifier_descriptor>(),
	           1usize,
	           concat!("Alignment of ", stringify!(usb_qualifier_descriptor))
	);
	fn test_field_bLength() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<usb_qualifier_descriptor>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).bLength) as usize - ptr as usize
		           },
		           0usize,
		           concat!(
			"Offset of field: ",
			stringify!(usb_qualifier_descriptor),
			"::",
			stringify!(bLength)
		)
		);
	}
	test_field_bLength();
	fn test_field_bDescriptorType() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<usb_qualifier_descriptor>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).bDescriptorType) as usize - ptr as usize
		           },
		           1usize,
		           concat!(
			"Offset of field: ",
			stringify!(usb_qualifier_descriptor),
			"::",
			stringify!(bDescriptorType)
		)
		);
	}
	test_field_bDescriptorType();
	fn test_field_bcdUSB() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<usb_qualifier_descriptor>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).bcdUSB) as usize - ptr as usize
		           },
		           2usize,
		           concat!(
			"Offset of field: ",
			stringify!(usb_qualifier_descriptor),
			"::",
			stringify!(bcdUSB)
		)
		);
	}
	test_field_bcdUSB();
	fn test_field_bDeviceClass() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<usb_qualifier_descriptor>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).bDeviceClass) as usize - ptr as usize
		           },
		           4usize,
		           concat!(
			"Offset of field: ",
			stringify!(usb_qualifier_descriptor),
			"::",
			stringify!(bDeviceClass)
		)
		);
	}
	test_field_bDeviceClass();
	fn test_field_bDeviceSubClass() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<usb_qualifier_descriptor>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).bDeviceSubClass) as usize - ptr as usize
		           },
		           5usize,
		           concat!(
			"Offset of field: ",
			stringify!(usb_qualifier_descriptor),
			"::",
			stringify!(bDeviceSubClass)
		)
		);
	}
	test_field_bDeviceSubClass();
	fn test_field_bDeviceProtocol() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<usb_qualifier_descriptor>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).bDeviceProtocol) as usize - ptr as usize
		           },
		           6usize,
		           concat!(
			"Offset of field: ",
			stringify!(usb_qualifier_descriptor),
			"::",
			stringify!(bDeviceProtocol)
		)
		);
	}
	test_field_bDeviceProtocol();
	fn test_field_bMaxPacketSize0() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<usb_qualifier_descriptor>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).bMaxPacketSize0) as usize - ptr as usize
		           },
		           7usize,
		           concat!(
			"Offset of field: ",
			stringify!(usb_qualifier_descriptor),
			"::",
			stringify!(bMaxPacketSize0)
		)
		);
	}
	test_field_bMaxPacketSize0();
	fn test_field_bNumConfigurations() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<usb_qualifier_descriptor>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).bNumConfigurations) as usize - ptr as usize
		           },
		           8usize,
		           concat!(
			"Offset of field: ",
			stringify!(usb_qualifier_descriptor),
			"::",
			stringify!(bNumConfigurations)
		)
		);
	}
	test_field_bNumConfigurations();
	fn test_field_bReserved() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<usb_qualifier_descriptor>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).bReserved) as usize - ptr as usize
		           },
		           9usize,
		           concat!(
			"Offset of field: ",
			stringify!(usb_qualifier_descriptor),
			"::",
			stringify!(bReserved)
		)
		);
	}
	test_field_bReserved();
}
#[doc = "\\brief USB device configuration descriptor"]
#[doc = " \\details The configuration descriptor describes information about a specific device configuration."]
#[doc = " The descriptor contains a bConfigurationValue field with a value that, when used as a parameter"]
#[doc = " to the SetConfiguration() request, causes the device to assume the described configuration."]
#[repr(C, packed)]
pub struct usb_config_descriptor {
	#[doc = "<\\brief Size of the descriptor, in bytes."]
	pub bLength: u8,
	#[doc = "<\\brief Configuration descriptor."]
	pub bDescriptorType: u8,
	#[doc = "<\\brief Size of the configuration descriptor header, and all"]
	#[doc = " sub descriptors inside the configuration."]
	pub wTotalLength: u16,
	#[doc = "<\\brief Total number of interfaces in the configuration."]
	pub bNumInterfaces: u8,
	#[doc = "<\\brief Configuration index of the current configuration."]
	pub bConfigurationValue: u8,
	#[doc = "<\\brief Index of a string descriptor describing the configuration."]
	pub iConfiguration: u8,
	#[doc = "<\\brief Configuration attributes."]
	#[doc = " \\details Comprised of a mask of \\c USB_CONFIG_ATTR_ masks. On"]
	#[doc = " all devices, this should include USB_CONFIG_ATTR_RESERVED at"]
	#[doc = " a minimum."]
	pub bmAttributes: u8,
	#[doc = "<\\brief Maximum power consumption of the device."]
	#[doc = " \\ref USB_CFG_POWER_MA() macro."]
	pub bMaxPower: u8,
}
#[test]
fn bindgen_test_layout_usb_config_descriptor() {
	assert_eq!(
	           ::core::mem::size_of::<usb_config_descriptor>(),
	           9usize,
	           concat!("Size of: ", stringify!(usb_config_descriptor))
	);
	assert_eq!(
	           ::core::mem::align_of::<usb_config_descriptor>(),
	           1usize,
	           concat!("Alignment of ", stringify!(usb_config_descriptor))
	);
	fn test_field_bLength() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<usb_config_descriptor>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).bLength) as usize - ptr as usize
		           },
		           0usize,
		           concat!(
			"Offset of field: ",
			stringify!(usb_config_descriptor),
			"::",
			stringify!(bLength)
		)
		);
	}
	test_field_bLength();
	fn test_field_bDescriptorType() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<usb_config_descriptor>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).bDescriptorType) as usize - ptr as usize
		           },
		           1usize,
		           concat!(
			"Offset of field: ",
			stringify!(usb_config_descriptor),
			"::",
			stringify!(bDescriptorType)
		)
		);
	}
	test_field_bDescriptorType();
	fn test_field_wTotalLength() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<usb_config_descriptor>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).wTotalLength) as usize - ptr as usize
		           },
		           2usize,
		           concat!(
			"Offset of field: ",
			stringify!(usb_config_descriptor),
			"::",
			stringify!(wTotalLength)
		)
		);
	}
	test_field_wTotalLength();
	fn test_field_bNumInterfaces() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<usb_config_descriptor>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).bNumInterfaces) as usize - ptr as usize
		           },
		           4usize,
		           concat!(
			"Offset of field: ",
			stringify!(usb_config_descriptor),
			"::",
			stringify!(bNumInterfaces)
		)
		);
	}
	test_field_bNumInterfaces();
	fn test_field_bConfigurationValue() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<usb_config_descriptor>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).bConfigurationValue) as usize - ptr as usize
		           },
		           5usize,
		           concat!(
			"Offset of field: ",
			stringify!(usb_config_descriptor),
			"::",
			stringify!(bConfigurationValue)
		)
		);
	}
	test_field_bConfigurationValue();
	fn test_field_iConfiguration() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<usb_config_descriptor>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).iConfiguration) as usize - ptr as usize
		           },
		           6usize,
		           concat!(
			"Offset of field: ",
			stringify!(usb_config_descriptor),
			"::",
			stringify!(iConfiguration)
		)
		);
	}
	test_field_iConfiguration();
	fn test_field_bmAttributes() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<usb_config_descriptor>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).bmAttributes) as usize - ptr as usize
		           },
		           7usize,
		           concat!(
			"Offset of field: ",
			stringify!(usb_config_descriptor),
			"::",
			stringify!(bmAttributes)
		)
		);
	}
	test_field_bmAttributes();
	fn test_field_bMaxPower() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<usb_config_descriptor>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).bMaxPower) as usize - ptr as usize
		           },
		           8usize,
		           concat!(
			"Offset of field: ",
			stringify!(usb_config_descriptor),
			"::",
			stringify!(bMaxPower)
		)
		);
	}
	test_field_bMaxPower();
}
#[doc = "\\brief USB interface descriptor"]
#[doc = " \\details The interface descriptor describes a specific interface within a configuration. A"]
#[doc = "configuration provides one or more interfaces, each with zero or more endpoint descriptors"]
#[doc = " describing a unique set of endpoints within the configuration."]
#[repr(C, packed)]
pub struct usb_interface_descriptor {
	#[doc = "<\\brief Size of the descriptor, in bytes."]
	pub bLength: u8,
	#[doc = "<\\brief Interface descriptor."]
	pub bDescriptorType: u8,
	#[doc = "<\\brief Index of the interface in the current configuration."]
	pub bInterfaceNumber: u8,
	#[doc = "<\\brief Alternate setting for the interface number."]
	pub bAlternateSetting: u8,
	#[doc = "<\\brief Total number of endpoints in the interface."]
	pub bNumEndpoints: u8,
	#[doc = "<\\brief Interface class ID."]
	pub bInterfaceClass: u8,
	#[doc = "<\\brief Interface subclass ID."]
	pub bInterfaceSubClass: u8,
	#[doc = "<\\brief Interface protocol ID."]
	pub bInterfaceProtocol: u8,
	#[doc = "<\\brief Index of the string descriptor describing the interface."]
	pub iInterface: u8,
}
#[test]
fn bindgen_test_layout_usb_interface_descriptor() {
	assert_eq!(
	           ::core::mem::size_of::<usb_interface_descriptor>(),
	           9usize,
	           concat!("Size of: ", stringify!(usb_interface_descriptor))
	);
	assert_eq!(
	           ::core::mem::align_of::<usb_interface_descriptor>(),
	           1usize,
	           concat!("Alignment of ", stringify!(usb_interface_descriptor))
	);
	fn test_field_bLength() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<usb_interface_descriptor>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).bLength) as usize - ptr as usize
		           },
		           0usize,
		           concat!(
			"Offset of field: ",
			stringify!(usb_interface_descriptor),
			"::",
			stringify!(bLength)
		)
		);
	}
	test_field_bLength();
	fn test_field_bDescriptorType() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<usb_interface_descriptor>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).bDescriptorType) as usize - ptr as usize
		           },
		           1usize,
		           concat!(
			"Offset of field: ",
			stringify!(usb_interface_descriptor),
			"::",
			stringify!(bDescriptorType)
		)
		);
	}
	test_field_bDescriptorType();
	fn test_field_bInterfaceNumber() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<usb_interface_descriptor>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).bInterfaceNumber) as usize - ptr as usize
		           },
		           2usize,
		           concat!(
			"Offset of field: ",
			stringify!(usb_interface_descriptor),
			"::",
			stringify!(bInterfaceNumber)
		)
		);
	}
	test_field_bInterfaceNumber();
	fn test_field_bAlternateSetting() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<usb_interface_descriptor>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).bAlternateSetting) as usize - ptr as usize
		           },
		           3usize,
		           concat!(
			"Offset of field: ",
			stringify!(usb_interface_descriptor),
			"::",
			stringify!(bAlternateSetting)
		)
		);
	}
	test_field_bAlternateSetting();
	fn test_field_bNumEndpoints() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<usb_interface_descriptor>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).bNumEndpoints) as usize - ptr as usize
		           },
		           4usize,
		           concat!(
			"Offset of field: ",
			stringify!(usb_interface_descriptor),
			"::",
			stringify!(bNumEndpoints)
		)
		);
	}
	test_field_bNumEndpoints();
	fn test_field_bInterfaceClass() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<usb_interface_descriptor>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).bInterfaceClass) as usize - ptr as usize
		           },
		           5usize,
		           concat!(
			"Offset of field: ",
			stringify!(usb_interface_descriptor),
			"::",
			stringify!(bInterfaceClass)
		)
		);
	}
	test_field_bInterfaceClass();
	fn test_field_bInterfaceSubClass() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<usb_interface_descriptor>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).bInterfaceSubClass) as usize - ptr as usize
		           },
		           6usize,
		           concat!(
			"Offset of field: ",
			stringify!(usb_interface_descriptor),
			"::",
			stringify!(bInterfaceSubClass)
		)
		);
	}
	test_field_bInterfaceSubClass();
	fn test_field_bInterfaceProtocol() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<usb_interface_descriptor>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).bInterfaceProtocol) as usize - ptr as usize
		           },
		           7usize,
		           concat!(
			"Offset of field: ",
			stringify!(usb_interface_descriptor),
			"::",
			stringify!(bInterfaceProtocol)
		)
		);
	}
	test_field_bInterfaceProtocol();
	fn test_field_iInterface() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<usb_interface_descriptor>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).iInterface) as usize - ptr as usize
		           },
		           8usize,
		           concat!(
			"Offset of field: ",
			stringify!(usb_interface_descriptor),
			"::",
			stringify!(iInterface)
		)
		);
	}
	test_field_iInterface();
}
#[doc = "\\brief USB interface association descriptor"]
#[doc = " \\details USB interface association descriptor (IAD) allows the device to group interfaces that"]
#[doc = " belong to a function."]
#[repr(C, packed)]
pub struct usb_iad_descriptor {
	#[doc = "<\\brief Size of the descriptor, in bytes."]
	pub bLength: u8,
	#[doc = "<\\brief IAD descriptor"]
	pub bDescriptorType: u8,
	#[doc = "<\\brief Index of the first associated interface."]
	pub bFirstInterface: u8,
	#[doc = "<\\brief Total number of associated interfaces."]
	pub bInterfaceCount: u8,
	#[doc = "<\\brief Function class ID."]
	pub bFunctionClass: u8,
	#[doc = "<\\brief Function subclass ID."]
	pub bFunctionSubClass: u8,
	#[doc = "<\\brief Function protocol ID."]
	pub bFunctionProtocol: u8,
	#[doc = "<\\brief Index of the string descriptor describing the"]
	#[doc = " interface association."]
	pub iFunction: u8,
}
#[test]
fn bindgen_test_layout_usb_iad_descriptor() {
	assert_eq!(
	           ::core::mem::size_of::<usb_iad_descriptor>(),
	           8usize,
	           concat!("Size of: ", stringify!(usb_iad_descriptor))
	);
	assert_eq!(
	           ::core::mem::align_of::<usb_iad_descriptor>(),
	           1usize,
	           concat!("Alignment of ", stringify!(usb_iad_descriptor))
	);
	fn test_field_bLength() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<usb_iad_descriptor>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).bLength) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(usb_iad_descriptor), "::", stringify!(bLength))
		);
	}
	test_field_bLength();
	fn test_field_bDescriptorType() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<usb_iad_descriptor>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).bDescriptorType) as usize - ptr as usize
		           },
		           1usize,
		           concat!(
			"Offset of field: ",
			stringify!(usb_iad_descriptor),
			"::",
			stringify!(bDescriptorType)
		)
		);
	}
	test_field_bDescriptorType();
	fn test_field_bFirstInterface() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<usb_iad_descriptor>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).bFirstInterface) as usize - ptr as usize
		           },
		           2usize,
		           concat!(
			"Offset of field: ",
			stringify!(usb_iad_descriptor),
			"::",
			stringify!(bFirstInterface)
		)
		);
	}
	test_field_bFirstInterface();
	fn test_field_bInterfaceCount() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<usb_iad_descriptor>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).bInterfaceCount) as usize - ptr as usize
		           },
		           3usize,
		           concat!(
			"Offset of field: ",
			stringify!(usb_iad_descriptor),
			"::",
			stringify!(bInterfaceCount)
		)
		);
	}
	test_field_bInterfaceCount();
	fn test_field_bFunctionClass() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<usb_iad_descriptor>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).bFunctionClass) as usize - ptr as usize
		           },
		           4usize,
		           concat!(
			"Offset of field: ",
			stringify!(usb_iad_descriptor),
			"::",
			stringify!(bFunctionClass)
		)
		);
	}
	test_field_bFunctionClass();
	fn test_field_bFunctionSubClass() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<usb_iad_descriptor>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).bFunctionSubClass) as usize - ptr as usize
		           },
		           5usize,
		           concat!(
			"Offset of field: ",
			stringify!(usb_iad_descriptor),
			"::",
			stringify!(bFunctionSubClass)
		)
		);
	}
	test_field_bFunctionSubClass();
	fn test_field_bFunctionProtocol() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<usb_iad_descriptor>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).bFunctionProtocol) as usize - ptr as usize
		           },
		           6usize,
		           concat!(
			"Offset of field: ",
			stringify!(usb_iad_descriptor),
			"::",
			stringify!(bFunctionProtocol)
		)
		);
	}
	test_field_bFunctionProtocol();
	fn test_field_iFunction() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<usb_iad_descriptor>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).iFunction) as usize - ptr as usize
		           },
		           7usize,
		           concat!(
			"Offset of field: ",
			stringify!(usb_iad_descriptor),
			"::",
			stringify!(iFunction)
		)
		);
	}
	test_field_iFunction();
}
#[doc = "\\brief USB endpoint descriptor"]
#[doc = " \\details This descriptor contains the information required by the host to determine the bandwidth"]
#[doc = " requirements of each endpoint."]
#[repr(C, packed)]
pub struct usb_endpoint_descriptor {
	#[doc = "<\\brief Size of the descriptor, in bytes."]
	pub bLength: u8,
	#[doc = "<\\brief Endpoint descriptor."]
	pub bDescriptorType: u8,
	#[doc = "<\\brief Logical address of the endpoint within the device for"]
	#[doc = " the current configuration, including direction mask."]
	pub bEndpointAddress: u8,
	#[doc = "<\\brief Endpoint attributes, \\ref USB_ENDPOINT_DEF."]
	pub bmAttributes: u8,
	#[doc = "<\\brief Size of the endpoint bank, in bytes. This indicates the"]
	#[doc = " maximum packet size that the endpoint can receive at a time."]
	pub wMaxPacketSize: u16,
	#[doc = "<\\brief Polling interval in milliseconds for the endpoint if"]
	#[doc = " it is an INTERRUPT or ISOCHRONOUS type."]
	pub bInterval: u8,
}
#[test]
fn bindgen_test_layout_usb_endpoint_descriptor() {
	assert_eq!(
	           ::core::mem::size_of::<usb_endpoint_descriptor>(),
	           7usize,
	           concat!("Size of: ", stringify!(usb_endpoint_descriptor))
	);
	assert_eq!(
	           ::core::mem::align_of::<usb_endpoint_descriptor>(),
	           1usize,
	           concat!("Alignment of ", stringify!(usb_endpoint_descriptor))
	);
	fn test_field_bLength() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<usb_endpoint_descriptor>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).bLength) as usize - ptr as usize
		           },
		           0usize,
		           concat!(
			"Offset of field: ",
			stringify!(usb_endpoint_descriptor),
			"::",
			stringify!(bLength)
		)
		);
	}
	test_field_bLength();
	fn test_field_bDescriptorType() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<usb_endpoint_descriptor>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).bDescriptorType) as usize - ptr as usize
		           },
		           1usize,
		           concat!(
			"Offset of field: ",
			stringify!(usb_endpoint_descriptor),
			"::",
			stringify!(bDescriptorType)
		)
		);
	}
	test_field_bDescriptorType();
	fn test_field_bEndpointAddress() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<usb_endpoint_descriptor>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).bEndpointAddress) as usize - ptr as usize
		           },
		           2usize,
		           concat!(
			"Offset of field: ",
			stringify!(usb_endpoint_descriptor),
			"::",
			stringify!(bEndpointAddress)
		)
		);
	}
	test_field_bEndpointAddress();
	fn test_field_bmAttributes() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<usb_endpoint_descriptor>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).bmAttributes) as usize - ptr as usize
		           },
		           3usize,
		           concat!(
			"Offset of field: ",
			stringify!(usb_endpoint_descriptor),
			"::",
			stringify!(bmAttributes)
		)
		);
	}
	test_field_bmAttributes();
	fn test_field_wMaxPacketSize() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<usb_endpoint_descriptor>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).wMaxPacketSize) as usize - ptr as usize
		           },
		           4usize,
		           concat!(
			"Offset of field: ",
			stringify!(usb_endpoint_descriptor),
			"::",
			stringify!(wMaxPacketSize)
		)
		);
	}
	test_field_wMaxPacketSize();
	fn test_field_bInterval() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<usb_endpoint_descriptor>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).bInterval) as usize - ptr as usize
		           },
		           6usize,
		           concat!(
			"Offset of field: ",
			stringify!(usb_endpoint_descriptor),
			"::",
			stringify!(bInterval)
		)
		);
	}
	test_field_bInterval();
}
#[doc = "\\brief USB string descriptor"]
#[doc = " \\details String descriptors are referenced by their one-based index number. A string descriptor"]
#[doc = " contains one or more not NULL-terminated Unicode strings."]
#[doc = " \\note String descriptors are optional. if a device does not support string descriptors, all"]
#[doc = " references to string descriptors within device, configuration, and interface descriptors must be"]
#[doc = " reset to zero."]
#[repr(C, packed(2))]
pub struct usb_string_descriptor {
	#[doc = "<\\brief Size of the descriptor, in bytes."]
	pub bLength: u8,
	#[doc = "<\\brief String descriptor type."]
	pub bDescriptorType: u8,
	#[doc = "<\\brief String data, as unicode characters or array of"]
	#[doc = " \\ref USB_STD_LANGID codes."]
	pub wString: __IncompleteArrayField<u16>,
}
#[test]
fn bindgen_test_layout_usb_string_descriptor() {
	assert_eq!(
	           ::core::mem::size_of::<usb_string_descriptor>(),
	           2usize,
	           concat!("Size of: ", stringify!(usb_string_descriptor))
	);
	assert_eq!(
	           ::core::mem::align_of::<usb_string_descriptor>(),
	           2usize,
	           concat!("Alignment of ", stringify!(usb_string_descriptor))
	);
	fn test_field_bLength() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<usb_string_descriptor>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).bLength) as usize - ptr as usize
		           },
		           0usize,
		           concat!(
			"Offset of field: ",
			stringify!(usb_string_descriptor),
			"::",
			stringify!(bLength)
		)
		);
	}
	test_field_bLength();
	fn test_field_bDescriptorType() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<usb_string_descriptor>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).bDescriptorType) as usize - ptr as usize
		           },
		           1usize,
		           concat!(
			"Offset of field: ",
			stringify!(usb_string_descriptor),
			"::",
			stringify!(bDescriptorType)
		)
		);
	}
	test_field_bDescriptorType();
	fn test_field_wString() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<usb_string_descriptor>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).wString) as usize - ptr as usize
		           },
		           2usize,
		           concat!(
			"Offset of field: ",
			stringify!(usb_string_descriptor),
			"::",
			stringify!(wString)
		)
		);
	}
	test_field_wString();
}
#[doc = "\\brief USB debug descriptor"]
#[doc = " \\details This descriptor is used to describe certain characteristics of the device that the host"]
#[doc = " debug port driver needs to know to communicate with the device. Specifically, the debug descriptor"]
#[doc = " lists the addresses of the endpoints that comprise the Debug Pipe. The endpoints are identified by"]
#[doc = " endpoint number."]
#[repr(C, packed)]
pub struct usb_debug_descriptor {
	#[doc = "<\\brief Size of the descriptor, in bytes."]
	pub bLength: u8,
	#[doc = "<\\brief Debug descriptor type."]
	pub bDescriptorType: u8,
	#[doc = "<\\brief Endpoint number of the Debug Data IN endpoint."]
	pub bDebugInEndpoint: u8,
	#[doc = "<\\brief Endpoint number of the Debug Data OUTendpoint."]
	pub bDebugOutEndpoint: u8,
}
#[test]
fn bindgen_test_layout_usb_debug_descriptor() {
	assert_eq!(
	           ::core::mem::size_of::<usb_debug_descriptor>(),
	           4usize,
	           concat!("Size of: ", stringify!(usb_debug_descriptor))
	);
	assert_eq!(
	           ::core::mem::align_of::<usb_debug_descriptor>(),
	           1usize,
	           concat!("Alignment of ", stringify!(usb_debug_descriptor))
	);
	fn test_field_bLength() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<usb_debug_descriptor>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).bLength) as usize - ptr as usize
		           },
		           0usize,
		           concat!(
			"Offset of field: ",
			stringify!(usb_debug_descriptor),
			"::",
			stringify!(bLength)
		)
		);
	}
	test_field_bLength();
	fn test_field_bDescriptorType() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<usb_debug_descriptor>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).bDescriptorType) as usize - ptr as usize
		           },
		           1usize,
		           concat!(
			"Offset of field: ",
			stringify!(usb_debug_descriptor),
			"::",
			stringify!(bDescriptorType)
		)
		);
	}
	test_field_bDescriptorType();
	fn test_field_bDebugInEndpoint() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<usb_debug_descriptor>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).bDebugInEndpoint) as usize - ptr as usize
		           },
		           2usize,
		           concat!(
			"Offset of field: ",
			stringify!(usb_debug_descriptor),
			"::",
			stringify!(bDebugInEndpoint)
		)
		);
	}
	test_field_bDebugInEndpoint();
	fn test_field_bDebugOutEndpoint() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<usb_debug_descriptor>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).bDebugOutEndpoint) as usize - ptr as usize
		           },
		           3usize,
		           concat!(
			"Offset of field: ",
			stringify!(usb_debug_descriptor),
			"::",
			stringify!(bDebugOutEndpoint)
		)
		);
	}
	test_field_bDebugOutEndpoint();
}
extern "C" {
	pub static usbd_devfs: usbd_driver;
}
#[repr(C)]
pub struct FuriHalUsbInterface {
	pub init: ::core::option::Option<unsafe extern "C" fn(dev: *mut usbd_device,
	                                                      intf: *mut FuriHalUsbInterface,
	                                                      ctx: *mut core::ffi::c_void)>,
	pub deinit: ::core::option::Option<unsafe extern "C" fn(dev: *mut usbd_device)>,
	pub wakeup: ::core::option::Option<unsafe extern "C" fn(dev: *mut usbd_device)>,
	pub suspend: ::core::option::Option<unsafe extern "C" fn(dev: *mut usbd_device)>,
	pub dev_descr: *mut usb_device_descriptor,
	pub str_manuf_descr: *mut core::ffi::c_void,
	pub str_prod_descr: *mut core::ffi::c_void,
	pub str_serial_descr: *mut core::ffi::c_void,
	pub cfg_descr: *mut core::ffi::c_void,
}
#[test]
fn bindgen_test_layout_FuriHalUsbInterface() {
	assert_eq!(
	           ::core::mem::size_of::<FuriHalUsbInterface>(),
	           36usize,
	           concat!("Size of: ", stringify!(FuriHalUsbInterface))
	);
	assert_eq!(
	           ::core::mem::align_of::<FuriHalUsbInterface>(),
	           4usize,
	           concat!("Alignment of ", stringify!(FuriHalUsbInterface))
	);
	fn test_field_init() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<FuriHalUsbInterface>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).init) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(FuriHalUsbInterface), "::", stringify!(init))
		);
	}
	test_field_init();
	fn test_field_deinit() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<FuriHalUsbInterface>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).deinit) as usize - ptr as usize
		           },
		           4usize,
		           concat!("Offset of field: ", stringify!(FuriHalUsbInterface), "::", stringify!(deinit))
		);
	}
	test_field_deinit();
	fn test_field_wakeup() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<FuriHalUsbInterface>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).wakeup) as usize - ptr as usize
		           },
		           8usize,
		           concat!("Offset of field: ", stringify!(FuriHalUsbInterface), "::", stringify!(wakeup))
		);
	}
	test_field_wakeup();
	fn test_field_suspend() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<FuriHalUsbInterface>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).suspend) as usize - ptr as usize
		           },
		           12usize,
		           concat!(
			"Offset of field: ",
			stringify!(FuriHalUsbInterface),
			"::",
			stringify!(suspend)
		)
		);
	}
	test_field_suspend();
	fn test_field_dev_descr() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<FuriHalUsbInterface>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).dev_descr) as usize - ptr as usize
		           },
		           16usize,
		           concat!(
			"Offset of field: ",
			stringify!(FuriHalUsbInterface),
			"::",
			stringify!(dev_descr)
		)
		);
	}
	test_field_dev_descr();
	fn test_field_str_manuf_descr() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<FuriHalUsbInterface>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).str_manuf_descr) as usize - ptr as usize
		           },
		           20usize,
		           concat!(
			"Offset of field: ",
			stringify!(FuriHalUsbInterface),
			"::",
			stringify!(str_manuf_descr)
		)
		);
	}
	test_field_str_manuf_descr();
	fn test_field_str_prod_descr() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<FuriHalUsbInterface>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).str_prod_descr) as usize - ptr as usize
		           },
		           24usize,
		           concat!(
			"Offset of field: ",
			stringify!(FuriHalUsbInterface),
			"::",
			stringify!(str_prod_descr)
		)
		);
	}
	test_field_str_prod_descr();
	fn test_field_str_serial_descr() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<FuriHalUsbInterface>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).str_serial_descr) as usize - ptr as usize
		           },
		           28usize,
		           concat!(
			"Offset of field: ",
			stringify!(FuriHalUsbInterface),
			"::",
			stringify!(str_serial_descr)
		)
		);
	}
	test_field_str_serial_descr();
	fn test_field_cfg_descr() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<FuriHalUsbInterface>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).cfg_descr) as usize - ptr as usize
		           },
		           32usize,
		           concat!(
			"Offset of field: ",
			stringify!(FuriHalUsbInterface),
			"::",
			stringify!(cfg_descr)
		)
		);
	}
	test_field_cfg_descr();
}
extern "C" {
	#[doc = " USB device interface modes"]
	pub static mut usb_cdc_single: FuriHalUsbInterface;
}
extern "C" {
	pub static mut usb_cdc_dual: FuriHalUsbInterface;
}
extern "C" {
	pub static mut usb_hid: FuriHalUsbInterface;
}
extern "C" {
	pub static mut usb_hid_u2f: FuriHalUsbInterface;
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum FuriHalUsbStateEvent {
	FuriHalUsbStateEventReset = 0,
	FuriHalUsbStateEventWakeup = 1,
	FuriHalUsbStateEventSuspend = 2,
	FuriHalUsbStateEventDescriptorRequest = 3,
}
pub type FuriHalUsbStateCallback =
	::core::option::Option<unsafe extern "C" fn(state: FuriHalUsbStateEvent, context: *mut core::ffi::c_void)>;
extern "C" {
	#[doc = " USB device low-level initialization"]
	pub fn furi_hal_usb_init();
}
extern "C" {
	#[doc = " Set USB device configuration"]
	#[doc = ""]
	#[doc = " @param      mode new USB device mode"]
	#[doc = " @param      ctx context passed to device mode init function"]
	#[doc = " @return     true - mode switch started, false - mode switch is locked"]
	pub fn furi_hal_usb_set_config(new_if: *mut FuriHalUsbInterface, ctx: *mut core::ffi::c_void) -> bool;
}
extern "C" {
	#[doc = " Get USB device configuration"]
	#[doc = ""]
	#[doc = " @return    current USB device mode"]
	pub fn furi_hal_usb_get_config() -> *mut FuriHalUsbInterface;
}
extern "C" {
	#[doc = " Lock USB device mode switch"]
	pub fn furi_hal_usb_lock();
}
extern "C" {
	#[doc = " Unlock USB device mode switch"]
	pub fn furi_hal_usb_unlock();
}
extern "C" {
	#[doc = " Check if USB device mode switch locked"]
	#[doc = ""]
	#[doc = " @return    lock state"]
	pub fn furi_hal_usb_is_locked() -> bool;
}
extern "C" {
	#[doc = " Disable USB device"]
	pub fn furi_hal_usb_disable();
}
extern "C" {
	#[doc = " Enable USB device"]
	pub fn furi_hal_usb_enable();
}
extern "C" {
	#[doc = " Set USB state callback"]
	pub fn furi_hal_usb_set_state_callback(cb: FuriHalUsbStateCallback, ctx: *mut core::ffi::c_void);
}
extern "C" {
	#[doc = " Restart USB device"]
	pub fn furi_hal_usb_reinit();
}
#[repr(u32)]
#[non_exhaustive]
#[doc = " HID keyboard modifier keys"]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum HidKeyboardMods {
	KEY_MOD_LEFT_CTRL = 256,
	KEY_MOD_LEFT_SHIFT = 512,
	KEY_MOD_LEFT_ALT = 1024,
	KEY_MOD_LEFT_GUI = 2048,
	KEY_MOD_RIGHT_CTRL = 4096,
	KEY_MOD_RIGHT_SHIFT = 8192,
	KEY_MOD_RIGHT_ALT = 16384,
	KEY_MOD_RIGHT_GUI = 32768,
}
extern "C" {
	#[doc = " ASCII to keycode conversion table"]
	pub static hid_asciimap: [u16; 128usize];
}
#[repr(C)]
pub struct FuriHalUsbHidConfig {
	pub vid: u32,
	pub pid: u32,
	pub manuf: [core::ffi::c_char; 32usize],
	pub product: [core::ffi::c_char; 32usize],
}
#[test]
fn bindgen_test_layout_FuriHalUsbHidConfig() {
	assert_eq!(
	           ::core::mem::size_of::<FuriHalUsbHidConfig>(),
	           72usize,
	           concat!("Size of: ", stringify!(FuriHalUsbHidConfig))
	);
	assert_eq!(
	           ::core::mem::align_of::<FuriHalUsbHidConfig>(),
	           4usize,
	           concat!("Alignment of ", stringify!(FuriHalUsbHidConfig))
	);
	fn test_field_vid() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<FuriHalUsbHidConfig>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).vid) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(FuriHalUsbHidConfig), "::", stringify!(vid))
		);
	}
	test_field_vid();
	fn test_field_pid() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<FuriHalUsbHidConfig>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).pid) as usize - ptr as usize
		           },
		           4usize,
		           concat!("Offset of field: ", stringify!(FuriHalUsbHidConfig), "::", stringify!(pid))
		);
	}
	test_field_pid();
	fn test_field_manuf() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<FuriHalUsbHidConfig>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).manuf) as usize - ptr as usize
		           },
		           8usize,
		           concat!("Offset of field: ", stringify!(FuriHalUsbHidConfig), "::", stringify!(manuf))
		);
	}
	test_field_manuf();
	fn test_field_product() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<FuriHalUsbHidConfig>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).product) as usize - ptr as usize
		           },
		           40usize,
		           concat!(
			"Offset of field: ",
			stringify!(FuriHalUsbHidConfig),
			"::",
			stringify!(product)
		)
		);
	}
	test_field_product();
}
pub type HidStateCallback = ::core::option::Option<unsafe extern "C" fn(state: bool, context: *mut core::ffi::c_void)>;
#[repr(u32)]
#[non_exhaustive]
#[doc = " HID keyboard leds"]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum HidKeyboardLeds {
	HID_KB_LED_NUM = 1,
	HID_KB_LED_CAPS = 2,
	HID_KB_LED_SCROLL = 4,
}
#[repr(u32)]
#[non_exhaustive]
#[doc = " HID mouse buttons"]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum HidMouseButtons {
	HID_MOUSE_BTN_LEFT = 1,
	HID_MOUSE_BTN_RIGHT = 2,
	HID_MOUSE_BTN_WHEEL = 4,
}
extern "C" {
	#[doc = " Get USB HID connection state"]
	#[doc = ""]
	#[doc = " @return      true / false"]
	pub fn furi_hal_hid_is_connected() -> bool;
}
extern "C" {
	#[doc = " Get USB HID keyboard leds state"]
	#[doc = ""]
	#[doc = " @return      leds state"]
	pub fn furi_hal_hid_get_led_state() -> u8;
}
extern "C" {
	#[doc = " Set USB HID connect/disconnect callback"]
	#[doc = ""]
	#[doc = " @param      cb  callback"]
	#[doc = " @param      ctx  callback context"]
	pub fn furi_hal_hid_set_state_callback(cb: HidStateCallback, ctx: *mut core::ffi::c_void);
}
extern "C" {
	#[doc = " Set the following key to pressed state and send HID report"]
	#[doc = ""]
	#[doc = " @param      button  key code"]
	pub fn furi_hal_hid_kb_press(button: u16) -> bool;
}
extern "C" {
	#[doc = " Set the following key to released state and send HID report"]
	#[doc = ""]
	#[doc = " @param      button  key code"]
	pub fn furi_hal_hid_kb_release(button: u16) -> bool;
}
extern "C" {
	#[doc = " Clear all pressed keys and send HID report"]
	#[doc = ""]
	pub fn furi_hal_hid_kb_release_all() -> bool;
}
extern "C" {
	#[doc = " Set mouse movement and send HID report"]
	#[doc = ""]
	#[doc = " @param      dx  x coordinate delta"]
	#[doc = " @param      dy  y coordinate delta"]
	pub fn furi_hal_hid_mouse_move(dx: i8, dy: i8) -> bool;
}
extern "C" {
	#[doc = " Set mouse button to pressed state and send HID report"]
	#[doc = ""]
	#[doc = " @param      button  key code"]
	pub fn furi_hal_hid_mouse_press(button: u8) -> bool;
}
extern "C" {
	#[doc = " Set mouse button to released state and send HID report"]
	#[doc = ""]
	#[doc = " @param      button  key code"]
	pub fn furi_hal_hid_mouse_release(button: u8) -> bool;
}
extern "C" {
	#[doc = " Set mouse wheel position and send HID report"]
	#[doc = ""]
	#[doc = " @param      delta  number of scroll steps"]
	pub fn furi_hal_hid_mouse_scroll(delta: i8) -> bool;
}
extern "C" {
	#[doc = " Set the following consumer key to pressed state and send HID report"]
	#[doc = ""]
	#[doc = " @param      button  key code"]
	pub fn furi_hal_hid_consumer_key_press(button: u16) -> bool;
}
extern "C" {
	#[doc = " Set the following consumer key to released state and send HID report"]
	#[doc = ""]
	#[doc = " @param      button  key code"]
	pub fn furi_hal_hid_consumer_key_release(button: u16) -> bool;
}
#[repr(C)]
pub struct FuriHalCompress {
	_unused: [u8; 0],
}
extern "C" {
	#[doc = " Initialize icon decoder"]
	pub fn furi_hal_compress_icon_init();
}
extern "C" {
	#[doc = " Icon decoder"]
	#[doc = ""]
	#[doc = " @param   icon_data    pointer to icon data"]
	#[doc = " @param   decoded_buff pointer to decoded buffer"]
	pub fn furi_hal_compress_icon_decode(icon_data: *const u8, decoded_buff: *mut *mut u8);
}
extern "C" {
	#[doc = " Allocate encoder and decoder"]
	#[doc = ""]
	#[doc = " @param   compress_buff_size  size of decoder and encoder buffer to allocate"]
	#[doc = ""]
	#[doc = " @return  FuriHalCompress instance"]
	pub fn furi_hal_compress_alloc(compress_buff_size: u16) -> *mut FuriHalCompress;
}
extern "C" {
	#[doc = " Free encoder and decoder"]
	#[doc = ""]
	#[doc = " @param   compress  FuriHalCompress instance"]
	pub fn furi_hal_compress_free(compress: *mut FuriHalCompress);
}
extern "C" {
	#[doc = " Encode data"]
	#[doc = ""]
	#[doc = " @param   compress FuriHalCompress instance"]
	#[doc = " @param   data_in pointer to input data"]
	#[doc = " @param   data_in_size size of input data"]
	#[doc = " @param   data_out maximum size of output data"]
	#[doc = " @param   data_res_size pointer to result output data size"]
	#[doc = ""]
	#[doc = " @return  true on success"]
	pub fn furi_hal_compress_encode(compress: *mut FuriHalCompress,
	                                data_in: *mut u8,
	                                data_in_size: usize,
	                                data_out: *mut u8,
	                                data_out_size: usize,
	                                data_res_size: *mut usize)
	                                -> bool;
}
extern "C" {
	#[doc = " Decode data"]
	#[doc = ""]
	#[doc = " @param   compress FuriHalCompress instance"]
	#[doc = " @param   data_in pointer to input data"]
	#[doc = " @param   data_in_size size of input data"]
	#[doc = " @param   data_out maximum size of output data"]
	#[doc = " @param   data_res_size pointer to result output data size"]
	#[doc = ""]
	#[doc = " @return  true on success"]
	pub fn furi_hal_compress_decode(compress: *mut FuriHalCompress,
	                                data_in: *mut u8,
	                                data_in_size: usize,
	                                data_out: *mut u8,
	                                data_out_size: usize,
	                                data_res_size: *mut usize)
	                                -> bool;
}
#[doc = " Callback type called every time another key-value pair of device information is ready"]
#[doc = ""]
#[doc = " @param      key[in]      device information type identifier"]
#[doc = " @param      value[in]    device information value"]
#[doc = " @param      last[in]     whether the passed key-value pair is the last one"]
#[doc = " @param      context[in]  to pass to callback"]
pub type FuriHalInfoValueCallback = ::core::option::Option<unsafe extern "C" fn(key: *const core::ffi::c_char,
                                                                                value: *const core::ffi::c_char,
                                                                                last: bool,
                                                                                context: *mut core::ffi::c_void)>;
extern "C" {
	#[doc = " Get device information"]
	#[doc = ""]
	#[doc = " @param[in]  callback     callback to provide with new data"]
	#[doc = " @param[in]  context      context to pass to callback"]
	pub fn furi_hal_info_get(callback: FuriHalInfoValueCallback, context: *mut core::ffi::c_void);
}
extern "C" {
	#[doc = " Get random value"]
	#[doc = ""]
	#[doc = " @return     random value"]
	pub fn furi_hal_random_get() -> u32;
}
extern "C" {
	#[doc = " Fill buffer with random data"]
	#[doc = ""]
	#[doc = " @param      buf  buffer pointer"]
	#[doc = " @param      data buffer len"]
	pub fn furi_hal_random_fill_buf(buf: *mut u8, len: u32);
}
extern "C" {
	#[doc = " Early FuriHal init, only essential subsystems"]
	pub fn furi_hal_init_early();
}
extern "C" {
	#[doc = " Early FuriHal deinit"]
	pub fn furi_hal_deinit_early();
}
extern "C" {
	#[doc = " Init FuriHal"]
	pub fn furi_hal_init();
}
extern "C" {
	#[doc = " Transfer execution to address"]
	#[doc = ""]
	#[doc = " @param[in]  address  pointer to new executable"]
	pub fn furi_hal_switch(address: *mut core::ffi::c_void);
}
extern "C" {
	#[doc = " Start Hid Keyboard Profile"]
	pub fn furi_hal_bt_hid_start();
}
extern "C" {
	#[doc = " Stop Hid Keyboard Profile"]
	pub fn furi_hal_bt_hid_stop();
}
extern "C" {
	#[doc = " Press keyboard button"]
	#[doc = ""]
	#[doc = " @param button    button code from HID specification"]
	#[doc = ""]
	#[doc = " @return          true on success"]
	pub fn furi_hal_bt_hid_kb_press(button: u16) -> bool;
}
extern "C" {
	#[doc = " Release keyboard button"]
	#[doc = ""]
	#[doc = " @param button    button code from HID specification"]
	#[doc = ""]
	#[doc = " @return          true on success"]
	pub fn furi_hal_bt_hid_kb_release(button: u16) -> bool;
}
extern "C" {
	#[doc = " Release all keyboard buttons"]
	#[doc = ""]
	#[doc = " @return          true on success"]
	pub fn furi_hal_bt_hid_kb_release_all() -> bool;
}
extern "C" {
	#[doc = " Set mouse movement and send HID report"]
	#[doc = ""]
	#[doc = " @param      dx  x coordinate delta"]
	#[doc = " @param      dy  y coordinate delta"]
	pub fn furi_hal_bt_hid_mouse_move(dx: i8, dy: i8) -> bool;
}
extern "C" {
	#[doc = " Set mouse button to pressed state and send HID report"]
	#[doc = ""]
	#[doc = " @param      button  key code"]
	pub fn furi_hal_bt_hid_mouse_press(button: u8) -> bool;
}
extern "C" {
	#[doc = " Set mouse button to released state and send HID report"]
	#[doc = ""]
	#[doc = " @param      button  key code"]
	pub fn furi_hal_bt_hid_mouse_release(button: u8) -> bool;
}
extern "C" {
	#[doc = " Set mouse button to released state and send HID report"]
	#[doc = ""]
	#[doc = " @param      button  key code"]
	pub fn furi_hal_bt_hid_mouse_release_all() -> bool;
}
extern "C" {
	#[doc = " Set mouse wheel position and send HID report"]
	#[doc = ""]
	#[doc = " @param      delta  number of scroll steps"]
	pub fn furi_hal_bt_hid_mouse_scroll(delta: i8) -> bool;
}
extern "C" {
	#[doc = " Set the following consumer key to pressed state and send HID report"]
	#[doc = ""]
	#[doc = " @param      button  key code"]
	pub fn furi_hal_bt_hid_consumer_key_press(button: u16) -> bool;
}
extern "C" {
	#[doc = " Set the following consumer key to released state and send HID report"]
	#[doc = ""]
	#[doc = " @param      button  key code"]
	pub fn furi_hal_bt_hid_consumer_key_release(button: u16) -> bool;
}
extern "C" {
	#[doc = " Set consumer key to released state and send HID report"]
	#[doc = ""]
	#[doc = " @param      button  key code"]
	pub fn furi_hal_bt_hid_consumer_key_release_all() -> bool;
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum FuriHalInfraredTxGetDataState {
	#[doc = "< New data obtained"]
	FuriHalInfraredTxGetDataStateOk = 0,
	#[doc = "< New data obtained, and this is end of package"]
	FuriHalInfraredTxGetDataStateDone = 1,
	#[doc = "< New data obtained, and this is end of package and no more data available"]
	FuriHalInfraredTxGetDataStateLastDone = 2,
}
#[doc = " Callback type for providing data to INFRARED DMA TX system. It is called every tim"]
pub type FuriHalInfraredTxGetDataISRCallback = ::core::option::Option<unsafe extern "C" fn(context: *mut core::ffi::c_void,
                                                                                           duration: *mut u32,
                                                                                           level: *mut bool)
                                                                                           -> FuriHalInfraredTxGetDataState>;
#[doc = " Callback type called every time signal is sent by DMA to Timer."]
#[doc = ""]
#[doc = " Actually, it means there are 2 timings left to send for this signal, which is"]
#[doc = " almost end. Don't use this callback to stop transmission, as far as there are"]
#[doc = " next signal is charged for transmission by DMA."]
pub type FuriHalInfraredTxSignalSentISRCallback = ::core::option::Option<unsafe extern "C" fn(context: *mut core::ffi::c_void)>;
#[doc = " Signature of callback function for receiving continuous INFRARED rx signal."]
#[doc = ""]
#[doc = " @param      ctx[in]       context to pass to callback"]
#[doc = " @param      level[in]     level of input INFRARED rx signal"]
#[doc = " @param      duration[in]  duration of continuous rx signal level in us"]
pub type FuriHalInfraredRxCaptureCallback =
	::core::option::Option<unsafe extern "C" fn(ctx: *mut core::ffi::c_void, level: bool, duration: u32)>;
#[doc = " Signature of callback function for reaching silence timeout on INFRARED port."]
#[doc = ""]
#[doc = " @param      ctx[in]  context to pass to callback"]
pub type FuriHalInfraredRxTimeoutCallback = ::core::option::Option<unsafe extern "C" fn(ctx: *mut core::ffi::c_void)>;
extern "C" {
	#[doc = " Initialize INFRARED RX timer to receive interrupts."]
	#[doc = ""]
	#[doc = " It provides interrupts for every RX-signal edge changing with its duration."]
	pub fn furi_hal_infrared_async_rx_start();
}
extern "C" {
	#[doc = " Deinitialize INFRARED RX interrupt."]
	pub fn furi_hal_infrared_async_rx_stop();
}
extern "C" {
	#[doc = " Setup hal for receiving silence timeout."]
	#[doc = ""]
	#[doc = " Should be used with 'furi_hal_infrared_timeout_irq_set_callback()'."]
	#[doc = ""]
	#[doc = " @param[in]  timeout_us  time to wait for silence on INFRARED port before"]
	#[doc = "                         generating IRQ."]
	pub fn furi_hal_infrared_async_rx_set_timeout(timeout_us: u32);
}
extern "C" {
	#[doc = " Setup callback for previously initialized INFRARED RX interrupt."]
	#[doc = ""]
	#[doc = " @param[in]  callback  callback to call when RX signal edge changing occurs"]
	#[doc = " @param[in]  ctx       context for callback"]
	pub fn furi_hal_infrared_async_rx_set_capture_isr_callback(callback: FuriHalInfraredRxCaptureCallback,
	                                                           ctx: *mut core::ffi::c_void);
}
extern "C" {
	#[doc = " Setup callback for reaching silence timeout on INFRARED port."]
	#[doc = ""]
	#[doc = " Should setup hal with 'furi_hal_infrared_setup_rx_timeout_irq()' first."]
	#[doc = ""]
	#[doc = " @param[in]  callback  callback for silence timeout"]
	#[doc = " @param[in]  ctx       context to pass to callback"]
	pub fn furi_hal_infrared_async_rx_set_timeout_isr_callback(callback: FuriHalInfraredRxTimeoutCallback,
	                                                           ctx: *mut core::ffi::c_void);
}
extern "C" {
	#[doc = " Check if INFRARED is in use now."]
	#[doc = ""]
	#[doc = " @return     true if INFRARED is busy, false otherwise."]
	pub fn furi_hal_infrared_is_busy() -> bool;
}
extern "C" {
	#[doc = " Set callback providing new data."]
	#[doc = ""]
	#[doc = " This function has to be called before furi_hal_infrared_async_tx_start()."]
	#[doc = ""]
	#[doc = " @param[in]  callback  function to provide new data"]
	#[doc = " @param[in]  context   context for callback"]
	pub fn furi_hal_infrared_async_tx_set_data_isr_callback(callback: FuriHalInfraredTxGetDataISRCallback,
	                                                        context: *mut core::ffi::c_void);
}
extern "C" {
	#[doc = " Start IR asynchronous transmission."]
	#[doc = ""]
	#[doc = " It can be stopped by 2 reasons:"]
	#[doc = " 1. implicit call for furi_hal_infrared_async_tx_stop()"]
	#[doc = " 2. callback can provide FuriHalInfraredTxGetDataStateLastDone response which"]
	#[doc = "    means no more data available for transmission."]
	#[doc = ""]
	#[doc = " Any func (furi_hal_infrared_async_tx_stop() or"]
	#[doc = " furi_hal_infrared_async_tx_wait_termination()) has to be called to wait end of"]
	#[doc = " transmission and free resources."]
	#[doc = ""]
	#[doc = " @param[in]  freq        frequency for PWM"]
	#[doc = " @param[in]  duty_cycle  duty cycle for PWM"]
	pub fn furi_hal_infrared_async_tx_start(freq: u32, duty_cycle: core::ffi::c_float);
}
extern "C" {
	#[doc = " Stop IR asynchronous transmission and free resources."]
	#[doc = ""]
	#[doc = " Transmission will stop as soon as transmission reaches end of package"]
	#[doc = " (FuriHalInfraredTxGetDataStateDone or FuriHalInfraredTxGetDataStateLastDone)."]
	pub fn furi_hal_infrared_async_tx_stop();
}
extern "C" {
	#[doc = " Wait for end of IR asynchronous transmission and free resources."]
	#[doc = ""]
	#[doc = " Transmission will stop as soon as transmission reaches end of transmission"]
	#[doc = " (FuriHalInfraredTxGetDataStateLastDone)."]
	pub fn furi_hal_infrared_async_tx_wait_termination();
}
extern "C" {
	#[doc = " Set callback for end of signal transmission"]
	#[doc = ""]
	#[doc = " @param[in]  callback  function to call when signal is sent"]
	#[doc = " @param[in]  context   context for callback"]
	pub fn furi_hal_infrared_async_tx_set_signal_sent_isr_callback(callback: FuriHalInfraredTxSignalSentISRCallback,
	                                                               context: *mut core::ffi::c_void);
}
extern "C" {
	#[doc = " @brief Init memory pool manager"]
	pub fn furi_hal_memory_init();
}
extern "C" {
	#[doc = " @brief Allocate memory from separate memory pool. That memory can't be freed."]
	#[doc = ""]
	#[doc = " @param size"]
	#[doc = " @return void*"]
	pub fn furi_hal_memory_alloc(size: usize) -> *mut core::ffi::c_void;
}
extern "C" {
	#[doc = " @brief Get free memory pool size"]
	#[doc = ""]
	#[doc = " @return size_t"]
	pub fn furi_hal_memory_get_free() -> usize;
}
extern "C" {
	#[doc = " @brief Get max free block size from memory pool"]
	#[doc = ""]
	#[doc = " @return size_t"]
	pub fn furi_hal_memory_max_pool_block() -> usize;
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum FuriHalMpuRegion {
	FuriHalMpuRegionNULL = 0,
	FuriHalMpuRegionStack = 1,
	FuriHalMpuRegion2 = 2,
	FuriHalMpuRegion3 = 3,
	FuriHalMpuRegion4 = 4,
	FuriHalMpuRegion5 = 5,
	FuriHalMpuRegion6 = 6,
	FuriHalMpuRegion7 = 7,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum FuriHalMPURegionSize {
	FuriHalMPURegionSize32B = 4,
	FuriHalMPURegionSize64B = 5,
	FuriHalMPURegionSize128B = 6,
	FuriHalMPURegionSize256B = 7,
	FuriHalMPURegionSize512B = 8,
	FuriHalMPURegionSize1KB = 9,
	FuriHalMPURegionSize2KB = 10,
	FuriHalMPURegionSize4KB = 11,
	FuriHalMPURegionSize8KB = 12,
	FuriHalMPURegionSize16KB = 13,
	FuriHalMPURegionSize32KB = 14,
	FuriHalMPURegionSize64KB = 15,
	FuriHalMPURegionSize128KB = 16,
	FuriHalMPURegionSize256KB = 17,
	FuriHalMPURegionSize512KB = 18,
	FuriHalMPURegionSize1MB = 19,
	FuriHalMPURegionSize2MB = 20,
	FuriHalMPURegionSize4MB = 21,
	FuriHalMPURegionSize8MB = 22,
	FuriHalMPURegionSize16MB = 23,
	FuriHalMPURegionSize32MB = 24,
	FuriHalMPURegionSize64MB = 25,
	FuriHalMPURegionSize128MB = 26,
	FuriHalMPURegionSize256MB = 27,
	FuriHalMPURegionSize512MB = 28,
	FuriHalMPURegionSize1GB = 29,
	FuriHalMPURegionSize2GB = 30,
	FuriHalMPURegionSize4GB = 31,
}
extern "C" {
	#[doc = " @brief Initialize memory protection unit"]
	pub fn furi_hal_mpu_init();
}
extern "C" {
	#[doc = " @brief Enable memory protection unit"]
	pub fn furi_hal_mpu_enable();
}
extern "C" {
	#[doc = " @brief Disable memory protection unit"]
	pub fn furi_hal_mpu_disable();
}
extern "C" {
	pub fn furi_hal_mpu_protect_no_access(region: FuriHalMpuRegion, address: u32, size: FuriHalMPURegionSize);
}
extern "C" {
	pub fn furi_hal_mpu_protect_read_only(region: FuriHalMpuRegion, address: u32, size: FuriHalMPURegionSize);
}
extern "C" {
	pub fn furi_hal_mpu_protect_disable(region: FuriHalMpuRegion);
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum HidU2fEvent {
	HidU2fDisconnected = 0,
	HidU2fConnected = 1,
	HidU2fRequest = 2,
}
pub type HidU2fCallback = ::core::option::Option<unsafe extern "C" fn(ev: HidU2fEvent, context: *mut core::ffi::c_void)>;
extern "C" {
	#[doc = " Get HID U2F connection state"]
	#[doc = ""]
	#[doc = " @return      true / false"]
	pub fn furi_hal_hid_u2f_is_connected() -> bool;
}
extern "C" {
	#[doc = " Set HID U2F event callback"]
	#[doc = ""]
	#[doc = " @param      cb  callback"]
	#[doc = " @param      ctx  callback context"]
	pub fn furi_hal_hid_u2f_set_callback(cb: HidU2fCallback, ctx: *mut core::ffi::c_void);
}
extern "C" {
	#[doc = " Get received U2F HID packet"]
	#[doc = ""]
	pub fn furi_hal_hid_u2f_get_request(data: *mut u8) -> u32;
}
extern "C" {
	#[doc = " Send U2F HID response packet"]
	#[doc = ""]
	#[doc = " @param      data  response data"]
	#[doc = " @param      len  packet length"]
	pub fn furi_hal_hid_u2f_send_response(data: *mut u8, len: u8);
}
#[doc = " @brief  Structure definition of some features of ADC common parameters"]
#[doc = "         and multimode"]
#[doc = "         (all ADC instances belonging to the same ADC common instance)."]
#[doc = " @note   The setting of these parameters by function @ref LL_ADC_CommonInit()"]
#[doc = "         is conditioned to ADC instances state (all ADC instances"]
#[doc = "         sharing the same ADC common instance):"]
#[doc = "         All ADC instances sharing the same ADC common instance must be"]
#[doc = "         disabled."]
#[repr(C)]
pub struct LL_ADC_CommonInitTypeDef {
	#[doc = "< Set parameter common to several ADC: Clock source and prescaler."]
	#[doc = "This parameter can be a value of @ref ADC_LL_EC_COMMON_CLOCK_SOURCE"]
	#[doc = "@note On this STM32 serie, if ADC group injected is used, some"]
	#[doc = "clock ratio constraints between ADC clock and AHB clock"]
	#[doc = "must be respected. Refer to reference manual."]
	#[doc = ""]
	#[doc = "This feature can be modified afterwards using unitary function @ref LL_ADC_SetCommonClock()."]
	pub CommonClock: u32,
}
#[test]
fn bindgen_test_layout_LL_ADC_CommonInitTypeDef() {
	assert_eq!(
	           ::core::mem::size_of::<LL_ADC_CommonInitTypeDef>(),
	           4usize,
	           concat!("Size of: ", stringify!(LL_ADC_CommonInitTypeDef))
	);
	assert_eq!(
	           ::core::mem::align_of::<LL_ADC_CommonInitTypeDef>(),
	           4usize,
	           concat!("Alignment of ", stringify!(LL_ADC_CommonInitTypeDef))
	);
	fn test_field_CommonClock() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_ADC_CommonInitTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).CommonClock) as usize - ptr as usize
		           },
		           0usize,
		           concat!(
			"Offset of field: ",
			stringify!(LL_ADC_CommonInitTypeDef),
			"::",
			stringify!(CommonClock)
		)
		);
	}
	test_field_CommonClock();
}
#[doc = " @brief  Structure definition of some features of ADC instance."]
#[doc = " @note   These parameters have an impact on ADC scope: ADC instance."]
#[doc = "         Affects both group regular and group injected (availability"]
#[doc = "         of ADC group injected depends on STM32 families)."]
#[doc = "         Refer to corresponding unitary functions into"]
#[doc = "         @ref ADC_LL_EF_Configuration_ADC_Instance ."]
#[doc = " @note   The setting of these parameters by function @ref LL_ADC_Init()"]
#[doc = "         is conditioned to ADC state:"]
#[doc = "         ADC instance must be disabled."]
#[doc = "         This condition is applied to all ADC features, for efficiency"]
#[doc = "         and compatibility over all STM32 families. However, the different"]
#[doc = "         features can be set under different ADC state conditions"]
#[doc = "         (setting possible with ADC enabled without conversion on going,"]
#[doc = "         ADC enabled with conversion on going, ...)"]
#[doc = "         Each feature can be updated afterwards with a unitary function"]
#[doc = "         and potentially with ADC in a different state than disabled,"]
#[doc = "         refer to description of each function for setting"]
#[doc = "         conditioned to ADC state."]
#[repr(C)]
pub struct LL_ADC_InitTypeDef {
	#[doc = "< Set ADC resolution."]
	#[doc = "This parameter can be a value of @ref ADC_LL_EC_RESOLUTION"]
	#[doc = ""]
	#[doc = "This feature can be modified afterwards using unitary function @ref LL_ADC_SetResolution()."]
	pub Resolution: u32,
	#[doc = "< Set ADC conversion data alignment."]
	#[doc = "This parameter can be a value of @ref ADC_LL_EC_DATA_ALIGN"]
	#[doc = ""]
	#[doc = "This feature can be modified afterwards using unitary function @ref LL_ADC_SetDataAlignment()."]
	pub DataAlignment: u32,
	#[doc = "< Set ADC low power mode."]
	#[doc = "This parameter can be a value of @ref ADC_LL_EC_LP_MODE"]
	#[doc = ""]
	#[doc = "This feature can be modified afterwards using unitary function @ref LL_ADC_SetLowPowerMode()."]
	pub LowPowerMode: u32,
}
#[test]
fn bindgen_test_layout_LL_ADC_InitTypeDef() {
	assert_eq!(
	           ::core::mem::size_of::<LL_ADC_InitTypeDef>(),
	           12usize,
	           concat!("Size of: ", stringify!(LL_ADC_InitTypeDef))
	);
	assert_eq!(
	           ::core::mem::align_of::<LL_ADC_InitTypeDef>(),
	           4usize,
	           concat!("Alignment of ", stringify!(LL_ADC_InitTypeDef))
	);
	fn test_field_Resolution() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_ADC_InitTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).Resolution) as usize - ptr as usize
		           },
		           0usize,
		           concat!(
			"Offset of field: ",
			stringify!(LL_ADC_InitTypeDef),
			"::",
			stringify!(Resolution)
		)
		);
	}
	test_field_Resolution();
	fn test_field_DataAlignment() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_ADC_InitTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).DataAlignment) as usize - ptr as usize
		           },
		           4usize,
		           concat!(
			"Offset of field: ",
			stringify!(LL_ADC_InitTypeDef),
			"::",
			stringify!(DataAlignment)
		)
		);
	}
	test_field_DataAlignment();
	fn test_field_LowPowerMode() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_ADC_InitTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).LowPowerMode) as usize - ptr as usize
		           },
		           8usize,
		           concat!(
			"Offset of field: ",
			stringify!(LL_ADC_InitTypeDef),
			"::",
			stringify!(LowPowerMode)
		)
		);
	}
	test_field_LowPowerMode();
}
#[doc = " @brief  Structure definition of some features of ADC group regular."]
#[doc = " @note   These parameters have an impact on ADC scope: ADC group regular."]
#[doc = "         Refer to corresponding unitary functions into"]
#[doc = "         @ref ADC_LL_EF_Configuration_ADC_Group_Regular"]
#[doc = "         (functions with prefix \"REG\")."]
#[doc = " @note   The setting of these parameters by function @ref LL_ADC_REG_Init()"]
#[doc = "         is conditioned to ADC state:"]
#[doc = "         ADC instance must be disabled."]
#[doc = "         This condition is applied to all ADC features, for efficiency"]
#[doc = "         and compatibility over all STM32 families. However, the different"]
#[doc = "         features can be set under different ADC state conditions"]
#[doc = "         (setting possible with ADC enabled without conversion on going,"]
#[doc = "         ADC enabled with conversion on going, ...)"]
#[doc = "         Each feature can be updated afterwards with a unitary function"]
#[doc = "         and potentially with ADC in a different state than disabled,"]
#[doc = "         refer to description of each function for setting"]
#[doc = "         conditioned to ADC state."]
#[repr(C)]
pub struct LL_ADC_REG_InitTypeDef {
	#[doc = "< Set ADC group regular conversion trigger source: internal (SW start) or from external peripheral (timer event, external interrupt line)."]
	#[doc = "This parameter can be a value of @ref ADC_LL_EC_REG_TRIGGER_SOURCE"]
	#[doc = "@note On this STM32 serie, setting trigger source to external trigger also set trigger polarity to rising edge"]
	#[doc = "(default setting for compatibility with some ADC on other STM32 families having this setting set by HW default value)."]
	#[doc = "In case of need to modify trigger edge, use function @ref LL_ADC_REG_SetTriggerEdge()."]
	#[doc = ""]
	#[doc = "This feature can be modified afterwards using unitary function @ref LL_ADC_REG_SetTriggerSource()."]
	pub TriggerSource: u32,
	#[doc = "< Set ADC group regular sequencer length."]
	#[doc = "This parameter can be a value of @ref ADC_LL_EC_REG_SEQ_SCAN_LENGTH"]
	#[doc = ""]
	#[doc = "This feature can be modified afterwards using unitary function @ref LL_ADC_REG_SetSequencerLength()."]
	pub SequencerLength: u32,
	#[doc = "< Set ADC group regular sequencer discontinuous mode: sequence subdivided and scan conversions interrupted every selected number of ranks."]
	#[doc = "This parameter can be a value of @ref ADC_LL_EC_REG_SEQ_DISCONT_MODE"]
	#[doc = "@note This parameter has an effect only if group regular sequencer is enabled"]
	#[doc = "(scan length of 2 ranks or more)."]
	#[doc = ""]
	#[doc = "This feature can be modified afterwards using unitary function @ref LL_ADC_REG_SetSequencerDiscont()."]
	pub SequencerDiscont: u32,
	#[doc = "< Set ADC continuous conversion mode on ADC group regular, whether ADC conversions are performed in single mode (one conversion per trigger) or in continuous mode (after the first trigger, following conversions launched successively automatically)."]
	#[doc = "This parameter can be a value of @ref ADC_LL_EC_REG_CONTINUOUS_MODE"]
	#[doc = "Note: It is not possible to enable both ADC group regular continuous mode and discontinuous mode."]
	#[doc = ""]
	#[doc = "This feature can be modified afterwards using unitary function @ref LL_ADC_REG_SetContinuousMode()."]
	pub ContinuousMode: u32,
	#[doc = "< Set ADC group regular conversion data transfer: no transfer or transfer by DMA, and DMA requests mode."]
	#[doc = "This parameter can be a value of @ref ADC_LL_EC_REG_DMA_TRANSFER"]
	#[doc = ""]
	#[doc = "This feature can be modified afterwards using unitary function @ref LL_ADC_REG_SetDMATransfer()."]
	pub DMATransfer: u32,
	#[doc = "< Set ADC group regular behavior in case of overrun:"]
	#[doc = "data preserved or overwritten."]
	#[doc = "This parameter can be a value of @ref ADC_LL_EC_REG_OVR_DATA_BEHAVIOR"]
	#[doc = ""]
	#[doc = "This feature can be modified afterwards using unitary function @ref LL_ADC_REG_SetOverrun()."]
	pub Overrun: u32,
}
#[test]
fn bindgen_test_layout_LL_ADC_REG_InitTypeDef() {
	assert_eq!(
	           ::core::mem::size_of::<LL_ADC_REG_InitTypeDef>(),
	           24usize,
	           concat!("Size of: ", stringify!(LL_ADC_REG_InitTypeDef))
	);
	assert_eq!(
	           ::core::mem::align_of::<LL_ADC_REG_InitTypeDef>(),
	           4usize,
	           concat!("Alignment of ", stringify!(LL_ADC_REG_InitTypeDef))
	);
	fn test_field_TriggerSource() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_ADC_REG_InitTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).TriggerSource) as usize - ptr as usize
		           },
		           0usize,
		           concat!(
			"Offset of field: ",
			stringify!(LL_ADC_REG_InitTypeDef),
			"::",
			stringify!(TriggerSource)
		)
		);
	}
	test_field_TriggerSource();
	fn test_field_SequencerLength() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_ADC_REG_InitTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).SequencerLength) as usize - ptr as usize
		           },
		           4usize,
		           concat!(
			"Offset of field: ",
			stringify!(LL_ADC_REG_InitTypeDef),
			"::",
			stringify!(SequencerLength)
		)
		);
	}
	test_field_SequencerLength();
	fn test_field_SequencerDiscont() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_ADC_REG_InitTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).SequencerDiscont) as usize - ptr as usize
		           },
		           8usize,
		           concat!(
			"Offset of field: ",
			stringify!(LL_ADC_REG_InitTypeDef),
			"::",
			stringify!(SequencerDiscont)
		)
		);
	}
	test_field_SequencerDiscont();
	fn test_field_ContinuousMode() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_ADC_REG_InitTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).ContinuousMode) as usize - ptr as usize
		           },
		           12usize,
		           concat!(
			"Offset of field: ",
			stringify!(LL_ADC_REG_InitTypeDef),
			"::",
			stringify!(ContinuousMode)
		)
		);
	}
	test_field_ContinuousMode();
	fn test_field_DMATransfer() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_ADC_REG_InitTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).DMATransfer) as usize - ptr as usize
		           },
		           16usize,
		           concat!(
			"Offset of field: ",
			stringify!(LL_ADC_REG_InitTypeDef),
			"::",
			stringify!(DMATransfer)
		)
		);
	}
	test_field_DMATransfer();
	fn test_field_Overrun() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_ADC_REG_InitTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).Overrun) as usize - ptr as usize
		           },
		           20usize,
		           concat!(
			"Offset of field: ",
			stringify!(LL_ADC_REG_InitTypeDef),
			"::",
			stringify!(Overrun)
		)
		);
	}
	test_field_Overrun();
}
#[doc = " @brief  Structure definition of some features of ADC group injected."]
#[doc = " @note   These parameters have an impact on ADC scope: ADC group injected."]
#[doc = "         Refer to corresponding unitary functions into"]
#[doc = "         @ref ADC_LL_EF_Configuration_ADC_Group_Regular"]
#[doc = "         (functions with prefix \"INJ\")."]
#[doc = " @note   The setting of these parameters by function @ref LL_ADC_INJ_Init()"]
#[doc = "         is conditioned to ADC state:"]
#[doc = "         ADC instance must be disabled."]
#[doc = "         This condition is applied to all ADC features, for efficiency"]
#[doc = "         and compatibility over all STM32 families. However, the different"]
#[doc = "         features can be set under different ADC state conditions"]
#[doc = "         (setting possible with ADC enabled without conversion on going,"]
#[doc = "         ADC enabled with conversion on going, ...)"]
#[doc = "         Each feature can be updated afterwards with a unitary function"]
#[doc = "         and potentially with ADC in a different state than disabled,"]
#[doc = "         refer to description of each function for setting"]
#[doc = "         conditioned to ADC state."]
#[repr(C)]
pub struct LL_ADC_INJ_InitTypeDef {
	#[doc = "< Set ADC group injected conversion trigger source: internal (SW start) or from external peripheral (timer event, external interrupt line)."]
	#[doc = "This parameter can be a value of @ref ADC_LL_EC_INJ_TRIGGER_SOURCE"]
	#[doc = "@note On this STM32 serie, setting trigger source to external trigger also set trigger polarity to rising edge"]
	#[doc = "(default setting for compatibility with some ADC on other STM32 families having this setting set by HW default value)."]
	#[doc = "In case of need to modify trigger edge, use function @ref LL_ADC_INJ_SetTriggerEdge()."]
	#[doc = ""]
	#[doc = "This feature can be modified afterwards using unitary function @ref LL_ADC_INJ_SetTriggerSource()."]
	pub TriggerSource: u32,
	#[doc = "< Set ADC group injected sequencer length."]
	#[doc = "This parameter can be a value of @ref ADC_LL_EC_INJ_SEQ_SCAN_LENGTH"]
	#[doc = ""]
	#[doc = "This feature can be modified afterwards using unitary function @ref LL_ADC_INJ_SetSequencerLength()."]
	pub SequencerLength: u32,
	#[doc = "< Set ADC group injected sequencer discontinuous mode: sequence subdivided and scan conversions interrupted every selected number of ranks."]
	#[doc = "This parameter can be a value of @ref ADC_LL_EC_INJ_SEQ_DISCONT_MODE"]
	#[doc = "@note This parameter has an effect only if group injected sequencer is enabled"]
	#[doc = "(scan length of 2 ranks or more)."]
	#[doc = ""]
	#[doc = "This feature can be modified afterwards using unitary function @ref LL_ADC_INJ_SetSequencerDiscont()."]
	pub SequencerDiscont: u32,
	#[doc = "< Set ADC group injected conversion trigger: independent or from ADC group regular."]
	#[doc = "This parameter can be a value of @ref ADC_LL_EC_INJ_TRIG_AUTO"]
	#[doc = "Note: This parameter must be set to set to independent trigger if injected trigger source is set to an external trigger."]
	#[doc = ""]
	#[doc = "This feature can be modified afterwards using unitary function @ref LL_ADC_INJ_SetTrigAuto()."]
	pub TrigAuto: u32,
}
#[test]
fn bindgen_test_layout_LL_ADC_INJ_InitTypeDef() {
	assert_eq!(
	           ::core::mem::size_of::<LL_ADC_INJ_InitTypeDef>(),
	           16usize,
	           concat!("Size of: ", stringify!(LL_ADC_INJ_InitTypeDef))
	);
	assert_eq!(
	           ::core::mem::align_of::<LL_ADC_INJ_InitTypeDef>(),
	           4usize,
	           concat!("Alignment of ", stringify!(LL_ADC_INJ_InitTypeDef))
	);
	fn test_field_TriggerSource() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_ADC_INJ_InitTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).TriggerSource) as usize - ptr as usize
		           },
		           0usize,
		           concat!(
			"Offset of field: ",
			stringify!(LL_ADC_INJ_InitTypeDef),
			"::",
			stringify!(TriggerSource)
		)
		);
	}
	test_field_TriggerSource();
	fn test_field_SequencerLength() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_ADC_INJ_InitTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).SequencerLength) as usize - ptr as usize
		           },
		           4usize,
		           concat!(
			"Offset of field: ",
			stringify!(LL_ADC_INJ_InitTypeDef),
			"::",
			stringify!(SequencerLength)
		)
		);
	}
	test_field_SequencerLength();
	fn test_field_SequencerDiscont() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_ADC_INJ_InitTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).SequencerDiscont) as usize - ptr as usize
		           },
		           8usize,
		           concat!(
			"Offset of field: ",
			stringify!(LL_ADC_INJ_InitTypeDef),
			"::",
			stringify!(SequencerDiscont)
		)
		);
	}
	test_field_SequencerDiscont();
	fn test_field_TrigAuto() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_ADC_INJ_InitTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).TrigAuto) as usize - ptr as usize
		           },
		           12usize,
		           concat!(
			"Offset of field: ",
			stringify!(LL_ADC_INJ_InitTypeDef),
			"::",
			stringify!(TrigAuto)
		)
		);
	}
	test_field_TrigAuto();
}
extern "C" {
	#[doc = " @defgroup ADC_LL_EF_Init Initialization and de-initialization functions"]
	#[doc = " @{"]
	pub fn LL_ADC_CommonDeInit(ADCxy_COMMON: *mut ADC_Common_TypeDef) -> ErrorStatus;
}
extern "C" {
	pub fn LL_ADC_CommonInit(ADCxy_COMMON: *mut ADC_Common_TypeDef,
	                         ADC_CommonInitStruct: *mut LL_ADC_CommonInitTypeDef)
	                         -> ErrorStatus;
}
extern "C" {
	pub fn LL_ADC_CommonStructInit(ADC_CommonInitStruct: *mut LL_ADC_CommonInitTypeDef);
}
extern "C" {
	pub fn LL_ADC_DeInit(ADCx: *mut ADC_TypeDef) -> ErrorStatus;
}
extern "C" {
	pub fn LL_ADC_Init(ADCx: *mut ADC_TypeDef, ADC_InitStruct: *mut LL_ADC_InitTypeDef) -> ErrorStatus;
}
extern "C" {
	pub fn LL_ADC_StructInit(ADC_InitStruct: *mut LL_ADC_InitTypeDef);
}
extern "C" {
	pub fn LL_ADC_REG_Init(ADCx: *mut ADC_TypeDef, ADC_REG_InitStruct: *mut LL_ADC_REG_InitTypeDef) -> ErrorStatus;
}
extern "C" {
	pub fn LL_ADC_REG_StructInit(ADC_REG_InitStruct: *mut LL_ADC_REG_InitTypeDef);
}
extern "C" {
	pub fn LL_ADC_INJ_Init(ADCx: *mut ADC_TypeDef, ADC_INJ_InitStruct: *mut LL_ADC_INJ_InitTypeDef) -> ErrorStatus;
}
extern "C" {
	pub fn LL_ADC_INJ_StructInit(ADC_INJ_InitStruct: *mut LL_ADC_INJ_InitTypeDef);
}
#[doc = " @brief  Structure definition of some features of COMP instance."]
#[repr(C)]
pub struct LL_COMP_InitTypeDef {
	#[doc = "< Set comparator operating mode to adjust power and speed."]
	#[doc = "This parameter can be a value of @ref COMP_LL_EC_POWERMODE"]
	#[doc = ""]
	#[doc = "This feature can be modified afterwards using unitary function @ref LL_COMP_SetPowerMode()."]
	pub PowerMode: u32,
	#[doc = "< Set comparator input plus (non-inverting input)."]
	#[doc = "This parameter can be a value of @ref COMP_LL_EC_INPUT_PLUS"]
	#[doc = ""]
	#[doc = "This feature can be modified afterwards using unitary function @ref LL_COMP_SetInputPlus()."]
	pub InputPlus: u32,
	#[doc = "< Set comparator input minus (inverting input)."]
	#[doc = "This parameter can be a value of @ref COMP_LL_EC_INPUT_MINUS"]
	#[doc = ""]
	#[doc = "This feature can be modified afterwards using unitary function @ref LL_COMP_SetInputMinus()."]
	pub InputMinus: u32,
	#[doc = "< Set comparator hysteresis mode of the input minus."]
	#[doc = "This parameter can be a value of @ref COMP_LL_EC_INPUT_HYSTERESIS"]
	#[doc = ""]
	#[doc = "This feature can be modified afterwards using unitary function @ref LL_COMP_SetInputHysteresis()."]
	pub InputHysteresis: u32,
	#[doc = "< Set comparator output polarity."]
	#[doc = "This parameter can be a value of @ref COMP_LL_EC_OUTPUT_POLARITY"]
	#[doc = ""]
	#[doc = "This feature can be modified afterwards using unitary function @ref LL_COMP_SetOutputPolarity()."]
	pub OutputPolarity: u32,
	#[doc = "< Set comparator blanking source."]
	#[doc = "This parameter can be a value of @ref COMP_LL_EC_OUTPUT_BLANKING_SOURCE"]
	#[doc = ""]
	#[doc = "This feature can be modified afterwards using unitary function @ref LL_COMP_SetOutputBlankingSource()."]
	pub OutputBlankingSource: u32,
}
#[test]
fn bindgen_test_layout_LL_COMP_InitTypeDef() {
	assert_eq!(
	           ::core::mem::size_of::<LL_COMP_InitTypeDef>(),
	           24usize,
	           concat!("Size of: ", stringify!(LL_COMP_InitTypeDef))
	);
	assert_eq!(
	           ::core::mem::align_of::<LL_COMP_InitTypeDef>(),
	           4usize,
	           concat!("Alignment of ", stringify!(LL_COMP_InitTypeDef))
	);
	fn test_field_PowerMode() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_COMP_InitTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).PowerMode) as usize - ptr as usize
		           },
		           0usize,
		           concat!(
			"Offset of field: ",
			stringify!(LL_COMP_InitTypeDef),
			"::",
			stringify!(PowerMode)
		)
		);
	}
	test_field_PowerMode();
	fn test_field_InputPlus() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_COMP_InitTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).InputPlus) as usize - ptr as usize
		           },
		           4usize,
		           concat!(
			"Offset of field: ",
			stringify!(LL_COMP_InitTypeDef),
			"::",
			stringify!(InputPlus)
		)
		);
	}
	test_field_InputPlus();
	fn test_field_InputMinus() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_COMP_InitTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).InputMinus) as usize - ptr as usize
		           },
		           8usize,
		           concat!(
			"Offset of field: ",
			stringify!(LL_COMP_InitTypeDef),
			"::",
			stringify!(InputMinus)
		)
		);
	}
	test_field_InputMinus();
	fn test_field_InputHysteresis() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_COMP_InitTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).InputHysteresis) as usize - ptr as usize
		           },
		           12usize,
		           concat!(
			"Offset of field: ",
			stringify!(LL_COMP_InitTypeDef),
			"::",
			stringify!(InputHysteresis)
		)
		);
	}
	test_field_InputHysteresis();
	fn test_field_OutputPolarity() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_COMP_InitTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).OutputPolarity) as usize - ptr as usize
		           },
		           16usize,
		           concat!(
			"Offset of field: ",
			stringify!(LL_COMP_InitTypeDef),
			"::",
			stringify!(OutputPolarity)
		)
		);
	}
	test_field_OutputPolarity();
	fn test_field_OutputBlankingSource() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_COMP_InitTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).OutputBlankingSource) as usize - ptr as usize
		           },
		           20usize,
		           concat!(
			"Offset of field: ",
			stringify!(LL_COMP_InitTypeDef),
			"::",
			stringify!(OutputBlankingSource)
		)
		);
	}
	test_field_OutputBlankingSource();
}
extern "C" {
	#[doc = " @defgroup COMP_LL_EF_Init Initialization and de-initialization functions"]
	#[doc = " @{"]
	pub fn LL_COMP_DeInit(COMPx: *mut COMP_TypeDef) -> ErrorStatus;
}
extern "C" {
	pub fn LL_COMP_Init(COMPx: *mut COMP_TypeDef, COMP_InitStruct: *mut LL_COMP_InitTypeDef) -> ErrorStatus;
}
extern "C" {
	pub fn LL_COMP_StructInit(COMP_InitStruct: *mut LL_COMP_InitTypeDef);
}
extern "C" {
	#[doc = " @defgroup CRC_LL_EF_Init Initialization and de-initialization functions"]
	#[doc = " @{"]
	pub fn LL_CRC_DeInit(CRCx: *mut CRC_TypeDef) -> ErrorStatus;
}
extern "C" {
	#[doc = " @defgroup CRS_LL_EF_Init Initialization and de-initialization functions"]
	#[doc = " @{"]
	pub fn LL_CRS_DeInit() -> ErrorStatus;
}
#[doc = " @defgroup DMA_LL_ES_INIT DMA Exported Init structure"]
#[doc = " @{"]
#[repr(C)]
pub struct LL_DMA_InitTypeDef {
	#[doc = "< Specifies the peripheral base address for DMA transfer"]
	#[doc = "or as Source base address in case of memory to memory transfer direction."]
	#[doc = ""]
	#[doc = "This parameter must be a value between Min_Data = 0 and Max_Data = 0xFFFFFFFF."]
	pub PeriphOrM2MSrcAddress: u32,
	#[doc = "< Specifies the memory base address for DMA transfer"]
	#[doc = "or as Destination base address in case of memory to memory transfer direction."]
	#[doc = ""]
	#[doc = "This parameter must be a value between Min_Data = 0 and Max_Data = 0xFFFFFFFF."]
	pub MemoryOrM2MDstAddress: u32,
	#[doc = "< Specifies if the data will be transferred from memory to peripheral,"]
	#[doc = "from memory to memory or from peripheral to memory."]
	#[doc = "This parameter can be a value of @ref DMA_LL_EC_DIRECTION"]
	#[doc = ""]
	#[doc = "This feature can be modified afterwards using unitary function @ref LL_DMA_SetDataTransferDirection()."]
	pub Direction: u32,
	#[doc = "< Specifies the normal or circular operation mode."]
	#[doc = "This parameter can be a value of @ref DMA_LL_EC_MODE"]
	#[doc = "@note: The circular buffer mode cannot be used if the memory to memory"]
	#[doc = "data transfer direction is configured on the selected Channel"]
	#[doc = ""]
	#[doc = "This feature can be modified afterwards using unitary function @ref LL_DMA_SetMode()."]
	pub Mode: u32,
	#[doc = "< Specifies whether the Peripheral address or Source address in case of memory to memory transfer direction"]
	#[doc = "is incremented or not."]
	#[doc = "This parameter can be a value of @ref DMA_LL_EC_PERIPH"]
	#[doc = ""]
	#[doc = "This feature can be modified afterwards using unitary function @ref LL_DMA_SetPeriphIncMode()."]
	pub PeriphOrM2MSrcIncMode: u32,
	#[doc = "< Specifies whether the Memory address or Destination address in case of memory to memory transfer direction"]
	#[doc = "is incremented or not."]
	#[doc = "This parameter can be a value of @ref DMA_LL_EC_MEMORY"]
	#[doc = ""]
	#[doc = "This feature can be modified afterwards using unitary function @ref LL_DMA_SetMemoryIncMode()."]
	pub MemoryOrM2MDstIncMode: u32,
	#[doc = "< Specifies the Peripheral data size alignment or Source data size alignment (byte, half word, word)"]
	#[doc = "in case of memory to memory transfer direction."]
	#[doc = "This parameter can be a value of @ref DMA_LL_EC_PDATAALIGN"]
	#[doc = ""]
	#[doc = "This feature can be modified afterwards using unitary function @ref LL_DMA_SetPeriphSize()."]
	pub PeriphOrM2MSrcDataSize: u32,
	#[doc = "< Specifies the Memory data size alignment or Destination data size alignment (byte, half word, word)"]
	#[doc = "in case of memory to memory transfer direction."]
	#[doc = "This parameter can be a value of @ref DMA_LL_EC_MDATAALIGN"]
	#[doc = ""]
	#[doc = "This feature can be modified afterwards using unitary function @ref LL_DMA_SetMemorySize()."]
	pub MemoryOrM2MDstDataSize: u32,
	#[doc = "< Specifies the number of data to transfer, in data unit."]
	#[doc = "The data unit is equal to the source buffer configuration set in PeripheralSize"]
	#[doc = "or MemorySize parameters depending in the transfer direction."]
	#[doc = "This parameter must be a value between Min_Data = 0 and Max_Data = 0x0000FFFF"]
	#[doc = ""]
	#[doc = "This feature can be modified afterwards using unitary function @ref LL_DMA_SetDataLength()."]
	pub NbData: u32,
	#[doc = "< Specifies the peripheral request."]
	#[doc = "This parameter can be a value of @ref DMAMUX_LL_EC_REQUEST"]
	#[doc = ""]
	#[doc = "This feature can be modified afterwards using unitary function @ref LL_DMA_SetPeriphRequest()."]
	pub PeriphRequest: u32,
	#[doc = "< Specifies the channel priority level."]
	#[doc = "This parameter can be a value of @ref DMA_LL_EC_PRIORITY"]
	#[doc = ""]
	#[doc = "This feature can be modified afterwards using unitary function @ref LL_DMA_SetChannelPriorityLevel()."]
	pub Priority: u32,
}
#[test]
fn bindgen_test_layout_LL_DMA_InitTypeDef() {
	assert_eq!(
	           ::core::mem::size_of::<LL_DMA_InitTypeDef>(),
	           44usize,
	           concat!("Size of: ", stringify!(LL_DMA_InitTypeDef))
	);
	assert_eq!(
	           ::core::mem::align_of::<LL_DMA_InitTypeDef>(),
	           4usize,
	           concat!("Alignment of ", stringify!(LL_DMA_InitTypeDef))
	);
	fn test_field_PeriphOrM2MSrcAddress() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_DMA_InitTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).PeriphOrM2MSrcAddress) as usize - ptr as usize
		           },
		           0usize,
		           concat!(
			"Offset of field: ",
			stringify!(LL_DMA_InitTypeDef),
			"::",
			stringify!(PeriphOrM2MSrcAddress)
		)
		);
	}
	test_field_PeriphOrM2MSrcAddress();
	fn test_field_MemoryOrM2MDstAddress() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_DMA_InitTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).MemoryOrM2MDstAddress) as usize - ptr as usize
		           },
		           4usize,
		           concat!(
			"Offset of field: ",
			stringify!(LL_DMA_InitTypeDef),
			"::",
			stringify!(MemoryOrM2MDstAddress)
		)
		);
	}
	test_field_MemoryOrM2MDstAddress();
	fn test_field_Direction() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_DMA_InitTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).Direction) as usize - ptr as usize
		           },
		           8usize,
		           concat!(
			"Offset of field: ",
			stringify!(LL_DMA_InitTypeDef),
			"::",
			stringify!(Direction)
		)
		);
	}
	test_field_Direction();
	fn test_field_Mode() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_DMA_InitTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).Mode) as usize - ptr as usize
		           },
		           12usize,
		           concat!("Offset of field: ", stringify!(LL_DMA_InitTypeDef), "::", stringify!(Mode))
		);
	}
	test_field_Mode();
	fn test_field_PeriphOrM2MSrcIncMode() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_DMA_InitTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).PeriphOrM2MSrcIncMode) as usize - ptr as usize
		           },
		           16usize,
		           concat!(
			"Offset of field: ",
			stringify!(LL_DMA_InitTypeDef),
			"::",
			stringify!(PeriphOrM2MSrcIncMode)
		)
		);
	}
	test_field_PeriphOrM2MSrcIncMode();
	fn test_field_MemoryOrM2MDstIncMode() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_DMA_InitTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).MemoryOrM2MDstIncMode) as usize - ptr as usize
		           },
		           20usize,
		           concat!(
			"Offset of field: ",
			stringify!(LL_DMA_InitTypeDef),
			"::",
			stringify!(MemoryOrM2MDstIncMode)
		)
		);
	}
	test_field_MemoryOrM2MDstIncMode();
	fn test_field_PeriphOrM2MSrcDataSize() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_DMA_InitTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).PeriphOrM2MSrcDataSize) as usize - ptr as usize
		           },
		           24usize,
		           concat!(
			"Offset of field: ",
			stringify!(LL_DMA_InitTypeDef),
			"::",
			stringify!(PeriphOrM2MSrcDataSize)
		)
		);
	}
	test_field_PeriphOrM2MSrcDataSize();
	fn test_field_MemoryOrM2MDstDataSize() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_DMA_InitTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).MemoryOrM2MDstDataSize) as usize - ptr as usize
		           },
		           28usize,
		           concat!(
			"Offset of field: ",
			stringify!(LL_DMA_InitTypeDef),
			"::",
			stringify!(MemoryOrM2MDstDataSize)
		)
		);
	}
	test_field_MemoryOrM2MDstDataSize();
	fn test_field_NbData() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_DMA_InitTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).NbData) as usize - ptr as usize
		           },
		           32usize,
		           concat!("Offset of field: ", stringify!(LL_DMA_InitTypeDef), "::", stringify!(NbData))
		);
	}
	test_field_NbData();
	fn test_field_PeriphRequest() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_DMA_InitTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).PeriphRequest) as usize - ptr as usize
		           },
		           36usize,
		           concat!(
			"Offset of field: ",
			stringify!(LL_DMA_InitTypeDef),
			"::",
			stringify!(PeriphRequest)
		)
		);
	}
	test_field_PeriphRequest();
	fn test_field_Priority() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_DMA_InitTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).Priority) as usize - ptr as usize
		           },
		           40usize,
		           concat!(
			"Offset of field: ",
			stringify!(LL_DMA_InitTypeDef),
			"::",
			stringify!(Priority)
		)
		);
	}
	test_field_Priority();
}
extern "C" {
	#[doc = " @defgroup DMA_LL_EF_Init Initialization and de-initialization functions"]
	#[doc = " @{"]
	pub fn LL_DMA_Init(DMAx: *mut DMA_TypeDef, Channel: u32, DMA_InitStruct: *mut LL_DMA_InitTypeDef) -> ErrorStatus;
}
extern "C" {
	pub fn LL_DMA_DeInit(DMAx: *mut DMA_TypeDef, Channel: u32) -> ErrorStatus;
}
extern "C" {
	pub fn LL_DMA_StructInit(DMA_InitStruct: *mut LL_DMA_InitTypeDef);
}
extern "C" {
	pub static LPUART_PRESCALER_TAB: [u16; 12usize];
}
#[doc = " @brief LL LPUART Init Structure definition"]
#[repr(C)]
pub struct LL_LPUART_InitTypeDef {
	#[doc = "< Specifies the Prescaler to compute the communication baud rate."]
	#[doc = "This parameter can be a value of @ref LPUART_LL_EC_PRESCALER."]
	#[doc = ""]
	#[doc = "This feature can be modified afterwards using unitary"]
	#[doc = "function @ref LL_LPUART_SetPrescaler()."]
	pub PrescalerValue: u32,
	#[doc = "< This field defines expected LPUART communication baud rate."]
	#[doc = ""]
	#[doc = "This feature can be modified afterwards using unitary"]
	#[doc = "function @ref LL_LPUART_SetBaudRate()."]
	pub BaudRate: u32,
	#[doc = "< Specifies the number of data bits transmitted or received in a frame."]
	#[doc = "This parameter can be a value of @ref LPUART_LL_EC_DATAWIDTH."]
	#[doc = ""]
	#[doc = "This feature can be modified afterwards using unitary"]
	#[doc = "function @ref LL_LPUART_SetDataWidth()."]
	pub DataWidth: u32,
	#[doc = "< Specifies the number of stop bits transmitted."]
	#[doc = "This parameter can be a value of @ref LPUART_LL_EC_STOPBITS."]
	#[doc = ""]
	#[doc = "This feature can be modified afterwards using unitary"]
	#[doc = "function @ref LL_LPUART_SetStopBitsLength()."]
	pub StopBits: u32,
	#[doc = "< Specifies the parity mode."]
	#[doc = "This parameter can be a value of @ref LPUART_LL_EC_PARITY."]
	#[doc = ""]
	#[doc = "This feature can be modified afterwards using unitary"]
	#[doc = "function @ref LL_LPUART_SetParity()."]
	pub Parity: u32,
	#[doc = "< Specifies whether the Receive and/or Transmit mode is enabled or disabled."]
	#[doc = "This parameter can be a value of @ref LPUART_LL_EC_DIRECTION."]
	#[doc = ""]
	#[doc = "This feature can be modified afterwards using unitary"]
	#[doc = "function @ref LL_LPUART_SetTransferDirection()."]
	pub TransferDirection: u32,
	#[doc = "< Specifies whether the hardware flow control mode is enabled or disabled."]
	#[doc = "This parameter can be a value of @ref LPUART_LL_EC_HWCONTROL."]
	#[doc = ""]
	#[doc = "This feature can be modified afterwards using unitary"]
	#[doc = "function @ref LL_LPUART_SetHWFlowCtrl()."]
	pub HardwareFlowControl: u32,
}
#[test]
fn bindgen_test_layout_LL_LPUART_InitTypeDef() {
	assert_eq!(
	           ::core::mem::size_of::<LL_LPUART_InitTypeDef>(),
	           28usize,
	           concat!("Size of: ", stringify!(LL_LPUART_InitTypeDef))
	);
	assert_eq!(
	           ::core::mem::align_of::<LL_LPUART_InitTypeDef>(),
	           4usize,
	           concat!("Alignment of ", stringify!(LL_LPUART_InitTypeDef))
	);
	fn test_field_PrescalerValue() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_LPUART_InitTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).PrescalerValue) as usize - ptr as usize
		           },
		           0usize,
		           concat!(
			"Offset of field: ",
			stringify!(LL_LPUART_InitTypeDef),
			"::",
			stringify!(PrescalerValue)
		)
		);
	}
	test_field_PrescalerValue();
	fn test_field_BaudRate() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_LPUART_InitTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).BaudRate) as usize - ptr as usize
		           },
		           4usize,
		           concat!(
			"Offset of field: ",
			stringify!(LL_LPUART_InitTypeDef),
			"::",
			stringify!(BaudRate)
		)
		);
	}
	test_field_BaudRate();
	fn test_field_DataWidth() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_LPUART_InitTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).DataWidth) as usize - ptr as usize
		           },
		           8usize,
		           concat!(
			"Offset of field: ",
			stringify!(LL_LPUART_InitTypeDef),
			"::",
			stringify!(DataWidth)
		)
		);
	}
	test_field_DataWidth();
	fn test_field_StopBits() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_LPUART_InitTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).StopBits) as usize - ptr as usize
		           },
		           12usize,
		           concat!(
			"Offset of field: ",
			stringify!(LL_LPUART_InitTypeDef),
			"::",
			stringify!(StopBits)
		)
		);
	}
	test_field_StopBits();
	fn test_field_Parity() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_LPUART_InitTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).Parity) as usize - ptr as usize
		           },
		           16usize,
		           concat!(
			"Offset of field: ",
			stringify!(LL_LPUART_InitTypeDef),
			"::",
			stringify!(Parity)
		)
		);
	}
	test_field_Parity();
	fn test_field_TransferDirection() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_LPUART_InitTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).TransferDirection) as usize - ptr as usize
		           },
		           20usize,
		           concat!(
			"Offset of field: ",
			stringify!(LL_LPUART_InitTypeDef),
			"::",
			stringify!(TransferDirection)
		)
		);
	}
	test_field_TransferDirection();
	fn test_field_HardwareFlowControl() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_LPUART_InitTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).HardwareFlowControl) as usize - ptr as usize
		           },
		           24usize,
		           concat!(
			"Offset of field: ",
			stringify!(LL_LPUART_InitTypeDef),
			"::",
			stringify!(HardwareFlowControl)
		)
		);
	}
	test_field_HardwareFlowControl();
}
extern "C" {
	#[doc = " @defgroup LPUART_LL_EF_Init Initialization and de-initialization functions"]
	#[doc = " @{"]
	pub fn LL_LPUART_DeInit(LPUARTx: *mut USART_TypeDef) -> ErrorStatus;
}
extern "C" {
	pub fn LL_LPUART_Init(LPUARTx: *mut USART_TypeDef, LPUART_InitStruct: *mut LL_LPUART_InitTypeDef) -> ErrorStatus;
}
extern "C" {
	pub fn LL_LPUART_StructInit(LPUART_InitStruct: *mut LL_LPUART_InitTypeDef);
}
#[doc = " @brief  PKA Init structures definition"]
#[repr(C)]
pub struct LL_PKA_InitTypeDef {
	#[doc = "< Specifies the PKA operation mode."]
	#[doc = "This parameter can be a value of @ref PKA_LL_EC_MODE."]
	#[doc = ""]
	#[doc = "This feature can be modified afterwards using unitary function @ref LL_PKA_SetMode()."]
	pub Mode: u32,
}
#[test]
fn bindgen_test_layout_LL_PKA_InitTypeDef() {
	assert_eq!(
	           ::core::mem::size_of::<LL_PKA_InitTypeDef>(),
	           4usize,
	           concat!("Size of: ", stringify!(LL_PKA_InitTypeDef))
	);
	assert_eq!(
	           ::core::mem::align_of::<LL_PKA_InitTypeDef>(),
	           4usize,
	           concat!("Alignment of ", stringify!(LL_PKA_InitTypeDef))
	);
	fn test_field_Mode() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_PKA_InitTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).Mode) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(LL_PKA_InitTypeDef), "::", stringify!(Mode))
		);
	}
	test_field_Mode();
}
extern "C" {
	#[doc = " @defgroup PKA_LL_EF_Init Initialization and de-initialization functions"]
	#[doc = " @{"]
	pub fn LL_PKA_DeInit(PKAx: *mut PKA_TypeDef) -> ErrorStatus;
}
extern "C" {
	pub fn LL_PKA_Init(PKAx: *mut PKA_TypeDef, PKA_InitStruct: *mut LL_PKA_InitTypeDef) -> ErrorStatus;
}
extern "C" {
	pub fn LL_PKA_StructInit(PKA_InitStruct: *mut LL_PKA_InitTypeDef);
}
extern "C" {
	#[doc = " @defgroup PWR_LL_EF_Init De-initialization function"]
	#[doc = " @{"]
	pub fn LL_PWR_DeInit() -> ErrorStatus;
}
#[doc = " @brief LL RNG Init Structure Definition"]
#[repr(C)]
pub struct LL_RNG_InitTypeDef {
	#[doc = "< Clock error detection."]
	#[doc = "This parameter can be one value of @ref RNG_LL_CED."]
	#[doc = ""]
	#[doc = "This parameter can be modified using unitary functions @ref LL_RNG_EnableClkErrorDetect()."]
	pub ClockErrorDetection: u32,
}
#[test]
fn bindgen_test_layout_LL_RNG_InitTypeDef() {
	assert_eq!(
	           ::core::mem::size_of::<LL_RNG_InitTypeDef>(),
	           4usize,
	           concat!("Size of: ", stringify!(LL_RNG_InitTypeDef))
	);
	assert_eq!(
	           ::core::mem::align_of::<LL_RNG_InitTypeDef>(),
	           4usize,
	           concat!("Alignment of ", stringify!(LL_RNG_InitTypeDef))
	);
	fn test_field_ClockErrorDetection() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_RNG_InitTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).ClockErrorDetection) as usize - ptr as usize
		           },
		           0usize,
		           concat!(
			"Offset of field: ",
			stringify!(LL_RNG_InitTypeDef),
			"::",
			stringify!(ClockErrorDetection)
		)
		);
	}
	test_field_ClockErrorDetection();
}
extern "C" {
	#[doc = " @defgroup RNG_LL_EF_Init Initialization and de-initialization functions"]
	#[doc = " @{"]
	pub fn LL_RNG_Init(RNGx: *mut RNG_TypeDef, RNG_InitStruct: *mut LL_RNG_InitTypeDef) -> ErrorStatus;
}
extern "C" {
	pub fn LL_RNG_StructInit(RNG_InitStruct: *mut LL_RNG_InitTypeDef);
}
extern "C" {
	pub fn LL_RNG_DeInit(RNGx: *mut RNG_TypeDef) -> ErrorStatus;
}
#[doc = " @brief  RTC Init structures definition"]
#[repr(C)]
pub struct LL_RTC_InitTypeDef {
	#[doc = "< Specifies the RTC Hours Format."]
	#[doc = "This parameter can be a value of @ref RTC_LL_EC_HOURFORMAT"]
	#[doc = ""]
	#[doc = "This feature can be modified afterwards using unitary function"]
	#[doc = "@ref LL_RTC_SetHourFormat()."]
	pub HourFormat: u32,
	#[doc = "< Specifies the RTC Asynchronous Predivider value."]
	#[doc = "This parameter must be a number between Min_Data = 0x00 and Max_Data = 0x7F"]
	#[doc = ""]
	#[doc = "This feature can be modified afterwards using unitary function"]
	#[doc = "@ref LL_RTC_SetAsynchPrescaler()."]
	pub AsynchPrescaler: u32,
	#[doc = "< Specifies the RTC Synchronous Predivider value."]
	#[doc = "This parameter must be a number between Min_Data = 0x00 and Max_Data = 0x7FFF"]
	#[doc = ""]
	#[doc = "This feature can be modified afterwards using unitary function"]
	#[doc = "@ref LL_RTC_SetSynchPrescaler()."]
	pub SynchPrescaler: u32,
}
#[test]
fn bindgen_test_layout_LL_RTC_InitTypeDef() {
	assert_eq!(
	           ::core::mem::size_of::<LL_RTC_InitTypeDef>(),
	           12usize,
	           concat!("Size of: ", stringify!(LL_RTC_InitTypeDef))
	);
	assert_eq!(
	           ::core::mem::align_of::<LL_RTC_InitTypeDef>(),
	           4usize,
	           concat!("Alignment of ", stringify!(LL_RTC_InitTypeDef))
	);
	fn test_field_HourFormat() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_RTC_InitTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).HourFormat) as usize - ptr as usize
		           },
		           0usize,
		           concat!(
			"Offset of field: ",
			stringify!(LL_RTC_InitTypeDef),
			"::",
			stringify!(HourFormat)
		)
		);
	}
	test_field_HourFormat();
	fn test_field_AsynchPrescaler() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_RTC_InitTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).AsynchPrescaler) as usize - ptr as usize
		           },
		           4usize,
		           concat!(
			"Offset of field: ",
			stringify!(LL_RTC_InitTypeDef),
			"::",
			stringify!(AsynchPrescaler)
		)
		);
	}
	test_field_AsynchPrescaler();
	fn test_field_SynchPrescaler() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_RTC_InitTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).SynchPrescaler) as usize - ptr as usize
		           },
		           8usize,
		           concat!(
			"Offset of field: ",
			stringify!(LL_RTC_InitTypeDef),
			"::",
			stringify!(SynchPrescaler)
		)
		);
	}
	test_field_SynchPrescaler();
}
#[doc = " @brief  RTC Time structure definition"]
#[repr(C)]
pub struct LL_RTC_TimeTypeDef {
	#[doc = "< Specifies the RTC AM/PM Time."]
	#[doc = "This parameter can be a value of @ref RTC_LL_EC_TIME_FORMAT"]
	#[doc = ""]
	#[doc = "This feature can be modified afterwards using unitary function @ref LL_RTC_TIME_SetFormat()."]
	pub TimeFormat: u32,
	#[doc = "< Specifies the RTC Time Hours."]
	#[doc = "This parameter must be a number between Min_Data = 0 and Max_Data = 12 if the @ref LL_RTC_TIME_FORMAT_PM is selected."]
	#[doc = "This parameter must be a number between Min_Data = 0 and Max_Data = 23 if the @ref LL_RTC_TIME_FORMAT_AM_OR_24 is selected."]
	#[doc = ""]
	#[doc = "This feature can be modified afterwards using unitary function @ref LL_RTC_TIME_SetHour()."]
	pub Hours: u8,
	#[doc = "< Specifies the RTC Time Minutes."]
	#[doc = "This parameter must be a number between Min_Data = 0 and Max_Data = 59"]
	#[doc = ""]
	#[doc = "This feature can be modified afterwards using unitary function @ref LL_RTC_TIME_SetMinute()."]
	pub Minutes: u8,
	#[doc = "< Specifies the RTC Time Seconds."]
	#[doc = "This parameter must be a number between Min_Data = 0 and Max_Data = 59"]
	#[doc = ""]
	#[doc = "This feature can be modified afterwards using unitary function @ref LL_RTC_TIME_SetSecond()."]
	pub Seconds: u8,
}
#[test]
fn bindgen_test_layout_LL_RTC_TimeTypeDef() {
	assert_eq!(
	           ::core::mem::size_of::<LL_RTC_TimeTypeDef>(),
	           8usize,
	           concat!("Size of: ", stringify!(LL_RTC_TimeTypeDef))
	);
	assert_eq!(
	           ::core::mem::align_of::<LL_RTC_TimeTypeDef>(),
	           4usize,
	           concat!("Alignment of ", stringify!(LL_RTC_TimeTypeDef))
	);
	fn test_field_TimeFormat() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_RTC_TimeTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).TimeFormat) as usize - ptr as usize
		           },
		           0usize,
		           concat!(
			"Offset of field: ",
			stringify!(LL_RTC_TimeTypeDef),
			"::",
			stringify!(TimeFormat)
		)
		);
	}
	test_field_TimeFormat();
	fn test_field_Hours() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_RTC_TimeTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).Hours) as usize - ptr as usize
		           },
		           4usize,
		           concat!("Offset of field: ", stringify!(LL_RTC_TimeTypeDef), "::", stringify!(Hours))
		);
	}
	test_field_Hours();
	fn test_field_Minutes() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_RTC_TimeTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).Minutes) as usize - ptr as usize
		           },
		           5usize,
		           concat!("Offset of field: ", stringify!(LL_RTC_TimeTypeDef), "::", stringify!(Minutes))
		);
	}
	test_field_Minutes();
	fn test_field_Seconds() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_RTC_TimeTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).Seconds) as usize - ptr as usize
		           },
		           6usize,
		           concat!("Offset of field: ", stringify!(LL_RTC_TimeTypeDef), "::", stringify!(Seconds))
		);
	}
	test_field_Seconds();
}
#[doc = " @brief  RTC Date structure definition"]
#[repr(C)]
pub struct LL_RTC_DateTypeDef {
	#[doc = "< Specifies the RTC Date WeekDay."]
	#[doc = "This parameter can be a value of @ref RTC_LL_EC_WEEKDAY"]
	#[doc = ""]
	#[doc = "This feature can be modified afterwards using unitary function @ref LL_RTC_DATE_SetWeekDay()."]
	pub WeekDay: u8,
	#[doc = "< Specifies the RTC Date Month."]
	#[doc = "This parameter can be a value of @ref RTC_LL_EC_MONTH"]
	#[doc = ""]
	#[doc = "This feature can be modified afterwards using unitary function @ref LL_RTC_DATE_SetMonth()."]
	pub Month: u8,
	#[doc = "< Specifies the RTC Date Day."]
	#[doc = "This parameter must be a number between Min_Data = 1 and Max_Data = 31"]
	#[doc = ""]
	#[doc = "This feature can be modified afterwards using unitary function @ref LL_RTC_DATE_SetDay()."]
	pub Day: u8,
	#[doc = "< Specifies the RTC Date Year."]
	#[doc = "This parameter must be a number between Min_Data = 0 and Max_Data = 99"]
	#[doc = ""]
	#[doc = "This feature can be modified afterwards using unitary function @ref LL_RTC_DATE_SetYear()."]
	pub Year: u8,
}
#[test]
fn bindgen_test_layout_LL_RTC_DateTypeDef() {
	assert_eq!(
	           ::core::mem::size_of::<LL_RTC_DateTypeDef>(),
	           4usize,
	           concat!("Size of: ", stringify!(LL_RTC_DateTypeDef))
	);
	assert_eq!(
	           ::core::mem::align_of::<LL_RTC_DateTypeDef>(),
	           1usize,
	           concat!("Alignment of ", stringify!(LL_RTC_DateTypeDef))
	);
	fn test_field_WeekDay() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_RTC_DateTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).WeekDay) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(LL_RTC_DateTypeDef), "::", stringify!(WeekDay))
		);
	}
	test_field_WeekDay();
	fn test_field_Month() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_RTC_DateTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).Month) as usize - ptr as usize
		           },
		           1usize,
		           concat!("Offset of field: ", stringify!(LL_RTC_DateTypeDef), "::", stringify!(Month))
		);
	}
	test_field_Month();
	fn test_field_Day() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_RTC_DateTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).Day) as usize - ptr as usize
		           },
		           2usize,
		           concat!("Offset of field: ", stringify!(LL_RTC_DateTypeDef), "::", stringify!(Day))
		);
	}
	test_field_Day();
	fn test_field_Year() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_RTC_DateTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).Year) as usize - ptr as usize
		           },
		           3usize,
		           concat!("Offset of field: ", stringify!(LL_RTC_DateTypeDef), "::", stringify!(Year))
		);
	}
	test_field_Year();
}
#[doc = " @brief  RTC Alarm structure definition"]
#[repr(C)]
pub struct LL_RTC_AlarmTypeDef {
	#[doc = "< Specifies the RTC Alarm Time members."]
	pub AlarmTime: LL_RTC_TimeTypeDef,
	#[doc = "< Specifies the RTC Alarm Masks."]
	#[doc = "This parameter can be a value of @ref RTC_LL_EC_ALMA_MASK for ALARM A or @ref RTC_LL_EC_ALMB_MASK for ALARM B."]
	#[doc = ""]
	#[doc = "This feature can be modified afterwards using unitary function @ref LL_RTC_ALMA_SetMask() for ALARM A"]
	#[doc = "or @ref LL_RTC_ALMB_SetMask() for ALARM B"]
	pub AlarmMask: u32,
	#[doc = "< Specifies the RTC Alarm is on day or WeekDay."]
	#[doc = "This parameter can be a value of @ref RTC_LL_EC_ALMA_WEEKDAY_SELECTION for ALARM A or @ref RTC_LL_EC_ALMB_WEEKDAY_SELECTION for ALARM B"]
	#[doc = ""]
	#[doc = "This feature can be modified afterwards using unitary function @ref LL_RTC_ALMA_EnableWeekday() or @ref LL_RTC_ALMA_DisableWeekday()"]
	#[doc = "for ALARM A or @ref LL_RTC_ALMB_EnableWeekday() or @ref LL_RTC_ALMB_DisableWeekday() for ALARM B"]
	pub AlarmDateWeekDaySel: u32,
	#[doc = "< Specifies the RTC Alarm Day/WeekDay."]
	#[doc = "If AlarmDateWeekDaySel set to day, this parameter  must be a number between Min_Data = 1 and Max_Data = 31."]
	#[doc = ""]
	#[doc = "This feature can be modified afterwards using unitary function @ref LL_RTC_ALMA_SetDay()"]
	#[doc = "for ALARM A or @ref LL_RTC_ALMB_SetDay() for ALARM B."]
	#[doc = ""]
	#[doc = "If AlarmDateWeekDaySel set to Weekday, this parameter can be a value of @ref RTC_LL_EC_WEEKDAY."]
	#[doc = ""]
	#[doc = "This feature can be modified afterwards using unitary function @ref LL_RTC_ALMA_SetWeekDay()"]
	#[doc = "for ALARM A or @ref LL_RTC_ALMB_SetWeekDay() for ALARM B."]
	pub AlarmDateWeekDay: u8,
}
#[test]
fn bindgen_test_layout_LL_RTC_AlarmTypeDef() {
	assert_eq!(
	           ::core::mem::size_of::<LL_RTC_AlarmTypeDef>(),
	           20usize,
	           concat!("Size of: ", stringify!(LL_RTC_AlarmTypeDef))
	);
	assert_eq!(
	           ::core::mem::align_of::<LL_RTC_AlarmTypeDef>(),
	           4usize,
	           concat!("Alignment of ", stringify!(LL_RTC_AlarmTypeDef))
	);
	fn test_field_AlarmTime() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_RTC_AlarmTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).AlarmTime) as usize - ptr as usize
		           },
		           0usize,
		           concat!(
			"Offset of field: ",
			stringify!(LL_RTC_AlarmTypeDef),
			"::",
			stringify!(AlarmTime)
		)
		);
	}
	test_field_AlarmTime();
	fn test_field_AlarmMask() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_RTC_AlarmTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).AlarmMask) as usize - ptr as usize
		           },
		           8usize,
		           concat!(
			"Offset of field: ",
			stringify!(LL_RTC_AlarmTypeDef),
			"::",
			stringify!(AlarmMask)
		)
		);
	}
	test_field_AlarmMask();
	fn test_field_AlarmDateWeekDaySel() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_RTC_AlarmTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).AlarmDateWeekDaySel) as usize - ptr as usize
		           },
		           12usize,
		           concat!(
			"Offset of field: ",
			stringify!(LL_RTC_AlarmTypeDef),
			"::",
			stringify!(AlarmDateWeekDaySel)
		)
		);
	}
	test_field_AlarmDateWeekDaySel();
	fn test_field_AlarmDateWeekDay() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_RTC_AlarmTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).AlarmDateWeekDay) as usize - ptr as usize
		           },
		           16usize,
		           concat!(
			"Offset of field: ",
			stringify!(LL_RTC_AlarmTypeDef),
			"::",
			stringify!(AlarmDateWeekDay)
		)
		);
	}
	test_field_AlarmDateWeekDay();
}
extern "C" {
	#[doc = " @defgroup RTC_LL_EF_Init Initialization and de-initialization functions"]
	#[doc = " @{"]
	pub fn LL_RTC_DeInit(RTCx: *mut RTC_TypeDef) -> ErrorStatus;
}
extern "C" {
	pub fn LL_RTC_Init(RTCx: *mut RTC_TypeDef, RTC_InitStruct: *mut LL_RTC_InitTypeDef) -> ErrorStatus;
}
extern "C" {
	pub fn LL_RTC_StructInit(RTC_InitStruct: *mut LL_RTC_InitTypeDef);
}
extern "C" {
	pub fn LL_RTC_TIME_Init(RTCx: *mut RTC_TypeDef, RTC_Format: u32, RTC_TimeStruct: *mut LL_RTC_TimeTypeDef) -> ErrorStatus;
}
extern "C" {
	pub fn LL_RTC_TIME_StructInit(RTC_TimeStruct: *mut LL_RTC_TimeTypeDef);
}
extern "C" {
	pub fn LL_RTC_DATE_Init(RTCx: *mut RTC_TypeDef, RTC_Format: u32, RTC_DateStruct: *mut LL_RTC_DateTypeDef) -> ErrorStatus;
}
extern "C" {
	pub fn LL_RTC_DATE_StructInit(RTC_DateStruct: *mut LL_RTC_DateTypeDef);
}
extern "C" {
	pub fn LL_RTC_ALMA_Init(RTCx: *mut RTC_TypeDef, RTC_Format: u32, RTC_AlarmStruct: *mut LL_RTC_AlarmTypeDef) -> ErrorStatus;
}
extern "C" {
	pub fn LL_RTC_ALMB_Init(RTCx: *mut RTC_TypeDef, RTC_Format: u32, RTC_AlarmStruct: *mut LL_RTC_AlarmTypeDef) -> ErrorStatus;
}
extern "C" {
	pub fn LL_RTC_ALMA_StructInit(RTC_AlarmStruct: *mut LL_RTC_AlarmTypeDef);
}
extern "C" {
	pub fn LL_RTC_ALMB_StructInit(RTC_AlarmStruct: *mut LL_RTC_AlarmTypeDef);
}
extern "C" {
	pub fn LL_RTC_EnterInitMode(RTCx: *mut RTC_TypeDef) -> ErrorStatus;
}
extern "C" {
	pub fn LL_RTC_ExitInitMode(RTCx: *mut RTC_TypeDef) -> ErrorStatus;
}
extern "C" {
	pub fn LL_RTC_WaitForSynchro(RTCx: *mut RTC_TypeDef) -> ErrorStatus;
}
extern "C" {
	pub static USART_PRESCALER_TAB: [u16; 12usize];
}
#[doc = " @brief LL USART Init Structure definition"]
#[repr(C)]
pub struct LL_USART_InitTypeDef {
	#[doc = "< Specifies the Prescaler to compute the communication baud rate."]
	#[doc = "This parameter can be a value of @ref USART_LL_EC_PRESCALER."]
	#[doc = ""]
	#[doc = "This feature can be modified afterwards using unitary"]
	#[doc = "function @ref LL_USART_SetPrescaler()."]
	pub PrescalerValue: u32,
	#[doc = "< This field defines expected Usart communication baud rate."]
	#[doc = ""]
	#[doc = "This feature can be modified afterwards using unitary"]
	#[doc = "function @ref LL_USART_SetBaudRate()."]
	pub BaudRate: u32,
	#[doc = "< Specifies the number of data bits transmitted or received in a frame."]
	#[doc = "This parameter can be a value of @ref USART_LL_EC_DATAWIDTH."]
	#[doc = ""]
	#[doc = "This feature can be modified afterwards using unitary"]
	#[doc = "function @ref LL_USART_SetDataWidth()."]
	pub DataWidth: u32,
	#[doc = "< Specifies the number of stop bits transmitted."]
	#[doc = "This parameter can be a value of @ref USART_LL_EC_STOPBITS."]
	#[doc = ""]
	#[doc = "This feature can be modified afterwards using unitary"]
	#[doc = "function @ref LL_USART_SetStopBitsLength()."]
	pub StopBits: u32,
	#[doc = "< Specifies the parity mode."]
	#[doc = "This parameter can be a value of @ref USART_LL_EC_PARITY."]
	#[doc = ""]
	#[doc = "This feature can be modified afterwards using unitary"]
	#[doc = "function @ref LL_USART_SetParity()."]
	pub Parity: u32,
	#[doc = "< Specifies whether the Receive and/or Transmit mode is enabled or disabled."]
	#[doc = "This parameter can be a value of @ref USART_LL_EC_DIRECTION."]
	#[doc = ""]
	#[doc = "This feature can be modified afterwards using unitary"]
	#[doc = "function @ref LL_USART_SetTransferDirection()."]
	pub TransferDirection: u32,
	#[doc = "< Specifies whether the hardware flow control mode is enabled or disabled."]
	#[doc = "This parameter can be a value of @ref USART_LL_EC_HWCONTROL."]
	#[doc = ""]
	#[doc = "This feature can be modified afterwards using unitary"]
	#[doc = "function @ref LL_USART_SetHWFlowCtrl()."]
	pub HardwareFlowControl: u32,
	#[doc = "< Specifies whether USART oversampling mode is 16 or 8."]
	#[doc = "This parameter can be a value of @ref USART_LL_EC_OVERSAMPLING."]
	#[doc = ""]
	#[doc = "This feature can be modified afterwards using unitary"]
	#[doc = "function @ref LL_USART_SetOverSampling()."]
	pub OverSampling: u32,
}
#[test]
fn bindgen_test_layout_LL_USART_InitTypeDef() {
	assert_eq!(
	           ::core::mem::size_of::<LL_USART_InitTypeDef>(),
	           32usize,
	           concat!("Size of: ", stringify!(LL_USART_InitTypeDef))
	);
	assert_eq!(
	           ::core::mem::align_of::<LL_USART_InitTypeDef>(),
	           4usize,
	           concat!("Alignment of ", stringify!(LL_USART_InitTypeDef))
	);
	fn test_field_PrescalerValue() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_USART_InitTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).PrescalerValue) as usize - ptr as usize
		           },
		           0usize,
		           concat!(
			"Offset of field: ",
			stringify!(LL_USART_InitTypeDef),
			"::",
			stringify!(PrescalerValue)
		)
		);
	}
	test_field_PrescalerValue();
	fn test_field_BaudRate() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_USART_InitTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).BaudRate) as usize - ptr as usize
		           },
		           4usize,
		           concat!(
			"Offset of field: ",
			stringify!(LL_USART_InitTypeDef),
			"::",
			stringify!(BaudRate)
		)
		);
	}
	test_field_BaudRate();
	fn test_field_DataWidth() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_USART_InitTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).DataWidth) as usize - ptr as usize
		           },
		           8usize,
		           concat!(
			"Offset of field: ",
			stringify!(LL_USART_InitTypeDef),
			"::",
			stringify!(DataWidth)
		)
		);
	}
	test_field_DataWidth();
	fn test_field_StopBits() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_USART_InitTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).StopBits) as usize - ptr as usize
		           },
		           12usize,
		           concat!(
			"Offset of field: ",
			stringify!(LL_USART_InitTypeDef),
			"::",
			stringify!(StopBits)
		)
		);
	}
	test_field_StopBits();
	fn test_field_Parity() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_USART_InitTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).Parity) as usize - ptr as usize
		           },
		           16usize,
		           concat!(
			"Offset of field: ",
			stringify!(LL_USART_InitTypeDef),
			"::",
			stringify!(Parity)
		)
		);
	}
	test_field_Parity();
	fn test_field_TransferDirection() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_USART_InitTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).TransferDirection) as usize - ptr as usize
		           },
		           20usize,
		           concat!(
			"Offset of field: ",
			stringify!(LL_USART_InitTypeDef),
			"::",
			stringify!(TransferDirection)
		)
		);
	}
	test_field_TransferDirection();
	fn test_field_HardwareFlowControl() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_USART_InitTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).HardwareFlowControl) as usize - ptr as usize
		           },
		           24usize,
		           concat!(
			"Offset of field: ",
			stringify!(LL_USART_InitTypeDef),
			"::",
			stringify!(HardwareFlowControl)
		)
		);
	}
	test_field_HardwareFlowControl();
	fn test_field_OverSampling() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_USART_InitTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).OverSampling) as usize - ptr as usize
		           },
		           28usize,
		           concat!(
			"Offset of field: ",
			stringify!(LL_USART_InitTypeDef),
			"::",
			stringify!(OverSampling)
		)
		);
	}
	test_field_OverSampling();
}
#[doc = " @brief LL USART Clock Init Structure definition"]
#[repr(C)]
pub struct LL_USART_ClockInitTypeDef {
	#[doc = "< Specifies whether the USART clock is enabled or disabled."]
	#[doc = "This parameter can be a value of @ref USART_LL_EC_CLOCK."]
	#[doc = ""]
	#[doc = "USART HW configuration can be modified afterwards using unitary functions"]
	#[doc = "@ref LL_USART_EnableSCLKOutput() or @ref LL_USART_DisableSCLKOutput()."]
	#[doc = "For more details, refer to description of this function."]
	pub ClockOutput: u32,
	#[doc = "< Specifies the steady state of the serial clock."]
	#[doc = "This parameter can be a value of @ref USART_LL_EC_POLARITY."]
	#[doc = ""]
	#[doc = "USART HW configuration can be modified afterwards using unitary"]
	#[doc = "functions @ref LL_USART_SetClockPolarity()."]
	#[doc = "For more details, refer to description of this function."]
	pub ClockPolarity: u32,
	#[doc = "< Specifies the clock transition on which the bit capture is made."]
	#[doc = "This parameter can be a value of @ref USART_LL_EC_PHASE."]
	#[doc = ""]
	#[doc = "USART HW configuration can be modified afterwards using unitary"]
	#[doc = "functions @ref LL_USART_SetClockPhase()."]
	#[doc = "For more details, refer to description of this function."]
	pub ClockPhase: u32,
	#[doc = "< Specifies whether the clock pulse corresponding to the last transmitted"]
	#[doc = "data bit (MSB) has to be output on the SCLK pin in synchronous mode."]
	#[doc = "This parameter can be a value of @ref USART_LL_EC_LASTCLKPULSE."]
	#[doc = ""]
	#[doc = "USART HW configuration can be modified afterwards using unitary"]
	#[doc = "functions @ref LL_USART_SetLastClkPulseOutput()."]
	#[doc = "For more details, refer to description of this function."]
	pub LastBitClockPulse: u32,
}
#[test]
fn bindgen_test_layout_LL_USART_ClockInitTypeDef() {
	assert_eq!(
	           ::core::mem::size_of::<LL_USART_ClockInitTypeDef>(),
	           16usize,
	           concat!("Size of: ", stringify!(LL_USART_ClockInitTypeDef))
	);
	assert_eq!(
	           ::core::mem::align_of::<LL_USART_ClockInitTypeDef>(),
	           4usize,
	           concat!("Alignment of ", stringify!(LL_USART_ClockInitTypeDef))
	);
	fn test_field_ClockOutput() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_USART_ClockInitTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).ClockOutput) as usize - ptr as usize
		           },
		           0usize,
		           concat!(
			"Offset of field: ",
			stringify!(LL_USART_ClockInitTypeDef),
			"::",
			stringify!(ClockOutput)
		)
		);
	}
	test_field_ClockOutput();
	fn test_field_ClockPolarity() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_USART_ClockInitTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).ClockPolarity) as usize - ptr as usize
		           },
		           4usize,
		           concat!(
			"Offset of field: ",
			stringify!(LL_USART_ClockInitTypeDef),
			"::",
			stringify!(ClockPolarity)
		)
		);
	}
	test_field_ClockPolarity();
	fn test_field_ClockPhase() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_USART_ClockInitTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).ClockPhase) as usize - ptr as usize
		           },
		           8usize,
		           concat!(
			"Offset of field: ",
			stringify!(LL_USART_ClockInitTypeDef),
			"::",
			stringify!(ClockPhase)
		)
		);
	}
	test_field_ClockPhase();
	fn test_field_LastBitClockPulse() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_USART_ClockInitTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).LastBitClockPulse) as usize - ptr as usize
		           },
		           12usize,
		           concat!(
			"Offset of field: ",
			stringify!(LL_USART_ClockInitTypeDef),
			"::",
			stringify!(LastBitClockPulse)
		)
		);
	}
	test_field_LastBitClockPulse();
}
extern "C" {
	#[doc = " @defgroup USART_LL_EF_Init Initialization and de-initialization functions"]
	#[doc = " @{"]
	pub fn LL_USART_DeInit(USARTx: *mut USART_TypeDef) -> ErrorStatus;
}
extern "C" {
	pub fn LL_USART_Init(USARTx: *mut USART_TypeDef, USART_InitStruct: *mut LL_USART_InitTypeDef) -> ErrorStatus;
}
extern "C" {
	pub fn LL_USART_StructInit(USART_InitStruct: *mut LL_USART_InitTypeDef);
}
extern "C" {
	pub fn LL_USART_ClockInit(USARTx: *mut USART_TypeDef, USART_ClockInitStruct: *mut LL_USART_ClockInitTypeDef) -> ErrorStatus;
}
extern "C" {
	pub fn LL_USART_ClockStructInit(USART_ClockInitStruct: *mut LL_USART_ClockInitTypeDef);
}
#[doc = " @defgroup UTILS_LL_ES_INIT UTILS Exported structures"]
#[doc = " @{"]
#[doc = " @brief  UTILS PLL structure definition"]
#[repr(C)]
pub struct LL_UTILS_PLLInitTypeDef {
	#[doc = "< Division factor for PLL VCO input clock."]
	#[doc = "This parameter can be a value of @ref RCC_LL_EC_PLLM_DIV."]
	#[doc = ""]
	#[doc = "This feature can be modified afterwards using unitary function"]
	#[doc = "@ref LL_RCC_PLL_ConfigDomain_SYS()."]
	pub PLLM: u32,
	#[doc = "< Multiplication factor for PLL VCO output clock."]
	#[doc = "This parameter must be a number between Min_Data = 6 and Max_Data = 127."]
	#[doc = ""]
	#[doc = "This feature can be modified afterwards using unitary function"]
	#[doc = "@ref LL_RCC_PLL_ConfigDomain_SYS()."]
	pub PLLN: u32,
	#[doc = "< Division for the main system clock."]
	#[doc = "This parameter can be a value of @ref RCC_LL_EC_PLLR_DIV."]
	#[doc = ""]
	#[doc = "This feature can be modified afterwards using unitary function"]
	#[doc = "@ref LL_RCC_PLL_ConfigDomain_SYS()."]
	pub PLLR: u32,
}
#[test]
fn bindgen_test_layout_LL_UTILS_PLLInitTypeDef() {
	assert_eq!(
	           ::core::mem::size_of::<LL_UTILS_PLLInitTypeDef>(),
	           12usize,
	           concat!("Size of: ", stringify!(LL_UTILS_PLLInitTypeDef))
	);
	assert_eq!(
	           ::core::mem::align_of::<LL_UTILS_PLLInitTypeDef>(),
	           4usize,
	           concat!("Alignment of ", stringify!(LL_UTILS_PLLInitTypeDef))
	);
	fn test_field_PLLM() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_UTILS_PLLInitTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).PLLM) as usize - ptr as usize
		           },
		           0usize,
		           concat!(
			"Offset of field: ",
			stringify!(LL_UTILS_PLLInitTypeDef),
			"::",
			stringify!(PLLM)
		)
		);
	}
	test_field_PLLM();
	fn test_field_PLLN() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_UTILS_PLLInitTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).PLLN) as usize - ptr as usize
		           },
		           4usize,
		           concat!(
			"Offset of field: ",
			stringify!(LL_UTILS_PLLInitTypeDef),
			"::",
			stringify!(PLLN)
		)
		);
	}
	test_field_PLLN();
	fn test_field_PLLR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_UTILS_PLLInitTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).PLLR) as usize - ptr as usize
		           },
		           8usize,
		           concat!(
			"Offset of field: ",
			stringify!(LL_UTILS_PLLInitTypeDef),
			"::",
			stringify!(PLLR)
		)
		);
	}
	test_field_PLLR();
}
#[doc = " @brief  UTILS System, AHB and APB buses clock configuration structure definition"]
#[repr(C)]
pub struct LL_UTILS_ClkInitTypeDef {
	#[doc = "< The CPU1 clock (HCLK1) divider. This clock is derived from the system clock (SYSCLK)."]
	#[doc = "This parameter can be a value of @ref RCC_LL_EC_SYSCLK_DIV."]
	#[doc = ""]
	#[doc = "This feature can be modified afterwards using unitary function"]
	#[doc = "@ref LL_RCC_SetAHBPrescaler()."]
	pub CPU1CLKDivider: u32,
	#[doc = "< The CPU2 clock (HCLK2) divider. This clock is derived from the system clock (SYSCLK)."]
	#[doc = "This parameter can be a value of @ref RCC_LL_EC_SYSCLK_DIV."]
	#[doc = ""]
	#[doc = "This feature can be modified afterwards using unitary function"]
	#[doc = "@ref LL_C2_RCC_SetAHBPrescaler()."]
	pub CPU2CLKDivider: u32,
	#[doc = "< The AHBS clock (HCLK4) divider. This clock is derived from the system clock (SYSCLK)."]
	#[doc = "This parameter can be a value of @ref RCC_LL_EC_SYSCLK_DIV."]
	#[doc = ""]
	#[doc = "This feature can be modified afterwards using unitary function"]
	#[doc = "@ref LL_RCC_SetAHB4Prescaler()."]
	pub AHB4CLKDivider: u32,
	#[doc = "< The APB1 clock (PCLK1) divider. This clock is derived from the AHB clock (HCLK1)."]
	#[doc = "This parameter can be a value of @ref RCC_LL_EC_APB1_DIV."]
	#[doc = ""]
	#[doc = "This feature can be modified afterwards using unitary function"]
	#[doc = "@ref LL_RCC_SetAPB1Prescaler()."]
	pub APB1CLKDivider: u32,
	#[doc = "< The APB2 clock (PCLK2) divider. This clock is derived from the AHB clock (HCLK1)."]
	#[doc = "This parameter can be a value of @ref RCC_LL_EC_APB2_DIV."]
	#[doc = ""]
	#[doc = "This feature can be modified afterwards using unitary function"]
	#[doc = "@ref LL_RCC_SetAPB2Prescaler()."]
	pub APB2CLKDivider: u32,
}
#[test]
fn bindgen_test_layout_LL_UTILS_ClkInitTypeDef() {
	assert_eq!(
	           ::core::mem::size_of::<LL_UTILS_ClkInitTypeDef>(),
	           20usize,
	           concat!("Size of: ", stringify!(LL_UTILS_ClkInitTypeDef))
	);
	assert_eq!(
	           ::core::mem::align_of::<LL_UTILS_ClkInitTypeDef>(),
	           4usize,
	           concat!("Alignment of ", stringify!(LL_UTILS_ClkInitTypeDef))
	);
	fn test_field_CPU1CLKDivider() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_UTILS_ClkInitTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).CPU1CLKDivider) as usize - ptr as usize
		           },
		           0usize,
		           concat!(
			"Offset of field: ",
			stringify!(LL_UTILS_ClkInitTypeDef),
			"::",
			stringify!(CPU1CLKDivider)
		)
		);
	}
	test_field_CPU1CLKDivider();
	fn test_field_CPU2CLKDivider() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_UTILS_ClkInitTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).CPU2CLKDivider) as usize - ptr as usize
		           },
		           4usize,
		           concat!(
			"Offset of field: ",
			stringify!(LL_UTILS_ClkInitTypeDef),
			"::",
			stringify!(CPU2CLKDivider)
		)
		);
	}
	test_field_CPU2CLKDivider();
	fn test_field_AHB4CLKDivider() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_UTILS_ClkInitTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).AHB4CLKDivider) as usize - ptr as usize
		           },
		           8usize,
		           concat!(
			"Offset of field: ",
			stringify!(LL_UTILS_ClkInitTypeDef),
			"::",
			stringify!(AHB4CLKDivider)
		)
		);
	}
	test_field_AHB4CLKDivider();
	fn test_field_APB1CLKDivider() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_UTILS_ClkInitTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).APB1CLKDivider) as usize - ptr as usize
		           },
		           12usize,
		           concat!(
			"Offset of field: ",
			stringify!(LL_UTILS_ClkInitTypeDef),
			"::",
			stringify!(APB1CLKDivider)
		)
		);
	}
	test_field_APB1CLKDivider();
	fn test_field_APB2CLKDivider() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_UTILS_ClkInitTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).APB2CLKDivider) as usize - ptr as usize
		           },
		           16usize,
		           concat!(
			"Offset of field: ",
			stringify!(LL_UTILS_ClkInitTypeDef),
			"::",
			stringify!(APB2CLKDivider)
		)
		);
	}
	test_field_APB2CLKDivider();
}
extern "C" {
	pub fn LL_Init1msTick(HCLKFrequency: u32);
}
extern "C" {
	pub fn LL_mDelay(Delay: u32);
}
extern "C" {
	#[doc = " @defgroup UTILS_EF_SYSTEM SYSTEM"]
	#[doc = " @{"]
	pub fn LL_SetSystemCoreClock(HCLKFrequency: u32);
}
extern "C" {
	pub fn LL_SetFlashLatency(HCLK4Frequency: u32) -> ErrorStatus;
}
extern "C" {
	pub fn LL_PLL_ConfigSystemClock_MSI(UTILS_PLLInitStruct: *mut LL_UTILS_PLLInitTypeDef,
	                                    UTILS_ClkInitStruct: *mut LL_UTILS_ClkInitTypeDef)
	                                    -> ErrorStatus;
}
extern "C" {
	pub fn LL_PLL_ConfigSystemClock_HSI(UTILS_PLLInitStruct: *mut LL_UTILS_PLLInitTypeDef,
	                                    UTILS_ClkInitStruct: *mut LL_UTILS_ClkInitTypeDef)
	                                    -> ErrorStatus;
}
extern "C" {
	pub fn LL_PLL_ConfigSystemClock_HSE(HSEBypass: u32,
	                                    UTILS_PLLInitStruct: *mut LL_UTILS_PLLInitTypeDef,
	                                    UTILS_ClkInitStruct: *mut LL_UTILS_ClkInitTypeDef)
	                                    -> ErrorStatus;
}
pub type Elf32_Half = u16;
pub type Elf64_Half = u16;
pub type Elf32_Word = u32;
pub type Elf32_Sword = i32;
pub type Elf64_Word = u32;
pub type Elf64_Sword = i32;
pub type Elf32_Xword = u64;
pub type Elf32_Sxword = i64;
pub type Elf64_Xword = u64;
pub type Elf64_Sxword = i64;
pub type Elf32_Addr = u32;
pub type Elf64_Addr = u64;
pub type Elf32_Off = u32;
pub type Elf64_Off = u64;
pub type Elf32_Section = u16;
pub type Elf64_Section = u16;
pub type Elf32_Versym = Elf32_Half;
pub type Elf64_Versym = Elf64_Half;
#[repr(C)]
pub struct Elf32_Ehdr {
	pub e_ident: [core::ffi::c_uchar; 16usize],
	pub e_type: Elf32_Half,
	pub e_machine: Elf32_Half,
	pub e_version: Elf32_Word,
	pub e_entry: Elf32_Addr,
	pub e_phoff: Elf32_Off,
	pub e_shoff: Elf32_Off,
	pub e_flags: Elf32_Word,
	pub e_ehsize: Elf32_Half,
	pub e_phentsize: Elf32_Half,
	pub e_phnum: Elf32_Half,
	pub e_shentsize: Elf32_Half,
	pub e_shnum: Elf32_Half,
	pub e_shstrndx: Elf32_Half,
}
#[test]
fn bindgen_test_layout_Elf32_Ehdr() {
	assert_eq!(
	           ::core::mem::size_of::<Elf32_Ehdr>(),
	           52usize,
	           concat!("Size of: ", stringify!(Elf32_Ehdr))
	);
	assert_eq!(
	           ::core::mem::align_of::<Elf32_Ehdr>(),
	           4usize,
	           concat!("Alignment of ", stringify!(Elf32_Ehdr))
	);
	fn test_field_e_ident() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<Elf32_Ehdr>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).e_ident) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(Elf32_Ehdr), "::", stringify!(e_ident))
		);
	}
	test_field_e_ident();
	fn test_field_e_type() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<Elf32_Ehdr>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).e_type) as usize - ptr as usize
		           },
		           16usize,
		           concat!("Offset of field: ", stringify!(Elf32_Ehdr), "::", stringify!(e_type))
		);
	}
	test_field_e_type();
	fn test_field_e_machine() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<Elf32_Ehdr>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).e_machine) as usize - ptr as usize
		           },
		           18usize,
		           concat!("Offset of field: ", stringify!(Elf32_Ehdr), "::", stringify!(e_machine))
		);
	}
	test_field_e_machine();
	fn test_field_e_version() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<Elf32_Ehdr>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).e_version) as usize - ptr as usize
		           },
		           20usize,
		           concat!("Offset of field: ", stringify!(Elf32_Ehdr), "::", stringify!(e_version))
		);
	}
	test_field_e_version();
	fn test_field_e_entry() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<Elf32_Ehdr>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).e_entry) as usize - ptr as usize
		           },
		           24usize,
		           concat!("Offset of field: ", stringify!(Elf32_Ehdr), "::", stringify!(e_entry))
		);
	}
	test_field_e_entry();
	fn test_field_e_phoff() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<Elf32_Ehdr>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).e_phoff) as usize - ptr as usize
		           },
		           28usize,
		           concat!("Offset of field: ", stringify!(Elf32_Ehdr), "::", stringify!(e_phoff))
		);
	}
	test_field_e_phoff();
	fn test_field_e_shoff() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<Elf32_Ehdr>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).e_shoff) as usize - ptr as usize
		           },
		           32usize,
		           concat!("Offset of field: ", stringify!(Elf32_Ehdr), "::", stringify!(e_shoff))
		);
	}
	test_field_e_shoff();
	fn test_field_e_flags() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<Elf32_Ehdr>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).e_flags) as usize - ptr as usize
		           },
		           36usize,
		           concat!("Offset of field: ", stringify!(Elf32_Ehdr), "::", stringify!(e_flags))
		);
	}
	test_field_e_flags();
	fn test_field_e_ehsize() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<Elf32_Ehdr>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).e_ehsize) as usize - ptr as usize
		           },
		           40usize,
		           concat!("Offset of field: ", stringify!(Elf32_Ehdr), "::", stringify!(e_ehsize))
		);
	}
	test_field_e_ehsize();
	fn test_field_e_phentsize() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<Elf32_Ehdr>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).e_phentsize) as usize - ptr as usize
		           },
		           42usize,
		           concat!("Offset of field: ", stringify!(Elf32_Ehdr), "::", stringify!(e_phentsize))
		);
	}
	test_field_e_phentsize();
	fn test_field_e_phnum() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<Elf32_Ehdr>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).e_phnum) as usize - ptr as usize
		           },
		           44usize,
		           concat!("Offset of field: ", stringify!(Elf32_Ehdr), "::", stringify!(e_phnum))
		);
	}
	test_field_e_phnum();
	fn test_field_e_shentsize() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<Elf32_Ehdr>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).e_shentsize) as usize - ptr as usize
		           },
		           46usize,
		           concat!("Offset of field: ", stringify!(Elf32_Ehdr), "::", stringify!(e_shentsize))
		);
	}
	test_field_e_shentsize();
	fn test_field_e_shnum() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<Elf32_Ehdr>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).e_shnum) as usize - ptr as usize
		           },
		           48usize,
		           concat!("Offset of field: ", stringify!(Elf32_Ehdr), "::", stringify!(e_shnum))
		);
	}
	test_field_e_shnum();
	fn test_field_e_shstrndx() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<Elf32_Ehdr>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).e_shstrndx) as usize - ptr as usize
		           },
		           50usize,
		           concat!("Offset of field: ", stringify!(Elf32_Ehdr), "::", stringify!(e_shstrndx))
		);
	}
	test_field_e_shstrndx();
}
#[repr(C)]
pub struct Elf64_Ehdr {
	pub e_ident: [core::ffi::c_uchar; 16usize],
	pub e_type: Elf64_Half,
	pub e_machine: Elf64_Half,
	pub e_version: Elf64_Word,
	pub e_entry: Elf64_Addr,
	pub e_phoff: Elf64_Off,
	pub e_shoff: Elf64_Off,
	pub e_flags: Elf64_Word,
	pub e_ehsize: Elf64_Half,
	pub e_phentsize: Elf64_Half,
	pub e_phnum: Elf64_Half,
	pub e_shentsize: Elf64_Half,
	pub e_shnum: Elf64_Half,
	pub e_shstrndx: Elf64_Half,
}
#[test]
fn bindgen_test_layout_Elf64_Ehdr() {
	assert_eq!(
	           ::core::mem::size_of::<Elf64_Ehdr>(),
	           64usize,
	           concat!("Size of: ", stringify!(Elf64_Ehdr))
	);
	assert_eq!(
	           ::core::mem::align_of::<Elf64_Ehdr>(),
	           8usize,
	           concat!("Alignment of ", stringify!(Elf64_Ehdr))
	);
	fn test_field_e_ident() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<Elf64_Ehdr>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).e_ident) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(Elf64_Ehdr), "::", stringify!(e_ident))
		);
	}
	test_field_e_ident();
	fn test_field_e_type() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<Elf64_Ehdr>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).e_type) as usize - ptr as usize
		           },
		           16usize,
		           concat!("Offset of field: ", stringify!(Elf64_Ehdr), "::", stringify!(e_type))
		);
	}
	test_field_e_type();
	fn test_field_e_machine() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<Elf64_Ehdr>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).e_machine) as usize - ptr as usize
		           },
		           18usize,
		           concat!("Offset of field: ", stringify!(Elf64_Ehdr), "::", stringify!(e_machine))
		);
	}
	test_field_e_machine();
	fn test_field_e_version() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<Elf64_Ehdr>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).e_version) as usize - ptr as usize
		           },
		           20usize,
		           concat!("Offset of field: ", stringify!(Elf64_Ehdr), "::", stringify!(e_version))
		);
	}
	test_field_e_version();
	fn test_field_e_entry() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<Elf64_Ehdr>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).e_entry) as usize - ptr as usize
		           },
		           24usize,
		           concat!("Offset of field: ", stringify!(Elf64_Ehdr), "::", stringify!(e_entry))
		);
	}
	test_field_e_entry();
	fn test_field_e_phoff() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<Elf64_Ehdr>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).e_phoff) as usize - ptr as usize
		           },
		           32usize,
		           concat!("Offset of field: ", stringify!(Elf64_Ehdr), "::", stringify!(e_phoff))
		);
	}
	test_field_e_phoff();
	fn test_field_e_shoff() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<Elf64_Ehdr>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).e_shoff) as usize - ptr as usize
		           },
		           40usize,
		           concat!("Offset of field: ", stringify!(Elf64_Ehdr), "::", stringify!(e_shoff))
		);
	}
	test_field_e_shoff();
	fn test_field_e_flags() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<Elf64_Ehdr>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).e_flags) as usize - ptr as usize
		           },
		           48usize,
		           concat!("Offset of field: ", stringify!(Elf64_Ehdr), "::", stringify!(e_flags))
		);
	}
	test_field_e_flags();
	fn test_field_e_ehsize() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<Elf64_Ehdr>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).e_ehsize) as usize - ptr as usize
		           },
		           52usize,
		           concat!("Offset of field: ", stringify!(Elf64_Ehdr), "::", stringify!(e_ehsize))
		);
	}
	test_field_e_ehsize();
	fn test_field_e_phentsize() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<Elf64_Ehdr>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).e_phentsize) as usize - ptr as usize
		           },
		           54usize,
		           concat!("Offset of field: ", stringify!(Elf64_Ehdr), "::", stringify!(e_phentsize))
		);
	}
	test_field_e_phentsize();
	fn test_field_e_phnum() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<Elf64_Ehdr>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).e_phnum) as usize - ptr as usize
		           },
		           56usize,
		           concat!("Offset of field: ", stringify!(Elf64_Ehdr), "::", stringify!(e_phnum))
		);
	}
	test_field_e_phnum();
	fn test_field_e_shentsize() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<Elf64_Ehdr>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).e_shentsize) as usize - ptr as usize
		           },
		           58usize,
		           concat!("Offset of field: ", stringify!(Elf64_Ehdr), "::", stringify!(e_shentsize))
		);
	}
	test_field_e_shentsize();
	fn test_field_e_shnum() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<Elf64_Ehdr>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).e_shnum) as usize - ptr as usize
		           },
		           60usize,
		           concat!("Offset of field: ", stringify!(Elf64_Ehdr), "::", stringify!(e_shnum))
		);
	}
	test_field_e_shnum();
	fn test_field_e_shstrndx() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<Elf64_Ehdr>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).e_shstrndx) as usize - ptr as usize
		           },
		           62usize,
		           concat!("Offset of field: ", stringify!(Elf64_Ehdr), "::", stringify!(e_shstrndx))
		);
	}
	test_field_e_shstrndx();
}
#[repr(C)]
pub struct Elf32_Shdr {
	pub sh_name: Elf32_Word,
	pub sh_type: Elf32_Word,
	pub sh_flags: Elf32_Word,
	pub sh_addr: Elf32_Addr,
	pub sh_offset: Elf32_Off,
	pub sh_size: Elf32_Word,
	pub sh_link: Elf32_Word,
	pub sh_info: Elf32_Word,
	pub sh_addralign: Elf32_Word,
	pub sh_entsize: Elf32_Word,
}
#[test]
fn bindgen_test_layout_Elf32_Shdr() {
	assert_eq!(
	           ::core::mem::size_of::<Elf32_Shdr>(),
	           40usize,
	           concat!("Size of: ", stringify!(Elf32_Shdr))
	);
	assert_eq!(
	           ::core::mem::align_of::<Elf32_Shdr>(),
	           4usize,
	           concat!("Alignment of ", stringify!(Elf32_Shdr))
	);
	fn test_field_sh_name() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<Elf32_Shdr>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).sh_name) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(Elf32_Shdr), "::", stringify!(sh_name))
		);
	}
	test_field_sh_name();
	fn test_field_sh_type() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<Elf32_Shdr>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).sh_type) as usize - ptr as usize
		           },
		           4usize,
		           concat!("Offset of field: ", stringify!(Elf32_Shdr), "::", stringify!(sh_type))
		);
	}
	test_field_sh_type();
	fn test_field_sh_flags() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<Elf32_Shdr>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).sh_flags) as usize - ptr as usize
		           },
		           8usize,
		           concat!("Offset of field: ", stringify!(Elf32_Shdr), "::", stringify!(sh_flags))
		);
	}
	test_field_sh_flags();
	fn test_field_sh_addr() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<Elf32_Shdr>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).sh_addr) as usize - ptr as usize
		           },
		           12usize,
		           concat!("Offset of field: ", stringify!(Elf32_Shdr), "::", stringify!(sh_addr))
		);
	}
	test_field_sh_addr();
	fn test_field_sh_offset() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<Elf32_Shdr>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).sh_offset) as usize - ptr as usize
		           },
		           16usize,
		           concat!("Offset of field: ", stringify!(Elf32_Shdr), "::", stringify!(sh_offset))
		);
	}
	test_field_sh_offset();
	fn test_field_sh_size() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<Elf32_Shdr>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).sh_size) as usize - ptr as usize
		           },
		           20usize,
		           concat!("Offset of field: ", stringify!(Elf32_Shdr), "::", stringify!(sh_size))
		);
	}
	test_field_sh_size();
	fn test_field_sh_link() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<Elf32_Shdr>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).sh_link) as usize - ptr as usize
		           },
		           24usize,
		           concat!("Offset of field: ", stringify!(Elf32_Shdr), "::", stringify!(sh_link))
		);
	}
	test_field_sh_link();
	fn test_field_sh_info() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<Elf32_Shdr>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).sh_info) as usize - ptr as usize
		           },
		           28usize,
		           concat!("Offset of field: ", stringify!(Elf32_Shdr), "::", stringify!(sh_info))
		);
	}
	test_field_sh_info();
	fn test_field_sh_addralign() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<Elf32_Shdr>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).sh_addralign) as usize - ptr as usize
		           },
		           32usize,
		           concat!("Offset of field: ", stringify!(Elf32_Shdr), "::", stringify!(sh_addralign))
		);
	}
	test_field_sh_addralign();
	fn test_field_sh_entsize() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<Elf32_Shdr>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).sh_entsize) as usize - ptr as usize
		           },
		           36usize,
		           concat!("Offset of field: ", stringify!(Elf32_Shdr), "::", stringify!(sh_entsize))
		);
	}
	test_field_sh_entsize();
}
#[repr(C)]
pub struct Elf64_Shdr {
	pub sh_name: Elf64_Word,
	pub sh_type: Elf64_Word,
	pub sh_flags: Elf64_Xword,
	pub sh_addr: Elf64_Addr,
	pub sh_offset: Elf64_Off,
	pub sh_size: Elf64_Xword,
	pub sh_link: Elf64_Word,
	pub sh_info: Elf64_Word,
	pub sh_addralign: Elf64_Xword,
	pub sh_entsize: Elf64_Xword,
}
#[test]
fn bindgen_test_layout_Elf64_Shdr() {
	assert_eq!(
	           ::core::mem::size_of::<Elf64_Shdr>(),
	           64usize,
	           concat!("Size of: ", stringify!(Elf64_Shdr))
	);
	assert_eq!(
	           ::core::mem::align_of::<Elf64_Shdr>(),
	           8usize,
	           concat!("Alignment of ", stringify!(Elf64_Shdr))
	);
	fn test_field_sh_name() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<Elf64_Shdr>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).sh_name) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(Elf64_Shdr), "::", stringify!(sh_name))
		);
	}
	test_field_sh_name();
	fn test_field_sh_type() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<Elf64_Shdr>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).sh_type) as usize - ptr as usize
		           },
		           4usize,
		           concat!("Offset of field: ", stringify!(Elf64_Shdr), "::", stringify!(sh_type))
		);
	}
	test_field_sh_type();
	fn test_field_sh_flags() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<Elf64_Shdr>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).sh_flags) as usize - ptr as usize
		           },
		           8usize,
		           concat!("Offset of field: ", stringify!(Elf64_Shdr), "::", stringify!(sh_flags))
		);
	}
	test_field_sh_flags();
	fn test_field_sh_addr() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<Elf64_Shdr>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).sh_addr) as usize - ptr as usize
		           },
		           16usize,
		           concat!("Offset of field: ", stringify!(Elf64_Shdr), "::", stringify!(sh_addr))
		);
	}
	test_field_sh_addr();
	fn test_field_sh_offset() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<Elf64_Shdr>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).sh_offset) as usize - ptr as usize
		           },
		           24usize,
		           concat!("Offset of field: ", stringify!(Elf64_Shdr), "::", stringify!(sh_offset))
		);
	}
	test_field_sh_offset();
	fn test_field_sh_size() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<Elf64_Shdr>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).sh_size) as usize - ptr as usize
		           },
		           32usize,
		           concat!("Offset of field: ", stringify!(Elf64_Shdr), "::", stringify!(sh_size))
		);
	}
	test_field_sh_size();
	fn test_field_sh_link() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<Elf64_Shdr>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).sh_link) as usize - ptr as usize
		           },
		           40usize,
		           concat!("Offset of field: ", stringify!(Elf64_Shdr), "::", stringify!(sh_link))
		);
	}
	test_field_sh_link();
	fn test_field_sh_info() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<Elf64_Shdr>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).sh_info) as usize - ptr as usize
		           },
		           44usize,
		           concat!("Offset of field: ", stringify!(Elf64_Shdr), "::", stringify!(sh_info))
		);
	}
	test_field_sh_info();
	fn test_field_sh_addralign() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<Elf64_Shdr>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).sh_addralign) as usize - ptr as usize
		           },
		           48usize,
		           concat!("Offset of field: ", stringify!(Elf64_Shdr), "::", stringify!(sh_addralign))
		);
	}
	test_field_sh_addralign();
	fn test_field_sh_entsize() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<Elf64_Shdr>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).sh_entsize) as usize - ptr as usize
		           },
		           56usize,
		           concat!("Offset of field: ", stringify!(Elf64_Shdr), "::", stringify!(sh_entsize))
		);
	}
	test_field_sh_entsize();
}
#[repr(C)]
pub struct Elf32_Chdr {
	pub ch_type: Elf32_Word,
	pub ch_size: Elf32_Word,
	pub ch_addralign: Elf32_Word,
}
#[test]
fn bindgen_test_layout_Elf32_Chdr() {
	assert_eq!(
	           ::core::mem::size_of::<Elf32_Chdr>(),
	           12usize,
	           concat!("Size of: ", stringify!(Elf32_Chdr))
	);
	assert_eq!(
	           ::core::mem::align_of::<Elf32_Chdr>(),
	           4usize,
	           concat!("Alignment of ", stringify!(Elf32_Chdr))
	);
	fn test_field_ch_type() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<Elf32_Chdr>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).ch_type) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(Elf32_Chdr), "::", stringify!(ch_type))
		);
	}
	test_field_ch_type();
	fn test_field_ch_size() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<Elf32_Chdr>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).ch_size) as usize - ptr as usize
		           },
		           4usize,
		           concat!("Offset of field: ", stringify!(Elf32_Chdr), "::", stringify!(ch_size))
		);
	}
	test_field_ch_size();
	fn test_field_ch_addralign() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<Elf32_Chdr>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).ch_addralign) as usize - ptr as usize
		           },
		           8usize,
		           concat!("Offset of field: ", stringify!(Elf32_Chdr), "::", stringify!(ch_addralign))
		);
	}
	test_field_ch_addralign();
}
#[repr(C)]
pub struct Elf64_Chdr {
	pub ch_type: Elf64_Word,
	pub ch_reserved: Elf64_Word,
	pub ch_size: Elf64_Xword,
	pub ch_addralign: Elf64_Xword,
}
#[test]
fn bindgen_test_layout_Elf64_Chdr() {
	assert_eq!(
	           ::core::mem::size_of::<Elf64_Chdr>(),
	           24usize,
	           concat!("Size of: ", stringify!(Elf64_Chdr))
	);
	assert_eq!(
	           ::core::mem::align_of::<Elf64_Chdr>(),
	           8usize,
	           concat!("Alignment of ", stringify!(Elf64_Chdr))
	);
	fn test_field_ch_type() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<Elf64_Chdr>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).ch_type) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(Elf64_Chdr), "::", stringify!(ch_type))
		);
	}
	test_field_ch_type();
	fn test_field_ch_reserved() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<Elf64_Chdr>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).ch_reserved) as usize - ptr as usize
		           },
		           4usize,
		           concat!("Offset of field: ", stringify!(Elf64_Chdr), "::", stringify!(ch_reserved))
		);
	}
	test_field_ch_reserved();
	fn test_field_ch_size() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<Elf64_Chdr>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).ch_size) as usize - ptr as usize
		           },
		           8usize,
		           concat!("Offset of field: ", stringify!(Elf64_Chdr), "::", stringify!(ch_size))
		);
	}
	test_field_ch_size();
	fn test_field_ch_addralign() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<Elf64_Chdr>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).ch_addralign) as usize - ptr as usize
		           },
		           16usize,
		           concat!("Offset of field: ", stringify!(Elf64_Chdr), "::", stringify!(ch_addralign))
		);
	}
	test_field_ch_addralign();
}
#[repr(C)]
pub struct Elf32_Sym {
	pub st_name: Elf32_Word,
	pub st_value: Elf32_Addr,
	pub st_size: Elf32_Word,
	pub st_info: core::ffi::c_uchar,
	pub st_other: core::ffi::c_uchar,
	pub st_shndx: Elf32_Section,
}
#[test]
fn bindgen_test_layout_Elf32_Sym() {
	assert_eq!(
	           ::core::mem::size_of::<Elf32_Sym>(),
	           16usize,
	           concat!("Size of: ", stringify!(Elf32_Sym))
	);
	assert_eq!(
	           ::core::mem::align_of::<Elf32_Sym>(),
	           4usize,
	           concat!("Alignment of ", stringify!(Elf32_Sym))
	);
	fn test_field_st_name() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<Elf32_Sym>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).st_name) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(Elf32_Sym), "::", stringify!(st_name))
		);
	}
	test_field_st_name();
	fn test_field_st_value() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<Elf32_Sym>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).st_value) as usize - ptr as usize
		           },
		           4usize,
		           concat!("Offset of field: ", stringify!(Elf32_Sym), "::", stringify!(st_value))
		);
	}
	test_field_st_value();
	fn test_field_st_size() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<Elf32_Sym>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).st_size) as usize - ptr as usize
		           },
		           8usize,
		           concat!("Offset of field: ", stringify!(Elf32_Sym), "::", stringify!(st_size))
		);
	}
	test_field_st_size();
	fn test_field_st_info() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<Elf32_Sym>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).st_info) as usize - ptr as usize
		           },
		           12usize,
		           concat!("Offset of field: ", stringify!(Elf32_Sym), "::", stringify!(st_info))
		);
	}
	test_field_st_info();
	fn test_field_st_other() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<Elf32_Sym>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).st_other) as usize - ptr as usize
		           },
		           13usize,
		           concat!("Offset of field: ", stringify!(Elf32_Sym), "::", stringify!(st_other))
		);
	}
	test_field_st_other();
	fn test_field_st_shndx() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<Elf32_Sym>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).st_shndx) as usize - ptr as usize
		           },
		           14usize,
		           concat!("Offset of field: ", stringify!(Elf32_Sym), "::", stringify!(st_shndx))
		);
	}
	test_field_st_shndx();
}
#[repr(C)]
pub struct Elf64_Sym {
	pub st_name: Elf64_Word,
	pub st_info: core::ffi::c_uchar,
	pub st_other: core::ffi::c_uchar,
	pub st_shndx: Elf64_Section,
	pub st_value: Elf64_Addr,
	pub st_size: Elf64_Xword,
}
#[test]
fn bindgen_test_layout_Elf64_Sym() {
	assert_eq!(
	           ::core::mem::size_of::<Elf64_Sym>(),
	           24usize,
	           concat!("Size of: ", stringify!(Elf64_Sym))
	);
	assert_eq!(
	           ::core::mem::align_of::<Elf64_Sym>(),
	           8usize,
	           concat!("Alignment of ", stringify!(Elf64_Sym))
	);
	fn test_field_st_name() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<Elf64_Sym>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).st_name) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(Elf64_Sym), "::", stringify!(st_name))
		);
	}
	test_field_st_name();
	fn test_field_st_info() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<Elf64_Sym>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).st_info) as usize - ptr as usize
		           },
		           4usize,
		           concat!("Offset of field: ", stringify!(Elf64_Sym), "::", stringify!(st_info))
		);
	}
	test_field_st_info();
	fn test_field_st_other() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<Elf64_Sym>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).st_other) as usize - ptr as usize
		           },
		           5usize,
		           concat!("Offset of field: ", stringify!(Elf64_Sym), "::", stringify!(st_other))
		);
	}
	test_field_st_other();
	fn test_field_st_shndx() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<Elf64_Sym>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).st_shndx) as usize - ptr as usize
		           },
		           6usize,
		           concat!("Offset of field: ", stringify!(Elf64_Sym), "::", stringify!(st_shndx))
		);
	}
	test_field_st_shndx();
	fn test_field_st_value() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<Elf64_Sym>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).st_value) as usize - ptr as usize
		           },
		           8usize,
		           concat!("Offset of field: ", stringify!(Elf64_Sym), "::", stringify!(st_value))
		);
	}
	test_field_st_value();
	fn test_field_st_size() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<Elf64_Sym>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).st_size) as usize - ptr as usize
		           },
		           16usize,
		           concat!("Offset of field: ", stringify!(Elf64_Sym), "::", stringify!(st_size))
		);
	}
	test_field_st_size();
}
#[repr(C)]
pub struct Elf32_Syminfo {
	pub si_boundto: Elf32_Half,
	pub si_flags: Elf32_Half,
}
#[test]
fn bindgen_test_layout_Elf32_Syminfo() {
	assert_eq!(
	           ::core::mem::size_of::<Elf32_Syminfo>(),
	           4usize,
	           concat!("Size of: ", stringify!(Elf32_Syminfo))
	);
	assert_eq!(
	           ::core::mem::align_of::<Elf32_Syminfo>(),
	           2usize,
	           concat!("Alignment of ", stringify!(Elf32_Syminfo))
	);
	fn test_field_si_boundto() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<Elf32_Syminfo>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).si_boundto) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(Elf32_Syminfo), "::", stringify!(si_boundto))
		);
	}
	test_field_si_boundto();
	fn test_field_si_flags() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<Elf32_Syminfo>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).si_flags) as usize - ptr as usize
		           },
		           2usize,
		           concat!("Offset of field: ", stringify!(Elf32_Syminfo), "::", stringify!(si_flags))
		);
	}
	test_field_si_flags();
}
#[repr(C)]
pub struct Elf64_Syminfo {
	pub si_boundto: Elf64_Half,
	pub si_flags: Elf64_Half,
}
#[test]
fn bindgen_test_layout_Elf64_Syminfo() {
	assert_eq!(
	           ::core::mem::size_of::<Elf64_Syminfo>(),
	           4usize,
	           concat!("Size of: ", stringify!(Elf64_Syminfo))
	);
	assert_eq!(
	           ::core::mem::align_of::<Elf64_Syminfo>(),
	           2usize,
	           concat!("Alignment of ", stringify!(Elf64_Syminfo))
	);
	fn test_field_si_boundto() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<Elf64_Syminfo>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).si_boundto) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(Elf64_Syminfo), "::", stringify!(si_boundto))
		);
	}
	test_field_si_boundto();
	fn test_field_si_flags() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<Elf64_Syminfo>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).si_flags) as usize - ptr as usize
		           },
		           2usize,
		           concat!("Offset of field: ", stringify!(Elf64_Syminfo), "::", stringify!(si_flags))
		);
	}
	test_field_si_flags();
}
#[repr(C)]
pub struct Elf32_Rel {
	pub r_offset: Elf32_Addr,
	pub r_info: Elf32_Word,
}
#[test]
fn bindgen_test_layout_Elf32_Rel() {
	assert_eq!(
	           ::core::mem::size_of::<Elf32_Rel>(),
	           8usize,
	           concat!("Size of: ", stringify!(Elf32_Rel))
	);
	assert_eq!(
	           ::core::mem::align_of::<Elf32_Rel>(),
	           4usize,
	           concat!("Alignment of ", stringify!(Elf32_Rel))
	);
	fn test_field_r_offset() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<Elf32_Rel>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).r_offset) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(Elf32_Rel), "::", stringify!(r_offset))
		);
	}
	test_field_r_offset();
	fn test_field_r_info() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<Elf32_Rel>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).r_info) as usize - ptr as usize
		           },
		           4usize,
		           concat!("Offset of field: ", stringify!(Elf32_Rel), "::", stringify!(r_info))
		);
	}
	test_field_r_info();
}
#[repr(C)]
pub struct Elf64_Rel {
	pub r_offset: Elf64_Addr,
	pub r_info: Elf64_Xword,
}
#[test]
fn bindgen_test_layout_Elf64_Rel() {
	assert_eq!(
	           ::core::mem::size_of::<Elf64_Rel>(),
	           16usize,
	           concat!("Size of: ", stringify!(Elf64_Rel))
	);
	assert_eq!(
	           ::core::mem::align_of::<Elf64_Rel>(),
	           8usize,
	           concat!("Alignment of ", stringify!(Elf64_Rel))
	);
	fn test_field_r_offset() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<Elf64_Rel>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).r_offset) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(Elf64_Rel), "::", stringify!(r_offset))
		);
	}
	test_field_r_offset();
	fn test_field_r_info() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<Elf64_Rel>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).r_info) as usize - ptr as usize
		           },
		           8usize,
		           concat!("Offset of field: ", stringify!(Elf64_Rel), "::", stringify!(r_info))
		);
	}
	test_field_r_info();
}
#[repr(C)]
pub struct Elf32_Rela {
	pub r_offset: Elf32_Addr,
	pub r_info: Elf32_Word,
	pub r_addend: Elf32_Sword,
}
#[test]
fn bindgen_test_layout_Elf32_Rela() {
	assert_eq!(
	           ::core::mem::size_of::<Elf32_Rela>(),
	           12usize,
	           concat!("Size of: ", stringify!(Elf32_Rela))
	);
	assert_eq!(
	           ::core::mem::align_of::<Elf32_Rela>(),
	           4usize,
	           concat!("Alignment of ", stringify!(Elf32_Rela))
	);
	fn test_field_r_offset() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<Elf32_Rela>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).r_offset) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(Elf32_Rela), "::", stringify!(r_offset))
		);
	}
	test_field_r_offset();
	fn test_field_r_info() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<Elf32_Rela>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).r_info) as usize - ptr as usize
		           },
		           4usize,
		           concat!("Offset of field: ", stringify!(Elf32_Rela), "::", stringify!(r_info))
		);
	}
	test_field_r_info();
	fn test_field_r_addend() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<Elf32_Rela>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).r_addend) as usize - ptr as usize
		           },
		           8usize,
		           concat!("Offset of field: ", stringify!(Elf32_Rela), "::", stringify!(r_addend))
		);
	}
	test_field_r_addend();
}
#[repr(C)]
pub struct Elf64_Rela {
	pub r_offset: Elf64_Addr,
	pub r_info: Elf64_Xword,
	pub r_addend: Elf64_Sxword,
}
#[test]
fn bindgen_test_layout_Elf64_Rela() {
	assert_eq!(
	           ::core::mem::size_of::<Elf64_Rela>(),
	           24usize,
	           concat!("Size of: ", stringify!(Elf64_Rela))
	);
	assert_eq!(
	           ::core::mem::align_of::<Elf64_Rela>(),
	           8usize,
	           concat!("Alignment of ", stringify!(Elf64_Rela))
	);
	fn test_field_r_offset() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<Elf64_Rela>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).r_offset) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(Elf64_Rela), "::", stringify!(r_offset))
		);
	}
	test_field_r_offset();
	fn test_field_r_info() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<Elf64_Rela>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).r_info) as usize - ptr as usize
		           },
		           8usize,
		           concat!("Offset of field: ", stringify!(Elf64_Rela), "::", stringify!(r_info))
		);
	}
	test_field_r_info();
	fn test_field_r_addend() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<Elf64_Rela>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).r_addend) as usize - ptr as usize
		           },
		           16usize,
		           concat!("Offset of field: ", stringify!(Elf64_Rela), "::", stringify!(r_addend))
		);
	}
	test_field_r_addend();
}
#[repr(C)]
pub struct Elf32_Phdr {
	pub p_type: Elf32_Word,
	pub p_offset: Elf32_Off,
	pub p_vaddr: Elf32_Addr,
	pub p_paddr: Elf32_Addr,
	pub p_filesz: Elf32_Word,
	pub p_memsz: Elf32_Word,
	pub p_flags: Elf32_Word,
	pub p_align: Elf32_Word,
}
#[test]
fn bindgen_test_layout_Elf32_Phdr() {
	assert_eq!(
	           ::core::mem::size_of::<Elf32_Phdr>(),
	           32usize,
	           concat!("Size of: ", stringify!(Elf32_Phdr))
	);
	assert_eq!(
	           ::core::mem::align_of::<Elf32_Phdr>(),
	           4usize,
	           concat!("Alignment of ", stringify!(Elf32_Phdr))
	);
	fn test_field_p_type() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<Elf32_Phdr>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).p_type) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(Elf32_Phdr), "::", stringify!(p_type))
		);
	}
	test_field_p_type();
	fn test_field_p_offset() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<Elf32_Phdr>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).p_offset) as usize - ptr as usize
		           },
		           4usize,
		           concat!("Offset of field: ", stringify!(Elf32_Phdr), "::", stringify!(p_offset))
		);
	}
	test_field_p_offset();
	fn test_field_p_vaddr() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<Elf32_Phdr>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).p_vaddr) as usize - ptr as usize
		           },
		           8usize,
		           concat!("Offset of field: ", stringify!(Elf32_Phdr), "::", stringify!(p_vaddr))
		);
	}
	test_field_p_vaddr();
	fn test_field_p_paddr() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<Elf32_Phdr>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).p_paddr) as usize - ptr as usize
		           },
		           12usize,
		           concat!("Offset of field: ", stringify!(Elf32_Phdr), "::", stringify!(p_paddr))
		);
	}
	test_field_p_paddr();
	fn test_field_p_filesz() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<Elf32_Phdr>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).p_filesz) as usize - ptr as usize
		           },
		           16usize,
		           concat!("Offset of field: ", stringify!(Elf32_Phdr), "::", stringify!(p_filesz))
		);
	}
	test_field_p_filesz();
	fn test_field_p_memsz() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<Elf32_Phdr>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).p_memsz) as usize - ptr as usize
		           },
		           20usize,
		           concat!("Offset of field: ", stringify!(Elf32_Phdr), "::", stringify!(p_memsz))
		);
	}
	test_field_p_memsz();
	fn test_field_p_flags() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<Elf32_Phdr>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).p_flags) as usize - ptr as usize
		           },
		           24usize,
		           concat!("Offset of field: ", stringify!(Elf32_Phdr), "::", stringify!(p_flags))
		);
	}
	test_field_p_flags();
	fn test_field_p_align() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<Elf32_Phdr>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).p_align) as usize - ptr as usize
		           },
		           28usize,
		           concat!("Offset of field: ", stringify!(Elf32_Phdr), "::", stringify!(p_align))
		);
	}
	test_field_p_align();
}
#[repr(C)]
pub struct Elf64_Phdr {
	pub p_type: Elf64_Word,
	pub p_flags: Elf64_Word,
	pub p_offset: Elf64_Off,
	pub p_vaddr: Elf64_Addr,
	pub p_paddr: Elf64_Addr,
	pub p_filesz: Elf64_Xword,
	pub p_memsz: Elf64_Xword,
	pub p_align: Elf64_Xword,
}
#[test]
fn bindgen_test_layout_Elf64_Phdr() {
	assert_eq!(
	           ::core::mem::size_of::<Elf64_Phdr>(),
	           56usize,
	           concat!("Size of: ", stringify!(Elf64_Phdr))
	);
	assert_eq!(
	           ::core::mem::align_of::<Elf64_Phdr>(),
	           8usize,
	           concat!("Alignment of ", stringify!(Elf64_Phdr))
	);
	fn test_field_p_type() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<Elf64_Phdr>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).p_type) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(Elf64_Phdr), "::", stringify!(p_type))
		);
	}
	test_field_p_type();
	fn test_field_p_flags() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<Elf64_Phdr>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).p_flags) as usize - ptr as usize
		           },
		           4usize,
		           concat!("Offset of field: ", stringify!(Elf64_Phdr), "::", stringify!(p_flags))
		);
	}
	test_field_p_flags();
	fn test_field_p_offset() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<Elf64_Phdr>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).p_offset) as usize - ptr as usize
		           },
		           8usize,
		           concat!("Offset of field: ", stringify!(Elf64_Phdr), "::", stringify!(p_offset))
		);
	}
	test_field_p_offset();
	fn test_field_p_vaddr() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<Elf64_Phdr>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).p_vaddr) as usize - ptr as usize
		           },
		           16usize,
		           concat!("Offset of field: ", stringify!(Elf64_Phdr), "::", stringify!(p_vaddr))
		);
	}
	test_field_p_vaddr();
	fn test_field_p_paddr() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<Elf64_Phdr>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).p_paddr) as usize - ptr as usize
		           },
		           24usize,
		           concat!("Offset of field: ", stringify!(Elf64_Phdr), "::", stringify!(p_paddr))
		);
	}
	test_field_p_paddr();
	fn test_field_p_filesz() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<Elf64_Phdr>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).p_filesz) as usize - ptr as usize
		           },
		           32usize,
		           concat!("Offset of field: ", stringify!(Elf64_Phdr), "::", stringify!(p_filesz))
		);
	}
	test_field_p_filesz();
	fn test_field_p_memsz() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<Elf64_Phdr>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).p_memsz) as usize - ptr as usize
		           },
		           40usize,
		           concat!("Offset of field: ", stringify!(Elf64_Phdr), "::", stringify!(p_memsz))
		);
	}
	test_field_p_memsz();
	fn test_field_p_align() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<Elf64_Phdr>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).p_align) as usize - ptr as usize
		           },
		           48usize,
		           concat!("Offset of field: ", stringify!(Elf64_Phdr), "::", stringify!(p_align))
		);
	}
	test_field_p_align();
}
#[repr(C)]
pub struct Elf32_Dyn {
	pub d_tag: Elf32_Sword,
	pub d_un: Elf32_Dyn__bindgen_ty_1,
}
#[repr(C)]
pub struct Elf32_Dyn__bindgen_ty_1 {
	pub d_val: __BindgenUnionField<Elf32_Word>,
	pub d_ptr: __BindgenUnionField<Elf32_Addr>,
	pub bindgen_union_field: u32,
}
#[test]
fn bindgen_test_layout_Elf32_Dyn__bindgen_ty_1() {
	assert_eq!(
	           ::core::mem::size_of::<Elf32_Dyn__bindgen_ty_1>(),
	           4usize,
	           concat!("Size of: ", stringify!(Elf32_Dyn__bindgen_ty_1))
	);
	assert_eq!(
	           ::core::mem::align_of::<Elf32_Dyn__bindgen_ty_1>(),
	           4usize,
	           concat!("Alignment of ", stringify!(Elf32_Dyn__bindgen_ty_1))
	);
	fn test_field_d_val() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<Elf32_Dyn__bindgen_ty_1>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).d_val) as usize - ptr as usize
		           },
		           0usize,
		           concat!(
			"Offset of field: ",
			stringify!(Elf32_Dyn__bindgen_ty_1),
			"::",
			stringify!(d_val)
		)
		);
	}
	test_field_d_val();
	fn test_field_d_ptr() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<Elf32_Dyn__bindgen_ty_1>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).d_ptr) as usize - ptr as usize
		           },
		           0usize,
		           concat!(
			"Offset of field: ",
			stringify!(Elf32_Dyn__bindgen_ty_1),
			"::",
			stringify!(d_ptr)
		)
		);
	}
	test_field_d_ptr();
}
#[test]
fn bindgen_test_layout_Elf32_Dyn() {
	assert_eq!(
	           ::core::mem::size_of::<Elf32_Dyn>(),
	           8usize,
	           concat!("Size of: ", stringify!(Elf32_Dyn))
	);
	assert_eq!(
	           ::core::mem::align_of::<Elf32_Dyn>(),
	           4usize,
	           concat!("Alignment of ", stringify!(Elf32_Dyn))
	);
	fn test_field_d_tag() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<Elf32_Dyn>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).d_tag) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(Elf32_Dyn), "::", stringify!(d_tag))
		);
	}
	test_field_d_tag();
	fn test_field_d_un() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<Elf32_Dyn>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).d_un) as usize - ptr as usize
		           },
		           4usize,
		           concat!("Offset of field: ", stringify!(Elf32_Dyn), "::", stringify!(d_un))
		);
	}
	test_field_d_un();
}
#[repr(C)]
pub struct Elf64_Dyn {
	pub d_tag: Elf64_Sxword,
	pub d_un: Elf64_Dyn__bindgen_ty_1,
}
#[repr(C)]
pub struct Elf64_Dyn__bindgen_ty_1 {
	pub d_val: __BindgenUnionField<Elf64_Xword>,
	pub d_ptr: __BindgenUnionField<Elf64_Addr>,
	pub bindgen_union_field: u64,
}
#[test]
fn bindgen_test_layout_Elf64_Dyn__bindgen_ty_1() {
	assert_eq!(
	           ::core::mem::size_of::<Elf64_Dyn__bindgen_ty_1>(),
	           8usize,
	           concat!("Size of: ", stringify!(Elf64_Dyn__bindgen_ty_1))
	);
	assert_eq!(
	           ::core::mem::align_of::<Elf64_Dyn__bindgen_ty_1>(),
	           8usize,
	           concat!("Alignment of ", stringify!(Elf64_Dyn__bindgen_ty_1))
	);
	fn test_field_d_val() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<Elf64_Dyn__bindgen_ty_1>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).d_val) as usize - ptr as usize
		           },
		           0usize,
		           concat!(
			"Offset of field: ",
			stringify!(Elf64_Dyn__bindgen_ty_1),
			"::",
			stringify!(d_val)
		)
		);
	}
	test_field_d_val();
	fn test_field_d_ptr() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<Elf64_Dyn__bindgen_ty_1>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).d_ptr) as usize - ptr as usize
		           },
		           0usize,
		           concat!(
			"Offset of field: ",
			stringify!(Elf64_Dyn__bindgen_ty_1),
			"::",
			stringify!(d_ptr)
		)
		);
	}
	test_field_d_ptr();
}
#[test]
fn bindgen_test_layout_Elf64_Dyn() {
	assert_eq!(
	           ::core::mem::size_of::<Elf64_Dyn>(),
	           16usize,
	           concat!("Size of: ", stringify!(Elf64_Dyn))
	);
	assert_eq!(
	           ::core::mem::align_of::<Elf64_Dyn>(),
	           8usize,
	           concat!("Alignment of ", stringify!(Elf64_Dyn))
	);
	fn test_field_d_tag() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<Elf64_Dyn>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).d_tag) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(Elf64_Dyn), "::", stringify!(d_tag))
		);
	}
	test_field_d_tag();
	fn test_field_d_un() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<Elf64_Dyn>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).d_un) as usize - ptr as usize
		           },
		           8usize,
		           concat!("Offset of field: ", stringify!(Elf64_Dyn), "::", stringify!(d_un))
		);
	}
	test_field_d_un();
}
#[repr(C)]
pub struct Elf32_Verdef {
	pub vd_version: Elf32_Half,
	pub vd_flags: Elf32_Half,
	pub vd_ndx: Elf32_Half,
	pub vd_cnt: Elf32_Half,
	pub vd_hash: Elf32_Word,
	pub vd_aux: Elf32_Word,
	pub vd_next: Elf32_Word,
}
#[test]
fn bindgen_test_layout_Elf32_Verdef() {
	assert_eq!(
	           ::core::mem::size_of::<Elf32_Verdef>(),
	           20usize,
	           concat!("Size of: ", stringify!(Elf32_Verdef))
	);
	assert_eq!(
	           ::core::mem::align_of::<Elf32_Verdef>(),
	           4usize,
	           concat!("Alignment of ", stringify!(Elf32_Verdef))
	);
	fn test_field_vd_version() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<Elf32_Verdef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).vd_version) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(Elf32_Verdef), "::", stringify!(vd_version))
		);
	}
	test_field_vd_version();
	fn test_field_vd_flags() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<Elf32_Verdef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).vd_flags) as usize - ptr as usize
		           },
		           2usize,
		           concat!("Offset of field: ", stringify!(Elf32_Verdef), "::", stringify!(vd_flags))
		);
	}
	test_field_vd_flags();
	fn test_field_vd_ndx() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<Elf32_Verdef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).vd_ndx) as usize - ptr as usize
		           },
		           4usize,
		           concat!("Offset of field: ", stringify!(Elf32_Verdef), "::", stringify!(vd_ndx))
		);
	}
	test_field_vd_ndx();
	fn test_field_vd_cnt() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<Elf32_Verdef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).vd_cnt) as usize - ptr as usize
		           },
		           6usize,
		           concat!("Offset of field: ", stringify!(Elf32_Verdef), "::", stringify!(vd_cnt))
		);
	}
	test_field_vd_cnt();
	fn test_field_vd_hash() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<Elf32_Verdef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).vd_hash) as usize - ptr as usize
		           },
		           8usize,
		           concat!("Offset of field: ", stringify!(Elf32_Verdef), "::", stringify!(vd_hash))
		);
	}
	test_field_vd_hash();
	fn test_field_vd_aux() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<Elf32_Verdef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).vd_aux) as usize - ptr as usize
		           },
		           12usize,
		           concat!("Offset of field: ", stringify!(Elf32_Verdef), "::", stringify!(vd_aux))
		);
	}
	test_field_vd_aux();
	fn test_field_vd_next() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<Elf32_Verdef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).vd_next) as usize - ptr as usize
		           },
		           16usize,
		           concat!("Offset of field: ", stringify!(Elf32_Verdef), "::", stringify!(vd_next))
		);
	}
	test_field_vd_next();
}
#[repr(C)]
pub struct Elf64_Verdef {
	pub vd_version: Elf64_Half,
	pub vd_flags: Elf64_Half,
	pub vd_ndx: Elf64_Half,
	pub vd_cnt: Elf64_Half,
	pub vd_hash: Elf64_Word,
	pub vd_aux: Elf64_Word,
	pub vd_next: Elf64_Word,
}
#[test]
fn bindgen_test_layout_Elf64_Verdef() {
	assert_eq!(
	           ::core::mem::size_of::<Elf64_Verdef>(),
	           20usize,
	           concat!("Size of: ", stringify!(Elf64_Verdef))
	);
	assert_eq!(
	           ::core::mem::align_of::<Elf64_Verdef>(),
	           4usize,
	           concat!("Alignment of ", stringify!(Elf64_Verdef))
	);
	fn test_field_vd_version() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<Elf64_Verdef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).vd_version) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(Elf64_Verdef), "::", stringify!(vd_version))
		);
	}
	test_field_vd_version();
	fn test_field_vd_flags() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<Elf64_Verdef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).vd_flags) as usize - ptr as usize
		           },
		           2usize,
		           concat!("Offset of field: ", stringify!(Elf64_Verdef), "::", stringify!(vd_flags))
		);
	}
	test_field_vd_flags();
	fn test_field_vd_ndx() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<Elf64_Verdef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).vd_ndx) as usize - ptr as usize
		           },
		           4usize,
		           concat!("Offset of field: ", stringify!(Elf64_Verdef), "::", stringify!(vd_ndx))
		);
	}
	test_field_vd_ndx();
	fn test_field_vd_cnt() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<Elf64_Verdef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).vd_cnt) as usize - ptr as usize
		           },
		           6usize,
		           concat!("Offset of field: ", stringify!(Elf64_Verdef), "::", stringify!(vd_cnt))
		);
	}
	test_field_vd_cnt();
	fn test_field_vd_hash() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<Elf64_Verdef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).vd_hash) as usize - ptr as usize
		           },
		           8usize,
		           concat!("Offset of field: ", stringify!(Elf64_Verdef), "::", stringify!(vd_hash))
		);
	}
	test_field_vd_hash();
	fn test_field_vd_aux() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<Elf64_Verdef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).vd_aux) as usize - ptr as usize
		           },
		           12usize,
		           concat!("Offset of field: ", stringify!(Elf64_Verdef), "::", stringify!(vd_aux))
		);
	}
	test_field_vd_aux();
	fn test_field_vd_next() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<Elf64_Verdef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).vd_next) as usize - ptr as usize
		           },
		           16usize,
		           concat!("Offset of field: ", stringify!(Elf64_Verdef), "::", stringify!(vd_next))
		);
	}
	test_field_vd_next();
}
#[repr(C)]
pub struct Elf32_Verdaux {
	pub vda_name: Elf32_Word,
	pub vda_next: Elf32_Word,
}
#[test]
fn bindgen_test_layout_Elf32_Verdaux() {
	assert_eq!(
	           ::core::mem::size_of::<Elf32_Verdaux>(),
	           8usize,
	           concat!("Size of: ", stringify!(Elf32_Verdaux))
	);
	assert_eq!(
	           ::core::mem::align_of::<Elf32_Verdaux>(),
	           4usize,
	           concat!("Alignment of ", stringify!(Elf32_Verdaux))
	);
	fn test_field_vda_name() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<Elf32_Verdaux>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).vda_name) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(Elf32_Verdaux), "::", stringify!(vda_name))
		);
	}
	test_field_vda_name();
	fn test_field_vda_next() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<Elf32_Verdaux>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).vda_next) as usize - ptr as usize
		           },
		           4usize,
		           concat!("Offset of field: ", stringify!(Elf32_Verdaux), "::", stringify!(vda_next))
		);
	}
	test_field_vda_next();
}
#[repr(C)]
pub struct Elf64_Verdaux {
	pub vda_name: Elf64_Word,
	pub vda_next: Elf64_Word,
}
#[test]
fn bindgen_test_layout_Elf64_Verdaux() {
	assert_eq!(
	           ::core::mem::size_of::<Elf64_Verdaux>(),
	           8usize,
	           concat!("Size of: ", stringify!(Elf64_Verdaux))
	);
	assert_eq!(
	           ::core::mem::align_of::<Elf64_Verdaux>(),
	           4usize,
	           concat!("Alignment of ", stringify!(Elf64_Verdaux))
	);
	fn test_field_vda_name() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<Elf64_Verdaux>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).vda_name) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(Elf64_Verdaux), "::", stringify!(vda_name))
		);
	}
	test_field_vda_name();
	fn test_field_vda_next() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<Elf64_Verdaux>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).vda_next) as usize - ptr as usize
		           },
		           4usize,
		           concat!("Offset of field: ", stringify!(Elf64_Verdaux), "::", stringify!(vda_next))
		);
	}
	test_field_vda_next();
}
#[repr(C)]
pub struct Elf32_Verneed {
	pub vn_version: Elf32_Half,
	pub vn_cnt: Elf32_Half,
	pub vn_file: Elf32_Word,
	pub vn_aux: Elf32_Word,
	pub vn_next: Elf32_Word,
}
#[test]
fn bindgen_test_layout_Elf32_Verneed() {
	assert_eq!(
	           ::core::mem::size_of::<Elf32_Verneed>(),
	           16usize,
	           concat!("Size of: ", stringify!(Elf32_Verneed))
	);
	assert_eq!(
	           ::core::mem::align_of::<Elf32_Verneed>(),
	           4usize,
	           concat!("Alignment of ", stringify!(Elf32_Verneed))
	);
	fn test_field_vn_version() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<Elf32_Verneed>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).vn_version) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(Elf32_Verneed), "::", stringify!(vn_version))
		);
	}
	test_field_vn_version();
	fn test_field_vn_cnt() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<Elf32_Verneed>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).vn_cnt) as usize - ptr as usize
		           },
		           2usize,
		           concat!("Offset of field: ", stringify!(Elf32_Verneed), "::", stringify!(vn_cnt))
		);
	}
	test_field_vn_cnt();
	fn test_field_vn_file() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<Elf32_Verneed>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).vn_file) as usize - ptr as usize
		           },
		           4usize,
		           concat!("Offset of field: ", stringify!(Elf32_Verneed), "::", stringify!(vn_file))
		);
	}
	test_field_vn_file();
	fn test_field_vn_aux() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<Elf32_Verneed>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).vn_aux) as usize - ptr as usize
		           },
		           8usize,
		           concat!("Offset of field: ", stringify!(Elf32_Verneed), "::", stringify!(vn_aux))
		);
	}
	test_field_vn_aux();
	fn test_field_vn_next() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<Elf32_Verneed>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).vn_next) as usize - ptr as usize
		           },
		           12usize,
		           concat!("Offset of field: ", stringify!(Elf32_Verneed), "::", stringify!(vn_next))
		);
	}
	test_field_vn_next();
}
#[repr(C)]
pub struct Elf64_Verneed {
	pub vn_version: Elf64_Half,
	pub vn_cnt: Elf64_Half,
	pub vn_file: Elf64_Word,
	pub vn_aux: Elf64_Word,
	pub vn_next: Elf64_Word,
}
#[test]
fn bindgen_test_layout_Elf64_Verneed() {
	assert_eq!(
	           ::core::mem::size_of::<Elf64_Verneed>(),
	           16usize,
	           concat!("Size of: ", stringify!(Elf64_Verneed))
	);
	assert_eq!(
	           ::core::mem::align_of::<Elf64_Verneed>(),
	           4usize,
	           concat!("Alignment of ", stringify!(Elf64_Verneed))
	);
	fn test_field_vn_version() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<Elf64_Verneed>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).vn_version) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(Elf64_Verneed), "::", stringify!(vn_version))
		);
	}
	test_field_vn_version();
	fn test_field_vn_cnt() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<Elf64_Verneed>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).vn_cnt) as usize - ptr as usize
		           },
		           2usize,
		           concat!("Offset of field: ", stringify!(Elf64_Verneed), "::", stringify!(vn_cnt))
		);
	}
	test_field_vn_cnt();
	fn test_field_vn_file() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<Elf64_Verneed>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).vn_file) as usize - ptr as usize
		           },
		           4usize,
		           concat!("Offset of field: ", stringify!(Elf64_Verneed), "::", stringify!(vn_file))
		);
	}
	test_field_vn_file();
	fn test_field_vn_aux() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<Elf64_Verneed>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).vn_aux) as usize - ptr as usize
		           },
		           8usize,
		           concat!("Offset of field: ", stringify!(Elf64_Verneed), "::", stringify!(vn_aux))
		);
	}
	test_field_vn_aux();
	fn test_field_vn_next() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<Elf64_Verneed>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).vn_next) as usize - ptr as usize
		           },
		           12usize,
		           concat!("Offset of field: ", stringify!(Elf64_Verneed), "::", stringify!(vn_next))
		);
	}
	test_field_vn_next();
}
#[repr(C)]
pub struct Elf32_Vernaux {
	pub vna_hash: Elf32_Word,
	pub vna_flags: Elf32_Half,
	pub vna_other: Elf32_Half,
	pub vna_name: Elf32_Word,
	pub vna_next: Elf32_Word,
}
#[test]
fn bindgen_test_layout_Elf32_Vernaux() {
	assert_eq!(
	           ::core::mem::size_of::<Elf32_Vernaux>(),
	           16usize,
	           concat!("Size of: ", stringify!(Elf32_Vernaux))
	);
	assert_eq!(
	           ::core::mem::align_of::<Elf32_Vernaux>(),
	           4usize,
	           concat!("Alignment of ", stringify!(Elf32_Vernaux))
	);
	fn test_field_vna_hash() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<Elf32_Vernaux>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).vna_hash) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(Elf32_Vernaux), "::", stringify!(vna_hash))
		);
	}
	test_field_vna_hash();
	fn test_field_vna_flags() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<Elf32_Vernaux>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).vna_flags) as usize - ptr as usize
		           },
		           4usize,
		           concat!("Offset of field: ", stringify!(Elf32_Vernaux), "::", stringify!(vna_flags))
		);
	}
	test_field_vna_flags();
	fn test_field_vna_other() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<Elf32_Vernaux>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).vna_other) as usize - ptr as usize
		           },
		           6usize,
		           concat!("Offset of field: ", stringify!(Elf32_Vernaux), "::", stringify!(vna_other))
		);
	}
	test_field_vna_other();
	fn test_field_vna_name() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<Elf32_Vernaux>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).vna_name) as usize - ptr as usize
		           },
		           8usize,
		           concat!("Offset of field: ", stringify!(Elf32_Vernaux), "::", stringify!(vna_name))
		);
	}
	test_field_vna_name();
	fn test_field_vna_next() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<Elf32_Vernaux>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).vna_next) as usize - ptr as usize
		           },
		           12usize,
		           concat!("Offset of field: ", stringify!(Elf32_Vernaux), "::", stringify!(vna_next))
		);
	}
	test_field_vna_next();
}
#[repr(C)]
pub struct Elf64_Vernaux {
	pub vna_hash: Elf64_Word,
	pub vna_flags: Elf64_Half,
	pub vna_other: Elf64_Half,
	pub vna_name: Elf64_Word,
	pub vna_next: Elf64_Word,
}
#[test]
fn bindgen_test_layout_Elf64_Vernaux() {
	assert_eq!(
	           ::core::mem::size_of::<Elf64_Vernaux>(),
	           16usize,
	           concat!("Size of: ", stringify!(Elf64_Vernaux))
	);
	assert_eq!(
	           ::core::mem::align_of::<Elf64_Vernaux>(),
	           4usize,
	           concat!("Alignment of ", stringify!(Elf64_Vernaux))
	);
	fn test_field_vna_hash() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<Elf64_Vernaux>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).vna_hash) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(Elf64_Vernaux), "::", stringify!(vna_hash))
		);
	}
	test_field_vna_hash();
	fn test_field_vna_flags() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<Elf64_Vernaux>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).vna_flags) as usize - ptr as usize
		           },
		           4usize,
		           concat!("Offset of field: ", stringify!(Elf64_Vernaux), "::", stringify!(vna_flags))
		);
	}
	test_field_vna_flags();
	fn test_field_vna_other() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<Elf64_Vernaux>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).vna_other) as usize - ptr as usize
		           },
		           6usize,
		           concat!("Offset of field: ", stringify!(Elf64_Vernaux), "::", stringify!(vna_other))
		);
	}
	test_field_vna_other();
	fn test_field_vna_name() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<Elf64_Vernaux>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).vna_name) as usize - ptr as usize
		           },
		           8usize,
		           concat!("Offset of field: ", stringify!(Elf64_Vernaux), "::", stringify!(vna_name))
		);
	}
	test_field_vna_name();
	fn test_field_vna_next() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<Elf64_Vernaux>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).vna_next) as usize - ptr as usize
		           },
		           12usize,
		           concat!("Offset of field: ", stringify!(Elf64_Vernaux), "::", stringify!(vna_next))
		);
	}
	test_field_vna_next();
}
#[repr(C)]
pub struct Elf32_auxv_t {
	pub a_type: u32,
	pub a_un: Elf32_auxv_t__bindgen_ty_1,
}
#[repr(C)]
pub struct Elf32_auxv_t__bindgen_ty_1 {
	pub a_val: __BindgenUnionField<u32>,
	pub bindgen_union_field: u32,
}
#[test]
fn bindgen_test_layout_Elf32_auxv_t__bindgen_ty_1() {
	assert_eq!(
	           ::core::mem::size_of::<Elf32_auxv_t__bindgen_ty_1>(),
	           4usize,
	           concat!("Size of: ", stringify!(Elf32_auxv_t__bindgen_ty_1))
	);
	assert_eq!(
	           ::core::mem::align_of::<Elf32_auxv_t__bindgen_ty_1>(),
	           4usize,
	           concat!("Alignment of ", stringify!(Elf32_auxv_t__bindgen_ty_1))
	);
	fn test_field_a_val() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<Elf32_auxv_t__bindgen_ty_1>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).a_val) as usize - ptr as usize
		           },
		           0usize,
		           concat!(
			"Offset of field: ",
			stringify!(Elf32_auxv_t__bindgen_ty_1),
			"::",
			stringify!(a_val)
		)
		);
	}
	test_field_a_val();
}
#[test]
fn bindgen_test_layout_Elf32_auxv_t() {
	assert_eq!(
	           ::core::mem::size_of::<Elf32_auxv_t>(),
	           8usize,
	           concat!("Size of: ", stringify!(Elf32_auxv_t))
	);
	assert_eq!(
	           ::core::mem::align_of::<Elf32_auxv_t>(),
	           4usize,
	           concat!("Alignment of ", stringify!(Elf32_auxv_t))
	);
	fn test_field_a_type() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<Elf32_auxv_t>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).a_type) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(Elf32_auxv_t), "::", stringify!(a_type))
		);
	}
	test_field_a_type();
	fn test_field_a_un() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<Elf32_auxv_t>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).a_un) as usize - ptr as usize
		           },
		           4usize,
		           concat!("Offset of field: ", stringify!(Elf32_auxv_t), "::", stringify!(a_un))
		);
	}
	test_field_a_un();
}
#[repr(C)]
pub struct Elf64_auxv_t {
	pub a_type: u64,
	pub a_un: Elf64_auxv_t__bindgen_ty_1,
}
#[repr(C)]
pub struct Elf64_auxv_t__bindgen_ty_1 {
	pub a_val: __BindgenUnionField<u64>,
	pub bindgen_union_field: u64,
}
#[test]
fn bindgen_test_layout_Elf64_auxv_t__bindgen_ty_1() {
	assert_eq!(
	           ::core::mem::size_of::<Elf64_auxv_t__bindgen_ty_1>(),
	           8usize,
	           concat!("Size of: ", stringify!(Elf64_auxv_t__bindgen_ty_1))
	);
	assert_eq!(
	           ::core::mem::align_of::<Elf64_auxv_t__bindgen_ty_1>(),
	           8usize,
	           concat!("Alignment of ", stringify!(Elf64_auxv_t__bindgen_ty_1))
	);
	fn test_field_a_val() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<Elf64_auxv_t__bindgen_ty_1>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).a_val) as usize - ptr as usize
		           },
		           0usize,
		           concat!(
			"Offset of field: ",
			stringify!(Elf64_auxv_t__bindgen_ty_1),
			"::",
			stringify!(a_val)
		)
		);
	}
	test_field_a_val();
}
#[test]
fn bindgen_test_layout_Elf64_auxv_t() {
	assert_eq!(
	           ::core::mem::size_of::<Elf64_auxv_t>(),
	           16usize,
	           concat!("Size of: ", stringify!(Elf64_auxv_t))
	);
	assert_eq!(
	           ::core::mem::align_of::<Elf64_auxv_t>(),
	           8usize,
	           concat!("Alignment of ", stringify!(Elf64_auxv_t))
	);
	fn test_field_a_type() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<Elf64_auxv_t>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).a_type) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(Elf64_auxv_t), "::", stringify!(a_type))
		);
	}
	test_field_a_type();
	fn test_field_a_un() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<Elf64_auxv_t>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).a_un) as usize - ptr as usize
		           },
		           8usize,
		           concat!("Offset of field: ", stringify!(Elf64_auxv_t), "::", stringify!(a_un))
		);
	}
	test_field_a_un();
}
#[repr(C)]
pub struct Elf32_Nhdr {
	pub n_namesz: Elf32_Word,
	pub n_descsz: Elf32_Word,
	pub n_type: Elf32_Word,
}
#[test]
fn bindgen_test_layout_Elf32_Nhdr() {
	assert_eq!(
	           ::core::mem::size_of::<Elf32_Nhdr>(),
	           12usize,
	           concat!("Size of: ", stringify!(Elf32_Nhdr))
	);
	assert_eq!(
	           ::core::mem::align_of::<Elf32_Nhdr>(),
	           4usize,
	           concat!("Alignment of ", stringify!(Elf32_Nhdr))
	);
	fn test_field_n_namesz() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<Elf32_Nhdr>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).n_namesz) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(Elf32_Nhdr), "::", stringify!(n_namesz))
		);
	}
	test_field_n_namesz();
	fn test_field_n_descsz() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<Elf32_Nhdr>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).n_descsz) as usize - ptr as usize
		           },
		           4usize,
		           concat!("Offset of field: ", stringify!(Elf32_Nhdr), "::", stringify!(n_descsz))
		);
	}
	test_field_n_descsz();
	fn test_field_n_type() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<Elf32_Nhdr>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).n_type) as usize - ptr as usize
		           },
		           8usize,
		           concat!("Offset of field: ", stringify!(Elf32_Nhdr), "::", stringify!(n_type))
		);
	}
	test_field_n_type();
}
#[repr(C)]
pub struct Elf64_Nhdr {
	pub n_namesz: Elf64_Word,
	pub n_descsz: Elf64_Word,
	pub n_type: Elf64_Word,
}
#[test]
fn bindgen_test_layout_Elf64_Nhdr() {
	assert_eq!(
	           ::core::mem::size_of::<Elf64_Nhdr>(),
	           12usize,
	           concat!("Size of: ", stringify!(Elf64_Nhdr))
	);
	assert_eq!(
	           ::core::mem::align_of::<Elf64_Nhdr>(),
	           4usize,
	           concat!("Alignment of ", stringify!(Elf64_Nhdr))
	);
	fn test_field_n_namesz() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<Elf64_Nhdr>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).n_namesz) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(Elf64_Nhdr), "::", stringify!(n_namesz))
		);
	}
	test_field_n_namesz();
	fn test_field_n_descsz() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<Elf64_Nhdr>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).n_descsz) as usize - ptr as usize
		           },
		           4usize,
		           concat!("Offset of field: ", stringify!(Elf64_Nhdr), "::", stringify!(n_descsz))
		);
	}
	test_field_n_descsz();
	fn test_field_n_type() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<Elf64_Nhdr>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).n_type) as usize - ptr as usize
		           },
		           8usize,
		           concat!("Offset of field: ", stringify!(Elf64_Nhdr), "::", stringify!(n_type))
		);
	}
	test_field_n_type();
}
#[repr(C)]
pub struct Elf32_Move {
	pub m_value: Elf32_Xword,
	pub m_info: Elf32_Word,
	pub m_poffset: Elf32_Word,
	pub m_repeat: Elf32_Half,
	pub m_stride: Elf32_Half,
}
#[test]
fn bindgen_test_layout_Elf32_Move() {
	assert_eq!(
	           ::core::mem::size_of::<Elf32_Move>(),
	           24usize,
	           concat!("Size of: ", stringify!(Elf32_Move))
	);
	assert_eq!(
	           ::core::mem::align_of::<Elf32_Move>(),
	           8usize,
	           concat!("Alignment of ", stringify!(Elf32_Move))
	);
	fn test_field_m_value() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<Elf32_Move>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).m_value) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(Elf32_Move), "::", stringify!(m_value))
		);
	}
	test_field_m_value();
	fn test_field_m_info() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<Elf32_Move>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).m_info) as usize - ptr as usize
		           },
		           8usize,
		           concat!("Offset of field: ", stringify!(Elf32_Move), "::", stringify!(m_info))
		);
	}
	test_field_m_info();
	fn test_field_m_poffset() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<Elf32_Move>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).m_poffset) as usize - ptr as usize
		           },
		           12usize,
		           concat!("Offset of field: ", stringify!(Elf32_Move), "::", stringify!(m_poffset))
		);
	}
	test_field_m_poffset();
	fn test_field_m_repeat() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<Elf32_Move>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).m_repeat) as usize - ptr as usize
		           },
		           16usize,
		           concat!("Offset of field: ", stringify!(Elf32_Move), "::", stringify!(m_repeat))
		);
	}
	test_field_m_repeat();
	fn test_field_m_stride() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<Elf32_Move>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).m_stride) as usize - ptr as usize
		           },
		           18usize,
		           concat!("Offset of field: ", stringify!(Elf32_Move), "::", stringify!(m_stride))
		);
	}
	test_field_m_stride();
}
#[repr(C)]
pub struct Elf64_Move {
	pub m_value: Elf64_Xword,
	pub m_info: Elf64_Xword,
	pub m_poffset: Elf64_Xword,
	pub m_repeat: Elf64_Half,
	pub m_stride: Elf64_Half,
}
#[test]
fn bindgen_test_layout_Elf64_Move() {
	assert_eq!(
	           ::core::mem::size_of::<Elf64_Move>(),
	           32usize,
	           concat!("Size of: ", stringify!(Elf64_Move))
	);
	assert_eq!(
	           ::core::mem::align_of::<Elf64_Move>(),
	           8usize,
	           concat!("Alignment of ", stringify!(Elf64_Move))
	);
	fn test_field_m_value() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<Elf64_Move>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).m_value) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(Elf64_Move), "::", stringify!(m_value))
		);
	}
	test_field_m_value();
	fn test_field_m_info() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<Elf64_Move>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).m_info) as usize - ptr as usize
		           },
		           8usize,
		           concat!("Offset of field: ", stringify!(Elf64_Move), "::", stringify!(m_info))
		);
	}
	test_field_m_info();
	fn test_field_m_poffset() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<Elf64_Move>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).m_poffset) as usize - ptr as usize
		           },
		           16usize,
		           concat!("Offset of field: ", stringify!(Elf64_Move), "::", stringify!(m_poffset))
		);
	}
	test_field_m_poffset();
	fn test_field_m_repeat() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<Elf64_Move>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).m_repeat) as usize - ptr as usize
		           },
		           24usize,
		           concat!("Offset of field: ", stringify!(Elf64_Move), "::", stringify!(m_repeat))
		);
	}
	test_field_m_repeat();
	fn test_field_m_stride() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<Elf64_Move>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).m_stride) as usize - ptr as usize
		           },
		           26usize,
		           concat!("Offset of field: ", stringify!(Elf64_Move), "::", stringify!(m_stride))
		);
	}
	test_field_m_stride();
}
#[repr(C)]
pub struct Elf32_gptab {
	pub gt_header: __BindgenUnionField<Elf32_gptab__bindgen_ty_1>,
	pub gt_entry: __BindgenUnionField<Elf32_gptab__bindgen_ty_2>,
	pub bindgen_union_field: [u32; 2usize],
}
#[repr(C)]
pub struct Elf32_gptab__bindgen_ty_1 {
	pub gt_current_g_value: Elf32_Word,
	pub gt_unused: Elf32_Word,
}
#[test]
fn bindgen_test_layout_Elf32_gptab__bindgen_ty_1() {
	assert_eq!(
	           ::core::mem::size_of::<Elf32_gptab__bindgen_ty_1>(),
	           8usize,
	           concat!("Size of: ", stringify!(Elf32_gptab__bindgen_ty_1))
	);
	assert_eq!(
	           ::core::mem::align_of::<Elf32_gptab__bindgen_ty_1>(),
	           4usize,
	           concat!("Alignment of ", stringify!(Elf32_gptab__bindgen_ty_1))
	);
	fn test_field_gt_current_g_value() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<Elf32_gptab__bindgen_ty_1>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).gt_current_g_value) as usize - ptr as usize
		           },
		           0usize,
		           concat!(
			"Offset of field: ",
			stringify!(Elf32_gptab__bindgen_ty_1),
			"::",
			stringify!(gt_current_g_value)
		)
		);
	}
	test_field_gt_current_g_value();
	fn test_field_gt_unused() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<Elf32_gptab__bindgen_ty_1>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).gt_unused) as usize - ptr as usize
		           },
		           4usize,
		           concat!(
			"Offset of field: ",
			stringify!(Elf32_gptab__bindgen_ty_1),
			"::",
			stringify!(gt_unused)
		)
		);
	}
	test_field_gt_unused();
}
#[repr(C)]
pub struct Elf32_gptab__bindgen_ty_2 {
	pub gt_g_value: Elf32_Word,
	pub gt_bytes: Elf32_Word,
}
#[test]
fn bindgen_test_layout_Elf32_gptab__bindgen_ty_2() {
	assert_eq!(
	           ::core::mem::size_of::<Elf32_gptab__bindgen_ty_2>(),
	           8usize,
	           concat!("Size of: ", stringify!(Elf32_gptab__bindgen_ty_2))
	);
	assert_eq!(
	           ::core::mem::align_of::<Elf32_gptab__bindgen_ty_2>(),
	           4usize,
	           concat!("Alignment of ", stringify!(Elf32_gptab__bindgen_ty_2))
	);
	fn test_field_gt_g_value() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<Elf32_gptab__bindgen_ty_2>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).gt_g_value) as usize - ptr as usize
		           },
		           0usize,
		           concat!(
			"Offset of field: ",
			stringify!(Elf32_gptab__bindgen_ty_2),
			"::",
			stringify!(gt_g_value)
		)
		);
	}
	test_field_gt_g_value();
	fn test_field_gt_bytes() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<Elf32_gptab__bindgen_ty_2>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).gt_bytes) as usize - ptr as usize
		           },
		           4usize,
		           concat!(
			"Offset of field: ",
			stringify!(Elf32_gptab__bindgen_ty_2),
			"::",
			stringify!(gt_bytes)
		)
		);
	}
	test_field_gt_bytes();
}
#[test]
fn bindgen_test_layout_Elf32_gptab() {
	assert_eq!(
	           ::core::mem::size_of::<Elf32_gptab>(),
	           8usize,
	           concat!("Size of: ", stringify!(Elf32_gptab))
	);
	assert_eq!(
	           ::core::mem::align_of::<Elf32_gptab>(),
	           4usize,
	           concat!("Alignment of ", stringify!(Elf32_gptab))
	);
	fn test_field_gt_header() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<Elf32_gptab>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).gt_header) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(Elf32_gptab), "::", stringify!(gt_header))
		);
	}
	test_field_gt_header();
	fn test_field_gt_entry() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<Elf32_gptab>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).gt_entry) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(Elf32_gptab), "::", stringify!(gt_entry))
		);
	}
	test_field_gt_entry();
}
#[repr(C)]
pub struct Elf32_RegInfo {
	pub ri_gprmask: Elf32_Word,
	pub ri_cprmask: [Elf32_Word; 4usize],
	pub ri_gp_value: Elf32_Sword,
}
#[test]
fn bindgen_test_layout_Elf32_RegInfo() {
	assert_eq!(
	           ::core::mem::size_of::<Elf32_RegInfo>(),
	           24usize,
	           concat!("Size of: ", stringify!(Elf32_RegInfo))
	);
	assert_eq!(
	           ::core::mem::align_of::<Elf32_RegInfo>(),
	           4usize,
	           concat!("Alignment of ", stringify!(Elf32_RegInfo))
	);
	fn test_field_ri_gprmask() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<Elf32_RegInfo>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).ri_gprmask) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(Elf32_RegInfo), "::", stringify!(ri_gprmask))
		);
	}
	test_field_ri_gprmask();
	fn test_field_ri_cprmask() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<Elf32_RegInfo>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).ri_cprmask) as usize - ptr as usize
		           },
		           4usize,
		           concat!("Offset of field: ", stringify!(Elf32_RegInfo), "::", stringify!(ri_cprmask))
		);
	}
	test_field_ri_cprmask();
	fn test_field_ri_gp_value() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<Elf32_RegInfo>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).ri_gp_value) as usize - ptr as usize
		           },
		           20usize,
		           concat!("Offset of field: ", stringify!(Elf32_RegInfo), "::", stringify!(ri_gp_value))
		);
	}
	test_field_ri_gp_value();
}
#[repr(C)]
pub struct Elf_Options {
	pub kind: core::ffi::c_uchar,
	pub size: core::ffi::c_uchar,
	pub section: Elf32_Section,
	pub info: Elf32_Word,
}
#[test]
fn bindgen_test_layout_Elf_Options() {
	assert_eq!(
	           ::core::mem::size_of::<Elf_Options>(),
	           8usize,
	           concat!("Size of: ", stringify!(Elf_Options))
	);
	assert_eq!(
	           ::core::mem::align_of::<Elf_Options>(),
	           4usize,
	           concat!("Alignment of ", stringify!(Elf_Options))
	);
	fn test_field_kind() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<Elf_Options>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).kind) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(Elf_Options), "::", stringify!(kind))
		);
	}
	test_field_kind();
	fn test_field_size() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<Elf_Options>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).size) as usize - ptr as usize
		           },
		           1usize,
		           concat!("Offset of field: ", stringify!(Elf_Options), "::", stringify!(size))
		);
	}
	test_field_size();
	fn test_field_section() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<Elf_Options>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).section) as usize - ptr as usize
		           },
		           2usize,
		           concat!("Offset of field: ", stringify!(Elf_Options), "::", stringify!(section))
		);
	}
	test_field_section();
	fn test_field_info() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<Elf_Options>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).info) as usize - ptr as usize
		           },
		           4usize,
		           concat!("Offset of field: ", stringify!(Elf_Options), "::", stringify!(info))
		);
	}
	test_field_info();
}
#[repr(C)]
pub struct Elf_Options_Hw {
	pub hwp_flags1: Elf32_Word,
	pub hwp_flags2: Elf32_Word,
}
#[test]
fn bindgen_test_layout_Elf_Options_Hw() {
	assert_eq!(
	           ::core::mem::size_of::<Elf_Options_Hw>(),
	           8usize,
	           concat!("Size of: ", stringify!(Elf_Options_Hw))
	);
	assert_eq!(
	           ::core::mem::align_of::<Elf_Options_Hw>(),
	           4usize,
	           concat!("Alignment of ", stringify!(Elf_Options_Hw))
	);
	fn test_field_hwp_flags1() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<Elf_Options_Hw>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).hwp_flags1) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(Elf_Options_Hw), "::", stringify!(hwp_flags1))
		);
	}
	test_field_hwp_flags1();
	fn test_field_hwp_flags2() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<Elf_Options_Hw>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).hwp_flags2) as usize - ptr as usize
		           },
		           4usize,
		           concat!("Offset of field: ", stringify!(Elf_Options_Hw), "::", stringify!(hwp_flags2))
		);
	}
	test_field_hwp_flags2();
}
#[repr(C)]
pub struct Elf32_Lib {
	pub l_name: Elf32_Word,
	pub l_time_stamp: Elf32_Word,
	pub l_checksum: Elf32_Word,
	pub l_version: Elf32_Word,
	pub l_flags: Elf32_Word,
}
#[test]
fn bindgen_test_layout_Elf32_Lib() {
	assert_eq!(
	           ::core::mem::size_of::<Elf32_Lib>(),
	           20usize,
	           concat!("Size of: ", stringify!(Elf32_Lib))
	);
	assert_eq!(
	           ::core::mem::align_of::<Elf32_Lib>(),
	           4usize,
	           concat!("Alignment of ", stringify!(Elf32_Lib))
	);
	fn test_field_l_name() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<Elf32_Lib>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).l_name) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(Elf32_Lib), "::", stringify!(l_name))
		);
	}
	test_field_l_name();
	fn test_field_l_time_stamp() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<Elf32_Lib>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).l_time_stamp) as usize - ptr as usize
		           },
		           4usize,
		           concat!("Offset of field: ", stringify!(Elf32_Lib), "::", stringify!(l_time_stamp))
		);
	}
	test_field_l_time_stamp();
	fn test_field_l_checksum() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<Elf32_Lib>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).l_checksum) as usize - ptr as usize
		           },
		           8usize,
		           concat!("Offset of field: ", stringify!(Elf32_Lib), "::", stringify!(l_checksum))
		);
	}
	test_field_l_checksum();
	fn test_field_l_version() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<Elf32_Lib>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).l_version) as usize - ptr as usize
		           },
		           12usize,
		           concat!("Offset of field: ", stringify!(Elf32_Lib), "::", stringify!(l_version))
		);
	}
	test_field_l_version();
	fn test_field_l_flags() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<Elf32_Lib>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).l_flags) as usize - ptr as usize
		           },
		           16usize,
		           concat!("Offset of field: ", stringify!(Elf32_Lib), "::", stringify!(l_flags))
		);
	}
	test_field_l_flags();
}
#[repr(C)]
pub struct Elf64_Lib {
	pub l_name: Elf64_Word,
	pub l_time_stamp: Elf64_Word,
	pub l_checksum: Elf64_Word,
	pub l_version: Elf64_Word,
	pub l_flags: Elf64_Word,
}
#[test]
fn bindgen_test_layout_Elf64_Lib() {
	assert_eq!(
	           ::core::mem::size_of::<Elf64_Lib>(),
	           20usize,
	           concat!("Size of: ", stringify!(Elf64_Lib))
	);
	assert_eq!(
	           ::core::mem::align_of::<Elf64_Lib>(),
	           4usize,
	           concat!("Alignment of ", stringify!(Elf64_Lib))
	);
	fn test_field_l_name() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<Elf64_Lib>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).l_name) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(Elf64_Lib), "::", stringify!(l_name))
		);
	}
	test_field_l_name();
	fn test_field_l_time_stamp() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<Elf64_Lib>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).l_time_stamp) as usize - ptr as usize
		           },
		           4usize,
		           concat!("Offset of field: ", stringify!(Elf64_Lib), "::", stringify!(l_time_stamp))
		);
	}
	test_field_l_time_stamp();
	fn test_field_l_checksum() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<Elf64_Lib>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).l_checksum) as usize - ptr as usize
		           },
		           8usize,
		           concat!("Offset of field: ", stringify!(Elf64_Lib), "::", stringify!(l_checksum))
		);
	}
	test_field_l_checksum();
	fn test_field_l_version() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<Elf64_Lib>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).l_version) as usize - ptr as usize
		           },
		           12usize,
		           concat!("Offset of field: ", stringify!(Elf64_Lib), "::", stringify!(l_version))
		);
	}
	test_field_l_version();
	fn test_field_l_flags() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<Elf64_Lib>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).l_flags) as usize - ptr as usize
		           },
		           16usize,
		           concat!("Offset of field: ", stringify!(Elf64_Lib), "::", stringify!(l_flags))
		);
	}
	test_field_l_flags();
}
pub type Elf32_Conflict = Elf32_Addr;
#[repr(C)]
pub struct Elf_MIPS_ABIFlags_v0 {
	pub version: Elf32_Half,
	pub isa_level: core::ffi::c_uchar,
	pub isa_rev: core::ffi::c_uchar,
	pub gpr_size: core::ffi::c_uchar,
	pub cpr1_size: core::ffi::c_uchar,
	pub cpr2_size: core::ffi::c_uchar,
	pub fp_abi: core::ffi::c_uchar,
	pub isa_ext: Elf32_Word,
	pub ases: Elf32_Word,
	pub flags1: Elf32_Word,
	pub flags2: Elf32_Word,
}
#[test]
fn bindgen_test_layout_Elf_MIPS_ABIFlags_v0() {
	assert_eq!(
	           ::core::mem::size_of::<Elf_MIPS_ABIFlags_v0>(),
	           24usize,
	           concat!("Size of: ", stringify!(Elf_MIPS_ABIFlags_v0))
	);
	assert_eq!(
	           ::core::mem::align_of::<Elf_MIPS_ABIFlags_v0>(),
	           4usize,
	           concat!("Alignment of ", stringify!(Elf_MIPS_ABIFlags_v0))
	);
	fn test_field_version() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<Elf_MIPS_ABIFlags_v0>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).version) as usize - ptr as usize
		           },
		           0usize,
		           concat!(
			"Offset of field: ",
			stringify!(Elf_MIPS_ABIFlags_v0),
			"::",
			stringify!(version)
		)
		);
	}
	test_field_version();
	fn test_field_isa_level() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<Elf_MIPS_ABIFlags_v0>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).isa_level) as usize - ptr as usize
		           },
		           2usize,
		           concat!(
			"Offset of field: ",
			stringify!(Elf_MIPS_ABIFlags_v0),
			"::",
			stringify!(isa_level)
		)
		);
	}
	test_field_isa_level();
	fn test_field_isa_rev() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<Elf_MIPS_ABIFlags_v0>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).isa_rev) as usize - ptr as usize
		           },
		           3usize,
		           concat!(
			"Offset of field: ",
			stringify!(Elf_MIPS_ABIFlags_v0),
			"::",
			stringify!(isa_rev)
		)
		);
	}
	test_field_isa_rev();
	fn test_field_gpr_size() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<Elf_MIPS_ABIFlags_v0>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).gpr_size) as usize - ptr as usize
		           },
		           4usize,
		           concat!(
			"Offset of field: ",
			stringify!(Elf_MIPS_ABIFlags_v0),
			"::",
			stringify!(gpr_size)
		)
		);
	}
	test_field_gpr_size();
	fn test_field_cpr1_size() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<Elf_MIPS_ABIFlags_v0>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).cpr1_size) as usize - ptr as usize
		           },
		           5usize,
		           concat!(
			"Offset of field: ",
			stringify!(Elf_MIPS_ABIFlags_v0),
			"::",
			stringify!(cpr1_size)
		)
		);
	}
	test_field_cpr1_size();
	fn test_field_cpr2_size() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<Elf_MIPS_ABIFlags_v0>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).cpr2_size) as usize - ptr as usize
		           },
		           6usize,
		           concat!(
			"Offset of field: ",
			stringify!(Elf_MIPS_ABIFlags_v0),
			"::",
			stringify!(cpr2_size)
		)
		);
	}
	test_field_cpr2_size();
	fn test_field_fp_abi() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<Elf_MIPS_ABIFlags_v0>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).fp_abi) as usize - ptr as usize
		           },
		           7usize,
		           concat!(
			"Offset of field: ",
			stringify!(Elf_MIPS_ABIFlags_v0),
			"::",
			stringify!(fp_abi)
		)
		);
	}
	test_field_fp_abi();
	fn test_field_isa_ext() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<Elf_MIPS_ABIFlags_v0>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).isa_ext) as usize - ptr as usize
		           },
		           8usize,
		           concat!(
			"Offset of field: ",
			stringify!(Elf_MIPS_ABIFlags_v0),
			"::",
			stringify!(isa_ext)
		)
		);
	}
	test_field_isa_ext();
	fn test_field_ases() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<Elf_MIPS_ABIFlags_v0>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).ases) as usize - ptr as usize
		           },
		           12usize,
		           concat!("Offset of field: ", stringify!(Elf_MIPS_ABIFlags_v0), "::", stringify!(ases))
		);
	}
	test_field_ases();
	fn test_field_flags1() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<Elf_MIPS_ABIFlags_v0>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).flags1) as usize - ptr as usize
		           },
		           16usize,
		           concat!(
			"Offset of field: ",
			stringify!(Elf_MIPS_ABIFlags_v0),
			"::",
			stringify!(flags1)
		)
		);
	}
	test_field_flags1();
	fn test_field_flags2() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<Elf_MIPS_ABIFlags_v0>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).flags2) as usize - ptr as usize
		           },
		           20usize,
		           concat!(
			"Offset of field: ",
			stringify!(Elf_MIPS_ABIFlags_v0),
			"::",
			stringify!(flags2)
		)
		);
	}
	test_field_flags2();
}
pub const Val_GNU_MIPS_ABI_FP_ANY: _bindgen_ty_14 = _bindgen_ty_14::Val_GNU_MIPS_ABI_FP_ANY;
pub const Val_GNU_MIPS_ABI_FP_DOUBLE: _bindgen_ty_14 = _bindgen_ty_14::Val_GNU_MIPS_ABI_FP_DOUBLE;
pub const Val_GNU_MIPS_ABI_FP_SINGLE: _bindgen_ty_14 = _bindgen_ty_14::Val_GNU_MIPS_ABI_FP_SINGLE;
pub const Val_GNU_MIPS_ABI_FP_SOFT: _bindgen_ty_14 = _bindgen_ty_14::Val_GNU_MIPS_ABI_FP_SOFT;
pub const Val_GNU_MIPS_ABI_FP_OLD_64: _bindgen_ty_14 = _bindgen_ty_14::Val_GNU_MIPS_ABI_FP_OLD_64;
pub const Val_GNU_MIPS_ABI_FP_XX: _bindgen_ty_14 = _bindgen_ty_14::Val_GNU_MIPS_ABI_FP_XX;
pub const Val_GNU_MIPS_ABI_FP_64: _bindgen_ty_14 = _bindgen_ty_14::Val_GNU_MIPS_ABI_FP_64;
pub const Val_GNU_MIPS_ABI_FP_64A: _bindgen_ty_14 = _bindgen_ty_14::Val_GNU_MIPS_ABI_FP_64A;
pub const Val_GNU_MIPS_ABI_FP_MAX: _bindgen_ty_14 = _bindgen_ty_14::Val_GNU_MIPS_ABI_FP_64A;
#[repr(u32)]
#[non_exhaustive]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum _bindgen_ty_14 {
	Val_GNU_MIPS_ABI_FP_ANY = 0,
	Val_GNU_MIPS_ABI_FP_DOUBLE = 1,
	Val_GNU_MIPS_ABI_FP_SINGLE = 2,
	Val_GNU_MIPS_ABI_FP_SOFT = 3,
	Val_GNU_MIPS_ABI_FP_OLD_64 = 4,
	Val_GNU_MIPS_ABI_FP_XX = 5,
	Val_GNU_MIPS_ABI_FP_64 = 6,
	Val_GNU_MIPS_ABI_FP_64A = 7,
}
#[repr(C)]
pub struct ElfApiInterface {
	pub api_version_major: u16,
	pub api_version_minor: u16,
	pub resolver_callback:
		::core::option::Option<unsafe extern "C" fn(name: *const core::ffi::c_char, address: *mut Elf32_Addr) -> bool>,
}
#[test]
fn bindgen_test_layout_ElfApiInterface() {
	assert_eq!(
	           ::core::mem::size_of::<ElfApiInterface>(),
	           8usize,
	           concat!("Size of: ", stringify!(ElfApiInterface))
	);
	assert_eq!(
	           ::core::mem::align_of::<ElfApiInterface>(),
	           4usize,
	           concat!("Alignment of ", stringify!(ElfApiInterface))
	);
	fn test_field_api_version_major() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<ElfApiInterface>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).api_version_major) as usize - ptr as usize
		           },
		           0usize,
		           concat!(
			"Offset of field: ",
			stringify!(ElfApiInterface),
			"::",
			stringify!(api_version_major)
		)
		);
	}
	test_field_api_version_major();
	fn test_field_api_version_minor() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<ElfApiInterface>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).api_version_minor) as usize - ptr as usize
		           },
		           2usize,
		           concat!(
			"Offset of field: ",
			stringify!(ElfApiInterface),
			"::",
			stringify!(api_version_minor)
		)
		);
	}
	test_field_api_version_minor();
	fn test_field_resolver_callback() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<ElfApiInterface>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).resolver_callback) as usize - ptr as usize
		           },
		           4usize,
		           concat!(
			"Offset of field: ",
			stringify!(ElfApiInterface),
			"::",
			stringify!(resolver_callback)
		)
		);
	}
	test_field_resolver_callback();
}
#[repr(C, packed)]
pub struct FlipperApplicationManifestBase {
	pub manifest_magic: u32,
	pub manifest_version: u32,
	pub api_version: FlipperApplicationManifestBase__bindgen_ty_1,
	pub hardware_target_id: u16,
}
#[repr(C, packed)]
pub struct FlipperApplicationManifestBase__bindgen_ty_1 {
	pub __bindgen_anon_1: __BindgenUnionField<FlipperApplicationManifestBase__bindgen_ty_1__bindgen_ty_1>,
	pub version: __BindgenUnionField<u32>,
	pub bindgen_union_field: [u8; 4usize],
}
#[repr(C, packed)]
pub struct FlipperApplicationManifestBase__bindgen_ty_1__bindgen_ty_1 {
	pub minor: u16,
	pub major: u16,
}
#[test]
fn bindgen_test_layout_FlipperApplicationManifestBase__bindgen_ty_1__bindgen_ty_1() {
	assert_eq!(
	           ::core::mem::size_of::<FlipperApplicationManifestBase__bindgen_ty_1__bindgen_ty_1>(),
	           4usize,
	           concat!(
		"Size of: ",
		stringify!(FlipperApplicationManifestBase__bindgen_ty_1__bindgen_ty_1)
	)
	);
	assert_eq!(
	           ::core::mem::align_of::<FlipperApplicationManifestBase__bindgen_ty_1__bindgen_ty_1>(),
	           1usize,
	           concat!(
		"Alignment of ",
		stringify!(FlipperApplicationManifestBase__bindgen_ty_1__bindgen_ty_1)
	)
	);
	fn test_field_minor() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<FlipperApplicationManifestBase__bindgen_ty_1__bindgen_ty_1>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).minor) as usize - ptr as usize
		           },
		           0usize,
		           concat!(
			"Offset of field: ",
			stringify!(FlipperApplicationManifestBase__bindgen_ty_1__bindgen_ty_1),
			"::",
			stringify!(minor)
		)
		);
	}
	test_field_minor();
	fn test_field_major() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<FlipperApplicationManifestBase__bindgen_ty_1__bindgen_ty_1>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).major) as usize - ptr as usize
		           },
		           2usize,
		           concat!(
			"Offset of field: ",
			stringify!(FlipperApplicationManifestBase__bindgen_ty_1__bindgen_ty_1),
			"::",
			stringify!(major)
		)
		);
	}
	test_field_major();
}
#[test]
fn bindgen_test_layout_FlipperApplicationManifestBase__bindgen_ty_1() {
	assert_eq!(
	           ::core::mem::size_of::<FlipperApplicationManifestBase__bindgen_ty_1>(),
	           4usize,
	           concat!("Size of: ", stringify!(FlipperApplicationManifestBase__bindgen_ty_1))
	);
	assert_eq!(
	           ::core::mem::align_of::<FlipperApplicationManifestBase__bindgen_ty_1>(),
	           1usize,
	           concat!("Alignment of ", stringify!(FlipperApplicationManifestBase__bindgen_ty_1))
	);
	fn test_field_version() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<FlipperApplicationManifestBase__bindgen_ty_1>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).version) as usize - ptr as usize
		           },
		           0usize,
		           concat!(
			"Offset of field: ",
			stringify!(FlipperApplicationManifestBase__bindgen_ty_1),
			"::",
			stringify!(version)
		)
		);
	}
	test_field_version();
}
#[test]
fn bindgen_test_layout_FlipperApplicationManifestBase() {
	assert_eq!(
	           ::core::mem::size_of::<FlipperApplicationManifestBase>(),
	           14usize,
	           concat!("Size of: ", stringify!(FlipperApplicationManifestBase))
	);
	assert_eq!(
	           ::core::mem::align_of::<FlipperApplicationManifestBase>(),
	           1usize,
	           concat!("Alignment of ", stringify!(FlipperApplicationManifestBase))
	);
	fn test_field_manifest_magic() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<FlipperApplicationManifestBase>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).manifest_magic) as usize - ptr as usize
		           },
		           0usize,
		           concat!(
			"Offset of field: ",
			stringify!(FlipperApplicationManifestBase),
			"::",
			stringify!(manifest_magic)
		)
		);
	}
	test_field_manifest_magic();
	fn test_field_manifest_version() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<FlipperApplicationManifestBase>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).manifest_version) as usize - ptr as usize
		           },
		           4usize,
		           concat!(
			"Offset of field: ",
			stringify!(FlipperApplicationManifestBase),
			"::",
			stringify!(manifest_version)
		)
		);
	}
	test_field_manifest_version();
	fn test_field_api_version() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<FlipperApplicationManifestBase>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).api_version) as usize - ptr as usize
		           },
		           8usize,
		           concat!(
			"Offset of field: ",
			stringify!(FlipperApplicationManifestBase),
			"::",
			stringify!(api_version)
		)
		);
	}
	test_field_api_version();
	fn test_field_hardware_target_id() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<FlipperApplicationManifestBase>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).hardware_target_id) as usize - ptr as usize
		           },
		           12usize,
		           concat!(
			"Offset of field: ",
			stringify!(FlipperApplicationManifestBase),
			"::",
			stringify!(hardware_target_id)
		)
		);
	}
	test_field_hardware_target_id();
}
#[repr(C, packed)]
pub struct FlipperApplicationManifestV1 {
	pub base: FlipperApplicationManifestBase,
	pub stack_size: u16,
	pub app_version: u32,
	pub name: [core::ffi::c_char; 32usize],
	pub has_icon: core::ffi::c_char,
	pub icon: [core::ffi::c_char; 32usize],
}
#[test]
fn bindgen_test_layout_FlipperApplicationManifestV1() {
	assert_eq!(
	           ::core::mem::size_of::<FlipperApplicationManifestV1>(),
	           85usize,
	           concat!("Size of: ", stringify!(FlipperApplicationManifestV1))
	);
	assert_eq!(
	           ::core::mem::align_of::<FlipperApplicationManifestV1>(),
	           1usize,
	           concat!("Alignment of ", stringify!(FlipperApplicationManifestV1))
	);
	fn test_field_base() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<FlipperApplicationManifestV1>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).base) as usize - ptr as usize
		           },
		           0usize,
		           concat!(
			"Offset of field: ",
			stringify!(FlipperApplicationManifestV1),
			"::",
			stringify!(base)
		)
		);
	}
	test_field_base();
	fn test_field_stack_size() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<FlipperApplicationManifestV1>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).stack_size) as usize - ptr as usize
		           },
		           14usize,
		           concat!(
			"Offset of field: ",
			stringify!(FlipperApplicationManifestV1),
			"::",
			stringify!(stack_size)
		)
		);
	}
	test_field_stack_size();
	fn test_field_app_version() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<FlipperApplicationManifestV1>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).app_version) as usize - ptr as usize
		           },
		           16usize,
		           concat!(
			"Offset of field: ",
			stringify!(FlipperApplicationManifestV1),
			"::",
			stringify!(app_version)
		)
		);
	}
	test_field_app_version();
	fn test_field_name() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<FlipperApplicationManifestV1>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).name) as usize - ptr as usize
		           },
		           20usize,
		           concat!(
			"Offset of field: ",
			stringify!(FlipperApplicationManifestV1),
			"::",
			stringify!(name)
		)
		);
	}
	test_field_name();
	fn test_field_has_icon() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<FlipperApplicationManifestV1>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).has_icon) as usize - ptr as usize
		           },
		           52usize,
		           concat!(
			"Offset of field: ",
			stringify!(FlipperApplicationManifestV1),
			"::",
			stringify!(has_icon)
		)
		);
	}
	test_field_has_icon();
	fn test_field_icon() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<FlipperApplicationManifestV1>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).icon) as usize - ptr as usize
		           },
		           53usize,
		           concat!(
			"Offset of field: ",
			stringify!(FlipperApplicationManifestV1),
			"::",
			stringify!(icon)
		)
		);
	}
	test_field_icon();
}
pub type FlipperApplicationManifest = FlipperApplicationManifestV1;
extern "C" {
	#[doc = " @brief Check if manifest is valid"]
	#[doc = ""]
	#[doc = " @param manifest"]
	#[doc = " @return bool"]
	pub fn flipper_application_manifest_is_valid(manifest: *const FlipperApplicationManifest) -> bool;
}
extern "C" {
	#[doc = " @brief Check if manifest is compatible with current ELF API interface"]
	#[doc = ""]
	#[doc = " @param manifest"]
	#[doc = " @param api_interface"]
	#[doc = " @return bool"]
	pub fn flipper_application_manifest_is_compatible(manifest: *const FlipperApplicationManifest,
	                                                  api_interface: *const ElfApiInterface)
	                                                  -> bool;
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum FlipperApplicationPreloadStatus {
	FlipperApplicationPreloadStatusSuccess = 0,
	FlipperApplicationPreloadStatusUnspecifiedError = 1,
	FlipperApplicationPreloadStatusInvalidFile = 2,
	FlipperApplicationPreloadStatusInvalidManifest = 3,
	FlipperApplicationPreloadStatusApiMismatch = 4,
	FlipperApplicationPreloadStatusTargetMismatch = 5,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum FlipperApplicationLoadStatus {
	FlipperApplicationLoadStatusSuccess = 0,
	FlipperApplicationLoadStatusUnspecifiedError = 1,
	FlipperApplicationLoadStatusNoFreeMemory = 2,
	FlipperApplicationLoadStatusMissingImports = 3,
}
extern "C" {
	#[doc = " @brief Get text description of preload status"]
	#[doc = " @param status Status code"]
	#[doc = " @return String pointer to description"]
	pub fn flipper_application_preload_status_to_string(status: FlipperApplicationPreloadStatus) -> *const core::ffi::c_char;
}
extern "C" {
	#[doc = " @brief Get text description of load status"]
	#[doc = " @param status Status code"]
	#[doc = " @return String pointer to description"]
	pub fn flipper_application_load_status_to_string(status: FlipperApplicationLoadStatus) -> *const core::ffi::c_char;
}
#[repr(C)]
pub struct FlipperApplication {
	_unused: [u8; 0],
}
#[repr(C)]
pub struct FlipperApplicationMemoryMapEntry {
	pub name: *const core::ffi::c_char,
	pub address: u32,
}
#[test]
fn bindgen_test_layout_FlipperApplicationMemoryMapEntry() {
	assert_eq!(
	           ::core::mem::size_of::<FlipperApplicationMemoryMapEntry>(),
	           8usize,
	           concat!("Size of: ", stringify!(FlipperApplicationMemoryMapEntry))
	);
	assert_eq!(
	           ::core::mem::align_of::<FlipperApplicationMemoryMapEntry>(),
	           4usize,
	           concat!("Alignment of ", stringify!(FlipperApplicationMemoryMapEntry))
	);
	fn test_field_name() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<FlipperApplicationMemoryMapEntry>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).name) as usize - ptr as usize
		           },
		           0usize,
		           concat!(
			"Offset of field: ",
			stringify!(FlipperApplicationMemoryMapEntry),
			"::",
			stringify!(name)
		)
		);
	}
	test_field_name();
	fn test_field_address() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<FlipperApplicationMemoryMapEntry>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).address) as usize - ptr as usize
		           },
		           4usize,
		           concat!(
			"Offset of field: ",
			stringify!(FlipperApplicationMemoryMapEntry),
			"::",
			stringify!(address)
		)
		);
	}
	test_field_address();
}
#[repr(C)]
pub struct FlipperApplicationState {
	pub mmap_entry_count: u32,
	pub mmap_entries: *mut FlipperApplicationMemoryMapEntry,
	pub debug_link_size: u32,
	pub debug_link: *mut u8,
}
#[test]
fn bindgen_test_layout_FlipperApplicationState() {
	assert_eq!(
	           ::core::mem::size_of::<FlipperApplicationState>(),
	           16usize,
	           concat!("Size of: ", stringify!(FlipperApplicationState))
	);
	assert_eq!(
	           ::core::mem::align_of::<FlipperApplicationState>(),
	           4usize,
	           concat!("Alignment of ", stringify!(FlipperApplicationState))
	);
	fn test_field_mmap_entry_count() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<FlipperApplicationState>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).mmap_entry_count) as usize - ptr as usize
		           },
		           0usize,
		           concat!(
			"Offset of field: ",
			stringify!(FlipperApplicationState),
			"::",
			stringify!(mmap_entry_count)
		)
		);
	}
	test_field_mmap_entry_count();
	fn test_field_mmap_entries() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<FlipperApplicationState>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).mmap_entries) as usize - ptr as usize
		           },
		           4usize,
		           concat!(
			"Offset of field: ",
			stringify!(FlipperApplicationState),
			"::",
			stringify!(mmap_entries)
		)
		);
	}
	test_field_mmap_entries();
	fn test_field_debug_link_size() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<FlipperApplicationState>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).debug_link_size) as usize - ptr as usize
		           },
		           8usize,
		           concat!(
			"Offset of field: ",
			stringify!(FlipperApplicationState),
			"::",
			stringify!(debug_link_size)
		)
		);
	}
	test_field_debug_link_size();
	fn test_field_debug_link() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<FlipperApplicationState>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).debug_link) as usize - ptr as usize
		           },
		           12usize,
		           concat!(
			"Offset of field: ",
			stringify!(FlipperApplicationState),
			"::",
			stringify!(debug_link)
		)
		);
	}
	test_field_debug_link();
}
extern "C" {
	#[doc = " @brief Initialize FlipperApplication object"]
	#[doc = " @param storage Storage instance"]
	#[doc = " @param api_interface ELF API interface to use for pre-loading and symbol resolving"]
	#[doc = " @return Application instance"]
	pub fn flipper_application_alloc(storage: *mut Storage, api_interface: *const ElfApiInterface) -> *mut FlipperApplication;
}
extern "C" {
	#[doc = " @brief Destroy FlipperApplication object"]
	#[doc = " @param app Application pointer"]
	pub fn flipper_application_free(app: *mut FlipperApplication);
}
extern "C" {
	#[doc = " @brief Validate elf file and load application metadata"]
	#[doc = " @param app Application pointer"]
	#[doc = " @return Preload result code"]
	pub fn flipper_application_preload(app: *mut FlipperApplication,
	                                   path: *const core::ffi::c_char)
	                                   -> FlipperApplicationPreloadStatus;
}
extern "C" {
	#[doc = " @brief Validate elf file and load application manifest"]
	#[doc = " @param app Application pointer"]
	#[doc = " @return Preload result code"]
	pub fn flipper_application_preload_manifest(app: *mut FlipperApplication,
	                                            path: *const core::ffi::c_char)
	                                            -> FlipperApplicationPreloadStatus;
}
extern "C" {
	#[doc = " @brief Get pointer to application manifest for preloaded application"]
	#[doc = " @param app Application pointer"]
	#[doc = " @return Pointer to application manifest"]
	pub fn flipper_application_get_manifest(app: *mut FlipperApplication) -> *const FlipperApplicationManifest;
}
extern "C" {
	#[doc = " @brief Load sections and process relocations for already pre-loaded application"]
	#[doc = " @param app Application pointer"]
	#[doc = " @return Load result code"]
	pub fn flipper_application_map_to_memory(app: *mut FlipperApplication) -> FlipperApplicationLoadStatus;
}
extern "C" {
	#[doc = " @brief Create application thread at entry point address, using app name and"]
	#[doc = " stack size from metadata. Returned thread isn't started yet."]
	#[doc = " Can be only called once for application instance."]
	#[doc = " @param app Applicaiton pointer"]
	#[doc = " @param args Object to pass to app's entry point"]
	#[doc = " @return Created thread"]
	pub fn flipper_application_spawn(app: *mut FlipperApplication, args: *mut core::ffi::c_void) -> *mut FuriThread;
}
#[repr(C)]
pub struct FlipperFormat {
	_unused: [u8; 0],
}
extern "C" {
	#[doc = " Allocate FlipperFormat as string."]
	#[doc = " @return FlipperFormat* pointer to a FlipperFormat instance"]
	pub fn flipper_format_string_alloc() -> *mut FlipperFormat;
}
extern "C" {
	#[doc = " Allocate FlipperFormat as file."]
	#[doc = " @return FlipperFormat* pointer to a FlipperFormat instance"]
	pub fn flipper_format_file_alloc(storage: *mut Storage) -> *mut FlipperFormat;
}
extern "C" {
	#[doc = " Allocate FlipperFormat as file, buffered mode."]
	#[doc = " @return FlipperFormat* pointer to a FlipperFormat instance"]
	pub fn flipper_format_buffered_file_alloc(storage: *mut Storage) -> *mut FlipperFormat;
}
extern "C" {
	#[doc = " Open existing file."]
	#[doc = " Use only if FlipperFormat allocated as a file."]
	#[doc = " @param flipper_format Pointer to a FlipperFormat instance"]
	#[doc = " @param path File path"]
	#[doc = " @return True on success"]
	pub fn flipper_format_file_open_existing(flipper_format: *mut FlipperFormat, path: *const core::ffi::c_char) -> bool;
}
extern "C" {
	#[doc = " Open existing file, buffered mode."]
	#[doc = " Use only if FlipperFormat allocated as a file."]
	#[doc = " @param flipper_format Pointer to a FlipperFormat instance"]
	#[doc = " @param path File path"]
	#[doc = " @return True on success"]
	pub fn flipper_format_buffered_file_open_existing(flipper_format: *mut FlipperFormat, path: *const core::ffi::c_char) -> bool;
}
extern "C" {
	#[doc = " Open existing file for writing and add values to the end of file."]
	#[doc = " Use only if FlipperFormat allocated as a file."]
	#[doc = " @param flipper_format Pointer to a FlipperFormat instance"]
	#[doc = " @param path File path"]
	#[doc = " @return True on success"]
	pub fn flipper_format_file_open_append(flipper_format: *mut FlipperFormat, path: *const core::ffi::c_char) -> bool;
}
extern "C" {
	#[doc = " Open file. Creates a new file, or deletes the contents of the file if it already exists."]
	#[doc = " Use only if FlipperFormat allocated as a file."]
	#[doc = " @param flipper_format Pointer to a FlipperFormat instance"]
	#[doc = " @param path File path"]
	#[doc = " @return True on success"]
	pub fn flipper_format_file_open_always(flipper_format: *mut FlipperFormat, path: *const core::ffi::c_char) -> bool;
}
extern "C" {
	#[doc = " Open file. Creates a new file, fails if file already exists."]
	#[doc = " Use only if FlipperFormat allocated as a file."]
	#[doc = " @param flipper_format Pointer to a FlipperFormat instance"]
	#[doc = " @param path File path"]
	#[doc = " @return True on success"]
	pub fn flipper_format_file_open_new(flipper_format: *mut FlipperFormat, path: *const core::ffi::c_char) -> bool;
}
extern "C" {
	#[doc = " Closes the file, use only if FlipperFormat allocated as a file."]
	#[doc = " @param flipper_format"]
	#[doc = " @return true"]
	#[doc = " @return false"]
	pub fn flipper_format_file_close(flipper_format: *mut FlipperFormat) -> bool;
}
extern "C" {
	#[doc = " Closes the file, use only if FlipperFormat allocated as a buffered file."]
	#[doc = " @param flipper_format"]
	#[doc = " @return true"]
	#[doc = " @return false"]
	pub fn flipper_format_buffered_file_close(flipper_format: *mut FlipperFormat) -> bool;
}
extern "C" {
	#[doc = " Free FlipperFormat."]
	#[doc = " @param flipper_format Pointer to a FlipperFormat instance"]
	pub fn flipper_format_free(flipper_format: *mut FlipperFormat);
}
extern "C" {
	#[doc = " Set FlipperFormat mode."]
	#[doc = " @param flipper_format Pointer to a FlipperFormat instance"]
	#[doc = " @param strict_mode True obligates not to skip valid fields. False by default."]
	pub fn flipper_format_set_strict_mode(flipper_format: *mut FlipperFormat, strict_mode: bool);
}
extern "C" {
	#[doc = " Rewind the RW pointer."]
	#[doc = " @param flipper_format Pointer to a FlipperFormat instance"]
	#[doc = " @return True on success"]
	pub fn flipper_format_rewind(flipper_format: *mut FlipperFormat) -> bool;
}
extern "C" {
	#[doc = " Move the RW pointer at the end. Can be useful if you want to add some data after reading."]
	#[doc = " @param flipper_format Pointer to a FlipperFormat instance"]
	#[doc = " @return True on success"]
	pub fn flipper_format_seek_to_end(flipper_format: *mut FlipperFormat) -> bool;
}
extern "C" {
	#[doc = " Check if the key exists."]
	#[doc = " @param flipper_format Pointer to a FlipperFormat instance"]
	#[doc = " @param key Key"]
	#[doc = " @return true key exists"]
	#[doc = " @return false key is not exists"]
	pub fn flipper_format_key_exist(flipper_format: *mut FlipperFormat, key: *const core::ffi::c_char) -> bool;
}
extern "C" {
	#[doc = " Read the header (file type and version)."]
	#[doc = " @param flipper_format Pointer to a FlipperFormat instance"]
	#[doc = " @param filetype File type string"]
	#[doc = " @param version Version Value"]
	#[doc = " @return True on success"]
	pub fn flipper_format_read_header(flipper_format: *mut FlipperFormat, filetype: *mut string_t, version: *mut u32) -> bool;
}
extern "C" {
	#[doc = " Write the header (file type and version)."]
	#[doc = " @param flipper_format Pointer to a FlipperFormat instance"]
	#[doc = " @param filetype File type string"]
	#[doc = " @param version Version Value"]
	#[doc = " @return True on success"]
	pub fn flipper_format_write_header(flipper_format: *mut FlipperFormat, filetype: *mut string_t, version: u32) -> bool;
}
extern "C" {
	#[doc = " Write the header (file type and version). Plain C string version."]
	#[doc = " @param flipper_format Pointer to a FlipperFormat instance"]
	#[doc = " @param filetype File type string"]
	#[doc = " @param version Version Value"]
	#[doc = " @return True on success"]
	pub fn flipper_format_write_header_cstr(flipper_format: *mut FlipperFormat,
	                                        filetype: *const core::ffi::c_char,
	                                        version: u32)
	                                        -> bool;
}
extern "C" {
	#[doc = " Get the count of values by key"]
	#[doc = " @param flipper_format Pointer to a FlipperFormat instance"]
	#[doc = " @param key"]
	#[doc = " @param count"]
	#[doc = " @return bool"]
	pub fn flipper_format_get_value_count(flipper_format: *mut FlipperFormat, key: *const core::ffi::c_char, count: *mut u32) -> bool;
}
extern "C" {
	#[doc = " Read a string by key"]
	#[doc = " @param flipper_format Pointer to a FlipperFormat instance"]
	#[doc = " @param key Key"]
	#[doc = " @param data Value"]
	#[doc = " @return True on success"]
	pub fn flipper_format_read_string(flipper_format: *mut FlipperFormat, key: *const core::ffi::c_char, data: *mut string_t) -> bool;
}
extern "C" {
	#[doc = " Write key and string"]
	#[doc = " @param flipper_format Pointer to a FlipperFormat instance"]
	#[doc = " @param key Key"]
	#[doc = " @param data Value"]
	#[doc = " @return True on success"]
	pub fn flipper_format_write_string(flipper_format: *mut FlipperFormat, key: *const core::ffi::c_char, data: *mut string_t)
	                                   -> bool;
}
extern "C" {
	#[doc = " Write key and string. Plain C string version."]
	#[doc = " @param flipper_format Pointer to a FlipperFormat instance"]
	#[doc = " @param key Key"]
	#[doc = " @param data Value"]
	#[doc = " @return True on success"]
	pub fn flipper_format_write_string_cstr(flipper_format: *mut FlipperFormat,
	                                        key: *const core::ffi::c_char,
	                                        data: *const core::ffi::c_char)
	                                        -> bool;
}
extern "C" {
	#[doc = " Read array of uint64 in hex format by key"]
	#[doc = " @param flipper_format Pointer to a FlipperFormat instance"]
	#[doc = " @param key Key"]
	#[doc = " @param data Value"]
	#[doc = " @param data_size Values count"]
	#[doc = " @return True on success"]
	pub fn flipper_format_read_hex_uint64(flipper_format: *mut FlipperFormat,
	                                      key: *const core::ffi::c_char,
	                                      data: *mut u64,
	                                      data_size: u16)
	                                      -> bool;
}
extern "C" {
	#[doc = " Write key and array of uint64 in hex format"]
	#[doc = " @param flipper_format Pointer to a FlipperFormat instance"]
	#[doc = " @param key Key"]
	#[doc = " @param data Value"]
	#[doc = " @param data_size Values count"]
	#[doc = " @return True on success"]
	pub fn flipper_format_write_hex_uint64(flipper_format: *mut FlipperFormat,
	                                       key: *const core::ffi::c_char,
	                                       data: *const u64,
	                                       data_size: u16)
	                                       -> bool;
}
extern "C" {
	#[doc = " Read array of uint32 by key"]
	#[doc = " @param flipper_format Pointer to a FlipperFormat instance"]
	#[doc = " @param key Key"]
	#[doc = " @param data Value"]
	#[doc = " @param data_size Values count"]
	#[doc = " @return True on success"]
	pub fn flipper_format_read_uint32(flipper_format: *mut FlipperFormat,
	                                  key: *const core::ffi::c_char,
	                                  data: *mut u32,
	                                  data_size: u16)
	                                  -> bool;
}
extern "C" {
	#[doc = " Write key and array of uint32"]
	#[doc = " @param flipper_format Pointer to a FlipperFormat instance"]
	#[doc = " @param key Key"]
	#[doc = " @param data Value"]
	#[doc = " @param data_size Values count"]
	#[doc = " @return True on success"]
	pub fn flipper_format_write_uint32(flipper_format: *mut FlipperFormat,
	                                   key: *const core::ffi::c_char,
	                                   data: *const u32,
	                                   data_size: u16)
	                                   -> bool;
}
extern "C" {
	#[doc = " Read array of int32 by key"]
	#[doc = " @param flipper_format Pointer to a FlipperFormat instance"]
	#[doc = " @param key Key"]
	#[doc = " @param data Value"]
	#[doc = " @param data_size Values count"]
	#[doc = " @return True on success"]
	pub fn flipper_format_read_int32(flipper_format: *mut FlipperFormat,
	                                 key: *const core::ffi::c_char,
	                                 data: *mut i32,
	                                 data_size: u16)
	                                 -> bool;
}
extern "C" {
	#[doc = " Write key and array of int32"]
	#[doc = " @param flipper_format Pointer to a FlipperFormat instance"]
	#[doc = " @param key Key"]
	#[doc = " @param data Value"]
	#[doc = " @param data_size Values count"]
	#[doc = " @return True on success"]
	pub fn flipper_format_write_int32(flipper_format: *mut FlipperFormat,
	                                  key: *const core::ffi::c_char,
	                                  data: *const i32,
	                                  data_size: u16)
	                                  -> bool;
}
extern "C" {
	#[doc = " Read array of bool by key"]
	#[doc = " @param flipper_format Pointer to a FlipperFormat instance"]
	#[doc = " @param key Key"]
	#[doc = " @param data Value"]
	#[doc = " @param data_size Values count"]
	#[doc = " @return True on success"]
	pub fn flipper_format_read_bool(flipper_format: *mut FlipperFormat,
	                                key: *const core::ffi::c_char,
	                                data: *mut bool,
	                                data_size: u16)
	                                -> bool;
}
extern "C" {
	#[doc = " Write key and array of bool"]
	#[doc = " @param flipper_format Pointer to a FlipperFormat instance"]
	#[doc = " @param key Key"]
	#[doc = " @param data Value"]
	#[doc = " @param data_size Values count"]
	#[doc = " @return True on success"]
	pub fn flipper_format_write_bool(flipper_format: *mut FlipperFormat,
	                                 key: *const core::ffi::c_char,
	                                 data: *const bool,
	                                 data_size: u16)
	                                 -> bool;
}
extern "C" {
	#[doc = " Read array of float by key"]
	#[doc = " @param flipper_format Pointer to a FlipperFormat instance"]
	#[doc = " @param key Key"]
	#[doc = " @param data Value"]
	#[doc = " @param data_size Values count"]
	#[doc = " @return True on success"]
	pub fn flipper_format_read_float(flipper_format: *mut FlipperFormat,
	                                 key: *const core::ffi::c_char,
	                                 data: *mut core::ffi::c_float,
	                                 data_size: u16)
	                                 -> bool;
}
extern "C" {
	#[doc = " Write key and array of float"]
	#[doc = " @param flipper_format Pointer to a FlipperFormat instance"]
	#[doc = " @param key Key"]
	#[doc = " @param data Value"]
	#[doc = " @param data_size Values count"]
	#[doc = " @return True on success"]
	pub fn flipper_format_write_float(flipper_format: *mut FlipperFormat,
	                                  key: *const core::ffi::c_char,
	                                  data: *const core::ffi::c_float,
	                                  data_size: u16)
	                                  -> bool;
}
extern "C" {
	#[doc = " Read array of hex-formatted bytes by key"]
	#[doc = " @param flipper_format Pointer to a FlipperFormat instance"]
	#[doc = " @param key Key"]
	#[doc = " @param data Value"]
	#[doc = " @param data_size Values count"]
	#[doc = " @return True on success"]
	pub fn flipper_format_read_hex(flipper_format: *mut FlipperFormat,
	                               key: *const core::ffi::c_char,
	                               data: *mut u8,
	                               data_size: u16)
	                               -> bool;
}
extern "C" {
	#[doc = " Write key and array of hex-formatted bytes"]
	#[doc = " @param flipper_format Pointer to a FlipperFormat instance"]
	#[doc = " @param key Key"]
	#[doc = " @param data Value"]
	#[doc = " @param data_size Values count"]
	#[doc = " @return True on success"]
	pub fn flipper_format_write_hex(flipper_format: *mut FlipperFormat,
	                                key: *const core::ffi::c_char,
	                                data: *const u8,
	                                data_size: u16)
	                                -> bool;
}
extern "C" {
	#[doc = " Write comment"]
	#[doc = " @param flipper_format Pointer to a FlipperFormat instance"]
	#[doc = " @param data Comment text"]
	#[doc = " @return True on success"]
	pub fn flipper_format_write_comment(flipper_format: *mut FlipperFormat, data: *mut string_t) -> bool;
}
extern "C" {
	#[doc = " Write comment. Plain C string version."]
	#[doc = " @param flipper_format Pointer to a FlipperFormat instance"]
	#[doc = " @param data Comment text"]
	#[doc = " @return True on success"]
	pub fn flipper_format_write_comment_cstr(flipper_format: *mut FlipperFormat, data: *const core::ffi::c_char) -> bool;
}
extern "C" {
	#[doc = " Removes the first matching key and its value. Sets the RW pointer to a position of deleted data."]
	#[doc = " @param flipper_format Pointer to a FlipperFormat instance"]
	#[doc = " @param key Key"]
	#[doc = " @return True on success"]
	pub fn flipper_format_delete_key(flipper_format: *mut FlipperFormat, key: *const core::ffi::c_char) -> bool;
}
extern "C" {
	#[doc = " Updates the value of the first matching key to a string value. Sets the RW pointer to a position at the end of inserted data."]
	#[doc = " @param flipper_format Pointer to a FlipperFormat instance"]
	#[doc = " @param key Key"]
	#[doc = " @param data Value"]
	#[doc = " @return True on success"]
	pub fn flipper_format_update_string(flipper_format: *mut FlipperFormat,
	                                    key: *const core::ffi::c_char,
	                                    data: *mut string_t)
	                                    -> bool;
}
extern "C" {
	#[doc = " Updates the value of the first matching key to a string value. Plain C version. Sets the RW pointer to a position at the end of inserted data."]
	#[doc = " @param flipper_format Pointer to a FlipperFormat instance"]
	#[doc = " @param key Key"]
	#[doc = " @param data Value"]
	#[doc = " @return True on success"]
	pub fn flipper_format_update_string_cstr(flipper_format: *mut FlipperFormat,
	                                         key: *const core::ffi::c_char,
	                                         data: *const core::ffi::c_char)
	                                         -> bool;
}
extern "C" {
	#[doc = " Updates the value of the first matching key to a uint32 array value. Sets the RW pointer to a position at the end of inserted data."]
	#[doc = " @param flipper_format Pointer to a FlipperFormat instance"]
	#[doc = " @param key Key"]
	#[doc = " @param data Value"]
	#[doc = " @return True on success"]
	pub fn flipper_format_update_uint32(flipper_format: *mut FlipperFormat,
	                                    key: *const core::ffi::c_char,
	                                    data: *const u32,
	                                    data_size: u16)
	                                    -> bool;
}
extern "C" {
	#[doc = " Updates the value of the first matching key to a int32 array value. Sets the RW pointer to a position at the end of inserted data."]
	#[doc = " @param flipper_format Pointer to a FlipperFormat instance"]
	#[doc = " @param key Key"]
	#[doc = " @param data Value"]
	#[doc = " @return True on success"]
	pub fn flipper_format_update_int32(flipper_format: *mut FlipperFormat,
	                                   key: *const core::ffi::c_char,
	                                   data: *const i32,
	                                   data_size: u16)
	                                   -> bool;
}
extern "C" {
	#[doc = " Updates the value of the first matching key to a bool array value. Sets the RW pointer to a position at the end of inserted data."]
	#[doc = " @param flipper_format Pointer to a FlipperFormat instance"]
	#[doc = " @param key Key"]
	#[doc = " @param data Value"]
	#[doc = " @return True on success"]
	pub fn flipper_format_update_bool(flipper_format: *mut FlipperFormat,
	                                  key: *const core::ffi::c_char,
	                                  data: *const bool,
	                                  data_size: u16)
	                                  -> bool;
}
extern "C" {
	#[doc = " Updates the value of the first matching key to a float array value. Sets the RW pointer to a position at the end of inserted data."]
	#[doc = " @param flipper_format Pointer to a FlipperFormat instance"]
	#[doc = " @param key Key"]
	#[doc = " @param data Value"]
	#[doc = " @return True on success"]
	pub fn flipper_format_update_float(flipper_format: *mut FlipperFormat,
	                                   key: *const core::ffi::c_char,
	                                   data: *const core::ffi::c_float,
	                                   data_size: u16)
	                                   -> bool;
}
extern "C" {
	#[doc = " Updates the value of the first matching key to an array of hex-formatted bytes. Sets the RW pointer to a position at the end of inserted data."]
	#[doc = " @param flipper_format Pointer to a FlipperFormat instance"]
	#[doc = " @param key Key"]
	#[doc = " @param data Value"]
	#[doc = " @return True on success"]
	pub fn flipper_format_update_hex(flipper_format: *mut FlipperFormat,
	                                 key: *const core::ffi::c_char,
	                                 data: *const u8,
	                                 data_size: u16)
	                                 -> bool;
}
extern "C" {
	#[doc = " Updates the value of the first matching key to a string value, or adds the key and value if the key did not exist."]
	#[doc = " Sets the RW pointer to a position at the end of inserted data."]
	#[doc = " @param flipper_format Pointer to a FlipperFormat instance"]
	#[doc = " @param key Key"]
	#[doc = " @param data Value"]
	#[doc = " @return True on success"]
	pub fn flipper_format_insert_or_update_string(flipper_format: *mut FlipperFormat,
	                                              key: *const core::ffi::c_char,
	                                              data: *mut string_t)
	                                              -> bool;
}
extern "C" {
	#[doc = " Updates the value of the first matching key to a string value, or adds the key and value if the key did not exist."]
	#[doc = " Plain C version."]
	#[doc = " Sets the RW pointer to a position at the end of inserted data."]
	#[doc = " @param flipper_format Pointer to a FlipperFormat instance"]
	#[doc = " @param key Key"]
	#[doc = " @param data Value"]
	#[doc = " @return True on success"]
	pub fn flipper_format_insert_or_update_string_cstr(flipper_format: *mut FlipperFormat,
	                                                   key: *const core::ffi::c_char,
	                                                   data: *const core::ffi::c_char)
	                                                   -> bool;
}
extern "C" {
	#[doc = " Updates the value of the first matching key to a uint32 array value, or adds the key and value if the key did not exist."]
	#[doc = "  Sets the RW pointer to a position at the end of inserted data."]
	#[doc = " @param flipper_format Pointer to a FlipperFormat instance"]
	#[doc = " @param key Key"]
	#[doc = " @param data Value"]
	#[doc = " @return True on success"]
	pub fn flipper_format_insert_or_update_uint32(flipper_format: *mut FlipperFormat,
	                                              key: *const core::ffi::c_char,
	                                              data: *const u32,
	                                              data_size: u16)
	                                              -> bool;
}
extern "C" {
	#[doc = " Updates the value of the first matching key to a int32 array value, or adds the key and value if the key did not exist."]
	#[doc = " Sets the RW pointer to a position at the end of inserted data."]
	#[doc = " @param flipper_format Pointer to a FlipperFormat instance"]
	#[doc = " @param key Key"]
	#[doc = " @param data Value"]
	#[doc = " @return True on success"]
	pub fn flipper_format_insert_or_update_int32(flipper_format: *mut FlipperFormat,
	                                             key: *const core::ffi::c_char,
	                                             data: *const i32,
	                                             data_size: u16)
	                                             -> bool;
}
extern "C" {
	#[doc = " Updates the value of the first matching key to a bool array value, or adds the key and value if the key did not exist."]
	#[doc = " Sets the RW pointer to a position at the end of inserted data."]
	#[doc = " @param flipper_format Pointer to a FlipperFormat instance"]
	#[doc = " @param key Key"]
	#[doc = " @param data Value"]
	#[doc = " @return True on success"]
	pub fn flipper_format_insert_or_update_bool(flipper_format: *mut FlipperFormat,
	                                            key: *const core::ffi::c_char,
	                                            data: *const bool,
	                                            data_size: u16)
	                                            -> bool;
}
extern "C" {
	#[doc = " Updates the value of the first matching key to a float array value, or adds the key and value if the key did not exist."]
	#[doc = " Sets the RW pointer to a position at the end of inserted data."]
	#[doc = " @param flipper_format Pointer to a FlipperFormat instance"]
	#[doc = " @param key Key"]
	#[doc = " @param data Value"]
	#[doc = " @return True on success"]
	pub fn flipper_format_insert_or_update_float(flipper_format: *mut FlipperFormat,
	                                             key: *const core::ffi::c_char,
	                                             data: *const core::ffi::c_float,
	                                             data_size: u16)
	                                             -> bool;
}
extern "C" {
	#[doc = " Updates the value of the first matching key to an array of hex-formatted bytes, or adds the key and value if the key did not exist."]
	#[doc = "Sets the RW pointer to a position at the end of inserted data."]
	#[doc = " @param flipper_format Pointer to a FlipperFormat instance"]
	#[doc = " @param key Key"]
	#[doc = " @param data Value"]
	#[doc = " @return True on success"]
	pub fn flipper_format_insert_or_update_hex(flipper_format: *mut FlipperFormat,
	                                           key: *const core::ffi::c_char,
	                                           data: *const u8,
	                                           data_size: u16)
	                                           -> bool;
}
#[repr(C)]
pub struct Stream {
	_unused: [u8; 0],
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum StreamOffset {
	StreamOffsetFromCurrent = 0,
	StreamOffsetFromStart = 1,
	StreamOffsetFromEnd = 2,
}
pub type StreamWriteCB = ::core::option::Option<unsafe extern "C" fn(stream: *mut Stream, context: *const core::ffi::c_void) -> bool>;
extern "C" {
	#[doc = " Free Stream"]
	#[doc = " @param stream Stream instance"]
	pub fn stream_free(stream: *mut Stream);
}
extern "C" {
	#[doc = " Clean (empty) Stream"]
	#[doc = " @param stream Stream instance"]
	pub fn stream_clean(stream: *mut Stream);
}
extern "C" {
	#[doc = " Indicates that the rw pointer is at the end of the stream"]
	#[doc = " @param stream Stream instance"]
	#[doc = " @return true if rw pointer is at the end of the stream"]
	#[doc = " @return false if rw pointer is not at the end of the stream"]
	pub fn stream_eof(stream: *mut Stream) -> bool;
}
extern "C" {
	#[doc = " Moves the rw pointer."]
	#[doc = " @param stream Stream instance"]
	#[doc = " @param offset how much to move the pointer"]
	#[doc = " @param offset_type starting from what"]
	#[doc = " @return true"]
	#[doc = " @return false"]
	pub fn stream_seek(stream: *mut Stream, offset: i32, offset_type: StreamOffset) -> bool;
}
extern "C" {
	#[doc = " Gets the value of the rw pointer"]
	#[doc = " @param stream Stream instance"]
	#[doc = " @return size_t value of the rw pointer"]
	pub fn stream_tell(stream: *mut Stream) -> usize;
}
extern "C" {
	#[doc = " Gets the size of the stream"]
	#[doc = " @param stream Stream instance"]
	#[doc = " @return size_t size of the stream"]
	pub fn stream_size(stream: *mut Stream) -> usize;
}
extern "C" {
	#[doc = " Write N bytes to the stream"]
	#[doc = " @param stream Stream instance"]
	#[doc = " @param data data to write"]
	#[doc = " @param size size of data to be written"]
	#[doc = " @return size_t how many bytes was written"]
	pub fn stream_write(stream: *mut Stream, data: *const u8, size: usize) -> usize;
}
extern "C" {
	#[doc = " Read N bytes from stream"]
	#[doc = " @param stream Stream instance"]
	#[doc = " @param data data to be read"]
	#[doc = " @param count size of data to be read"]
	#[doc = " @return size_t how many bytes was read"]
	pub fn stream_read(stream: *mut Stream, data: *mut u8, count: usize) -> usize;
}
extern "C" {
	#[doc = " Delete N chars from the stream and write data by calling write_callback(context)"]
	#[doc = " @param stream Stream instance"]
	#[doc = " @param delete_size size of data to be deleted"]
	#[doc = " @param write_callback write callback"]
	#[doc = " @param context write callback context"]
	#[doc = " @return true if the operation was successful"]
	#[doc = " @return false on error"]
	pub fn stream_delete_and_insert(stream: *mut Stream,
	                                delete_size: usize,
	                                write_callback: StreamWriteCB,
	                                context: *const core::ffi::c_void)
	                                -> bool;
}
extern "C" {
	#[doc = " Read line from a stream (supports LF and CRLF line endings)"]
	#[doc = " @param stream"]
	#[doc = " @param str_result"]
	#[doc = " @return true if line lenght is not zero"]
	#[doc = " @return false otherwise"]
	pub fn stream_read_line(stream: *mut Stream, str_result: *mut string_t) -> bool;
}
extern "C" {
	#[doc = " Moves the rw pointer to the start"]
	#[doc = " @param stream Stream instance"]
	pub fn stream_rewind(stream: *mut Stream) -> bool;
}
extern "C" {
	#[doc = " Write char to the stream"]
	#[doc = " @param stream Stream instance"]
	#[doc = " @param c char value"]
	#[doc = " @return size_t how many bytes was written"]
	pub fn stream_write_char(stream: *mut Stream, c: core::ffi::c_char) -> usize;
}
extern "C" {
	#[doc = " Write string to the stream"]
	#[doc = " @param stream Stream instance"]
	#[doc = " @param string string value"]
	#[doc = " @return size_t how many bytes was written"]
	pub fn stream_write_string(stream: *mut Stream, string: *mut string_t) -> usize;
}
extern "C" {
	#[doc = " Write const char* to the stream"]
	#[doc = " @param stream Stream instance"]
	#[doc = " @param string c-string value"]
	#[doc = " @return size_t how many bytes was written"]
	pub fn stream_write_cstring(stream: *mut Stream, string: *const core::ffi::c_char) -> usize;
}
extern "C" {
	#[doc = " Write formatted string to the stream"]
	#[doc = " @param stream Stream instance"]
	#[doc = " @param format"]
	#[doc = " @param ..."]
	#[doc = " @return size_t how many bytes was written"]
	pub fn stream_write_format(stream: *mut Stream, format: *const core::ffi::c_char, ...) -> usize;
}
extern "C" {
	#[doc = " Write formatted string to the stream, va_list version"]
	#[doc = " @param stream Stream instance"]
	#[doc = " @param format"]
	#[doc = " @param args"]
	#[doc = " @return size_t how many bytes was written"]
	pub fn stream_write_vaformat(stream: *mut Stream, format: *const core::ffi::c_char, args: va_list) -> usize;
}
extern "C" {
	#[doc = " Insert N chars to the stream, starting at the current pointer."]
	#[doc = " Data will be inserted, not overwritteт, so the stream will be increased in size."]
	#[doc = " @param stream Stream instance"]
	#[doc = " @param data data to be inserted"]
	#[doc = " @param size size of data to be inserted"]
	#[doc = " @return true if the operation was successful"]
	#[doc = " @return false on error"]
	pub fn stream_insert(stream: *mut Stream, data: *const u8, size: usize) -> bool;
}
extern "C" {
	#[doc = " Insert char to the stream"]
	#[doc = " @param stream Stream instance"]
	#[doc = " @param c char value"]
	#[doc = " @return true if the operation was successful"]
	#[doc = " @return false on error"]
	pub fn stream_insert_char(stream: *mut Stream, c: core::ffi::c_char) -> bool;
}
extern "C" {
	#[doc = " Insert string to the stream"]
	#[doc = " @param stream Stream instance"]
	#[doc = " @param string string value"]
	#[doc = " @return true if the operation was successful"]
	#[doc = " @return false on error"]
	pub fn stream_insert_string(stream: *mut Stream, string: *mut string_t) -> bool;
}
extern "C" {
	#[doc = " Insert const char* to the stream"]
	#[doc = " @param stream Stream instance"]
	#[doc = " @param string c-string value"]
	#[doc = " @return true if the operation was successful"]
	#[doc = " @return false on error"]
	pub fn stream_insert_cstring(stream: *mut Stream, string: *const core::ffi::c_char) -> bool;
}
extern "C" {
	#[doc = " Insert formatted string to the stream"]
	#[doc = " @param stream Stream instance"]
	#[doc = " @param format"]
	#[doc = " @param ..."]
	#[doc = " @return true if the operation was successful"]
	#[doc = " @return false on error"]
	pub fn stream_insert_format(stream: *mut Stream, format: *const core::ffi::c_char, ...) -> bool;
}
extern "C" {
	#[doc = " Insert formatted string to the stream, va_list version"]
	#[doc = " @param stream Stream instance"]
	#[doc = " @param format"]
	#[doc = " @param args"]
	#[doc = " @return true if the operation was successful"]
	#[doc = " @return false on error"]
	pub fn stream_insert_vaformat(stream: *mut Stream, format: *const core::ffi::c_char, args: va_list) -> bool;
}
extern "C" {
	#[doc = " Delete N chars from the stream and insert char to the stream"]
	#[doc = " @param stream Stream instance"]
	#[doc = " @param delete_size size of data to be deleted"]
	#[doc = " @param c char value"]
	#[doc = " @return true if the operation was successful"]
	#[doc = " @return false on error"]
	pub fn stream_delete_and_insert_char(stream: *mut Stream, delete_size: usize, c: core::ffi::c_char) -> bool;
}
extern "C" {
	#[doc = " Delete N chars from the stream and insert string to the stream"]
	#[doc = " @param stream Stream instance"]
	#[doc = " @param delete_size size of data to be deleted"]
	#[doc = " @param string string value"]
	#[doc = " @return true if the operation was successful"]
	#[doc = " @return false on error"]
	pub fn stream_delete_and_insert_string(stream: *mut Stream, delete_size: usize, string: *mut string_t) -> bool;
}
extern "C" {
	#[doc = " Delete N chars from the stream and insert const char* to the stream"]
	#[doc = " @param stream Stream instance"]
	#[doc = " @param delete_size size of data to be deleted"]
	#[doc = " @param string c-string value"]
	#[doc = " @return true if the operation was successful"]
	#[doc = " @return false on error"]
	pub fn stream_delete_and_insert_cstring(stream: *mut Stream, delete_size: usize, string: *const core::ffi::c_char) -> bool;
}
extern "C" {
	#[doc = " Delete N chars from the stream and insert formatted string to the stream"]
	#[doc = " @param stream Stream instance"]
	#[doc = " @param delete_size size of data to be deleted"]
	#[doc = " @param format"]
	#[doc = " @param ..."]
	#[doc = " @return true if the operation was successful"]
	#[doc = " @return false on error"]
	pub fn stream_delete_and_insert_format(stream: *mut Stream, delete_size: usize, format: *const core::ffi::c_char, ...) -> bool;
}
extern "C" {
	#[doc = " Delete N chars from the stream and insert formatted string to the stream, va_list version"]
	#[doc = " @param stream Stream instance"]
	#[doc = " @param delete_size size of data to be deleted"]
	#[doc = " @param format"]
	#[doc = " @param args"]
	#[doc = " @return true if the operation was successful"]
	#[doc = " @return false on error"]
	pub fn stream_delete_and_insert_vaformat(stream: *mut Stream,
	                                         delete_size: usize,
	                                         format: *const core::ffi::c_char,
	                                         args: va_list)
	                                         -> bool;
}
extern "C" {
	#[doc = " Remove N chars from the stream, starting at the current pointer."]
	#[doc = " The size may be larger than stream size, the stream will be cleared from current rw pointer to the end."]
	#[doc = " @param stream Stream instance"]
	#[doc = " @param size how many chars need to be deleted"]
	#[doc = " @return true if the operation was successful"]
	#[doc = " @return false on error"]
	pub fn stream_delete(stream: *mut Stream, size: usize) -> bool;
}
extern "C" {
	#[doc = " Copy data from one stream to another. Data will be copied from current rw pointer and to current rw pointer."]
	#[doc = " @param stream_from"]
	#[doc = " @param stream_to"]
	#[doc = " @param size"]
	#[doc = " @return size_t"]
	pub fn stream_copy(stream_from: *mut Stream, stream_to: *mut Stream, size: usize) -> usize;
}
extern "C" {
	#[doc = " Copy data from one stream to another. Data will be copied from start of one stream and to start of other stream."]
	#[doc = " @param stream_from"]
	#[doc = " @param stream_to"]
	#[doc = " @return size_t"]
	pub fn stream_copy_full(stream_from: *mut Stream, stream_to: *mut Stream) -> usize;
}
extern "C" {
	#[doc = " Splits one stream into two others. The original stream will remain untouched."]
	#[doc = " @param stream"]
	#[doc = " @param stream_left"]
	#[doc = " @param stream_right"]
	#[doc = " @return true"]
	#[doc = " @return false"]
	pub fn stream_split(stream: *mut Stream, stream_left: *mut Stream, stream_right: *mut Stream) -> bool;
}
extern "C" {
	#[doc = " Loads data to the stream from a file. Data will be loaded to the current RW pointer. RW pointer will be moved to the end of the stream."]
	#[doc = " @param stream Stream instance"]
	#[doc = " @param storage"]
	#[doc = " @param path"]
	#[doc = " @return size_t"]
	pub fn stream_load_from_file(stream: *mut Stream, storage: *mut Storage, path: *const core::ffi::c_char) -> usize;
}
extern "C" {
	#[doc = " Writes data from a stream to a file. Data will be saved starting from the current RW pointer. RW pointer will be moved to the end of the stream."]
	#[doc = " @param stream Stream instance"]
	#[doc = " @param storage"]
	#[doc = " @param path"]
	#[doc = " @param mode"]
	#[doc = " @return size_t"]
	pub fn stream_save_to_file(stream: *mut Stream, storage: *mut Storage, path: *const core::ffi::c_char, mode: FS_OpenMode)
	                           -> usize;
}
extern "C" {
	#[doc = " Dump stream inner data (size, RW positiot, content)"]
	#[doc = " @param stream Stream instance"]
	pub fn stream_dump_data(stream: *mut Stream);
}
extern "C" {
	#[doc = " Returns the underlying stream instance."]
	#[doc = " Use only if you know what you are doing."]
	#[doc = " @param flipper_format"]
	#[doc = " @return Stream*"]
	pub fn flipper_format_get_raw_stream(flipper_format: *mut FlipperFormat) -> *mut Stream;
}
pub type ProtocolAlloc = ::core::option::Option<unsafe extern "C" fn() -> *mut core::ffi::c_void>;
pub type ProtocolFree = ::core::option::Option<unsafe extern "C" fn(protocol: *mut core::ffi::c_void)>;
pub type ProtocolGetData = ::core::option::Option<unsafe extern "C" fn(protocol: *mut core::ffi::c_void) -> *mut u8>;
pub type ProtocolDecoderStart = ::core::option::Option<unsafe extern "C" fn(protocol: *mut core::ffi::c_void)>;
pub type ProtocolDecoderFeed =
	::core::option::Option<unsafe extern "C" fn(protocol: *mut core::ffi::c_void, level: bool, duration: u32) -> bool>;
pub type ProtocolEncoderStart = ::core::option::Option<unsafe extern "C" fn(protocol: *mut core::ffi::c_void) -> bool>;
pub type ProtocolEncoderYield = ::core::option::Option<unsafe extern "C" fn(protocol: *mut core::ffi::c_void) -> LevelDuration>;
pub type ProtocolRenderData = ::core::option::Option<unsafe extern "C" fn(protocol: *mut core::ffi::c_void, result: *mut string_t)>;
pub type ProtocolWriteData =
	::core::option::Option<unsafe extern "C" fn(protocol: *mut core::ffi::c_void, data: *mut core::ffi::c_void) -> bool>;
#[repr(C)]
pub struct ProtocolDecoder {
	pub start: ProtocolDecoderStart,
	pub feed: ProtocolDecoderFeed,
}
#[test]
fn bindgen_test_layout_ProtocolDecoder() {
	assert_eq!(
	           ::core::mem::size_of::<ProtocolDecoder>(),
	           8usize,
	           concat!("Size of: ", stringify!(ProtocolDecoder))
	);
	assert_eq!(
	           ::core::mem::align_of::<ProtocolDecoder>(),
	           4usize,
	           concat!("Alignment of ", stringify!(ProtocolDecoder))
	);
	fn test_field_start() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<ProtocolDecoder>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).start) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(ProtocolDecoder), "::", stringify!(start))
		);
	}
	test_field_start();
	fn test_field_feed() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<ProtocolDecoder>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).feed) as usize - ptr as usize
		           },
		           4usize,
		           concat!("Offset of field: ", stringify!(ProtocolDecoder), "::", stringify!(feed))
		);
	}
	test_field_feed();
}
#[repr(C)]
pub struct ProtocolEncoder {
	pub start: ProtocolEncoderStart,
	pub yield_: ProtocolEncoderYield,
}
#[test]
fn bindgen_test_layout_ProtocolEncoder() {
	assert_eq!(
	           ::core::mem::size_of::<ProtocolEncoder>(),
	           8usize,
	           concat!("Size of: ", stringify!(ProtocolEncoder))
	);
	assert_eq!(
	           ::core::mem::align_of::<ProtocolEncoder>(),
	           4usize,
	           concat!("Alignment of ", stringify!(ProtocolEncoder))
	);
	fn test_field_start() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<ProtocolEncoder>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).start) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(ProtocolEncoder), "::", stringify!(start))
		);
	}
	test_field_start();
	fn test_field_yield() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<ProtocolEncoder>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).yield_) as usize - ptr as usize
		           },
		           4usize,
		           concat!("Offset of field: ", stringify!(ProtocolEncoder), "::", stringify!(yield_))
		);
	}
	test_field_yield();
}
#[repr(C)]
pub struct ProtocolBase {
	pub data_size: usize,
	pub name: *const core::ffi::c_char,
	pub manufacturer: *const core::ffi::c_char,
	pub features: u32,
	pub validate_count: u8,
	pub alloc: ProtocolAlloc,
	pub free: ProtocolFree,
	pub get_data: ProtocolGetData,
	pub decoder: ProtocolDecoder,
	pub encoder: ProtocolEncoder,
	pub render_data: ProtocolRenderData,
	pub render_brief_data: ProtocolRenderData,
	pub write_data: ProtocolWriteData,
}
#[test]
fn bindgen_test_layout_ProtocolBase() {
	assert_eq!(
	           ::core::mem::size_of::<ProtocolBase>(),
	           60usize,
	           concat!("Size of: ", stringify!(ProtocolBase))
	);
	assert_eq!(
	           ::core::mem::align_of::<ProtocolBase>(),
	           4usize,
	           concat!("Alignment of ", stringify!(ProtocolBase))
	);
	fn test_field_data_size() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<ProtocolBase>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).data_size) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(ProtocolBase), "::", stringify!(data_size))
		);
	}
	test_field_data_size();
	fn test_field_name() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<ProtocolBase>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).name) as usize - ptr as usize
		           },
		           4usize,
		           concat!("Offset of field: ", stringify!(ProtocolBase), "::", stringify!(name))
		);
	}
	test_field_name();
	fn test_field_manufacturer() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<ProtocolBase>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).manufacturer) as usize - ptr as usize
		           },
		           8usize,
		           concat!("Offset of field: ", stringify!(ProtocolBase), "::", stringify!(manufacturer))
		);
	}
	test_field_manufacturer();
	fn test_field_features() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<ProtocolBase>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).features) as usize - ptr as usize
		           },
		           12usize,
		           concat!("Offset of field: ", stringify!(ProtocolBase), "::", stringify!(features))
		);
	}
	test_field_features();
	fn test_field_validate_count() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<ProtocolBase>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).validate_count) as usize - ptr as usize
		           },
		           16usize,
		           concat!(
			"Offset of field: ",
			stringify!(ProtocolBase),
			"::",
			stringify!(validate_count)
		)
		);
	}
	test_field_validate_count();
	fn test_field_alloc() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<ProtocolBase>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).alloc) as usize - ptr as usize
		           },
		           20usize,
		           concat!("Offset of field: ", stringify!(ProtocolBase), "::", stringify!(alloc))
		);
	}
	test_field_alloc();
	fn test_field_free() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<ProtocolBase>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).free) as usize - ptr as usize
		           },
		           24usize,
		           concat!("Offset of field: ", stringify!(ProtocolBase), "::", stringify!(free))
		);
	}
	test_field_free();
	fn test_field_get_data() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<ProtocolBase>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).get_data) as usize - ptr as usize
		           },
		           28usize,
		           concat!("Offset of field: ", stringify!(ProtocolBase), "::", stringify!(get_data))
		);
	}
	test_field_get_data();
	fn test_field_decoder() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<ProtocolBase>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).decoder) as usize - ptr as usize
		           },
		           32usize,
		           concat!("Offset of field: ", stringify!(ProtocolBase), "::", stringify!(decoder))
		);
	}
	test_field_decoder();
	fn test_field_encoder() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<ProtocolBase>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).encoder) as usize - ptr as usize
		           },
		           40usize,
		           concat!("Offset of field: ", stringify!(ProtocolBase), "::", stringify!(encoder))
		);
	}
	test_field_encoder();
	fn test_field_render_data() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<ProtocolBase>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).render_data) as usize - ptr as usize
		           },
		           48usize,
		           concat!("Offset of field: ", stringify!(ProtocolBase), "::", stringify!(render_data))
		);
	}
	test_field_render_data();
	fn test_field_render_brief_data() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<ProtocolBase>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).render_brief_data) as usize - ptr as usize
		           },
		           52usize,
		           concat!(
			"Offset of field: ",
			stringify!(ProtocolBase),
			"::",
			stringify!(render_brief_data)
		)
		);
	}
	test_field_render_brief_data();
	fn test_field_write_data() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<ProtocolBase>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).write_data) as usize - ptr as usize
		           },
		           56usize,
		           concat!("Offset of field: ", stringify!(ProtocolBase), "::", stringify!(write_data))
		);
	}
	test_field_write_data();
}
#[repr(C)]
pub struct ProtocolDict {
	_unused: [u8; 0],
}
pub type ProtocolId = i32;
extern "C" {
	pub fn protocol_dict_alloc(protocols: *mut *const ProtocolBase, protocol_count: usize) -> *mut ProtocolDict;
}
extern "C" {
	pub fn protocol_dict_free(dict: *mut ProtocolDict);
}
extern "C" {
	pub fn protocol_dict_set_data(dict: *mut ProtocolDict, protocol_index: usize, data: *const u8, data_size: usize);
}
extern "C" {
	pub fn protocol_dict_get_data(dict: *mut ProtocolDict, protocol_index: usize, data: *mut u8, data_size: usize);
}
extern "C" {
	pub fn protocol_dict_get_data_size(dict: *mut ProtocolDict, protocol_index: usize) -> usize;
}
extern "C" {
	pub fn protocol_dict_get_max_data_size(dict: *mut ProtocolDict) -> usize;
}
extern "C" {
	pub fn protocol_dict_get_name(dict: *mut ProtocolDict, protocol_index: usize) -> *const core::ffi::c_char;
}
extern "C" {
	pub fn protocol_dict_get_manufacturer(dict: *mut ProtocolDict, protocol_index: usize) -> *const core::ffi::c_char;
}
extern "C" {
	pub fn protocol_dict_decoders_start(dict: *mut ProtocolDict);
}
extern "C" {
	pub fn protocol_dict_get_features(dict: *mut ProtocolDict, protocol_index: usize) -> u32;
}
extern "C" {
	pub fn protocol_dict_decoders_feed(dict: *mut ProtocolDict, level: bool, duration: u32) -> ProtocolId;
}
extern "C" {
	pub fn protocol_dict_decoders_feed_by_feature(dict: *mut ProtocolDict, feature: u32, level: bool, duration: u32) -> ProtocolId;
}
extern "C" {
	pub fn protocol_dict_decoders_feed_by_id(dict: *mut ProtocolDict, protocol_index: usize, level: bool, duration: u32)
	                                         -> ProtocolId;
}
extern "C" {
	pub fn protocol_dict_encoder_start(dict: *mut ProtocolDict, protocol_index: usize) -> bool;
}
extern "C" {
	pub fn protocol_dict_encoder_yield(dict: *mut ProtocolDict, protocol_index: usize) -> LevelDuration;
}
extern "C" {
	pub fn protocol_dict_render_data(dict: *mut ProtocolDict, result: *mut string_t, protocol_index: usize);
}
extern "C" {
	pub fn protocol_dict_render_brief_data(dict: *mut ProtocolDict, result: *mut string_t, protocol_index: usize);
}
extern "C" {
	pub fn protocol_dict_get_validate_count(dict: *mut ProtocolDict, protocol_index: usize) -> u32;
}
extern "C" {
	pub fn protocol_dict_get_protocol_by_name(dict: *mut ProtocolDict, name: *const core::ffi::c_char) -> ProtocolId;
}
extern "C" {
	pub fn protocol_dict_get_write_data(dict: *mut ProtocolDict, protocol_index: usize, data: *mut core::ffi::c_void) -> bool;
}
#[repr(C)]
pub struct LFRFIDT5577 {
	pub block: [u32; 8usize],
	pub blocks_to_write: u32,
}
#[test]
fn bindgen_test_layout_LFRFIDT5577() {
	assert_eq!(
	           ::core::mem::size_of::<LFRFIDT5577>(),
	           36usize,
	           concat!("Size of: ", stringify!(LFRFIDT5577))
	);
	assert_eq!(
	           ::core::mem::align_of::<LFRFIDT5577>(),
	           4usize,
	           concat!("Alignment of ", stringify!(LFRFIDT5577))
	);
	fn test_field_block() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LFRFIDT5577>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).block) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(LFRFIDT5577), "::", stringify!(block))
		);
	}
	test_field_block();
	fn test_field_blocks_to_write() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LFRFIDT5577>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).blocks_to_write) as usize - ptr as usize
		           },
		           32usize,
		           concat!(
			"Offset of field: ",
			stringify!(LFRFIDT5577),
			"::",
			stringify!(blocks_to_write)
		)
		);
	}
	test_field_blocks_to_write();
}
extern "C" {
	#[doc = " @brief Write T5577 tag data to tag"]
	#[doc = ""]
	#[doc = " @param data"]
	pub fn t5577_write(data: *mut LFRFIDT5577);
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum LFRFIDFeature {
	LFRFIDFeatureASK = 1,
	#[doc = " ASK Demodulation"]
	LFRFIDFeaturePSK = 2,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum LFRFIDProtocol {
	LFRFIDProtocolEM4100 = 0,
	LFRFIDProtocolH10301 = 1,
	LFRFIDProtocolIndala26 = 2,
	LFRFIDProtocolIOProxXSF = 3,
	LFRFIDProtocolAwid = 4,
	LFRFIDProtocolFDXA = 5,
	LFRFIDProtocolFDXB = 6,
	LFRFIDProtocolHidGeneric = 7,
	LFRFIDProtocolHidExGeneric = 8,
	LFRFIDProtocolPyramid = 9,
	LFRFIDProtocolViking = 10,
	LFRFIDProtocolJablotron = 11,
	LFRFIDProtocolParadox = 12,
	LFRFIDProtocolPACStanley = 13,
	LFRFIDProtocolKeri = 14,
	LFRFIDProtocolGallagher = 15,
	LFRFIDProtocolMax = 16,
}
extern "C" {
	pub static mut lfrfid_protocols: [*const ProtocolBase; 0usize];
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum LFRFIDWriteType {
	LFRFIDWriteTypeT5577 = 0,
}
#[repr(C)]
pub struct LFRFIDWriteRequest {
	pub write_type: LFRFIDWriteType,
	pub __bindgen_anon_1: LFRFIDWriteRequest__bindgen_ty_1,
}
#[repr(C)]
pub struct LFRFIDWriteRequest__bindgen_ty_1 {
	pub t5577: __BindgenUnionField<LFRFIDT5577>,
	pub bindgen_union_field: [u32; 9usize],
}
#[test]
fn bindgen_test_layout_LFRFIDWriteRequest__bindgen_ty_1() {
	assert_eq!(
	           ::core::mem::size_of::<LFRFIDWriteRequest__bindgen_ty_1>(),
	           36usize,
	           concat!("Size of: ", stringify!(LFRFIDWriteRequest__bindgen_ty_1))
	);
	assert_eq!(
	           ::core::mem::align_of::<LFRFIDWriteRequest__bindgen_ty_1>(),
	           4usize,
	           concat!("Alignment of ", stringify!(LFRFIDWriteRequest__bindgen_ty_1))
	);
	fn test_field_t5577() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LFRFIDWriteRequest__bindgen_ty_1>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).t5577) as usize - ptr as usize
		           },
		           0usize,
		           concat!(
			"Offset of field: ",
			stringify!(LFRFIDWriteRequest__bindgen_ty_1),
			"::",
			stringify!(t5577)
		)
		);
	}
	test_field_t5577();
}
#[test]
fn bindgen_test_layout_LFRFIDWriteRequest() {
	assert_eq!(
	           ::core::mem::size_of::<LFRFIDWriteRequest>(),
	           40usize,
	           concat!("Size of: ", stringify!(LFRFIDWriteRequest))
	);
	assert_eq!(
	           ::core::mem::align_of::<LFRFIDWriteRequest>(),
	           4usize,
	           concat!("Alignment of ", stringify!(LFRFIDWriteRequest))
	);
	fn test_field_write_type() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LFRFIDWriteRequest>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).write_type) as usize - ptr as usize
		           },
		           0usize,
		           concat!(
			"Offset of field: ",
			stringify!(LFRFIDWriteRequest),
			"::",
			stringify!(write_type)
		)
		);
	}
	test_field_write_type();
}
extern "C" {
	#[doc = " @brief Save protocol from dictionary to file"]
	#[doc = ""]
	#[doc = " @param dict"]
	#[doc = " @param protocol"]
	#[doc = " @param filename"]
	#[doc = " @return true"]
	#[doc = " @return false"]
	pub fn lfrfid_dict_file_save(dict: *mut ProtocolDict, protocol: ProtocolId, filename: *const core::ffi::c_char) -> bool;
}
extern "C" {
	#[doc = " @brief Load protocol from file to dictionary"]
	#[doc = ""]
	#[doc = " @param dict"]
	#[doc = " @param filename"]
	#[doc = " @return ProtocolId"]
	pub fn lfrfid_dict_file_load(dict: *mut ProtocolDict, filename: *const core::ffi::c_char) -> ProtocolId;
}
#[repr(C)]
pub struct LFRFIDRawFile {
	_unused: [u8; 0],
}
extern "C" {
	#[doc = " @brief Allocate a new LFRFIDRawFile instance"]
	#[doc = ""]
	#[doc = " @param storage"]
	#[doc = " @return LFRFIDRawFile*"]
	pub fn lfrfid_raw_file_alloc(storage: *mut Storage) -> *mut LFRFIDRawFile;
}
extern "C" {
	#[doc = " @brief Free a LFRFIDRawFile instance"]
	#[doc = ""]
	#[doc = " @param file"]
	pub fn lfrfid_raw_file_free(file: *mut LFRFIDRawFile);
}
extern "C" {
	#[doc = " @brief Open RAW file for writing"]
	#[doc = ""]
	#[doc = " @param file"]
	#[doc = " @param file_path"]
	#[doc = " @return bool"]
	pub fn lfrfid_raw_file_open_write(file: *mut LFRFIDRawFile, file_path: *const core::ffi::c_char) -> bool;
}
extern "C" {
	#[doc = " @brief Open RAW file for reading"]
	#[doc = " @param file"]
	#[doc = " @param file_path"]
	#[doc = " @return bool"]
	pub fn lfrfid_raw_file_open_read(file: *mut LFRFIDRawFile, file_path: *const core::ffi::c_char) -> bool;
}
extern "C" {
	#[doc = " @brief Write RAW file header"]
	#[doc = ""]
	#[doc = " @param file"]
	#[doc = " @param frequency"]
	#[doc = " @param duty_cycle"]
	#[doc = " @param max_buffer_size"]
	#[doc = " @return bool"]
	pub fn lfrfid_raw_file_write_header(file: *mut LFRFIDRawFile,
	                                    frequency: core::ffi::c_float,
	                                    duty_cycle: core::ffi::c_float,
	                                    max_buffer_size: u32)
	                                    -> bool;
}
extern "C" {
	#[doc = " @brief Write data to RAW file"]
	#[doc = ""]
	#[doc = " @param file"]
	#[doc = " @param buffer_data"]
	#[doc = " @param buffer_size"]
	#[doc = " @return bool"]
	pub fn lfrfid_raw_file_write_buffer(file: *mut LFRFIDRawFile, buffer_data: *mut u8, buffer_size: usize) -> bool;
}
extern "C" {
	#[doc = " @brief Read RAW file header"]
	#[doc = ""]
	#[doc = " @param file"]
	#[doc = " @param frequency"]
	#[doc = " @param duty_cycle"]
	#[doc = " @return bool"]
	pub fn lfrfid_raw_file_read_header(file: *mut LFRFIDRawFile,
	                                   frequency: *mut core::ffi::c_float,
	                                   duty_cycle: *mut core::ffi::c_float)
	                                   -> bool;
}
extern "C" {
	#[doc = " @brief Read varint-encoded pair from RAW file"]
	#[doc = ""]
	#[doc = " @param file"]
	#[doc = " @param duration"]
	#[doc = " @param pulse"]
	#[doc = " @param pass_end file was wrapped around, can be NULL"]
	#[doc = " @return bool"]
	pub fn lfrfid_raw_file_read_pair(file: *mut LFRFIDRawFile, duration: *mut u32, pulse: *mut u32, pass_end: *mut bool) -> bool;
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum LFRFIDWorkerWriteResult {
	LFRFIDWorkerWriteOK = 0,
	LFRFIDWorkerWriteProtocolCannotBeWritten = 1,
	LFRFIDWorkerWriteFobCannotBeWritten = 2,
	LFRFIDWorkerWriteTooLongToWrite = 3,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum LFRFIDWorkerReadType {
	LFRFIDWorkerReadTypeAuto = 0,
	LFRFIDWorkerReadTypeASKOnly = 1,
	LFRFIDWorkerReadTypePSKOnly = 2,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum LFRFIDWorkerReadResult {
	LFRFIDWorkerReadSenseStart = 0,
	LFRFIDWorkerReadSenseEnd = 1,
	LFRFIDWorkerReadSenseCardStart = 2,
	LFRFIDWorkerReadSenseCardEnd = 3,
	LFRFIDWorkerReadStartASK = 4,
	LFRFIDWorkerReadStartPSK = 5,
	LFRFIDWorkerReadDone = 6,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum LFRFIDWorkerReadRawResult {
	LFRFIDWorkerReadRawFileError = 0,
	LFRFIDWorkerReadRawOverrun = 1,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum LFRFIDWorkerEmulateRawResult {
	LFRFIDWorkerEmulateRawFileError = 0,
	LFRFIDWorkerEmulateRawOverrun = 1,
}
pub type LFRFIDWorkerReadCallback = ::core::option::Option<unsafe extern "C" fn(result: LFRFIDWorkerReadResult,
                                                                                protocol: ProtocolId,
                                                                                context: *mut core::ffi::c_void)>;
pub type LFRFIDWorkerWriteCallback =
	::core::option::Option<unsafe extern "C" fn(result: LFRFIDWorkerWriteResult, context: *mut core::ffi::c_void)>;
pub type LFRFIDWorkerReadRawCallback =
	::core::option::Option<unsafe extern "C" fn(result: LFRFIDWorkerReadRawResult, context: *mut core::ffi::c_void)>;
pub type LFRFIDWorkerEmulateRawCallback =
	::core::option::Option<unsafe extern "C" fn(result: LFRFIDWorkerEmulateRawResult, context: *mut core::ffi::c_void)>;
#[repr(C)]
pub struct LFRFIDWorker {
	_unused: [u8; 0],
}
extern "C" {
	#[doc = " Allocate LF-RFID worker"]
	#[doc = " @return LFRFIDWorker*"]
	pub fn lfrfid_worker_alloc(dict: *mut ProtocolDict) -> *mut LFRFIDWorker;
}
extern "C" {
	#[doc = " Free LF-RFID worker"]
	#[doc = " @param worker"]
	pub fn lfrfid_worker_free(worker: *mut LFRFIDWorker);
}
extern "C" {
	#[doc = " Start LF-RFID worker thread"]
	#[doc = " @param worker"]
	pub fn lfrfid_worker_start_thread(worker: *mut LFRFIDWorker);
}
extern "C" {
	#[doc = " Stop LF-RFID worker thread"]
	#[doc = " @param worker"]
	pub fn lfrfid_worker_stop_thread(worker: *mut LFRFIDWorker);
}
extern "C" {
	#[doc = " @brief Start read mode"]
	#[doc = ""]
	#[doc = " @param worker"]
	#[doc = " @param type"]
	#[doc = " @param callback"]
	#[doc = " @param context"]
	pub fn lfrfid_worker_read_start(worker: *mut LFRFIDWorker,
	                                type_: LFRFIDWorkerReadType,
	                                callback: LFRFIDWorkerReadCallback,
	                                context: *mut core::ffi::c_void);
}
extern "C" {
	#[doc = " @brief Start write mode"]
	#[doc = ""]
	#[doc = " @param worker"]
	#[doc = " @param protocol"]
	#[doc = " @param callback"]
	#[doc = " @param context"]
	pub fn lfrfid_worker_write_start(worker: *mut LFRFIDWorker,
	                                 protocol: LFRFIDProtocol,
	                                 callback: LFRFIDWorkerWriteCallback,
	                                 context: *mut core::ffi::c_void);
}
extern "C" {
	#[doc = " Start emulate mode"]
	#[doc = " @param worker"]
	pub fn lfrfid_worker_emulate_start(worker: *mut LFRFIDWorker, protocol: LFRFIDProtocol);
}
extern "C" {
	#[doc = " @brief Start raw read mode"]
	#[doc = ""]
	#[doc = " @param worker"]
	#[doc = " @param filename"]
	#[doc = " @param type"]
	#[doc = " @param callback"]
	#[doc = " @param context"]
	pub fn lfrfid_worker_read_raw_start(worker: *mut LFRFIDWorker,
	                                    filename: *const core::ffi::c_char,
	                                    type_: LFRFIDWorkerReadType,
	                                    callback: LFRFIDWorkerReadRawCallback,
	                                    context: *mut core::ffi::c_void);
}
extern "C" {
	#[doc = " Emulate raw read mode"]
	#[doc = " @param worker"]
	#[doc = " @param filename"]
	#[doc = " @param callback"]
	#[doc = " @param context"]
	pub fn lfrfid_worker_emulate_raw_start(worker: *mut LFRFIDWorker,
	                                       filename: *const core::ffi::c_char,
	                                       callback: LFRFIDWorkerEmulateRawCallback,
	                                       context: *mut core::ffi::c_void);
}
extern "C" {
	#[doc = " Stop all modes"]
	#[doc = " @param worker"]
	pub fn lfrfid_worker_stop(worker: *mut LFRFIDWorker);
}
#[repr(C)]
pub struct LFRFIDRawWorker {
	_unused: [u8; 0],
}
extern "C" {
	#[doc = " @brief Allocate a new LFRFIDRawWorker instance"]
	#[doc = ""]
	#[doc = " @return LFRFIDRawWorker*"]
	pub fn lfrfid_raw_worker_alloc() -> *mut LFRFIDRawWorker;
}
extern "C" {
	#[doc = " @brief Free a LFRFIDRawWorker instance"]
	#[doc = ""]
	#[doc = " @param worker LFRFIDRawWorker instance"]
	pub fn lfrfid_raw_worker_free(worker: *mut LFRFIDRawWorker);
}
extern "C" {
	#[doc = " @brief Start reading"]
	#[doc = ""]
	#[doc = " @param worker LFRFIDRawWorker instance"]
	#[doc = " @param file_path path where file will be saved"]
	#[doc = " @param frequency HW frequency"]
	#[doc = " @param duty_cycle HW duty cycle"]
	#[doc = " @param callback callback for read event"]
	#[doc = " @param context context for callback"]
	pub fn lfrfid_raw_worker_start_read(worker: *mut LFRFIDRawWorker,
	                                    file_path: *const core::ffi::c_char,
	                                    frequency: core::ffi::c_float,
	                                    duty_cycle: core::ffi::c_float,
	                                    callback: LFRFIDWorkerReadRawCallback,
	                                    context: *mut core::ffi::c_void);
}
extern "C" {
	#[doc = " @brief Start emulate"]
	#[doc = ""]
	#[doc = " @param worker LFRFIDRawWorker instance"]
	#[doc = " @param file_path path to file that will be emulated"]
	#[doc = " @param callback callback for emulate event"]
	#[doc = " @param context context for callback"]
	pub fn lfrfid_raw_worker_start_emulate(worker: *mut LFRFIDRawWorker,
	                                       file_path: *const core::ffi::c_char,
	                                       callback: LFRFIDWorkerEmulateRawCallback,
	                                       context: *mut core::ffi::c_void);
}
extern "C" {
	#[doc = " @brief Stop worker"]
	#[doc = ""]
	#[doc = " @param worker"]
	pub fn lfrfid_raw_worker_stop(worker: *mut LFRFIDRawWorker);
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum BitLibParity {
	BitLibParityEven = 0,
	BitLibParityOdd = 1,
	BitLibParityAlways0 = 2,
	BitLibParityAlways1 = 3,
}
extern "C" {
	#[doc = " @brief Push a bit into a byte array."]
	#[doc = "  @param data array to push bit into"]
	#[doc = "  @param data_size array size"]
	#[doc = "  @param bit bit to push"]
	pub fn bit_lib_push_bit(data: *mut u8, data_size: usize, bit: bool);
}
extern "C" {
	#[doc = " @brief Set a bit in a byte array."]
	#[doc = "  @param data array to set bit in"]
	#[doc = "  @param position The position of the bit to set."]
	#[doc = "  @param bit bit value to set"]
	pub fn bit_lib_set_bit(data: *mut u8, position: usize, bit: bool);
}
extern "C" {
	#[doc = " @brief Set the bit at the given position to the given value."]
	#[doc = " @param data The data to set the bit in."]
	#[doc = " @param position The position of the bit to set."]
	#[doc = " @param byte The data to set the bit to."]
	#[doc = " @param length The length of the data."]
	pub fn bit_lib_set_bits(data: *mut u8, position: usize, byte: u8, length: u8);
}
extern "C" {
	#[doc = " @brief Get the bit of a byte."]
	#[doc = " @param data The byte to get the bits from."]
	#[doc = " @param position The position of the bit."]
	#[doc = " @return The bit."]
	pub fn bit_lib_get_bit(data: *const u8, position: usize) -> bool;
}
extern "C" {
	#[doc = " @brief Get the bits of a data, as uint8_t."]
	#[doc = " @param data The data to get the bits from."]
	#[doc = " @param position The position of the first bit."]
	#[doc = " @param length The length of the bits."]
	#[doc = " @return The bits."]
	pub fn bit_lib_get_bits(data: *const u8, position: usize, length: u8) -> u8;
}
extern "C" {
	#[doc = " @brief Get the bits of a data, as uint16_t."]
	#[doc = " @param data The data to get the bits from."]
	#[doc = " @param position The position of the first bit."]
	#[doc = " @param length The length of the bits."]
	#[doc = " @return The bits."]
	pub fn bit_lib_get_bits_16(data: *const u8, position: usize, length: u8) -> u16;
}
extern "C" {
	#[doc = " @brief Get the bits of a data, as uint32_t."]
	#[doc = " @param data The data to get the bits from."]
	#[doc = " @param position The position of the first bit."]
	#[doc = " @param length The length of the bits."]
	#[doc = " @return The bits."]
	pub fn bit_lib_get_bits_32(data: *const u8, position: usize, length: u8) -> u32;
}
extern "C" {
	#[doc = " @brief Test parity of given bits"]
	#[doc = " @param bits Bits to test parity of"]
	#[doc = " @param parity Parity to test against"]
	#[doc = " @return true if parity is correct, false otherwise"]
	pub fn bit_lib_test_parity_32(bits: u32, parity: BitLibParity) -> bool;
}
extern "C" {
	#[doc = " @brief Test parity of bit array, check parity for every parity_length block from start"]
	#[doc = ""]
	#[doc = " @param data Bit array"]
	#[doc = " @param position Start position"]
	#[doc = " @param length Bit count"]
	#[doc = " @param parity Parity to test against"]
	#[doc = " @param parity_length Parity block length"]
	#[doc = " @return true"]
	#[doc = " @return false"]
	pub fn bit_lib_test_parity(data: *const u8, position: usize, length: u8, parity: BitLibParity, parity_length: u8) -> bool;
}
extern "C" {
	#[doc = " @brief Add parity to bit array"]
	#[doc = ""]
	#[doc = " @param data Source bit array"]
	#[doc = " @param position Start position"]
	#[doc = " @param dest Destination bit array"]
	#[doc = " @param dest_position Destination position"]
	#[doc = " @param source_length Source bit count"]
	#[doc = " @param parity_length Parity block length"]
	#[doc = " @param parity Parity to test against"]
	#[doc = " @return size_t"]
	pub fn bit_lib_add_parity(data: *const u8,
	                          position: usize,
	                          dest: *mut u8,
	                          dest_position: usize,
	                          source_length: u8,
	                          parity_length: u8,
	                          parity: BitLibParity)
	                          -> usize;
}
extern "C" {
	#[doc = " @brief Remove bit every n in array and shift array left. Useful to remove parity."]
	#[doc = ""]
	#[doc = " @param data Bit array"]
	#[doc = " @param position Start position"]
	#[doc = " @param length Bit count"]
	#[doc = " @param n every n bit will be removed"]
	#[doc = " @return size_t"]
	pub fn bit_lib_remove_bit_every_nth(data: *mut u8, position: usize, length: u8, n: u8) -> usize;
}
extern "C" {
	#[doc = " @brief Copy bits from source to destination."]
	#[doc = ""]
	#[doc = " @param data destination array"]
	#[doc = " @param position position in destination array"]
	#[doc = " @param length length of bits to copy"]
	#[doc = " @param source source array"]
	#[doc = " @param source_position position in source array"]
	pub fn bit_lib_copy_bits(data: *mut u8, position: usize, length: usize, source: *const u8, source_position: usize);
}
extern "C" {
	#[doc = " @brief Reverse bits in bit array"]
	#[doc = ""]
	#[doc = " @param data Bit array"]
	#[doc = " @param position start position"]
	#[doc = " @param length length of bits to reverse"]
	pub fn bit_lib_reverse_bits(data: *mut u8, position: usize, length: u8);
}
extern "C" {
	#[doc = " @brief Count 1 bits in data"]
	#[doc = ""]
	#[doc = " @param data"]
	#[doc = " @return uint8_t set bit count"]
	pub fn bit_lib_get_bit_count(data: u32) -> u8;
}
extern "C" {
	#[doc = " @brief Print data as bit array"]
	#[doc = ""]
	#[doc = " @param data"]
	#[doc = " @param length"]
	pub fn bit_lib_print_bits(data: *const u8, length: usize);
}
#[repr(C)]
pub struct BitLibRegion {
	pub mark: core::ffi::c_char,
	pub start: usize,
	pub length: usize,
}
#[test]
fn bindgen_test_layout_BitLibRegion() {
	assert_eq!(
	           ::core::mem::size_of::<BitLibRegion>(),
	           12usize,
	           concat!("Size of: ", stringify!(BitLibRegion))
	);
	assert_eq!(
	           ::core::mem::align_of::<BitLibRegion>(),
	           4usize,
	           concat!("Alignment of ", stringify!(BitLibRegion))
	);
	fn test_field_mark() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<BitLibRegion>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).mark) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(BitLibRegion), "::", stringify!(mark))
		);
	}
	test_field_mark();
	fn test_field_start() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<BitLibRegion>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).start) as usize - ptr as usize
		           },
		           4usize,
		           concat!("Offset of field: ", stringify!(BitLibRegion), "::", stringify!(start))
		);
	}
	test_field_start();
	fn test_field_length() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<BitLibRegion>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).length) as usize - ptr as usize
		           },
		           8usize,
		           concat!("Offset of field: ", stringify!(BitLibRegion), "::", stringify!(length))
		);
	}
	test_field_length();
}
extern "C" {
	#[doc = " @brief Print data as bit array and mark regions. Regions needs to be sorted by start position."]
	#[doc = ""]
	#[doc = " @param regions"]
	#[doc = " @param region_count"]
	#[doc = " @param data"]
	#[doc = " @param length"]
	pub fn bit_lib_print_regions(regions: *const BitLibRegion, region_count: usize, data: *const u8, length: usize);
}
extern "C" {
	#[doc = " @brief Reverse bits in uint16_t, faster than generic bit_lib_reverse_bits."]
	#[doc = ""]
	#[doc = " @param data"]
	#[doc = " @return uint16_t"]
	pub fn bit_lib_reverse_16_fast(data: u16) -> u16;
}
extern "C" {
	#[doc = " @brief Reverse bits in uint8_t, faster than generic bit_lib_reverse_bits."]
	#[doc = ""]
	#[doc = " @param byte Byte"]
	#[doc = " @return uint8_t the reversed byte"]
	pub fn bit_lib_reverse_8_fast(byte: u8) -> u8;
}
extern "C" {
	#[doc = " @brief Slow, but generic CRC8 implementation"]
	#[doc = ""]
	#[doc = " @param data"]
	#[doc = " @param data_size"]
	#[doc = " @param polynom CRC polynom"]
	#[doc = " @param init init value"]
	#[doc = " @param ref_in true if the right bit is older"]
	#[doc = " @param ref_out true to reverse output"]
	#[doc = " @param xor_out xor output with this value"]
	#[doc = " @return uint8_t"]
	pub fn bit_lib_crc8(data: *const u8, data_size: usize, polynom: u8, init: u8, ref_in: bool, ref_out: bool, xor_out: u8) -> u16;
}
extern "C" {
	#[doc = " @brief Slow, but generic CRC16 implementation"]
	#[doc = ""]
	#[doc = " @param data"]
	#[doc = " @param data_size"]
	#[doc = " @param polynom CRC polynom"]
	#[doc = " @param init init value"]
	#[doc = " @param ref_in true if the right bit is older"]
	#[doc = " @param ref_out true to reverse output"]
	#[doc = " @param xor_out xor output with this value"]
	#[doc = " @return uint16_t"]
	pub fn bit_lib_crc16(data: *const u8, data_size: usize, polynom: u16, init: u16, ref_in: bool, ref_out: bool, xor_out: u16)
	                     -> u16;
}
#[repr(C)]
pub struct uECC_Curve_t {
	_unused: [u8; 0],
}
pub type uECC_Curve = *const uECC_Curve_t;
extern "C" {
	pub fn uECC_secp160r1() -> uECC_Curve;
}
extern "C" {
	pub fn uECC_secp192r1() -> uECC_Curve;
}
extern "C" {
	pub fn uECC_secp224r1() -> uECC_Curve;
}
extern "C" {
	pub fn uECC_secp256r1() -> uECC_Curve;
}
extern "C" {
	pub fn uECC_secp256k1() -> uECC_Curve;
}
pub type uECC_RNG_Function = ::core::option::Option<unsafe extern "C" fn(dest: *mut u8, size: core::ffi::c_uint) -> core::ffi::c_int>;
extern "C" {
	pub fn uECC_set_rng(rng_function: uECC_RNG_Function);
}
extern "C" {
	pub fn uECC_get_rng() -> uECC_RNG_Function;
}
extern "C" {
	pub fn uECC_curve_private_key_size(curve: uECC_Curve) -> core::ffi::c_int;
}
extern "C" {
	pub fn uECC_curve_public_key_size(curve: uECC_Curve) -> core::ffi::c_int;
}
extern "C" {
	pub fn uECC_make_key(public_key: *mut u8, private_key: *mut u8, curve: uECC_Curve) -> core::ffi::c_int;
}
extern "C" {
	pub fn uECC_shared_secret(public_key: *const u8, private_key: *const u8, secret: *mut u8, curve: uECC_Curve) -> core::ffi::c_int;
}
extern "C" {
	pub fn uECC_compress(public_key: *const u8, compressed: *mut u8, curve: uECC_Curve);
}
extern "C" {
	pub fn uECC_decompress(compressed: *const u8, public_key: *mut u8, curve: uECC_Curve);
}
extern "C" {
	pub fn uECC_valid_public_key(public_key: *const u8, curve: uECC_Curve) -> core::ffi::c_int;
}
extern "C" {
	pub fn uECC_compute_public_key(private_key: *const u8, public_key: *mut u8, curve: uECC_Curve) -> core::ffi::c_int;
}
extern "C" {
	pub fn uECC_sign(private_key: *const u8,
	                 message_hash: *const u8,
	                 hash_size: core::ffi::c_uint,
	                 signature: *mut u8,
	                 curve: uECC_Curve)
	                 -> core::ffi::c_int;
}
#[repr(C)]
pub struct uECC_HashContext {
	pub init_hash: ::core::option::Option<unsafe extern "C" fn(context: *const uECC_HashContext)>,
	pub update_hash: ::core::option::Option<unsafe extern "C" fn(context: *const uECC_HashContext,
	                                                             message: *const u8,
	                                                             message_size: core::ffi::c_uint)>,
	pub finish_hash: ::core::option::Option<unsafe extern "C" fn(context: *const uECC_HashContext, hash_result: *mut u8)>,
	pub block_size: core::ffi::c_uint,
	pub result_size: core::ffi::c_uint,
	pub tmp: *mut u8,
}
#[test]
fn bindgen_test_layout_uECC_HashContext() {
	assert_eq!(
	           ::core::mem::size_of::<uECC_HashContext>(),
	           24usize,
	           concat!("Size of: ", stringify!(uECC_HashContext))
	);
	assert_eq!(
	           ::core::mem::align_of::<uECC_HashContext>(),
	           4usize,
	           concat!("Alignment of ", stringify!(uECC_HashContext))
	);
	fn test_field_init_hash() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<uECC_HashContext>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).init_hash) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(uECC_HashContext), "::", stringify!(init_hash))
		);
	}
	test_field_init_hash();
	fn test_field_update_hash() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<uECC_HashContext>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).update_hash) as usize - ptr as usize
		           },
		           4usize,
		           concat!(
			"Offset of field: ",
			stringify!(uECC_HashContext),
			"::",
			stringify!(update_hash)
		)
		);
	}
	test_field_update_hash();
	fn test_field_finish_hash() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<uECC_HashContext>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).finish_hash) as usize - ptr as usize
		           },
		           8usize,
		           concat!(
			"Offset of field: ",
			stringify!(uECC_HashContext),
			"::",
			stringify!(finish_hash)
		)
		);
	}
	test_field_finish_hash();
	fn test_field_block_size() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<uECC_HashContext>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).block_size) as usize - ptr as usize
		           },
		           12usize,
		           concat!(
			"Offset of field: ",
			stringify!(uECC_HashContext),
			"::",
			stringify!(block_size)
		)
		);
	}
	test_field_block_size();
	fn test_field_result_size() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<uECC_HashContext>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).result_size) as usize - ptr as usize
		           },
		           16usize,
		           concat!(
			"Offset of field: ",
			stringify!(uECC_HashContext),
			"::",
			stringify!(result_size)
		)
		);
	}
	test_field_result_size();
	fn test_field_tmp() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<uECC_HashContext>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).tmp) as usize - ptr as usize
		           },
		           20usize,
		           concat!("Offset of field: ", stringify!(uECC_HashContext), "::", stringify!(tmp))
		);
	}
	test_field_tmp();
}
extern "C" {
	pub fn uECC_sign_deterministic(private_key: *const u8,
	                               message_hash: *const u8,
	                               hash_size: core::ffi::c_uint,
	                               hash_context: *const uECC_HashContext,
	                               signature: *mut u8,
	                               curve: uECC_Curve)
	                               -> core::ffi::c_int;
}
extern "C" {
	pub fn uECC_verify(public_key: *const u8,
	                   message_hash: *const u8,
	                   hash_size: core::ffi::c_uint,
	                   signature: *const u8,
	                   curve: uECC_Curve)
	                   -> core::ffi::c_int;
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum iButtonKeyType {
	iButtonKeyDS1990 = 0,
	iButtonKeyCyfral = 1,
	iButtonKeyMetakom = 2,
}
#[repr(C)]
pub struct iButtonKey {
	_unused: [u8; 0],
}
extern "C" {
	#[doc = " Allocate key"]
	#[doc = " @return iButtonKey*"]
	pub fn ibutton_key_alloc() -> *mut iButtonKey;
}
extern "C" {
	#[doc = " Free key"]
	#[doc = " @param key"]
	pub fn ibutton_key_free(key: *mut iButtonKey);
}
extern "C" {
	#[doc = " Copy key"]
	#[doc = " @param to"]
	#[doc = " @param from"]
	pub fn ibutton_key_set(to: *mut iButtonKey, from: *const iButtonKey);
}
extern "C" {
	#[doc = " Set key data"]
	#[doc = " @param key"]
	#[doc = " @param data"]
	#[doc = " @param data_count"]
	pub fn ibutton_key_set_data(key: *mut iButtonKey, data: *mut u8, data_count: u8);
}
extern "C" {
	#[doc = " Clear key data"]
	#[doc = " @param key"]
	pub fn ibutton_key_clear_data(key: *mut iButtonKey);
}
extern "C" {
	#[doc = " Get pointer to key data"]
	#[doc = " @param key"]
	#[doc = " @return const uint8_t*"]
	pub fn ibutton_key_get_data_p(key: *mut iButtonKey) -> *const u8;
}
extern "C" {
	#[doc = " Get key data size"]
	#[doc = " @param key"]
	#[doc = " @return uint8_t"]
	pub fn ibutton_key_get_data_size(key: *mut iButtonKey) -> u8;
}
extern "C" {
	#[doc = " Set key type"]
	#[doc = " @param key"]
	#[doc = " @param key_type"]
	pub fn ibutton_key_set_type(key: *mut iButtonKey, key_type: iButtonKeyType);
}
extern "C" {
	#[doc = " Get key type"]
	#[doc = " @param key"]
	#[doc = " @return iButtonKeyType"]
	pub fn ibutton_key_get_type(key: *mut iButtonKey) -> iButtonKeyType;
}
extern "C" {
	#[doc = " Get type string from key type"]
	#[doc = " @param key_type"]
	#[doc = " @return const char*"]
	pub fn ibutton_key_get_string_by_type(key_type: iButtonKeyType) -> *const core::ffi::c_char;
}
extern "C" {
	#[doc = " Get key type from string"]
	#[doc = " @param type_string"]
	#[doc = " @param key_type"]
	#[doc = " @return bool"]
	pub fn ibutton_key_get_type_by_string(type_string: *const core::ffi::c_char, key_type: *mut iButtonKeyType) -> bool;
}
extern "C" {
	#[doc = " Get key data size from type"]
	#[doc = " @param key_type"]
	#[doc = " @return uint8_t"]
	pub fn ibutton_key_get_size_by_type(key_type: iButtonKeyType) -> u8;
}
extern "C" {
	#[doc = " Get max key size"]
	#[doc = " @return uint8_t"]
	pub fn ibutton_key_get_max_size() -> u8;
}
extern "C" {
	#[doc = " Check if CRC for onewire key is valid"]
	#[doc = " @param key"]
	#[doc = " @return true"]
	#[doc = " @return false"]
	pub fn ibutton_key_dallas_crc_is_valid(key: *mut iButtonKey) -> bool;
}
extern "C" {
	#[doc = " Check if onewire key is a DS1990 key"]
	#[doc = " @param key"]
	#[doc = " @return true"]
	#[doc = " @return false"]
	pub fn ibutton_key_dallas_is_1990_key(key: *mut iButtonKey) -> bool;
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum iButtonWorkerWriteResult {
	iButtonWorkerWriteOK = 0,
	iButtonWorkerWriteSameKey = 1,
	iButtonWorkerWriteNoDetect = 2,
	iButtonWorkerWriteCannotWrite = 3,
}
pub type iButtonWorkerReadCallback = ::core::option::Option<unsafe extern "C" fn(context: *mut core::ffi::c_void)>;
pub type iButtonWorkerWriteCallback =
	::core::option::Option<unsafe extern "C" fn(context: *mut core::ffi::c_void, result: iButtonWorkerWriteResult)>;
pub type iButtonWorkerEmulateCallback = ::core::option::Option<unsafe extern "C" fn(context: *mut core::ffi::c_void, emulated: bool)>;
#[repr(C)]
pub struct iButtonWorker {
	_unused: [u8; 0],
}
extern "C" {
	#[doc = " Allocate ibutton worker"]
	#[doc = " @return iButtonWorker*"]
	pub fn ibutton_worker_alloc() -> *mut iButtonWorker;
}
extern "C" {
	#[doc = " Free ibutton worker"]
	#[doc = " @param worker"]
	pub fn ibutton_worker_free(worker: *mut iButtonWorker);
}
extern "C" {
	#[doc = " Start ibutton worker thread"]
	#[doc = " @param worker"]
	pub fn ibutton_worker_start_thread(worker: *mut iButtonWorker);
}
extern "C" {
	#[doc = " Stop ibutton worker thread"]
	#[doc = " @param worker"]
	pub fn ibutton_worker_stop_thread(worker: *mut iButtonWorker);
}
extern "C" {
	#[doc = " Set \"read success\" callback"]
	#[doc = " @param worker"]
	#[doc = " @param callback"]
	#[doc = " @param context"]
	pub fn ibutton_worker_read_set_callback(worker: *mut iButtonWorker,
	                                        callback: iButtonWorkerReadCallback,
	                                        context: *mut core::ffi::c_void);
}
extern "C" {
	#[doc = " Start read mode"]
	#[doc = " @param worker"]
	#[doc = " @param key"]
	pub fn ibutton_worker_read_start(worker: *mut iButtonWorker, key: *mut iButtonKey);
}
extern "C" {
	#[doc = " Set \"write event\" callback"]
	#[doc = " @param worker"]
	#[doc = " @param callback"]
	#[doc = " @param context"]
	pub fn ibutton_worker_write_set_callback(worker: *mut iButtonWorker,
	                                         callback: iButtonWorkerWriteCallback,
	                                         context: *mut core::ffi::c_void);
}
extern "C" {
	#[doc = " Start write mode"]
	#[doc = " @param worker"]
	#[doc = " @param key"]
	pub fn ibutton_worker_write_start(worker: *mut iButtonWorker, key: *mut iButtonKey);
}
extern "C" {
	#[doc = " Set \"emulate success\" callback"]
	#[doc = " @param worker"]
	#[doc = " @param callback"]
	#[doc = " @param context"]
	pub fn ibutton_worker_emulate_set_callback(worker: *mut iButtonWorker,
	                                           callback: iButtonWorkerEmulateCallback,
	                                           context: *mut core::ffi::c_void);
}
extern "C" {
	#[doc = " Start emulate mode"]
	#[doc = " @param worker"]
	#[doc = " @param key"]
	pub fn ibutton_worker_emulate_start(worker: *mut iButtonWorker, key: *mut iButtonKey);
}
extern "C" {
	#[doc = " Stop all modes"]
	#[doc = " @param worker"]
	pub fn ibutton_worker_stop(worker: *mut iButtonWorker);
}
extern "C" {
	pub fn maxim_crc8(data: *const u8, data_size: u8, crc_init: u8) -> u8;
}
#[repr(C)]
pub struct OneWireSlave {
	_unused: [u8; 0],
}
#[repr(C)]
pub struct OneWireDevice {
	_unused: [u8; 0],
}
extern "C" {
	#[doc = " Allocate onewire device with ID"]
	#[doc = " @param id_1"]
	#[doc = " @param id_2"]
	#[doc = " @param id_3"]
	#[doc = " @param id_4"]
	#[doc = " @param id_5"]
	#[doc = " @param id_6"]
	#[doc = " @param id_7"]
	#[doc = " @param id_8"]
	#[doc = " @return OneWireDevice*"]
	pub fn onewire_device_alloc(id_1: u8, id_2: u8, id_3: u8, id_4: u8, id_5: u8, id_6: u8, id_7: u8, id_8: u8) -> *mut OneWireDevice;
}
extern "C" {
	#[doc = " Deallocate onewire device"]
	#[doc = " @param device"]
	pub fn onewire_device_free(device: *mut OneWireDevice);
}
extern "C" {
	#[doc = " Send ID report, called from onewire slave"]
	#[doc = " @param device"]
	pub fn onewire_device_send_id(device: *mut OneWireDevice);
}
extern "C" {
	#[doc = " Attach device to onewire slave bus"]
	#[doc = " @param device"]
	#[doc = " @param bus"]
	pub fn onewire_device_attach(device: *mut OneWireDevice, bus: *mut OneWireSlave);
}
extern "C" {
	#[doc = " Attach device from onewire slave bus"]
	#[doc = " @param device"]
	pub fn onewire_device_detach(device: *mut OneWireDevice);
}
extern "C" {
	#[doc = " Get pointer to device id array"]
	#[doc = " @param device"]
	#[doc = " @return uint8_t*"]
	pub fn onewire_device_get_id_p(device: *mut OneWireDevice) -> *mut u8;
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum OneWireHostSearchMode {
	#[doc = "< Search for alarmed device"]
	CONDITIONAL_SEARCH = 0,
	#[doc = "< Search all devices"]
	NORMAL_SEARCH = 1,
}
#[repr(C)]
pub struct OneWireHost {
	_unused: [u8; 0],
}
extern "C" {
	#[doc = " Allocate onewire host bus"]
	#[doc = " @param gpio"]
	#[doc = " @return OneWireHost*"]
	pub fn onewire_host_alloc() -> *mut OneWireHost;
}
extern "C" {
	#[doc = " Deallocate onewire host bus"]
	#[doc = " @param host"]
	pub fn onewire_host_free(host: *mut OneWireHost);
}
extern "C" {
	#[doc = " Reset bus"]
	#[doc = " @param host"]
	#[doc = " @return bool"]
	pub fn onewire_host_reset(host: *mut OneWireHost) -> bool;
}
extern "C" {
	#[doc = " Read one bit"]
	#[doc = " @param host"]
	#[doc = " @return bool"]
	pub fn onewire_host_read_bit(host: *mut OneWireHost) -> bool;
}
extern "C" {
	#[doc = " Read one byte"]
	#[doc = " @param host"]
	#[doc = " @return uint8_t"]
	pub fn onewire_host_read(host: *mut OneWireHost) -> u8;
}
extern "C" {
	#[doc = " Read many bytes"]
	#[doc = " @param host"]
	#[doc = " @param buffer"]
	#[doc = " @param count"]
	pub fn onewire_host_read_bytes(host: *mut OneWireHost, buffer: *mut u8, count: u16);
}
extern "C" {
	#[doc = " Write one bit"]
	#[doc = " @param host"]
	#[doc = " @param value"]
	pub fn onewire_host_write_bit(host: *mut OneWireHost, value: bool);
}
extern "C" {
	#[doc = " Write one byte"]
	#[doc = " @param host"]
	#[doc = " @param value"]
	pub fn onewire_host_write(host: *mut OneWireHost, value: u8);
}
extern "C" {
	#[doc = " Skip ROM command"]
	#[doc = " @param host"]
	pub fn onewire_host_skip(host: *mut OneWireHost);
}
extern "C" {
	#[doc = " Start working with the bus"]
	#[doc = " @param host"]
	pub fn onewire_host_start(host: *mut OneWireHost);
}
extern "C" {
	#[doc = " Stop working with the bus"]
	#[doc = " @param host"]
	pub fn onewire_host_stop(host: *mut OneWireHost);
}
extern "C" {
	#[doc = " @param host"]
	pub fn onewire_host_reset_search(host: *mut OneWireHost);
}
extern "C" {
	#[doc = " @param host"]
	#[doc = " @param family_code"]
	pub fn onewire_host_target_search(host: *mut OneWireHost, family_code: u8);
}
extern "C" {
	#[doc = " @param host"]
	#[doc = " @param newAddr"]
	#[doc = " @param mode"]
	#[doc = " @return uint8_t"]
	pub fn onewire_host_search(host: *mut OneWireHost, newAddr: *mut u8, mode: OneWireHostSearchMode) -> u8;
}
pub type OneWireSlaveResultCallback = ::core::option::Option<unsafe extern "C" fn(context: *mut core::ffi::c_void)>;
extern "C" {
	#[doc = " Allocate onewire slave"]
	#[doc = " @param pin"]
	#[doc = " @return OneWireSlave*"]
	pub fn onewire_slave_alloc() -> *mut OneWireSlave;
}
extern "C" {
	#[doc = " Free onewire slave"]
	#[doc = " @param bus"]
	pub fn onewire_slave_free(bus: *mut OneWireSlave);
}
extern "C" {
	#[doc = " Start working with the bus"]
	#[doc = " @param bus"]
	pub fn onewire_slave_start(bus: *mut OneWireSlave);
}
extern "C" {
	#[doc = " Stop working with the bus"]
	#[doc = " @param bus"]
	pub fn onewire_slave_stop(bus: *mut OneWireSlave);
}
extern "C" {
	#[doc = " Attach device for emulation"]
	#[doc = " @param bus"]
	#[doc = " @param device"]
	pub fn onewire_slave_attach(bus: *mut OneWireSlave, device: *mut OneWireDevice);
}
extern "C" {
	#[doc = " Detach device from bus"]
	#[doc = " @param bus"]
	pub fn onewire_slave_detach(bus: *mut OneWireSlave);
}
extern "C" {
	#[doc = " Set a callback to report emulation success"]
	#[doc = " @param bus"]
	#[doc = " @param result_cb"]
	#[doc = " @param context"]
	pub fn onewire_slave_set_result_callback(bus: *mut OneWireSlave,
	                                         result_cb: OneWireSlaveResultCallback,
	                                         context: *mut core::ffi::c_void);
}
extern "C" {
	pub fn _putchar(character: core::ffi::c_char);
}
extern "C" {
	pub fn __wrap_printf(format: *const core::ffi::c_char, ...) -> core::ffi::c_int;
}
extern "C" {
	pub fn __wrap_vsnprintf(str_: *mut core::ffi::c_char,
	                        size: usize,
	                        format: *const core::ffi::c_char,
	                        args: va_list)
	                        -> core::ffi::c_int;
}
extern "C" {
	pub fn __wrap_puts(str_: *const core::ffi::c_char) -> core::ffi::c_int;
}
extern "C" {
	pub fn __wrap_putchar(ch: core::ffi::c_int) -> core::ffi::c_int;
}
extern "C" {
	pub fn __wrap_putc(ch: core::ffi::c_int, stream: *mut FILE) -> core::ffi::c_int;
}
extern "C" {
	pub fn __wrap_snprintf(str_: *mut core::ffi::c_char, size: usize, format: *const core::ffi::c_char, ...) -> core::ffi::c_int;
}
extern "C" {
	pub fn __wrap_fflush(stream: *mut FILE) -> core::ffi::c_int;
}
extern "C" {
	pub fn __wrap___assert(file: *const core::ffi::c_char, line: core::ffi::c_int, e: *const core::ffi::c_char);
}
extern "C" {
	pub fn __wrap___assert_func(file: *const core::ffi::c_char,
	                            line: core::ffi::c_int,
	                            func: *const core::ffi::c_char,
	                            e: *const core::ffi::c_char);
}
#[repr(C)]
pub struct SubGhzKey {
	pub name: string_t,
	pub key: u64,
	pub type_: u16,
}
#[test]
fn bindgen_test_layout_SubGhzKey() {
	assert_eq!(
	           ::core::mem::size_of::<SubGhzKey>(),
	           32usize,
	           concat!("Size of: ", stringify!(SubGhzKey))
	);
	assert_eq!(
	           ::core::mem::align_of::<SubGhzKey>(),
	           8usize,
	           concat!("Alignment of ", stringify!(SubGhzKey))
	);
	fn test_field_name() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<SubGhzKey>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).name) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(SubGhzKey), "::", stringify!(name))
		);
	}
	test_field_name();
	fn test_field_key() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<SubGhzKey>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).key) as usize - ptr as usize
		           },
		           16usize,
		           concat!("Offset of field: ", stringify!(SubGhzKey), "::", stringify!(key))
		);
	}
	test_field_key();
	fn test_field_type() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<SubGhzKey>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize
		           },
		           24usize,
		           concat!("Offset of field: ", stringify!(SubGhzKey), "::", stringify!(type_))
		);
	}
	test_field_type();
}
#[repr(C)]
pub struct SubGhzKeyArray_s {
	pub size: usize,
	pub alloc: usize,
	pub ptr: *mut SubGhzKey,
}
#[test]
fn bindgen_test_layout_SubGhzKeyArray_s() {
	assert_eq!(
	           ::core::mem::size_of::<SubGhzKeyArray_s>(),
	           12usize,
	           concat!("Size of: ", stringify!(SubGhzKeyArray_s))
	);
	assert_eq!(
	           ::core::mem::align_of::<SubGhzKeyArray_s>(),
	           4usize,
	           concat!("Alignment of ", stringify!(SubGhzKeyArray_s))
	);
	fn test_field_size() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<SubGhzKeyArray_s>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).size) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(SubGhzKeyArray_s), "::", stringify!(size))
		);
	}
	test_field_size();
	fn test_field_alloc() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<SubGhzKeyArray_s>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).alloc) as usize - ptr as usize
		           },
		           4usize,
		           concat!("Offset of field: ", stringify!(SubGhzKeyArray_s), "::", stringify!(alloc))
		);
	}
	test_field_alloc();
	fn test_field_ptr() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<SubGhzKeyArray_s>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).ptr) as usize - ptr as usize
		           },
		           8usize,
		           concat!("Offset of field: ", stringify!(SubGhzKeyArray_s), "::", stringify!(ptr))
		);
	}
	test_field_ptr();
}
pub type SubGhzKeyArray_t = [SubGhzKeyArray_s; 1usize];
#[repr(C)]
pub struct SubGhzKeyArray_it_s {
	pub index: usize,
	pub array: *const SubGhzKeyArray_s,
}
#[test]
fn bindgen_test_layout_SubGhzKeyArray_it_s() {
	assert_eq!(
	           ::core::mem::size_of::<SubGhzKeyArray_it_s>(),
	           8usize,
	           concat!("Size of: ", stringify!(SubGhzKeyArray_it_s))
	);
	assert_eq!(
	           ::core::mem::align_of::<SubGhzKeyArray_it_s>(),
	           4usize,
	           concat!("Alignment of ", stringify!(SubGhzKeyArray_it_s))
	);
	fn test_field_index() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<SubGhzKeyArray_it_s>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).index) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(SubGhzKeyArray_it_s), "::", stringify!(index))
		);
	}
	test_field_index();
	fn test_field_array() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<SubGhzKeyArray_it_s>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).array) as usize - ptr as usize
		           },
		           4usize,
		           concat!("Offset of field: ", stringify!(SubGhzKeyArray_it_s), "::", stringify!(array))
		);
	}
	test_field_array();
}
pub type SubGhzKeyArray_it_t = [SubGhzKeyArray_it_s; 1usize];
pub type SubGhzKeyArray_ptr = *mut SubGhzKeyArray_s;
pub type SubGhzKeyArray_srcptr = *const SubGhzKeyArray_s;
pub type SubGhzKeyArray_ct = SubGhzKeyArray_t;
pub type SubGhzKeyArray_it_ct = SubGhzKeyArray_it_t;
pub type SubGhzKeyArray_subtype_ct = SubGhzKey;
#[repr(C)]
pub struct SubGhzKeystore {
	_unused: [u8; 0],
}
extern "C" {
	#[doc = " Allocate SubGhzKeystore."]
	#[doc = " @return SubGhzKeystore* pointer to a SubGhzKeystore instance"]
	pub fn subghz_keystore_alloc() -> *mut SubGhzKeystore;
}
extern "C" {
	#[doc = " Free SubGhzKeystore."]
	#[doc = " @param instance Pointer to a SubGhzKeystore instance"]
	pub fn subghz_keystore_free(instance: *mut SubGhzKeystore);
}
extern "C" {
	#[doc = " Loading manufacture key from file"]
	#[doc = " @param instance Pointer to a SubGhzKeystore instance"]
	#[doc = " @param filename Full path to the file"]
	pub fn subghz_keystore_load(instance: *mut SubGhzKeystore, filename: *const core::ffi::c_char) -> bool;
}
extern "C" {
	#[doc = " Save manufacture key to file"]
	#[doc = " @param instance Pointer to a SubGhzKeystore instance"]
	#[doc = " @param filename Full path to the file"]
	#[doc = " @return true On success"]
	pub fn subghz_keystore_save(instance: *mut SubGhzKeystore, filename: *const core::ffi::c_char, iv: *mut u8) -> bool;
}
extern "C" {
	#[doc = " Get array of keys and names manufacture"]
	#[doc = " @param instance Pointer to a SubGhzKeystore instance"]
	#[doc = " @return SubGhzKeyArray_t*"]
	pub fn subghz_keystore_get_data(instance: *mut SubGhzKeystore) -> *mut SubGhzKeyArray_t;
}
extern "C" {
	#[doc = " Save RAW encrypted to file"]
	#[doc = " @param input_file_name Full path to the input file"]
	#[doc = " @param output_file_name Full path to the output file"]
	#[doc = " @param iv IV, 16 bytes in hex"]
	pub fn subghz_keystore_raw_encrypted_save(input_file_name: *const core::ffi::c_char,
	                                          output_file_name: *const core::ffi::c_char,
	                                          iv: *mut u8)
	                                          -> bool;
}
extern "C" {
	#[doc = " Get decrypt RAW data to file"]
	#[doc = " @param file_name Full path to the input file"]
	#[doc = " @param offset Offset from the start of the RAW data"]
	#[doc = " @param data Returned array"]
	#[doc = " @param len Required data length"]
	#[doc = " @return true On success"]
	pub fn subghz_keystore_raw_get_data(file_name: *const core::ffi::c_char, offset: usize, data: *mut u8, len: usize) -> bool;
}
#[repr(C)]
pub struct SubGhzEnvironment {
	_unused: [u8; 0],
}
extern "C" {
	#[doc = " Allocate SubGhzEnvironment."]
	#[doc = " @return SubGhzEnvironment* pointer to a SubGhzEnvironment instance"]
	pub fn subghz_environment_alloc() -> *mut SubGhzEnvironment;
}
extern "C" {
	#[doc = " Free SubGhzEnvironment."]
	#[doc = " @param instance Pointer to a SubGhzEnvironment instance"]
	pub fn subghz_environment_free(instance: *mut SubGhzEnvironment);
}
extern "C" {
	#[doc = " Downloading the manufacture key file."]
	#[doc = " @param instance Pointer to a SubGhzEnvironment instance"]
	#[doc = " @param filename Full path to the file"]
	#[doc = " @return true On succes"]
	pub fn subghz_environment_load_keystore(instance: *mut SubGhzEnvironment, filename: *const core::ffi::c_char) -> bool;
}
extern "C" {
	#[doc = " Get pointer to a SubGhzKeystore* instance."]
	#[doc = " @return SubGhzEnvironment* pointer to a SubGhzEnvironment instance"]
	pub fn subghz_environment_get_keystore(instance: *mut SubGhzEnvironment) -> *mut SubGhzKeystore;
}
extern "C" {
	#[doc = " Set filename to work with Came Atomo."]
	#[doc = " @param instance Pointer to a SubGhzEnvironment instance"]
	#[doc = " @param filename Full path to the file"]
	pub fn subghz_environment_set_came_atomo_rainbow_table_file_name(instance: *mut SubGhzEnvironment,
	                                                                 filename: *const core::ffi::c_char);
}
extern "C" {
	#[doc = " Get filename to work with Came Atomo."]
	#[doc = " @param instance Pointer to a SubGhzEnvironment instance"]
	#[doc = " @return Full path to the file"]
	pub fn subghz_environment_get_came_atomo_rainbow_table_file_name(instance: *mut SubGhzEnvironment) -> *const core::ffi::c_char;
}
extern "C" {
	#[doc = " Set filename to work with Nice Flor-S."]
	#[doc = " @param instance Pointer to a SubGhzEnvironment instance"]
	#[doc = " @param filename Full path to the file"]
	pub fn subghz_environment_set_nice_flor_s_rainbow_table_file_name(instance: *mut SubGhzEnvironment,
	                                                                  filename: *const core::ffi::c_char);
}
extern "C" {
	#[doc = " Get filename to work with Nice Flor-S."]
	#[doc = " @param instance Pointer to a SubGhzEnvironment instance"]
	#[doc = " @return Full path to the file"]
	pub fn subghz_environment_get_nice_flor_s_rainbow_table_file_name(instance: *mut SubGhzEnvironment) -> *const core::ffi::c_char;
}
#[repr(u32)]
#[non_exhaustive]
#[doc = " SubGhzNotification state"]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum SubGhzNotificationState {
	SubGhzNotificationStateStarting = 0,
	SubGhzNotificationStateIDLE = 1,
	SubGhzNotificationStateTx = 2,
	SubGhzNotificationStateRx = 3,
	SubGhzNotificationStateRxDone = 4,
}
#[repr(u32)]
#[non_exhaustive]
#[doc = " SubGhzTxRx state"]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum SubGhzTxRxState {
	SubGhzTxRxStateIDLE = 0,
	SubGhzTxRxStateRx = 1,
	SubGhzTxRxStateTx = 2,
	SubGhzTxRxStateSleep = 3,
}
#[repr(u32)]
#[non_exhaustive]
#[doc = " SubGhzHopperState state"]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum SubGhzHopperState {
	SubGhzHopperStateOFF = 0,
	SubGhzHopperStateRunnig = 1,
	SubGhzHopperStatePause = 2,
	SubGhzHopperStateRSSITimeOut = 3,
}
#[repr(u32)]
#[non_exhaustive]
#[doc = " SubGhzRxKeyState state"]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum SubGhzRxKeyState {
	SubGhzRxKeyStateIDLE = 0,
	SubGhzRxKeyStateNoSave = 1,
	SubGhzRxKeyStateNeedSave = 2,
	SubGhzRxKeyStateBack = 3,
	SubGhzRxKeyStateStart = 4,
	SubGhzRxKeyStateAddKey = 5,
	SubGhzRxKeyStateExit = 6,
	SubGhzRxKeyStateRAWLoad = 7,
	SubGhzRxKeyStateRAWSave = 8,
}
#[repr(u32)]
#[non_exhaustive]
#[doc = " SubGhzLoadKeyState state"]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum SubGhzLoadKeyState {
	SubGhzLoadKeyStateUnknown = 0,
	SubGhzLoadKeyStateOK = 1,
	SubGhzLoadKeyStateParseErr = 2,
}
#[repr(u32)]
#[non_exhaustive]
#[doc = " SubGhzLock"]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum SubGhzLock {
	SubGhzLockOff = 0,
	SubGhzLockOn = 1,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum SubGhzViewId {
	SubGhzViewIdMenu = 0,
	SubGhzViewIdReceiver = 1,
	SubGhzViewIdPopup = 2,
	SubGhzViewIdTextInput = 3,
	SubGhzViewIdWidget = 4,
	SubGhzViewIdTransmitter = 5,
	SubGhzViewIdVariableItemList = 6,
	SubGhzViewIdFrequencyAnalyzer = 7,
	SubGhzViewIdReadRAW = 8,
	SubGhzViewIdStatic = 9,
	SubGhzViewIdTestCarrier = 10,
	SubGhzViewIdTestPacket = 11,
}
#[repr(C)]
pub struct SubGhzPresetDefinition {
	pub name: string_t,
	pub frequency: u32,
	pub data: *mut u8,
	pub data_size: usize,
}
#[test]
fn bindgen_test_layout_SubGhzPresetDefinition() {
	assert_eq!(
	           ::core::mem::size_of::<SubGhzPresetDefinition>(),
	           24usize,
	           concat!("Size of: ", stringify!(SubGhzPresetDefinition))
	);
	assert_eq!(
	           ::core::mem::align_of::<SubGhzPresetDefinition>(),
	           4usize,
	           concat!("Alignment of ", stringify!(SubGhzPresetDefinition))
	);
	fn test_field_name() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<SubGhzPresetDefinition>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).name) as usize - ptr as usize
		           },
		           0usize,
		           concat!(
			"Offset of field: ",
			stringify!(SubGhzPresetDefinition),
			"::",
			stringify!(name)
		)
		);
	}
	test_field_name();
	fn test_field_frequency() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<SubGhzPresetDefinition>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).frequency) as usize - ptr as usize
		           },
		           12usize,
		           concat!(
			"Offset of field: ",
			stringify!(SubGhzPresetDefinition),
			"::",
			stringify!(frequency)
		)
		);
	}
	test_field_frequency();
	fn test_field_data() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<SubGhzPresetDefinition>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).data) as usize - ptr as usize
		           },
		           16usize,
		           concat!(
			"Offset of field: ",
			stringify!(SubGhzPresetDefinition),
			"::",
			stringify!(data)
		)
		);
	}
	test_field_data();
	fn test_field_data_size() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<SubGhzPresetDefinition>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).data_size) as usize - ptr as usize
		           },
		           20usize,
		           concat!(
			"Offset of field: ",
			stringify!(SubGhzPresetDefinition),
			"::",
			stringify!(data_size)
		)
		);
	}
	test_field_data_size();
}
pub type SubGhzAlloc = ::core::option::Option<unsafe extern "C" fn(environment: *mut SubGhzEnvironment) -> *mut core::ffi::c_void>;
pub type SubGhzFree = ::core::option::Option<unsafe extern "C" fn(context: *mut core::ffi::c_void)>;
pub type SubGhzSerialize = ::core::option::Option<unsafe extern "C" fn(context: *mut core::ffi::c_void,
                                                                       flipper_format: *mut FlipperFormat,
                                                                       preset: *mut SubGhzPresetDefinition)
                                                                       -> bool>;
pub type SubGhzDeserialize =
	::core::option::Option<unsafe extern "C" fn(context: *mut core::ffi::c_void, flipper_format: *mut FlipperFormat) -> bool>;
pub type SubGhzDecoderFeed =
	::core::option::Option<unsafe extern "C" fn(decoder: *mut core::ffi::c_void, level: bool, duration: u32)>;
pub type SubGhzDecoderReset = ::core::option::Option<unsafe extern "C" fn(decoder: *mut core::ffi::c_void)>;
pub type SubGhzGetHashData = ::core::option::Option<unsafe extern "C" fn(decoder: *mut core::ffi::c_void) -> u8>;
pub type SubGhzGetString = ::core::option::Option<unsafe extern "C" fn(decoder: *mut core::ffi::c_void, output: *mut string_t)>;
pub type SubGhzEncoderStop = ::core::option::Option<unsafe extern "C" fn(encoder: *mut core::ffi::c_void)>;
pub type SubGhzEncoderYield = ::core::option::Option<unsafe extern "C" fn(context: *mut core::ffi::c_void) -> LevelDuration>;
#[repr(C)]
pub struct SubGhzProtocolDecoder {
	pub alloc: SubGhzAlloc,
	pub free: SubGhzFree,
	pub feed: SubGhzDecoderFeed,
	pub reset: SubGhzDecoderReset,
	pub get_hash_data: SubGhzGetHashData,
	pub get_string: SubGhzGetString,
	pub serialize: SubGhzSerialize,
	pub deserialize: SubGhzDeserialize,
}
#[test]
fn bindgen_test_layout_SubGhzProtocolDecoder() {
	assert_eq!(
	           ::core::mem::size_of::<SubGhzProtocolDecoder>(),
	           32usize,
	           concat!("Size of: ", stringify!(SubGhzProtocolDecoder))
	);
	assert_eq!(
	           ::core::mem::align_of::<SubGhzProtocolDecoder>(),
	           4usize,
	           concat!("Alignment of ", stringify!(SubGhzProtocolDecoder))
	);
	fn test_field_alloc() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<SubGhzProtocolDecoder>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).alloc) as usize - ptr as usize
		           },
		           0usize,
		           concat!(
			"Offset of field: ",
			stringify!(SubGhzProtocolDecoder),
			"::",
			stringify!(alloc)
		)
		);
	}
	test_field_alloc();
	fn test_field_free() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<SubGhzProtocolDecoder>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).free) as usize - ptr as usize
		           },
		           4usize,
		           concat!("Offset of field: ", stringify!(SubGhzProtocolDecoder), "::", stringify!(free))
		);
	}
	test_field_free();
	fn test_field_feed() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<SubGhzProtocolDecoder>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).feed) as usize - ptr as usize
		           },
		           8usize,
		           concat!("Offset of field: ", stringify!(SubGhzProtocolDecoder), "::", stringify!(feed))
		);
	}
	test_field_feed();
	fn test_field_reset() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<SubGhzProtocolDecoder>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).reset) as usize - ptr as usize
		           },
		           12usize,
		           concat!(
			"Offset of field: ",
			stringify!(SubGhzProtocolDecoder),
			"::",
			stringify!(reset)
		)
		);
	}
	test_field_reset();
	fn test_field_get_hash_data() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<SubGhzProtocolDecoder>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).get_hash_data) as usize - ptr as usize
		           },
		           16usize,
		           concat!(
			"Offset of field: ",
			stringify!(SubGhzProtocolDecoder),
			"::",
			stringify!(get_hash_data)
		)
		);
	}
	test_field_get_hash_data();
	fn test_field_get_string() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<SubGhzProtocolDecoder>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).get_string) as usize - ptr as usize
		           },
		           20usize,
		           concat!(
			"Offset of field: ",
			stringify!(SubGhzProtocolDecoder),
			"::",
			stringify!(get_string)
		)
		);
	}
	test_field_get_string();
	fn test_field_serialize() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<SubGhzProtocolDecoder>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).serialize) as usize - ptr as usize
		           },
		           24usize,
		           concat!(
			"Offset of field: ",
			stringify!(SubGhzProtocolDecoder),
			"::",
			stringify!(serialize)
		)
		);
	}
	test_field_serialize();
	fn test_field_deserialize() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<SubGhzProtocolDecoder>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).deserialize) as usize - ptr as usize
		           },
		           28usize,
		           concat!(
			"Offset of field: ",
			stringify!(SubGhzProtocolDecoder),
			"::",
			stringify!(deserialize)
		)
		);
	}
	test_field_deserialize();
}
#[repr(C)]
pub struct SubGhzProtocolEncoder {
	pub alloc: SubGhzAlloc,
	pub free: SubGhzFree,
	pub deserialize: SubGhzDeserialize,
	pub stop: SubGhzEncoderStop,
	pub yield_: SubGhzEncoderYield,
}
#[test]
fn bindgen_test_layout_SubGhzProtocolEncoder() {
	assert_eq!(
	           ::core::mem::size_of::<SubGhzProtocolEncoder>(),
	           20usize,
	           concat!("Size of: ", stringify!(SubGhzProtocolEncoder))
	);
	assert_eq!(
	           ::core::mem::align_of::<SubGhzProtocolEncoder>(),
	           4usize,
	           concat!("Alignment of ", stringify!(SubGhzProtocolEncoder))
	);
	fn test_field_alloc() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<SubGhzProtocolEncoder>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).alloc) as usize - ptr as usize
		           },
		           0usize,
		           concat!(
			"Offset of field: ",
			stringify!(SubGhzProtocolEncoder),
			"::",
			stringify!(alloc)
		)
		);
	}
	test_field_alloc();
	fn test_field_free() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<SubGhzProtocolEncoder>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).free) as usize - ptr as usize
		           },
		           4usize,
		           concat!("Offset of field: ", stringify!(SubGhzProtocolEncoder), "::", stringify!(free))
		);
	}
	test_field_free();
	fn test_field_deserialize() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<SubGhzProtocolEncoder>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).deserialize) as usize - ptr as usize
		           },
		           8usize,
		           concat!(
			"Offset of field: ",
			stringify!(SubGhzProtocolEncoder),
			"::",
			stringify!(deserialize)
		)
		);
	}
	test_field_deserialize();
	fn test_field_stop() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<SubGhzProtocolEncoder>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).stop) as usize - ptr as usize
		           },
		           12usize,
		           concat!("Offset of field: ", stringify!(SubGhzProtocolEncoder), "::", stringify!(stop))
		);
	}
	test_field_stop();
	fn test_field_yield() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<SubGhzProtocolEncoder>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).yield_) as usize - ptr as usize
		           },
		           16usize,
		           concat!(
			"Offset of field: ",
			stringify!(SubGhzProtocolEncoder),
			"::",
			stringify!(yield_)
		)
		);
	}
	test_field_yield();
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum SubGhzProtocolType {
	SubGhzProtocolTypeUnknown = 0,
	SubGhzProtocolTypeStatic = 1,
	SubGhzProtocolTypeDynamic = 2,
	SubGhzProtocolTypeRAW = 3,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum SubGhzProtocolFlag {
	SubGhzProtocolFlag_RAW = 1,
	SubGhzProtocolFlag_Decodable = 2,
	SubGhzProtocolFlag_315 = 4,
	SubGhzProtocolFlag_433 = 8,
	SubGhzProtocolFlag_868 = 16,
	SubGhzProtocolFlag_AM = 32,
	SubGhzProtocolFlag_FM = 64,
	SubGhzProtocolFlag_Save = 128,
	SubGhzProtocolFlag_Load = 256,
	SubGhzProtocolFlag_Send = 512,
}
#[repr(C)]
pub struct SubGhzProtocol {
	pub name: *const core::ffi::c_char,
	pub type_: SubGhzProtocolType,
	pub flag: SubGhzProtocolFlag,
	pub encoder: *const SubGhzProtocolEncoder,
	pub decoder: *const SubGhzProtocolDecoder,
}
#[test]
fn bindgen_test_layout_SubGhzProtocol() {
	assert_eq!(
	           ::core::mem::size_of::<SubGhzProtocol>(),
	           20usize,
	           concat!("Size of: ", stringify!(SubGhzProtocol))
	);
	assert_eq!(
	           ::core::mem::align_of::<SubGhzProtocol>(),
	           4usize,
	           concat!("Alignment of ", stringify!(SubGhzProtocol))
	);
	fn test_field_name() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<SubGhzProtocol>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).name) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(SubGhzProtocol), "::", stringify!(name))
		);
	}
	test_field_name();
	fn test_field_type() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<SubGhzProtocol>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize
		           },
		           4usize,
		           concat!("Offset of field: ", stringify!(SubGhzProtocol), "::", stringify!(type_))
		);
	}
	test_field_type();
	fn test_field_flag() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<SubGhzProtocol>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).flag) as usize - ptr as usize
		           },
		           8usize,
		           concat!("Offset of field: ", stringify!(SubGhzProtocol), "::", stringify!(flag))
		);
	}
	test_field_flag();
	fn test_field_encoder() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<SubGhzProtocol>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).encoder) as usize - ptr as usize
		           },
		           12usize,
		           concat!("Offset of field: ", stringify!(SubGhzProtocol), "::", stringify!(encoder))
		);
	}
	test_field_encoder();
	fn test_field_decoder() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<SubGhzProtocol>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).decoder) as usize - ptr as usize
		           },
		           16usize,
		           concat!("Offset of field: ", stringify!(SubGhzProtocol), "::", stringify!(decoder))
		);
	}
	test_field_decoder();
}
pub type SubGhzProtocolDecoderBaseRxCallback =
	::core::option::Option<unsafe extern "C" fn(instance: *mut SubGhzProtocolDecoderBase, context: *mut core::ffi::c_void)>;
pub type SubGhzProtocolDecoderBaseSerialize =
	::core::option::Option<unsafe extern "C" fn(decoder_base: *mut SubGhzProtocolDecoderBase, output: *mut string_t)>;
#[repr(C)]
pub struct SubGhzProtocolDecoderBase {
	pub protocol: *const SubGhzProtocol,
	pub callback: SubGhzProtocolDecoderBaseRxCallback,
	pub context: *mut core::ffi::c_void,
}
#[test]
fn bindgen_test_layout_SubGhzProtocolDecoderBase() {
	assert_eq!(
	           ::core::mem::size_of::<SubGhzProtocolDecoderBase>(),
	           12usize,
	           concat!("Size of: ", stringify!(SubGhzProtocolDecoderBase))
	);
	assert_eq!(
	           ::core::mem::align_of::<SubGhzProtocolDecoderBase>(),
	           4usize,
	           concat!("Alignment of ", stringify!(SubGhzProtocolDecoderBase))
	);
	fn test_field_protocol() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<SubGhzProtocolDecoderBase>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).protocol) as usize - ptr as usize
		           },
		           0usize,
		           concat!(
			"Offset of field: ",
			stringify!(SubGhzProtocolDecoderBase),
			"::",
			stringify!(protocol)
		)
		);
	}
	test_field_protocol();
	fn test_field_callback() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<SubGhzProtocolDecoderBase>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).callback) as usize - ptr as usize
		           },
		           4usize,
		           concat!(
			"Offset of field: ",
			stringify!(SubGhzProtocolDecoderBase),
			"::",
			stringify!(callback)
		)
		);
	}
	test_field_callback();
	fn test_field_context() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<SubGhzProtocolDecoderBase>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).context) as usize - ptr as usize
		           },
		           8usize,
		           concat!(
			"Offset of field: ",
			stringify!(SubGhzProtocolDecoderBase),
			"::",
			stringify!(context)
		)
		);
	}
	test_field_context();
}
extern "C" {
	#[doc = " Set a callback upon completion of successful decoding of one of the protocols."]
	#[doc = " @param decoder_base Pointer to a SubGhzProtocolDecoderBase instance"]
	#[doc = " @param callback Callback, SubGhzProtocolDecoderBaseRxCallback"]
	#[doc = " @param context Context"]
	pub fn subghz_protocol_decoder_base_set_decoder_callback(decoder_base: *mut SubGhzProtocolDecoderBase,
	                                                         callback: SubGhzProtocolDecoderBaseRxCallback,
	                                                         context: *mut core::ffi::c_void);
}
extern "C" {
	#[doc = " Getting a textual representation of the received data."]
	#[doc = " @param decoder_base Pointer to a SubGhzProtocolDecoderBase instance"]
	#[doc = " @param output Resulting text"]
	pub fn subghz_protocol_decoder_base_get_string(decoder_base: *mut SubGhzProtocolDecoderBase, output: *mut string_t) -> bool;
}
extern "C" {
	#[doc = " Serialize data SubGhzProtocolDecoderBase."]
	#[doc = " @param decoder_base Pointer to a SubGhzProtocolDecoderBase instance"]
	#[doc = " @param flipper_format Pointer to a FlipperFormat instance"]
	#[doc = " @param preset The modulation on which the signal was received, SubGhzPresetDefinition"]
	#[doc = " @return true On success"]
	pub fn subghz_protocol_decoder_base_serialize(decoder_base: *mut SubGhzProtocolDecoderBase,
	                                              flipper_format: *mut FlipperFormat,
	                                              preset: *mut SubGhzPresetDefinition)
	                                              -> bool;
}
extern "C" {
	#[doc = " Deserialize data SubGhzProtocolDecoderBase."]
	#[doc = " @param decoder_base Pointer to a SubGhzProtocolDecoderBase instance"]
	#[doc = " @param flipper_format Pointer to a FlipperFormat instance"]
	#[doc = " @return true On success"]
	pub fn subghz_protocol_decoder_base_deserialize(decoder_base: *mut SubGhzProtocolDecoderBase,
	                                                flipper_format: *mut FlipperFormat)
	                                                -> bool;
}
extern "C" {
	#[doc = " Getting the hash sum of the last randomly received parcel."]
	#[doc = " @param decoder_base Pointer to a SubGhzProtocolDecoderBase instance"]
	#[doc = " @return hash Hash sum"]
	pub fn subghz_protocol_decoder_base_get_hash_data(decoder_base: *mut SubGhzProtocolDecoderBase) -> u8;
}
#[repr(C)]
pub struct SubGhzProtocolEncoderBase {
	pub protocol: *const SubGhzProtocol,
}
#[test]
fn bindgen_test_layout_SubGhzProtocolEncoderBase() {
	assert_eq!(
	           ::core::mem::size_of::<SubGhzProtocolEncoderBase>(),
	           4usize,
	           concat!("Size of: ", stringify!(SubGhzProtocolEncoderBase))
	);
	assert_eq!(
	           ::core::mem::align_of::<SubGhzProtocolEncoderBase>(),
	           4usize,
	           concat!("Alignment of ", stringify!(SubGhzProtocolEncoderBase))
	);
	fn test_field_protocol() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<SubGhzProtocolEncoderBase>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).protocol) as usize - ptr as usize
		           },
		           0usize,
		           concat!(
			"Offset of field: ",
			stringify!(SubGhzProtocolEncoderBase),
			"::",
			stringify!(protocol)
		)
		);
	}
	test_field_protocol();
}
pub type SubGhzProtocolEncoderRAWCallbackEnd = ::core::option::Option<unsafe extern "C" fn(context: *mut core::ffi::c_void)>;
#[repr(C)]
pub struct SubGhzProtocolDecoderRAW {
	_unused: [u8; 0],
}
#[repr(C)]
pub struct SubGhzProtocolEncoderRAW {
	_unused: [u8; 0],
}
extern "C" {
	pub static subghz_protocol_raw_decoder: SubGhzProtocolDecoder;
}
extern "C" {
	pub static subghz_protocol_raw_encoder: SubGhzProtocolEncoder;
}
extern "C" {
	pub static subghz_protocol_raw: SubGhzProtocol;
}
extern "C" {
	#[doc = " Open file for writing"]
	#[doc = " @param instance Pointer to a SubGhzProtocolDecoderRAW instance"]
	#[doc = " @param dev_name  File name"]
	#[doc = " @param preset The modulation on which the signal was received, SubGhzPresetDefinition"]
	#[doc = " @return true On success"]
	pub fn subghz_protocol_raw_save_to_file_init(instance: *mut SubGhzProtocolDecoderRAW,
	                                             dev_name: *const core::ffi::c_char,
	                                             preset: *mut SubGhzPresetDefinition)
	                                             -> bool;
}
extern "C" {
	#[doc = " Stop writing file to flash"]
	#[doc = " @param instance Pointer to a SubGhzProtocolDecoderRAW instance"]
	pub fn subghz_protocol_raw_save_to_file_stop(instance: *mut SubGhzProtocolDecoderRAW);
}
extern "C" {
	#[doc = " Get the number of samples received SubGhzProtocolDecoderRAW."]
	#[doc = " @param instance Pointer to a SubGhzProtocolDecoderRAW instance"]
	#[doc = " @return count of samples"]
	pub fn subghz_protocol_raw_get_sample_write(instance: *mut SubGhzProtocolDecoderRAW) -> usize;
}
extern "C" {
	#[doc = " Allocate SubGhzProtocolDecoderRAW."]
	#[doc = " @param environment Pointer to a SubGhzEnvironment instance"]
	#[doc = " @return SubGhzProtocolDecoderRAW* pointer to a SubGhzProtocolDecoderRAW instance"]
	pub fn subghz_protocol_decoder_raw_alloc(environment: *mut SubGhzEnvironment) -> *mut core::ffi::c_void;
}
extern "C" {
	#[doc = " Free SubGhzProtocolDecoderRAW."]
	#[doc = " @param context Pointer to a SubGhzProtocolDecoderRAW instance"]
	pub fn subghz_protocol_decoder_raw_free(context: *mut core::ffi::c_void);
}
extern "C" {
	#[doc = " Reset decoder SubGhzProtocolDecoderRAW."]
	#[doc = " @param context Pointer to a SubGhzProtocolDecoderRAW instance"]
	pub fn subghz_protocol_decoder_raw_reset(context: *mut core::ffi::c_void);
}
extern "C" {
	#[doc = " Parse a raw sequence of levels and durations received from the air."]
	#[doc = " @param context Pointer to a SubGhzProtocolDecoderRAW instance"]
	#[doc = " @param level Signal level true-high false-low"]
	#[doc = " @param duration Duration of this level in, us"]
	pub fn subghz_protocol_decoder_raw_feed(context: *mut core::ffi::c_void, level: bool, duration: u32);
}
extern "C" {
	#[doc = " Deserialize data SubGhzProtocolDecoderRAW."]
	#[doc = " @param context Pointer to a SubGhzProtocolDecoderRAW instance"]
	#[doc = " @param flipper_format Pointer to a FlipperFormat instance"]
	#[doc = " @return true On success"]
	pub fn subghz_protocol_decoder_raw_deserialize(context: *mut core::ffi::c_void, flipper_format: *mut FlipperFormat) -> bool;
}
extern "C" {
	#[doc = " Getting a textual representation of the received data."]
	#[doc = " @param context Pointer to a SubGhzProtocolDecoderRAW instance"]
	#[doc = " @param output Resulting text"]
	pub fn subghz_protocol_decoder_raw_get_string(context: *mut core::ffi::c_void, output: *mut string_t);
}
extern "C" {
	#[doc = " Allocate SubGhzProtocolEncoderRAW."]
	#[doc = " @param environment Pointer to a SubGhzEnvironment instance"]
	#[doc = " @return SubGhzProtocolEncoderRAW* pointer to a SubGhzProtocolEncoderRAW instance"]
	pub fn subghz_protocol_encoder_raw_alloc(environment: *mut SubGhzEnvironment) -> *mut core::ffi::c_void;
}
extern "C" {
	#[doc = " Free SubGhzProtocolEncoderRAW."]
	#[doc = " @param context Pointer to a SubGhzProtocolEncoderRAW instance"]
	pub fn subghz_protocol_encoder_raw_free(context: *mut core::ffi::c_void);
}
extern "C" {
	#[doc = " Forced transmission stop."]
	#[doc = " @param context Pointer to a SubGhzProtocolEncoderRAW instance"]
	pub fn subghz_protocol_encoder_raw_stop(context: *mut core::ffi::c_void);
}
extern "C" {
	#[doc = " Set callback on completion of file transfer."]
	#[doc = " @param instance Pointer to a SubGhzProtocolEncoderRAW instance"]
	#[doc = " @param callback_end Callback, SubGhzProtocolEncoderRAWCallbackEnd"]
	#[doc = " @param context_end Context"]
	pub fn subghz_protocol_raw_file_encoder_worker_set_callback_end(instance: *mut SubGhzProtocolEncoderRAW,
	                                                                callback_end: SubGhzProtocolEncoderRAWCallbackEnd,
	                                                                context_end: *mut core::ffi::c_void);
}
extern "C" {
	#[doc = " File generation for RAW work."]
	#[doc = " @param flipper_format Pointer to a FlipperFormat instance"]
	#[doc = " @param file_path File path"]
	pub fn subghz_protocol_raw_gen_fff_data(flipper_format: *mut FlipperFormat, file_path: *const core::ffi::c_char);
}
extern "C" {
	#[doc = " Deserialize and generating an upload to send."]
	#[doc = " @param context Pointer to a SubGhzProtocolEncoderRAW instance"]
	#[doc = " @param flipper_format Pointer to a FlipperFormat instance"]
	#[doc = " @return true On success"]
	pub fn subghz_protocol_encoder_raw_deserialize(context: *mut core::ffi::c_void, flipper_format: *mut FlipperFormat) -> bool;
}
extern "C" {
	#[doc = " Getting the level and duration of the upload to be loaded into DMA."]
	#[doc = " @param context Pointer to a SubGhzProtocolEncoderRAW instance"]
	#[doc = " @return LevelDuration"]
	pub fn subghz_protocol_encoder_raw_yield(context: *mut core::ffi::c_void) -> LevelDuration;
}
#[repr(C)]
pub struct SubGhzReceiver {
	_unused: [u8; 0],
}
pub type SubGhzReceiverCallback = ::core::option::Option<unsafe extern "C" fn(decoder: *mut SubGhzReceiver,
                                                                              decoder_base: *mut SubGhzProtocolDecoderBase,
                                                                              context: *mut core::ffi::c_void)>;
extern "C" {
	#[doc = " Allocate and init SubGhzReceiver."]
	#[doc = " @param environment Pointer to a SubGhzEnvironment instance"]
	#[doc = " @return SubGhzReceiver* pointer to a SubGhzReceiver instance"]
	pub fn subghz_receiver_alloc_init(environment: *mut SubGhzEnvironment) -> *mut SubGhzReceiver;
}
extern "C" {
	#[doc = " Free SubGhzReceiver."]
	#[doc = " @param instance Pointer to a SubGhzReceiver instance"]
	pub fn subghz_receiver_free(instance: *mut SubGhzReceiver);
}
extern "C" {
	#[doc = " Parse a raw sequence of levels and durations received from the air."]
	#[doc = " @param instance Pointer to a SubGhzReceiver instance"]
	#[doc = " @param level Signal level true-high false-low"]
	#[doc = " @param duration Duration of this level in, us"]
	pub fn subghz_receiver_decode(instance: *mut SubGhzReceiver, level: bool, duration: u32);
}
extern "C" {
	#[doc = " Reset decoder SubGhzReceiver."]
	#[doc = " @param instance Pointer to a SubGhzReceiver instance"]
	pub fn subghz_receiver_reset(instance: *mut SubGhzReceiver);
}
extern "C" {
	#[doc = " Set a callback upon completion of successful decoding of one of the protocols."]
	#[doc = " @param instance Pointer to a SubGhzReceiver instance"]
	#[doc = " @param callback Callback, SubGhzReceiverCallback"]
	#[doc = " @param context Context"]
	pub fn subghz_receiver_set_rx_callback(instance: *mut SubGhzReceiver,
	                                       callback: SubGhzReceiverCallback,
	                                       context: *mut core::ffi::c_void);
}
extern "C" {
	#[doc = " Set the filter of receivers that will work at the moment."]
	#[doc = " @param instance Pointer to a SubGhzReceiver instance"]
	#[doc = " @param filter Filter, SubGhzProtocolFlag"]
	pub fn subghz_receiver_set_filter(instance: *mut SubGhzReceiver, filter: SubGhzProtocolFlag);
}
extern "C" {
	#[doc = " Search for a cattery by his name."]
	#[doc = " @param instance Pointer to a SubGhzReceiver instance"]
	#[doc = " @param decoder_name Receiver name"]
	#[doc = " @return SubGhzProtocolDecoderBase* pointer to a SubGhzProtocolDecoderBase instance"]
	pub fn subghz_receiver_search_decoder_base_by_name(instance: *mut SubGhzReceiver,
	                                                   decoder_name: *const core::ffi::c_char)
	                                                   -> *mut SubGhzProtocolDecoderBase;
}
pub type SubGhzTxRxWorkerCallbackHaveRead = ::core::option::Option<unsafe extern "C" fn(context: *mut core::ffi::c_void)>;
#[repr(C)]
pub struct SubGhzTxRxWorker {
	_unused: [u8; 0],
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum SubGhzTxRxWorkerStatus {
	SubGhzTxRxWorkerStatusIDLE = 0,
	SubGhzTxRxWorkerStatusTx = 1,
	SubGhzTxRxWorkerStatusRx = 2,
}
extern "C" {
	#[doc = " SubGhzTxRxWorker, add data to transfer"]
	#[doc = " @param instance  Pointer to a SubGhzTxRxWorker instance"]
	#[doc = " @param data      *data"]
	#[doc = " @param size      data size"]
	#[doc = " @return bool     true if ok"]
	pub fn subghz_tx_rx_worker_write(instance: *mut SubGhzTxRxWorker, data: *mut u8, size: usize) -> bool;
}
extern "C" {
	#[doc = " SubGhzTxRxWorker, get available data"]
	#[doc = " @param instance   Pointer to a SubGhzTxRxWorker instance"]
	#[doc = " @return size_t    data size"]
	pub fn subghz_tx_rx_worker_available(instance: *mut SubGhzTxRxWorker) -> usize;
}
extern "C" {
	#[doc = " SubGhzTxRxWorker, read data"]
	#[doc = " @param instance   Pointer to a SubGhzTxRxWorker instance"]
	#[doc = " @param data       *data"]
	#[doc = " @param size       max data size, which can be read"]
	#[doc = " @return size_t    data size, how much is actually read"]
	pub fn subghz_tx_rx_worker_read(instance: *mut SubGhzTxRxWorker, data: *mut u8, size: usize) -> usize;
}
extern "C" {
	#[doc = " Сallback SubGhzTxRxWorker when there is data to read in an empty buffer"]
	#[doc = " @param instance Pointer to a SubGhzTxRxWorker instance"]
	#[doc = " @param callback SubGhzTxRxWorkerCallbackHaveRead callback"]
	#[doc = " @param context"]
	pub fn subghz_tx_rx_worker_set_callback_have_read(instance: *mut SubGhzTxRxWorker,
	                                                  callback: SubGhzTxRxWorkerCallbackHaveRead,
	                                                  context: *mut core::ffi::c_void);
}
extern "C" {
	#[doc = " Allocate SubGhzTxRxWorker"]
	#[doc = " @return SubGhzTxRxWorker* Pointer to a SubGhzTxRxWorker instance"]
	pub fn subghz_tx_rx_worker_alloc() -> *mut SubGhzTxRxWorker;
}
extern "C" {
	#[doc = " Free SubGhzTxRxWorker"]
	#[doc = " @param instance Pointer to a SubGhzTxRxWorker instance"]
	pub fn subghz_tx_rx_worker_free(instance: *mut SubGhzTxRxWorker);
}
extern "C" {
	#[doc = " Start SubGhzTxRxWorker"]
	#[doc = " @param instance Pointer to a SubGhzTxRxWorker instance"]
	#[doc = " @return bool - true if ok"]
	pub fn subghz_tx_rx_worker_start(instance: *mut SubGhzTxRxWorker, frequency: u32) -> bool;
}
extern "C" {
	#[doc = " Stop SubGhzTxRxWorker"]
	#[doc = " @param instance Pointer to a SubGhzTxRxWorker instance"]
	pub fn subghz_tx_rx_worker_stop(instance: *mut SubGhzTxRxWorker);
}
extern "C" {
	#[doc = " Check if worker is running"]
	#[doc = " @param instance Pointer to a SubGhzTxRxWorker instance"]
	#[doc = " @return bool - true if running"]
	pub fn subghz_tx_rx_worker_is_running(instance: *mut SubGhzTxRxWorker) -> bool;
}
#[repr(C)]
pub struct SubGhzWorker {
	_unused: [u8; 0],
}
pub type SubGhzWorkerOverrunCallback = ::core::option::Option<unsafe extern "C" fn(context: *mut core::ffi::c_void)>;
pub type SubGhzWorkerPairCallback =
	::core::option::Option<unsafe extern "C" fn(context: *mut core::ffi::c_void, level: bool, duration: u32)>;
extern "C" {
	pub fn subghz_worker_rx_callback(level: bool, duration: u32, context: *mut core::ffi::c_void);
}
extern "C" {
	#[doc = " Allocate SubGhzWorker."]
	#[doc = " @return SubGhzWorker* Pointer to a SubGhzWorker instance"]
	pub fn subghz_worker_alloc() -> *mut SubGhzWorker;
}
extern "C" {
	#[doc = " Free SubGhzWorker."]
	#[doc = " @param instance Pointer to a SubGhzWorker instance"]
	pub fn subghz_worker_free(instance: *mut SubGhzWorker);
}
extern "C" {
	#[doc = " Overrun callback SubGhzWorker."]
	#[doc = " @param instance Pointer to a SubGhzWorker instance"]
	#[doc = " @param callback SubGhzWorkerOverrunCallback callback"]
	pub fn subghz_worker_set_overrun_callback(instance: *mut SubGhzWorker, callback: SubGhzWorkerOverrunCallback);
}
extern "C" {
	#[doc = " Pair callback SubGhzWorker."]
	#[doc = " @param instance Pointer to a SubGhzWorker instance"]
	#[doc = " @param callback SubGhzWorkerOverrunCallback callback"]
	pub fn subghz_worker_set_pair_callback(instance: *mut SubGhzWorker, callback: SubGhzWorkerPairCallback);
}
extern "C" {
	#[doc = " Context callback SubGhzWorker."]
	#[doc = " @param instance Pointer to a SubGhzWorker instance"]
	#[doc = " @param context"]
	pub fn subghz_worker_set_context(instance: *mut SubGhzWorker, context: *mut core::ffi::c_void);
}
extern "C" {
	#[doc = " Start SubGhzWorker."]
	#[doc = " @param instance Pointer to a SubGhzWorker instance"]
	pub fn subghz_worker_start(instance: *mut SubGhzWorker);
}
extern "C" {
	#[doc = " Stop SubGhzWorker"]
	#[doc = " @param instance Pointer to a SubGhzWorker instance"]
	pub fn subghz_worker_stop(instance: *mut SubGhzWorker);
}
extern "C" {
	#[doc = " Check if worker is running."]
	#[doc = " @param instance Pointer to a SubGhzWorker instance"]
	#[doc = " @return bool - true if running"]
	pub fn subghz_worker_is_running(instance: *mut SubGhzWorker) -> bool;
}
#[repr(C)]
pub struct SubGhzTransmitter {
	_unused: [u8; 0],
}
extern "C" {
	#[doc = " Allocate and init SubGhzTransmitter."]
	#[doc = " @param environment Pointer to a SubGhzEnvironment instance"]
	#[doc = " @return SubGhzTransmitter* pointer to a SubGhzTransmitter instance"]
	pub fn subghz_transmitter_alloc_init(environment: *mut SubGhzEnvironment,
	                                     protocol_name: *const core::ffi::c_char)
	                                     -> *mut SubGhzTransmitter;
}
extern "C" {
	#[doc = " Free SubGhzTransmitter."]
	#[doc = " @param instance Pointer to a SubGhzTransmitter instance"]
	pub fn subghz_transmitter_free(instance: *mut SubGhzTransmitter);
}
extern "C" {
	#[doc = " Get protocol instance."]
	#[doc = " @param instance Pointer to a SubGhzTransmitter instance"]
	pub fn subghz_transmitter_get_protocol_instance(instance: *mut SubGhzTransmitter) -> *mut SubGhzProtocolEncoderBase;
}
extern "C" {
	#[doc = " Forced transmission stop."]
	#[doc = " @param instance Pointer to a SubGhzTransmitter instance"]
	pub fn subghz_transmitter_stop(instance: *mut SubGhzTransmitter) -> bool;
}
extern "C" {
	#[doc = " Deserialize and generating an upload to send."]
	#[doc = " @param instance Pointer to a SubGhzTransmitter instance"]
	#[doc = " @param flipper_format Pointer to a FlipperFormat instance"]
	#[doc = " @return true On success"]
	pub fn subghz_transmitter_deserialize(instance: *mut SubGhzTransmitter, flipper_format: *mut FlipperFormat) -> bool;
}
extern "C" {
	#[doc = " Getting the level and duration of the upload to be loaded into DMA."]
	#[doc = " @param context Pointer to a SubGhzTransmitter instance"]
	#[doc = " @return LevelDuration"]
	pub fn subghz_transmitter_yield(context: *mut core::ffi::c_void) -> LevelDuration;
}
extern "C" {
	#[doc = " Extract int value and trim arguments string"]
	#[doc = ""]
	#[doc = " @param args - arguments string"]
	#[doc = " @param word first argument, output"]
	#[doc = " @return true - success"]
	#[doc = " @return false - arguments string does not contain int"]
	pub fn args_read_int_and_trim(args: *mut string_t, value: *mut core::ffi::c_int) -> bool;
}
extern "C" {
	#[doc = " @brief Extract first argument from arguments string and trim arguments string"]
	#[doc = ""]
	#[doc = " @param args arguments string"]
	#[doc = " @param word first argument, output"]
	#[doc = " @return true - success"]
	#[doc = " @return false - arguments string does not contain anything"]
	pub fn args_read_string_and_trim(args: *mut string_t, word: *mut string_t) -> bool;
}
extern "C" {
	#[doc = " @brief Extract the first quoted argument from the argument string and trim the argument string. If the argument is not quoted, calls args_read_string_and_trim."]
	#[doc = ""]
	#[doc = " @param args arguments string"]
	#[doc = " @param word first argument, output, without quotes"]
	#[doc = " @return true - success"]
	#[doc = " @return false - arguments string does not contain anything"]
	pub fn args_read_probably_quoted_string_and_trim(args: *mut string_t, word: *mut string_t) -> bool;
}
extern "C" {
	#[doc = " @brief Convert hex ASCII values to byte array"]
	#[doc = ""]
	#[doc = " @param args arguments string"]
	#[doc = " @param bytes byte array pointer, output"]
	#[doc = " @param bytes_count needed bytes count"]
	#[doc = " @return true - success"]
	#[doc = " @return false - arguments string does not contain enough values, or contain non-hex ASCII values"]
	pub fn args_read_hex_bytes(args: *mut string_t, bytes: *mut u8, bytes_count: usize) -> bool;
}
extern "C" {
	#[doc = " @brief Get length of first word from arguments string"]
	#[doc = ""]
	#[doc = " @param args arguments string"]
	#[doc = " @return size_t length of first word"]
	pub fn args_get_first_word_length(args: *mut string_t) -> usize;
}
extern "C" {
	#[doc = " @brief Get length of arguments string"]
	#[doc = ""]
	#[doc = " @param args arguments string"]
	#[doc = " @return size_t length of arguments string"]
	pub fn args_length(args: *mut string_t) -> usize;
}
extern "C" {
	#[doc = " @brief Convert ASCII hex values to byte"]
	#[doc = ""]
	#[doc = " @param hi_nibble ASCII hi nibble character"]
	#[doc = " @param low_nibble ASCII low nibble character"]
	#[doc = " @param byte byte pointer, output"]
	#[doc = " @return bool conversion status"]
	pub fn args_char_to_hex(hi_nibble: core::ffi::c_char, low_nibble: core::ffi::c_char, byte: *mut u8) -> bool;
}
extern "C" {
	pub fn crc32_calc_buffer(crc: u32, buffer: *const core::ffi::c_void, size: usize) -> u32;
}
pub type FileCrcProgressCb = ::core::option::Option<unsafe extern "C" fn(progress: u8, context: *mut core::ffi::c_void)>;
extern "C" {
	pub fn crc32_calc_file(file: *mut File, progress_cb: FileCrcProgressCb, context: *mut core::ffi::c_void) -> u32;
}
#[repr(C)]
pub struct DirWalk {
	_unused: [u8; 0],
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum DirWalkResult {
	#[doc = "< OK"]
	DirWalkOK = 0,
	#[doc = "< Error"]
	DirWalkError = 1,
	#[doc = "< Last element"]
	DirWalkLast = 2,
}
pub type DirWalkFilterCb = ::core::option::Option<unsafe extern "C" fn(name: *const core::ffi::c_char,
                                                                       fileinfo: *mut FileInfo,
                                                                       ctx: *mut core::ffi::c_void)
                                                                       -> bool>;
extern "C" {
	#[doc = " Allocate DirWalk"]
	#[doc = " @param storage"]
	#[doc = " @return DirWalk*"]
	pub fn dir_walk_alloc(storage: *mut Storage) -> *mut DirWalk;
}
extern "C" {
	#[doc = " Free DirWalk"]
	#[doc = " @param dir_walk"]
	pub fn dir_walk_free(dir_walk: *mut DirWalk);
}
extern "C" {
	#[doc = " Set recursive mode (true by default)"]
	#[doc = " @param dir_walk"]
	#[doc = " @param recursive"]
	pub fn dir_walk_set_recursive(dir_walk: *mut DirWalk, recursive: bool);
}
extern "C" {
	#[doc = " Set filter callback (Should return true if the data is valid)"]
	#[doc = " @param dir_walk"]
	#[doc = " @param cb"]
	#[doc = " @param context"]
	pub fn dir_walk_set_filter_cb(dir_walk: *mut DirWalk, cb: DirWalkFilterCb, context: *mut core::ffi::c_void);
}
extern "C" {
	#[doc = " Open directory"]
	#[doc = " @param dir_walk"]
	#[doc = " @param path"]
	#[doc = " @return true"]
	#[doc = " @return false"]
	pub fn dir_walk_open(dir_walk: *mut DirWalk, path: *const core::ffi::c_char) -> bool;
}
extern "C" {
	#[doc = " Get error id"]
	#[doc = " @param dir_walk"]
	#[doc = " @return FS_Error"]
	pub fn dir_walk_get_error(dir_walk: *mut DirWalk) -> FS_Error;
}
extern "C" {
	#[doc = " Read next element from directory"]
	#[doc = " @param dir_walk"]
	#[doc = " @param return_path"]
	#[doc = " @param fileinfo"]
	#[doc = " @return DirWalkResult"]
	pub fn dir_walk_read(dir_walk: *mut DirWalk, return_path: *mut string_t, fileinfo: *mut FileInfo) -> DirWalkResult;
}
extern "C" {
	#[doc = " Close directory"]
	#[doc = " @param dir_walk"]
	pub fn dir_walk_close(dir_walk: *mut DirWalk);
}
#[repr(C)]
pub struct sha256_context {
	pub total: [u32; 2usize],
	pub state: [u32; 8usize],
	pub wbuf: [u32; 16usize],
}
#[test]
fn bindgen_test_layout_sha256_context() {
	assert_eq!(
	           ::core::mem::size_of::<sha256_context>(),
	           104usize,
	           concat!("Size of: ", stringify!(sha256_context))
	);
	assert_eq!(
	           ::core::mem::align_of::<sha256_context>(),
	           4usize,
	           concat!("Alignment of ", stringify!(sha256_context))
	);
	fn test_field_total() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<sha256_context>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).total) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(sha256_context), "::", stringify!(total))
		);
	}
	test_field_total();
	fn test_field_state() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<sha256_context>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).state) as usize - ptr as usize
		           },
		           8usize,
		           concat!("Offset of field: ", stringify!(sha256_context), "::", stringify!(state))
		);
	}
	test_field_state();
	fn test_field_wbuf() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<sha256_context>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).wbuf) as usize - ptr as usize
		           },
		           40usize,
		           concat!("Offset of field: ", stringify!(sha256_context), "::", stringify!(wbuf))
		);
	}
	test_field_wbuf();
}
extern "C" {
	pub fn sha256(input: *const core::ffi::c_uchar, ilen: core::ffi::c_uint, output: *mut [core::ffi::c_uchar; 32usize]);
}
extern "C" {
	pub fn sha256_start(ctx: *mut sha256_context);
}
extern "C" {
	pub fn sha256_finish(ctx: *mut sha256_context, output: *mut [core::ffi::c_uchar; 32usize]);
}
extern "C" {
	pub fn sha256_update(ctx: *mut sha256_context, input: *const core::ffi::c_uchar, ilen: core::ffi::c_uint);
}
extern "C" {
	pub fn sha256_process(ctx: *mut sha256_context);
}
#[repr(C)]
pub struct hmac_context {
	pub init_hash: ::core::option::Option<unsafe extern "C" fn(context: *const hmac_context)>,
	pub update_hash:
		::core::option::Option<unsafe extern "C" fn(context: *const hmac_context, message: *const u8, message_size: core::ffi::c_uint)>,
	pub finish_hash: ::core::option::Option<unsafe extern "C" fn(context: *const hmac_context, hash_result: *mut u8)>,
	pub block_size: core::ffi::c_uint,
	pub result_size: core::ffi::c_uint,
	pub tmp: *mut u8,
}
#[test]
fn bindgen_test_layout_hmac_context() {
	assert_eq!(
	           ::core::mem::size_of::<hmac_context>(),
	           24usize,
	           concat!("Size of: ", stringify!(hmac_context))
	);
	assert_eq!(
	           ::core::mem::align_of::<hmac_context>(),
	           4usize,
	           concat!("Alignment of ", stringify!(hmac_context))
	);
	fn test_field_init_hash() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<hmac_context>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).init_hash) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(hmac_context), "::", stringify!(init_hash))
		);
	}
	test_field_init_hash();
	fn test_field_update_hash() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<hmac_context>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).update_hash) as usize - ptr as usize
		           },
		           4usize,
		           concat!("Offset of field: ", stringify!(hmac_context), "::", stringify!(update_hash))
		);
	}
	test_field_update_hash();
	fn test_field_finish_hash() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<hmac_context>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).finish_hash) as usize - ptr as usize
		           },
		           8usize,
		           concat!("Offset of field: ", stringify!(hmac_context), "::", stringify!(finish_hash))
		);
	}
	test_field_finish_hash();
	fn test_field_block_size() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<hmac_context>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).block_size) as usize - ptr as usize
		           },
		           12usize,
		           concat!("Offset of field: ", stringify!(hmac_context), "::", stringify!(block_size))
		);
	}
	test_field_block_size();
	fn test_field_result_size() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<hmac_context>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).result_size) as usize - ptr as usize
		           },
		           16usize,
		           concat!("Offset of field: ", stringify!(hmac_context), "::", stringify!(result_size))
		);
	}
	test_field_result_size();
	fn test_field_tmp() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<hmac_context>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).tmp) as usize - ptr as usize
		           },
		           20usize,
		           concat!("Offset of field: ", stringify!(hmac_context), "::", stringify!(tmp))
		);
	}
	test_field_tmp();
}
#[repr(C)]
pub struct hmac_sha256_context {
	pub hmac_ctx: hmac_context,
	pub sha_ctx: sha256_context,
	pub tmp: [u8; 128usize],
}
#[test]
fn bindgen_test_layout_hmac_sha256_context() {
	assert_eq!(
	           ::core::mem::size_of::<hmac_sha256_context>(),
	           256usize,
	           concat!("Size of: ", stringify!(hmac_sha256_context))
	);
	assert_eq!(
	           ::core::mem::align_of::<hmac_sha256_context>(),
	           4usize,
	           concat!("Alignment of ", stringify!(hmac_sha256_context))
	);
	fn test_field_hmac_ctx() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<hmac_sha256_context>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).hmac_ctx) as usize - ptr as usize
		           },
		           0usize,
		           concat!(
			"Offset of field: ",
			stringify!(hmac_sha256_context),
			"::",
			stringify!(hmac_ctx)
		)
		);
	}
	test_field_hmac_ctx();
	fn test_field_sha_ctx() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<hmac_sha256_context>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).sha_ctx) as usize - ptr as usize
		           },
		           24usize,
		           concat!(
			"Offset of field: ",
			stringify!(hmac_sha256_context),
			"::",
			stringify!(sha_ctx)
		)
		);
	}
	test_field_sha_ctx();
	fn test_field_tmp() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<hmac_sha256_context>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).tmp) as usize - ptr as usize
		           },
		           128usize,
		           concat!("Offset of field: ", stringify!(hmac_sha256_context), "::", stringify!(tmp))
		);
	}
	test_field_tmp();
}
extern "C" {
	pub fn hmac_sha256_init(ctx: *mut hmac_sha256_context, K: *const u8);
}
extern "C" {
	pub fn hmac_sha256_update(ctx: *const hmac_sha256_context, message: *const u8, message_size: core::ffi::c_uint);
}
extern "C" {
	pub fn hmac_sha256_finish(ctx: *const hmac_sha256_context, K: *const u8, hash_result: *mut u8);
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum ManchesterEvent {
	ManchesterEventShortLow = 0,
	ManchesterEventShortHigh = 2,
	ManchesterEventLongLow = 4,
	ManchesterEventLongHigh = 6,
	ManchesterEventReset = 8,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum ManchesterState {
	ManchesterStateStart1 = 0,
	ManchesterStateMid1 = 1,
	ManchesterStateMid0 = 2,
	ManchesterStateStart0 = 3,
}
extern "C" {
	pub fn manchester_advance(state: ManchesterState,
	                          event: ManchesterEvent,
	                          next_state: *mut ManchesterState,
	                          data: *mut bool)
	                          -> bool;
}
#[repr(C)]
pub struct ManchesterEncoderState {
	pub prev_bit: bool,
	pub step: u8,
}
#[test]
fn bindgen_test_layout_ManchesterEncoderState() {
	assert_eq!(
	           ::core::mem::size_of::<ManchesterEncoderState>(),
	           2usize,
	           concat!("Size of: ", stringify!(ManchesterEncoderState))
	);
	assert_eq!(
	           ::core::mem::align_of::<ManchesterEncoderState>(),
	           1usize,
	           concat!("Alignment of ", stringify!(ManchesterEncoderState))
	);
	fn test_field_prev_bit() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<ManchesterEncoderState>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).prev_bit) as usize - ptr as usize
		           },
		           0usize,
		           concat!(
			"Offset of field: ",
			stringify!(ManchesterEncoderState),
			"::",
			stringify!(prev_bit)
		)
		);
	}
	test_field_prev_bit();
	fn test_field_step() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<ManchesterEncoderState>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).step) as usize - ptr as usize
		           },
		           1usize,
		           concat!(
			"Offset of field: ",
			stringify!(ManchesterEncoderState),
			"::",
			stringify!(step)
		)
		);
	}
	test_field_step();
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum ManchesterEncoderResult {
	ManchesterEncoderResultShortLow = 0,
	ManchesterEncoderResultLongLow = 1,
	ManchesterEncoderResultLongHigh = 2,
	ManchesterEncoderResultShortHigh = 3,
}
extern "C" {
	pub fn manchester_encoder_reset(state: *mut ManchesterEncoderState);
}
extern "C" {
	pub fn manchester_encoder_advance(state: *mut ManchesterEncoderState,
	                                  curr_bit: bool,
	                                  result: *mut ManchesterEncoderResult)
	                                  -> bool;
}
extern "C" {
	pub fn manchester_encoder_finish(state: *mut ManchesterEncoderState) -> ManchesterEncoderResult;
}
#[doc = " \\brief          MD5 context structure"]
#[repr(C)]
pub struct md5_context {
	#[doc = "< number of bytes processed"]
	pub total: [u32; 2usize],
	#[doc = "< intermediate digest state"]
	pub state: [u32; 4usize],
	#[doc = "< data block being processed"]
	pub buffer: [core::ffi::c_uchar; 64usize],
}
#[test]
fn bindgen_test_layout_md5_context() {
	assert_eq!(
	           ::core::mem::size_of::<md5_context>(),
	           88usize,
	           concat!("Size of: ", stringify!(md5_context))
	);
	assert_eq!(
	           ::core::mem::align_of::<md5_context>(),
	           4usize,
	           concat!("Alignment of ", stringify!(md5_context))
	);
	fn test_field_total() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<md5_context>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).total) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(md5_context), "::", stringify!(total))
		);
	}
	test_field_total();
	fn test_field_state() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<md5_context>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).state) as usize - ptr as usize
		           },
		           8usize,
		           concat!("Offset of field: ", stringify!(md5_context), "::", stringify!(state))
		);
	}
	test_field_state();
	fn test_field_buffer() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<md5_context>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).buffer) as usize - ptr as usize
		           },
		           24usize,
		           concat!("Offset of field: ", stringify!(md5_context), "::", stringify!(buffer))
		);
	}
	test_field_buffer();
}
extern "C" {
	#[doc = " \\brief          MD5 context setup"]
	#[doc = ""]
	#[doc = " \\param ctx      context to be initialized"]
	pub fn md5_starts(ctx: *mut md5_context);
}
extern "C" {
	#[doc = " \\brief          MD5 process buffer"]
	#[doc = ""]
	#[doc = " \\param ctx      MD5 context"]
	#[doc = " \\param input    buffer holding the  data"]
	#[doc = " \\param ilen     length of the input data"]
	pub fn md5_update(ctx: *mut md5_context, input: *const core::ffi::c_uchar, ilen: usize);
}
extern "C" {
	#[doc = " \\brief          MD5 final digest"]
	#[doc = ""]
	#[doc = " \\param ctx      MD5 context"]
	#[doc = " \\param output   MD5 checksum result"]
	pub fn md5_finish(ctx: *mut md5_context, output: *mut [core::ffi::c_uchar; 16usize]);
}
extern "C" {
	pub fn md5_process(ctx: *mut md5_context, data: *const [core::ffi::c_uchar; 64usize]);
}
extern "C" {
	#[doc = " \\brief          Output = MD5( input buffer )"]
	#[doc = ""]
	#[doc = " \\param input    buffer holding the  data"]
	#[doc = " \\param ilen     length of the input data"]
	#[doc = " \\param output   MD5 checksum result"]
	pub fn md5(input: *const core::ffi::c_uchar, ilen: usize, output: *mut [core::ffi::c_uchar; 16usize]);
}
extern "C" {
	#[doc = " @brief Extract filename without extension from path."]
	#[doc = ""]
	#[doc = " @param path path string"]
	#[doc = " @param filename output filename string. Must be initialized before."]
	pub fn path_extract_filename_no_ext(path: *const core::ffi::c_char, filename: *mut string_t);
}
extern "C" {
	#[doc = " @brief Extract filename string from path."]
	#[doc = ""]
	#[doc = " @param path path string"]
	#[doc = " @param filename output filename string. Must be initialized before."]
	#[doc = " @param trim_ext true - get filename without extension"]
	pub fn path_extract_filename(path: *mut string_t, filename: *mut string_t, trim_ext: bool);
}
extern "C" {
	#[doc = " @brief Extract file extension from path."]
	#[doc = ""]
	#[doc = " @param path path string"]
	#[doc = " @param ext output extension string"]
	#[doc = " @param ext_len_max maximum extension string length"]
	pub fn path_extract_extension(path: *mut string_t, ext: *mut core::ffi::c_char, ext_len_max: usize);
}
extern "C" {
	#[doc = " @brief Extract last path component"]
	#[doc = ""]
	#[doc = " @param path path string"]
	#[doc = " @param filename output string. Must be initialized before."]
	pub fn path_extract_basename(path: *const core::ffi::c_char, basename: *mut string_t);
}
extern "C" {
	#[doc = " @brief Extract path, except for last component"]
	#[doc = ""]
	#[doc = " @param path path string"]
	#[doc = " @param filename output string. Must be initialized before."]
	pub fn path_extract_dirname(path: *const core::ffi::c_char, dirname: *mut string_t);
}
extern "C" {
	#[doc = " @brief Appends new component to path, adding path delimiter"]
	#[doc = ""]
	#[doc = " @param path path string"]
	#[doc = " @param suffix path part to apply"]
	pub fn path_append(path: *mut string_t, suffix: *const core::ffi::c_char);
}
extern "C" {
	#[doc = " @brief Appends new component to path, adding path delimiter"]
	#[doc = ""]
	#[doc = " @param path first path part"]
	#[doc = " @param suffix second path part"]
	#[doc = " @param out_path output string to combine parts into. Must be initialized"]
	pub fn path_concat(path: *const core::ffi::c_char, suffix: *const core::ffi::c_char, out_path: *mut string_t);
}
extern "C" {
	#[doc = " @brief Check that path contains only ascii characters"]
	#[doc = ""]
	#[doc = " @param path"]
	#[doc = " @return true"]
	#[doc = " @return false"]
	pub fn path_contains_only_ascii(path: *const core::ffi::c_char) -> bool;
}
extern "C" {
	#[doc = " Generates random name"]
	#[doc = " @param name buffer to write random name"]
	#[doc = " @param max_name_size length of given buffer"]
	pub fn set_random_name(name: *mut core::ffi::c_char, max_name_size: u8);
}
extern "C" {
	pub fn saved_struct_load(path: *const core::ffi::c_char,
	                         data: *mut core::ffi::c_void,
	                         size: usize,
	                         magic: u8,
	                         version: u8)
	                         -> bool;
}
extern "C" {
	pub fn saved_struct_save(path: *const core::ffi::c_char,
	                         data: *mut core::ffi::c_void,
	                         size: usize,
	                         magic: u8,
	                         version: u8)
	                         -> bool;
}
extern "C" {
	#[doc = " Allocate a file stream with buffered read operations"]
	#[doc = " @return Stream*"]
	pub fn buffered_file_stream_alloc(storage: *mut Storage) -> *mut Stream;
}
extern "C" {
	#[doc = " Opens an existing file or creates a new one."]
	#[doc = " @param stream pointer to file stream object."]
	#[doc = " @param path path to file"]
	#[doc = " @param access_mode access mode from FS_AccessMode"]
	#[doc = " @param open_mode open mode from FS_OpenMode"]
	#[doc = " @return True on success, False on failure. You need to close the file even if the open operation failed."]
	pub fn buffered_file_stream_open(stream: *mut Stream,
	                                 path: *const core::ffi::c_char,
	                                 access_mode: FS_AccessMode,
	                                 open_mode: FS_OpenMode)
	                                 -> bool;
}
extern "C" {
	#[doc = " Closes the file."]
	#[doc = " @param stream pointer to file stream object."]
	#[doc = " @return True on success, False on failure."]
	pub fn buffered_file_stream_close(stream: *mut Stream) -> bool;
}
extern "C" {
	#[doc = " Forces write from cache to the underlying file."]
	#[doc = " @param stream pointer to file stream object."]
	#[doc = " @return True on success, False on failure."]
	pub fn buffered_file_stream_sync(stream: *mut Stream) -> bool;
}
extern "C" {
	#[doc = " Retrieves the error id from the file object"]
	#[doc = " @param stream pointer to stream object."]
	#[doc = " @return FS_Error error id"]
	pub fn buffered_file_stream_get_error(stream: *mut Stream) -> FS_Error;
}
extern "C" {
	#[doc = " Allocate file stream"]
	#[doc = " @return Stream*"]
	pub fn file_stream_alloc(storage: *mut Storage) -> *mut Stream;
}
extern "C" {
	#[doc = " Opens an existing file or create a new one."]
	#[doc = " @param stream pointer to file stream object."]
	#[doc = " @param path path to file"]
	#[doc = " @param access_mode access mode from FS_AccessMode"]
	#[doc = " @param open_mode open mode from FS_OpenMode"]
	#[doc = " @return success flag. You need to close the file even if the open operation failed."]
	pub fn file_stream_open(stream: *mut Stream,
	                        path: *const core::ffi::c_char,
	                        access_mode: FS_AccessMode,
	                        open_mode: FS_OpenMode)
	                        -> bool;
}
extern "C" {
	#[doc = " Closes the file."]
	#[doc = " @param stream"]
	#[doc = " @return true"]
	#[doc = " @return false"]
	pub fn file_stream_close(stream: *mut Stream) -> bool;
}
extern "C" {
	#[doc = " Retrieves the error id from the file object"]
	#[doc = " @param stream pointer to stream object."]
	#[doc = " @return FS_Error error id"]
	pub fn file_stream_get_error(stream: *mut Stream) -> FS_Error;
}
extern "C" {
	#[doc = " Allocate string stream"]
	#[doc = " @return Stream*"]
	pub fn string_stream_alloc() -> *mut Stream;
}
#[repr(C)]
pub struct TarArchive {
	_unused: [u8; 0],
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum TarOpenMode {
	TAR_OPEN_MODE_READ = 114,
	TAR_OPEN_MODE_WRITE = 119,
	TAR_OPEN_MODE_STDOUT = 115,
}
extern "C" {
	pub fn tar_archive_alloc(storage: *mut Storage) -> *mut TarArchive;
}
extern "C" {
	pub fn tar_archive_open(archive: *mut TarArchive, path: *const core::ffi::c_char, mode: TarOpenMode) -> bool;
}
extern "C" {
	pub fn tar_archive_free(archive: *mut TarArchive);
}
extern "C" {
	pub fn tar_archive_unpack_to(archive: *mut TarArchive,
	                             destination: *const core::ffi::c_char,
	                             converter: Storage_name_converter)
	                             -> bool;
}
extern "C" {
	pub fn tar_archive_add_file(archive: *mut TarArchive,
	                            fs_file_path: *const core::ffi::c_char,
	                            archive_fname: *const core::ffi::c_char,
	                            file_size: i32)
	                            -> bool;
}
extern "C" {
	pub fn tar_archive_add_dir(archive: *mut TarArchive,
	                           fs_full_path: *const core::ffi::c_char,
	                           path_prefix: *const core::ffi::c_char)
	                           -> bool;
}
extern "C" {
	pub fn tar_archive_get_entries_count(archive: *mut TarArchive) -> i32;
}
extern "C" {
	pub fn tar_archive_unpack_file(archive: *mut TarArchive,
	                               archive_fname: *const core::ffi::c_char,
	                               destination: *const core::ffi::c_char)
	                               -> bool;
}
pub type tar_unpack_file_cb = ::core::option::Option<unsafe extern "C" fn(name: *const core::ffi::c_char,
                                                                          is_directory: bool,
                                                                          context: *mut core::ffi::c_void)
                                                                          -> bool>;
extern "C" {
	pub fn tar_archive_set_file_callback(archive: *mut TarArchive, callback: tar_unpack_file_cb, context: *mut core::ffi::c_void);
}
extern "C" {
	pub fn tar_archive_dir_add_element(archive: *mut TarArchive, dirpath: *const core::ffi::c_char) -> bool;
}
extern "C" {
	pub fn tar_archive_file_add_header(archive: *mut TarArchive, path: *const core::ffi::c_char, data_len: i32) -> bool;
}
extern "C" {
	pub fn tar_archive_file_add_data_block(archive: *mut TarArchive, data_block: *const u8, block_len: i32) -> bool;
}
extern "C" {
	pub fn tar_archive_file_finalize(archive: *mut TarArchive) -> bool;
}
extern "C" {
	pub fn tar_archive_store_data(archive: *mut TarArchive, path: *const core::ffi::c_char, data: *const u8, data_len: i32) -> bool;
}
extern "C" {
	pub fn tar_archive_finalize(archive: *mut TarArchive) -> bool;
}
