/* automatically generated by rust-bindgen 0.60.1 */

/*  Flipper Zero SDK git tag: 0.68.1, revision: 5c52bb76217679db33b8cb6bff4273df11785388, API version: __1.13__. */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage> {
	storage: Storage,
}
impl<Storage> __BindgenBitfieldUnit<Storage> {
	#[inline]
	pub const fn new(storage: Storage) -> Self { Self { storage } }
}
impl<Storage> __BindgenBitfieldUnit<Storage> where Storage: AsRef<[u8]> + AsMut<[u8]> {
	#[inline]
	pub fn get_bit(&self, index: usize) -> bool {
		debug_assert!(index / 8 < self.storage.as_ref().len());
		let byte_index = index / 8;
		let byte = self.storage.as_ref()[byte_index];
		let bit_index = if cfg!(target_endian = "big") {
			7 - (index % 8)
		} else {
			index % 8
		};
		let mask = 1 << bit_index;
		byte & mask == mask
	}
	#[inline]
	pub fn set_bit(&mut self, index: usize, val: bool) {
		debug_assert!(index / 8 < self.storage.as_ref().len());
		let byte_index = index / 8;
		let byte = &mut self.storage.as_mut()[byte_index];
		let bit_index = if cfg!(target_endian = "big") {
			7 - (index % 8)
		} else {
			index % 8
		};
		let mask = 1 << bit_index;
		if val {
			*byte |= mask;
		} else {
			*byte &= !mask;
		}
	}
	#[inline]
	pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
		debug_assert!(bit_width <= 64);
		debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
		debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
		let mut val = 0;
		for i in 0..(bit_width as usize) {
			if self.get_bit(i + bit_offset) {
				let index = if cfg!(target_endian = "big") {
					bit_width as usize - 1 - i
				} else {
					i
				};
				val |= 1 << index;
			}
		}
		val
	}
	#[inline]
	pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
		debug_assert!(bit_width <= 64);
		debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
		debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
		for i in 0..(bit_width as usize) {
			let mask = 1 << i;
			let val_bit_is_set = val & mask == mask;
			let index = if cfg!(target_endian = "big") {
				bit_width as usize - 1 - i
			} else {
				i
			};
			self.set_bit(index + bit_offset, val_bit_is_set);
		}
	}
}
#[repr(C)]
#[derive(Default)]
pub struct __IncompleteArrayField<T>(::core::marker::PhantomData<T>, [T; 0]);
impl<T> __IncompleteArrayField<T> {
	#[inline]
	pub const fn new() -> Self { __IncompleteArrayField(::core::marker::PhantomData, []) }
	#[inline]
	pub fn as_ptr(&self) -> *const T { self as *const _ as *const T }
	#[inline]
	pub fn as_mut_ptr(&mut self) -> *mut T { self as *mut _ as *mut T }
	#[inline]
	pub unsafe fn as_slice(&self, len: usize) -> &[T] { ::core::slice::from_raw_parts(self.as_ptr(), len) }
	#[inline]
	pub unsafe fn as_mut_slice(&mut self, len: usize) -> &mut [T] { ::core::slice::from_raw_parts_mut(self.as_mut_ptr(), len) }
}
impl<T> ::core::fmt::Debug for __IncompleteArrayField<T> {
	fn fmt(&self, fmt: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result { fmt.write_str("__IncompleteArrayField") }
}
#[repr(C)]
pub struct __BindgenUnionField<T>(::core::marker::PhantomData<T>);
impl<T> __BindgenUnionField<T> {
	#[inline]
	pub const fn new() -> Self { __BindgenUnionField(::core::marker::PhantomData) }
	#[inline]
	pub unsafe fn as_ref(&self) -> &T { ::core::mem::transmute(self) }
	#[inline]
	pub unsafe fn as_mut(&mut self) -> &mut T { ::core::mem::transmute(self) }
}
impl<T> ::core::default::Default for __BindgenUnionField<T> {
	#[inline]
	fn default() -> Self { Self::new() }
}
impl<T> ::core::clone::Clone for __BindgenUnionField<T> {
	#[inline]
	fn clone(&self) -> Self { Self::new() }
}
impl<T> ::core::marker::Copy for __BindgenUnionField<T> {}
impl<T> ::core::fmt::Debug for __BindgenUnionField<T> {
	fn fmt(&self, fmt: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result { fmt.write_str("__BindgenUnionField") }
}
impl<T> ::core::hash::Hash for __BindgenUnionField<T> {
	fn hash<H: ::core::hash::Hasher>(&self, _state: &mut H) {}
}
impl<T> ::core::cmp::PartialEq for __BindgenUnionField<T> {
	fn eq(&self, _other: &__BindgenUnionField<T>) -> bool { true }
}
impl<T> ::core::cmp::Eq for __BindgenUnionField<T> {}
pub const RECORD_GUI: &[u8; 4usize] = b"gui\0";
pub const STORAGE_INT_PATH_PREFIX: &[u8; 5usize] = b"/int\0";
pub const STORAGE_EXT_PATH_PREFIX: &[u8; 5usize] = b"/ext\0";
pub const STORAGE_ANY_PATH_PREFIX: &[u8; 5usize] = b"/any\0";
pub const RECORD_STORAGE: &[u8; 8usize] = b"storage\0";
pub const FURI_HAL_FLASH_OB_RAW_SIZE_BYTES: u32 = 128;
pub type __int8_t = core::ffi::c_schar;
pub type __uint8_t = core::ffi::c_uchar;
pub type __int16_t = core::ffi::c_short;
pub type __uint16_t = core::ffi::c_ushort;
pub type __int32_t = core::ffi::c_int;
pub type __uint32_t = core::ffi::c_uint;
pub type __uint64_t = core::ffi::c_ulonglong;
pub type __int_least64_t = core::ffi::c_longlong;
#[repr(C)]
pub struct Bt {
	_unused: [u8; 0],
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum BtStatus {
	BtStatusUnavailable = 0,
	BtStatusOff = 1,
	BtStatusAdvertising = 2,
	BtStatusConnected = 3,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum BtProfile {
	BtProfileSerial = 0,
	BtProfileHidKeyboard = 1,
}
pub type BtStatusChangedCallback = ::core::option::Option<unsafe extern "C" fn(status: BtStatus, context: *mut core::ffi::c_void)>;
extern "C" {
	#[doc = " Change BLE Profile"]
	#[doc = " @note Call of this function leads to 2nd core restart"]
	#[doc = ""]
	#[doc = " @param bt        Bt instance"]
	#[doc = " @param profile   BtProfile"]
	#[doc = ""]
	#[doc = " @return          true on success"]
	pub fn bt_set_profile(bt: *mut Bt, profile: BtProfile) -> bool;
}
extern "C" {
	#[doc = " Disconnect from Central"]
	#[doc = ""]
	#[doc = " @param bt        Bt instance"]
	pub fn bt_disconnect(bt: *mut Bt);
}
extern "C" {
	#[doc = " Set callback for Bluetooth status change notification"]
	#[doc = ""]
	#[doc = " @param bt        Bt instance"]
	#[doc = " @param callback  BtStatusChangedCallback instance"]
	#[doc = " @param context   pointer to context"]
	pub fn bt_set_status_changed_callback(bt: *mut Bt, callback: BtStatusChangedCallback, context: *mut core::ffi::c_void);
}
extern "C" {
	#[doc = " Forget bonded devices"]
	#[doc = " @note Leads to wipe ble key storage and deleting bt.keys"]
	#[doc = ""]
	#[doc = " @param bt        Bt instance"]
	pub fn bt_forget_bonded_devices(bt: *mut Bt);
}
pub type wchar_t = core::ffi::c_uint;
pub type wint_t = core::ffi::c_int;
pub type _off_t = core::ffi::c_long;
pub type __off_t = _off_t;
pub type _fpos_t = core::ffi::c_long;
pub type _ssize_t = core::ffi::c_int;
#[repr(C)]
pub struct _mbstate_t {
	pub __count: core::ffi::c_int,
	pub __value: _mbstate_t__bindgen_ty_1,
}
#[repr(C)]
pub struct _mbstate_t__bindgen_ty_1 {
	pub __wch: __BindgenUnionField<wint_t>,
	pub __wchb: __BindgenUnionField<[core::ffi::c_uchar; 4usize]>,
	pub bindgen_union_field: u32,
}
#[test]
fn bindgen_test_layout__mbstate_t__bindgen_ty_1() {
	assert_eq!(
	           ::core::mem::size_of::<_mbstate_t__bindgen_ty_1>(),
	           4usize,
	           concat!("Size of: ", stringify!(_mbstate_t__bindgen_ty_1))
	);
	assert_eq!(
	           ::core::mem::align_of::<_mbstate_t__bindgen_ty_1>(),
	           4usize,
	           concat!("Alignment of ", stringify!(_mbstate_t__bindgen_ty_1))
	);
	fn test_field___wch() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<_mbstate_t__bindgen_ty_1>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).__wch) as usize - ptr as usize
		           },
		           0usize,
		           concat!(
			"Offset of field: ",
			stringify!(_mbstate_t__bindgen_ty_1),
			"::",
			stringify!(__wch)
		)
		);
	}
	test_field___wch();
	fn test_field___wchb() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<_mbstate_t__bindgen_ty_1>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).__wchb) as usize - ptr as usize
		           },
		           0usize,
		           concat!(
			"Offset of field: ",
			stringify!(_mbstate_t__bindgen_ty_1),
			"::",
			stringify!(__wchb)
		)
		);
	}
	test_field___wchb();
}
#[test]
fn bindgen_test_layout__mbstate_t() {
	assert_eq!(
	           ::core::mem::size_of::<_mbstate_t>(),
	           8usize,
	           concat!("Size of: ", stringify!(_mbstate_t))
	);
	assert_eq!(
	           ::core::mem::align_of::<_mbstate_t>(),
	           4usize,
	           concat!("Alignment of ", stringify!(_mbstate_t))
	);
	fn test_field___count() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<_mbstate_t>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).__count) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(_mbstate_t), "::", stringify!(__count))
		);
	}
	test_field___count();
	fn test_field___value() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<_mbstate_t>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).__value) as usize - ptr as usize
		           },
		           4usize,
		           concat!("Offset of field: ", stringify!(_mbstate_t), "::", stringify!(__value))
		);
	}
	test_field___value();
}
pub type __suseconds_t = core::ffi::c_long;
pub type __ULong = core::ffi::c_ulong;
#[repr(C)]
pub struct __lock {
	_unused: [u8; 0],
}
pub type _LOCK_T = *mut __lock;
extern "C" {
	pub fn __retarget_lock_init(lock: *mut _LOCK_T);
}
extern "C" {
	pub fn __retarget_lock_init_recursive(lock: *mut _LOCK_T);
}
extern "C" {
	pub fn __retarget_lock_close(lock: _LOCK_T);
}
extern "C" {
	pub fn __retarget_lock_close_recursive(lock: _LOCK_T);
}
extern "C" {
	pub fn __retarget_lock_acquire(lock: _LOCK_T);
}
extern "C" {
	pub fn __retarget_lock_acquire_recursive(lock: _LOCK_T);
}
extern "C" {
	pub fn __retarget_lock_try_acquire(lock: _LOCK_T) -> core::ffi::c_int;
}
extern "C" {
	pub fn __retarget_lock_try_acquire_recursive(lock: _LOCK_T) -> core::ffi::c_int;
}
extern "C" {
	pub fn __retarget_lock_release(lock: _LOCK_T);
}
extern "C" {
	pub fn __retarget_lock_release_recursive(lock: _LOCK_T);
}
pub type _flock_t = _LOCK_T;
#[repr(C)]
pub struct __locale_t {
	_unused: [u8; 0],
}
#[repr(C)]
pub struct _Bigint {
	pub _next: *mut _Bigint,
	pub _k: core::ffi::c_int,
	pub _maxwds: core::ffi::c_int,
	pub _sign: core::ffi::c_int,
	pub _wds: core::ffi::c_int,
	pub _x: [__ULong; 1usize],
}
#[test]
fn bindgen_test_layout__Bigint() {
	assert_eq!(
	           ::core::mem::size_of::<_Bigint>(),
	           24usize,
	           concat!("Size of: ", stringify!(_Bigint))
	);
	assert_eq!(
	           ::core::mem::align_of::<_Bigint>(),
	           4usize,
	           concat!("Alignment of ", stringify!(_Bigint))
	);
	fn test_field__next() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<_Bigint>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr)._next) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(_Bigint), "::", stringify!(_next))
		);
	}
	test_field__next();
	fn test_field__k() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<_Bigint>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr)._k) as usize - ptr as usize
		           },
		           4usize,
		           concat!("Offset of field: ", stringify!(_Bigint), "::", stringify!(_k))
		);
	}
	test_field__k();
	fn test_field__maxwds() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<_Bigint>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr)._maxwds) as usize - ptr as usize
		           },
		           8usize,
		           concat!("Offset of field: ", stringify!(_Bigint), "::", stringify!(_maxwds))
		);
	}
	test_field__maxwds();
	fn test_field__sign() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<_Bigint>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr)._sign) as usize - ptr as usize
		           },
		           12usize,
		           concat!("Offset of field: ", stringify!(_Bigint), "::", stringify!(_sign))
		);
	}
	test_field__sign();
	fn test_field__wds() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<_Bigint>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr)._wds) as usize - ptr as usize
		           },
		           16usize,
		           concat!("Offset of field: ", stringify!(_Bigint), "::", stringify!(_wds))
		);
	}
	test_field__wds();
	fn test_field__x() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<_Bigint>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr)._x) as usize - ptr as usize
		           },
		           20usize,
		           concat!("Offset of field: ", stringify!(_Bigint), "::", stringify!(_x))
		);
	}
	test_field__x();
}
#[repr(C)]
pub struct __tm {
	pub __tm_sec: core::ffi::c_int,
	pub __tm_min: core::ffi::c_int,
	pub __tm_hour: core::ffi::c_int,
	pub __tm_mday: core::ffi::c_int,
	pub __tm_mon: core::ffi::c_int,
	pub __tm_year: core::ffi::c_int,
	pub __tm_wday: core::ffi::c_int,
	pub __tm_yday: core::ffi::c_int,
	pub __tm_isdst: core::ffi::c_int,
}
#[test]
fn bindgen_test_layout___tm() {
	assert_eq!(
	           ::core::mem::size_of::<__tm>(),
	           36usize,
	           concat!("Size of: ", stringify!(__tm))
	);
	assert_eq!(
	           ::core::mem::align_of::<__tm>(),
	           4usize,
	           concat!("Alignment of ", stringify!(__tm))
	);
	fn test_field___tm_sec() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<__tm>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).__tm_sec) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(__tm), "::", stringify!(__tm_sec))
		);
	}
	test_field___tm_sec();
	fn test_field___tm_min() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<__tm>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).__tm_min) as usize - ptr as usize
		           },
		           4usize,
		           concat!("Offset of field: ", stringify!(__tm), "::", stringify!(__tm_min))
		);
	}
	test_field___tm_min();
	fn test_field___tm_hour() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<__tm>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).__tm_hour) as usize - ptr as usize
		           },
		           8usize,
		           concat!("Offset of field: ", stringify!(__tm), "::", stringify!(__tm_hour))
		);
	}
	test_field___tm_hour();
	fn test_field___tm_mday() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<__tm>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).__tm_mday) as usize - ptr as usize
		           },
		           12usize,
		           concat!("Offset of field: ", stringify!(__tm), "::", stringify!(__tm_mday))
		);
	}
	test_field___tm_mday();
	fn test_field___tm_mon() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<__tm>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).__tm_mon) as usize - ptr as usize
		           },
		           16usize,
		           concat!("Offset of field: ", stringify!(__tm), "::", stringify!(__tm_mon))
		);
	}
	test_field___tm_mon();
	fn test_field___tm_year() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<__tm>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).__tm_year) as usize - ptr as usize
		           },
		           20usize,
		           concat!("Offset of field: ", stringify!(__tm), "::", stringify!(__tm_year))
		);
	}
	test_field___tm_year();
	fn test_field___tm_wday() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<__tm>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).__tm_wday) as usize - ptr as usize
		           },
		           24usize,
		           concat!("Offset of field: ", stringify!(__tm), "::", stringify!(__tm_wday))
		);
	}
	test_field___tm_wday();
	fn test_field___tm_yday() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<__tm>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).__tm_yday) as usize - ptr as usize
		           },
		           28usize,
		           concat!("Offset of field: ", stringify!(__tm), "::", stringify!(__tm_yday))
		);
	}
	test_field___tm_yday();
	fn test_field___tm_isdst() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<__tm>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).__tm_isdst) as usize - ptr as usize
		           },
		           32usize,
		           concat!("Offset of field: ", stringify!(__tm), "::", stringify!(__tm_isdst))
		);
	}
	test_field___tm_isdst();
}
#[repr(C)]
pub struct _on_exit_args {
	pub _fnargs: [*mut core::ffi::c_void; 32usize],
	pub _dso_handle: [*mut core::ffi::c_void; 32usize],
	pub _fntypes: __ULong,
	pub _is_cxa: __ULong,
}
#[test]
fn bindgen_test_layout__on_exit_args() {
	assert_eq!(
	           ::core::mem::size_of::<_on_exit_args>(),
	           264usize,
	           concat!("Size of: ", stringify!(_on_exit_args))
	);
	assert_eq!(
	           ::core::mem::align_of::<_on_exit_args>(),
	           4usize,
	           concat!("Alignment of ", stringify!(_on_exit_args))
	);
	fn test_field__fnargs() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<_on_exit_args>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr)._fnargs) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(_on_exit_args), "::", stringify!(_fnargs))
		);
	}
	test_field__fnargs();
	fn test_field__dso_handle() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<_on_exit_args>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr)._dso_handle) as usize - ptr as usize
		           },
		           128usize,
		           concat!("Offset of field: ", stringify!(_on_exit_args), "::", stringify!(_dso_handle))
		);
	}
	test_field__dso_handle();
	fn test_field__fntypes() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<_on_exit_args>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr)._fntypes) as usize - ptr as usize
		           },
		           256usize,
		           concat!("Offset of field: ", stringify!(_on_exit_args), "::", stringify!(_fntypes))
		);
	}
	test_field__fntypes();
	fn test_field__is_cxa() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<_on_exit_args>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr)._is_cxa) as usize - ptr as usize
		           },
		           260usize,
		           concat!("Offset of field: ", stringify!(_on_exit_args), "::", stringify!(_is_cxa))
		);
	}
	test_field__is_cxa();
}
#[repr(C)]
pub struct _atexit {
	pub _next: *mut _atexit,
	pub _ind: core::ffi::c_int,
	pub _fns: [::core::option::Option<unsafe extern "C" fn()>; 32usize],
	pub _on_exit_args: _on_exit_args,
}
#[test]
fn bindgen_test_layout__atexit() {
	assert_eq!(
	           ::core::mem::size_of::<_atexit>(),
	           400usize,
	           concat!("Size of: ", stringify!(_atexit))
	);
	assert_eq!(
	           ::core::mem::align_of::<_atexit>(),
	           4usize,
	           concat!("Alignment of ", stringify!(_atexit))
	);
	fn test_field__next() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<_atexit>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr)._next) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(_atexit), "::", stringify!(_next))
		);
	}
	test_field__next();
	fn test_field__ind() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<_atexit>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr)._ind) as usize - ptr as usize
		           },
		           4usize,
		           concat!("Offset of field: ", stringify!(_atexit), "::", stringify!(_ind))
		);
	}
	test_field__ind();
	fn test_field__fns() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<_atexit>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr)._fns) as usize - ptr as usize
		           },
		           8usize,
		           concat!("Offset of field: ", stringify!(_atexit), "::", stringify!(_fns))
		);
	}
	test_field__fns();
	fn test_field__on_exit_args() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<_atexit>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr)._on_exit_args) as usize - ptr as usize
		           },
		           136usize,
		           concat!("Offset of field: ", stringify!(_atexit), "::", stringify!(_on_exit_args))
		);
	}
	test_field__on_exit_args();
}
#[repr(C)]
pub struct __sbuf {
	pub _base: *mut core::ffi::c_uchar,
	pub _size: core::ffi::c_int,
}
#[test]
fn bindgen_test_layout___sbuf() {
	assert_eq!(
	           ::core::mem::size_of::<__sbuf>(),
	           8usize,
	           concat!("Size of: ", stringify!(__sbuf))
	);
	assert_eq!(
	           ::core::mem::align_of::<__sbuf>(),
	           4usize,
	           concat!("Alignment of ", stringify!(__sbuf))
	);
	fn test_field__base() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<__sbuf>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr)._base) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(__sbuf), "::", stringify!(_base))
		);
	}
	test_field__base();
	fn test_field__size() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<__sbuf>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr)._size) as usize - ptr as usize
		           },
		           4usize,
		           concat!("Offset of field: ", stringify!(__sbuf), "::", stringify!(_size))
		);
	}
	test_field__size();
}
#[repr(C)]
pub struct __sFILE {
	pub _p: *mut core::ffi::c_uchar,
	pub _r: core::ffi::c_int,
	pub _w: core::ffi::c_int,
	pub _flags: core::ffi::c_short,
	pub _file: core::ffi::c_short,
	pub _bf: __sbuf,
	pub _lbfsize: core::ffi::c_int,
	pub _cookie: *mut core::ffi::c_void,
	pub _read: ::core::option::Option<unsafe extern "C" fn(arg1: *mut _reent,
	                                                       arg2: *mut core::ffi::c_void,
	                                                       arg3: *mut core::ffi::c_char,
	                                                       arg4: core::ffi::c_int)
	                                                       -> core::ffi::c_int>,
	pub _write: ::core::option::Option<unsafe extern "C" fn(arg1: *mut _reent,
	                                                        arg2: *mut core::ffi::c_void,
	                                                        arg3: *const core::ffi::c_char,
	                                                        arg4: core::ffi::c_int)
	                                                        -> core::ffi::c_int>,
	pub _seek: ::core::option::Option<unsafe extern "C" fn(arg1: *mut _reent,
	                                                       arg2: *mut core::ffi::c_void,
	                                                       arg3: _fpos_t,
	                                                       arg4: core::ffi::c_int)
	                                                       -> _fpos_t>,
	pub _close: ::core::option::Option<unsafe extern "C" fn(arg1: *mut _reent, arg2: *mut core::ffi::c_void) -> core::ffi::c_int>,
	pub _ub: __sbuf,
	pub _up: *mut core::ffi::c_uchar,
	pub _ur: core::ffi::c_int,
	pub _ubuf: [core::ffi::c_uchar; 3usize],
	pub _nbuf: [core::ffi::c_uchar; 1usize],
	pub _lb: __sbuf,
	pub _blksize: core::ffi::c_int,
	pub _offset: _off_t,
	pub _data: *mut _reent,
	pub _lock: _flock_t,
	pub _mbstate: _mbstate_t,
	pub _flags2: core::ffi::c_int,
}
#[test]
fn bindgen_test_layout___sFILE() {
	assert_eq!(
	           ::core::mem::size_of::<__sFILE>(),
	           104usize,
	           concat!("Size of: ", stringify!(__sFILE))
	);
	assert_eq!(
	           ::core::mem::align_of::<__sFILE>(),
	           4usize,
	           concat!("Alignment of ", stringify!(__sFILE))
	);
	fn test_field__p() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<__sFILE>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr)._p) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(__sFILE), "::", stringify!(_p))
		);
	}
	test_field__p();
	fn test_field__r() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<__sFILE>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr)._r) as usize - ptr as usize
		           },
		           4usize,
		           concat!("Offset of field: ", stringify!(__sFILE), "::", stringify!(_r))
		);
	}
	test_field__r();
	fn test_field__w() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<__sFILE>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr)._w) as usize - ptr as usize
		           },
		           8usize,
		           concat!("Offset of field: ", stringify!(__sFILE), "::", stringify!(_w))
		);
	}
	test_field__w();
	fn test_field__flags() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<__sFILE>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr)._flags) as usize - ptr as usize
		           },
		           12usize,
		           concat!("Offset of field: ", stringify!(__sFILE), "::", stringify!(_flags))
		);
	}
	test_field__flags();
	fn test_field__file() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<__sFILE>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr)._file) as usize - ptr as usize
		           },
		           14usize,
		           concat!("Offset of field: ", stringify!(__sFILE), "::", stringify!(_file))
		);
	}
	test_field__file();
	fn test_field__bf() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<__sFILE>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr)._bf) as usize - ptr as usize
		           },
		           16usize,
		           concat!("Offset of field: ", stringify!(__sFILE), "::", stringify!(_bf))
		);
	}
	test_field__bf();
	fn test_field__lbfsize() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<__sFILE>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr)._lbfsize) as usize - ptr as usize
		           },
		           24usize,
		           concat!("Offset of field: ", stringify!(__sFILE), "::", stringify!(_lbfsize))
		);
	}
	test_field__lbfsize();
	fn test_field__cookie() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<__sFILE>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr)._cookie) as usize - ptr as usize
		           },
		           28usize,
		           concat!("Offset of field: ", stringify!(__sFILE), "::", stringify!(_cookie))
		);
	}
	test_field__cookie();
	fn test_field__read() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<__sFILE>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr)._read) as usize - ptr as usize
		           },
		           32usize,
		           concat!("Offset of field: ", stringify!(__sFILE), "::", stringify!(_read))
		);
	}
	test_field__read();
	fn test_field__write() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<__sFILE>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr)._write) as usize - ptr as usize
		           },
		           36usize,
		           concat!("Offset of field: ", stringify!(__sFILE), "::", stringify!(_write))
		);
	}
	test_field__write();
	fn test_field__seek() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<__sFILE>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr)._seek) as usize - ptr as usize
		           },
		           40usize,
		           concat!("Offset of field: ", stringify!(__sFILE), "::", stringify!(_seek))
		);
	}
	test_field__seek();
	fn test_field__close() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<__sFILE>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr)._close) as usize - ptr as usize
		           },
		           44usize,
		           concat!("Offset of field: ", stringify!(__sFILE), "::", stringify!(_close))
		);
	}
	test_field__close();
	fn test_field__ub() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<__sFILE>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr)._ub) as usize - ptr as usize
		           },
		           48usize,
		           concat!("Offset of field: ", stringify!(__sFILE), "::", stringify!(_ub))
		);
	}
	test_field__ub();
	fn test_field__up() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<__sFILE>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr)._up) as usize - ptr as usize
		           },
		           56usize,
		           concat!("Offset of field: ", stringify!(__sFILE), "::", stringify!(_up))
		);
	}
	test_field__up();
	fn test_field__ur() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<__sFILE>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr)._ur) as usize - ptr as usize
		           },
		           60usize,
		           concat!("Offset of field: ", stringify!(__sFILE), "::", stringify!(_ur))
		);
	}
	test_field__ur();
	fn test_field__ubuf() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<__sFILE>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr)._ubuf) as usize - ptr as usize
		           },
		           64usize,
		           concat!("Offset of field: ", stringify!(__sFILE), "::", stringify!(_ubuf))
		);
	}
	test_field__ubuf();
	fn test_field__nbuf() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<__sFILE>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr)._nbuf) as usize - ptr as usize
		           },
		           67usize,
		           concat!("Offset of field: ", stringify!(__sFILE), "::", stringify!(_nbuf))
		);
	}
	test_field__nbuf();
	fn test_field__lb() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<__sFILE>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr)._lb) as usize - ptr as usize
		           },
		           68usize,
		           concat!("Offset of field: ", stringify!(__sFILE), "::", stringify!(_lb))
		);
	}
	test_field__lb();
	fn test_field__blksize() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<__sFILE>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr)._blksize) as usize - ptr as usize
		           },
		           76usize,
		           concat!("Offset of field: ", stringify!(__sFILE), "::", stringify!(_blksize))
		);
	}
	test_field__blksize();
	fn test_field__offset() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<__sFILE>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr)._offset) as usize - ptr as usize
		           },
		           80usize,
		           concat!("Offset of field: ", stringify!(__sFILE), "::", stringify!(_offset))
		);
	}
	test_field__offset();
	fn test_field__data() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<__sFILE>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr)._data) as usize - ptr as usize
		           },
		           84usize,
		           concat!("Offset of field: ", stringify!(__sFILE), "::", stringify!(_data))
		);
	}
	test_field__data();
	fn test_field__lock() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<__sFILE>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr)._lock) as usize - ptr as usize
		           },
		           88usize,
		           concat!("Offset of field: ", stringify!(__sFILE), "::", stringify!(_lock))
		);
	}
	test_field__lock();
	fn test_field__mbstate() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<__sFILE>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr)._mbstate) as usize - ptr as usize
		           },
		           92usize,
		           concat!("Offset of field: ", stringify!(__sFILE), "::", stringify!(_mbstate))
		);
	}
	test_field__mbstate();
	fn test_field__flags2() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<__sFILE>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr)._flags2) as usize - ptr as usize
		           },
		           100usize,
		           concat!("Offset of field: ", stringify!(__sFILE), "::", stringify!(_flags2))
		);
	}
	test_field__flags2();
}
pub type __FILE = __sFILE;
#[repr(C)]
pub struct _glue {
	pub _next: *mut _glue,
	pub _niobs: core::ffi::c_int,
	pub _iobs: *mut __FILE,
}
#[test]
fn bindgen_test_layout__glue() {
	assert_eq!(
	           ::core::mem::size_of::<_glue>(),
	           12usize,
	           concat!("Size of: ", stringify!(_glue))
	);
	assert_eq!(
	           ::core::mem::align_of::<_glue>(),
	           4usize,
	           concat!("Alignment of ", stringify!(_glue))
	);
	fn test_field__next() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<_glue>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr)._next) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(_glue), "::", stringify!(_next))
		);
	}
	test_field__next();
	fn test_field__niobs() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<_glue>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr)._niobs) as usize - ptr as usize
		           },
		           4usize,
		           concat!("Offset of field: ", stringify!(_glue), "::", stringify!(_niobs))
		);
	}
	test_field__niobs();
	fn test_field__iobs() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<_glue>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr)._iobs) as usize - ptr as usize
		           },
		           8usize,
		           concat!("Offset of field: ", stringify!(_glue), "::", stringify!(_iobs))
		);
	}
	test_field__iobs();
}
#[repr(C)]
pub struct _rand48 {
	pub _seed: [core::ffi::c_ushort; 3usize],
	pub _mult: [core::ffi::c_ushort; 3usize],
	pub _add: core::ffi::c_ushort,
}
#[test]
fn bindgen_test_layout__rand48() {
	assert_eq!(
	           ::core::mem::size_of::<_rand48>(),
	           14usize,
	           concat!("Size of: ", stringify!(_rand48))
	);
	assert_eq!(
	           ::core::mem::align_of::<_rand48>(),
	           2usize,
	           concat!("Alignment of ", stringify!(_rand48))
	);
	fn test_field__seed() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<_rand48>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr)._seed) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(_rand48), "::", stringify!(_seed))
		);
	}
	test_field__seed();
	fn test_field__mult() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<_rand48>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr)._mult) as usize - ptr as usize
		           },
		           6usize,
		           concat!("Offset of field: ", stringify!(_rand48), "::", stringify!(_mult))
		);
	}
	test_field__mult();
	fn test_field__add() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<_rand48>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr)._add) as usize - ptr as usize
		           },
		           12usize,
		           concat!("Offset of field: ", stringify!(_rand48), "::", stringify!(_add))
		);
	}
	test_field__add();
}
#[repr(C)]
pub struct _reent {
	pub _errno: core::ffi::c_int,
	pub _stdin: *mut __FILE,
	pub _stdout: *mut __FILE,
	pub _stderr: *mut __FILE,
	pub _inc: core::ffi::c_int,
	pub _emergency: [core::ffi::c_char; 25usize],
	pub _unspecified_locale_info: core::ffi::c_int,
	pub _locale: *mut __locale_t,
	pub __sdidinit: core::ffi::c_int,
	pub __cleanup: ::core::option::Option<unsafe extern "C" fn(arg1: *mut _reent)>,
	pub _result: *mut _Bigint,
	pub _result_k: core::ffi::c_int,
	pub _p5s: *mut _Bigint,
	pub _freelist: *mut *mut _Bigint,
	pub _cvtlen: core::ffi::c_int,
	pub _cvtbuf: *mut core::ffi::c_char,
	pub _new: _reent__bindgen_ty_1,
	pub _atexit: *mut _atexit,
	pub _atexit0: _atexit,
	pub _sig_func: *mut ::core::option::Option<unsafe extern "C" fn(arg1: core::ffi::c_int)>,
	pub __sglue: _glue,
	pub __sf: [__FILE; 3usize],
}
#[repr(C)]
pub struct _reent__bindgen_ty_1 {
	pub _reent: __BindgenUnionField<_reent__bindgen_ty_1__bindgen_ty_1>,
	pub _unused: __BindgenUnionField<_reent__bindgen_ty_1__bindgen_ty_2>,
	pub bindgen_union_field: [u64; 30usize],
}
#[repr(C)]
pub struct _reent__bindgen_ty_1__bindgen_ty_1 {
	pub _unused_rand: core::ffi::c_uint,
	pub _strtok_last: *mut core::ffi::c_char,
	pub _asctime_buf: [core::ffi::c_char; 26usize],
	pub _localtime_buf: __tm,
	pub _gamma_signgam: core::ffi::c_int,
	pub _rand_next: core::ffi::c_ulonglong,
	pub _r48: _rand48,
	pub _mblen_state: _mbstate_t,
	pub _mbtowc_state: _mbstate_t,
	pub _wctomb_state: _mbstate_t,
	pub _l64a_buf: [core::ffi::c_char; 8usize],
	pub _signal_buf: [core::ffi::c_char; 24usize],
	pub _getdate_err: core::ffi::c_int,
	pub _mbrlen_state: _mbstate_t,
	pub _mbrtowc_state: _mbstate_t,
	pub _mbsrtowcs_state: _mbstate_t,
	pub _wcrtomb_state: _mbstate_t,
	pub _wcsrtombs_state: _mbstate_t,
	pub _h_errno: core::ffi::c_int,
}
#[test]
fn bindgen_test_layout__reent__bindgen_ty_1__bindgen_ty_1() {
	assert_eq!(
	           ::core::mem::size_of::<_reent__bindgen_ty_1__bindgen_ty_1>(),
	           208usize,
	           concat!("Size of: ", stringify!(_reent__bindgen_ty_1__bindgen_ty_1))
	);
	assert_eq!(
	           ::core::mem::align_of::<_reent__bindgen_ty_1__bindgen_ty_1>(),
	           8usize,
	           concat!("Alignment of ", stringify!(_reent__bindgen_ty_1__bindgen_ty_1))
	);
	fn test_field__unused_rand() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<_reent__bindgen_ty_1__bindgen_ty_1>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr)._unused_rand) as usize - ptr as usize
		           },
		           0usize,
		           concat!(
			"Offset of field: ",
			stringify!(_reent__bindgen_ty_1__bindgen_ty_1),
			"::",
			stringify!(_unused_rand)
		)
		);
	}
	test_field__unused_rand();
	fn test_field__strtok_last() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<_reent__bindgen_ty_1__bindgen_ty_1>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr)._strtok_last) as usize - ptr as usize
		           },
		           4usize,
		           concat!(
			"Offset of field: ",
			stringify!(_reent__bindgen_ty_1__bindgen_ty_1),
			"::",
			stringify!(_strtok_last)
		)
		);
	}
	test_field__strtok_last();
	fn test_field__asctime_buf() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<_reent__bindgen_ty_1__bindgen_ty_1>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr)._asctime_buf) as usize - ptr as usize
		           },
		           8usize,
		           concat!(
			"Offset of field: ",
			stringify!(_reent__bindgen_ty_1__bindgen_ty_1),
			"::",
			stringify!(_asctime_buf)
		)
		);
	}
	test_field__asctime_buf();
	fn test_field__localtime_buf() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<_reent__bindgen_ty_1__bindgen_ty_1>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr)._localtime_buf) as usize - ptr as usize
		           },
		           36usize,
		           concat!(
			"Offset of field: ",
			stringify!(_reent__bindgen_ty_1__bindgen_ty_1),
			"::",
			stringify!(_localtime_buf)
		)
		);
	}
	test_field__localtime_buf();
	fn test_field__gamma_signgam() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<_reent__bindgen_ty_1__bindgen_ty_1>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr)._gamma_signgam) as usize - ptr as usize
		           },
		           72usize,
		           concat!(
			"Offset of field: ",
			stringify!(_reent__bindgen_ty_1__bindgen_ty_1),
			"::",
			stringify!(_gamma_signgam)
		)
		);
	}
	test_field__gamma_signgam();
	fn test_field__rand_next() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<_reent__bindgen_ty_1__bindgen_ty_1>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr)._rand_next) as usize - ptr as usize
		           },
		           80usize,
		           concat!(
			"Offset of field: ",
			stringify!(_reent__bindgen_ty_1__bindgen_ty_1),
			"::",
			stringify!(_rand_next)
		)
		);
	}
	test_field__rand_next();
	fn test_field__r48() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<_reent__bindgen_ty_1__bindgen_ty_1>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr)._r48) as usize - ptr as usize
		           },
		           88usize,
		           concat!(
			"Offset of field: ",
			stringify!(_reent__bindgen_ty_1__bindgen_ty_1),
			"::",
			stringify!(_r48)
		)
		);
	}
	test_field__r48();
	fn test_field__mblen_state() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<_reent__bindgen_ty_1__bindgen_ty_1>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr)._mblen_state) as usize - ptr as usize
		           },
		           104usize,
		           concat!(
			"Offset of field: ",
			stringify!(_reent__bindgen_ty_1__bindgen_ty_1),
			"::",
			stringify!(_mblen_state)
		)
		);
	}
	test_field__mblen_state();
	fn test_field__mbtowc_state() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<_reent__bindgen_ty_1__bindgen_ty_1>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr)._mbtowc_state) as usize - ptr as usize
		           },
		           112usize,
		           concat!(
			"Offset of field: ",
			stringify!(_reent__bindgen_ty_1__bindgen_ty_1),
			"::",
			stringify!(_mbtowc_state)
		)
		);
	}
	test_field__mbtowc_state();
	fn test_field__wctomb_state() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<_reent__bindgen_ty_1__bindgen_ty_1>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr)._wctomb_state) as usize - ptr as usize
		           },
		           120usize,
		           concat!(
			"Offset of field: ",
			stringify!(_reent__bindgen_ty_1__bindgen_ty_1),
			"::",
			stringify!(_wctomb_state)
		)
		);
	}
	test_field__wctomb_state();
	fn test_field__l64a_buf() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<_reent__bindgen_ty_1__bindgen_ty_1>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr)._l64a_buf) as usize - ptr as usize
		           },
		           128usize,
		           concat!(
			"Offset of field: ",
			stringify!(_reent__bindgen_ty_1__bindgen_ty_1),
			"::",
			stringify!(_l64a_buf)
		)
		);
	}
	test_field__l64a_buf();
	fn test_field__signal_buf() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<_reent__bindgen_ty_1__bindgen_ty_1>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr)._signal_buf) as usize - ptr as usize
		           },
		           136usize,
		           concat!(
			"Offset of field: ",
			stringify!(_reent__bindgen_ty_1__bindgen_ty_1),
			"::",
			stringify!(_signal_buf)
		)
		);
	}
	test_field__signal_buf();
	fn test_field__getdate_err() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<_reent__bindgen_ty_1__bindgen_ty_1>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr)._getdate_err) as usize - ptr as usize
		           },
		           160usize,
		           concat!(
			"Offset of field: ",
			stringify!(_reent__bindgen_ty_1__bindgen_ty_1),
			"::",
			stringify!(_getdate_err)
		)
		);
	}
	test_field__getdate_err();
	fn test_field__mbrlen_state() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<_reent__bindgen_ty_1__bindgen_ty_1>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr)._mbrlen_state) as usize - ptr as usize
		           },
		           164usize,
		           concat!(
			"Offset of field: ",
			stringify!(_reent__bindgen_ty_1__bindgen_ty_1),
			"::",
			stringify!(_mbrlen_state)
		)
		);
	}
	test_field__mbrlen_state();
	fn test_field__mbrtowc_state() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<_reent__bindgen_ty_1__bindgen_ty_1>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr)._mbrtowc_state) as usize - ptr as usize
		           },
		           172usize,
		           concat!(
			"Offset of field: ",
			stringify!(_reent__bindgen_ty_1__bindgen_ty_1),
			"::",
			stringify!(_mbrtowc_state)
		)
		);
	}
	test_field__mbrtowc_state();
	fn test_field__mbsrtowcs_state() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<_reent__bindgen_ty_1__bindgen_ty_1>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr)._mbsrtowcs_state) as usize - ptr as usize
		           },
		           180usize,
		           concat!(
			"Offset of field: ",
			stringify!(_reent__bindgen_ty_1__bindgen_ty_1),
			"::",
			stringify!(_mbsrtowcs_state)
		)
		);
	}
	test_field__mbsrtowcs_state();
	fn test_field__wcrtomb_state() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<_reent__bindgen_ty_1__bindgen_ty_1>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr)._wcrtomb_state) as usize - ptr as usize
		           },
		           188usize,
		           concat!(
			"Offset of field: ",
			stringify!(_reent__bindgen_ty_1__bindgen_ty_1),
			"::",
			stringify!(_wcrtomb_state)
		)
		);
	}
	test_field__wcrtomb_state();
	fn test_field__wcsrtombs_state() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<_reent__bindgen_ty_1__bindgen_ty_1>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr)._wcsrtombs_state) as usize - ptr as usize
		           },
		           196usize,
		           concat!(
			"Offset of field: ",
			stringify!(_reent__bindgen_ty_1__bindgen_ty_1),
			"::",
			stringify!(_wcsrtombs_state)
		)
		);
	}
	test_field__wcsrtombs_state();
	fn test_field__h_errno() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<_reent__bindgen_ty_1__bindgen_ty_1>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr)._h_errno) as usize - ptr as usize
		           },
		           204usize,
		           concat!(
			"Offset of field: ",
			stringify!(_reent__bindgen_ty_1__bindgen_ty_1),
			"::",
			stringify!(_h_errno)
		)
		);
	}
	test_field__h_errno();
}
#[repr(C)]
pub struct _reent__bindgen_ty_1__bindgen_ty_2 {
	pub _nextf: [*mut core::ffi::c_uchar; 30usize],
	pub _nmalloc: [core::ffi::c_uint; 30usize],
}
#[test]
fn bindgen_test_layout__reent__bindgen_ty_1__bindgen_ty_2() {
	assert_eq!(
	           ::core::mem::size_of::<_reent__bindgen_ty_1__bindgen_ty_2>(),
	           240usize,
	           concat!("Size of: ", stringify!(_reent__bindgen_ty_1__bindgen_ty_2))
	);
	assert_eq!(
	           ::core::mem::align_of::<_reent__bindgen_ty_1__bindgen_ty_2>(),
	           4usize,
	           concat!("Alignment of ", stringify!(_reent__bindgen_ty_1__bindgen_ty_2))
	);
	fn test_field__nextf() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<_reent__bindgen_ty_1__bindgen_ty_2>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr)._nextf) as usize - ptr as usize
		           },
		           0usize,
		           concat!(
			"Offset of field: ",
			stringify!(_reent__bindgen_ty_1__bindgen_ty_2),
			"::",
			stringify!(_nextf)
		)
		);
	}
	test_field__nextf();
	fn test_field__nmalloc() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<_reent__bindgen_ty_1__bindgen_ty_2>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr)._nmalloc) as usize - ptr as usize
		           },
		           120usize,
		           concat!(
			"Offset of field: ",
			stringify!(_reent__bindgen_ty_1__bindgen_ty_2),
			"::",
			stringify!(_nmalloc)
		)
		);
	}
	test_field__nmalloc();
}
#[test]
fn bindgen_test_layout__reent__bindgen_ty_1() {
	assert_eq!(
	           ::core::mem::size_of::<_reent__bindgen_ty_1>(),
	           240usize,
	           concat!("Size of: ", stringify!(_reent__bindgen_ty_1))
	);
	assert_eq!(
	           ::core::mem::align_of::<_reent__bindgen_ty_1>(),
	           8usize,
	           concat!("Alignment of ", stringify!(_reent__bindgen_ty_1))
	);
	fn test_field__reent() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<_reent__bindgen_ty_1>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr)._reent) as usize - ptr as usize
		           },
		           0usize,
		           concat!(
			"Offset of field: ",
			stringify!(_reent__bindgen_ty_1),
			"::",
			stringify!(_reent)
		)
		);
	}
	test_field__reent();
	fn test_field__unused() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<_reent__bindgen_ty_1>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr)._unused) as usize - ptr as usize
		           },
		           0usize,
		           concat!(
			"Offset of field: ",
			stringify!(_reent__bindgen_ty_1),
			"::",
			stringify!(_unused)
		)
		);
	}
	test_field__unused();
}
#[test]
fn bindgen_test_layout__reent() {
	assert_eq!(
	           ::core::mem::size_of::<_reent>(),
	           1064usize,
	           concat!("Size of: ", stringify!(_reent))
	);
	assert_eq!(
	           ::core::mem::align_of::<_reent>(),
	           8usize,
	           concat!("Alignment of ", stringify!(_reent))
	);
	fn test_field__errno() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<_reent>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr)._errno) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(_reent), "::", stringify!(_errno))
		);
	}
	test_field__errno();
	fn test_field__stdin() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<_reent>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr)._stdin) as usize - ptr as usize
		           },
		           4usize,
		           concat!("Offset of field: ", stringify!(_reent), "::", stringify!(_stdin))
		);
	}
	test_field__stdin();
	fn test_field__stdout() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<_reent>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr)._stdout) as usize - ptr as usize
		           },
		           8usize,
		           concat!("Offset of field: ", stringify!(_reent), "::", stringify!(_stdout))
		);
	}
	test_field__stdout();
	fn test_field__stderr() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<_reent>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr)._stderr) as usize - ptr as usize
		           },
		           12usize,
		           concat!("Offset of field: ", stringify!(_reent), "::", stringify!(_stderr))
		);
	}
	test_field__stderr();
	fn test_field__inc() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<_reent>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr)._inc) as usize - ptr as usize
		           },
		           16usize,
		           concat!("Offset of field: ", stringify!(_reent), "::", stringify!(_inc))
		);
	}
	test_field__inc();
	fn test_field__emergency() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<_reent>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr)._emergency) as usize - ptr as usize
		           },
		           20usize,
		           concat!("Offset of field: ", stringify!(_reent), "::", stringify!(_emergency))
		);
	}
	test_field__emergency();
	fn test_field__unspecified_locale_info() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<_reent>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr)._unspecified_locale_info) as usize - ptr as usize
		           },
		           48usize,
		           concat!(
			"Offset of field: ",
			stringify!(_reent),
			"::",
			stringify!(_unspecified_locale_info)
		)
		);
	}
	test_field__unspecified_locale_info();
	fn test_field__locale() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<_reent>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr)._locale) as usize - ptr as usize
		           },
		           52usize,
		           concat!("Offset of field: ", stringify!(_reent), "::", stringify!(_locale))
		);
	}
	test_field__locale();
	fn test_field___sdidinit() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<_reent>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).__sdidinit) as usize - ptr as usize
		           },
		           56usize,
		           concat!("Offset of field: ", stringify!(_reent), "::", stringify!(__sdidinit))
		);
	}
	test_field___sdidinit();
	fn test_field___cleanup() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<_reent>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).__cleanup) as usize - ptr as usize
		           },
		           60usize,
		           concat!("Offset of field: ", stringify!(_reent), "::", stringify!(__cleanup))
		);
	}
	test_field___cleanup();
	fn test_field__result() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<_reent>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr)._result) as usize - ptr as usize
		           },
		           64usize,
		           concat!("Offset of field: ", stringify!(_reent), "::", stringify!(_result))
		);
	}
	test_field__result();
	fn test_field__result_k() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<_reent>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr)._result_k) as usize - ptr as usize
		           },
		           68usize,
		           concat!("Offset of field: ", stringify!(_reent), "::", stringify!(_result_k))
		);
	}
	test_field__result_k();
	fn test_field__p5s() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<_reent>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr)._p5s) as usize - ptr as usize
		           },
		           72usize,
		           concat!("Offset of field: ", stringify!(_reent), "::", stringify!(_p5s))
		);
	}
	test_field__p5s();
	fn test_field__freelist() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<_reent>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr)._freelist) as usize - ptr as usize
		           },
		           76usize,
		           concat!("Offset of field: ", stringify!(_reent), "::", stringify!(_freelist))
		);
	}
	test_field__freelist();
	fn test_field__cvtlen() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<_reent>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr)._cvtlen) as usize - ptr as usize
		           },
		           80usize,
		           concat!("Offset of field: ", stringify!(_reent), "::", stringify!(_cvtlen))
		);
	}
	test_field__cvtlen();
	fn test_field__cvtbuf() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<_reent>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr)._cvtbuf) as usize - ptr as usize
		           },
		           84usize,
		           concat!("Offset of field: ", stringify!(_reent), "::", stringify!(_cvtbuf))
		);
	}
	test_field__cvtbuf();
	fn test_field__new() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<_reent>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr)._new) as usize - ptr as usize
		           },
		           88usize,
		           concat!("Offset of field: ", stringify!(_reent), "::", stringify!(_new))
		);
	}
	test_field__new();
	fn test_field__atexit() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<_reent>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr)._atexit) as usize - ptr as usize
		           },
		           328usize,
		           concat!("Offset of field: ", stringify!(_reent), "::", stringify!(_atexit))
		);
	}
	test_field__atexit();
	fn test_field__atexit0() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<_reent>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr)._atexit0) as usize - ptr as usize
		           },
		           332usize,
		           concat!("Offset of field: ", stringify!(_reent), "::", stringify!(_atexit0))
		);
	}
	test_field__atexit0();
	fn test_field__sig_func() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<_reent>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr)._sig_func) as usize - ptr as usize
		           },
		           732usize,
		           concat!("Offset of field: ", stringify!(_reent), "::", stringify!(_sig_func))
		);
	}
	test_field__sig_func();
	fn test_field___sglue() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<_reent>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).__sglue) as usize - ptr as usize
		           },
		           736usize,
		           concat!("Offset of field: ", stringify!(_reent), "::", stringify!(__sglue))
		);
	}
	test_field___sglue();
	fn test_field___sf() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<_reent>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).__sf) as usize - ptr as usize
		           },
		           748usize,
		           concat!("Offset of field: ", stringify!(_reent), "::", stringify!(__sf))
		);
	}
	test_field___sf();
}
extern "C" {
	pub static mut _impure_ptr: *mut _reent;
}
extern "C" {
	pub static _global_impure_ptr: *mut _reent;
}
extern "C" {
	pub fn _reclaim_reent(arg1: *mut _reent);
}
pub type locale_t = *mut __locale_t;
extern "C" {
	pub fn bcmp(arg1: *const core::ffi::c_void, arg2: *const core::ffi::c_void, arg3: core::ffi::c_uint) -> core::ffi::c_int;
}
extern "C" {
	pub fn bcopy(arg1: *const core::ffi::c_void, arg2: *mut core::ffi::c_void, arg3: usize);
}
extern "C" {
	pub fn bzero(arg1: *mut core::ffi::c_void, arg2: core::ffi::c_uint);
}
extern "C" {
	pub fn explicit_bzero(arg1: *mut core::ffi::c_void, arg2: usize);
}
extern "C" {
	pub fn ffs(arg1: core::ffi::c_int) -> core::ffi::c_int;
}
extern "C" {
	pub fn ffsl(arg1: core::ffi::c_long) -> core::ffi::c_int;
}
extern "C" {
	pub fn ffsll(arg1: core::ffi::c_longlong) -> core::ffi::c_int;
}
extern "C" {
	pub fn fls(arg1: core::ffi::c_int) -> core::ffi::c_int;
}
extern "C" {
	pub fn flsl(arg1: core::ffi::c_long) -> core::ffi::c_int;
}
extern "C" {
	pub fn flsll(arg1: core::ffi::c_longlong) -> core::ffi::c_int;
}
extern "C" {
	pub fn index(arg1: *const core::ffi::c_char, arg2: core::ffi::c_int) -> *mut core::ffi::c_char;
}
extern "C" {
	pub fn rindex(arg1: *const core::ffi::c_char, arg2: core::ffi::c_int) -> *mut core::ffi::c_char;
}
extern "C" {
	pub fn strcasecmp(arg1: *const core::ffi::c_char, arg2: *const core::ffi::c_char) -> core::ffi::c_int;
}
extern "C" {
	pub fn strncasecmp(arg1: *const core::ffi::c_char, arg2: *const core::ffi::c_char, arg3: core::ffi::c_uint) -> core::ffi::c_int;
}
extern "C" {
	pub fn strcasecmp_l(arg1: *const core::ffi::c_char, arg2: *const core::ffi::c_char, arg3: locale_t) -> core::ffi::c_int;
}
extern "C" {
	pub fn strncasecmp_l(arg1: *const core::ffi::c_char,
	                     arg2: *const core::ffi::c_char,
	                     arg3: usize,
	                     arg4: locale_t)
	                     -> core::ffi::c_int;
}
extern "C" {
	pub fn memchr(arg1: *const core::ffi::c_void, arg2: core::ffi::c_int, arg3: core::ffi::c_uint) -> *mut core::ffi::c_void;
}
extern "C" {
	pub fn memcmp(arg1: *const core::ffi::c_void, arg2: *const core::ffi::c_void, arg3: core::ffi::c_uint) -> core::ffi::c_int;
}
extern "C" {
	pub fn memcpy(arg1: *mut core::ffi::c_void, arg2: *const core::ffi::c_void, arg3: core::ffi::c_uint) -> *mut core::ffi::c_void;
}
extern "C" {
	pub fn memmove(arg1: *mut core::ffi::c_void, arg2: *const core::ffi::c_void, arg3: core::ffi::c_uint) -> *mut core::ffi::c_void;
}
extern "C" {
	pub fn memset(arg1: *mut core::ffi::c_void, arg2: core::ffi::c_int, arg3: core::ffi::c_uint) -> *mut core::ffi::c_void;
}
extern "C" {
	pub fn strcat(arg1: *mut core::ffi::c_char, arg2: *const core::ffi::c_char) -> *mut core::ffi::c_char;
}
extern "C" {
	pub fn strchr(arg1: *const core::ffi::c_char, arg2: core::ffi::c_int) -> *mut core::ffi::c_char;
}
extern "C" {
	pub fn strcmp(arg1: *const core::ffi::c_char, arg2: *const core::ffi::c_char) -> core::ffi::c_int;
}
extern "C" {
	pub fn strcoll(arg1: *const core::ffi::c_char, arg2: *const core::ffi::c_char) -> core::ffi::c_int;
}
extern "C" {
	pub fn strcpy(arg1: *mut core::ffi::c_char, arg2: *const core::ffi::c_char) -> *mut core::ffi::c_char;
}
extern "C" {
	pub fn strcspn(arg1: *const core::ffi::c_char, arg2: *const core::ffi::c_char) -> core::ffi::c_uint;
}
extern "C" {
	pub fn strerror(arg1: core::ffi::c_int) -> *mut core::ffi::c_char;
}
extern "C" {
	pub fn strlen(arg1: *const core::ffi::c_char) -> core::ffi::c_uint;
}
extern "C" {
	pub fn strncat(arg1: *mut core::ffi::c_char, arg2: *const core::ffi::c_char, arg3: core::ffi::c_uint) -> *mut core::ffi::c_char;
}
extern "C" {
	pub fn strncmp(arg1: *const core::ffi::c_char, arg2: *const core::ffi::c_char, arg3: core::ffi::c_uint) -> core::ffi::c_int;
}
extern "C" {
	pub fn strncpy(arg1: *mut core::ffi::c_char, arg2: *const core::ffi::c_char, arg3: core::ffi::c_uint) -> *mut core::ffi::c_char;
}
extern "C" {
	pub fn strpbrk(arg1: *const core::ffi::c_char, arg2: *const core::ffi::c_char) -> *mut core::ffi::c_char;
}
extern "C" {
	pub fn strrchr(arg1: *const core::ffi::c_char, arg2: core::ffi::c_int) -> *mut core::ffi::c_char;
}
extern "C" {
	pub fn strspn(arg1: *const core::ffi::c_char, arg2: *const core::ffi::c_char) -> core::ffi::c_uint;
}
extern "C" {
	pub fn strstr(arg1: *const core::ffi::c_char, arg2: *const core::ffi::c_char) -> *mut core::ffi::c_char;
}
extern "C" {
	pub fn strtok(arg1: *mut core::ffi::c_char, arg2: *const core::ffi::c_char) -> *mut core::ffi::c_char;
}
extern "C" {
	pub fn strxfrm(arg1: *mut core::ffi::c_char, arg2: *const core::ffi::c_char, arg3: core::ffi::c_uint) -> core::ffi::c_uint;
}
extern "C" {
	pub fn strcoll_l(arg1: *const core::ffi::c_char, arg2: *const core::ffi::c_char, arg3: locale_t) -> core::ffi::c_int;
}
extern "C" {
	pub fn strerror_l(arg1: core::ffi::c_int, arg2: locale_t) -> *mut core::ffi::c_char;
}
extern "C" {
	pub fn strxfrm_l(arg1: *mut core::ffi::c_char, arg2: *const core::ffi::c_char, arg3: usize, arg4: locale_t) -> usize;
}
extern "C" {
	pub fn strtok_r(arg1: *mut core::ffi::c_char,
	                arg2: *const core::ffi::c_char,
	                arg3: *mut *mut core::ffi::c_char)
	                -> *mut core::ffi::c_char;
}
extern "C" {
	pub fn timingsafe_bcmp(arg1: *const core::ffi::c_void, arg2: *const core::ffi::c_void, arg3: usize) -> core::ffi::c_int;
}
extern "C" {
	pub fn timingsafe_memcmp(arg1: *const core::ffi::c_void, arg2: *const core::ffi::c_void, arg3: usize) -> core::ffi::c_int;
}
extern "C" {
	pub fn memccpy(arg1: *mut core::ffi::c_void,
	               arg2: *const core::ffi::c_void,
	               arg3: core::ffi::c_int,
	               arg4: core::ffi::c_uint)
	               -> *mut core::ffi::c_void;
}
extern "C" {
	pub fn stpcpy(arg1: *mut core::ffi::c_char, arg2: *const core::ffi::c_char) -> *mut core::ffi::c_char;
}
extern "C" {
	pub fn stpncpy(arg1: *mut core::ffi::c_char, arg2: *const core::ffi::c_char, arg3: core::ffi::c_uint) -> *mut core::ffi::c_char;
}
extern "C" {
	#[must_use]
	pub fn strdup(arg1: *const core::ffi::c_char) -> *mut core::ffi::c_char;
}
extern "C" {
	pub fn _strdup_r(arg1: *mut _reent, arg2: *const core::ffi::c_char) -> *mut core::ffi::c_char;
}
extern "C" {
	#[must_use]
	pub fn strndup(arg1: *const core::ffi::c_char, arg2: core::ffi::c_uint) -> *mut core::ffi::c_char;
}
extern "C" {
	pub fn _strndup_r(arg1: *mut _reent, arg2: *const core::ffi::c_char, arg3: usize) -> *mut core::ffi::c_char;
}
extern "C" {
	#[link_name = "\u{1}__xpg_strerror_r"]
	pub fn strerror_r(arg1: core::ffi::c_int, arg2: *mut core::ffi::c_char, arg3: usize) -> core::ffi::c_int;
}
extern "C" {
	pub fn _strerror_r(arg1: *mut _reent,
	                   arg2: core::ffi::c_int,
	                   arg3: core::ffi::c_int,
	                   arg4: *mut core::ffi::c_int)
	                   -> *mut core::ffi::c_char;
}
extern "C" {
	pub fn strlcat(arg1: *mut core::ffi::c_char, arg2: *const core::ffi::c_char, arg3: core::ffi::c_uint) -> core::ffi::c_uint;
}
extern "C" {
	pub fn strlcpy(arg1: *mut core::ffi::c_char, arg2: *const core::ffi::c_char, arg3: core::ffi::c_uint) -> core::ffi::c_uint;
}
extern "C" {
	pub fn strnlen(arg1: *const core::ffi::c_char, arg2: usize) -> usize;
}
extern "C" {
	pub fn strsep(arg1: *mut *mut core::ffi::c_char, arg2: *const core::ffi::c_char) -> *mut core::ffi::c_char;
}
extern "C" {
	pub fn strnstr(arg1: *const core::ffi::c_char, arg2: *const core::ffi::c_char, arg3: usize) -> *mut core::ffi::c_char;
}
extern "C" {
	pub fn strlwr(arg1: *mut core::ffi::c_char) -> *mut core::ffi::c_char;
}
extern "C" {
	pub fn strupr(arg1: *mut core::ffi::c_char) -> *mut core::ffi::c_char;
}
extern "C" {
	pub fn strsignal(__signo: core::ffi::c_int) -> *mut core::ffi::c_char;
}
extern "C" {
	pub fn isalnum(__c: core::ffi::c_int) -> core::ffi::c_int;
}
extern "C" {
	pub fn isalpha(__c: core::ffi::c_int) -> core::ffi::c_int;
}
extern "C" {
	pub fn iscntrl(__c: core::ffi::c_int) -> core::ffi::c_int;
}
extern "C" {
	pub fn isdigit(__c: core::ffi::c_int) -> core::ffi::c_int;
}
extern "C" {
	pub fn isgraph(__c: core::ffi::c_int) -> core::ffi::c_int;
}
extern "C" {
	pub fn islower(__c: core::ffi::c_int) -> core::ffi::c_int;
}
extern "C" {
	pub fn isprint(__c: core::ffi::c_int) -> core::ffi::c_int;
}
extern "C" {
	pub fn ispunct(__c: core::ffi::c_int) -> core::ffi::c_int;
}
extern "C" {
	pub fn isspace(__c: core::ffi::c_int) -> core::ffi::c_int;
}
extern "C" {
	pub fn isupper(__c: core::ffi::c_int) -> core::ffi::c_int;
}
extern "C" {
	pub fn isxdigit(__c: core::ffi::c_int) -> core::ffi::c_int;
}
extern "C" {
	pub fn tolower(__c: core::ffi::c_int) -> core::ffi::c_int;
}
extern "C" {
	pub fn toupper(__c: core::ffi::c_int) -> core::ffi::c_int;
}
extern "C" {
	pub fn isblank(__c: core::ffi::c_int) -> core::ffi::c_int;
}
extern "C" {
	pub fn isascii(__c: core::ffi::c_int) -> core::ffi::c_int;
}
extern "C" {
	pub fn toascii(__c: core::ffi::c_int) -> core::ffi::c_int;
}
extern "C" {
	pub fn isalnum_l(__c: core::ffi::c_int, __l: locale_t) -> core::ffi::c_int;
}
extern "C" {
	pub fn isalpha_l(__c: core::ffi::c_int, __l: locale_t) -> core::ffi::c_int;
}
extern "C" {
	pub fn isblank_l(__c: core::ffi::c_int, __l: locale_t) -> core::ffi::c_int;
}
extern "C" {
	pub fn iscntrl_l(__c: core::ffi::c_int, __l: locale_t) -> core::ffi::c_int;
}
extern "C" {
	pub fn isdigit_l(__c: core::ffi::c_int, __l: locale_t) -> core::ffi::c_int;
}
extern "C" {
	pub fn isgraph_l(__c: core::ffi::c_int, __l: locale_t) -> core::ffi::c_int;
}
extern "C" {
	pub fn islower_l(__c: core::ffi::c_int, __l: locale_t) -> core::ffi::c_int;
}
extern "C" {
	pub fn isprint_l(__c: core::ffi::c_int, __l: locale_t) -> core::ffi::c_int;
}
extern "C" {
	pub fn ispunct_l(__c: core::ffi::c_int, __l: locale_t) -> core::ffi::c_int;
}
extern "C" {
	pub fn isspace_l(__c: core::ffi::c_int, __l: locale_t) -> core::ffi::c_int;
}
extern "C" {
	pub fn isupper_l(__c: core::ffi::c_int, __l: locale_t) -> core::ffi::c_int;
}
extern "C" {
	pub fn isxdigit_l(__c: core::ffi::c_int, __l: locale_t) -> core::ffi::c_int;
}
extern "C" {
	pub fn tolower_l(__c: core::ffi::c_int, __l: locale_t) -> core::ffi::c_int;
}
extern "C" {
	pub fn toupper_l(__c: core::ffi::c_int, __l: locale_t) -> core::ffi::c_int;
}
extern "C" {
	pub fn isascii_l(__c: core::ffi::c_int, __l: locale_t) -> core::ffi::c_int;
}
extern "C" {
	pub fn toascii_l(__c: core::ffi::c_int, __l: locale_t) -> core::ffi::c_int;
}
extern "C" {
	pub static mut _ctype_: [core::ffi::c_char; 0usize];
}
#[repr(C)]
pub struct div_t {
	pub quot: core::ffi::c_int,
	pub rem: core::ffi::c_int,
}
#[test]
fn bindgen_test_layout_div_t() {
	assert_eq!(
	           ::core::mem::size_of::<div_t>(),
	           8usize,
	           concat!("Size of: ", stringify!(div_t))
	);
	assert_eq!(
	           ::core::mem::align_of::<div_t>(),
	           4usize,
	           concat!("Alignment of ", stringify!(div_t))
	);
	fn test_field_quot() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<div_t>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).quot) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(div_t), "::", stringify!(quot))
		);
	}
	test_field_quot();
	fn test_field_rem() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<div_t>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).rem) as usize - ptr as usize
		           },
		           4usize,
		           concat!("Offset of field: ", stringify!(div_t), "::", stringify!(rem))
		);
	}
	test_field_rem();
}
#[repr(C)]
pub struct ldiv_t {
	pub quot: core::ffi::c_long,
	pub rem: core::ffi::c_long,
}
#[test]
fn bindgen_test_layout_ldiv_t() {
	assert_eq!(
	           ::core::mem::size_of::<ldiv_t>(),
	           8usize,
	           concat!("Size of: ", stringify!(ldiv_t))
	);
	assert_eq!(
	           ::core::mem::align_of::<ldiv_t>(),
	           4usize,
	           concat!("Alignment of ", stringify!(ldiv_t))
	);
	fn test_field_quot() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<ldiv_t>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).quot) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(ldiv_t), "::", stringify!(quot))
		);
	}
	test_field_quot();
	fn test_field_rem() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<ldiv_t>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).rem) as usize - ptr as usize
		           },
		           4usize,
		           concat!("Offset of field: ", stringify!(ldiv_t), "::", stringify!(rem))
		);
	}
	test_field_rem();
}
#[repr(C)]
pub struct lldiv_t {
	pub quot: core::ffi::c_longlong,
	pub rem: core::ffi::c_longlong,
}
#[test]
fn bindgen_test_layout_lldiv_t() {
	assert_eq!(
	           ::core::mem::size_of::<lldiv_t>(),
	           16usize,
	           concat!("Size of: ", stringify!(lldiv_t))
	);
	assert_eq!(
	           ::core::mem::align_of::<lldiv_t>(),
	           8usize,
	           concat!("Alignment of ", stringify!(lldiv_t))
	);
	fn test_field_quot() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<lldiv_t>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).quot) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(lldiv_t), "::", stringify!(quot))
		);
	}
	test_field_quot();
	fn test_field_rem() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<lldiv_t>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).rem) as usize - ptr as usize
		           },
		           8usize,
		           concat!("Offset of field: ", stringify!(lldiv_t), "::", stringify!(rem))
		);
	}
	test_field_rem();
}
pub type __compar_fn_t =
	::core::option::Option<unsafe extern "C" fn(arg1: *const core::ffi::c_void, arg2: *const core::ffi::c_void) -> core::ffi::c_int>;
extern "C" {
	pub fn __locale_mb_cur_max() -> core::ffi::c_int;
}
extern "C" {
	pub fn abort();
}
extern "C" {
	pub fn abs(arg1: core::ffi::c_int) -> core::ffi::c_int;
}
extern "C" {
	pub fn arc4random() -> __uint32_t;
}
extern "C" {
	pub fn arc4random_uniform(arg1: __uint32_t) -> __uint32_t;
}
extern "C" {
	pub fn arc4random_buf(arg1: *mut core::ffi::c_void, arg2: usize);
}
extern "C" {
	pub fn atexit(__func: ::core::option::Option<unsafe extern "C" fn()>) -> core::ffi::c_int;
}
extern "C" {
	pub fn atof(__nptr: *const core::ffi::c_char) -> core::ffi::c_double;
}
extern "C" {
	pub fn atoff(__nptr: *const core::ffi::c_char) -> core::ffi::c_float;
}
extern "C" {
	pub fn atoi(__nptr: *const core::ffi::c_char) -> core::ffi::c_int;
}
extern "C" {
	pub fn _atoi_r(arg1: *mut _reent, __nptr: *const core::ffi::c_char) -> core::ffi::c_int;
}
extern "C" {
	pub fn atol(__nptr: *const core::ffi::c_char) -> core::ffi::c_long;
}
extern "C" {
	pub fn _atol_r(arg1: *mut _reent, __nptr: *const core::ffi::c_char) -> core::ffi::c_long;
}
extern "C" {
	pub fn bsearch(__key: *const core::ffi::c_void,
	               __base: *const core::ffi::c_void,
	               __nmemb: usize,
	               __size: usize,
	               _compar: __compar_fn_t)
	               -> *mut core::ffi::c_void;
}
extern "C" {
	#[must_use]
	pub fn calloc(arg1: core::ffi::c_uint, arg2: core::ffi::c_uint) -> *mut core::ffi::c_void;
}
extern "C" {
	pub fn div(__numer: core::ffi::c_int, __denom: core::ffi::c_int) -> div_t;
}
extern "C" {
	pub fn exit(__status: core::ffi::c_int);
}
extern "C" {
	pub fn free(arg1: *mut core::ffi::c_void);
}
extern "C" {
	pub fn getenv(__string: *const core::ffi::c_char) -> *mut core::ffi::c_char;
}
extern "C" {
	pub fn _getenv_r(arg1: *mut _reent, __string: *const core::ffi::c_char) -> *mut core::ffi::c_char;
}
extern "C" {
	pub fn _findenv(arg1: *const core::ffi::c_char, arg2: *mut core::ffi::c_int) -> *mut core::ffi::c_char;
}
extern "C" {
	pub fn _findenv_r(arg1: *mut _reent, arg2: *const core::ffi::c_char, arg3: *mut core::ffi::c_int) -> *mut core::ffi::c_char;
}
extern "C" {
	pub static mut suboptarg: *mut core::ffi::c_char;
}
extern "C" {
	pub fn getsubopt(arg1: *mut *mut core::ffi::c_char,
	                 arg2: *const *mut core::ffi::c_char,
	                 arg3: *mut *mut core::ffi::c_char)
	                 -> core::ffi::c_int;
}
extern "C" {
	pub fn labs(arg1: core::ffi::c_long) -> core::ffi::c_long;
}
extern "C" {
	pub fn ldiv(__numer: core::ffi::c_long, __denom: core::ffi::c_long) -> ldiv_t;
}
extern "C" {
	#[must_use]
	pub fn malloc(arg1: core::ffi::c_uint) -> *mut core::ffi::c_void;
}
extern "C" {
	pub fn mblen(arg1: *const core::ffi::c_char, arg2: usize) -> core::ffi::c_int;
}
extern "C" {
	pub fn _mblen_r(arg1: *mut _reent, arg2: *const core::ffi::c_char, arg3: usize, arg4: *mut _mbstate_t) -> core::ffi::c_int;
}
extern "C" {
	pub fn mbtowc(arg1: *mut wchar_t, arg2: *const core::ffi::c_char, arg3: usize) -> core::ffi::c_int;
}
extern "C" {
	pub fn _mbtowc_r(arg1: *mut _reent,
	                 arg2: *mut wchar_t,
	                 arg3: *const core::ffi::c_char,
	                 arg4: usize,
	                 arg5: *mut _mbstate_t)
	                 -> core::ffi::c_int;
}
extern "C" {
	pub fn wctomb(arg1: *mut core::ffi::c_char, arg2: wchar_t) -> core::ffi::c_int;
}
extern "C" {
	pub fn _wctomb_r(arg1: *mut _reent, arg2: *mut core::ffi::c_char, arg3: wchar_t, arg4: *mut _mbstate_t) -> core::ffi::c_int;
}
extern "C" {
	pub fn mbstowcs(arg1: *mut wchar_t, arg2: *const core::ffi::c_char, arg3: usize) -> usize;
}
extern "C" {
	pub fn _mbstowcs_r(arg1: *mut _reent,
	                   arg2: *mut wchar_t,
	                   arg3: *const core::ffi::c_char,
	                   arg4: usize,
	                   arg5: *mut _mbstate_t)
	                   -> usize;
}
extern "C" {
	pub fn wcstombs(arg1: *mut core::ffi::c_char, arg2: *const wchar_t, arg3: usize) -> usize;
}
extern "C" {
	pub fn _wcstombs_r(arg1: *mut _reent,
	                   arg2: *mut core::ffi::c_char,
	                   arg3: *const wchar_t,
	                   arg4: usize,
	                   arg5: *mut _mbstate_t)
	                   -> usize;
}
extern "C" {
	pub fn mkdtemp(arg1: *mut core::ffi::c_char) -> *mut core::ffi::c_char;
}
extern "C" {
	pub fn mkstemp(arg1: *mut core::ffi::c_char) -> core::ffi::c_int;
}
extern "C" {
	pub fn mkstemps(arg1: *mut core::ffi::c_char, arg2: core::ffi::c_int) -> core::ffi::c_int;
}
extern "C" {
	pub fn mktemp(arg1: *mut core::ffi::c_char) -> *mut core::ffi::c_char;
}
extern "C" {
	pub fn _mkdtemp_r(arg1: *mut _reent, arg2: *mut core::ffi::c_char) -> *mut core::ffi::c_char;
}
extern "C" {
	pub fn _mkostemp_r(arg1: *mut _reent, arg2: *mut core::ffi::c_char, arg3: core::ffi::c_int) -> core::ffi::c_int;
}
extern "C" {
	pub fn _mkostemps_r(arg1: *mut _reent,
	                    arg2: *mut core::ffi::c_char,
	                    arg3: core::ffi::c_int,
	                    arg4: core::ffi::c_int)
	                    -> core::ffi::c_int;
}
extern "C" {
	pub fn _mkstemp_r(arg1: *mut _reent, arg2: *mut core::ffi::c_char) -> core::ffi::c_int;
}
extern "C" {
	pub fn _mkstemps_r(arg1: *mut _reent, arg2: *mut core::ffi::c_char, arg3: core::ffi::c_int) -> core::ffi::c_int;
}
extern "C" {
	pub fn _mktemp_r(arg1: *mut _reent, arg2: *mut core::ffi::c_char) -> *mut core::ffi::c_char;
}
extern "C" {
	pub fn qsort(__base: *mut core::ffi::c_void, __nmemb: usize, __size: usize, _compar: __compar_fn_t);
}
extern "C" {
	pub fn rand() -> core::ffi::c_int;
}
extern "C" {
	#[must_use]
	pub fn realloc(arg1: *mut core::ffi::c_void, arg2: core::ffi::c_uint) -> *mut core::ffi::c_void;
}
extern "C" {
	#[must_use]
	pub fn reallocarray(arg1: *mut core::ffi::c_void, arg2: usize, arg3: usize) -> *mut core::ffi::c_void;
}
extern "C" {
	#[must_use]
	pub fn reallocf(arg1: *mut core::ffi::c_void, arg2: usize) -> *mut core::ffi::c_void;
}
extern "C" {
	pub fn realpath(path: *const core::ffi::c_char, resolved_path: *mut core::ffi::c_char) -> *mut core::ffi::c_char;
}
extern "C" {
	pub fn rpmatch(response: *const core::ffi::c_char) -> core::ffi::c_int;
}
extern "C" {
	pub fn srand(__seed: core::ffi::c_uint);
}
extern "C" {
	pub fn strtod(__n: *const core::ffi::c_char, __end_PTR: *mut *mut core::ffi::c_char) -> core::ffi::c_double;
}
extern "C" {
	pub fn _strtod_r(arg1: *mut _reent, __n: *const core::ffi::c_char, __end_PTR: *mut *mut core::ffi::c_char) -> core::ffi::c_double;
}
extern "C" {
	pub fn strtof(__n: *const core::ffi::c_char, __end_PTR: *mut *mut core::ffi::c_char) -> core::ffi::c_float;
}
extern "C" {
	pub fn strtol(__n: *const core::ffi::c_char,
	              __end_PTR: *mut *mut core::ffi::c_char,
	              __base: core::ffi::c_int)
	              -> core::ffi::c_long;
}
extern "C" {
	pub fn _strtol_r(arg1: *mut _reent,
	                 __n: *const core::ffi::c_char,
	                 __end_PTR: *mut *mut core::ffi::c_char,
	                 __base: core::ffi::c_int)
	                 -> core::ffi::c_long;
}
extern "C" {
	pub fn strtoul(__n: *const core::ffi::c_char,
	               __end_PTR: *mut *mut core::ffi::c_char,
	               __base: core::ffi::c_int)
	               -> core::ffi::c_ulong;
}
extern "C" {
	pub fn _strtoul_r(arg1: *mut _reent,
	                  __n: *const core::ffi::c_char,
	                  __end_PTR: *mut *mut core::ffi::c_char,
	                  __base: core::ffi::c_int)
	                  -> core::ffi::c_ulong;
}
extern "C" {
	pub fn system(__string: *const core::ffi::c_char) -> core::ffi::c_int;
}
extern "C" {
	pub fn a64l(__input: *const core::ffi::c_char) -> core::ffi::c_long;
}
extern "C" {
	pub fn l64a(__input: core::ffi::c_long) -> *mut core::ffi::c_char;
}
extern "C" {
	pub fn _l64a_r(arg1: *mut _reent, __input: core::ffi::c_long) -> *mut core::ffi::c_char;
}
extern "C" {
	pub fn on_exit(__func: ::core::option::Option<unsafe extern "C" fn(arg1: core::ffi::c_int, arg2: *mut core::ffi::c_void)>,
	               __arg: *mut core::ffi::c_void)
	               -> core::ffi::c_int;
}
extern "C" {
	pub fn _Exit(__status: core::ffi::c_int);
}
extern "C" {
	pub fn putenv(__string: *mut core::ffi::c_char) -> core::ffi::c_int;
}
extern "C" {
	pub fn _putenv_r(arg1: *mut _reent, __string: *mut core::ffi::c_char) -> core::ffi::c_int;
}
extern "C" {
	pub fn _reallocf_r(arg1: *mut _reent, arg2: *mut core::ffi::c_void, arg3: usize) -> *mut core::ffi::c_void;
}
extern "C" {
	pub fn setenv(__string: *const core::ffi::c_char,
	              __value: *const core::ffi::c_char,
	              __overwrite: core::ffi::c_int)
	              -> core::ffi::c_int;
}
extern "C" {
	pub fn _setenv_r(arg1: *mut _reent,
	                 __string: *const core::ffi::c_char,
	                 __value: *const core::ffi::c_char,
	                 __overwrite: core::ffi::c_int)
	                 -> core::ffi::c_int;
}
extern "C" {
	pub fn __itoa(arg1: core::ffi::c_int, arg2: *mut core::ffi::c_char, arg3: core::ffi::c_int) -> *mut core::ffi::c_char;
}
extern "C" {
	pub fn __utoa(arg1: core::ffi::c_uint, arg2: *mut core::ffi::c_char, arg3: core::ffi::c_int) -> *mut core::ffi::c_char;
}
extern "C" {
	pub fn itoa(arg1: core::ffi::c_int, arg2: *mut core::ffi::c_char, arg3: core::ffi::c_int) -> *mut core::ffi::c_char;
}
extern "C" {
	pub fn utoa(arg1: core::ffi::c_uint, arg2: *mut core::ffi::c_char, arg3: core::ffi::c_int) -> *mut core::ffi::c_char;
}
extern "C" {
	pub fn rand_r(__seed: *mut core::ffi::c_uint) -> core::ffi::c_int;
}
extern "C" {
	pub fn drand48() -> core::ffi::c_double;
}
extern "C" {
	pub fn _drand48_r(arg1: *mut _reent) -> core::ffi::c_double;
}
extern "C" {
	pub fn erand48(arg1: *mut [core::ffi::c_ushort; 3usize]) -> core::ffi::c_double;
}
extern "C" {
	pub fn _erand48_r(arg1: *mut _reent, arg2: *mut [core::ffi::c_ushort; 3usize]) -> core::ffi::c_double;
}
extern "C" {
	pub fn jrand48(arg1: *mut [core::ffi::c_ushort; 3usize]) -> core::ffi::c_long;
}
extern "C" {
	pub fn _jrand48_r(arg1: *mut _reent, arg2: *mut [core::ffi::c_ushort; 3usize]) -> core::ffi::c_long;
}
extern "C" {
	pub fn lcong48(arg1: *mut [core::ffi::c_ushort; 7usize]);
}
extern "C" {
	pub fn _lcong48_r(arg1: *mut _reent, arg2: *mut [core::ffi::c_ushort; 7usize]);
}
extern "C" {
	pub fn lrand48() -> core::ffi::c_long;
}
extern "C" {
	pub fn _lrand48_r(arg1: *mut _reent) -> core::ffi::c_long;
}
extern "C" {
	pub fn mrand48() -> core::ffi::c_long;
}
extern "C" {
	pub fn _mrand48_r(arg1: *mut _reent) -> core::ffi::c_long;
}
extern "C" {
	pub fn nrand48(arg1: *mut [core::ffi::c_ushort; 3usize]) -> core::ffi::c_long;
}
extern "C" {
	pub fn _nrand48_r(arg1: *mut _reent, arg2: *mut [core::ffi::c_ushort; 3usize]) -> core::ffi::c_long;
}
extern "C" {
	pub fn seed48(arg1: *mut [core::ffi::c_ushort; 3usize]) -> *mut core::ffi::c_ushort;
}
extern "C" {
	pub fn _seed48_r(arg1: *mut _reent, arg2: *mut [core::ffi::c_ushort; 3usize]) -> *mut core::ffi::c_ushort;
}
extern "C" {
	pub fn srand48(arg1: core::ffi::c_long);
}
extern "C" {
	pub fn _srand48_r(arg1: *mut _reent, arg2: core::ffi::c_long);
}
extern "C" {
	pub fn initstate(arg1: core::ffi::c_uint, arg2: *mut core::ffi::c_char, arg3: usize) -> *mut core::ffi::c_char;
}
extern "C" {
	pub fn random() -> core::ffi::c_long;
}
extern "C" {
	pub fn setstate(arg1: *mut core::ffi::c_char) -> *mut core::ffi::c_char;
}
extern "C" {
	pub fn srandom(arg1: core::ffi::c_uint);
}
extern "C" {
	pub fn atoll(__nptr: *const core::ffi::c_char) -> core::ffi::c_longlong;
}
extern "C" {
	pub fn _atoll_r(arg1: *mut _reent, __nptr: *const core::ffi::c_char) -> core::ffi::c_longlong;
}
extern "C" {
	pub fn llabs(arg1: core::ffi::c_longlong) -> core::ffi::c_longlong;
}
extern "C" {
	pub fn lldiv(__numer: core::ffi::c_longlong, __denom: core::ffi::c_longlong) -> lldiv_t;
}
extern "C" {
	pub fn strtoll(__n: *const core::ffi::c_char,
	               __end_PTR: *mut *mut core::ffi::c_char,
	               __base: core::ffi::c_int)
	               -> core::ffi::c_longlong;
}
extern "C" {
	pub fn _strtoll_r(arg1: *mut _reent,
	                  __n: *const core::ffi::c_char,
	                  __end_PTR: *mut *mut core::ffi::c_char,
	                  __base: core::ffi::c_int)
	                  -> core::ffi::c_longlong;
}
extern "C" {
	pub fn strtoull(__n: *const core::ffi::c_char,
	                __end_PTR: *mut *mut core::ffi::c_char,
	                __base: core::ffi::c_int)
	                -> core::ffi::c_ulonglong;
}
extern "C" {
	pub fn _strtoull_r(arg1: *mut _reent,
	                   __n: *const core::ffi::c_char,
	                   __end_PTR: *mut *mut core::ffi::c_char,
	                   __base: core::ffi::c_int)
	                   -> core::ffi::c_ulonglong;
}
extern "C" {
	pub fn cfree(arg1: *mut core::ffi::c_void);
}
extern "C" {
	pub fn unsetenv(__string: *const core::ffi::c_char) -> core::ffi::c_int;
}
extern "C" {
	pub fn _unsetenv_r(arg1: *mut _reent, __string: *const core::ffi::c_char) -> core::ffi::c_int;
}
extern "C" {
	#[must_use]
	pub fn posix_memalign(arg1: *mut *mut core::ffi::c_void, arg2: usize, arg3: usize) -> core::ffi::c_int;
}
extern "C" {
	pub fn _dtoa_r(arg1: *mut _reent,
	               arg2: core::ffi::c_double,
	               arg3: core::ffi::c_int,
	               arg4: core::ffi::c_int,
	               arg5: *mut core::ffi::c_int,
	               arg6: *mut core::ffi::c_int,
	               arg7: *mut *mut core::ffi::c_char)
	               -> *mut core::ffi::c_char;
}
extern "C" {
	pub fn _malloc_r(arg1: *mut _reent, arg2: usize) -> *mut core::ffi::c_void;
}
extern "C" {
	pub fn _calloc_r(arg1: *mut _reent, arg2: usize, arg3: usize) -> *mut core::ffi::c_void;
}
extern "C" {
	pub fn _free_r(arg1: *mut _reent, arg2: *mut core::ffi::c_void);
}
extern "C" {
	pub fn _realloc_r(arg1: *mut _reent, arg2: *mut core::ffi::c_void, arg3: usize) -> *mut core::ffi::c_void;
}
extern "C" {
	pub fn _mstats_r(arg1: *mut _reent, arg2: *mut core::ffi::c_char);
}
extern "C" {
	pub fn _system_r(arg1: *mut _reent, arg2: *const core::ffi::c_char) -> core::ffi::c_int;
}
extern "C" {
	pub fn __eprintf(arg1: *const core::ffi::c_char,
	                 arg2: *const core::ffi::c_char,
	                 arg3: core::ffi::c_uint,
	                 arg4: *const core::ffi::c_char);
}
extern "C" {
	#[link_name = "\u{1}__bsd_qsort_r"]
	pub fn qsort_r(__base: *mut core::ffi::c_void,
	               __nmemb: usize,
	               __size: usize,
	               __thunk: *mut core::ffi::c_void,
	               _compar: ::core::option::Option<unsafe extern "C" fn(arg1: *mut core::ffi::c_void,
	                                                           arg2: *const core::ffi::c_void,
	                                                           arg3: *const core::ffi::c_void)
	                                                           -> core::ffi::c_int>);
}
extern "C" {
	pub fn _strtold_r(arg1: *mut _reent, arg2: *const core::ffi::c_char, arg3: *mut *mut core::ffi::c_char) -> f64;
}
extern "C" {
	pub fn strtold(arg1: *const core::ffi::c_char, arg2: *mut *mut core::ffi::c_char) -> f64;
}
extern "C" {
	#[must_use]
	pub fn aligned_alloc(arg1: core::ffi::c_uint, arg2: core::ffi::c_uint) -> *mut core::ffi::c_void;
}
extern "C" {
	pub fn at_quick_exit(arg1: ::core::option::Option<unsafe extern "C" fn()>) -> core::ffi::c_int;
}
extern "C" {
	pub fn quick_exit(arg1: core::ffi::c_int);
}
extern "C" {
	pub fn __assert(arg1: *const core::ffi::c_char, arg2: core::ffi::c_int, arg3: *const core::ffi::c_char);
}
extern "C" {
	pub fn __assert_func(arg1: *const core::ffi::c_char,
	                     arg2: core::ffi::c_int,
	                     arg3: *const core::ffi::c_char,
	                     arg4: *const core::ffi::c_char);
}
pub type va_list = u32;
pub type __gnuc_va_list = u32;
pub type __sigset_t = core::ffi::c_ulong;
pub type suseconds_t = __suseconds_t;
pub type time_t = __int_least64_t;
#[repr(C)]
pub struct timeval {
	pub tv_sec: time_t,
	pub tv_usec: suseconds_t,
}
#[test]
fn bindgen_test_layout_timeval() {
	assert_eq!(
	           ::core::mem::size_of::<timeval>(),
	           16usize,
	           concat!("Size of: ", stringify!(timeval))
	);
	assert_eq!(
	           ::core::mem::align_of::<timeval>(),
	           8usize,
	           concat!("Alignment of ", stringify!(timeval))
	);
	fn test_field_tv_sec() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<timeval>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).tv_sec) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(timeval), "::", stringify!(tv_sec))
		);
	}
	test_field_tv_sec();
	fn test_field_tv_usec() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<timeval>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).tv_usec) as usize - ptr as usize
		           },
		           8usize,
		           concat!("Offset of field: ", stringify!(timeval), "::", stringify!(tv_usec))
		);
	}
	test_field_tv_usec();
}
#[repr(C)]
pub struct timespec {
	pub tv_sec: time_t,
	pub tv_nsec: core::ffi::c_long,
}
#[test]
fn bindgen_test_layout_timespec() {
	assert_eq!(
	           ::core::mem::size_of::<timespec>(),
	           16usize,
	           concat!("Size of: ", stringify!(timespec))
	);
	assert_eq!(
	           ::core::mem::align_of::<timespec>(),
	           8usize,
	           concat!("Alignment of ", stringify!(timespec))
	);
	fn test_field_tv_sec() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<timespec>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).tv_sec) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(timespec), "::", stringify!(tv_sec))
		);
	}
	test_field_tv_sec();
	fn test_field_tv_nsec() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<timespec>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).tv_nsec) as usize - ptr as usize
		           },
		           8usize,
		           concat!("Offset of field: ", stringify!(timespec), "::", stringify!(tv_nsec))
		);
	}
	test_field_tv_nsec();
}
pub type sigset_t = __sigset_t;
pub type __fd_mask = core::ffi::c_ulong;
#[repr(C)]
pub struct fd_set {
	pub __fds_bits: [__fd_mask; 2usize],
}
#[test]
fn bindgen_test_layout_fd_set() {
	assert_eq!(
	           ::core::mem::size_of::<fd_set>(),
	           8usize,
	           concat!("Size of: ", stringify!(fd_set))
	);
	assert_eq!(
	           ::core::mem::align_of::<fd_set>(),
	           4usize,
	           concat!("Alignment of ", stringify!(fd_set))
	);
	fn test_field___fds_bits() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<fd_set>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).__fds_bits) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(fd_set), "::", stringify!(__fds_bits))
		);
	}
	test_field___fds_bits();
}
extern "C" {
	pub fn select(__n: core::ffi::c_int,
	              __readfds: *mut fd_set,
	              __writefds: *mut fd_set,
	              __exceptfds: *mut fd_set,
	              __timeout: *mut timeval)
	              -> core::ffi::c_int;
}
extern "C" {
	pub fn pselect(__n: core::ffi::c_int,
	               __readfds: *mut fd_set,
	               __writefds: *mut fd_set,
	               __exceptfds: *mut fd_set,
	               __timeout: *const timespec,
	               __set: *const sigset_t)
	               -> core::ffi::c_int;
}
pub type off_t = __off_t;
pub type FILE = __FILE;
pub type fpos_t = _fpos_t;
extern "C" {
	pub fn ctermid(arg1: *mut core::ffi::c_char) -> *mut core::ffi::c_char;
}
extern "C" {
	pub fn tmpfile() -> *mut FILE;
}
extern "C" {
	pub fn tmpnam(arg1: *mut core::ffi::c_char) -> *mut core::ffi::c_char;
}
extern "C" {
	#[must_use]
	pub fn tempnam(arg1: *const core::ffi::c_char, arg2: *const core::ffi::c_char) -> *mut core::ffi::c_char;
}
extern "C" {
	pub fn fclose(arg1: *mut FILE) -> core::ffi::c_int;
}
extern "C" {
	pub fn fflush(arg1: *mut FILE) -> core::ffi::c_int;
}
extern "C" {
	pub fn freopen(arg1: *const core::ffi::c_char, arg2: *const core::ffi::c_char, arg3: *mut FILE) -> *mut FILE;
}
extern "C" {
	pub fn setbuf(arg1: *mut FILE, arg2: *mut core::ffi::c_char);
}
extern "C" {
	pub fn setvbuf(arg1: *mut FILE, arg2: *mut core::ffi::c_char, arg3: core::ffi::c_int, arg4: usize) -> core::ffi::c_int;
}
extern "C" {
	pub fn fprintf(arg1: *mut FILE, arg2: *const core::ffi::c_char, ...) -> core::ffi::c_int;
}
extern "C" {
	pub fn fscanf(arg1: *mut FILE, arg2: *const core::ffi::c_char, ...) -> core::ffi::c_int;
}
extern "C" {
	pub fn printf(arg1: *const core::ffi::c_char, ...) -> core::ffi::c_int;
}
extern "C" {
	pub fn scanf(arg1: *const core::ffi::c_char, ...) -> core::ffi::c_int;
}
extern "C" {
	pub fn sscanf(arg1: *const core::ffi::c_char, arg2: *const core::ffi::c_char, ...) -> core::ffi::c_int;
}
extern "C" {
	pub fn vfprintf(arg1: *mut FILE, arg2: *const core::ffi::c_char, arg3: u32) -> core::ffi::c_int;
}
extern "C" {
	pub fn vprintf(arg1: *const core::ffi::c_char, arg2: u32) -> core::ffi::c_int;
}
extern "C" {
	pub fn vsprintf(arg1: *mut core::ffi::c_char, arg2: *const core::ffi::c_char, arg3: u32) -> core::ffi::c_int;
}
extern "C" {
	pub fn fgetc(arg1: *mut FILE) -> core::ffi::c_int;
}
extern "C" {
	pub fn fgets(arg1: *mut core::ffi::c_char, arg2: core::ffi::c_int, arg3: *mut FILE) -> *mut core::ffi::c_char;
}
extern "C" {
	pub fn fputc(arg1: core::ffi::c_int, arg2: *mut FILE) -> core::ffi::c_int;
}
extern "C" {
	pub fn fputs(arg1: *const core::ffi::c_char, arg2: *mut FILE) -> core::ffi::c_int;
}
extern "C" {
	pub fn getc(arg1: *mut FILE) -> core::ffi::c_int;
}
extern "C" {
	pub fn getchar() -> core::ffi::c_int;
}
extern "C" {
	pub fn gets(arg1: *mut core::ffi::c_char) -> *mut core::ffi::c_char;
}
extern "C" {
	pub fn putc(arg1: core::ffi::c_int, arg2: *mut FILE) -> core::ffi::c_int;
}
extern "C" {
	pub fn putchar(arg1: core::ffi::c_int) -> core::ffi::c_int;
}
extern "C" {
	pub fn puts(arg1: *const core::ffi::c_char) -> core::ffi::c_int;
}
extern "C" {
	pub fn ungetc(arg1: core::ffi::c_int, arg2: *mut FILE) -> core::ffi::c_int;
}
extern "C" {
	pub fn fread(arg1: *mut core::ffi::c_void, _size: core::ffi::c_uint, _n: core::ffi::c_uint, arg2: *mut FILE) -> core::ffi::c_uint;
}
extern "C" {
	pub fn fwrite(arg1: *const core::ffi::c_void,
	              _size: core::ffi::c_uint,
	              _n: core::ffi::c_uint,
	              arg2: *mut FILE)
	              -> core::ffi::c_uint;
}
extern "C" {
	pub fn fgetpos(arg1: *mut FILE, arg2: *mut fpos_t) -> core::ffi::c_int;
}
extern "C" {
	pub fn fseek(arg1: *mut FILE, arg2: core::ffi::c_long, arg3: core::ffi::c_int) -> core::ffi::c_int;
}
extern "C" {
	pub fn fsetpos(arg1: *mut FILE, arg2: *const fpos_t) -> core::ffi::c_int;
}
extern "C" {
	pub fn ftell(arg1: *mut FILE) -> core::ffi::c_long;
}
extern "C" {
	pub fn rewind(arg1: *mut FILE);
}
extern "C" {
	pub fn clearerr(arg1: *mut FILE);
}
extern "C" {
	pub fn feof(arg1: *mut FILE) -> core::ffi::c_int;
}
extern "C" {
	pub fn ferror(arg1: *mut FILE) -> core::ffi::c_int;
}
extern "C" {
	pub fn perror(arg1: *const core::ffi::c_char);
}
extern "C" {
	pub fn fopen(_name: *const core::ffi::c_char, _type: *const core::ffi::c_char) -> *mut FILE;
}
extern "C" {
	pub fn sprintf(arg1: *mut core::ffi::c_char, arg2: *const core::ffi::c_char, ...) -> core::ffi::c_int;
}
extern "C" {
	pub fn remove(arg1: *const core::ffi::c_char) -> core::ffi::c_int;
}
extern "C" {
	pub fn rename(arg1: *const core::ffi::c_char, arg2: *const core::ffi::c_char) -> core::ffi::c_int;
}
extern "C" {
	pub fn fseeko(arg1: *mut FILE, arg2: off_t, arg3: core::ffi::c_int) -> core::ffi::c_int;
}
extern "C" {
	pub fn ftello(arg1: *mut FILE) -> off_t;
}
extern "C" {
	pub fn snprintf(arg1: *mut core::ffi::c_char, arg2: core::ffi::c_uint, arg3: *const core::ffi::c_char, ...) -> core::ffi::c_int;
}
extern "C" {
	pub fn vsnprintf(arg1: *mut core::ffi::c_char,
	                 arg2: core::ffi::c_uint,
	                 arg3: *const core::ffi::c_char,
	                 arg4: u32)
	                 -> core::ffi::c_int;
}
extern "C" {
	pub fn vfscanf(arg1: *mut FILE, arg2: *const core::ffi::c_char, arg3: u32) -> core::ffi::c_int;
}
extern "C" {
	pub fn vscanf(arg1: *const core::ffi::c_char, arg2: u32) -> core::ffi::c_int;
}
extern "C" {
	pub fn vsscanf(arg1: *const core::ffi::c_char, arg2: *const core::ffi::c_char, arg3: u32) -> core::ffi::c_int;
}
extern "C" {
	pub fn asiprintf(arg1: *mut *mut core::ffi::c_char, arg2: *const core::ffi::c_char, ...) -> core::ffi::c_int;
}
extern "C" {
	pub fn asniprintf(arg1: *mut core::ffi::c_char, arg2: *mut usize, arg3: *const core::ffi::c_char, ...) -> *mut core::ffi::c_char;
}
extern "C" {
	pub fn asnprintf(arg1: *mut core::ffi::c_char, arg2: *mut usize, arg3: *const core::ffi::c_char, ...) -> *mut core::ffi::c_char;
}
extern "C" {
	pub fn diprintf(arg1: core::ffi::c_int, arg2: *const core::ffi::c_char, ...) -> core::ffi::c_int;
}
extern "C" {
	pub fn fiprintf(arg1: *mut FILE, arg2: *const core::ffi::c_char, ...) -> core::ffi::c_int;
}
extern "C" {
	pub fn fiscanf(arg1: *mut FILE, arg2: *const core::ffi::c_char, ...) -> core::ffi::c_int;
}
extern "C" {
	pub fn iprintf(arg1: *const core::ffi::c_char, ...) -> core::ffi::c_int;
}
extern "C" {
	pub fn iscanf(arg1: *const core::ffi::c_char, ...) -> core::ffi::c_int;
}
extern "C" {
	pub fn siprintf(arg1: *mut core::ffi::c_char, arg2: *const core::ffi::c_char, ...) -> core::ffi::c_int;
}
extern "C" {
	pub fn siscanf(arg1: *const core::ffi::c_char, arg2: *const core::ffi::c_char, ...) -> core::ffi::c_int;
}
extern "C" {
	pub fn sniprintf(arg1: *mut core::ffi::c_char, arg2: usize, arg3: *const core::ffi::c_char, ...) -> core::ffi::c_int;
}
extern "C" {
	pub fn vasiprintf(arg1: *mut *mut core::ffi::c_char, arg2: *const core::ffi::c_char, arg3: __gnuc_va_list) -> core::ffi::c_int;
}
extern "C" {
	pub fn vasniprintf(arg1: *mut core::ffi::c_char,
	                   arg2: *mut usize,
	                   arg3: *const core::ffi::c_char,
	                   arg4: __gnuc_va_list)
	                   -> *mut core::ffi::c_char;
}
extern "C" {
	pub fn vasnprintf(arg1: *mut core::ffi::c_char,
	                  arg2: *mut usize,
	                  arg3: *const core::ffi::c_char,
	                  arg4: __gnuc_va_list)
	                  -> *mut core::ffi::c_char;
}
extern "C" {
	pub fn vdiprintf(arg1: core::ffi::c_int, arg2: *const core::ffi::c_char, arg3: __gnuc_va_list) -> core::ffi::c_int;
}
extern "C" {
	pub fn vfiprintf(arg1: *mut FILE, arg2: *const core::ffi::c_char, arg3: __gnuc_va_list) -> core::ffi::c_int;
}
extern "C" {
	pub fn vfiscanf(arg1: *mut FILE, arg2: *const core::ffi::c_char, arg3: __gnuc_va_list) -> core::ffi::c_int;
}
extern "C" {
	pub fn viprintf(arg1: *const core::ffi::c_char, arg2: __gnuc_va_list) -> core::ffi::c_int;
}
extern "C" {
	pub fn viscanf(arg1: *const core::ffi::c_char, arg2: __gnuc_va_list) -> core::ffi::c_int;
}
extern "C" {
	pub fn vsiprintf(arg1: *mut core::ffi::c_char, arg2: *const core::ffi::c_char, arg3: __gnuc_va_list) -> core::ffi::c_int;
}
extern "C" {
	pub fn vsiscanf(arg1: *const core::ffi::c_char, arg2: *const core::ffi::c_char, arg3: __gnuc_va_list) -> core::ffi::c_int;
}
extern "C" {
	pub fn vsniprintf(arg1: *mut core::ffi::c_char,
	                  arg2: usize,
	                  arg3: *const core::ffi::c_char,
	                  arg4: __gnuc_va_list)
	                  -> core::ffi::c_int;
}
extern "C" {
	pub fn fdopen(arg1: core::ffi::c_int, arg2: *const core::ffi::c_char) -> *mut FILE;
}
extern "C" {
	pub fn fileno(arg1: *mut FILE) -> core::ffi::c_int;
}
extern "C" {
	pub fn pclose(arg1: *mut FILE) -> core::ffi::c_int;
}
extern "C" {
	pub fn popen(arg1: *const core::ffi::c_char, arg2: *const core::ffi::c_char) -> *mut FILE;
}
extern "C" {
	pub fn setbuffer(arg1: *mut FILE, arg2: *mut core::ffi::c_char, arg3: core::ffi::c_int);
}
extern "C" {
	pub fn setlinebuf(arg1: *mut FILE) -> core::ffi::c_int;
}
extern "C" {
	pub fn getw(arg1: *mut FILE) -> core::ffi::c_int;
}
extern "C" {
	pub fn putw(arg1: core::ffi::c_int, arg2: *mut FILE) -> core::ffi::c_int;
}
extern "C" {
	pub fn getc_unlocked(arg1: *mut FILE) -> core::ffi::c_int;
}
extern "C" {
	pub fn getchar_unlocked() -> core::ffi::c_int;
}
extern "C" {
	pub fn flockfile(arg1: *mut FILE);
}
extern "C" {
	pub fn ftrylockfile(arg1: *mut FILE) -> core::ffi::c_int;
}
extern "C" {
	pub fn funlockfile(arg1: *mut FILE);
}
extern "C" {
	pub fn putc_unlocked(arg1: core::ffi::c_int, arg2: *mut FILE) -> core::ffi::c_int;
}
extern "C" {
	pub fn putchar_unlocked(arg1: core::ffi::c_int) -> core::ffi::c_int;
}
extern "C" {
	pub fn dprintf(arg1: core::ffi::c_int, arg2: *const core::ffi::c_char, ...) -> core::ffi::c_int;
}
extern "C" {
	pub fn fmemopen(arg1: *mut core::ffi::c_void, arg2: usize, arg3: *const core::ffi::c_char) -> *mut FILE;
}
extern "C" {
	pub fn open_memstream(arg1: *mut *mut core::ffi::c_char, arg2: *mut usize) -> *mut FILE;
}
extern "C" {
	pub fn vdprintf(arg1: core::ffi::c_int, arg2: *const core::ffi::c_char, arg3: __gnuc_va_list) -> core::ffi::c_int;
}
extern "C" {
	pub fn renameat(arg1: core::ffi::c_int,
	                arg2: *const core::ffi::c_char,
	                arg3: core::ffi::c_int,
	                arg4: *const core::ffi::c_char)
	                -> core::ffi::c_int;
}
extern "C" {
	pub fn _asiprintf_r(arg1: *mut _reent, arg2: *mut *mut core::ffi::c_char, arg3: *const core::ffi::c_char, ...)
	                    -> core::ffi::c_int;
}
extern "C" {
	pub fn _asniprintf_r(arg1: *mut _reent,
	                     arg2: *mut core::ffi::c_char,
	                     arg3: *mut usize,
	                     arg4: *const core::ffi::c_char,
	                     ...)
	                     -> *mut core::ffi::c_char;
}
extern "C" {
	pub fn _asnprintf_r(arg1: *mut _reent,
	                    arg2: *mut core::ffi::c_char,
	                    arg3: *mut usize,
	                    arg4: *const core::ffi::c_char,
	                    ...)
	                    -> *mut core::ffi::c_char;
}
extern "C" {
	pub fn _asprintf_r(arg1: *mut _reent, arg2: *mut *mut core::ffi::c_char, arg3: *const core::ffi::c_char, ...) -> core::ffi::c_int;
}
extern "C" {
	pub fn _diprintf_r(arg1: *mut _reent, arg2: core::ffi::c_int, arg3: *const core::ffi::c_char, ...) -> core::ffi::c_int;
}
extern "C" {
	pub fn _dprintf_r(arg1: *mut _reent, arg2: core::ffi::c_int, arg3: *const core::ffi::c_char, ...) -> core::ffi::c_int;
}
extern "C" {
	pub fn _fclose_r(arg1: *mut _reent, arg2: *mut FILE) -> core::ffi::c_int;
}
extern "C" {
	pub fn _fcloseall_r(arg1: *mut _reent) -> core::ffi::c_int;
}
extern "C" {
	pub fn _fdopen_r(arg1: *mut _reent, arg2: core::ffi::c_int, arg3: *const core::ffi::c_char) -> *mut FILE;
}
extern "C" {
	pub fn _fflush_r(arg1: *mut _reent, arg2: *mut FILE) -> core::ffi::c_int;
}
extern "C" {
	pub fn _fgetc_r(arg1: *mut _reent, arg2: *mut FILE) -> core::ffi::c_int;
}
extern "C" {
	pub fn _fgetc_unlocked_r(arg1: *mut _reent, arg2: *mut FILE) -> core::ffi::c_int;
}
extern "C" {
	pub fn _fgets_r(arg1: *mut _reent,
	                arg2: *mut core::ffi::c_char,
	                arg3: core::ffi::c_int,
	                arg4: *mut FILE)
	                -> *mut core::ffi::c_char;
}
extern "C" {
	pub fn _fgets_unlocked_r(arg1: *mut _reent,
	                         arg2: *mut core::ffi::c_char,
	                         arg3: core::ffi::c_int,
	                         arg4: *mut FILE)
	                         -> *mut core::ffi::c_char;
}
extern "C" {
	pub fn _fgetpos_r(arg1: *mut _reent, arg2: *mut FILE, arg3: *mut fpos_t) -> core::ffi::c_int;
}
extern "C" {
	pub fn _fsetpos_r(arg1: *mut _reent, arg2: *mut FILE, arg3: *const fpos_t) -> core::ffi::c_int;
}
extern "C" {
	pub fn _fiprintf_r(arg1: *mut _reent, arg2: *mut FILE, arg3: *const core::ffi::c_char, ...) -> core::ffi::c_int;
}
extern "C" {
	pub fn _fiscanf_r(arg1: *mut _reent, arg2: *mut FILE, arg3: *const core::ffi::c_char, ...) -> core::ffi::c_int;
}
extern "C" {
	pub fn _fmemopen_r(arg1: *mut _reent, arg2: *mut core::ffi::c_void, arg3: usize, arg4: *const core::ffi::c_char) -> *mut FILE;
}
extern "C" {
	pub fn _fopen_r(arg1: *mut _reent, arg2: *const core::ffi::c_char, arg3: *const core::ffi::c_char) -> *mut FILE;
}
extern "C" {
	pub fn _freopen_r(arg1: *mut _reent, arg2: *const core::ffi::c_char, arg3: *const core::ffi::c_char, arg4: *mut FILE)
	                  -> *mut FILE;
}
extern "C" {
	pub fn _fprintf_r(arg1: *mut _reent, arg2: *mut FILE, arg3: *const core::ffi::c_char, ...) -> core::ffi::c_int;
}
extern "C" {
	pub fn _fpurge_r(arg1: *mut _reent, arg2: *mut FILE) -> core::ffi::c_int;
}
extern "C" {
	pub fn _fputc_r(arg1: *mut _reent, arg2: core::ffi::c_int, arg3: *mut FILE) -> core::ffi::c_int;
}
extern "C" {
	pub fn _fputc_unlocked_r(arg1: *mut _reent, arg2: core::ffi::c_int, arg3: *mut FILE) -> core::ffi::c_int;
}
extern "C" {
	pub fn _fputs_r(arg1: *mut _reent, arg2: *const core::ffi::c_char, arg3: *mut FILE) -> core::ffi::c_int;
}
extern "C" {
	pub fn _fputs_unlocked_r(arg1: *mut _reent, arg2: *const core::ffi::c_char, arg3: *mut FILE) -> core::ffi::c_int;
}
extern "C" {
	pub fn _fread_r(arg1: *mut _reent, arg2: *mut core::ffi::c_void, _size: usize, _n: usize, arg3: *mut FILE) -> usize;
}
extern "C" {
	pub fn _fread_unlocked_r(arg1: *mut _reent, arg2: *mut core::ffi::c_void, _size: usize, _n: usize, arg3: *mut FILE) -> usize;
}
extern "C" {
	pub fn _fscanf_r(arg1: *mut _reent, arg2: *mut FILE, arg3: *const core::ffi::c_char, ...) -> core::ffi::c_int;
}
extern "C" {
	pub fn _fseek_r(arg1: *mut _reent, arg2: *mut FILE, arg3: core::ffi::c_long, arg4: core::ffi::c_int) -> core::ffi::c_int;
}
extern "C" {
	pub fn _fseeko_r(arg1: *mut _reent, arg2: *mut FILE, arg3: _off_t, arg4: core::ffi::c_int) -> core::ffi::c_int;
}
extern "C" {
	pub fn _ftell_r(arg1: *mut _reent, arg2: *mut FILE) -> core::ffi::c_long;
}
extern "C" {
	pub fn _ftello_r(arg1: *mut _reent, arg2: *mut FILE) -> _off_t;
}
extern "C" {
	pub fn _rewind_r(arg1: *mut _reent, arg2: *mut FILE);
}
extern "C" {
	pub fn _fwrite_r(arg1: *mut _reent, arg2: *const core::ffi::c_void, _size: usize, _n: usize, arg3: *mut FILE) -> usize;
}
extern "C" {
	pub fn _fwrite_unlocked_r(arg1: *mut _reent, arg2: *const core::ffi::c_void, _size: usize, _n: usize, arg3: *mut FILE) -> usize;
}
extern "C" {
	pub fn _getc_r(arg1: *mut _reent, arg2: *mut FILE) -> core::ffi::c_int;
}
extern "C" {
	pub fn _getc_unlocked_r(arg1: *mut _reent, arg2: *mut FILE) -> core::ffi::c_int;
}
extern "C" {
	pub fn _getchar_r(arg1: *mut _reent) -> core::ffi::c_int;
}
extern "C" {
	pub fn _getchar_unlocked_r(arg1: *mut _reent) -> core::ffi::c_int;
}
extern "C" {
	pub fn _gets_r(arg1: *mut _reent, arg2: *mut core::ffi::c_char) -> *mut core::ffi::c_char;
}
extern "C" {
	pub fn _iprintf_r(arg1: *mut _reent, arg2: *const core::ffi::c_char, ...) -> core::ffi::c_int;
}
extern "C" {
	pub fn _iscanf_r(arg1: *mut _reent, arg2: *const core::ffi::c_char, ...) -> core::ffi::c_int;
}
extern "C" {
	pub fn _open_memstream_r(arg1: *mut _reent, arg2: *mut *mut core::ffi::c_char, arg3: *mut usize) -> *mut FILE;
}
extern "C" {
	pub fn _perror_r(arg1: *mut _reent, arg2: *const core::ffi::c_char);
}
extern "C" {
	pub fn _printf_r(arg1: *mut _reent, arg2: *const core::ffi::c_char, ...) -> core::ffi::c_int;
}
extern "C" {
	pub fn _putc_r(arg1: *mut _reent, arg2: core::ffi::c_int, arg3: *mut FILE) -> core::ffi::c_int;
}
extern "C" {
	pub fn _putc_unlocked_r(arg1: *mut _reent, arg2: core::ffi::c_int, arg3: *mut FILE) -> core::ffi::c_int;
}
extern "C" {
	pub fn _putchar_unlocked_r(arg1: *mut _reent, arg2: core::ffi::c_int) -> core::ffi::c_int;
}
extern "C" {
	pub fn _putchar_r(arg1: *mut _reent, arg2: core::ffi::c_int) -> core::ffi::c_int;
}
extern "C" {
	pub fn _puts_r(arg1: *mut _reent, arg2: *const core::ffi::c_char) -> core::ffi::c_int;
}
extern "C" {
	pub fn _remove_r(arg1: *mut _reent, arg2: *const core::ffi::c_char) -> core::ffi::c_int;
}
extern "C" {
	pub fn _rename_r(arg1: *mut _reent, _old: *const core::ffi::c_char, _new: *const core::ffi::c_char) -> core::ffi::c_int;
}
extern "C" {
	pub fn _scanf_r(arg1: *mut _reent, arg2: *const core::ffi::c_char, ...) -> core::ffi::c_int;
}
extern "C" {
	pub fn _siprintf_r(arg1: *mut _reent, arg2: *mut core::ffi::c_char, arg3: *const core::ffi::c_char, ...) -> core::ffi::c_int;
}
extern "C" {
	pub fn _siscanf_r(arg1: *mut _reent, arg2: *const core::ffi::c_char, arg3: *const core::ffi::c_char, ...) -> core::ffi::c_int;
}
extern "C" {
	pub fn _sniprintf_r(arg1: *mut _reent,
	                    arg2: *mut core::ffi::c_char,
	                    arg3: usize,
	                    arg4: *const core::ffi::c_char,
	                    ...)
	                    -> core::ffi::c_int;
}
extern "C" {
	pub fn _snprintf_r(arg1: *mut _reent,
	                   arg2: *mut core::ffi::c_char,
	                   arg3: usize,
	                   arg4: *const core::ffi::c_char,
	                   ...)
	                   -> core::ffi::c_int;
}
extern "C" {
	pub fn _sprintf_r(arg1: *mut _reent, arg2: *mut core::ffi::c_char, arg3: *const core::ffi::c_char, ...) -> core::ffi::c_int;
}
extern "C" {
	pub fn _sscanf_r(arg1: *mut _reent, arg2: *const core::ffi::c_char, arg3: *const core::ffi::c_char, ...) -> core::ffi::c_int;
}
extern "C" {
	pub fn _tempnam_r(arg1: *mut _reent, arg2: *const core::ffi::c_char, arg3: *const core::ffi::c_char) -> *mut core::ffi::c_char;
}
extern "C" {
	pub fn _tmpfile_r(arg1: *mut _reent) -> *mut FILE;
}
extern "C" {
	pub fn _tmpnam_r(arg1: *mut _reent, arg2: *mut core::ffi::c_char) -> *mut core::ffi::c_char;
}
extern "C" {
	pub fn _ungetc_r(arg1: *mut _reent, arg2: core::ffi::c_int, arg3: *mut FILE) -> core::ffi::c_int;
}
extern "C" {
	pub fn _vasiprintf_r(arg1: *mut _reent,
	                     arg2: *mut *mut core::ffi::c_char,
	                     arg3: *const core::ffi::c_char,
	                     arg4: __gnuc_va_list)
	                     -> core::ffi::c_int;
}
extern "C" {
	pub fn _vasniprintf_r(arg1: *mut _reent,
	                      arg2: *mut core::ffi::c_char,
	                      arg3: *mut usize,
	                      arg4: *const core::ffi::c_char,
	                      arg5: __gnuc_va_list)
	                      -> *mut core::ffi::c_char;
}
extern "C" {
	pub fn _vasnprintf_r(arg1: *mut _reent,
	                     arg2: *mut core::ffi::c_char,
	                     arg3: *mut usize,
	                     arg4: *const core::ffi::c_char,
	                     arg5: __gnuc_va_list)
	                     -> *mut core::ffi::c_char;
}
extern "C" {
	pub fn _vasprintf_r(arg1: *mut _reent,
	                    arg2: *mut *mut core::ffi::c_char,
	                    arg3: *const core::ffi::c_char,
	                    arg4: __gnuc_va_list)
	                    -> core::ffi::c_int;
}
extern "C" {
	pub fn _vdiprintf_r(arg1: *mut _reent,
	                    arg2: core::ffi::c_int,
	                    arg3: *const core::ffi::c_char,
	                    arg4: __gnuc_va_list)
	                    -> core::ffi::c_int;
}
extern "C" {
	pub fn _vdprintf_r(arg1: *mut _reent,
	                   arg2: core::ffi::c_int,
	                   arg3: *const core::ffi::c_char,
	                   arg4: __gnuc_va_list)
	                   -> core::ffi::c_int;
}
extern "C" {
	pub fn _vfiprintf_r(arg1: *mut _reent, arg2: *mut FILE, arg3: *const core::ffi::c_char, arg4: __gnuc_va_list) -> core::ffi::c_int;
}
extern "C" {
	pub fn _vfiscanf_r(arg1: *mut _reent, arg2: *mut FILE, arg3: *const core::ffi::c_char, arg4: __gnuc_va_list) -> core::ffi::c_int;
}
extern "C" {
	pub fn _vfprintf_r(arg1: *mut _reent, arg2: *mut FILE, arg3: *const core::ffi::c_char, arg4: __gnuc_va_list) -> core::ffi::c_int;
}
extern "C" {
	pub fn _vfscanf_r(arg1: *mut _reent, arg2: *mut FILE, arg3: *const core::ffi::c_char, arg4: __gnuc_va_list) -> core::ffi::c_int;
}
extern "C" {
	pub fn _viprintf_r(arg1: *mut _reent, arg2: *const core::ffi::c_char, arg3: __gnuc_va_list) -> core::ffi::c_int;
}
extern "C" {
	pub fn _viscanf_r(arg1: *mut _reent, arg2: *const core::ffi::c_char, arg3: __gnuc_va_list) -> core::ffi::c_int;
}
extern "C" {
	pub fn _vprintf_r(arg1: *mut _reent, arg2: *const core::ffi::c_char, arg3: __gnuc_va_list) -> core::ffi::c_int;
}
extern "C" {
	pub fn _vscanf_r(arg1: *mut _reent, arg2: *const core::ffi::c_char, arg3: __gnuc_va_list) -> core::ffi::c_int;
}
extern "C" {
	pub fn _vsiprintf_r(arg1: *mut _reent,
	                    arg2: *mut core::ffi::c_char,
	                    arg3: *const core::ffi::c_char,
	                    arg4: __gnuc_va_list)
	                    -> core::ffi::c_int;
}
extern "C" {
	pub fn _vsiscanf_r(arg1: *mut _reent,
	                   arg2: *const core::ffi::c_char,
	                   arg3: *const core::ffi::c_char,
	                   arg4: __gnuc_va_list)
	                   -> core::ffi::c_int;
}
extern "C" {
	pub fn _vsniprintf_r(arg1: *mut _reent,
	                     arg2: *mut core::ffi::c_char,
	                     arg3: usize,
	                     arg4: *const core::ffi::c_char,
	                     arg5: __gnuc_va_list)
	                     -> core::ffi::c_int;
}
extern "C" {
	pub fn _vsnprintf_r(arg1: *mut _reent,
	                    arg2: *mut core::ffi::c_char,
	                    arg3: usize,
	                    arg4: *const core::ffi::c_char,
	                    arg5: __gnuc_va_list)
	                    -> core::ffi::c_int;
}
extern "C" {
	pub fn _vsprintf_r(arg1: *mut _reent,
	                   arg2: *mut core::ffi::c_char,
	                   arg3: *const core::ffi::c_char,
	                   arg4: __gnuc_va_list)
	                   -> core::ffi::c_int;
}
extern "C" {
	pub fn _vsscanf_r(arg1: *mut _reent,
	                  arg2: *const core::ffi::c_char,
	                  arg3: *const core::ffi::c_char,
	                  arg4: __gnuc_va_list)
	                  -> core::ffi::c_int;
}
extern "C" {
	pub fn fpurge(arg1: *mut FILE) -> core::ffi::c_int;
}
extern "C" {
	pub fn __getdelim(arg1: *mut *mut core::ffi::c_char, arg2: *mut usize, arg3: core::ffi::c_int, arg4: *mut FILE) -> isize;
}
extern "C" {
	pub fn __getline(arg1: *mut *mut core::ffi::c_char, arg2: *mut usize, arg3: *mut FILE) -> isize;
}
extern "C" {
	pub fn clearerr_unlocked(arg1: *mut FILE);
}
extern "C" {
	pub fn feof_unlocked(arg1: *mut FILE) -> core::ffi::c_int;
}
extern "C" {
	pub fn ferror_unlocked(arg1: *mut FILE) -> core::ffi::c_int;
}
extern "C" {
	pub fn fileno_unlocked(arg1: *mut FILE) -> core::ffi::c_int;
}
extern "C" {
	pub fn fflush_unlocked(arg1: *mut FILE) -> core::ffi::c_int;
}
extern "C" {
	pub fn fgetc_unlocked(arg1: *mut FILE) -> core::ffi::c_int;
}
extern "C" {
	pub fn fputc_unlocked(arg1: core::ffi::c_int, arg2: *mut FILE) -> core::ffi::c_int;
}
extern "C" {
	pub fn fread_unlocked(arg1: *mut core::ffi::c_void, _size: usize, _n: usize, arg2: *mut FILE) -> usize;
}
extern "C" {
	pub fn fwrite_unlocked(arg1: *const core::ffi::c_void, _size: usize, _n: usize, arg2: *mut FILE) -> usize;
}
extern "C" {
	pub fn __srget_r(arg1: *mut _reent, arg2: *mut FILE) -> core::ffi::c_int;
}
extern "C" {
	pub fn __swbuf_r(arg1: *mut _reent, arg2: core::ffi::c_int, arg3: *mut FILE) -> core::ffi::c_int;
}
extern "C" {
	pub fn funopen(__cookie: *const core::ffi::c_void,
	               __readfn: ::core::option::Option<unsafe extern "C" fn(__cookie: *mut core::ffi::c_void,
	                                                           __buf: *mut core::ffi::c_char,
	                                                           __n: core::ffi::c_int)
	                                                           -> core::ffi::c_int>,
	               __writefn: ::core::option::Option<unsafe extern "C" fn(__cookie: *mut core::ffi::c_void,
	                                                           __buf: *const core::ffi::c_char,
	                                                           __n: core::ffi::c_int)
	                                                           -> core::ffi::c_int>,
	               __seekfn: ::core::option::Option<unsafe extern "C" fn(__cookie: *mut core::ffi::c_void,
	                                                           __off: fpos_t,
	                                                           __whence: core::ffi::c_int)
	                                                           -> fpos_t>,
	               __closefn: ::core::option::Option<unsafe extern "C" fn(__cookie: *mut core::ffi::c_void) -> core::ffi::c_int>)
	               -> *mut FILE;
}
extern "C" {
	pub fn _funopen_r(arg1: *mut _reent,
	                  __cookie: *const core::ffi::c_void,
	                  __readfn: ::core::option::Option<unsafe extern "C" fn(__cookie: *mut core::ffi::c_void,
	                                                              __buf: *mut core::ffi::c_char,
	                                                              __n: core::ffi::c_int)
	                                                              -> core::ffi::c_int>,
	                  __writefn: ::core::option::Option<unsafe extern "C" fn(__cookie: *mut core::ffi::c_void,
	                                                              __buf: *const core::ffi::c_char,
	                                                              __n: core::ffi::c_int)
	                                                              -> core::ffi::c_int>,
	                  __seekfn: ::core::option::Option<unsafe extern "C" fn(__cookie: *mut core::ffi::c_void,
	                                                              __off: fpos_t,
	                                                              __whence: core::ffi::c_int)
	                                                              -> fpos_t>,
	                  __closefn: ::core::option::Option<unsafe extern "C" fn(__cookie: *mut core::ffi::c_void) -> core::ffi::c_int>)
	                  -> *mut FILE;
}
#[repr(C)]
pub struct string_heap_s {
	pub size: usize,
	pub alloc: usize,
}
#[test]
fn bindgen_test_layout_string_heap_s() {
	assert_eq!(
	           ::core::mem::size_of::<string_heap_s>(),
	           8usize,
	           concat!("Size of: ", stringify!(string_heap_s))
	);
	assert_eq!(
	           ::core::mem::align_of::<string_heap_s>(),
	           4usize,
	           concat!("Alignment of ", stringify!(string_heap_s))
	);
	fn test_field_size() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<string_heap_s>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).size) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(string_heap_s), "::", stringify!(size))
		);
	}
	test_field_size();
	fn test_field_alloc() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<string_heap_s>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).alloc) as usize - ptr as usize
		           },
		           4usize,
		           concat!("Offset of field: ", stringify!(string_heap_s), "::", stringify!(alloc))
		);
	}
	test_field_alloc();
}
pub type string_heap_ct = string_heap_s;
#[repr(C)]
pub struct string_stack_s {
	pub buffer: [core::ffi::c_char; 8usize],
}
#[test]
fn bindgen_test_layout_string_stack_s() {
	assert_eq!(
	           ::core::mem::size_of::<string_stack_s>(),
	           8usize,
	           concat!("Size of: ", stringify!(string_stack_s))
	);
	assert_eq!(
	           ::core::mem::align_of::<string_stack_s>(),
	           1usize,
	           concat!("Alignment of ", stringify!(string_stack_s))
	);
	fn test_field_buffer() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<string_stack_s>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).buffer) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(string_stack_s), "::", stringify!(buffer))
		);
	}
	test_field_buffer();
}
pub type string_stack_ct = string_stack_s;
#[repr(C)]
pub struct string_union_u {
	pub heap: __BindgenUnionField<string_heap_ct>,
	pub stack: __BindgenUnionField<string_stack_ct>,
	pub bindgen_union_field: [u32; 2usize],
}
#[test]
fn bindgen_test_layout_string_union_u() {
	assert_eq!(
	           ::core::mem::size_of::<string_union_u>(),
	           8usize,
	           concat!("Size of: ", stringify!(string_union_u))
	);
	assert_eq!(
	           ::core::mem::align_of::<string_union_u>(),
	           4usize,
	           concat!("Alignment of ", stringify!(string_union_u))
	);
	fn test_field_heap() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<string_union_u>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).heap) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(string_union_u), "::", stringify!(heap))
		);
	}
	test_field_heap();
	fn test_field_stack() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<string_union_u>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).stack) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(string_union_u), "::", stringify!(stack))
		);
	}
	test_field_stack();
}
pub type string_union_ct = string_union_u;
#[repr(C)]
pub struct string_s {
	pub u: string_union_ct,
	pub ptr: *mut core::ffi::c_char,
}
#[test]
fn bindgen_test_layout_string_s() {
	assert_eq!(
	           ::core::mem::size_of::<string_s>(),
	           12usize,
	           concat!("Size of: ", stringify!(string_s))
	);
	assert_eq!(
	           ::core::mem::align_of::<string_s>(),
	           4usize,
	           concat!("Alignment of ", stringify!(string_s))
	);
	fn test_field_u() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<string_s>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).u) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(string_s), "::", stringify!(u))
		);
	}
	test_field_u();
	fn test_field_ptr() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<string_s>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).ptr) as usize - ptr as usize
		           },
		           8usize,
		           concat!("Offset of field: ", stringify!(string_s), "::", stringify!(ptr))
		);
	}
	test_field_ptr();
}
pub type string_t = [string_s; 1usize];
pub type string_ptr = *mut string_s;
#[repr(u32)]
#[non_exhaustive]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum CliCommandFlag {
	#[doc = "< Default, loader lock is used"]
	CliCommandFlagDefault = 0,
	CliCommandFlagParallelSafe = 1,
	#[doc = "< Safe to run with insomnia mode on"]
	CliCommandFlagInsomniaSafe = 2,
}
#[repr(C)]
pub struct Cli {
	_unused: [u8; 0],
}
#[doc = " Cli callback function pointer. Implement this interface and use"]
#[doc = " add_cli_command"]
#[doc = " @param      args     string with what was passed after command"]
#[doc = " @param      context  pointer to whatever you gave us on cli_add_command"]
pub type CliCallback =
	::core::option::Option<unsafe extern "C" fn(cli: *mut Cli, args: *mut string_t, context: *mut core::ffi::c_void)>;
extern "C" {
	#[doc = " Add cli command Registers you command callback"]
	#[doc = ""]
	#[doc = " @param      cli       pointer to cli instance"]
	#[doc = " @param      name      command name"]
	#[doc = " @param      flags     CliCommandFlag"]
	#[doc = " @param      callback  callback function"]
	#[doc = " @param      context   pointer to whatever we need to pass to callback"]
	pub fn cli_add_command(cli: *mut Cli,
	                       name: *const core::ffi::c_char,
	                       flags: CliCommandFlag,
	                       callback: CliCallback,
	                       context: *mut core::ffi::c_void);
}
extern "C" {
	#[doc = " Print unified cmd usage tip"]
	#[doc = ""]
	#[doc = " @param      cmd    cmd name"]
	#[doc = " @param      usage  usage tip"]
	#[doc = " @param      arg    arg passed by user"]
	pub fn cli_print_usage(cmd: *const core::ffi::c_char, usage: *const core::ffi::c_char, arg: *const core::ffi::c_char);
}
extern "C" {
	#[doc = " Delete cli command"]
	#[doc = ""]
	#[doc = " @param      cli   pointer to cli instance"]
	#[doc = " @param      name  command name"]
	pub fn cli_delete_command(cli: *mut Cli, name: *const core::ffi::c_char);
}
extern "C" {
	#[doc = " Read from terminal"]
	#[doc = ""]
	#[doc = " @param      cli     Cli instance"]
	#[doc = " @param      buffer  pointer to buffer"]
	#[doc = " @param      size    size of buffer in bytes"]
	#[doc = ""]
	#[doc = " @return     bytes read"]
	pub fn cli_read(cli: *mut Cli, buffer: *mut u8, size: usize) -> usize;
}
extern "C" {
	#[doc = " Non-blocking read from terminal"]
	#[doc = ""]
	#[doc = " @param      cli     Cli instance"]
	#[doc = " @param      buffer  pointer to buffer"]
	#[doc = " @param      size    size of buffer in bytes"]
	#[doc = " @param      timeout timeout value in ms"]
	#[doc = ""]
	#[doc = " @return     bytes read"]
	pub fn cli_read_timeout(cli: *mut Cli, buffer: *mut u8, size: usize, timeout: u32) -> usize;
}
extern "C" {
	#[doc = " Non-blocking check for interrupt command received"]
	#[doc = ""]
	#[doc = " @param      cli   Cli instance"]
	#[doc = ""]
	#[doc = " @return     true if received"]
	pub fn cli_cmd_interrupt_received(cli: *mut Cli) -> bool;
}
extern "C" {
	#[doc = " Write to terminal Do it only from inside of cli call."]
	#[doc = ""]
	#[doc = " @param      cli     Cli instance"]
	#[doc = " @param      buffer  pointer to buffer"]
	#[doc = " @param      size    size of buffer in bytes"]
	pub fn cli_write(cli: *mut Cli, buffer: *const u8, size: usize);
}
extern "C" {
	#[doc = " Read character"]
	#[doc = ""]
	#[doc = " @param      cli   Cli instance"]
	#[doc = ""]
	#[doc = " @return     char"]
	pub fn cli_getc(cli: *mut Cli) -> core::ffi::c_char;
}
extern "C" {
	#[doc = " New line Send new ine sequence"]
	pub fn cli_nl();
}
extern "C" {
	pub fn cli_session_open(cli: *mut Cli, session: *mut core::ffi::c_void);
}
extern "C" {
	pub fn cli_session_close(cli: *mut Cli);
}
extern "C" {
	pub fn cli_is_connected(cli: *mut Cli) -> bool;
}
#[repr(C)]
pub struct CliSession {
	_unused: [u8; 0],
}
extern "C" {
	pub static mut cli_vcp: CliSession;
}
extern "C" {
	#[doc = " Crash system"]
	pub fn furi_crash(message: *const core::ffi::c_char);
}
extern "C" {
	#[doc = " Halt system"]
	pub fn furi_halt(message: *const core::ffi::c_char);
}
extern "C" {
	#[doc = "< System Clock Frequency"]
	pub static mut SystemCoreClock: u32;
}
extern "C" {
	pub fn furi_thread_catch();
}
pub type TaskFunction_t = ::core::option::Option<unsafe extern "C" fn(arg1: *mut core::ffi::c_void)>;
pub type StackType_t = u32;
pub type BaseType_t = core::ffi::c_long;
pub type UBaseType_t = core::ffi::c_ulong;
pub type TickType_t = u32;
extern "C" {
	pub fn vPortEnterCritical();
}
extern "C" {
	pub fn vPortExitCritical();
}
extern "C" {
	pub fn vPortSuppressTicksAndSleep(xExpectedIdleTime: TickType_t);
}
extern "C" {
	pub fn pxPortInitialiseStack(pxTopOfStack: *mut StackType_t,
	                             pxCode: TaskFunction_t,
	                             pvParameters: *mut core::ffi::c_void)
	                             -> *mut StackType_t;
}
#[repr(C)]
pub struct HeapRegion {
	pub pucStartAddress: *mut u8,
	pub xSizeInBytes: usize,
}
#[test]
fn bindgen_test_layout_HeapRegion() {
	assert_eq!(
	           ::core::mem::size_of::<HeapRegion>(),
	           8usize,
	           concat!("Size of: ", stringify!(HeapRegion))
	);
	assert_eq!(
	           ::core::mem::align_of::<HeapRegion>(),
	           4usize,
	           concat!("Alignment of ", stringify!(HeapRegion))
	);
	fn test_field_pucStartAddress() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<HeapRegion>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).pucStartAddress) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(HeapRegion), "::", stringify!(pucStartAddress))
		);
	}
	test_field_pucStartAddress();
	fn test_field_xSizeInBytes() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<HeapRegion>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).xSizeInBytes) as usize - ptr as usize
		           },
		           4usize,
		           concat!("Offset of field: ", stringify!(HeapRegion), "::", stringify!(xSizeInBytes))
		);
	}
	test_field_xSizeInBytes();
}
pub type HeapRegion_t = HeapRegion;
#[repr(C)]
pub struct xHeapStats {
	pub xAvailableHeapSpaceInBytes: usize,
	pub xSizeOfLargestFreeBlockInBytes: usize,
	pub xSizeOfSmallestFreeBlockInBytes: usize,
	pub xNumberOfFreeBlocks: usize,
	pub xMinimumEverFreeBytesRemaining: usize,
	pub xNumberOfSuccessfulAllocations: usize,
	pub xNumberOfSuccessfulFrees: usize,
}
#[test]
fn bindgen_test_layout_xHeapStats() {
	assert_eq!(
	           ::core::mem::size_of::<xHeapStats>(),
	           28usize,
	           concat!("Size of: ", stringify!(xHeapStats))
	);
	assert_eq!(
	           ::core::mem::align_of::<xHeapStats>(),
	           4usize,
	           concat!("Alignment of ", stringify!(xHeapStats))
	);
	fn test_field_xAvailableHeapSpaceInBytes() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<xHeapStats>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).xAvailableHeapSpaceInBytes) as usize - ptr as usize
		           },
		           0usize,
		           concat!(
			"Offset of field: ",
			stringify!(xHeapStats),
			"::",
			stringify!(xAvailableHeapSpaceInBytes)
		)
		);
	}
	test_field_xAvailableHeapSpaceInBytes();
	fn test_field_xSizeOfLargestFreeBlockInBytes() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<xHeapStats>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).xSizeOfLargestFreeBlockInBytes) as usize - ptr as usize
		           },
		           4usize,
		           concat!(
			"Offset of field: ",
			stringify!(xHeapStats),
			"::",
			stringify!(xSizeOfLargestFreeBlockInBytes)
		)
		);
	}
	test_field_xSizeOfLargestFreeBlockInBytes();
	fn test_field_xSizeOfSmallestFreeBlockInBytes() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<xHeapStats>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).xSizeOfSmallestFreeBlockInBytes) as usize - ptr as usize
		           },
		           8usize,
		           concat!(
			"Offset of field: ",
			stringify!(xHeapStats),
			"::",
			stringify!(xSizeOfSmallestFreeBlockInBytes)
		)
		);
	}
	test_field_xSizeOfSmallestFreeBlockInBytes();
	fn test_field_xNumberOfFreeBlocks() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<xHeapStats>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).xNumberOfFreeBlocks) as usize - ptr as usize
		           },
		           12usize,
		           concat!(
			"Offset of field: ",
			stringify!(xHeapStats),
			"::",
			stringify!(xNumberOfFreeBlocks)
		)
		);
	}
	test_field_xNumberOfFreeBlocks();
	fn test_field_xMinimumEverFreeBytesRemaining() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<xHeapStats>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).xMinimumEverFreeBytesRemaining) as usize - ptr as usize
		           },
		           16usize,
		           concat!(
			"Offset of field: ",
			stringify!(xHeapStats),
			"::",
			stringify!(xMinimumEverFreeBytesRemaining)
		)
		);
	}
	test_field_xMinimumEverFreeBytesRemaining();
	fn test_field_xNumberOfSuccessfulAllocations() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<xHeapStats>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).xNumberOfSuccessfulAllocations) as usize - ptr as usize
		           },
		           20usize,
		           concat!(
			"Offset of field: ",
			stringify!(xHeapStats),
			"::",
			stringify!(xNumberOfSuccessfulAllocations)
		)
		);
	}
	test_field_xNumberOfSuccessfulAllocations();
	fn test_field_xNumberOfSuccessfulFrees() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<xHeapStats>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).xNumberOfSuccessfulFrees) as usize - ptr as usize
		           },
		           24usize,
		           concat!(
			"Offset of field: ",
			stringify!(xHeapStats),
			"::",
			stringify!(xNumberOfSuccessfulFrees)
		)
		);
	}
	test_field_xNumberOfSuccessfulFrees();
}
pub type HeapStats_t = xHeapStats;
extern "C" {
	pub fn vPortDefineHeapRegions(pxHeapRegions: *const HeapRegion_t);
}
extern "C" {
	pub fn vPortGetHeapStats(pxHeapStats: *mut HeapStats_t);
}
extern "C" {
	pub fn pvPortMalloc(xSize: usize) -> *mut core::ffi::c_void;
}
extern "C" {
	pub fn vPortFree(pv: *mut core::ffi::c_void);
}
extern "C" {
	pub fn vPortInitialiseBlocks();
}
extern "C" {
	pub fn xPortGetFreeHeapSize() -> usize;
}
extern "C" {
	pub fn xPortGetMinimumEverFreeHeapSize() -> usize;
}
extern "C" {
	pub fn xPortStartScheduler() -> BaseType_t;
}
extern "C" {
	pub fn vPortEndScheduler();
}
#[repr(C)]
pub struct xSTATIC_LIST_ITEM {
	pub xDummy2: TickType_t,
	pub pvDummy3: [*mut core::ffi::c_void; 4usize],
}
#[test]
fn bindgen_test_layout_xSTATIC_LIST_ITEM() {
	assert_eq!(
	           ::core::mem::size_of::<xSTATIC_LIST_ITEM>(),
	           20usize,
	           concat!("Size of: ", stringify!(xSTATIC_LIST_ITEM))
	);
	assert_eq!(
	           ::core::mem::align_of::<xSTATIC_LIST_ITEM>(),
	           4usize,
	           concat!("Alignment of ", stringify!(xSTATIC_LIST_ITEM))
	);
	fn test_field_xDummy2() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<xSTATIC_LIST_ITEM>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).xDummy2) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(xSTATIC_LIST_ITEM), "::", stringify!(xDummy2))
		);
	}
	test_field_xDummy2();
	fn test_field_pvDummy3() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<xSTATIC_LIST_ITEM>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).pvDummy3) as usize - ptr as usize
		           },
		           4usize,
		           concat!("Offset of field: ", stringify!(xSTATIC_LIST_ITEM), "::", stringify!(pvDummy3))
		);
	}
	test_field_pvDummy3();
}
pub type StaticListItem_t = xSTATIC_LIST_ITEM;
#[repr(C)]
pub struct xSTATIC_TCB {
	pub pxDummy1: *mut core::ffi::c_void,
	pub xDummy3: [StaticListItem_t; 2usize],
	pub uxDummy5: UBaseType_t,
	pub pxDummy6: *mut core::ffi::c_void,
	pub ucDummy7: [u8; 16usize],
	pub pxDummy8: *mut core::ffi::c_void,
	pub uxDummy10: [UBaseType_t; 2usize],
	pub uxDummy12: [UBaseType_t; 2usize],
	pub pvDummy15: [*mut core::ffi::c_void; 1usize],
	pub ulDummy18: [u32; 2usize],
	pub ucDummy19: [u8; 2usize],
	pub uxDummy20: u8,
}
#[test]
fn bindgen_test_layout_xSTATIC_TCB() {
	assert_eq!(
	           ::core::mem::size_of::<xSTATIC_TCB>(),
	           104usize,
	           concat!("Size of: ", stringify!(xSTATIC_TCB))
	);
	assert_eq!(
	           ::core::mem::align_of::<xSTATIC_TCB>(),
	           4usize,
	           concat!("Alignment of ", stringify!(xSTATIC_TCB))
	);
	fn test_field_pxDummy1() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<xSTATIC_TCB>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).pxDummy1) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(xSTATIC_TCB), "::", stringify!(pxDummy1))
		);
	}
	test_field_pxDummy1();
	fn test_field_xDummy3() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<xSTATIC_TCB>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).xDummy3) as usize - ptr as usize
		           },
		           4usize,
		           concat!("Offset of field: ", stringify!(xSTATIC_TCB), "::", stringify!(xDummy3))
		);
	}
	test_field_xDummy3();
	fn test_field_uxDummy5() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<xSTATIC_TCB>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).uxDummy5) as usize - ptr as usize
		           },
		           44usize,
		           concat!("Offset of field: ", stringify!(xSTATIC_TCB), "::", stringify!(uxDummy5))
		);
	}
	test_field_uxDummy5();
	fn test_field_pxDummy6() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<xSTATIC_TCB>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).pxDummy6) as usize - ptr as usize
		           },
		           48usize,
		           concat!("Offset of field: ", stringify!(xSTATIC_TCB), "::", stringify!(pxDummy6))
		);
	}
	test_field_pxDummy6();
	fn test_field_ucDummy7() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<xSTATIC_TCB>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).ucDummy7) as usize - ptr as usize
		           },
		           52usize,
		           concat!("Offset of field: ", stringify!(xSTATIC_TCB), "::", stringify!(ucDummy7))
		);
	}
	test_field_ucDummy7();
	fn test_field_pxDummy8() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<xSTATIC_TCB>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).pxDummy8) as usize - ptr as usize
		           },
		           68usize,
		           concat!("Offset of field: ", stringify!(xSTATIC_TCB), "::", stringify!(pxDummy8))
		);
	}
	test_field_pxDummy8();
	fn test_field_uxDummy10() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<xSTATIC_TCB>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).uxDummy10) as usize - ptr as usize
		           },
		           72usize,
		           concat!("Offset of field: ", stringify!(xSTATIC_TCB), "::", stringify!(uxDummy10))
		);
	}
	test_field_uxDummy10();
	fn test_field_uxDummy12() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<xSTATIC_TCB>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).uxDummy12) as usize - ptr as usize
		           },
		           80usize,
		           concat!("Offset of field: ", stringify!(xSTATIC_TCB), "::", stringify!(uxDummy12))
		);
	}
	test_field_uxDummy12();
	fn test_field_pvDummy15() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<xSTATIC_TCB>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).pvDummy15) as usize - ptr as usize
		           },
		           88usize,
		           concat!("Offset of field: ", stringify!(xSTATIC_TCB), "::", stringify!(pvDummy15))
		);
	}
	test_field_pvDummy15();
	fn test_field_ulDummy18() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<xSTATIC_TCB>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).ulDummy18) as usize - ptr as usize
		           },
		           92usize,
		           concat!("Offset of field: ", stringify!(xSTATIC_TCB), "::", stringify!(ulDummy18))
		);
	}
	test_field_ulDummy18();
	fn test_field_ucDummy19() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<xSTATIC_TCB>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).ucDummy19) as usize - ptr as usize
		           },
		           100usize,
		           concat!("Offset of field: ", stringify!(xSTATIC_TCB), "::", stringify!(ucDummy19))
		);
	}
	test_field_ucDummy19();
	fn test_field_uxDummy20() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<xSTATIC_TCB>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).uxDummy20) as usize - ptr as usize
		           },
		           102usize,
		           concat!("Offset of field: ", stringify!(xSTATIC_TCB), "::", stringify!(uxDummy20))
		);
	}
	test_field_uxDummy20();
}
pub type StaticTask_t = xSTATIC_TCB;
#[repr(C)]
pub struct xSTATIC_TIMER {
	pub pvDummy1: *mut core::ffi::c_void,
	pub xDummy2: StaticListItem_t,
	pub xDummy3: TickType_t,
	pub pvDummy5: *mut core::ffi::c_void,
	pub pvDummy6: TaskFunction_t,
	pub uxDummy7: UBaseType_t,
	pub ucDummy8: u8,
}
#[test]
fn bindgen_test_layout_xSTATIC_TIMER() {
	assert_eq!(
	           ::core::mem::size_of::<xSTATIC_TIMER>(),
	           44usize,
	           concat!("Size of: ", stringify!(xSTATIC_TIMER))
	);
	assert_eq!(
	           ::core::mem::align_of::<xSTATIC_TIMER>(),
	           4usize,
	           concat!("Alignment of ", stringify!(xSTATIC_TIMER))
	);
	fn test_field_pvDummy1() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<xSTATIC_TIMER>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).pvDummy1) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(xSTATIC_TIMER), "::", stringify!(pvDummy1))
		);
	}
	test_field_pvDummy1();
	fn test_field_xDummy2() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<xSTATIC_TIMER>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).xDummy2) as usize - ptr as usize
		           },
		           4usize,
		           concat!("Offset of field: ", stringify!(xSTATIC_TIMER), "::", stringify!(xDummy2))
		);
	}
	test_field_xDummy2();
	fn test_field_xDummy3() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<xSTATIC_TIMER>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).xDummy3) as usize - ptr as usize
		           },
		           24usize,
		           concat!("Offset of field: ", stringify!(xSTATIC_TIMER), "::", stringify!(xDummy3))
		);
	}
	test_field_xDummy3();
	fn test_field_pvDummy5() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<xSTATIC_TIMER>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).pvDummy5) as usize - ptr as usize
		           },
		           28usize,
		           concat!("Offset of field: ", stringify!(xSTATIC_TIMER), "::", stringify!(pvDummy5))
		);
	}
	test_field_pvDummy5();
	fn test_field_pvDummy6() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<xSTATIC_TIMER>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).pvDummy6) as usize - ptr as usize
		           },
		           32usize,
		           concat!("Offset of field: ", stringify!(xSTATIC_TIMER), "::", stringify!(pvDummy6))
		);
	}
	test_field_pvDummy6();
	fn test_field_uxDummy7() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<xSTATIC_TIMER>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).uxDummy7) as usize - ptr as usize
		           },
		           36usize,
		           concat!("Offset of field: ", stringify!(xSTATIC_TIMER), "::", stringify!(uxDummy7))
		);
	}
	test_field_uxDummy7();
	fn test_field_ucDummy8() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<xSTATIC_TIMER>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).ucDummy8) as usize - ptr as usize
		           },
		           40usize,
		           concat!("Offset of field: ", stringify!(xSTATIC_TIMER), "::", stringify!(ucDummy8))
		);
	}
	test_field_ucDummy8();
}
pub type StaticTimer_t = xSTATIC_TIMER;
#[repr(C)]
pub struct xLIST_ITEM {
	pub xItemValue: TickType_t,
	pub pxNext: *mut xLIST_ITEM,
	pub pxPrevious: *mut xLIST_ITEM,
	pub pvOwner: *mut core::ffi::c_void,
	pub pxContainer: *mut xLIST,
}
#[test]
fn bindgen_test_layout_xLIST_ITEM() {
	assert_eq!(
	           ::core::mem::size_of::<xLIST_ITEM>(),
	           20usize,
	           concat!("Size of: ", stringify!(xLIST_ITEM))
	);
	assert_eq!(
	           ::core::mem::align_of::<xLIST_ITEM>(),
	           4usize,
	           concat!("Alignment of ", stringify!(xLIST_ITEM))
	);
	fn test_field_xItemValue() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<xLIST_ITEM>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).xItemValue) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(xLIST_ITEM), "::", stringify!(xItemValue))
		);
	}
	test_field_xItemValue();
	fn test_field_pxNext() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<xLIST_ITEM>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).pxNext) as usize - ptr as usize
		           },
		           4usize,
		           concat!("Offset of field: ", stringify!(xLIST_ITEM), "::", stringify!(pxNext))
		);
	}
	test_field_pxNext();
	fn test_field_pxPrevious() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<xLIST_ITEM>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).pxPrevious) as usize - ptr as usize
		           },
		           8usize,
		           concat!("Offset of field: ", stringify!(xLIST_ITEM), "::", stringify!(pxPrevious))
		);
	}
	test_field_pxPrevious();
	fn test_field_pvOwner() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<xLIST_ITEM>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).pvOwner) as usize - ptr as usize
		           },
		           12usize,
		           concat!("Offset of field: ", stringify!(xLIST_ITEM), "::", stringify!(pvOwner))
		);
	}
	test_field_pvOwner();
	fn test_field_pxContainer() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<xLIST_ITEM>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).pxContainer) as usize - ptr as usize
		           },
		           16usize,
		           concat!("Offset of field: ", stringify!(xLIST_ITEM), "::", stringify!(pxContainer))
		);
	}
	test_field_pxContainer();
}
pub type ListItem_t = xLIST_ITEM;
#[repr(C)]
pub struct xMINI_LIST_ITEM {
	pub xItemValue: TickType_t,
	pub pxNext: *mut xLIST_ITEM,
	pub pxPrevious: *mut xLIST_ITEM,
}
#[test]
fn bindgen_test_layout_xMINI_LIST_ITEM() {
	assert_eq!(
	           ::core::mem::size_of::<xMINI_LIST_ITEM>(),
	           12usize,
	           concat!("Size of: ", stringify!(xMINI_LIST_ITEM))
	);
	assert_eq!(
	           ::core::mem::align_of::<xMINI_LIST_ITEM>(),
	           4usize,
	           concat!("Alignment of ", stringify!(xMINI_LIST_ITEM))
	);
	fn test_field_xItemValue() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<xMINI_LIST_ITEM>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).xItemValue) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(xMINI_LIST_ITEM), "::", stringify!(xItemValue))
		);
	}
	test_field_xItemValue();
	fn test_field_pxNext() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<xMINI_LIST_ITEM>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).pxNext) as usize - ptr as usize
		           },
		           4usize,
		           concat!("Offset of field: ", stringify!(xMINI_LIST_ITEM), "::", stringify!(pxNext))
		);
	}
	test_field_pxNext();
	fn test_field_pxPrevious() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<xMINI_LIST_ITEM>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).pxPrevious) as usize - ptr as usize
		           },
		           8usize,
		           concat!("Offset of field: ", stringify!(xMINI_LIST_ITEM), "::", stringify!(pxPrevious))
		);
	}
	test_field_pxPrevious();
}
pub type MiniListItem_t = xMINI_LIST_ITEM;
#[repr(C)]
pub struct xLIST {
	pub uxNumberOfItems: UBaseType_t,
	pub pxIndex: *mut ListItem_t,
	pub xListEnd: MiniListItem_t,
}
#[test]
fn bindgen_test_layout_xLIST() {
	assert_eq!(
	           ::core::mem::size_of::<xLIST>(),
	           20usize,
	           concat!("Size of: ", stringify!(xLIST))
	);
	assert_eq!(
	           ::core::mem::align_of::<xLIST>(),
	           4usize,
	           concat!("Alignment of ", stringify!(xLIST))
	);
	fn test_field_uxNumberOfItems() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<xLIST>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).uxNumberOfItems) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(xLIST), "::", stringify!(uxNumberOfItems))
		);
	}
	test_field_uxNumberOfItems();
	fn test_field_pxIndex() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<xLIST>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).pxIndex) as usize - ptr as usize
		           },
		           4usize,
		           concat!("Offset of field: ", stringify!(xLIST), "::", stringify!(pxIndex))
		);
	}
	test_field_pxIndex();
	fn test_field_xListEnd() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<xLIST>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).xListEnd) as usize - ptr as usize
		           },
		           8usize,
		           concat!("Offset of field: ", stringify!(xLIST), "::", stringify!(xListEnd))
		);
	}
	test_field_xListEnd();
}
pub type List_t = xLIST;
extern "C" {
	pub fn vListInitialise(pxList: *mut List_t);
}
extern "C" {
	pub fn vListInitialiseItem(pxItem: *mut ListItem_t);
}
extern "C" {
	pub fn vListInsert(pxList: *mut List_t, pxNewListItem: *mut ListItem_t);
}
extern "C" {
	pub fn vListInsertEnd(pxList: *mut List_t, pxNewListItem: *mut ListItem_t);
}
extern "C" {
	pub fn uxListRemove(pxItemToRemove: *mut ListItem_t) -> UBaseType_t;
}
#[doc = " task. h"]
#[doc = ""]
#[doc = " Type by which tasks are referenced.  For example, a call to xTaskCreate"]
#[doc = " returns (via a pointer parameter) an TaskHandle_t variable that can then"]
#[doc = " be used as a parameter to vTaskDelete to delete the task."]
#[doc = ""]
#[doc = " \\defgroup TaskHandle_t TaskHandle_t"]
#[doc = " \\ingroup Tasks"]
#[repr(C)]
pub struct tskTaskControlBlock {
	_unused: [u8; 0],
}
pub type TaskHandle_t = *mut tskTaskControlBlock;
#[repr(u32)]
#[non_exhaustive]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum eTaskState {
	eRunning = 0,
	eReady = 1,
	eBlocked = 2,
	eSuspended = 3,
	eDeleted = 4,
	eInvalid = 5,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum eNotifyAction {
	eNoAction = 0,
	eSetBits = 1,
	eIncrement = 2,
	eSetValueWithOverwrite = 3,
	eSetValueWithoutOverwrite = 4,
}
#[repr(C)]
pub struct xTIME_OUT {
	pub xOverflowCount: BaseType_t,
	pub xTimeOnEntering: TickType_t,
}
#[test]
fn bindgen_test_layout_xTIME_OUT() {
	assert_eq!(
	           ::core::mem::size_of::<xTIME_OUT>(),
	           8usize,
	           concat!("Size of: ", stringify!(xTIME_OUT))
	);
	assert_eq!(
	           ::core::mem::align_of::<xTIME_OUT>(),
	           4usize,
	           concat!("Alignment of ", stringify!(xTIME_OUT))
	);
	fn test_field_xOverflowCount() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<xTIME_OUT>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).xOverflowCount) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(xTIME_OUT), "::", stringify!(xOverflowCount))
		);
	}
	test_field_xOverflowCount();
	fn test_field_xTimeOnEntering() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<xTIME_OUT>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).xTimeOnEntering) as usize - ptr as usize
		           },
		           4usize,
		           concat!("Offset of field: ", stringify!(xTIME_OUT), "::", stringify!(xTimeOnEntering))
		);
	}
	test_field_xTimeOnEntering();
}
pub type TimeOut_t = xTIME_OUT;
#[repr(C)]
pub struct xMEMORY_REGION {
	pub pvBaseAddress: *mut core::ffi::c_void,
	pub ulLengthInBytes: u32,
	pub ulParameters: u32,
}
#[test]
fn bindgen_test_layout_xMEMORY_REGION() {
	assert_eq!(
	           ::core::mem::size_of::<xMEMORY_REGION>(),
	           12usize,
	           concat!("Size of: ", stringify!(xMEMORY_REGION))
	);
	assert_eq!(
	           ::core::mem::align_of::<xMEMORY_REGION>(),
	           4usize,
	           concat!("Alignment of ", stringify!(xMEMORY_REGION))
	);
	fn test_field_pvBaseAddress() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<xMEMORY_REGION>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).pvBaseAddress) as usize - ptr as usize
		           },
		           0usize,
		           concat!(
			"Offset of field: ",
			stringify!(xMEMORY_REGION),
			"::",
			stringify!(pvBaseAddress)
		)
		);
	}
	test_field_pvBaseAddress();
	fn test_field_ulLengthInBytes() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<xMEMORY_REGION>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).ulLengthInBytes) as usize - ptr as usize
		           },
		           4usize,
		           concat!(
			"Offset of field: ",
			stringify!(xMEMORY_REGION),
			"::",
			stringify!(ulLengthInBytes)
		)
		);
	}
	test_field_ulLengthInBytes();
	fn test_field_ulParameters() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<xMEMORY_REGION>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).ulParameters) as usize - ptr as usize
		           },
		           8usize,
		           concat!(
			"Offset of field: ",
			stringify!(xMEMORY_REGION),
			"::",
			stringify!(ulParameters)
		)
		);
	}
	test_field_ulParameters();
}
pub type MemoryRegion_t = xMEMORY_REGION;
#[repr(C)]
pub struct xTASK_STATUS {
	pub xHandle: TaskHandle_t,
	pub pcTaskName: *const core::ffi::c_char,
	pub xTaskNumber: UBaseType_t,
	pub eCurrentState: eTaskState,
	pub uxCurrentPriority: UBaseType_t,
	pub uxBasePriority: UBaseType_t,
	pub ulRunTimeCounter: u32,
	pub pxStackBase: *mut StackType_t,
	pub usStackHighWaterMark: u16,
}
#[test]
fn bindgen_test_layout_xTASK_STATUS() {
	assert_eq!(
	           ::core::mem::size_of::<xTASK_STATUS>(),
	           36usize,
	           concat!("Size of: ", stringify!(xTASK_STATUS))
	);
	assert_eq!(
	           ::core::mem::align_of::<xTASK_STATUS>(),
	           4usize,
	           concat!("Alignment of ", stringify!(xTASK_STATUS))
	);
	fn test_field_xHandle() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<xTASK_STATUS>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).xHandle) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(xTASK_STATUS), "::", stringify!(xHandle))
		);
	}
	test_field_xHandle();
	fn test_field_pcTaskName() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<xTASK_STATUS>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).pcTaskName) as usize - ptr as usize
		           },
		           4usize,
		           concat!("Offset of field: ", stringify!(xTASK_STATUS), "::", stringify!(pcTaskName))
		);
	}
	test_field_pcTaskName();
	fn test_field_xTaskNumber() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<xTASK_STATUS>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).xTaskNumber) as usize - ptr as usize
		           },
		           8usize,
		           concat!("Offset of field: ", stringify!(xTASK_STATUS), "::", stringify!(xTaskNumber))
		);
	}
	test_field_xTaskNumber();
	fn test_field_eCurrentState() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<xTASK_STATUS>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).eCurrentState) as usize - ptr as usize
		           },
		           12usize,
		           concat!("Offset of field: ", stringify!(xTASK_STATUS), "::", stringify!(eCurrentState))
		);
	}
	test_field_eCurrentState();
	fn test_field_uxCurrentPriority() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<xTASK_STATUS>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).uxCurrentPriority) as usize - ptr as usize
		           },
		           16usize,
		           concat!(
			"Offset of field: ",
			stringify!(xTASK_STATUS),
			"::",
			stringify!(uxCurrentPriority)
		)
		);
	}
	test_field_uxCurrentPriority();
	fn test_field_uxBasePriority() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<xTASK_STATUS>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).uxBasePriority) as usize - ptr as usize
		           },
		           20usize,
		           concat!(
			"Offset of field: ",
			stringify!(xTASK_STATUS),
			"::",
			stringify!(uxBasePriority)
		)
		);
	}
	test_field_uxBasePriority();
	fn test_field_ulRunTimeCounter() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<xTASK_STATUS>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).ulRunTimeCounter) as usize - ptr as usize
		           },
		           24usize,
		           concat!(
			"Offset of field: ",
			stringify!(xTASK_STATUS),
			"::",
			stringify!(ulRunTimeCounter)
		)
		);
	}
	test_field_ulRunTimeCounter();
	fn test_field_pxStackBase() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<xTASK_STATUS>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).pxStackBase) as usize - ptr as usize
		           },
		           28usize,
		           concat!("Offset of field: ", stringify!(xTASK_STATUS), "::", stringify!(pxStackBase))
		);
	}
	test_field_pxStackBase();
	fn test_field_usStackHighWaterMark() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<xTASK_STATUS>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).usStackHighWaterMark) as usize - ptr as usize
		           },
		           32usize,
		           concat!(
			"Offset of field: ",
			stringify!(xTASK_STATUS),
			"::",
			stringify!(usStackHighWaterMark)
		)
		);
	}
	test_field_usStackHighWaterMark();
}
pub type TaskStatus_t = xTASK_STATUS;
#[repr(u32)]
#[non_exhaustive]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum eSleepModeStatus {
	eAbortSleep = 0,
	eStandardSleep = 1,
	eNoTasksWaitingTimeout = 2,
}
extern "C" {
	pub fn xTaskCreate(pxTaskCode: TaskFunction_t,
	                   pcName: *const core::ffi::c_char,
	                   usStackDepth: u16,
	                   pvParameters: *mut core::ffi::c_void,
	                   uxPriority: UBaseType_t,
	                   pxCreatedTask: *mut TaskHandle_t)
	                   -> BaseType_t;
}
extern "C" {
	pub fn xTaskCreateStatic(pxTaskCode: TaskFunction_t,
	                         pcName: *const core::ffi::c_char,
	                         ulStackDepth: u32,
	                         pvParameters: *mut core::ffi::c_void,
	                         uxPriority: UBaseType_t,
	                         puxStackBuffer: *mut StackType_t,
	                         pxTaskBuffer: *mut StaticTask_t)
	                         -> TaskHandle_t;
}
extern "C" {
	#[doc = " task. h"]
	#[doc = " @code{c}"]
	#[doc = " void vTaskAllocateMPURegions( TaskHandle_t xTask, const MemoryRegion_t * const pxRegions );"]
	#[doc = " @endcode"]
	#[doc = ""]
	#[doc = " Memory regions are assigned to a restricted task when the task is created by"]
	#[doc = " a call to xTaskCreateRestricted().  These regions can be redefined using"]
	#[doc = " vTaskAllocateMPURegions()."]
	#[doc = ""]
	#[doc = " @param xTask The handle of the task being updated."]
	#[doc = ""]
	#[doc = " @param xRegions A pointer to a MemoryRegion_t structure that contains the"]
	#[doc = " new memory region definitions."]
	#[doc = ""]
	#[doc = " Example usage:"]
	#[doc = " @code{c}"]
	#[doc = " // Define an array of MemoryRegion_t structures that configures an MPU region"]
	#[doc = " // allowing read/write access for 1024 bytes starting at the beginning of the"]
	#[doc = " // ucOneKByte array.  The other two of the maximum 3 definable regions are"]
	#[doc = " // unused so set to zero."]
	#[doc = " static const MemoryRegion_t xAltRegions[ portNUM_CONFIGURABLE_REGIONS ] ="]
	#[doc = " {"]
	#[doc = "  // Base address     Length      Parameters"]
	#[doc = "  { ucOneKByte,       1024,       portMPU_REGION_READ_WRITE },"]
	#[doc = "  { 0,                0,          0 },"]
	#[doc = "  { 0,                0,          0 }"]
	#[doc = " };"]
	#[doc = ""]
	#[doc = " void vATask( void *pvParameters )"]
	#[doc = " {"]
	#[doc = "  // This task was created such that it has access to certain regions of"]
	#[doc = "  // memory as defined by the MPU configuration.  At some point it is"]
	#[doc = "  // desired that these MPU regions are replaced with that defined in the"]
	#[doc = "  // xAltRegions const struct above.  Use a call to vTaskAllocateMPURegions()"]
	#[doc = "  // for this purpose.  NULL is used as the task handle to indicate that this"]
	#[doc = "  // function should modify the MPU regions of the calling task."]
	#[doc = "  vTaskAllocateMPURegions( NULL, xAltRegions );"]
	#[doc = ""]
	#[doc = "  // Now the task can continue its function, but from this point on can only"]
	#[doc = "  // access its stack and the ucOneKByte array (unless any other statically"]
	#[doc = "  // defined or shared regions have been declared elsewhere)."]
	#[doc = " }"]
	#[doc = " @endcode"]
	#[doc = " \\defgroup xTaskCreateRestricted xTaskCreateRestricted"]
	#[doc = " \\ingroup Tasks"]
	pub fn vTaskAllocateMPURegions(xTask: TaskHandle_t, pxRegions: *const MemoryRegion_t);
}
extern "C" {
	#[doc = " task. h"]
	#[doc = " @code{c}"]
	#[doc = " void vTaskDelete( TaskHandle_t xTaskToDelete );"]
	#[doc = " @endcode"]
	#[doc = ""]
	#[doc = " INCLUDE_vTaskDelete must be defined as 1 for this function to be available."]
	#[doc = " See the configuration section for more information."]
	#[doc = ""]
	#[doc = " Remove a task from the RTOS real time kernel's management.  The task being"]
	#[doc = " deleted will be removed from all ready, blocked, suspended and event lists."]
	#[doc = ""]
	#[doc = " NOTE:  The idle task is responsible for freeing the kernel allocated"]
	#[doc = " memory from tasks that have been deleted.  It is therefore important that"]
	#[doc = " the idle task is not starved of microcontroller processing time if your"]
	#[doc = " application makes any calls to vTaskDelete ().  Memory allocated by the"]
	#[doc = " task code is not automatically freed, and should be freed before the task"]
	#[doc = " is deleted."]
	#[doc = ""]
	#[doc = " See the demo application file death.c for sample code that utilises"]
	#[doc = " vTaskDelete ()."]
	#[doc = ""]
	#[doc = " @param xTaskToDelete The handle of the task to be deleted.  Passing NULL will"]
	#[doc = " cause the calling task to be deleted."]
	#[doc = ""]
	#[doc = " Example usage:"]
	#[doc = " @code{c}"]
	#[doc = " void vOtherFunction( void )"]
	#[doc = " {"]
	#[doc = " TaskHandle_t xHandle;"]
	#[doc = ""]
	#[doc = "   // Create the task, storing the handle."]
	#[doc = "   xTaskCreate( vTaskCode, \"NAME\", STACK_SIZE, NULL, tskIDLE_PRIORITY, &xHandle );"]
	#[doc = ""]
	#[doc = "   // Use the handle to delete the task."]
	#[doc = "   vTaskDelete( xHandle );"]
	#[doc = " }"]
	#[doc = " @endcode"]
	#[doc = " \\defgroup vTaskDelete vTaskDelete"]
	#[doc = " \\ingroup Tasks"]
	pub fn vTaskDelete(xTaskToDelete: TaskHandle_t);
}
extern "C" {
	#[doc = " task. h"]
	#[doc = " @code{c}"]
	#[doc = " void vTaskDelay( const TickType_t xTicksToDelay );"]
	#[doc = " @endcode"]
	#[doc = ""]
	#[doc = " Delay a task for a given number of ticks.  The actual time that the"]
	#[doc = " task remains blocked depends on the tick rate.  The constant"]
	#[doc = " portTICK_PERIOD_MS can be used to calculate real time from the tick"]
	#[doc = " rate - with the resolution of one tick period."]
	#[doc = ""]
	#[doc = " INCLUDE_vTaskDelay must be defined as 1 for this function to be available."]
	#[doc = " See the configuration section for more information."]
	#[doc = ""]
	#[doc = ""]
	#[doc = " vTaskDelay() specifies a time at which the task wishes to unblock relative to"]
	#[doc = " the time at which vTaskDelay() is called.  For example, specifying a block"]
	#[doc = " period of 100 ticks will cause the task to unblock 100 ticks after"]
	#[doc = " vTaskDelay() is called.  vTaskDelay() does not therefore provide a good method"]
	#[doc = " of controlling the frequency of a periodic task as the path taken through the"]
	#[doc = " code, as well as other task and interrupt activity, will affect the frequency"]
	#[doc = " at which vTaskDelay() gets called and therefore the time at which the task"]
	#[doc = " next executes.  See xTaskDelayUntil() for an alternative API function designed"]
	#[doc = " to facilitate fixed frequency execution.  It does this by specifying an"]
	#[doc = " absolute time (rather than a relative time) at which the calling task should"]
	#[doc = " unblock."]
	#[doc = ""]
	#[doc = " @param xTicksToDelay The amount of time, in tick periods, that"]
	#[doc = " the calling task should block."]
	#[doc = ""]
	#[doc = " Example usage:"]
	#[doc = ""]
	#[doc = " void vTaskFunction( void * pvParameters )"]
	#[doc = " {"]
	#[doc = " // Block for 500ms."]
	#[doc = " const TickType_t xDelay = 500 / portTICK_PERIOD_MS;"]
	#[doc = ""]
	#[doc = "   for( ;; )"]
	#[doc = "   {"]
	#[doc = "       // Simply toggle the LED every 500ms, blocking between each toggle."]
	#[doc = "       vToggleLED();"]
	#[doc = "       vTaskDelay( xDelay );"]
	#[doc = "   }"]
	#[doc = " }"]
	#[doc = ""]
	#[doc = " \\defgroup vTaskDelay vTaskDelay"]
	#[doc = " \\ingroup TaskCtrl"]
	pub fn vTaskDelay(xTicksToDelay: TickType_t);
}
extern "C" {
	#[doc = " task. h"]
	#[doc = " @code{c}"]
	#[doc = " BaseType_t xTaskDelayUntil( TickType_t *pxPreviousWakeTime, const TickType_t xTimeIncrement );"]
	#[doc = " @endcode"]
	#[doc = ""]
	#[doc = " INCLUDE_xTaskDelayUntil must be defined as 1 for this function to be available."]
	#[doc = " See the configuration section for more information."]
	#[doc = ""]
	#[doc = " Delay a task until a specified time.  This function can be used by periodic"]
	#[doc = " tasks to ensure a constant execution frequency."]
	#[doc = ""]
	#[doc = " This function differs from vTaskDelay () in one important aspect:  vTaskDelay () will"]
	#[doc = " cause a task to block for the specified number of ticks from the time vTaskDelay () is"]
	#[doc = " called.  It is therefore difficult to use vTaskDelay () by itself to generate a fixed"]
	#[doc = " execution frequency as the time between a task starting to execute and that task"]
	#[doc = " calling vTaskDelay () may not be fixed [the task may take a different path though the"]
	#[doc = " code between calls, or may get interrupted or preempted a different number of times"]
	#[doc = " each time it executes]."]
	#[doc = ""]
	#[doc = " Whereas vTaskDelay () specifies a wake time relative to the time at which the function"]
	#[doc = " is called, xTaskDelayUntil () specifies the absolute (exact) time at which it wishes to"]
	#[doc = " unblock."]
	#[doc = ""]
	#[doc = " The macro pdMS_TO_TICKS() can be used to calculate the number of ticks from a"]
	#[doc = " time specified in milliseconds with a resolution of one tick period."]
	#[doc = ""]
	#[doc = " @param pxPreviousWakeTime Pointer to a variable that holds the time at which the"]
	#[doc = " task was last unblocked.  The variable must be initialised with the current time"]
	#[doc = " prior to its first use (see the example below).  Following this the variable is"]
	#[doc = " automatically updated within xTaskDelayUntil ()."]
	#[doc = ""]
	#[doc = " @param xTimeIncrement The cycle time period.  The task will be unblocked at"]
	#[doc = " time *pxPreviousWakeTime + xTimeIncrement.  Calling xTaskDelayUntil with the"]
	#[doc = " same xTimeIncrement parameter value will cause the task to execute with"]
	#[doc = " a fixed interface period."]
	#[doc = ""]
	#[doc = " @return Value which can be used to check whether the task was actually delayed."]
	#[doc = " Will be pdTRUE if the task way delayed and pdFALSE otherwise.  A task will not"]
	#[doc = " be delayed if the next expected wake time is in the past."]
	#[doc = ""]
	#[doc = " Example usage:"]
	#[doc = " @code{c}"]
	#[doc = " // Perform an action every 10 ticks."]
	#[doc = " void vTaskFunction( void * pvParameters )"]
	#[doc = " {"]
	#[doc = " TickType_t xLastWakeTime;"]
	#[doc = " const TickType_t xFrequency = 10;"]
	#[doc = " BaseType_t xWasDelayed;"]
	#[doc = ""]
	#[doc = "     // Initialise the xLastWakeTime variable with the current time."]
	#[doc = "     xLastWakeTime = xTaskGetTickCount ();"]
	#[doc = "     for( ;; )"]
	#[doc = "     {"]
	#[doc = "         // Wait for the next cycle."]
	#[doc = "         xWasDelayed = xTaskDelayUntil( &xLastWakeTime, xFrequency );"]
	#[doc = ""]
	#[doc = "         // Perform action here. xWasDelayed value can be used to determine"]
	#[doc = "         // whether a deadline was missed if the code here took too long."]
	#[doc = "     }"]
	#[doc = " }"]
	#[doc = " @endcode"]
	#[doc = " \\defgroup xTaskDelayUntil xTaskDelayUntil"]
	#[doc = " \\ingroup TaskCtrl"]
	pub fn xTaskDelayUntil(pxPreviousWakeTime: *mut TickType_t, xTimeIncrement: TickType_t) -> BaseType_t;
}
extern "C" {
	#[doc = " task. h"]
	#[doc = " @code{c}"]
	#[doc = " BaseType_t xTaskAbortDelay( TaskHandle_t xTask );"]
	#[doc = " @endcode"]
	#[doc = ""]
	#[doc = " INCLUDE_xTaskAbortDelay must be defined as 1 in FreeRTOSConfig.h for this"]
	#[doc = " function to be available."]
	#[doc = ""]
	#[doc = " A task will enter the Blocked state when it is waiting for an event.  The"]
	#[doc = " event it is waiting for can be a temporal event (waiting for a time), such"]
	#[doc = " as when vTaskDelay() is called, or an event on an object, such as when"]
	#[doc = " xQueueReceive() or ulTaskNotifyTake() is called.  If the handle of a task"]
	#[doc = " that is in the Blocked state is used in a call to xTaskAbortDelay() then the"]
	#[doc = " task will leave the Blocked state, and return from whichever function call"]
	#[doc = " placed the task into the Blocked state."]
	#[doc = ""]
	#[doc = " There is no 'FromISR' version of this function as an interrupt would need to"]
	#[doc = " know which object a task was blocked on in order to know which actions to"]
	#[doc = " take.  For example, if the task was blocked on a queue the interrupt handler"]
	#[doc = " would then need to know if the queue was locked."]
	#[doc = ""]
	#[doc = " @param xTask The handle of the task to remove from the Blocked state."]
	#[doc = ""]
	#[doc = " @return If the task referenced by xTask was not in the Blocked state then"]
	#[doc = " pdFAIL is returned.  Otherwise pdPASS is returned."]
	#[doc = ""]
	#[doc = " \\defgroup xTaskAbortDelay xTaskAbortDelay"]
	#[doc = " \\ingroup TaskCtrl"]
	pub fn xTaskAbortDelay(xTask: TaskHandle_t) -> BaseType_t;
}
extern "C" {
	#[doc = " task. h"]
	#[doc = " @code{c}"]
	#[doc = " UBaseType_t uxTaskPriorityGet( const TaskHandle_t xTask );"]
	#[doc = " @endcode"]
	#[doc = ""]
	#[doc = " INCLUDE_uxTaskPriorityGet must be defined as 1 for this function to be available."]
	#[doc = " See the configuration section for more information."]
	#[doc = ""]
	#[doc = " Obtain the priority of any task."]
	#[doc = ""]
	#[doc = " @param xTask Handle of the task to be queried.  Passing a NULL"]
	#[doc = " handle results in the priority of the calling task being returned."]
	#[doc = ""]
	#[doc = " @return The priority of xTask."]
	#[doc = ""]
	#[doc = " Example usage:"]
	#[doc = " @code{c}"]
	#[doc = " void vAFunction( void )"]
	#[doc = " {"]
	#[doc = " TaskHandle_t xHandle;"]
	#[doc = ""]
	#[doc = "   // Create a task, storing the handle."]
	#[doc = "   xTaskCreate( vTaskCode, \"NAME\", STACK_SIZE, NULL, tskIDLE_PRIORITY, &xHandle );"]
	#[doc = ""]
	#[doc = "   // ..."]
	#[doc = ""]
	#[doc = "   // Use the handle to obtain the priority of the created task."]
	#[doc = "   // It was created with tskIDLE_PRIORITY, but may have changed"]
	#[doc = "   // it itself."]
	#[doc = "   if( uxTaskPriorityGet( xHandle ) != tskIDLE_PRIORITY )"]
	#[doc = "   {"]
	#[doc = "       // The task has changed it's priority."]
	#[doc = "   }"]
	#[doc = ""]
	#[doc = "   // ..."]
	#[doc = ""]
	#[doc = "   // Is our priority higher than the created task?"]
	#[doc = "   if( uxTaskPriorityGet( xHandle ) < uxTaskPriorityGet( NULL ) )"]
	#[doc = "   {"]
	#[doc = "       // Our priority (obtained using NULL handle) is higher."]
	#[doc = "   }"]
	#[doc = " }"]
	#[doc = " @endcode"]
	#[doc = " \\defgroup uxTaskPriorityGet uxTaskPriorityGet"]
	#[doc = " \\ingroup TaskCtrl"]
	pub fn uxTaskPriorityGet(xTask: TaskHandle_t) -> UBaseType_t;
}
extern "C" {
	#[doc = " task. h"]
	#[doc = " @code{c}"]
	#[doc = " UBaseType_t uxTaskPriorityGetFromISR( const TaskHandle_t xTask );"]
	#[doc = " @endcode"]
	#[doc = ""]
	#[doc = " A version of uxTaskPriorityGet() that can be used from an ISR."]
	pub fn uxTaskPriorityGetFromISR(xTask: TaskHandle_t) -> UBaseType_t;
}
extern "C" {
	#[doc = " task. h"]
	#[doc = " @code{c}"]
	#[doc = " eTaskState eTaskGetState( TaskHandle_t xTask );"]
	#[doc = " @endcode"]
	#[doc = ""]
	#[doc = " INCLUDE_eTaskGetState must be defined as 1 for this function to be available."]
	#[doc = " See the configuration section for more information."]
	#[doc = ""]
	#[doc = " Obtain the state of any task.  States are encoded by the eTaskState"]
	#[doc = " enumerated type."]
	#[doc = ""]
	#[doc = " @param xTask Handle of the task to be queried."]
	#[doc = ""]
	#[doc = " @return The state of xTask at the time the function was called.  Note the"]
	#[doc = " state of the task might change between the function being called, and the"]
	#[doc = " functions return value being tested by the calling task."]
	pub fn eTaskGetState(xTask: TaskHandle_t) -> eTaskState;
}
extern "C" {
	#[doc = " task. h"]
	#[doc = " @code{c}"]
	#[doc = " void vTaskGetInfo( TaskHandle_t xTask, TaskStatus_t *pxTaskStatus, BaseType_t xGetFreeStackSpace, eTaskState eState );"]
	#[doc = " @endcode"]
	#[doc = ""]
	#[doc = " configUSE_TRACE_FACILITY must be defined as 1 for this function to be"]
	#[doc = " available.  See the configuration section for more information."]
	#[doc = ""]
	#[doc = " Populates a TaskStatus_t structure with information about a task."]
	#[doc = ""]
	#[doc = " @param xTask Handle of the task being queried.  If xTask is NULL then"]
	#[doc = " information will be returned about the calling task."]
	#[doc = ""]
	#[doc = " @param pxTaskStatus A pointer to the TaskStatus_t structure that will be"]
	#[doc = " filled with information about the task referenced by the handle passed using"]
	#[doc = " the xTask parameter."]
	#[doc = ""]
	#[doc = " @xGetFreeStackSpace The TaskStatus_t structure contains a member to report"]
	#[doc = " the stack high water mark of the task being queried.  Calculating the stack"]
	#[doc = " high water mark takes a relatively long time, and can make the system"]
	#[doc = " temporarily unresponsive - so the xGetFreeStackSpace parameter is provided to"]
	#[doc = " allow the high water mark checking to be skipped.  The high watermark value"]
	#[doc = " will only be written to the TaskStatus_t structure if xGetFreeStackSpace is"]
	#[doc = " not set to pdFALSE;"]
	#[doc = ""]
	#[doc = " @param eState The TaskStatus_t structure contains a member to report the"]
	#[doc = " state of the task being queried.  Obtaining the task state is not as fast as"]
	#[doc = " a simple assignment - so the eState parameter is provided to allow the state"]
	#[doc = " information to be omitted from the TaskStatus_t structure.  To obtain state"]
	#[doc = " information then set eState to eInvalid - otherwise the value passed in"]
	#[doc = " eState will be reported as the task state in the TaskStatus_t structure."]
	#[doc = ""]
	#[doc = " Example usage:"]
	#[doc = " @code{c}"]
	#[doc = " void vAFunction( void )"]
	#[doc = " {"]
	#[doc = " TaskHandle_t xHandle;"]
	#[doc = " TaskStatus_t xTaskDetails;"]
	#[doc = ""]
	#[doc = "  // Obtain the handle of a task from its name."]
	#[doc = "  xHandle = xTaskGetHandle( \"Task_Name\" );"]
	#[doc = ""]
	#[doc = "  // Check the handle is not NULL."]
	#[doc = "  configASSERT( xHandle );"]
	#[doc = ""]
	#[doc = "  // Use the handle to obtain further information about the task."]
	#[doc = "  vTaskGetInfo( xHandle,"]
	#[doc = "                &xTaskDetails,"]
	#[doc = "                pdTRUE, // Include the high water mark in xTaskDetails."]
	#[doc = "                eInvalid ); // Include the task state in xTaskDetails."]
	#[doc = " }"]
	#[doc = " @endcode"]
	#[doc = " \\defgroup vTaskGetInfo vTaskGetInfo"]
	#[doc = " \\ingroup TaskCtrl"]
	pub fn vTaskGetInfo(xTask: TaskHandle_t, pxTaskStatus: *mut TaskStatus_t, xGetFreeStackSpace: BaseType_t, eState: eTaskState);
}
extern "C" {
	#[doc = " task. h"]
	#[doc = " @code{c}"]
	#[doc = " void vTaskPrioritySet( TaskHandle_t xTask, UBaseType_t uxNewPriority );"]
	#[doc = " @endcode"]
	#[doc = ""]
	#[doc = " INCLUDE_vTaskPrioritySet must be defined as 1 for this function to be available."]
	#[doc = " See the configuration section for more information."]
	#[doc = ""]
	#[doc = " Set the priority of any task."]
	#[doc = ""]
	#[doc = " A context switch will occur before the function returns if the priority"]
	#[doc = " being set is higher than the currently executing task."]
	#[doc = ""]
	#[doc = " @param xTask Handle to the task for which the priority is being set."]
	#[doc = " Passing a NULL handle results in the priority of the calling task being set."]
	#[doc = ""]
	#[doc = " @param uxNewPriority The priority to which the task will be set."]
	#[doc = ""]
	#[doc = " Example usage:"]
	#[doc = " @code{c}"]
	#[doc = " void vAFunction( void )"]
	#[doc = " {"]
	#[doc = " TaskHandle_t xHandle;"]
	#[doc = ""]
	#[doc = "   // Create a task, storing the handle."]
	#[doc = "   xTaskCreate( vTaskCode, \"NAME\", STACK_SIZE, NULL, tskIDLE_PRIORITY, &xHandle );"]
	#[doc = ""]
	#[doc = "   // ..."]
	#[doc = ""]
	#[doc = "   // Use the handle to raise the priority of the created task."]
	#[doc = "   vTaskPrioritySet( xHandle, tskIDLE_PRIORITY + 1 );"]
	#[doc = ""]
	#[doc = "   // ..."]
	#[doc = ""]
	#[doc = "   // Use a NULL handle to raise our priority to the same value."]
	#[doc = "   vTaskPrioritySet( NULL, tskIDLE_PRIORITY + 1 );"]
	#[doc = " }"]
	#[doc = " @endcode"]
	#[doc = " \\defgroup vTaskPrioritySet vTaskPrioritySet"]
	#[doc = " \\ingroup TaskCtrl"]
	pub fn vTaskPrioritySet(xTask: TaskHandle_t, uxNewPriority: UBaseType_t);
}
extern "C" {
	#[doc = " task. h"]
	#[doc = " @code{c}"]
	#[doc = " void vTaskSuspend( TaskHandle_t xTaskToSuspend );"]
	#[doc = " @endcode"]
	#[doc = ""]
	#[doc = " INCLUDE_vTaskSuspend must be defined as 1 for this function to be available."]
	#[doc = " See the configuration section for more information."]
	#[doc = ""]
	#[doc = " Suspend any task.  When suspended a task will never get any microcontroller"]
	#[doc = " processing time, no matter what its priority."]
	#[doc = ""]
	#[doc = " Calls to vTaskSuspend are not accumulative -"]
	#[doc = " i.e. calling vTaskSuspend () twice on the same task still only requires one"]
	#[doc = " call to vTaskResume () to ready the suspended task."]
	#[doc = ""]
	#[doc = " @param xTaskToSuspend Handle to the task being suspended.  Passing a NULL"]
	#[doc = " handle will cause the calling task to be suspended."]
	#[doc = ""]
	#[doc = " Example usage:"]
	#[doc = " @code{c}"]
	#[doc = " void vAFunction( void )"]
	#[doc = " {"]
	#[doc = " TaskHandle_t xHandle;"]
	#[doc = ""]
	#[doc = "   // Create a task, storing the handle."]
	#[doc = "   xTaskCreate( vTaskCode, \"NAME\", STACK_SIZE, NULL, tskIDLE_PRIORITY, &xHandle );"]
	#[doc = ""]
	#[doc = "   // ..."]
	#[doc = ""]
	#[doc = "   // Use the handle to suspend the created task."]
	#[doc = "   vTaskSuspend( xHandle );"]
	#[doc = ""]
	#[doc = "   // ..."]
	#[doc = ""]
	#[doc = "   // The created task will not run during this period, unless"]
	#[doc = "   // another task calls vTaskResume( xHandle )."]
	#[doc = ""]
	#[doc = "   //..."]
	#[doc = ""]
	#[doc = ""]
	#[doc = "   // Suspend ourselves."]
	#[doc = "   vTaskSuspend( NULL );"]
	#[doc = ""]
	#[doc = "   // We cannot get here unless another task calls vTaskResume"]
	#[doc = "   // with our handle as the parameter."]
	#[doc = " }"]
	#[doc = " @endcode"]
	#[doc = " \\defgroup vTaskSuspend vTaskSuspend"]
	#[doc = " \\ingroup TaskCtrl"]
	pub fn vTaskSuspend(xTaskToSuspend: TaskHandle_t);
}
extern "C" {
	#[doc = " task. h"]
	#[doc = " @code{c}"]
	#[doc = " void vTaskResume( TaskHandle_t xTaskToResume );"]
	#[doc = " @endcode"]
	#[doc = ""]
	#[doc = " INCLUDE_vTaskSuspend must be defined as 1 for this function to be available."]
	#[doc = " See the configuration section for more information."]
	#[doc = ""]
	#[doc = " Resumes a suspended task."]
	#[doc = ""]
	#[doc = " A task that has been suspended by one or more calls to vTaskSuspend ()"]
	#[doc = " will be made available for running again by a single call to"]
	#[doc = " vTaskResume ()."]
	#[doc = ""]
	#[doc = " @param xTaskToResume Handle to the task being readied."]
	#[doc = ""]
	#[doc = " Example usage:"]
	#[doc = " @code{c}"]
	#[doc = " void vAFunction( void )"]
	#[doc = " {"]
	#[doc = " TaskHandle_t xHandle;"]
	#[doc = ""]
	#[doc = "   // Create a task, storing the handle."]
	#[doc = "   xTaskCreate( vTaskCode, \"NAME\", STACK_SIZE, NULL, tskIDLE_PRIORITY, &xHandle );"]
	#[doc = ""]
	#[doc = "   // ..."]
	#[doc = ""]
	#[doc = "   // Use the handle to suspend the created task."]
	#[doc = "   vTaskSuspend( xHandle );"]
	#[doc = ""]
	#[doc = "   // ..."]
	#[doc = ""]
	#[doc = "   // The created task will not run during this period, unless"]
	#[doc = "   // another task calls vTaskResume( xHandle )."]
	#[doc = ""]
	#[doc = "   //..."]
	#[doc = ""]
	#[doc = ""]
	#[doc = "   // Resume the suspended task ourselves."]
	#[doc = "   vTaskResume( xHandle );"]
	#[doc = ""]
	#[doc = "   // The created task will once again get microcontroller processing"]
	#[doc = "   // time in accordance with its priority within the system."]
	#[doc = " }"]
	#[doc = " @endcode"]
	#[doc = " \\defgroup vTaskResume vTaskResume"]
	#[doc = " \\ingroup TaskCtrl"]
	pub fn vTaskResume(xTaskToResume: TaskHandle_t);
}
extern "C" {
	#[doc = " task. h"]
	#[doc = " @code{c}"]
	#[doc = " void xTaskResumeFromISR( TaskHandle_t xTaskToResume );"]
	#[doc = " @endcode"]
	#[doc = ""]
	#[doc = " INCLUDE_xTaskResumeFromISR must be defined as 1 for this function to be"]
	#[doc = " available.  See the configuration section for more information."]
	#[doc = ""]
	#[doc = " An implementation of vTaskResume() that can be called from within an ISR."]
	#[doc = ""]
	#[doc = " A task that has been suspended by one or more calls to vTaskSuspend ()"]
	#[doc = " will be made available for running again by a single call to"]
	#[doc = " xTaskResumeFromISR ()."]
	#[doc = ""]
	#[doc = " xTaskResumeFromISR() should not be used to synchronise a task with an"]
	#[doc = " interrupt if there is a chance that the interrupt could arrive prior to the"]
	#[doc = " task being suspended - as this can lead to interrupts being missed. Use of a"]
	#[doc = " semaphore as a synchronisation mechanism would avoid this eventuality."]
	#[doc = ""]
	#[doc = " @param xTaskToResume Handle to the task being readied."]
	#[doc = ""]
	#[doc = " @return pdTRUE if resuming the task should result in a context switch,"]
	#[doc = " otherwise pdFALSE. This is used by the ISR to determine if a context switch"]
	#[doc = " may be required following the ISR."]
	#[doc = ""]
	#[doc = " \\defgroup vTaskResumeFromISR vTaskResumeFromISR"]
	#[doc = " \\ingroup TaskCtrl"]
	pub fn xTaskResumeFromISR(xTaskToResume: TaskHandle_t) -> BaseType_t;
}
extern "C" {
	#[doc = " task. h"]
	#[doc = " @code{c}"]
	#[doc = " void vTaskStartScheduler( void );"]
	#[doc = " @endcode"]
	#[doc = ""]
	#[doc = " Starts the real time kernel tick processing.  After calling the kernel"]
	#[doc = " has control over which tasks are executed and when."]
	#[doc = ""]
	#[doc = " See the demo application file main.c for an example of creating"]
	#[doc = " tasks and starting the kernel."]
	#[doc = ""]
	#[doc = " Example usage:"]
	#[doc = " @code{c}"]
	#[doc = " void vAFunction( void )"]
	#[doc = " {"]
	#[doc = "   // Create at least one task before starting the kernel."]
	#[doc = "   xTaskCreate( vTaskCode, \"NAME\", STACK_SIZE, NULL, tskIDLE_PRIORITY, NULL );"]
	#[doc = ""]
	#[doc = "   // Start the real time kernel with preemption."]
	#[doc = "   vTaskStartScheduler ();"]
	#[doc = ""]
	#[doc = "   // Will not get here unless a task calls vTaskEndScheduler ()"]
	#[doc = " }"]
	#[doc = " @endcode"]
	#[doc = ""]
	#[doc = " \\defgroup vTaskStartScheduler vTaskStartScheduler"]
	#[doc = " \\ingroup SchedulerControl"]
	pub fn vTaskStartScheduler();
}
extern "C" {
	#[doc = " task. h"]
	#[doc = " @code{c}"]
	#[doc = " void vTaskEndScheduler( void );"]
	#[doc = " @endcode"]
	#[doc = ""]
	#[doc = " NOTE:  At the time of writing only the x86 real mode port, which runs on a PC"]
	#[doc = " in place of DOS, implements this function."]
	#[doc = ""]
	#[doc = " Stops the real time kernel tick.  All created tasks will be automatically"]
	#[doc = " deleted and multitasking (either preemptive or cooperative) will"]
	#[doc = " stop.  Execution then resumes from the point where vTaskStartScheduler ()"]
	#[doc = " was called, as if vTaskStartScheduler () had just returned."]
	#[doc = ""]
	#[doc = " See the demo application file main. c in the demo/PC directory for an"]
	#[doc = " example that uses vTaskEndScheduler ()."]
	#[doc = ""]
	#[doc = " vTaskEndScheduler () requires an exit function to be defined within the"]
	#[doc = " portable layer (see vPortEndScheduler () in port. c for the PC port).  This"]
	#[doc = " performs hardware specific operations such as stopping the kernel tick."]
	#[doc = ""]
	#[doc = " vTaskEndScheduler () will cause all of the resources allocated by the"]
	#[doc = " kernel to be freed - but will not free resources allocated by application"]
	#[doc = " tasks."]
	#[doc = ""]
	#[doc = " Example usage:"]
	#[doc = " @code{c}"]
	#[doc = " void vTaskCode( void * pvParameters )"]
	#[doc = " {"]
	#[doc = "   for( ;; )"]
	#[doc = "   {"]
	#[doc = "       // Task code goes here."]
	#[doc = ""]
	#[doc = "       // At some point we want to end the real time kernel processing"]
	#[doc = "       // so call ..."]
	#[doc = "       vTaskEndScheduler ();"]
	#[doc = "   }"]
	#[doc = " }"]
	#[doc = ""]
	#[doc = " void vAFunction( void )"]
	#[doc = " {"]
	#[doc = "   // Create at least one task before starting the kernel."]
	#[doc = "   xTaskCreate( vTaskCode, \"NAME\", STACK_SIZE, NULL, tskIDLE_PRIORITY, NULL );"]
	#[doc = ""]
	#[doc = "   // Start the real time kernel with preemption."]
	#[doc = "   vTaskStartScheduler ();"]
	#[doc = ""]
	#[doc = "   // Will only get here when the vTaskCode () task has called"]
	#[doc = "   // vTaskEndScheduler ().  When we get here we are back to single task"]
	#[doc = "   // execution."]
	#[doc = " }"]
	#[doc = " @endcode"]
	#[doc = ""]
	#[doc = " \\defgroup vTaskEndScheduler vTaskEndScheduler"]
	#[doc = " \\ingroup SchedulerControl"]
	pub fn vTaskEndScheduler();
}
extern "C" {
	#[doc = " task. h"]
	#[doc = " @code{c}"]
	#[doc = " void vTaskSuspendAll( void );"]
	#[doc = " @endcode"]
	#[doc = ""]
	#[doc = " Suspends the scheduler without disabling interrupts.  Context switches will"]
	#[doc = " not occur while the scheduler is suspended."]
	#[doc = ""]
	#[doc = " After calling vTaskSuspendAll () the calling task will continue to execute"]
	#[doc = " without risk of being swapped out until a call to xTaskResumeAll () has been"]
	#[doc = " made."]
	#[doc = ""]
	#[doc = " API functions that have the potential to cause a context switch (for example,"]
	#[doc = " xTaskDelayUntil(), xQueueSend(), etc.) must not be called while the scheduler"]
	#[doc = " is suspended."]
	#[doc = ""]
	#[doc = " Example usage:"]
	#[doc = " @code{c}"]
	#[doc = " void vTask1( void * pvParameters )"]
	#[doc = " {"]
	#[doc = "   for( ;; )"]
	#[doc = "   {"]
	#[doc = "       // Task code goes here."]
	#[doc = ""]
	#[doc = "       // ..."]
	#[doc = ""]
	#[doc = "       // At some point the task wants to perform a long operation during"]
	#[doc = "       // which it does not want to get swapped out.  It cannot use"]
	#[doc = "       // taskENTER_CRITICAL ()/taskEXIT_CRITICAL () as the length of the"]
	#[doc = "       // operation may cause interrupts to be missed - including the"]
	#[doc = "       // ticks."]
	#[doc = ""]
	#[doc = "       // Prevent the real time kernel swapping out the task."]
	#[doc = "       vTaskSuspendAll ();"]
	#[doc = ""]
	#[doc = "       // Perform the operation here.  There is no need to use critical"]
	#[doc = "       // sections as we have all the microcontroller processing time."]
	#[doc = "       // During this time interrupts will still operate and the kernel"]
	#[doc = "       // tick count will be maintained."]
	#[doc = ""]
	#[doc = "       // ..."]
	#[doc = ""]
	#[doc = "       // The operation is complete.  Restart the kernel."]
	#[doc = "       xTaskResumeAll ();"]
	#[doc = "   }"]
	#[doc = " }"]
	#[doc = " @endcode"]
	#[doc = " \\defgroup vTaskSuspendAll vTaskSuspendAll"]
	#[doc = " \\ingroup SchedulerControl"]
	pub fn vTaskSuspendAll();
}
extern "C" {
	#[doc = " task. h"]
	#[doc = " @code{c}"]
	#[doc = " BaseType_t xTaskResumeAll( void );"]
	#[doc = " @endcode"]
	#[doc = ""]
	#[doc = " Resumes scheduler activity after it was suspended by a call to"]
	#[doc = " vTaskSuspendAll()."]
	#[doc = ""]
	#[doc = " xTaskResumeAll() only resumes the scheduler.  It does not unsuspend tasks"]
	#[doc = " that were previously suspended by a call to vTaskSuspend()."]
	#[doc = ""]
	#[doc = " @return If resuming the scheduler caused a context switch then pdTRUE is"]
	#[doc = "         returned, otherwise pdFALSE is returned."]
	#[doc = ""]
	#[doc = " Example usage:"]
	#[doc = " @code{c}"]
	#[doc = " void vTask1( void * pvParameters )"]
	#[doc = " {"]
	#[doc = "   for( ;; )"]
	#[doc = "   {"]
	#[doc = "       // Task code goes here."]
	#[doc = ""]
	#[doc = "       // ..."]
	#[doc = ""]
	#[doc = "       // At some point the task wants to perform a long operation during"]
	#[doc = "       // which it does not want to get swapped out.  It cannot use"]
	#[doc = "       // taskENTER_CRITICAL ()/taskEXIT_CRITICAL () as the length of the"]
	#[doc = "       // operation may cause interrupts to be missed - including the"]
	#[doc = "       // ticks."]
	#[doc = ""]
	#[doc = "       // Prevent the real time kernel swapping out the task."]
	#[doc = "       vTaskSuspendAll ();"]
	#[doc = ""]
	#[doc = "       // Perform the operation here.  There is no need to use critical"]
	#[doc = "       // sections as we have all the microcontroller processing time."]
	#[doc = "       // During this time interrupts will still operate and the real"]
	#[doc = "       // time kernel tick count will be maintained."]
	#[doc = ""]
	#[doc = "       // ..."]
	#[doc = ""]
	#[doc = "       // The operation is complete.  Restart the kernel.  We want to force"]
	#[doc = "       // a context switch - but there is no point if resuming the scheduler"]
	#[doc = "       // caused a context switch already."]
	#[doc = "       if( !xTaskResumeAll () )"]
	#[doc = "       {"]
	#[doc = "            taskYIELD ();"]
	#[doc = "       }"]
	#[doc = "   }"]
	#[doc = " }"]
	#[doc = " @endcode"]
	#[doc = " \\defgroup xTaskResumeAll xTaskResumeAll"]
	#[doc = " \\ingroup SchedulerControl"]
	pub fn xTaskResumeAll() -> BaseType_t;
}
extern "C" {
	#[doc = " task. h"]
	#[doc = " @code{c}"]
	#[doc = " TickType_t xTaskGetTickCount( void );"]
	#[doc = " @endcode"]
	#[doc = ""]
	#[doc = " @return The count of ticks since vTaskStartScheduler was called."]
	#[doc = ""]
	#[doc = " \\defgroup xTaskGetTickCount xTaskGetTickCount"]
	#[doc = " \\ingroup TaskUtils"]
	pub fn xTaskGetTickCount() -> TickType_t;
}
extern "C" {
	#[doc = " task. h"]
	#[doc = " @code{c}"]
	#[doc = " TickType_t xTaskGetTickCountFromISR( void );"]
	#[doc = " @endcode"]
	#[doc = ""]
	#[doc = " @return The count of ticks since vTaskStartScheduler was called."]
	#[doc = ""]
	#[doc = " This is a version of xTaskGetTickCount() that is safe to be called from an"]
	#[doc = " ISR - provided that TickType_t is the natural word size of the"]
	#[doc = " microcontroller being used or interrupt nesting is either not supported or"]
	#[doc = " not being used."]
	#[doc = ""]
	#[doc = " \\defgroup xTaskGetTickCountFromISR xTaskGetTickCountFromISR"]
	#[doc = " \\ingroup TaskUtils"]
	pub fn xTaskGetTickCountFromISR() -> TickType_t;
}
extern "C" {
	#[doc = " task. h"]
	#[doc = " @code{c}"]
	#[doc = " uint16_t uxTaskGetNumberOfTasks( void );"]
	#[doc = " @endcode"]
	#[doc = ""]
	#[doc = " @return The number of tasks that the real time kernel is currently managing."]
	#[doc = " This includes all ready, blocked and suspended tasks.  A task that"]
	#[doc = " has been deleted but not yet freed by the idle task will also be"]
	#[doc = " included in the count."]
	#[doc = ""]
	#[doc = " \\defgroup uxTaskGetNumberOfTasks uxTaskGetNumberOfTasks"]
	#[doc = " \\ingroup TaskUtils"]
	pub fn uxTaskGetNumberOfTasks() -> UBaseType_t;
}
extern "C" {
	#[doc = " task. h"]
	#[doc = " @code{c}"]
	#[doc = " char *pcTaskGetName( TaskHandle_t xTaskToQuery );"]
	#[doc = " @endcode"]
	#[doc = ""]
	#[doc = " @return The text (human readable) name of the task referenced by the handle"]
	#[doc = " xTaskToQuery.  A task can query its own name by either passing in its own"]
	#[doc = " handle, or by setting xTaskToQuery to NULL."]
	#[doc = ""]
	#[doc = " \\defgroup pcTaskGetName pcTaskGetName"]
	#[doc = " \\ingroup TaskUtils"]
	pub fn pcTaskGetName(xTaskToQuery: TaskHandle_t) -> *mut core::ffi::c_char;
}
extern "C" {
	#[doc = " task. h"]
	#[doc = " @code{c}"]
	#[doc = " TaskHandle_t xTaskGetHandle( const char *pcNameToQuery );"]
	#[doc = " @endcode"]
	#[doc = ""]
	#[doc = " NOTE:  This function takes a relatively long time to complete and should be"]
	#[doc = " used sparingly."]
	#[doc = ""]
	#[doc = " @return The handle of the task that has the human readable name pcNameToQuery."]
	#[doc = " NULL is returned if no matching name is found.  INCLUDE_xTaskGetHandle"]
	#[doc = " must be set to 1 in FreeRTOSConfig.h for pcTaskGetHandle() to be available."]
	#[doc = ""]
	#[doc = " \\defgroup pcTaskGetHandle pcTaskGetHandle"]
	#[doc = " \\ingroup TaskUtils"]
	pub fn xTaskGetHandle(pcNameToQuery: *const core::ffi::c_char) -> TaskHandle_t;
}
extern "C" {
	#[doc = " task.h"]
	#[doc = " @code{c}"]
	#[doc = " UBaseType_t uxTaskGetStackHighWaterMark( TaskHandle_t xTask );"]
	#[doc = " @endcode"]
	#[doc = ""]
	#[doc = " INCLUDE_uxTaskGetStackHighWaterMark must be set to 1 in FreeRTOSConfig.h for"]
	#[doc = " this function to be available."]
	#[doc = ""]
	#[doc = " Returns the high water mark of the stack associated with xTask.  That is,"]
	#[doc = " the minimum free stack space there has been (in words, so on a 32 bit machine"]
	#[doc = " a value of 1 means 4 bytes) since the task started.  The smaller the returned"]
	#[doc = " number the closer the task has come to overflowing its stack."]
	#[doc = ""]
	#[doc = " uxTaskGetStackHighWaterMark() and uxTaskGetStackHighWaterMark2() are the"]
	#[doc = " same except for their return type.  Using configSTACK_DEPTH_TYPE allows the"]
	#[doc = " user to determine the return type.  It gets around the problem of the value"]
	#[doc = " overflowing on 8-bit types without breaking backward compatibility for"]
	#[doc = " applications that expect an 8-bit return type."]
	#[doc = ""]
	#[doc = " @param xTask Handle of the task associated with the stack to be checked."]
	#[doc = " Set xTask to NULL to check the stack of the calling task."]
	#[doc = ""]
	#[doc = " @return The smallest amount of free stack space there has been (in words, so"]
	#[doc = " actual spaces on the stack rather than bytes) since the task referenced by"]
	#[doc = " xTask was created."]
	pub fn uxTaskGetStackHighWaterMark(xTask: TaskHandle_t) -> UBaseType_t;
}
extern "C" {
	#[doc = " task.h"]
	#[doc = " @code{c}"]
	#[doc = " configSTACK_DEPTH_TYPE uxTaskGetStackHighWaterMark2( TaskHandle_t xTask );"]
	#[doc = " @endcode"]
	#[doc = ""]
	#[doc = " INCLUDE_uxTaskGetStackHighWaterMark2 must be set to 1 in FreeRTOSConfig.h for"]
	#[doc = " this function to be available."]
	#[doc = ""]
	#[doc = " Returns the high water mark of the stack associated with xTask.  That is,"]
	#[doc = " the minimum free stack space there has been (in words, so on a 32 bit machine"]
	#[doc = " a value of 1 means 4 bytes) since the task started.  The smaller the returned"]
	#[doc = " number the closer the task has come to overflowing its stack."]
	#[doc = ""]
	#[doc = " uxTaskGetStackHighWaterMark() and uxTaskGetStackHighWaterMark2() are the"]
	#[doc = " same except for their return type.  Using configSTACK_DEPTH_TYPE allows the"]
	#[doc = " user to determine the return type.  It gets around the problem of the value"]
	#[doc = " overflowing on 8-bit types without breaking backward compatibility for"]
	#[doc = " applications that expect an 8-bit return type."]
	#[doc = ""]
	#[doc = " @param xTask Handle of the task associated with the stack to be checked."]
	#[doc = " Set xTask to NULL to check the stack of the calling task."]
	#[doc = ""]
	#[doc = " @return The smallest amount of free stack space there has been (in words, so"]
	#[doc = " actual spaces on the stack rather than bytes) since the task referenced by"]
	#[doc = " xTask was created."]
	pub fn uxTaskGetStackHighWaterMark2(xTask: TaskHandle_t) -> u16;
}
extern "C" {
	pub fn vTaskSetThreadLocalStoragePointer(xTaskToSet: TaskHandle_t, xIndex: BaseType_t, pvValue: *mut core::ffi::c_void);
}
extern "C" {
	pub fn pvTaskGetThreadLocalStoragePointer(xTaskToQuery: TaskHandle_t, xIndex: BaseType_t) -> *mut core::ffi::c_void;
}
extern "C" {
	#[doc = " task.h"]
	#[doc = " @code{c}"]
	#[doc = " void vApplicationGetIdleTaskMemory( StaticTask_t ** ppxIdleTaskTCBBuffer, StackType_t ** ppxIdleTaskStackBuffer, uint32_t *pulIdleTaskStackSize )"]
	#[doc = " @endcode"]
	#[doc = ""]
	#[doc = " This function is used to provide a statically allocated block of memory to FreeRTOS to hold the Idle Task TCB.  This function is required when"]
	#[doc = " configSUPPORT_STATIC_ALLOCATION is set.  For more information see this URI: https://www.FreeRTOS.org/a00110.html#configSUPPORT_STATIC_ALLOCATION"]
	#[doc = ""]
	#[doc = " @param ppxIdleTaskTCBBuffer A handle to a statically allocated TCB buffer"]
	#[doc = " @param ppxIdleTaskStackBuffer A handle to a statically allocated Stack buffer for the idle task"]
	#[doc = " @param pulIdleTaskStackSize A pointer to the number of elements that will fit in the allocated stack buffer"]
	pub fn vApplicationGetIdleTaskMemory(ppxIdleTaskTCBBuffer: *mut *mut StaticTask_t,
	                                     ppxIdleTaskStackBuffer: *mut *mut StackType_t,
	                                     pulIdleTaskStackSize: *mut u32);
}
extern "C" {
	#[doc = " task.h"]
	#[doc = " @code{c}"]
	#[doc = " BaseType_t xTaskCallApplicationTaskHook( TaskHandle_t xTask, void *pvParameter );"]
	#[doc = " @endcode"]
	#[doc = ""]
	#[doc = " Calls the hook function associated with xTask.  Passing xTask as NULL has"]
	#[doc = " the effect of calling the Running tasks (the calling task) hook function."]
	#[doc = ""]
	#[doc = " pvParameter is passed to the hook function for the task to interpret as it"]
	#[doc = " wants.  The return value is the value returned by the task hook function"]
	#[doc = " registered by the user."]
	pub fn xTaskCallApplicationTaskHook(xTask: TaskHandle_t, pvParameter: *mut core::ffi::c_void) -> BaseType_t;
}
extern "C" {
	#[doc = " xTaskGetIdleTaskHandle() is only available if"]
	#[doc = " INCLUDE_xTaskGetIdleTaskHandle is set to 1 in FreeRTOSConfig.h."]
	#[doc = ""]
	#[doc = " Simply returns the handle of the idle task.  It is not valid to call"]
	#[doc = " xTaskGetIdleTaskHandle() before the scheduler has been started."]
	pub fn xTaskGetIdleTaskHandle() -> TaskHandle_t;
}
extern "C" {
	#[doc = " configUSE_TRACE_FACILITY must be defined as 1 in FreeRTOSConfig.h for"]
	#[doc = " uxTaskGetSystemState() to be available."]
	#[doc = ""]
	#[doc = " uxTaskGetSystemState() populates an TaskStatus_t structure for each task in"]
	#[doc = " the system.  TaskStatus_t structures contain, among other things, members"]
	#[doc = " for the task handle, task name, task priority, task state, and total amount"]
	#[doc = " of run time consumed by the task.  See the TaskStatus_t structure"]
	#[doc = " definition in this file for the full member list."]
	#[doc = ""]
	#[doc = " NOTE:  This function is intended for debugging use only as its use results in"]
	#[doc = " the scheduler remaining suspended for an extended period."]
	#[doc = ""]
	#[doc = " @param pxTaskStatusArray A pointer to an array of TaskStatus_t structures."]
	#[doc = " The array must contain at least one TaskStatus_t structure for each task"]
	#[doc = " that is under the control of the RTOS.  The number of tasks under the control"]
	#[doc = " of the RTOS can be determined using the uxTaskGetNumberOfTasks() API function."]
	#[doc = ""]
	#[doc = " @param uxArraySize The size of the array pointed to by the pxTaskStatusArray"]
	#[doc = " parameter.  The size is specified as the number of indexes in the array, or"]
	#[doc = " the number of TaskStatus_t structures contained in the array, not by the"]
	#[doc = " number of bytes in the array."]
	#[doc = ""]
	#[doc = " @param pulTotalRunTime If configGENERATE_RUN_TIME_STATS is set to 1 in"]
	#[doc = " FreeRTOSConfig.h then *pulTotalRunTime is set by uxTaskGetSystemState() to the"]
	#[doc = " total run time (as defined by the run time stats clock, see"]
	#[doc = " https://www.FreeRTOS.org/rtos-run-time-stats.html) since the target booted."]
	#[doc = " pulTotalRunTime can be set to NULL to omit the total run time information."]
	#[doc = ""]
	#[doc = " @return The number of TaskStatus_t structures that were populated by"]
	#[doc = " uxTaskGetSystemState().  This should equal the number returned by the"]
	#[doc = " uxTaskGetNumberOfTasks() API function, but will be zero if the value passed"]
	#[doc = " in the uxArraySize parameter was too small."]
	#[doc = ""]
	#[doc = " Example usage:"]
	#[doc = " @code{c}"]
	#[doc = "  // This example demonstrates how a human readable table of run time stats"]
	#[doc = "  // information is generated from raw data provided by uxTaskGetSystemState()."]
	#[doc = "  // The human readable table is written to pcWriteBuffer"]
	#[doc = "  void vTaskGetRunTimeStats( char *pcWriteBuffer )"]
	#[doc = "  {"]
	#[doc = "  TaskStatus_t *pxTaskStatusArray;"]
	#[doc = "  volatile UBaseType_t uxArraySize, x;"]
	#[doc = "  configRUN_TIME_COUNTER_TYPE ulTotalRunTime, ulStatsAsPercentage;"]
	#[doc = ""]
	#[doc = "      // Make sure the write buffer does not contain a string."]
	#[doc = " pcWriteBuffer = 0x00;"]
	#[doc = ""]
	#[doc = "      // Take a snapshot of the number of tasks in case it changes while this"]
	#[doc = "      // function is executing."]
	#[doc = "      uxArraySize = uxTaskGetNumberOfTasks();"]
	#[doc = ""]
	#[doc = "      // Allocate a TaskStatus_t structure for each task.  An array could be"]
	#[doc = "      // allocated statically at compile time."]
	#[doc = "      pxTaskStatusArray = pvPortMalloc( uxArraySize * sizeof( TaskStatus_t ) );"]
	#[doc = ""]
	#[doc = "      if( pxTaskStatusArray != NULL )"]
	#[doc = "      {"]
	#[doc = "          // Generate raw status information about each task."]
	#[doc = "          uxArraySize = uxTaskGetSystemState( pxTaskStatusArray, uxArraySize, &ulTotalRunTime );"]
	#[doc = ""]
	#[doc = "          // For percentage calculations."]
	#[doc = "          ulTotalRunTime /= 100UL;"]
	#[doc = ""]
	#[doc = "          // Avoid divide by zero errors."]
	#[doc = "          if( ulTotalRunTime > 0 )"]
	#[doc = "          {"]
	#[doc = "              // For each populated position in the pxTaskStatusArray array,"]
	#[doc = "              // format the raw data as human readable ASCII data"]
	#[doc = "              for( x = 0; x < uxArraySize; x++ )"]
	#[doc = "              {"]
	#[doc = "                  // What percentage of the total run time has the task used?"]
	#[doc = "                  // This will always be rounded down to the nearest integer."]
	#[doc = "                  // ulTotalRunTimeDiv100 has already been divided by 100."]
	#[doc = "                  ulStatsAsPercentage = pxTaskStatusArray[ x ].ulRunTimeCounter / ulTotalRunTime;"]
	#[doc = ""]
	#[doc = "                  if( ulStatsAsPercentage > 0UL )"]
	#[doc = "                  {"]
	#[doc = "                      sprintf( pcWriteBuffer, \"%s\\t\\t%lu\\t\\t%lu%%\\r\\n\", pxTaskStatusArray[ x ].pcTaskName, pxTaskStatusArray[ x ].ulRunTimeCounter, ulStatsAsPercentage );"]
	#[doc = "                  }"]
	#[doc = "                  else"]
	#[doc = "                  {"]
	#[doc = "                      // If the percentage is zero here then the task has"]
	#[doc = "                      // consumed less than 1% of the total run time."]
	#[doc = "                      sprintf( pcWriteBuffer, \"%s\\t\\t%lu\\t\\t<1%%\\r\\n\", pxTaskStatusArray[ x ].pcTaskName, pxTaskStatusArray[ x ].ulRunTimeCounter );"]
	#[doc = "                  }"]
	#[doc = ""]
	#[doc = "                  pcWriteBuffer += strlen( ( char * ) pcWriteBuffer );"]
	#[doc = "              }"]
	#[doc = "          }"]
	#[doc = ""]
	#[doc = "          // The array is no longer needed, free the memory it consumes."]
	#[doc = "          vPortFree( pxTaskStatusArray );"]
	#[doc = "      }"]
	#[doc = "  }"]
	#[doc = "  @endcode"]
	pub fn uxTaskGetSystemState(pxTaskStatusArray: *mut TaskStatus_t,
	                            uxArraySize: UBaseType_t,
	                            pulTotalRunTime: *mut u32)
	                            -> UBaseType_t;
}
extern "C" {
	#[doc = " task. h"]
	#[doc = " @code{c}"]
	#[doc = " void vTaskList( char *pcWriteBuffer );"]
	#[doc = " @endcode"]
	#[doc = ""]
	#[doc = " configUSE_TRACE_FACILITY and configUSE_STATS_FORMATTING_FUNCTIONS must"]
	#[doc = " both be defined as 1 for this function to be available.  See the"]
	#[doc = " configuration section of the FreeRTOS.org website for more information."]
	#[doc = ""]
	#[doc = " NOTE 1: This function will disable interrupts for its duration.  It is"]
	#[doc = " not intended for normal application runtime use but as a debug aid."]
	#[doc = ""]
	#[doc = " Lists all the current tasks, along with their current state and stack"]
	#[doc = " usage high water mark."]
	#[doc = ""]
	#[doc = " Tasks are reported as blocked ('B'), ready ('R'), deleted ('D') or"]
	#[doc = " suspended ('S')."]
	#[doc = ""]
	#[doc = " PLEASE NOTE:"]
	#[doc = ""]
	#[doc = " This function is provided for convenience only, and is used by many of the"]
	#[doc = " demo applications.  Do not consider it to be part of the scheduler."]
	#[doc = ""]
	#[doc = " vTaskList() calls uxTaskGetSystemState(), then formats part of the"]
	#[doc = " uxTaskGetSystemState() output into a human readable table that displays task:"]
	#[doc = " names, states, priority, stack usage and task number."]
	#[doc = " Stack usage specified as the number of unused StackType_t words stack can hold"]
	#[doc = " on top of stack - not the number of bytes."]
	#[doc = ""]
	#[doc = " vTaskList() has a dependency on the sprintf() C library function that might"]
	#[doc = " bloat the code size, use a lot of stack, and provide different results on"]
	#[doc = " different platforms.  An alternative, tiny, third party, and limited"]
	#[doc = " functionality implementation of sprintf() is provided in many of the"]
	#[doc = " FreeRTOS/Demo sub-directories in a file called printf-stdarg.c (note"]
	#[doc = " printf-stdarg.c does not provide a full snprintf() implementation!)."]
	#[doc = ""]
	#[doc = " It is recommended that production systems call uxTaskGetSystemState()"]
	#[doc = " directly to get access to raw stats data, rather than indirectly through a"]
	#[doc = " call to vTaskList()."]
	#[doc = ""]
	#[doc = " @param pcWriteBuffer A buffer into which the above mentioned details"]
	#[doc = " will be written, in ASCII form.  This buffer is assumed to be large"]
	#[doc = " enough to contain the generated report.  Approximately 40 bytes per"]
	#[doc = " task should be sufficient."]
	#[doc = ""]
	#[doc = " \\defgroup vTaskList vTaskList"]
	#[doc = " \\ingroup TaskUtils"]
	pub fn vTaskList(pcWriteBuffer: *mut core::ffi::c_char);
}
extern "C" {
	#[doc = " task. h"]
	#[doc = " @code{c}"]
	#[doc = " void vTaskGetRunTimeStats( char *pcWriteBuffer );"]
	#[doc = " @endcode"]
	#[doc = ""]
	#[doc = " configGENERATE_RUN_TIME_STATS and configUSE_STATS_FORMATTING_FUNCTIONS"]
	#[doc = " must both be defined as 1 for this function to be available.  The application"]
	#[doc = " must also then provide definitions for"]
	#[doc = " portCONFIGURE_TIMER_FOR_RUN_TIME_STATS() and portGET_RUN_TIME_COUNTER_VALUE()"]
	#[doc = " to configure a peripheral timer/counter and return the timers current count"]
	#[doc = " value respectively.  The counter should be at least 10 times the frequency of"]
	#[doc = " the tick count."]
	#[doc = ""]
	#[doc = " NOTE 1: This function will disable interrupts for its duration.  It is"]
	#[doc = " not intended for normal application runtime use but as a debug aid."]
	#[doc = ""]
	#[doc = " Setting configGENERATE_RUN_TIME_STATS to 1 will result in a total"]
	#[doc = " accumulated execution time being stored for each task.  The resolution"]
	#[doc = " of the accumulated time value depends on the frequency of the timer"]
	#[doc = " configured by the portCONFIGURE_TIMER_FOR_RUN_TIME_STATS() macro."]
	#[doc = " Calling vTaskGetRunTimeStats() writes the total execution time of each"]
	#[doc = " task into a buffer, both as an absolute count value and as a percentage"]
	#[doc = " of the total system execution time."]
	#[doc = ""]
	#[doc = " NOTE 2:"]
	#[doc = ""]
	#[doc = " This function is provided for convenience only, and is used by many of the"]
	#[doc = " demo applications.  Do not consider it to be part of the scheduler."]
	#[doc = ""]
	#[doc = " vTaskGetRunTimeStats() calls uxTaskGetSystemState(), then formats part of the"]
	#[doc = " uxTaskGetSystemState() output into a human readable table that displays the"]
	#[doc = " amount of time each task has spent in the Running state in both absolute and"]
	#[doc = " percentage terms."]
	#[doc = ""]
	#[doc = " vTaskGetRunTimeStats() has a dependency on the sprintf() C library function"]
	#[doc = " that might bloat the code size, use a lot of stack, and provide different"]
	#[doc = " results on different platforms.  An alternative, tiny, third party, and"]
	#[doc = " limited functionality implementation of sprintf() is provided in many of the"]
	#[doc = " FreeRTOS/Demo sub-directories in a file called printf-stdarg.c (note"]
	#[doc = " printf-stdarg.c does not provide a full snprintf() implementation!)."]
	#[doc = ""]
	#[doc = " It is recommended that production systems call uxTaskGetSystemState() directly"]
	#[doc = " to get access to raw stats data, rather than indirectly through a call to"]
	#[doc = " vTaskGetRunTimeStats()."]
	#[doc = ""]
	#[doc = " @param pcWriteBuffer A buffer into which the execution times will be"]
	#[doc = " written, in ASCII form.  This buffer is assumed to be large enough to"]
	#[doc = " contain the generated report.  Approximately 40 bytes per task should"]
	#[doc = " be sufficient."]
	#[doc = ""]
	#[doc = " \\defgroup vTaskGetRunTimeStats vTaskGetRunTimeStats"]
	#[doc = " \\ingroup TaskUtils"]
	pub fn vTaskGetRunTimeStats(pcWriteBuffer: *mut core::ffi::c_char);
}
extern "C" {
	#[doc = " task. h"]
	#[doc = " @code{c}"]
	#[doc = " configRUN_TIME_COUNTER_TYPE ulTaskGetIdleRunTimeCounter( void );"]
	#[doc = " configRUN_TIME_COUNTER_TYPE ulTaskGetIdleRunTimePercent( void );"]
	#[doc = " @endcode"]
	#[doc = ""]
	#[doc = " configGENERATE_RUN_TIME_STATS, configUSE_STATS_FORMATTING_FUNCTIONS and"]
	#[doc = " INCLUDE_xTaskGetIdleTaskHandle must all be defined as 1 for these functions"]
	#[doc = " to be available.  The application must also then provide definitions for"]
	#[doc = " portCONFIGURE_TIMER_FOR_RUN_TIME_STATS() and portGET_RUN_TIME_COUNTER_VALUE()"]
	#[doc = " to configure a peripheral timer/counter and return the timers current count"]
	#[doc = " value respectively.  The counter should be at least 10 times the frequency of"]
	#[doc = " the tick count."]
	#[doc = ""]
	#[doc = " Setting configGENERATE_RUN_TIME_STATS to 1 will result in a total"]
	#[doc = " accumulated execution time being stored for each task.  The resolution"]
	#[doc = " of the accumulated time value depends on the frequency of the timer"]
	#[doc = " configured by the portCONFIGURE_TIMER_FOR_RUN_TIME_STATS() macro."]
	#[doc = " While uxTaskGetSystemState() and vTaskGetRunTimeStats() writes the total"]
	#[doc = " execution time of each task into a buffer, ulTaskGetIdleRunTimeCounter()"]
	#[doc = " returns the total execution time of just the idle task and"]
	#[doc = " ulTaskGetIdleRunTimePercent() returns the percentage of the CPU time used by"]
	#[doc = " just the idle task."]
	#[doc = ""]
	#[doc = " Note the amount of idle time is only a good measure of the slack time in a"]
	#[doc = " system if there are no other tasks executing at the idle priority, tickless"]
	#[doc = " idle is not used, and configIDLE_SHOULD_YIELD is set to 0."]
	#[doc = ""]
	#[doc = " @return The total run time of the idle task or the percentage of the total"]
	#[doc = " run time consumed by the idle task.  This is the amount of time the"]
	#[doc = " idle task has actually been executing.  The unit of time is dependent on the"]
	#[doc = " frequency configured using the portCONFIGURE_TIMER_FOR_RUN_TIME_STATS() and"]
	#[doc = " portGET_RUN_TIME_COUNTER_VALUE() macros."]
	#[doc = ""]
	#[doc = " \\defgroup ulTaskGetIdleRunTimeCounter ulTaskGetIdleRunTimeCounter"]
	#[doc = " \\ingroup TaskUtils"]
	pub fn ulTaskGetIdleRunTimeCounter() -> u32;
}
extern "C" {
	pub fn ulTaskGetIdleRunTimePercent() -> u32;
}
extern "C" {
	#[doc = " task. h"]
	#[doc = " @code{c}"]
	#[doc = " BaseType_t xTaskNotifyIndexed( TaskHandle_t xTaskToNotify, UBaseType_t uxIndexToNotify, uint32_t ulValue, eNotifyAction eAction );"]
	#[doc = " BaseType_t xTaskNotify( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction );"]
	#[doc = " @endcode"]
	#[doc = ""]
	#[doc = " See https://www.FreeRTOS.org/RTOS-task-notifications.html for details."]
	#[doc = ""]
	#[doc = " configUSE_TASK_NOTIFICATIONS must be undefined or defined as 1 for these"]
	#[doc = " functions to be available."]
	#[doc = ""]
	#[doc = " Sends a direct to task notification to a task, with an optional value and"]
	#[doc = " action."]
	#[doc = ""]
	#[doc = " Each task has a private array of \"notification values\" (or 'notifications'),"]
	#[doc = " each of which is a 32-bit unsigned integer (uint32_t).  The constant"]
	#[doc = " configTASK_NOTIFICATION_ARRAY_ENTRIES sets the number of indexes in the"]
	#[doc = " array, and (for backward compatibility) defaults to 1 if left undefined."]
	#[doc = " Prior to FreeRTOS V10.4.0 there was only one notification value per task."]
	#[doc = ""]
	#[doc = " Events can be sent to a task using an intermediary object.  Examples of such"]
	#[doc = " objects are queues, semaphores, mutexes and event groups.  Task notifications"]
	#[doc = " are a method of sending an event directly to a task without the need for such"]
	#[doc = " an intermediary object."]
	#[doc = ""]
	#[doc = " A notification sent to a task can optionally perform an action, such as"]
	#[doc = " update, overwrite or increment one of the task's notification values.  In"]
	#[doc = " that way task notifications can be used to send data to a task, or be used as"]
	#[doc = " light weight and fast binary or counting semaphores."]
	#[doc = ""]
	#[doc = " A task can use xTaskNotifyWaitIndexed() or ulTaskNotifyTakeIndexed() to"]
	#[doc = " [optionally] block to wait for a notification to be pending.  The task does"]
	#[doc = " not consume any CPU time while it is in the Blocked state."]
	#[doc = ""]
	#[doc = " A notification sent to a task will remain pending until it is cleared by the"]
	#[doc = " task calling xTaskNotifyWaitIndexed() or ulTaskNotifyTakeIndexed() (or their"]
	#[doc = " un-indexed equivalents).  If the task was already in the Blocked state to"]
	#[doc = " wait for a notification when the notification arrives then the task will"]
	#[doc = " automatically be removed from the Blocked state (unblocked) and the"]
	#[doc = " notification cleared."]
	#[doc = ""]
	#[doc = " **NOTE** Each notification within the array operates independently - a task"]
	#[doc = " can only block on one notification within the array at a time and will not be"]
	#[doc = " unblocked by a notification sent to any other array index."]
	#[doc = ""]
	#[doc = " Backward compatibility information:"]
	#[doc = " Prior to FreeRTOS V10.4.0 each task had a single \"notification value\", and"]
	#[doc = " all task notification API functions operated on that value. Replacing the"]
	#[doc = " single notification value with an array of notification values necessitated a"]
	#[doc = " new set of API functions that could address specific notifications within the"]
	#[doc = " array.  xTaskNotify() is the original API function, and remains backward"]
	#[doc = " compatible by always operating on the notification value at index 0 in the"]
	#[doc = " array. Calling xTaskNotify() is equivalent to calling xTaskNotifyIndexed()"]
	#[doc = " with the uxIndexToNotify parameter set to 0."]
	#[doc = ""]
	#[doc = " @param xTaskToNotify The handle of the task being notified.  The handle to a"]
	#[doc = " task can be returned from the xTaskCreate() API function used to create the"]
	#[doc = " task, and the handle of the currently running task can be obtained by calling"]
	#[doc = " xTaskGetCurrentTaskHandle()."]
	#[doc = ""]
	#[doc = " @param uxIndexToNotify The index within the target task's array of"]
	#[doc = " notification values to which the notification is to be sent.  uxIndexToNotify"]
	#[doc = " must be less than configTASK_NOTIFICATION_ARRAY_ENTRIES.  xTaskNotify() does"]
	#[doc = " not have this parameter and always sends notifications to index 0."]
	#[doc = ""]
	#[doc = " @param ulValue Data that can be sent with the notification.  How the data is"]
	#[doc = " used depends on the value of the eAction parameter."]
	#[doc = ""]
	#[doc = " @param eAction Specifies how the notification updates the task's notification"]
	#[doc = " value, if at all.  Valid values for eAction are as follows:"]
	#[doc = ""]
	#[doc = " eSetBits -"]
	#[doc = " The target notification value is bitwise ORed with ulValue."]
	#[doc = " xTaskNotifyIndexed() always returns pdPASS in this case."]
	#[doc = ""]
	#[doc = " eIncrement -"]
	#[doc = " The target notification value is incremented.  ulValue is not used and"]
	#[doc = " xTaskNotifyIndexed() always returns pdPASS in this case."]
	#[doc = ""]
	#[doc = " eSetValueWithOverwrite -"]
	#[doc = " The target notification value is set to the value of ulValue, even if the"]
	#[doc = " task being notified had not yet processed the previous notification at the"]
	#[doc = " same array index (the task already had a notification pending at that index)."]
	#[doc = " xTaskNotifyIndexed() always returns pdPASS in this case."]
	#[doc = ""]
	#[doc = " eSetValueWithoutOverwrite -"]
	#[doc = " If the task being notified did not already have a notification pending at the"]
	#[doc = " same array index then the target notification value is set to ulValue and"]
	#[doc = " xTaskNotifyIndexed() will return pdPASS.  If the task being notified already"]
	#[doc = " had a notification pending at the same array index then no action is"]
	#[doc = " performed and pdFAIL is returned."]
	#[doc = ""]
	#[doc = " eNoAction -"]
	#[doc = " The task receives a notification at the specified array index without the"]
	#[doc = " notification value at that index being updated.  ulValue is not used and"]
	#[doc = " xTaskNotifyIndexed() always returns pdPASS in this case."]
	#[doc = ""]
	#[doc = " pulPreviousNotificationValue -"]
	#[doc = " Can be used to pass out the subject task's notification value before any"]
	#[doc = " bits are modified by the notify function."]
	#[doc = ""]
	#[doc = " @return Dependent on the value of eAction.  See the description of the"]
	#[doc = " eAction parameter."]
	#[doc = ""]
	#[doc = " \\defgroup xTaskNotifyIndexed xTaskNotifyIndexed"]
	#[doc = " \\ingroup TaskNotifications"]
	pub fn xTaskGenericNotify(xTaskToNotify: TaskHandle_t,
	                          uxIndexToNotify: UBaseType_t,
	                          ulValue: u32,
	                          eAction: eNotifyAction,
	                          pulPreviousNotificationValue: *mut u32)
	                          -> BaseType_t;
}
extern "C" {
	#[doc = " task. h"]
	#[doc = " @code{c}"]
	#[doc = " BaseType_t xTaskNotifyIndexedFromISR( TaskHandle_t xTaskToNotify, UBaseType_t uxIndexToNotify, uint32_t ulValue, eNotifyAction eAction, BaseType_t *pxHigherPriorityTaskWoken );"]
	#[doc = " BaseType_t xTaskNotifyFromISR( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, BaseType_t *pxHigherPriorityTaskWoken );"]
	#[doc = " @endcode"]
	#[doc = ""]
	#[doc = " See https://www.FreeRTOS.org/RTOS-task-notifications.html for details."]
	#[doc = ""]
	#[doc = " configUSE_TASK_NOTIFICATIONS must be undefined or defined as 1 for these"]
	#[doc = " functions to be available."]
	#[doc = ""]
	#[doc = " A version of xTaskNotifyIndexed() that can be used from an interrupt service"]
	#[doc = " routine (ISR)."]
	#[doc = ""]
	#[doc = " Each task has a private array of \"notification values\" (or 'notifications'),"]
	#[doc = " each of which is a 32-bit unsigned integer (uint32_t).  The constant"]
	#[doc = " configTASK_NOTIFICATION_ARRAY_ENTRIES sets the number of indexes in the"]
	#[doc = " array, and (for backward compatibility) defaults to 1 if left undefined."]
	#[doc = " Prior to FreeRTOS V10.4.0 there was only one notification value per task."]
	#[doc = ""]
	#[doc = " Events can be sent to a task using an intermediary object.  Examples of such"]
	#[doc = " objects are queues, semaphores, mutexes and event groups.  Task notifications"]
	#[doc = " are a method of sending an event directly to a task without the need for such"]
	#[doc = " an intermediary object."]
	#[doc = ""]
	#[doc = " A notification sent to a task can optionally perform an action, such as"]
	#[doc = " update, overwrite or increment one of the task's notification values.  In"]
	#[doc = " that way task notifications can be used to send data to a task, or be used as"]
	#[doc = " light weight and fast binary or counting semaphores."]
	#[doc = ""]
	#[doc = " A task can use xTaskNotifyWaitIndexed() to [optionally] block to wait for a"]
	#[doc = " notification to be pending, or ulTaskNotifyTakeIndexed() to [optionally] block"]
	#[doc = " to wait for a notification value to have a non-zero value.  The task does"]
	#[doc = " not consume any CPU time while it is in the Blocked state."]
	#[doc = ""]
	#[doc = " A notification sent to a task will remain pending until it is cleared by the"]
	#[doc = " task calling xTaskNotifyWaitIndexed() or ulTaskNotifyTakeIndexed() (or their"]
	#[doc = " un-indexed equivalents).  If the task was already in the Blocked state to"]
	#[doc = " wait for a notification when the notification arrives then the task will"]
	#[doc = " automatically be removed from the Blocked state (unblocked) and the"]
	#[doc = " notification cleared."]
	#[doc = ""]
	#[doc = " **NOTE** Each notification within the array operates independently - a task"]
	#[doc = " can only block on one notification within the array at a time and will not be"]
	#[doc = " unblocked by a notification sent to any other array index."]
	#[doc = ""]
	#[doc = " Backward compatibility information:"]
	#[doc = " Prior to FreeRTOS V10.4.0 each task had a single \"notification value\", and"]
	#[doc = " all task notification API functions operated on that value. Replacing the"]
	#[doc = " single notification value with an array of notification values necessitated a"]
	#[doc = " new set of API functions that could address specific notifications within the"]
	#[doc = " array.  xTaskNotifyFromISR() is the original API function, and remains"]
	#[doc = " backward compatible by always operating on the notification value at index 0"]
	#[doc = " within the array. Calling xTaskNotifyFromISR() is equivalent to calling"]
	#[doc = " xTaskNotifyIndexedFromISR() with the uxIndexToNotify parameter set to 0."]
	#[doc = ""]
	#[doc = " @param uxIndexToNotify The index within the target task's array of"]
	#[doc = " notification values to which the notification is to be sent.  uxIndexToNotify"]
	#[doc = " must be less than configTASK_NOTIFICATION_ARRAY_ENTRIES.  xTaskNotifyFromISR()"]
	#[doc = " does not have this parameter and always sends notifications to index 0."]
	#[doc = ""]
	#[doc = " @param xTaskToNotify The handle of the task being notified.  The handle to a"]
	#[doc = " task can be returned from the xTaskCreate() API function used to create the"]
	#[doc = " task, and the handle of the currently running task can be obtained by calling"]
	#[doc = " xTaskGetCurrentTaskHandle()."]
	#[doc = ""]
	#[doc = " @param ulValue Data that can be sent with the notification.  How the data is"]
	#[doc = " used depends on the value of the eAction parameter."]
	#[doc = ""]
	#[doc = " @param eAction Specifies how the notification updates the task's notification"]
	#[doc = " value, if at all.  Valid values for eAction are as follows:"]
	#[doc = ""]
	#[doc = " eSetBits -"]
	#[doc = " The task's notification value is bitwise ORed with ulValue.  xTaskNotify()"]
	#[doc = " always returns pdPASS in this case."]
	#[doc = ""]
	#[doc = " eIncrement -"]
	#[doc = " The task's notification value is incremented.  ulValue is not used and"]
	#[doc = " xTaskNotify() always returns pdPASS in this case."]
	#[doc = ""]
	#[doc = " eSetValueWithOverwrite -"]
	#[doc = " The task's notification value is set to the value of ulValue, even if the"]
	#[doc = " task being notified had not yet processed the previous notification (the"]
	#[doc = " task already had a notification pending).  xTaskNotify() always returns"]
	#[doc = " pdPASS in this case."]
	#[doc = ""]
	#[doc = " eSetValueWithoutOverwrite -"]
	#[doc = " If the task being notified did not already have a notification pending then"]
	#[doc = " the task's notification value is set to ulValue and xTaskNotify() will"]
	#[doc = " return pdPASS.  If the task being notified already had a notification"]
	#[doc = " pending then no action is performed and pdFAIL is returned."]
	#[doc = ""]
	#[doc = " eNoAction -"]
	#[doc = " The task receives a notification without its notification value being"]
	#[doc = " updated.  ulValue is not used and xTaskNotify() always returns pdPASS in"]
	#[doc = " this case."]
	#[doc = ""]
	#[doc = " @param pxHigherPriorityTaskWoken  xTaskNotifyFromISR() will set"]
	#[doc = " *pxHigherPriorityTaskWoken to pdTRUE if sending the notification caused the"]
	#[doc = " task to which the notification was sent to leave the Blocked state, and the"]
	#[doc = " unblocked task has a priority higher than the currently running task.  If"]
	#[doc = " xTaskNotifyFromISR() sets this value to pdTRUE then a context switch should"]
	#[doc = " be requested before the interrupt is exited.  How a context switch is"]
	#[doc = " requested from an ISR is dependent on the port - see the documentation page"]
	#[doc = " for the port in use."]
	#[doc = ""]
	#[doc = " @return Dependent on the value of eAction.  See the description of the"]
	#[doc = " eAction parameter."]
	#[doc = ""]
	#[doc = " \\defgroup xTaskNotifyIndexedFromISR xTaskNotifyIndexedFromISR"]
	#[doc = " \\ingroup TaskNotifications"]
	pub fn xTaskGenericNotifyFromISR(xTaskToNotify: TaskHandle_t,
	                                 uxIndexToNotify: UBaseType_t,
	                                 ulValue: u32,
	                                 eAction: eNotifyAction,
	                                 pulPreviousNotificationValue: *mut u32,
	                                 pxHigherPriorityTaskWoken: *mut BaseType_t)
	                                 -> BaseType_t;
}
extern "C" {
	#[doc = " task. h"]
	#[doc = " @code{c}"]
	#[doc = " BaseType_t xTaskNotifyWaitIndexed( UBaseType_t uxIndexToWaitOn, uint32_t ulBitsToClearOnEntry, uint32_t ulBitsToClearOnExit, uint32_t *pulNotificationValue, TickType_t xTicksToWait );"]
	#[doc = ""]
	#[doc = " BaseType_t xTaskNotifyWait( uint32_t ulBitsToClearOnEntry, uint32_t ulBitsToClearOnExit, uint32_t *pulNotificationValue, TickType_t xTicksToWait );"]
	#[doc = " @endcode"]
	#[doc = ""]
	#[doc = " Waits for a direct to task notification to be pending at a given index within"]
	#[doc = " an array of direct to task notifications."]
	#[doc = ""]
	#[doc = " See https://www.FreeRTOS.org/RTOS-task-notifications.html for details."]
	#[doc = ""]
	#[doc = " configUSE_TASK_NOTIFICATIONS must be undefined or defined as 1 for this"]
	#[doc = " function to be available."]
	#[doc = ""]
	#[doc = " Each task has a private array of \"notification values\" (or 'notifications'),"]
	#[doc = " each of which is a 32-bit unsigned integer (uint32_t).  The constant"]
	#[doc = " configTASK_NOTIFICATION_ARRAY_ENTRIES sets the number of indexes in the"]
	#[doc = " array, and (for backward compatibility) defaults to 1 if left undefined."]
	#[doc = " Prior to FreeRTOS V10.4.0 there was only one notification value per task."]
	#[doc = ""]
	#[doc = " Events can be sent to a task using an intermediary object.  Examples of such"]
	#[doc = " objects are queues, semaphores, mutexes and event groups.  Task notifications"]
	#[doc = " are a method of sending an event directly to a task without the need for such"]
	#[doc = " an intermediary object."]
	#[doc = ""]
	#[doc = " A notification sent to a task can optionally perform an action, such as"]
	#[doc = " update, overwrite or increment one of the task's notification values.  In"]
	#[doc = " that way task notifications can be used to send data to a task, or be used as"]
	#[doc = " light weight and fast binary or counting semaphores."]
	#[doc = ""]
	#[doc = " A notification sent to a task will remain pending until it is cleared by the"]
	#[doc = " task calling xTaskNotifyWaitIndexed() or ulTaskNotifyTakeIndexed() (or their"]
	#[doc = " un-indexed equivalents).  If the task was already in the Blocked state to"]
	#[doc = " wait for a notification when the notification arrives then the task will"]
	#[doc = " automatically be removed from the Blocked state (unblocked) and the"]
	#[doc = " notification cleared."]
	#[doc = ""]
	#[doc = " A task can use xTaskNotifyWaitIndexed() to [optionally] block to wait for a"]
	#[doc = " notification to be pending, or ulTaskNotifyTakeIndexed() to [optionally] block"]
	#[doc = " to wait for a notification value to have a non-zero value.  The task does"]
	#[doc = " not consume any CPU time while it is in the Blocked state."]
	#[doc = ""]
	#[doc = " **NOTE** Each notification within the array operates independently - a task"]
	#[doc = " can only block on one notification within the array at a time and will not be"]
	#[doc = " unblocked by a notification sent to any other array index."]
	#[doc = ""]
	#[doc = " Backward compatibility information:"]
	#[doc = " Prior to FreeRTOS V10.4.0 each task had a single \"notification value\", and"]
	#[doc = " all task notification API functions operated on that value. Replacing the"]
	#[doc = " single notification value with an array of notification values necessitated a"]
	#[doc = " new set of API functions that could address specific notifications within the"]
	#[doc = " array.  xTaskNotifyWait() is the original API function, and remains backward"]
	#[doc = " compatible by always operating on the notification value at index 0 in the"]
	#[doc = " array. Calling xTaskNotifyWait() is equivalent to calling"]
	#[doc = " xTaskNotifyWaitIndexed() with the uxIndexToWaitOn parameter set to 0."]
	#[doc = ""]
	#[doc = " @param uxIndexToWaitOn The index within the calling task's array of"]
	#[doc = " notification values on which the calling task will wait for a notification to"]
	#[doc = " be received.  uxIndexToWaitOn must be less than"]
	#[doc = " configTASK_NOTIFICATION_ARRAY_ENTRIES.  xTaskNotifyWait() does"]
	#[doc = " not have this parameter and always waits for notifications on index 0."]
	#[doc = ""]
	#[doc = " @param ulBitsToClearOnEntry Bits that are set in ulBitsToClearOnEntry value"]
	#[doc = " will be cleared in the calling task's notification value before the task"]
	#[doc = " checks to see if any notifications are pending, and optionally blocks if no"]
	#[doc = " notifications are pending.  Setting ulBitsToClearOnEntry to ULONG_MAX (if"]
	#[doc = " limits.h is included) or 0xffffffffUL (if limits.h is not included) will have"]
	#[doc = " the effect of resetting the task's notification value to 0.  Setting"]
	#[doc = " ulBitsToClearOnEntry to 0 will leave the task's notification value unchanged."]
	#[doc = ""]
	#[doc = " @param ulBitsToClearOnExit If a notification is pending or received before"]
	#[doc = " the calling task exits the xTaskNotifyWait() function then the task's"]
	#[doc = " notification value (see the xTaskNotify() API function) is passed out using"]
	#[doc = " the pulNotificationValue parameter.  Then any bits that are set in"]
	#[doc = " ulBitsToClearOnExit will be cleared in the task's notification value (note"]
	#[doc = " *pulNotificationValue is set before any bits are cleared).  Setting"]
	#[doc = " ulBitsToClearOnExit to ULONG_MAX (if limits.h is included) or 0xffffffffUL"]
	#[doc = " (if limits.h is not included) will have the effect of resetting the task's"]
	#[doc = " notification value to 0 before the function exits.  Setting"]
	#[doc = " ulBitsToClearOnExit to 0 will leave the task's notification value unchanged"]
	#[doc = " when the function exits (in which case the value passed out in"]
	#[doc = " pulNotificationValue will match the task's notification value)."]
	#[doc = ""]
	#[doc = " @param pulNotificationValue Used to pass the task's notification value out"]
	#[doc = " of the function.  Note the value passed out will not be effected by the"]
	#[doc = " clearing of any bits caused by ulBitsToClearOnExit being non-zero."]
	#[doc = ""]
	#[doc = " @param xTicksToWait The maximum amount of time that the task should wait in"]
	#[doc = " the Blocked state for a notification to be received, should a notification"]
	#[doc = " not already be pending when xTaskNotifyWait() was called.  The task"]
	#[doc = " will not consume any processing time while it is in the Blocked state.  This"]
	#[doc = " is specified in kernel ticks, the macro pdMS_TO_TICKS( value_in_ms ) can be"]
	#[doc = " used to convert a time specified in milliseconds to a time specified in"]
	#[doc = " ticks."]
	#[doc = ""]
	#[doc = " @return If a notification was received (including notifications that were"]
	#[doc = " already pending when xTaskNotifyWait was called) then pdPASS is"]
	#[doc = " returned.  Otherwise pdFAIL is returned."]
	#[doc = ""]
	#[doc = " \\defgroup xTaskNotifyWaitIndexed xTaskNotifyWaitIndexed"]
	#[doc = " \\ingroup TaskNotifications"]
	pub fn xTaskGenericNotifyWait(uxIndexToWaitOn: UBaseType_t,
	                              ulBitsToClearOnEntry: u32,
	                              ulBitsToClearOnExit: u32,
	                              pulNotificationValue: *mut u32,
	                              xTicksToWait: TickType_t)
	                              -> BaseType_t;
}
extern "C" {
	#[doc = " task. h"]
	#[doc = " @code{c}"]
	#[doc = " void vTaskNotifyGiveIndexedFromISR( TaskHandle_t xTaskHandle, UBaseType_t uxIndexToNotify, BaseType_t *pxHigherPriorityTaskWoken );"]
	#[doc = " void vTaskNotifyGiveFromISR( TaskHandle_t xTaskHandle, BaseType_t *pxHigherPriorityTaskWoken );"]
	#[doc = " @endcode"]
	#[doc = ""]
	#[doc = " A version of xTaskNotifyGiveIndexed() that can be called from an interrupt"]
	#[doc = " service routine (ISR)."]
	#[doc = ""]
	#[doc = " See https://www.FreeRTOS.org/RTOS-task-notifications.html for more details."]
	#[doc = ""]
	#[doc = " configUSE_TASK_NOTIFICATIONS must be undefined or defined as 1 for this macro"]
	#[doc = " to be available."]
	#[doc = ""]
	#[doc = " Each task has a private array of \"notification values\" (or 'notifications'),"]
	#[doc = " each of which is a 32-bit unsigned integer (uint32_t).  The constant"]
	#[doc = " configTASK_NOTIFICATION_ARRAY_ENTRIES sets the number of indexes in the"]
	#[doc = " array, and (for backward compatibility) defaults to 1 if left undefined."]
	#[doc = " Prior to FreeRTOS V10.4.0 there was only one notification value per task."]
	#[doc = ""]
	#[doc = " Events can be sent to a task using an intermediary object.  Examples of such"]
	#[doc = " objects are queues, semaphores, mutexes and event groups.  Task notifications"]
	#[doc = " are a method of sending an event directly to a task without the need for such"]
	#[doc = " an intermediary object."]
	#[doc = ""]
	#[doc = " A notification sent to a task can optionally perform an action, such as"]
	#[doc = " update, overwrite or increment one of the task's notification values.  In"]
	#[doc = " that way task notifications can be used to send data to a task, or be used as"]
	#[doc = " light weight and fast binary or counting semaphores."]
	#[doc = ""]
	#[doc = " vTaskNotifyGiveIndexedFromISR() is intended for use when task notifications"]
	#[doc = " are used as light weight and faster binary or counting semaphore equivalents."]
	#[doc = " Actual FreeRTOS semaphores are given from an ISR using the"]
	#[doc = " xSemaphoreGiveFromISR() API function, the equivalent action that instead uses"]
	#[doc = " a task notification is vTaskNotifyGiveIndexedFromISR()."]
	#[doc = ""]
	#[doc = " When task notifications are being used as a binary or counting semaphore"]
	#[doc = " equivalent then the task being notified should wait for the notification"]
	#[doc = " using the ulTaskNotifyTakeIndexed() API function rather than the"]
	#[doc = " xTaskNotifyWaitIndexed() API function."]
	#[doc = ""]
	#[doc = " **NOTE** Each notification within the array operates independently - a task"]
	#[doc = " can only block on one notification within the array at a time and will not be"]
	#[doc = " unblocked by a notification sent to any other array index."]
	#[doc = ""]
	#[doc = " Backward compatibility information:"]
	#[doc = " Prior to FreeRTOS V10.4.0 each task had a single \"notification value\", and"]
	#[doc = " all task notification API functions operated on that value. Replacing the"]
	#[doc = " single notification value with an array of notification values necessitated a"]
	#[doc = " new set of API functions that could address specific notifications within the"]
	#[doc = " array.  xTaskNotifyFromISR() is the original API function, and remains"]
	#[doc = " backward compatible by always operating on the notification value at index 0"]
	#[doc = " within the array. Calling xTaskNotifyGiveFromISR() is equivalent to calling"]
	#[doc = " xTaskNotifyGiveIndexedFromISR() with the uxIndexToNotify parameter set to 0."]
	#[doc = ""]
	#[doc = " @param xTaskToNotify The handle of the task being notified.  The handle to a"]
	#[doc = " task can be returned from the xTaskCreate() API function used to create the"]
	#[doc = " task, and the handle of the currently running task can be obtained by calling"]
	#[doc = " xTaskGetCurrentTaskHandle()."]
	#[doc = ""]
	#[doc = " @param uxIndexToNotify The index within the target task's array of"]
	#[doc = " notification values to which the notification is to be sent.  uxIndexToNotify"]
	#[doc = " must be less than configTASK_NOTIFICATION_ARRAY_ENTRIES."]
	#[doc = " xTaskNotifyGiveFromISR() does not have this parameter and always sends"]
	#[doc = " notifications to index 0."]
	#[doc = ""]
	#[doc = " @param pxHigherPriorityTaskWoken  vTaskNotifyGiveFromISR() will set"]
	#[doc = " *pxHigherPriorityTaskWoken to pdTRUE if sending the notification caused the"]
	#[doc = " task to which the notification was sent to leave the Blocked state, and the"]
	#[doc = " unblocked task has a priority higher than the currently running task.  If"]
	#[doc = " vTaskNotifyGiveFromISR() sets this value to pdTRUE then a context switch"]
	#[doc = " should be requested before the interrupt is exited.  How a context switch is"]
	#[doc = " requested from an ISR is dependent on the port - see the documentation page"]
	#[doc = " for the port in use."]
	#[doc = ""]
	#[doc = " \\defgroup vTaskNotifyGiveIndexedFromISR vTaskNotifyGiveIndexedFromISR"]
	#[doc = " \\ingroup TaskNotifications"]
	pub fn vTaskGenericNotifyGiveFromISR(xTaskToNotify: TaskHandle_t,
	                                     uxIndexToNotify: UBaseType_t,
	                                     pxHigherPriorityTaskWoken: *mut BaseType_t);
}
extern "C" {
	#[doc = " task. h"]
	#[doc = " @code{c}"]
	#[doc = " uint32_t ulTaskNotifyTakeIndexed( UBaseType_t uxIndexToWaitOn, BaseType_t xClearCountOnExit, TickType_t xTicksToWait );"]
	#[doc = ""]
	#[doc = " uint32_t ulTaskNotifyTake( BaseType_t xClearCountOnExit, TickType_t xTicksToWait );"]
	#[doc = " @endcode"]
	#[doc = ""]
	#[doc = " Waits for a direct to task notification on a particular index in the calling"]
	#[doc = " task's notification array in a manner similar to taking a counting semaphore."]
	#[doc = ""]
	#[doc = " See https://www.FreeRTOS.org/RTOS-task-notifications.html for details."]
	#[doc = ""]
	#[doc = " configUSE_TASK_NOTIFICATIONS must be undefined or defined as 1 for this"]
	#[doc = " function to be available."]
	#[doc = ""]
	#[doc = " Each task has a private array of \"notification values\" (or 'notifications'),"]
	#[doc = " each of which is a 32-bit unsigned integer (uint32_t).  The constant"]
	#[doc = " configTASK_NOTIFICATION_ARRAY_ENTRIES sets the number of indexes in the"]
	#[doc = " array, and (for backward compatibility) defaults to 1 if left undefined."]
	#[doc = " Prior to FreeRTOS V10.4.0 there was only one notification value per task."]
	#[doc = ""]
	#[doc = " Events can be sent to a task using an intermediary object.  Examples of such"]
	#[doc = " objects are queues, semaphores, mutexes and event groups.  Task notifications"]
	#[doc = " are a method of sending an event directly to a task without the need for such"]
	#[doc = " an intermediary object."]
	#[doc = ""]
	#[doc = " A notification sent to a task can optionally perform an action, such as"]
	#[doc = " update, overwrite or increment one of the task's notification values.  In"]
	#[doc = " that way task notifications can be used to send data to a task, or be used as"]
	#[doc = " light weight and fast binary or counting semaphores."]
	#[doc = ""]
	#[doc = " ulTaskNotifyTakeIndexed() is intended for use when a task notification is"]
	#[doc = " used as a faster and lighter weight binary or counting semaphore alternative."]
	#[doc = " Actual FreeRTOS semaphores are taken using the xSemaphoreTake() API function,"]
	#[doc = " the equivalent action that instead uses a task notification is"]
	#[doc = " ulTaskNotifyTakeIndexed()."]
	#[doc = ""]
	#[doc = " When a task is using its notification value as a binary or counting semaphore"]
	#[doc = " other tasks should send notifications to it using the xTaskNotifyGiveIndexed()"]
	#[doc = " macro, or xTaskNotifyIndex() function with the eAction parameter set to"]
	#[doc = " eIncrement."]
	#[doc = ""]
	#[doc = " ulTaskNotifyTakeIndexed() can either clear the task's notification value at"]
	#[doc = " the array index specified by the uxIndexToWaitOn parameter to zero on exit,"]
	#[doc = " in which case the notification value acts like a binary semaphore, or"]
	#[doc = " decrement the notification value on exit, in which case the notification"]
	#[doc = " value acts like a counting semaphore."]
	#[doc = ""]
	#[doc = " A task can use ulTaskNotifyTakeIndexed() to [optionally] block to wait for"]
	#[doc = " a notification.  The task does not consume any CPU time while it is in the"]
	#[doc = " Blocked state."]
	#[doc = ""]
	#[doc = " Where as xTaskNotifyWaitIndexed() will return when a notification is pending,"]
	#[doc = " ulTaskNotifyTakeIndexed() will return when the task's notification value is"]
	#[doc = " not zero."]
	#[doc = ""]
	#[doc = " **NOTE** Each notification within the array operates independently - a task"]
	#[doc = " can only block on one notification within the array at a time and will not be"]
	#[doc = " unblocked by a notification sent to any other array index."]
	#[doc = ""]
	#[doc = " Backward compatibility information:"]
	#[doc = " Prior to FreeRTOS V10.4.0 each task had a single \"notification value\", and"]
	#[doc = " all task notification API functions operated on that value. Replacing the"]
	#[doc = " single notification value with an array of notification values necessitated a"]
	#[doc = " new set of API functions that could address specific notifications within the"]
	#[doc = " array.  ulTaskNotifyTake() is the original API function, and remains backward"]
	#[doc = " compatible by always operating on the notification value at index 0 in the"]
	#[doc = " array. Calling ulTaskNotifyTake() is equivalent to calling"]
	#[doc = " ulTaskNotifyTakeIndexed() with the uxIndexToWaitOn parameter set to 0."]
	#[doc = ""]
	#[doc = " @param uxIndexToWaitOn The index within the calling task's array of"]
	#[doc = " notification values on which the calling task will wait for a notification to"]
	#[doc = " be non-zero.  uxIndexToWaitOn must be less than"]
	#[doc = " configTASK_NOTIFICATION_ARRAY_ENTRIES.  xTaskNotifyTake() does"]
	#[doc = " not have this parameter and always waits for notifications on index 0."]
	#[doc = ""]
	#[doc = " @param xClearCountOnExit if xClearCountOnExit is pdFALSE then the task's"]
	#[doc = " notification value is decremented when the function exits.  In this way the"]
	#[doc = " notification value acts like a counting semaphore.  If xClearCountOnExit is"]
	#[doc = " not pdFALSE then the task's notification value is cleared to zero when the"]
	#[doc = " function exits.  In this way the notification value acts like a binary"]
	#[doc = " semaphore."]
	#[doc = ""]
	#[doc = " @param xTicksToWait The maximum amount of time that the task should wait in"]
	#[doc = " the Blocked state for the task's notification value to be greater than zero,"]
	#[doc = " should the count not already be greater than zero when"]
	#[doc = " ulTaskNotifyTake() was called.  The task will not consume any processing"]
	#[doc = " time while it is in the Blocked state.  This is specified in kernel ticks,"]
	#[doc = " the macro pdMS_TO_TICKS( value_in_ms ) can be used to convert a time"]
	#[doc = " specified in milliseconds to a time specified in ticks."]
	#[doc = ""]
	#[doc = " @return The task's notification count before it is either cleared to zero or"]
	#[doc = " decremented (see the xClearCountOnExit parameter)."]
	#[doc = ""]
	#[doc = " \\defgroup ulTaskNotifyTakeIndexed ulTaskNotifyTakeIndexed"]
	#[doc = " \\ingroup TaskNotifications"]
	pub fn ulTaskGenericNotifyTake(uxIndexToWaitOn: UBaseType_t, xClearCountOnExit: BaseType_t, xTicksToWait: TickType_t) -> u32;
}
extern "C" {
	#[doc = " task. h"]
	#[doc = " @code{c}"]
	#[doc = " BaseType_t xTaskNotifyStateClearIndexed( TaskHandle_t xTask, UBaseType_t uxIndexToCLear );"]
	#[doc = ""]
	#[doc = " BaseType_t xTaskNotifyStateClear( TaskHandle_t xTask );"]
	#[doc = " @endcode"]
	#[doc = ""]
	#[doc = " See https://www.FreeRTOS.org/RTOS-task-notifications.html for details."]
	#[doc = ""]
	#[doc = " configUSE_TASK_NOTIFICATIONS must be undefined or defined as 1 for these"]
	#[doc = " functions to be available."]
	#[doc = ""]
	#[doc = " Each task has a private array of \"notification values\" (or 'notifications'),"]
	#[doc = " each of which is a 32-bit unsigned integer (uint32_t).  The constant"]
	#[doc = " configTASK_NOTIFICATION_ARRAY_ENTRIES sets the number of indexes in the"]
	#[doc = " array, and (for backward compatibility) defaults to 1 if left undefined."]
	#[doc = " Prior to FreeRTOS V10.4.0 there was only one notification value per task."]
	#[doc = ""]
	#[doc = " If a notification is sent to an index within the array of notifications then"]
	#[doc = " the notification at that index is said to be 'pending' until it is read or"]
	#[doc = " explicitly cleared by the receiving task.  xTaskNotifyStateClearIndexed()"]
	#[doc = " is the function that clears a pending notification without reading the"]
	#[doc = " notification value.  The notification value at the same array index is not"]
	#[doc = " altered.  Set xTask to NULL to clear the notification state of the calling"]
	#[doc = " task."]
	#[doc = ""]
	#[doc = " Backward compatibility information:"]
	#[doc = " Prior to FreeRTOS V10.4.0 each task had a single \"notification value\", and"]
	#[doc = " all task notification API functions operated on that value. Replacing the"]
	#[doc = " single notification value with an array of notification values necessitated a"]
	#[doc = " new set of API functions that could address specific notifications within the"]
	#[doc = " array.  xTaskNotifyStateClear() is the original API function, and remains"]
	#[doc = " backward compatible by always operating on the notification value at index 0"]
	#[doc = " within the array. Calling xTaskNotifyStateClear() is equivalent to calling"]
	#[doc = " xTaskNotifyStateClearIndexed() with the uxIndexToNotify parameter set to 0."]
	#[doc = ""]
	#[doc = " @param xTask The handle of the RTOS task that will have a notification state"]
	#[doc = " cleared.  Set xTask to NULL to clear a notification state in the calling"]
	#[doc = " task.  To obtain a task's handle create the task using xTaskCreate() and"]
	#[doc = " make use of the pxCreatedTask parameter, or create the task using"]
	#[doc = " xTaskCreateStatic() and store the returned value, or use the task's name in"]
	#[doc = " a call to xTaskGetHandle()."]
	#[doc = ""]
	#[doc = " @param uxIndexToClear The index within the target task's array of"]
	#[doc = " notification values to act upon.  For example, setting uxIndexToClear to 1"]
	#[doc = " will clear the state of the notification at index 1 within the array."]
	#[doc = " uxIndexToClear must be less than configTASK_NOTIFICATION_ARRAY_ENTRIES."]
	#[doc = " ulTaskNotifyStateClear() does not have this parameter and always acts on the"]
	#[doc = " notification at index 0."]
	#[doc = ""]
	#[doc = " @return pdTRUE if the task's notification state was set to"]
	#[doc = " eNotWaitingNotification, otherwise pdFALSE."]
	#[doc = ""]
	#[doc = " \\defgroup xTaskNotifyStateClearIndexed xTaskNotifyStateClearIndexed"]
	#[doc = " \\ingroup TaskNotifications"]
	pub fn xTaskGenericNotifyStateClear(xTask: TaskHandle_t, uxIndexToClear: UBaseType_t) -> BaseType_t;
}
extern "C" {
	#[doc = " task. h"]
	#[doc = " @code{c}"]
	#[doc = " uint32_t ulTaskNotifyValueClearIndexed( TaskHandle_t xTask, UBaseType_t uxIndexToClear, uint32_t ulBitsToClear );"]
	#[doc = ""]
	#[doc = " uint32_t ulTaskNotifyValueClear( TaskHandle_t xTask, uint32_t ulBitsToClear );"]
	#[doc = " @endcode"]
	#[doc = ""]
	#[doc = " See https://www.FreeRTOS.org/RTOS-task-notifications.html for details."]
	#[doc = ""]
	#[doc = " configUSE_TASK_NOTIFICATIONS must be undefined or defined as 1 for these"]
	#[doc = " functions to be available."]
	#[doc = ""]
	#[doc = " Each task has a private array of \"notification values\" (or 'notifications'),"]
	#[doc = " each of which is a 32-bit unsigned integer (uint32_t).  The constant"]
	#[doc = " configTASK_NOTIFICATION_ARRAY_ENTRIES sets the number of indexes in the"]
	#[doc = " array, and (for backward compatibility) defaults to 1 if left undefined."]
	#[doc = " Prior to FreeRTOS V10.4.0 there was only one notification value per task."]
	#[doc = ""]
	#[doc = " ulTaskNotifyValueClearIndexed() clears the bits specified by the"]
	#[doc = " ulBitsToClear bit mask in the notification value at array index uxIndexToClear"]
	#[doc = " of the task referenced by xTask."]
	#[doc = ""]
	#[doc = " Backward compatibility information:"]
	#[doc = " Prior to FreeRTOS V10.4.0 each task had a single \"notification value\", and"]
	#[doc = " all task notification API functions operated on that value. Replacing the"]
	#[doc = " single notification value with an array of notification values necessitated a"]
	#[doc = " new set of API functions that could address specific notifications within the"]
	#[doc = " array.  ulTaskNotifyValueClear() is the original API function, and remains"]
	#[doc = " backward compatible by always operating on the notification value at index 0"]
	#[doc = " within the array. Calling ulTaskNotifyValueClear() is equivalent to calling"]
	#[doc = " ulTaskNotifyValueClearIndexed() with the uxIndexToClear parameter set to 0."]
	#[doc = ""]
	#[doc = " @param xTask The handle of the RTOS task that will have bits in one of its"]
	#[doc = " notification values cleared. Set xTask to NULL to clear bits in a"]
	#[doc = " notification value of the calling task.  To obtain a task's handle create the"]
	#[doc = " task using xTaskCreate() and make use of the pxCreatedTask parameter, or"]
	#[doc = " create the task using xTaskCreateStatic() and store the returned value, or"]
	#[doc = " use the task's name in a call to xTaskGetHandle()."]
	#[doc = ""]
	#[doc = " @param uxIndexToClear The index within the target task's array of"]
	#[doc = " notification values in which to clear the bits.  uxIndexToClear"]
	#[doc = " must be less than configTASK_NOTIFICATION_ARRAY_ENTRIES."]
	#[doc = " ulTaskNotifyValueClear() does not have this parameter and always clears bits"]
	#[doc = " in the notification value at index 0."]
	#[doc = ""]
	#[doc = " @param ulBitsToClear Bit mask of the bits to clear in the notification value of"]
	#[doc = " xTask. Set a bit to 1 to clear the corresponding bits in the task's notification"]
	#[doc = " value. Set ulBitsToClear to 0xffffffff (UINT_MAX on 32-bit architectures) to clear"]
	#[doc = " the notification value to 0.  Set ulBitsToClear to 0 to query the task's"]
	#[doc = " notification value without clearing any bits."]
	#[doc = ""]
	#[doc = ""]
	#[doc = " @return The value of the target task's notification value before the bits"]
	#[doc = " specified by ulBitsToClear were cleared."]
	#[doc = " \\defgroup ulTaskNotifyValueClear ulTaskNotifyValueClear"]
	#[doc = " \\ingroup TaskNotifications"]
	pub fn ulTaskGenericNotifyValueClear(xTask: TaskHandle_t, uxIndexToClear: UBaseType_t, ulBitsToClear: u32) -> u32;
}
extern "C" {
	#[doc = " task.h"]
	#[doc = " @code{c}"]
	#[doc = " void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut );"]
	#[doc = " @endcode"]
	#[doc = ""]
	#[doc = " Capture the current time for future use with xTaskCheckForTimeOut()."]
	#[doc = ""]
	#[doc = " @param pxTimeOut Pointer to a timeout object into which the current time"]
	#[doc = " is to be captured.  The captured time includes the tick count and the number"]
	#[doc = " of times the tick count has overflowed since the system first booted."]
	#[doc = " \\defgroup vTaskSetTimeOutState vTaskSetTimeOutState"]
	#[doc = " \\ingroup TaskCtrl"]
	pub fn vTaskSetTimeOutState(pxTimeOut: *mut TimeOut_t);
}
extern "C" {
	#[doc = " task.h"]
	#[doc = " @code{c}"]
	#[doc = " BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait );"]
	#[doc = " @endcode"]
	#[doc = ""]
	#[doc = " Determines if pxTicksToWait ticks has passed since a time was captured"]
	#[doc = " using a call to vTaskSetTimeOutState().  The captured time includes the tick"]
	#[doc = " count and the number of times the tick count has overflowed."]
	#[doc = ""]
	#[doc = " @param pxTimeOut The time status as captured previously using"]
	#[doc = " vTaskSetTimeOutState. If the timeout has not yet occurred, it is updated"]
	#[doc = " to reflect the current time status."]
	#[doc = " @param pxTicksToWait The number of ticks to check for timeout i.e. if"]
	#[doc = " pxTicksToWait ticks have passed since pxTimeOut was last updated (either by"]
	#[doc = " vTaskSetTimeOutState() or xTaskCheckForTimeOut()), the timeout has occurred."]
	#[doc = " If the timeout has not occurred, pxTicksToWait is updated to reflect the"]
	#[doc = " number of remaining ticks."]
	#[doc = ""]
	#[doc = " @return If timeout has occurred, pdTRUE is returned. Otherwise pdFALSE is"]
	#[doc = " returned and pxTicksToWait is updated to reflect the number of remaining"]
	#[doc = " ticks."]
	#[doc = ""]
	#[doc = " @see https://www.FreeRTOS.org/xTaskCheckForTimeOut.html"]
	#[doc = ""]
	#[doc = " Example Usage:"]
	#[doc = " @code{c}"]
	#[doc = "  // Driver library function used to receive uxWantedBytes from an Rx buffer"]
	#[doc = "  // that is filled by a UART interrupt. If there are not enough bytes in the"]
	#[doc = "  // Rx buffer then the task enters the Blocked state until it is notified that"]
	#[doc = "  // more data has been placed into the buffer. If there is still not enough"]
	#[doc = "  // data then the task re-enters the Blocked state, and xTaskCheckForTimeOut()"]
	#[doc = "  // is used to re-calculate the Block time to ensure the total amount of time"]
	#[doc = "  // spent in the Blocked state does not exceed MAX_TIME_TO_WAIT. This"]
	#[doc = "  // continues until either the buffer contains at least uxWantedBytes bytes,"]
	#[doc = "  // or the total amount of time spent in the Blocked state reaches"]
	#[doc = "  // MAX_TIME_TO_WAIT - at which point the task reads however many bytes are"]
	#[doc = "  // available up to a maximum of uxWantedBytes."]
	#[doc = ""]
	#[doc = "  size_t xUART_Receive( uint8_t *pucBuffer, size_t uxWantedBytes )"]
	#[doc = "  {"]
	#[doc = "  size_t uxReceived = 0;"]
	#[doc = "  TickType_t xTicksToWait = MAX_TIME_TO_WAIT;"]
	#[doc = "  TimeOut_t xTimeOut;"]
	#[doc = ""]
	#[doc = "      // Initialize xTimeOut.  This records the time at which this function"]
	#[doc = "      // was entered."]
	#[doc = "      vTaskSetTimeOutState( &xTimeOut );"]
	#[doc = ""]
	#[doc = "      // Loop until the buffer contains the wanted number of bytes, or a"]
	#[doc = "      // timeout occurs."]
	#[doc = "      while( UART_bytes_in_rx_buffer( pxUARTInstance ) < uxWantedBytes )"]
	#[doc = "      {"]
	#[doc = "          // The buffer didn't contain enough data so this task is going to"]
	#[doc = "          // enter the Blocked state. Adjusting xTicksToWait to account for"]
	#[doc = "          // any time that has been spent in the Blocked state within this"]
	#[doc = "          // function so far to ensure the total amount of time spent in the"]
	#[doc = "          // Blocked state does not exceed MAX_TIME_TO_WAIT."]
	#[doc = "          if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) != pdFALSE )"]
	#[doc = "          {"]
	#[doc = "              //Timed out before the wanted number of bytes were available,"]
	#[doc = "              // exit the loop."]
	#[doc = "              break;"]
	#[doc = "          }"]
	#[doc = ""]
	#[doc = "          // Wait for a maximum of xTicksToWait ticks to be notified that the"]
	#[doc = "          // receive interrupt has placed more data into the buffer."]
	#[doc = "          ulTaskNotifyTake( pdTRUE, xTicksToWait );"]
	#[doc = "      }"]
	#[doc = ""]
	#[doc = "      // Attempt to read uxWantedBytes from the receive buffer into pucBuffer."]
	#[doc = "      // The actual number of bytes read (which might be less than"]
	#[doc = "      // uxWantedBytes) is returned."]
	#[doc = "      uxReceived = UART_read_from_receive_buffer( pxUARTInstance,"]
	#[doc = "                                                  pucBuffer,"]
	#[doc = "                                                  uxWantedBytes );"]
	#[doc = ""]
	#[doc = "      return uxReceived;"]
	#[doc = "  }"]
	#[doc = " @endcode"]
	#[doc = " \\defgroup xTaskCheckForTimeOut xTaskCheckForTimeOut"]
	#[doc = " \\ingroup TaskCtrl"]
	pub fn xTaskCheckForTimeOut(pxTimeOut: *mut TimeOut_t, pxTicksToWait: *mut TickType_t) -> BaseType_t;
}
extern "C" {
	#[doc = " task.h"]
	#[doc = " @code{c}"]
	#[doc = " BaseType_t xTaskCatchUpTicks( TickType_t xTicksToCatchUp );"]
	#[doc = " @endcode"]
	#[doc = ""]
	#[doc = " This function corrects the tick count value after the application code has held"]
	#[doc = " interrupts disabled for an extended period resulting in tick interrupts having"]
	#[doc = " been missed."]
	#[doc = ""]
	#[doc = " This function is similar to vTaskStepTick(), however, unlike"]
	#[doc = " vTaskStepTick(), xTaskCatchUpTicks() may move the tick count forward past a"]
	#[doc = " time at which a task should be removed from the blocked state.  That means"]
	#[doc = " tasks may have to be removed from the blocked state as the tick count is"]
	#[doc = " moved."]
	#[doc = ""]
	#[doc = " @param xTicksToCatchUp The number of tick interrupts that have been missed due to"]
	#[doc = " interrupts being disabled.  Its value is not computed automatically, so must be"]
	#[doc = " computed by the application writer."]
	#[doc = ""]
	#[doc = " @return pdTRUE if moving the tick count forward resulted in a task leaving the"]
	#[doc = " blocked state and a context switch being performed.  Otherwise pdFALSE."]
	#[doc = ""]
	#[doc = " \\defgroup xTaskCatchUpTicks xTaskCatchUpTicks"]
	#[doc = " \\ingroup TaskCtrl"]
	pub fn xTaskCatchUpTicks(xTicksToCatchUp: TickType_t) -> BaseType_t;
}
extern "C" {
	pub fn xTaskIncrementTick() -> BaseType_t;
}
extern "C" {
	pub fn vTaskPlaceOnEventList(pxEventList: *mut List_t, xTicksToWait: TickType_t);
}
extern "C" {
	pub fn vTaskPlaceOnUnorderedEventList(pxEventList: *mut List_t, xItemValue: TickType_t, xTicksToWait: TickType_t);
}
extern "C" {
	pub fn vTaskPlaceOnEventListRestricted(pxEventList: *mut List_t, xTicksToWait: TickType_t, xWaitIndefinitely: BaseType_t);
}
extern "C" {
	pub fn xTaskRemoveFromEventList(pxEventList: *const List_t) -> BaseType_t;
}
extern "C" {
	pub fn vTaskRemoveFromUnorderedEventList(pxEventListItem: *mut ListItem_t, xItemValue: TickType_t);
}
extern "C" {
	pub fn vTaskSwitchContext();
}
extern "C" {
	pub fn uxTaskResetEventItemValue() -> TickType_t;
}
extern "C" {
	pub fn xTaskGetCurrentTaskHandle() -> TaskHandle_t;
}
extern "C" {
	pub fn vTaskMissedYield();
}
extern "C" {
	pub fn xTaskGetSchedulerState() -> BaseType_t;
}
extern "C" {
	pub fn xTaskPriorityInherit(pxMutexHolder: TaskHandle_t) -> BaseType_t;
}
extern "C" {
	pub fn xTaskPriorityDisinherit(pxMutexHolder: TaskHandle_t) -> BaseType_t;
}
extern "C" {
	pub fn vTaskPriorityDisinheritAfterTimeout(pxMutexHolder: TaskHandle_t, uxHighestPriorityWaitingTask: UBaseType_t);
}
extern "C" {
	pub fn uxTaskGetTaskNumber(xTask: TaskHandle_t) -> UBaseType_t;
}
extern "C" {
	pub fn vTaskSetTaskNumber(xTask: TaskHandle_t, uxHandle: UBaseType_t);
}
extern "C" {
	pub fn vTaskStepTick(xTicksToJump: TickType_t);
}
extern "C" {
	pub fn eTaskConfirmSleepModeStatus() -> eSleepModeStatus;
}
extern "C" {
	pub fn pvTaskIncrementMutexHeldCount() -> TaskHandle_t;
}
extern "C" {
	pub fn vTaskInternalSetTimeOutState(pxTimeOut: *mut TimeOut_t);
}
#[repr(i32)]
#[non_exhaustive]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum FuriStatus {
	#[doc = "< Operation completed successfully."]
	FuriStatusOk = 0,
	FuriStatusError = -1,
	#[doc = "< Operation not completed within the timeout period."]
	FuriStatusErrorTimeout = -2,
	#[doc = "< Resource not available."]
	FuriStatusErrorResource = -3,
	#[doc = "< Parameter error."]
	FuriStatusErrorParameter = -4,
	FuriStatusErrorNoMemory = -5,
	FuriStatusErrorISR = -6,
	#[doc = "< Prevents enum down-size compiler optimization."]
	FuriStatusReserved = 2147483647,
}
pub type FuriEventFlag = core::ffi::c_void;
extern "C" {
	#[doc = " Allocate FuriEventFlag"]
	#[doc = ""]
	#[doc = " @return     pointer to FuriEventFlag"]
	pub fn furi_event_flag_alloc() -> *mut FuriEventFlag;
}
extern "C" {
	#[doc = " Deallocate FuriEventFlag"]
	#[doc = ""]
	#[doc = " @param      instance  pointer to FuriEventFlag"]
	pub fn furi_event_flag_free(instance: *mut FuriEventFlag);
}
extern "C" {
	#[doc = " Set flags"]
	#[doc = ""]
	#[doc = " @param      instance  pointer to FuriEventFlag"]
	#[doc = " @param[in]  flags     The flags"]
	#[doc = ""]
	#[doc = " @return     Resulting flags or error (FuriStatus)"]
	pub fn furi_event_flag_set(instance: *mut FuriEventFlag, flags: u32) -> u32;
}
extern "C" {
	#[doc = " Clear flags"]
	#[doc = ""]
	#[doc = " @param      instance  pointer to FuriEventFlag"]
	#[doc = " @param[in]  flags     The flags"]
	#[doc = ""]
	#[doc = " @return     Resulting flags or error (FuriStatus)"]
	pub fn furi_event_flag_clear(instance: *mut FuriEventFlag, flags: u32) -> u32;
}
extern "C" {
	#[doc = " Get flags"]
	#[doc = ""]
	#[doc = " @param      instance  pointer to FuriEventFlag"]
	#[doc = ""]
	#[doc = " @return     Resulting flags"]
	pub fn furi_event_flag_get(instance: *mut FuriEventFlag) -> u32;
}
extern "C" {
	#[doc = " Wait flags"]
	#[doc = ""]
	#[doc = " @param      instance  pointer to FuriEventFlag"]
	#[doc = " @param[in]  flags     The flags"]
	#[doc = " @param[in]  options   The option flags"]
	#[doc = " @param[in]  timeout   The timeout"]
	#[doc = ""]
	#[doc = " @return     Resulting flags or error (FuriStatus)"]
	pub fn furi_event_flag_wait(instance: *mut FuriEventFlag, flags: u32, options: u32, timeout: u32) -> u32;
}
extern "C" {
	#[doc = " Lock kernel, pause process scheduling"]
	#[doc = ""]
	#[doc = " @return     previous lock state(0 - unlocked, 1 - locked)"]
	pub fn furi_kernel_lock() -> i32;
}
extern "C" {
	#[doc = " Unlock kernel, resume process scheduling"]
	#[doc = ""]
	#[doc = " @return     previous lock state(0 - unlocked, 1 - locked)"]
	pub fn furi_kernel_unlock() -> i32;
}
extern "C" {
	#[doc = " Restore kernel lock state"]
	#[doc = ""]
	#[doc = " @param[in]  lock  The lock state"]
	#[doc = ""]
	#[doc = " @return     new lock state or error"]
	pub fn furi_kernel_restore_lock(lock: i32) -> i32;
}
extern "C" {
	#[doc = " Get kernel systick frequency"]
	#[doc = ""]
	#[doc = " @return     systick counts per second"]
	pub fn furi_kernel_get_tick_frequency() -> u32;
}
extern "C" {
	#[doc = " Delay execution"]
	#[doc = ""]
	#[doc = " Also keep in mind delay is aliased to scheduler timer intervals."]
	#[doc = ""]
	#[doc = " @param[in]  ticks  The ticks count to pause"]
	pub fn furi_delay_tick(ticks: u32);
}
extern "C" {
	#[doc = " Delay until tick"]
	#[doc = ""]
	#[doc = " @param[in]  ticks  The tick until which kerel should delay task execution"]
	#[doc = ""]
	#[doc = " @return     The furi status."]
	pub fn furi_delay_until_tick(tick: u32) -> FuriStatus;
}
extern "C" {
	#[doc = " Get current tick counter"]
	#[doc = ""]
	#[doc = " System uptime, may overflow."]
	#[doc = ""]
	#[doc = " @return     Current ticks in milliseconds"]
	pub fn furi_get_tick() -> u32;
}
extern "C" {
	#[doc = " Convert milliseconds to ticks"]
	#[doc = ""]
	#[doc = " @param[in]   milliseconds    time in milliseconds"]
	#[doc = " @return      time in ticks"]
	pub fn furi_ms_to_ticks(milliseconds: u32) -> u32;
}
extern "C" {
	#[doc = " Delay in milliseconds"]
	#[doc = ""]
	#[doc = " This method uses kernel ticks on the inside, which causes delay to be aliased to scheduler timer intervals."]
	#[doc = " Real wait time will be between X+ milliseconds."]
	#[doc = " Special value: 0, will cause task yield."]
	#[doc = " Also if used when kernel is not running will fall back to `furi_delay_us`."]
	#[doc = ""]
	#[doc = " @warning    Cannot be used from ISR"]
	#[doc = ""]
	#[doc = " @param[in]  milliseconds  milliseconds to wait"]
	pub fn furi_delay_ms(milliseconds: u32);
}
extern "C" {
	#[doc = " Delay in microseconds"]
	#[doc = ""]
	#[doc = " Implemented using Cortex DWT counter. Blocking and non aliased."]
	#[doc = ""]
	#[doc = " @param[in]  microseconds  microseconds to wait"]
	pub fn furi_delay_us(microseconds: u32);
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum FuriLogLevel {
	FuriLogLevelDefault = 0,
	FuriLogLevelNone = 1,
	FuriLogLevelError = 2,
	FuriLogLevelWarn = 3,
	FuriLogLevelInfo = 4,
	FuriLogLevelDebug = 5,
	FuriLogLevelTrace = 6,
}
pub type FuriLogPuts = ::core::option::Option<unsafe extern "C" fn(data: *const core::ffi::c_char)>;
pub type FuriLogTimestamp = ::core::option::Option<unsafe extern "C" fn() -> u32>;
extern "C" {
	#[doc = " Initialize logging"]
	pub fn furi_log_init();
}
extern "C" {
	#[doc = " Print log record"]
	#[doc = ""]
	#[doc = " @param level"]
	#[doc = " @param tag"]
	#[doc = " @param format"]
	#[doc = " @param ..."]
	pub fn furi_log_print_format(level: FuriLogLevel, tag: *const core::ffi::c_char, format: *const core::ffi::c_char, ...);
}
extern "C" {
	#[doc = " Set log level"]
	#[doc = ""]
	#[doc = " @param[in]  level  The level"]
	pub fn furi_log_set_level(level: FuriLogLevel);
}
extern "C" {
	#[doc = " Get log level"]
	#[doc = ""]
	#[doc = " @return     The furi log level."]
	pub fn furi_log_get_level() -> FuriLogLevel;
}
extern "C" {
	#[doc = " Set log output callback"]
	#[doc = ""]
	#[doc = " @param[in]  puts  The puts callback"]
	pub fn furi_log_set_puts(puts: FuriLogPuts);
}
extern "C" {
	#[doc = " Set timestamp callback"]
	#[doc = ""]
	#[doc = " @param[in]  timestamp  The timestamp callback"]
	pub fn furi_log_set_timestamp(timestamp: FuriLogTimestamp);
}
extern "C" {
	#[doc = " Get free heap size"]
	#[doc = ""]
	#[doc = " @return     free heap size in bytes"]
	pub fn memmgr_get_free_heap() -> usize;
}
extern "C" {
	#[doc = " Get total heap size"]
	#[doc = ""]
	#[doc = " @return     total heap size in bytes"]
	pub fn memmgr_get_total_heap() -> usize;
}
extern "C" {
	#[doc = " Get heap watermark"]
	#[doc = ""]
	#[doc = " @return     minimum heap in bytes"]
	pub fn memmgr_get_minimum_free_heap() -> usize;
}
extern "C" {
	#[doc = " An aligned version of malloc, used when you need to get the aligned space on the heap"]
	#[doc = " Freeing the received address is performed ONLY through the aligned_free function"]
	#[doc = " @param size"]
	#[doc = " @param alignment"]
	#[doc = " @return void*"]
	pub fn aligned_malloc(size: usize, alignment: usize) -> *mut core::ffi::c_void;
}
extern "C" {
	#[doc = " Freed space obtained through the aligned_malloc function"]
	#[doc = " @param p pointer to result of aligned_malloc"]
	pub fn aligned_free(p: *mut core::ffi::c_void);
}
extern "C" {
	#[doc = " @brief Allocate memory from separate memory pool. That memory can't be freed."]
	#[doc = ""]
	#[doc = " @param size"]
	#[doc = " @return void*"]
	pub fn memmgr_alloc_from_pool(size: usize) -> *mut core::ffi::c_void;
}
extern "C" {
	#[doc = " @brief Get free memory pool size"]
	#[doc = ""]
	#[doc = " @return size_t"]
	pub fn memmgr_pool_get_free() -> usize;
}
extern "C" {
	#[doc = " @brief Get max free block size from memory pool"]
	#[doc = ""]
	#[doc = " @return size_t"]
	pub fn memmgr_pool_get_max_block() -> usize;
}
#[repr(u32)]
#[non_exhaustive]
#[doc = " FuriThreadState"]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum FuriThreadState {
	FuriThreadStateStopped = 0,
	FuriThreadStateStarting = 1,
	FuriThreadStateRunning = 2,
}
#[repr(u32)]
#[non_exhaustive]
#[doc = " FuriThreadPriority"]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum FuriThreadPriority {
	#[doc = "< Uninitialized, choose system default"]
	FuriThreadPriorityNone = 0,
	#[doc = "< Idle priority"]
	FuriThreadPriorityIdle = 1,
	#[doc = "< Lowest"]
	FuriThreadPriorityLowest = 14,
	#[doc = "< Low"]
	FuriThreadPriorityLow = 15,
	#[doc = "< Normal"]
	FuriThreadPriorityNormal = 16,
	#[doc = "< High"]
	FuriThreadPriorityHigh = 17,
	#[doc = "< Highest"]
	FuriThreadPriorityHighest = 18,
	#[doc = "< Deffered Isr (highest possible)"]
	FuriThreadPriorityIsr = 32,
}
#[repr(C)]
pub struct FuriThread {
	_unused: [u8; 0],
}
#[doc = " FuriThreadId proxy type to OS low level functions"]
pub type FuriThreadId = *mut core::ffi::c_void;
#[doc = " FuriThreadCallback Your callback to run in new thread"]
#[doc = " @warning    never use osThreadExit in FuriThread"]
pub type FuriThreadCallback = ::core::option::Option<unsafe extern "C" fn(context: *mut core::ffi::c_void) -> i32>;
#[doc = " Write to stdout callback"]
#[doc = " @param      data     pointer to data"]
#[doc = " @param      size     data size @warning your handler must consume everything"]
pub type FuriThreadStdoutWriteCallback = ::core::option::Option<unsafe extern "C" fn(data: *const core::ffi::c_char, size: usize)>;
#[doc = " FuriThread state change calback called upon thread state change"]
#[doc = " @param      state    new thread state"]
#[doc = " @param      context  callback context"]
pub type FuriThreadStateCallback =
	::core::option::Option<unsafe extern "C" fn(state: FuriThreadState, context: *mut core::ffi::c_void)>;
extern "C" {
	#[doc = " Allocate FuriThread"]
	#[doc = ""]
	#[doc = " @return     FuriThread instance"]
	pub fn furi_thread_alloc() -> *mut FuriThread;
}
extern "C" {
	#[doc = " Release FuriThread"]
	#[doc = ""]
	#[doc = " @param      thread  FuriThread instance"]
	pub fn furi_thread_free(thread: *mut FuriThread);
}
extern "C" {
	#[doc = " Set FuriThread name"]
	#[doc = ""]
	#[doc = " @param      thread  FuriThread instance"]
	#[doc = " @param      name    string"]
	pub fn furi_thread_set_name(thread: *mut FuriThread, name: *const core::ffi::c_char);
}
extern "C" {
	#[doc = " Mark thread as service"]
	#[doc = " The service cannot be stopped or removed, and cannot exit from the thread body"]
	#[doc = ""]
	#[doc = " @param thread"]
	pub fn furi_thread_mark_as_service(thread: *mut FuriThread);
}
extern "C" {
	#[doc = " Set FuriThread stack size"]
	#[doc = ""]
	#[doc = " @param      thread      FuriThread instance"]
	#[doc = " @param      stack_size  stack size in bytes"]
	pub fn furi_thread_set_stack_size(thread: *mut FuriThread, stack_size: usize);
}
extern "C" {
	#[doc = " Set FuriThread callback"]
	#[doc = ""]
	#[doc = " @param      thread    FuriThread instance"]
	#[doc = " @param      callback  FuriThreadCallback, called upon thread run"]
	pub fn furi_thread_set_callback(thread: *mut FuriThread, callback: FuriThreadCallback);
}
extern "C" {
	#[doc = " Set FuriThread context"]
	#[doc = ""]
	#[doc = " @param      thread   FuriThread instance"]
	#[doc = " @param      context  pointer to context for thread callback"]
	pub fn furi_thread_set_context(thread: *mut FuriThread, context: *mut core::ffi::c_void);
}
extern "C" {
	#[doc = " Set FuriThread priority"]
	#[doc = ""]
	#[doc = " @param      thread   FuriThread instance"]
	#[doc = " @param      priority FuriThreadPriority value"]
	pub fn furi_thread_set_priority(thread: *mut FuriThread, priority: FuriThreadPriority);
}
extern "C" {
	#[doc = " Set FuriThread state change callback"]
	#[doc = ""]
	#[doc = " @param      thread    FuriThread instance"]
	#[doc = " @param      callback  state change callback"]
	pub fn furi_thread_set_state_callback(thread: *mut FuriThread, callback: FuriThreadStateCallback);
}
extern "C" {
	#[doc = " Set FuriThread state change context"]
	#[doc = ""]
	#[doc = " @param      thread   FuriThread instance"]
	#[doc = " @param      context  pointer to context"]
	pub fn furi_thread_set_state_context(thread: *mut FuriThread, context: *mut core::ffi::c_void);
}
extern "C" {
	#[doc = " Get FuriThread state"]
	#[doc = ""]
	#[doc = " @param      thread  FuriThread instance"]
	#[doc = ""]
	#[doc = " @return     thread state from FuriThreadState"]
	pub fn furi_thread_get_state(thread: *mut FuriThread) -> FuriThreadState;
}
extern "C" {
	#[doc = " Start FuriThread"]
	#[doc = ""]
	#[doc = " @param      thread  FuriThread instance"]
	pub fn furi_thread_start(thread: *mut FuriThread);
}
extern "C" {
	#[doc = " Join FuriThread"]
	#[doc = ""]
	#[doc = " @param      thread  FuriThread instance"]
	#[doc = ""]
	#[doc = " @return     bool"]
	pub fn furi_thread_join(thread: *mut FuriThread) -> bool;
}
extern "C" {
	#[doc = " Get FreeRTOS FuriThreadId for FuriThread instance"]
	#[doc = ""]
	#[doc = " @param      thread  FuriThread instance"]
	#[doc = ""]
	#[doc = " @return     FuriThreadId or NULL"]
	pub fn furi_thread_get_id(thread: *mut FuriThread) -> FuriThreadId;
}
extern "C" {
	#[doc = " Enable heap tracing"]
	#[doc = ""]
	#[doc = " @param      thread  FuriThread instance"]
	pub fn furi_thread_enable_heap_trace(thread: *mut FuriThread);
}
extern "C" {
	#[doc = " Disable heap tracing"]
	#[doc = ""]
	#[doc = " @param      thread  FuriThread instance"]
	pub fn furi_thread_disable_heap_trace(thread: *mut FuriThread);
}
extern "C" {
	#[doc = " Get thread heap size"]
	#[doc = ""]
	#[doc = " @param      thread  FuriThread instance"]
	#[doc = ""]
	#[doc = " @return     size in bytes"]
	pub fn furi_thread_get_heap_size(thread: *mut FuriThread) -> usize;
}
extern "C" {
	#[doc = " Get thread return code"]
	#[doc = ""]
	#[doc = " @param      thread  FuriThread instance"]
	#[doc = ""]
	#[doc = " @return     return code"]
	pub fn furi_thread_get_return_code(thread: *mut FuriThread) -> i32;
}
extern "C" {
	#[doc = " Get FreeRTOS FuriThreadId for current thread"]
	#[doc = ""]
	#[doc = " @param      thread  FuriThread instance"]
	#[doc = ""]
	#[doc = " @return     FuriThreadId or NULL"]
	pub fn furi_thread_get_current_id() -> FuriThreadId;
}
extern "C" {
	#[doc = " Get FuriThread instance for current thread"]
	#[doc = ""]
	#[doc = " @return FuriThread*"]
	pub fn furi_thread_get_current() -> *mut FuriThread;
}
extern "C" {
	#[doc = " Return control to scheduler"]
	pub fn furi_thread_yield();
}
extern "C" {
	pub fn furi_thread_flags_set(thread_id: FuriThreadId, flags: u32) -> u32;
}
extern "C" {
	pub fn furi_thread_flags_clear(flags: u32) -> u32;
}
extern "C" {
	pub fn furi_thread_flags_get() -> u32;
}
extern "C" {
	pub fn furi_thread_flags_wait(flags: u32, options: u32, timeout: u32) -> u32;
}
extern "C" {
	pub fn furi_thread_enumerate(thread_array: *mut FuriThreadId, array_items: u32) -> u32;
}
extern "C" {
	pub fn furi_thread_get_name(thread_id: FuriThreadId) -> *const core::ffi::c_char;
}
extern "C" {
	pub fn furi_thread_get_stack_space(thread_id: FuriThreadId) -> u32;
}
extern "C" {
	#[doc = " Set STDOUT callback for thread"]
	#[doc = ""]
	#[doc = " @param      callback  callback or NULL to clear"]
	#[doc = ""]
	#[doc = " @return     true on success, otherwise fail"]
	pub fn furi_thread_set_stdout_callback(callback: FuriThreadStdoutWriteCallback) -> bool;
}
extern "C" {
	#[doc = " Write data to buffered STDOUT"]
	#[doc = ""]
	#[doc = " @param data input data"]
	#[doc = " @param size input data size"]
	#[doc = ""]
	#[doc = " @return size_t written data size"]
	pub fn furi_thread_stdout_write(data: *const core::ffi::c_char, size: usize) -> usize;
}
extern "C" {
	#[doc = " Flush data to STDOUT"]
	#[doc = ""]
	#[doc = " @return int32_t error code"]
	pub fn furi_thread_stdout_flush() -> i32;
}
extern "C" {
	#[doc = " Suspend thread"]
	#[doc = ""]
	#[doc = " @param thread_id thread id"]
	pub fn furi_thread_suspend(thread_id: FuriThreadId);
}
extern "C" {
	#[doc = " Resume thread"]
	#[doc = ""]
	#[doc = " @param thread_id thread id"]
	pub fn furi_thread_resume(thread_id: FuriThreadId);
}
extern "C" {
	#[doc = " Get thread suspended state"]
	#[doc = ""]
	#[doc = " @param thread_id thread id"]
	#[doc = " @return true if thread is suspended"]
	pub fn furi_thread_is_suspended(thread_id: FuriThreadId) -> bool;
}
extern "C" {
	#[doc = " Memmgr heap enable thread allocation tracking"]
	#[doc = ""]
	#[doc = " @param      thread_id  - thread id to track"]
	pub fn memmgr_heap_enable_thread_trace(taks_handle: FuriThreadId);
}
extern "C" {
	#[doc = " Memmgr heap disable thread allocation tracking"]
	#[doc = ""]
	#[doc = " @param      thread_id  - thread id to track"]
	pub fn memmgr_heap_disable_thread_trace(taks_handle: FuriThreadId);
}
extern "C" {
	#[doc = " Memmgr heap get allocatred thread memory"]
	#[doc = ""]
	#[doc = " @param      thread_id  - thread id to track"]
	#[doc = ""]
	#[doc = " @return     bytes allocated right now"]
	pub fn memmgr_heap_get_thread_memory(taks_handle: FuriThreadId) -> usize;
}
extern "C" {
	#[doc = " Memmgr heap get the max contiguous block size on the heap"]
	#[doc = ""]
	#[doc = " @return     size_t max contiguous block size"]
	pub fn memmgr_heap_get_max_free_block() -> usize;
}
extern "C" {
	#[doc = " Print the address and size of all free blocks to stdout"]
	pub fn memmgr_heap_printf_free_blocks();
}
pub type FuriMessageQueue = core::ffi::c_void;
extern "C" {
	#[doc = " Allocate furi message queue"]
	#[doc = ""]
	#[doc = " @param[in]  msg_count  The message count"]
	#[doc = " @param[in]  msg_size   The message size"]
	#[doc = ""]
	#[doc = " @return     pointer to FuriMessageQueue instance"]
	pub fn furi_message_queue_alloc(msg_count: u32, msg_size: u32) -> *mut FuriMessageQueue;
}
extern "C" {
	#[doc = " Free queue"]
	#[doc = ""]
	#[doc = " @param      instance  pointer to FuriMessageQueue instance"]
	pub fn furi_message_queue_free(instance: *mut FuriMessageQueue);
}
extern "C" {
	#[doc = " Put message into queue"]
	#[doc = ""]
	#[doc = " @param      instance  pointer to FuriMessageQueue instance"]
	#[doc = " @param[in]  msg_ptr   The message pointer"]
	#[doc = " @param[in]  timeout   The timeout"]
	#[doc = " @param[in]  msg_prio  The message prio"]
	#[doc = ""]
	#[doc = " @return     The furi status."]
	pub fn furi_message_queue_put(instance: *mut FuriMessageQueue, msg_ptr: *const core::ffi::c_void, timeout: u32) -> FuriStatus;
}
extern "C" {
	#[doc = " Get message from queue"]
	#[doc = ""]
	#[doc = " @param      instance  pointer to FuriMessageQueue instance"]
	#[doc = " @param      msg_ptr   The message pointer"]
	#[doc = " @param      msg_prio  The message prioority"]
	#[doc = " @param[in]  timeout   The timeout"]
	#[doc = ""]
	#[doc = " @return     The furi status."]
	pub fn furi_message_queue_get(instance: *mut FuriMessageQueue, msg_ptr: *mut core::ffi::c_void, timeout: u32) -> FuriStatus;
}
extern "C" {
	#[doc = " Get queue capacity"]
	#[doc = ""]
	#[doc = " @param      instance  pointer to FuriMessageQueue instance"]
	#[doc = ""]
	#[doc = " @return     capacity in object count"]
	pub fn furi_message_queue_get_capacity(instance: *mut FuriMessageQueue) -> u32;
}
extern "C" {
	#[doc = " Get message size"]
	#[doc = ""]
	#[doc = " @param      instance  pointer to FuriMessageQueue instance"]
	#[doc = ""]
	#[doc = " @return     Message size in bytes"]
	pub fn furi_message_queue_get_message_size(instance: *mut FuriMessageQueue) -> u32;
}
extern "C" {
	#[doc = " Get message count in queue"]
	#[doc = ""]
	#[doc = " @param      instance  pointer to FuriMessageQueue instance"]
	#[doc = ""]
	#[doc = " @return     Message count"]
	pub fn furi_message_queue_get_count(instance: *mut FuriMessageQueue) -> u32;
}
extern "C" {
	#[doc = " Get queue available space"]
	#[doc = ""]
	#[doc = " @param      instance  pointer to FuriMessageQueue instance"]
	#[doc = ""]
	#[doc = " @return     Message count"]
	pub fn furi_message_queue_get_space(instance: *mut FuriMessageQueue) -> u32;
}
extern "C" {
	#[doc = " Reset queue"]
	#[doc = ""]
	#[doc = " @param      instance  pointer to FuriMessageQueue instance"]
	#[doc = ""]
	#[doc = " @return     The furi status."]
	pub fn furi_message_queue_reset(instance: *mut FuriMessageQueue) -> FuriStatus;
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum FuriMutexType {
	FuriMutexTypeNormal = 0,
	FuriMutexTypeRecursive = 1,
}
pub type FuriMutex = core::ffi::c_void;
extern "C" {
	#[doc = " Allocate FuriMutex"]
	#[doc = ""]
	#[doc = " @param[in]  type  The mutex type"]
	#[doc = ""]
	#[doc = " @return     pointer to FuriMutex instance"]
	pub fn furi_mutex_alloc(type_: FuriMutexType) -> *mut FuriMutex;
}
extern "C" {
	#[doc = " Free FuriMutex"]
	#[doc = ""]
	#[doc = " @param      instance  The pointer to FuriMutex instance"]
	pub fn furi_mutex_free(instance: *mut FuriMutex);
}
extern "C" {
	#[doc = " Acquire mutex"]
	#[doc = ""]
	#[doc = " @param      instance  The pointer to FuriMutex instance"]
	#[doc = " @param[in]  timeout   The timeout"]
	#[doc = ""]
	#[doc = " @return     The furi status."]
	pub fn furi_mutex_acquire(instance: *mut FuriMutex, timeout: u32) -> FuriStatus;
}
extern "C" {
	#[doc = " Release mutex"]
	#[doc = ""]
	#[doc = " @param      instance  The pointer to FuriMutex instance"]
	#[doc = ""]
	#[doc = " @return     The furi status."]
	pub fn furi_mutex_release(instance: *mut FuriMutex) -> FuriStatus;
}
extern "C" {
	#[doc = " Get mutex owner thread id"]
	#[doc = ""]
	#[doc = " @param      instance  The pointer to FuriMutex instance"]
	#[doc = ""]
	#[doc = " @return     The furi thread identifier."]
	pub fn furi_mutex_get_owner(instance: *mut FuriMutex) -> FuriThreadId;
}
#[doc = " FuriPubSub Callback type"]
pub type FuriPubSubCallback =
	::core::option::Option<unsafe extern "C" fn(message: *const core::ffi::c_void, context: *mut core::ffi::c_void)>;
#[repr(C)]
pub struct FuriPubSub {
	_unused: [u8; 0],
}
#[repr(C)]
pub struct FuriPubSubSubscription {
	_unused: [u8; 0],
}
extern "C" {
	#[doc = " Allocate FuriPubSub"]
	#[doc = ""]
	#[doc = " Reentrable, Not threadsafe, one owner"]
	#[doc = ""]
	#[doc = " @return     pointer to FuriPubSub instance"]
	pub fn furi_pubsub_alloc() -> *mut FuriPubSub;
}
extern "C" {
	#[doc = " Free FuriPubSub"]
	#[doc = ""]
	#[doc = " @param      pubsub  FuriPubSub instance"]
	pub fn furi_pubsub_free(pubsub: *mut FuriPubSub);
}
extern "C" {
	#[doc = " Subscribe to FuriPubSub"]
	#[doc = ""]
	#[doc = " Threadsafe, Reentrable"]
	#[doc = ""]
	#[doc = " @param      pubsub            pointer to FuriPubSub instance"]
	#[doc = " @param[in]  callback          The callback"]
	#[doc = " @param      callback_context  The callback context"]
	#[doc = ""]
	#[doc = " @return     pointer to FuriPubSubSubscription instance"]
	pub fn furi_pubsub_subscribe(pubsub: *mut FuriPubSub,
	                             callback: FuriPubSubCallback,
	                             callback_context: *mut core::ffi::c_void)
	                             -> *mut FuriPubSubSubscription;
}
extern "C" {
	#[doc = " Unsubscribe from FuriPubSub"]
	#[doc = ""]
	#[doc = " No use of `pubsub_subscription` allowed after call of this method"]
	#[doc = " Threadsafe, Reentrable."]
	#[doc = ""]
	#[doc = " @param      pubsub               pointer to FuriPubSub instance"]
	#[doc = " @param      pubsub_subscription  pointer to FuriPubSubSubscription instance"]
	pub fn furi_pubsub_unsubscribe(pubsub: *mut FuriPubSub, pubsub_subscription: *mut FuriPubSubSubscription);
}
extern "C" {
	#[doc = " Publish message to FuriPubSub"]
	#[doc = ""]
	#[doc = " Threadsafe, Reentrable."]
	#[doc = ""]
	#[doc = " @param      pubsub   pointer to FuriPubSub instance"]
	#[doc = " @param      message  message pointer to publish"]
	pub fn furi_pubsub_publish(pubsub: *mut FuriPubSub, message: *mut core::ffi::c_void);
}
extern "C" {
	#[doc = " Initialize record storage For internal use only."]
	pub fn furi_record_init();
}
extern "C" {
	#[doc = " Check if record exists"]
	#[doc = ""]
	#[doc = " @param      name  record name"]
	#[doc = " @note       Thread safe. Create and destroy must be executed from the same"]
	#[doc = "             thread."]
	pub fn furi_record_exists(name: *const core::ffi::c_char) -> bool;
}
extern "C" {
	#[doc = " Create record"]
	#[doc = ""]
	#[doc = " @param      name  record name"]
	#[doc = " @param      data  data pointer"]
	#[doc = " @note       Thread safe. Create and destroy must be executed from the same"]
	#[doc = "             thread."]
	pub fn furi_record_create(name: *const core::ffi::c_char, data: *mut core::ffi::c_void);
}
extern "C" {
	#[doc = " Destroy record"]
	#[doc = ""]
	#[doc = " @param      name  record name"]
	#[doc = ""]
	#[doc = " @return     true if successful, false if still have holders or thread is not"]
	#[doc = "             owner."]
	#[doc = " @note       Thread safe. Create and destroy must be executed from the same"]
	#[doc = "             thread."]
	pub fn furi_record_destroy(name: *const core::ffi::c_char) -> bool;
}
extern "C" {
	#[doc = " Open record"]
	#[doc = ""]
	#[doc = " @param      name  record name"]
	#[doc = ""]
	#[doc = " @return     pointer to the record"]
	#[doc = " @note       Thread safe. Open and close must be executed from the same"]
	#[doc = "             thread. Suspends caller thread till record is available"]
	pub fn furi_record_open(name: *const core::ffi::c_char) -> *mut core::ffi::c_void;
}
extern "C" {
	#[doc = " Close record"]
	#[doc = ""]
	#[doc = " @param      name  record name"]
	#[doc = " @note       Thread safe. Open and close must be executed from the same"]
	#[doc = "             thread."]
	pub fn furi_record_close(name: *const core::ffi::c_char);
}
pub type FuriSemaphore = core::ffi::c_void;
extern "C" {
	#[doc = " Allocate semaphore"]
	#[doc = ""]
	#[doc = " @param[in]  max_count      The maximum count"]
	#[doc = " @param[in]  initial_count  The initial count"]
	#[doc = ""]
	#[doc = " @return     pointer to FuriSemaphore instance"]
	pub fn furi_semaphore_alloc(max_count: u32, initial_count: u32) -> *mut FuriSemaphore;
}
extern "C" {
	#[doc = " Free semaphore"]
	#[doc = ""]
	#[doc = " @param      instance  The pointer to FuriSemaphore instance"]
	pub fn furi_semaphore_free(instance: *mut FuriSemaphore);
}
extern "C" {
	#[doc = " Acquire semaphore"]
	#[doc = ""]
	#[doc = " @param      instance  The pointer to FuriSemaphore instance"]
	#[doc = " @param[in]  timeout   The timeout"]
	#[doc = ""]
	#[doc = " @return     The furi status."]
	pub fn furi_semaphore_acquire(instance: *mut FuriSemaphore, timeout: u32) -> FuriStatus;
}
extern "C" {
	#[doc = " Release semaphore"]
	#[doc = ""]
	#[doc = " @param      instance  The pointer to FuriSemaphore instance"]
	#[doc = ""]
	#[doc = " @return     The furi status."]
	pub fn furi_semaphore_release(instance: *mut FuriSemaphore) -> FuriStatus;
}
extern "C" {
	#[doc = " Get semaphore count"]
	#[doc = ""]
	#[doc = " @param      instance  The pointer to FuriSemaphore instance"]
	#[doc = ""]
	#[doc = " @return     Semaphore count"]
	pub fn furi_semaphore_get_count(instance: *mut FuriSemaphore) -> u32;
}
pub type FuriTimerCallback = ::core::option::Option<unsafe extern "C" fn(context: *mut core::ffi::c_void)>;
#[repr(u32)]
#[non_exhaustive]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum FuriTimerType {
	#[doc = "< One-shot timer."]
	FuriTimerTypeOnce = 0,
	#[doc = "< Repeating timer."]
	FuriTimerTypePeriodic = 1,
}
pub type FuriTimer = core::ffi::c_void;
extern "C" {
	#[doc = " Allocate timer"]
	#[doc = ""]
	#[doc = " @param[in]  func     The callback function"]
	#[doc = " @param[in]  type     The timer type"]
	#[doc = " @param      context  The callback context"]
	#[doc = ""]
	#[doc = " @return     The pointer to FuriTimer instance"]
	pub fn furi_timer_alloc(func: FuriTimerCallback, type_: FuriTimerType, context: *mut core::ffi::c_void) -> *mut FuriTimer;
}
extern "C" {
	#[doc = " Free timer"]
	#[doc = ""]
	#[doc = " @param      instance  The pointer to FuriTimer instance"]
	pub fn furi_timer_free(instance: *mut FuriTimer);
}
extern "C" {
	#[doc = " Start timer"]
	#[doc = ""]
	#[doc = " @param      instance  The pointer to FuriTimer instance"]
	#[doc = " @param[in]  ticks     The ticks"]
	#[doc = ""]
	#[doc = " @return     The furi status."]
	pub fn furi_timer_start(instance: *mut FuriTimer, ticks: u32) -> FuriStatus;
}
extern "C" {
	#[doc = " Stop timer"]
	#[doc = ""]
	#[doc = " @param      instance  The pointer to FuriTimer instance"]
	#[doc = ""]
	#[doc = " @return     The furi status."]
	pub fn furi_timer_stop(instance: *mut FuriTimer) -> FuriStatus;
}
extern "C" {
	#[doc = " Is timer running"]
	#[doc = ""]
	#[doc = " @param      instance  The pointer to FuriTimer instance"]
	#[doc = ""]
	#[doc = " @return     0: not running, 1: running"]
	pub fn furi_timer_is_running(instance: *mut FuriTimer) -> u32;
}
#[doc = " == ValueMutex =="]
#[doc = ""]
#[doc = " The most simple concept is ValueMutex."]
#[doc = " It is wrapper around mutex and value pointer."]
#[doc = " You can take and give mutex to work with value and read and write value."]
#[repr(C)]
pub struct ValueMutex {
	pub value: *mut core::ffi::c_void,
	pub size: usize,
	pub mutex: *mut FuriMutex,
}
#[test]
fn bindgen_test_layout_ValueMutex() {
	assert_eq!(
	           ::core::mem::size_of::<ValueMutex>(),
	           12usize,
	           concat!("Size of: ", stringify!(ValueMutex))
	);
	assert_eq!(
	           ::core::mem::align_of::<ValueMutex>(),
	           4usize,
	           concat!("Alignment of ", stringify!(ValueMutex))
	);
	fn test_field_value() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<ValueMutex>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).value) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(ValueMutex), "::", stringify!(value))
		);
	}
	test_field_value();
	fn test_field_size() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<ValueMutex>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).size) as usize - ptr as usize
		           },
		           4usize,
		           concat!("Offset of field: ", stringify!(ValueMutex), "::", stringify!(size))
		);
	}
	test_field_size();
	fn test_field_mutex() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<ValueMutex>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).mutex) as usize - ptr as usize
		           },
		           8usize,
		           concat!("Offset of field: ", stringify!(ValueMutex), "::", stringify!(mutex))
		);
	}
	test_field_mutex();
}
extern "C" {
	#[doc = " Creates ValueMutex."]
	pub fn init_mutex(valuemutex: *mut ValueMutex, value: *mut core::ffi::c_void, size: usize) -> bool;
}
extern "C" {
	#[doc = " Free resources allocated by `init_mutex`."]
	#[doc = " This function doesn't free the memory occupied by `ValueMutex` itself."]
	pub fn delete_mutex(valuemutex: *mut ValueMutex) -> bool;
}
extern "C" {
	#[doc = " Call for work with data stored in mutex."]
	#[doc = " @return pointer to data if success, NULL otherwise."]
	pub fn acquire_mutex(valuemutex: *mut ValueMutex, timeout: u32) -> *mut core::ffi::c_void;
}
extern "C" {
	#[doc = " Release mutex after end of work with data."]
	#[doc = " Call `release_mutex` and pass ValueData instance and pointer to data."]
	pub fn release_mutex(valuemutex: *mut ValueMutex, value: *const core::ffi::c_void) -> bool;
}
extern "C" {
	#[doc = " Instead of take-access-give sequence you can use `read_mutex` and `write_mutex` functions."]
	#[doc = " Both functions return true in case of success, false otherwise."]
	pub fn read_mutex(valuemutex: *mut ValueMutex, data: *mut core::ffi::c_void, len: usize, timeout: u32) -> bool;
}
extern "C" {
	pub fn write_mutex(valuemutex: *mut ValueMutex, data: *mut core::ffi::c_void, len: usize, timeout: u32) -> bool;
}
extern "C" {
	pub static mut ITM_RxBuffer: i32;
}
extern "C" {
	#[doc = "< AHB prescalers table values"]
	pub static AHBPrescTable: [u32; 16usize];
}
extern "C" {
	#[doc = "< APB prescalers table values"]
	pub static APBPrescTable: [u32; 8usize];
}
extern "C" {
	#[doc = "< MSI ranges table values"]
	pub static MSIRangeTable: [u32; 16usize];
}
extern "C" {
	#[doc = "< SMPS factor ranges table values"]
	pub static mut SmpsPrescalerTable: [[u32; 6usize]; 4usize];
}
extern "C" {
	#[doc = " @addtogroup STM32WBxx_System_Exported_Functions"]
	#[doc = " @{"]
	pub fn SystemInit();
}
extern "C" {
	pub fn SystemCoreClockUpdate();
}
#[doc = " @brief Analog to Digital Converter"]
#[repr(C)]
pub struct ADC_TypeDef {
	#[doc = "< ADC interrupt and status register,             Address offset: 0x00"]
	pub ISR: u32,
	#[doc = "< ADC interrupt enable register,                 Address offset: 0x04"]
	pub IER: u32,
	#[doc = "< ADC control register,                          Address offset: 0x08"]
	pub CR: u32,
	#[doc = "< ADC configuration register 1,                  Address offset: 0x0C"]
	pub CFGR: u32,
	#[doc = "< ADC configuration register 2,                  Address offset: 0x10"]
	pub CFGR2: u32,
	#[doc = "< ADC sampling time register 1,                  Address offset: 0x14"]
	pub SMPR1: u32,
	#[doc = "< ADC sampling time register 2,                  Address offset: 0x18"]
	pub SMPR2: u32,
	#[doc = "< Reserved,                                                      0x1C"]
	pub RESERVED1: u32,
	#[doc = "< ADC analog watchdog 1 threshold register,      Address offset: 0x20"]
	pub TR1: u32,
	#[doc = "< ADC analog watchdog 2 threshold register,      Address offset: 0x24"]
	pub TR2: u32,
	#[doc = "< ADC analog watchdog 3 threshold register,      Address offset: 0x28"]
	pub TR3: u32,
	#[doc = "< Reserved,                                                      0x2C"]
	pub RESERVED2: u32,
	#[doc = "< ADC group regular sequencer register 1,        Address offset: 0x30"]
	pub SQR1: u32,
	#[doc = "< ADC group regular sequencer register 2,        Address offset: 0x34"]
	pub SQR2: u32,
	#[doc = "< ADC group regular sequencer register 3,        Address offset: 0x38"]
	pub SQR3: u32,
	#[doc = "< ADC group regular sequencer register 4,        Address offset: 0x3C"]
	pub SQR4: u32,
	#[doc = "< ADC group regular data register,               Address offset: 0x40"]
	pub DR: u32,
	#[doc = "< Reserved,                                                      0x44"]
	pub RESERVED3: u32,
	#[doc = "< Reserved,                                                      0x48"]
	pub RESERVED4: u32,
	#[doc = "< ADC group injected sequencer register,         Address offset: 0x4C"]
	pub JSQR: u32,
	#[doc = "< Reserved,                                               0x50 - 0x5C"]
	pub RESERVED5: [u32; 4usize],
	#[doc = "< ADC offset register 1,                         Address offset: 0x60"]
	pub OFR1: u32,
	#[doc = "< ADC offset register 2,                         Address offset: 0x64"]
	pub OFR2: u32,
	#[doc = "< ADC offset register 3,                         Address offset: 0x68"]
	pub OFR3: u32,
	#[doc = "< ADC offset register 4,                         Address offset: 0x6C"]
	pub OFR4: u32,
	#[doc = "< Reserved,                                               0x70 - 0x7C"]
	pub RESERVED6: [u32; 4usize],
	#[doc = "< ADC group injected rank 1 data register,       Address offset: 0x80"]
	pub JDR1: u32,
	#[doc = "< ADC group injected rank 2 data register,       Address offset: 0x84"]
	pub JDR2: u32,
	#[doc = "< ADC group injected rank 3 data register,       Address offset: 0x88"]
	pub JDR3: u32,
	#[doc = "< ADC group injected rank 4 data register,       Address offset: 0x8C"]
	pub JDR4: u32,
	#[doc = "< Reserved,                                             0x090 - 0x09C"]
	pub RESERVED7: [u32; 4usize],
	#[doc = "< ADC analog watchdog 1 configuration register,  Address offset: 0xA0"]
	pub AWD2CR: u32,
	#[doc = "< ADC analog watchdog 3 Configuration Register,  Address offset: 0xA4"]
	pub AWD3CR: u32,
	#[doc = "< Reserved,                                                     0x0A8"]
	pub RESERVED8: u32,
	#[doc = "< Reserved,                                                     0x0AC"]
	pub RESERVED9: u32,
	#[doc = "< ADC differential mode selection register,      Address offset: 0xB0"]
	pub DIFSEL: u32,
	#[doc = "< ADC calibration factors,                       Address offset: 0xB4"]
	pub CALFACT: u32,
}
#[test]
fn bindgen_test_layout_ADC_TypeDef() {
	assert_eq!(
	           ::core::mem::size_of::<ADC_TypeDef>(),
	           184usize,
	           concat!("Size of: ", stringify!(ADC_TypeDef))
	);
	assert_eq!(
	           ::core::mem::align_of::<ADC_TypeDef>(),
	           4usize,
	           concat!("Alignment of ", stringify!(ADC_TypeDef))
	);
	fn test_field_ISR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<ADC_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).ISR) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(ADC_TypeDef), "::", stringify!(ISR))
		);
	}
	test_field_ISR();
	fn test_field_IER() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<ADC_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).IER) as usize - ptr as usize
		           },
		           4usize,
		           concat!("Offset of field: ", stringify!(ADC_TypeDef), "::", stringify!(IER))
		);
	}
	test_field_IER();
	fn test_field_CR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<ADC_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).CR) as usize - ptr as usize
		           },
		           8usize,
		           concat!("Offset of field: ", stringify!(ADC_TypeDef), "::", stringify!(CR))
		);
	}
	test_field_CR();
	fn test_field_CFGR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<ADC_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).CFGR) as usize - ptr as usize
		           },
		           12usize,
		           concat!("Offset of field: ", stringify!(ADC_TypeDef), "::", stringify!(CFGR))
		);
	}
	test_field_CFGR();
	fn test_field_CFGR2() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<ADC_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).CFGR2) as usize - ptr as usize
		           },
		           16usize,
		           concat!("Offset of field: ", stringify!(ADC_TypeDef), "::", stringify!(CFGR2))
		);
	}
	test_field_CFGR2();
	fn test_field_SMPR1() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<ADC_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).SMPR1) as usize - ptr as usize
		           },
		           20usize,
		           concat!("Offset of field: ", stringify!(ADC_TypeDef), "::", stringify!(SMPR1))
		);
	}
	test_field_SMPR1();
	fn test_field_SMPR2() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<ADC_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).SMPR2) as usize - ptr as usize
		           },
		           24usize,
		           concat!("Offset of field: ", stringify!(ADC_TypeDef), "::", stringify!(SMPR2))
		);
	}
	test_field_SMPR2();
	fn test_field_RESERVED1() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<ADC_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).RESERVED1) as usize - ptr as usize
		           },
		           28usize,
		           concat!("Offset of field: ", stringify!(ADC_TypeDef), "::", stringify!(RESERVED1))
		);
	}
	test_field_RESERVED1();
	fn test_field_TR1() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<ADC_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).TR1) as usize - ptr as usize
		           },
		           32usize,
		           concat!("Offset of field: ", stringify!(ADC_TypeDef), "::", stringify!(TR1))
		);
	}
	test_field_TR1();
	fn test_field_TR2() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<ADC_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).TR2) as usize - ptr as usize
		           },
		           36usize,
		           concat!("Offset of field: ", stringify!(ADC_TypeDef), "::", stringify!(TR2))
		);
	}
	test_field_TR2();
	fn test_field_TR3() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<ADC_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).TR3) as usize - ptr as usize
		           },
		           40usize,
		           concat!("Offset of field: ", stringify!(ADC_TypeDef), "::", stringify!(TR3))
		);
	}
	test_field_TR3();
	fn test_field_RESERVED2() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<ADC_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).RESERVED2) as usize - ptr as usize
		           },
		           44usize,
		           concat!("Offset of field: ", stringify!(ADC_TypeDef), "::", stringify!(RESERVED2))
		);
	}
	test_field_RESERVED2();
	fn test_field_SQR1() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<ADC_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).SQR1) as usize - ptr as usize
		           },
		           48usize,
		           concat!("Offset of field: ", stringify!(ADC_TypeDef), "::", stringify!(SQR1))
		);
	}
	test_field_SQR1();
	fn test_field_SQR2() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<ADC_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).SQR2) as usize - ptr as usize
		           },
		           52usize,
		           concat!("Offset of field: ", stringify!(ADC_TypeDef), "::", stringify!(SQR2))
		);
	}
	test_field_SQR2();
	fn test_field_SQR3() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<ADC_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).SQR3) as usize - ptr as usize
		           },
		           56usize,
		           concat!("Offset of field: ", stringify!(ADC_TypeDef), "::", stringify!(SQR3))
		);
	}
	test_field_SQR3();
	fn test_field_SQR4() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<ADC_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).SQR4) as usize - ptr as usize
		           },
		           60usize,
		           concat!("Offset of field: ", stringify!(ADC_TypeDef), "::", stringify!(SQR4))
		);
	}
	test_field_SQR4();
	fn test_field_DR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<ADC_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).DR) as usize - ptr as usize
		           },
		           64usize,
		           concat!("Offset of field: ", stringify!(ADC_TypeDef), "::", stringify!(DR))
		);
	}
	test_field_DR();
	fn test_field_RESERVED3() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<ADC_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).RESERVED3) as usize - ptr as usize
		           },
		           68usize,
		           concat!("Offset of field: ", stringify!(ADC_TypeDef), "::", stringify!(RESERVED3))
		);
	}
	test_field_RESERVED3();
	fn test_field_RESERVED4() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<ADC_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).RESERVED4) as usize - ptr as usize
		           },
		           72usize,
		           concat!("Offset of field: ", stringify!(ADC_TypeDef), "::", stringify!(RESERVED4))
		);
	}
	test_field_RESERVED4();
	fn test_field_JSQR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<ADC_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).JSQR) as usize - ptr as usize
		           },
		           76usize,
		           concat!("Offset of field: ", stringify!(ADC_TypeDef), "::", stringify!(JSQR))
		);
	}
	test_field_JSQR();
	fn test_field_RESERVED5() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<ADC_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).RESERVED5) as usize - ptr as usize
		           },
		           80usize,
		           concat!("Offset of field: ", stringify!(ADC_TypeDef), "::", stringify!(RESERVED5))
		);
	}
	test_field_RESERVED5();
	fn test_field_OFR1() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<ADC_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).OFR1) as usize - ptr as usize
		           },
		           96usize,
		           concat!("Offset of field: ", stringify!(ADC_TypeDef), "::", stringify!(OFR1))
		);
	}
	test_field_OFR1();
	fn test_field_OFR2() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<ADC_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).OFR2) as usize - ptr as usize
		           },
		           100usize,
		           concat!("Offset of field: ", stringify!(ADC_TypeDef), "::", stringify!(OFR2))
		);
	}
	test_field_OFR2();
	fn test_field_OFR3() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<ADC_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).OFR3) as usize - ptr as usize
		           },
		           104usize,
		           concat!("Offset of field: ", stringify!(ADC_TypeDef), "::", stringify!(OFR3))
		);
	}
	test_field_OFR3();
	fn test_field_OFR4() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<ADC_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).OFR4) as usize - ptr as usize
		           },
		           108usize,
		           concat!("Offset of field: ", stringify!(ADC_TypeDef), "::", stringify!(OFR4))
		);
	}
	test_field_OFR4();
	fn test_field_RESERVED6() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<ADC_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).RESERVED6) as usize - ptr as usize
		           },
		           112usize,
		           concat!("Offset of field: ", stringify!(ADC_TypeDef), "::", stringify!(RESERVED6))
		);
	}
	test_field_RESERVED6();
	fn test_field_JDR1() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<ADC_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).JDR1) as usize - ptr as usize
		           },
		           128usize,
		           concat!("Offset of field: ", stringify!(ADC_TypeDef), "::", stringify!(JDR1))
		);
	}
	test_field_JDR1();
	fn test_field_JDR2() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<ADC_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).JDR2) as usize - ptr as usize
		           },
		           132usize,
		           concat!("Offset of field: ", stringify!(ADC_TypeDef), "::", stringify!(JDR2))
		);
	}
	test_field_JDR2();
	fn test_field_JDR3() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<ADC_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).JDR3) as usize - ptr as usize
		           },
		           136usize,
		           concat!("Offset of field: ", stringify!(ADC_TypeDef), "::", stringify!(JDR3))
		);
	}
	test_field_JDR3();
	fn test_field_JDR4() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<ADC_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).JDR4) as usize - ptr as usize
		           },
		           140usize,
		           concat!("Offset of field: ", stringify!(ADC_TypeDef), "::", stringify!(JDR4))
		);
	}
	test_field_JDR4();
	fn test_field_RESERVED7() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<ADC_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).RESERVED7) as usize - ptr as usize
		           },
		           144usize,
		           concat!("Offset of field: ", stringify!(ADC_TypeDef), "::", stringify!(RESERVED7))
		);
	}
	test_field_RESERVED7();
	fn test_field_AWD2CR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<ADC_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).AWD2CR) as usize - ptr as usize
		           },
		           160usize,
		           concat!("Offset of field: ", stringify!(ADC_TypeDef), "::", stringify!(AWD2CR))
		);
	}
	test_field_AWD2CR();
	fn test_field_AWD3CR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<ADC_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).AWD3CR) as usize - ptr as usize
		           },
		           164usize,
		           concat!("Offset of field: ", stringify!(ADC_TypeDef), "::", stringify!(AWD3CR))
		);
	}
	test_field_AWD3CR();
	fn test_field_RESERVED8() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<ADC_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).RESERVED8) as usize - ptr as usize
		           },
		           168usize,
		           concat!("Offset of field: ", stringify!(ADC_TypeDef), "::", stringify!(RESERVED8))
		);
	}
	test_field_RESERVED8();
	fn test_field_RESERVED9() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<ADC_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).RESERVED9) as usize - ptr as usize
		           },
		           172usize,
		           concat!("Offset of field: ", stringify!(ADC_TypeDef), "::", stringify!(RESERVED9))
		);
	}
	test_field_RESERVED9();
	fn test_field_DIFSEL() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<ADC_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).DIFSEL) as usize - ptr as usize
		           },
		           176usize,
		           concat!("Offset of field: ", stringify!(ADC_TypeDef), "::", stringify!(DIFSEL))
		);
	}
	test_field_DIFSEL();
	fn test_field_CALFACT() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<ADC_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).CALFACT) as usize - ptr as usize
		           },
		           180usize,
		           concat!("Offset of field: ", stringify!(ADC_TypeDef), "::", stringify!(CALFACT))
		);
	}
	test_field_CALFACT();
}
#[repr(C)]
pub struct ADC_Common_TypeDef {
	#[doc = "< Reserved,                                      Address offset: ADC1 base address + 0x300"]
	pub RESERVED1: u32,
	#[doc = "< Reserved,                                      Address offset: ADC1 base address + 0x304"]
	pub RESERVED2: u32,
	#[doc = "< ADC common configuration register,             Address offset: ADC1 base address + 0x308"]
	pub CCR: u32,
	#[doc = "< Reserved,                                      Address offset: ADC1 base address + 0x30C"]
	pub RESERVED3: u32,
}
#[test]
fn bindgen_test_layout_ADC_Common_TypeDef() {
	assert_eq!(
	           ::core::mem::size_of::<ADC_Common_TypeDef>(),
	           16usize,
	           concat!("Size of: ", stringify!(ADC_Common_TypeDef))
	);
	assert_eq!(
	           ::core::mem::align_of::<ADC_Common_TypeDef>(),
	           4usize,
	           concat!("Alignment of ", stringify!(ADC_Common_TypeDef))
	);
	fn test_field_RESERVED1() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<ADC_Common_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).RESERVED1) as usize - ptr as usize
		           },
		           0usize,
		           concat!(
			"Offset of field: ",
			stringify!(ADC_Common_TypeDef),
			"::",
			stringify!(RESERVED1)
		)
		);
	}
	test_field_RESERVED1();
	fn test_field_RESERVED2() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<ADC_Common_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).RESERVED2) as usize - ptr as usize
		           },
		           4usize,
		           concat!(
			"Offset of field: ",
			stringify!(ADC_Common_TypeDef),
			"::",
			stringify!(RESERVED2)
		)
		);
	}
	test_field_RESERVED2();
	fn test_field_CCR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<ADC_Common_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).CCR) as usize - ptr as usize
		           },
		           8usize,
		           concat!("Offset of field: ", stringify!(ADC_Common_TypeDef), "::", stringify!(CCR))
		);
	}
	test_field_CCR();
	fn test_field_RESERVED3() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<ADC_Common_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).RESERVED3) as usize - ptr as usize
		           },
		           12usize,
		           concat!(
			"Offset of field: ",
			stringify!(ADC_Common_TypeDef),
			"::",
			stringify!(RESERVED3)
		)
		);
	}
	test_field_RESERVED3();
}
#[doc = " @brief Comparator"]
#[repr(C)]
pub struct COMP_TypeDef {
	#[doc = "< COMP control and status register,               Address offset: 0x00"]
	pub CSR: u32,
}
#[test]
fn bindgen_test_layout_COMP_TypeDef() {
	assert_eq!(
	           ::core::mem::size_of::<COMP_TypeDef>(),
	           4usize,
	           concat!("Size of: ", stringify!(COMP_TypeDef))
	);
	assert_eq!(
	           ::core::mem::align_of::<COMP_TypeDef>(),
	           4usize,
	           concat!("Alignment of ", stringify!(COMP_TypeDef))
	);
	fn test_field_CSR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<COMP_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).CSR) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(COMP_TypeDef), "::", stringify!(CSR))
		);
	}
	test_field_CSR();
}
#[doc = " @brief CRC calculation unit"]
#[repr(C)]
pub struct CRC_TypeDef {
	#[doc = "< CRC Data register,                           Address offset: 0x00"]
	pub DR: u32,
	#[doc = "< CRC Independent data register,               Address offset: 0x04"]
	pub IDR: u32,
	#[doc = "< CRC Control register,                        Address offset: 0x08"]
	pub CR: u32,
	#[doc = "< Reserved,                                                    0x0C"]
	pub RESERVED2: u32,
	#[doc = "< Initial CRC value register,                  Address offset: 0x10"]
	pub INIT: u32,
	#[doc = "< CRC polynomial register,                     Address offset: 0x14"]
	pub POL: u32,
}
#[test]
fn bindgen_test_layout_CRC_TypeDef() {
	assert_eq!(
	           ::core::mem::size_of::<CRC_TypeDef>(),
	           24usize,
	           concat!("Size of: ", stringify!(CRC_TypeDef))
	);
	assert_eq!(
	           ::core::mem::align_of::<CRC_TypeDef>(),
	           4usize,
	           concat!("Alignment of ", stringify!(CRC_TypeDef))
	);
	fn test_field_DR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<CRC_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).DR) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(CRC_TypeDef), "::", stringify!(DR))
		);
	}
	test_field_DR();
	fn test_field_IDR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<CRC_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).IDR) as usize - ptr as usize
		           },
		           4usize,
		           concat!("Offset of field: ", stringify!(CRC_TypeDef), "::", stringify!(IDR))
		);
	}
	test_field_IDR();
	fn test_field_CR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<CRC_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).CR) as usize - ptr as usize
		           },
		           8usize,
		           concat!("Offset of field: ", stringify!(CRC_TypeDef), "::", stringify!(CR))
		);
	}
	test_field_CR();
	fn test_field_RESERVED2() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<CRC_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).RESERVED2) as usize - ptr as usize
		           },
		           12usize,
		           concat!("Offset of field: ", stringify!(CRC_TypeDef), "::", stringify!(RESERVED2))
		);
	}
	test_field_RESERVED2();
	fn test_field_INIT() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<CRC_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).INIT) as usize - ptr as usize
		           },
		           16usize,
		           concat!("Offset of field: ", stringify!(CRC_TypeDef), "::", stringify!(INIT))
		);
	}
	test_field_INIT();
	fn test_field_POL() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<CRC_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).POL) as usize - ptr as usize
		           },
		           20usize,
		           concat!("Offset of field: ", stringify!(CRC_TypeDef), "::", stringify!(POL))
		);
	}
	test_field_POL();
}
#[repr(C)]
pub struct DMA_TypeDef {
	#[doc = "< DMA interrupt status register,                 Address offset: 0x00"]
	pub ISR: u32,
	#[doc = "< DMA interrupt flag clear register,             Address offset: 0x04"]
	pub IFCR: u32,
}
#[test]
fn bindgen_test_layout_DMA_TypeDef() {
	assert_eq!(
	           ::core::mem::size_of::<DMA_TypeDef>(),
	           8usize,
	           concat!("Size of: ", stringify!(DMA_TypeDef))
	);
	assert_eq!(
	           ::core::mem::align_of::<DMA_TypeDef>(),
	           4usize,
	           concat!("Alignment of ", stringify!(DMA_TypeDef))
	);
	fn test_field_ISR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<DMA_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).ISR) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(DMA_TypeDef), "::", stringify!(ISR))
		);
	}
	test_field_ISR();
	fn test_field_IFCR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<DMA_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).IFCR) as usize - ptr as usize
		           },
		           4usize,
		           concat!("Offset of field: ", stringify!(DMA_TypeDef), "::", stringify!(IFCR))
		);
	}
	test_field_IFCR();
}
#[doc = " @brief General Purpose I/O"]
#[repr(C)]
pub struct GPIO_TypeDef {
	#[doc = "< GPIO port mode register,               Address offset: 0x00"]
	pub MODER: u32,
	#[doc = "< GPIO port output type register,        Address offset: 0x04"]
	pub OTYPER: u32,
	#[doc = "< GPIO port output speed register,       Address offset: 0x08"]
	pub OSPEEDR: u32,
	#[doc = "< GPIO port pull-up/pull-down register,  Address offset: 0x0C"]
	pub PUPDR: u32,
	#[doc = "< GPIO port input data register,         Address offset: 0x10"]
	pub IDR: u32,
	#[doc = "< GPIO port output data register,        Address offset: 0x14"]
	pub ODR: u32,
	#[doc = "< GPIO port bit set/reset  register,     Address offset: 0x18"]
	pub BSRR: u32,
	#[doc = "< GPIO port configuration lock register, Address offset: 0x1C"]
	pub LCKR: u32,
	#[doc = "< GPIO alternate function registers,     Address offset: 0x20-0x24"]
	pub AFR: [u32; 2usize],
	#[doc = "< GPIO Bit Reset register,               Address offset: 0x28"]
	pub BRR: u32,
}
#[test]
fn bindgen_test_layout_GPIO_TypeDef() {
	assert_eq!(
	           ::core::mem::size_of::<GPIO_TypeDef>(),
	           44usize,
	           concat!("Size of: ", stringify!(GPIO_TypeDef))
	);
	assert_eq!(
	           ::core::mem::align_of::<GPIO_TypeDef>(),
	           4usize,
	           concat!("Alignment of ", stringify!(GPIO_TypeDef))
	);
	fn test_field_MODER() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<GPIO_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).MODER) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(GPIO_TypeDef), "::", stringify!(MODER))
		);
	}
	test_field_MODER();
	fn test_field_OTYPER() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<GPIO_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).OTYPER) as usize - ptr as usize
		           },
		           4usize,
		           concat!("Offset of field: ", stringify!(GPIO_TypeDef), "::", stringify!(OTYPER))
		);
	}
	test_field_OTYPER();
	fn test_field_OSPEEDR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<GPIO_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).OSPEEDR) as usize - ptr as usize
		           },
		           8usize,
		           concat!("Offset of field: ", stringify!(GPIO_TypeDef), "::", stringify!(OSPEEDR))
		);
	}
	test_field_OSPEEDR();
	fn test_field_PUPDR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<GPIO_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).PUPDR) as usize - ptr as usize
		           },
		           12usize,
		           concat!("Offset of field: ", stringify!(GPIO_TypeDef), "::", stringify!(PUPDR))
		);
	}
	test_field_PUPDR();
	fn test_field_IDR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<GPIO_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).IDR) as usize - ptr as usize
		           },
		           16usize,
		           concat!("Offset of field: ", stringify!(GPIO_TypeDef), "::", stringify!(IDR))
		);
	}
	test_field_IDR();
	fn test_field_ODR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<GPIO_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).ODR) as usize - ptr as usize
		           },
		           20usize,
		           concat!("Offset of field: ", stringify!(GPIO_TypeDef), "::", stringify!(ODR))
		);
	}
	test_field_ODR();
	fn test_field_BSRR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<GPIO_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).BSRR) as usize - ptr as usize
		           },
		           24usize,
		           concat!("Offset of field: ", stringify!(GPIO_TypeDef), "::", stringify!(BSRR))
		);
	}
	test_field_BSRR();
	fn test_field_LCKR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<GPIO_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).LCKR) as usize - ptr as usize
		           },
		           28usize,
		           concat!("Offset of field: ", stringify!(GPIO_TypeDef), "::", stringify!(LCKR))
		);
	}
	test_field_LCKR();
	fn test_field_AFR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<GPIO_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).AFR) as usize - ptr as usize
		           },
		           32usize,
		           concat!("Offset of field: ", stringify!(GPIO_TypeDef), "::", stringify!(AFR))
		);
	}
	test_field_AFR();
	fn test_field_BRR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<GPIO_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).BRR) as usize - ptr as usize
		           },
		           40usize,
		           concat!("Offset of field: ", stringify!(GPIO_TypeDef), "::", stringify!(BRR))
		);
	}
	test_field_BRR();
}
#[doc = " @brief Inter-integrated Circuit Interface"]
#[repr(C)]
pub struct I2C_TypeDef {
	#[doc = "< I2C Control register 1,            Address offset: 0x00"]
	pub CR1: u32,
	#[doc = "< I2C Control register 2,            Address offset: 0x04"]
	pub CR2: u32,
	#[doc = "< I2C Own address 1 register,        Address offset: 0x08"]
	pub OAR1: u32,
	#[doc = "< I2C Own address 2 register,        Address offset: 0x0C"]
	pub OAR2: u32,
	#[doc = "< I2C Timing register,               Address offset: 0x10"]
	pub TIMINGR: u32,
	#[doc = "< I2C Timeout register,              Address offset: 0x14"]
	pub TIMEOUTR: u32,
	#[doc = "< I2C Interrupt and status register, Address offset: 0x18"]
	pub ISR: u32,
	#[doc = "< I2C Interrupt clear register,      Address offset: 0x1C"]
	pub ICR: u32,
	#[doc = "< I2C PEC register,                  Address offset: 0x20"]
	pub PECR: u32,
	#[doc = "< I2C Receive data register,         Address offset: 0x24"]
	pub RXDR: u32,
	#[doc = "< I2C Transmit data register,        Address offset: 0x28"]
	pub TXDR: u32,
}
#[test]
fn bindgen_test_layout_I2C_TypeDef() {
	assert_eq!(
	           ::core::mem::size_of::<I2C_TypeDef>(),
	           44usize,
	           concat!("Size of: ", stringify!(I2C_TypeDef))
	);
	assert_eq!(
	           ::core::mem::align_of::<I2C_TypeDef>(),
	           4usize,
	           concat!("Alignment of ", stringify!(I2C_TypeDef))
	);
	fn test_field_CR1() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<I2C_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).CR1) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(I2C_TypeDef), "::", stringify!(CR1))
		);
	}
	test_field_CR1();
	fn test_field_CR2() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<I2C_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).CR2) as usize - ptr as usize
		           },
		           4usize,
		           concat!("Offset of field: ", stringify!(I2C_TypeDef), "::", stringify!(CR2))
		);
	}
	test_field_CR2();
	fn test_field_OAR1() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<I2C_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).OAR1) as usize - ptr as usize
		           },
		           8usize,
		           concat!("Offset of field: ", stringify!(I2C_TypeDef), "::", stringify!(OAR1))
		);
	}
	test_field_OAR1();
	fn test_field_OAR2() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<I2C_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).OAR2) as usize - ptr as usize
		           },
		           12usize,
		           concat!("Offset of field: ", stringify!(I2C_TypeDef), "::", stringify!(OAR2))
		);
	}
	test_field_OAR2();
	fn test_field_TIMINGR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<I2C_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).TIMINGR) as usize - ptr as usize
		           },
		           16usize,
		           concat!("Offset of field: ", stringify!(I2C_TypeDef), "::", stringify!(TIMINGR))
		);
	}
	test_field_TIMINGR();
	fn test_field_TIMEOUTR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<I2C_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).TIMEOUTR) as usize - ptr as usize
		           },
		           20usize,
		           concat!("Offset of field: ", stringify!(I2C_TypeDef), "::", stringify!(TIMEOUTR))
		);
	}
	test_field_TIMEOUTR();
	fn test_field_ISR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<I2C_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).ISR) as usize - ptr as usize
		           },
		           24usize,
		           concat!("Offset of field: ", stringify!(I2C_TypeDef), "::", stringify!(ISR))
		);
	}
	test_field_ISR();
	fn test_field_ICR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<I2C_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).ICR) as usize - ptr as usize
		           },
		           28usize,
		           concat!("Offset of field: ", stringify!(I2C_TypeDef), "::", stringify!(ICR))
		);
	}
	test_field_ICR();
	fn test_field_PECR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<I2C_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).PECR) as usize - ptr as usize
		           },
		           32usize,
		           concat!("Offset of field: ", stringify!(I2C_TypeDef), "::", stringify!(PECR))
		);
	}
	test_field_PECR();
	fn test_field_RXDR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<I2C_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).RXDR) as usize - ptr as usize
		           },
		           36usize,
		           concat!("Offset of field: ", stringify!(I2C_TypeDef), "::", stringify!(RXDR))
		);
	}
	test_field_RXDR();
	fn test_field_TXDR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<I2C_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).TXDR) as usize - ptr as usize
		           },
		           40usize,
		           concat!("Offset of field: ", stringify!(I2C_TypeDef), "::", stringify!(TXDR))
		);
	}
	test_field_TXDR();
}
#[doc = " @brief LPTIMER"]
#[repr(C)]
pub struct LPTIM_TypeDef {
	#[doc = "< LPTIM Interrupt and Status register,                Address offset: 0x00"]
	pub ISR: u32,
	#[doc = "< LPTIM Interrupt Clear register,                     Address offset: 0x04"]
	pub ICR: u32,
	#[doc = "< LPTIM Interrupt Enable register,                    Address offset: 0x08"]
	pub IER: u32,
	#[doc = "< LPTIM Configuration register,                       Address offset: 0x0C"]
	pub CFGR: u32,
	#[doc = "< LPTIM Control register,                             Address offset: 0x10"]
	pub CR: u32,
	#[doc = "< LPTIM Compare register,                             Address offset: 0x14"]
	pub CMP: u32,
	#[doc = "< LPTIM Autoreload register,                          Address offset: 0x18"]
	pub ARR: u32,
	#[doc = "< LPTIM Counter register,                             Address offset: 0x1C"]
	pub CNT: u32,
	#[doc = "< LPTIM Option register,                              Address offset: 0x20"]
	pub OR: u32,
}
#[test]
fn bindgen_test_layout_LPTIM_TypeDef() {
	assert_eq!(
	           ::core::mem::size_of::<LPTIM_TypeDef>(),
	           36usize,
	           concat!("Size of: ", stringify!(LPTIM_TypeDef))
	);
	assert_eq!(
	           ::core::mem::align_of::<LPTIM_TypeDef>(),
	           4usize,
	           concat!("Alignment of ", stringify!(LPTIM_TypeDef))
	);
	fn test_field_ISR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LPTIM_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).ISR) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(LPTIM_TypeDef), "::", stringify!(ISR))
		);
	}
	test_field_ISR();
	fn test_field_ICR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LPTIM_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).ICR) as usize - ptr as usize
		           },
		           4usize,
		           concat!("Offset of field: ", stringify!(LPTIM_TypeDef), "::", stringify!(ICR))
		);
	}
	test_field_ICR();
	fn test_field_IER() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LPTIM_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).IER) as usize - ptr as usize
		           },
		           8usize,
		           concat!("Offset of field: ", stringify!(LPTIM_TypeDef), "::", stringify!(IER))
		);
	}
	test_field_IER();
	fn test_field_CFGR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LPTIM_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).CFGR) as usize - ptr as usize
		           },
		           12usize,
		           concat!("Offset of field: ", stringify!(LPTIM_TypeDef), "::", stringify!(CFGR))
		);
	}
	test_field_CFGR();
	fn test_field_CR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LPTIM_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).CR) as usize - ptr as usize
		           },
		           16usize,
		           concat!("Offset of field: ", stringify!(LPTIM_TypeDef), "::", stringify!(CR))
		);
	}
	test_field_CR();
	fn test_field_CMP() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LPTIM_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).CMP) as usize - ptr as usize
		           },
		           20usize,
		           concat!("Offset of field: ", stringify!(LPTIM_TypeDef), "::", stringify!(CMP))
		);
	}
	test_field_CMP();
	fn test_field_ARR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LPTIM_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).ARR) as usize - ptr as usize
		           },
		           24usize,
		           concat!("Offset of field: ", stringify!(LPTIM_TypeDef), "::", stringify!(ARR))
		);
	}
	test_field_ARR();
	fn test_field_CNT() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LPTIM_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).CNT) as usize - ptr as usize
		           },
		           28usize,
		           concat!("Offset of field: ", stringify!(LPTIM_TypeDef), "::", stringify!(CNT))
		);
	}
	test_field_CNT();
	fn test_field_OR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LPTIM_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).OR) as usize - ptr as usize
		           },
		           32usize,
		           concat!("Offset of field: ", stringify!(LPTIM_TypeDef), "::", stringify!(OR))
		);
	}
	test_field_OR();
}
#[doc = " @brief Real-Time Clock"]
#[repr(C)]
pub struct RTC_TypeDef {
	#[doc = "< RTC time register,                                         Address offset: 0x00"]
	pub TR: u32,
	#[doc = "< RTC date register,                                         Address offset: 0x04"]
	pub DR: u32,
	#[doc = "< RTC control register,                                      Address offset: 0x08"]
	pub CR: u32,
	#[doc = "< RTC initialization and status register,                    Address offset: 0x0C"]
	pub ISR: u32,
	#[doc = "< RTC prescaler register,                                    Address offset: 0x10"]
	pub PRER: u32,
	#[doc = "< RTC wakeup timer register,                                 Address offset: 0x14"]
	pub WUTR: u32,
	#[doc = "< Reserved,                                                  Address offset: 0x18"]
	pub RESERVED: u32,
	#[doc = "< RTC alarm A register,                                      Address offset: 0x1C"]
	pub ALRMAR: u32,
	#[doc = "< RTC alarm B register,                                      Address offset: 0x20"]
	pub ALRMBR: u32,
	#[doc = "< RTC write protection register,                             Address offset: 0x24"]
	pub WPR: u32,
	#[doc = "< RTC sub second register,                                   Address offset: 0x28"]
	pub SSR: u32,
	#[doc = "< RTC shift control register,                                Address offset: 0x2C"]
	pub SHIFTR: u32,
	#[doc = "< RTC time stamp time register,                              Address offset: 0x30"]
	pub TSTR: u32,
	#[doc = "< RTC time stamp date register,                              Address offset: 0x34"]
	pub TSDR: u32,
	#[doc = "< RTC time-stamp sub second register,                        Address offset: 0x38"]
	pub TSSSR: u32,
	#[doc = "< RTC calibration register,                                  Address offset: 0x3C"]
	pub CALR: u32,
	#[doc = "< RTC tamper configuration register,                         Address offset: 0x40"]
	pub TAMPCR: u32,
	#[doc = "< RTC alarm A sub second register,                           Address offset: 0x44"]
	pub ALRMASSR: u32,
	#[doc = "< RTC alarm B sub second register,                           Address offset: 0x48"]
	pub ALRMBSSR: u32,
	#[doc = "< RTC option register,                                       Address offset  0x4C"]
	pub OR: u32,
	#[doc = "< RTC backup register 0,                                     Address offset: 0x50"]
	pub BKP0R: u32,
	#[doc = "< RTC backup register 1,                                     Address offset: 0x54"]
	pub BKP1R: u32,
	#[doc = "< RTC backup register 2,                                     Address offset: 0x58"]
	pub BKP2R: u32,
	#[doc = "< RTC backup register 3,                                     Address offset: 0x5C"]
	pub BKP3R: u32,
	#[doc = "< RTC backup register 4,                                     Address offset: 0x60"]
	pub BKP4R: u32,
	#[doc = "< RTC backup register 5,                                     Address offset: 0x64"]
	pub BKP5R: u32,
	#[doc = "< RTC backup register 6,                                     Address offset: 0x68"]
	pub BKP6R: u32,
	#[doc = "< RTC backup register 7,                                     Address offset: 0x6C"]
	pub BKP7R: u32,
	#[doc = "< RTC backup register 8,                                     Address offset: 0x70"]
	pub BKP8R: u32,
	#[doc = "< RTC backup register 9,                                     Address offset: 0x74"]
	pub BKP9R: u32,
	#[doc = "< RTC backup register 10,                                    Address offset: 0x78"]
	pub BKP10R: u32,
	#[doc = "< RTC backup register 11,                                    Address offset: 0x7C"]
	pub BKP11R: u32,
	#[doc = "< RTC backup register 12,                                    Address offset: 0x80"]
	pub BKP12R: u32,
	#[doc = "< RTC backup register 13,                                    Address offset: 0x84"]
	pub BKP13R: u32,
	#[doc = "< RTC backup register 14,                                    Address offset: 0x88"]
	pub BKP14R: u32,
	#[doc = "< RTC backup register 15,                                    Address offset: 0x8C"]
	pub BKP15R: u32,
	#[doc = "< RTC backup register 16,                                    Address offset: 0x90"]
	pub BKP16R: u32,
	#[doc = "< RTC backup register 17,                                    Address offset: 0x94"]
	pub BKP17R: u32,
	#[doc = "< RTC backup register 18,                                    Address offset: 0x98"]
	pub BKP18R: u32,
	#[doc = "< RTC backup register 19,                                    Address offset: 0x9C"]
	pub BKP19R: u32,
}
#[test]
fn bindgen_test_layout_RTC_TypeDef() {
	assert_eq!(
	           ::core::mem::size_of::<RTC_TypeDef>(),
	           160usize,
	           concat!("Size of: ", stringify!(RTC_TypeDef))
	);
	assert_eq!(
	           ::core::mem::align_of::<RTC_TypeDef>(),
	           4usize,
	           concat!("Alignment of ", stringify!(RTC_TypeDef))
	);
	fn test_field_TR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<RTC_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).TR) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(RTC_TypeDef), "::", stringify!(TR))
		);
	}
	test_field_TR();
	fn test_field_DR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<RTC_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).DR) as usize - ptr as usize
		           },
		           4usize,
		           concat!("Offset of field: ", stringify!(RTC_TypeDef), "::", stringify!(DR))
		);
	}
	test_field_DR();
	fn test_field_CR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<RTC_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).CR) as usize - ptr as usize
		           },
		           8usize,
		           concat!("Offset of field: ", stringify!(RTC_TypeDef), "::", stringify!(CR))
		);
	}
	test_field_CR();
	fn test_field_ISR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<RTC_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).ISR) as usize - ptr as usize
		           },
		           12usize,
		           concat!("Offset of field: ", stringify!(RTC_TypeDef), "::", stringify!(ISR))
		);
	}
	test_field_ISR();
	fn test_field_PRER() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<RTC_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).PRER) as usize - ptr as usize
		           },
		           16usize,
		           concat!("Offset of field: ", stringify!(RTC_TypeDef), "::", stringify!(PRER))
		);
	}
	test_field_PRER();
	fn test_field_WUTR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<RTC_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).WUTR) as usize - ptr as usize
		           },
		           20usize,
		           concat!("Offset of field: ", stringify!(RTC_TypeDef), "::", stringify!(WUTR))
		);
	}
	test_field_WUTR();
	fn test_field_RESERVED() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<RTC_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).RESERVED) as usize - ptr as usize
		           },
		           24usize,
		           concat!("Offset of field: ", stringify!(RTC_TypeDef), "::", stringify!(RESERVED))
		);
	}
	test_field_RESERVED();
	fn test_field_ALRMAR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<RTC_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).ALRMAR) as usize - ptr as usize
		           },
		           28usize,
		           concat!("Offset of field: ", stringify!(RTC_TypeDef), "::", stringify!(ALRMAR))
		);
	}
	test_field_ALRMAR();
	fn test_field_ALRMBR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<RTC_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).ALRMBR) as usize - ptr as usize
		           },
		           32usize,
		           concat!("Offset of field: ", stringify!(RTC_TypeDef), "::", stringify!(ALRMBR))
		);
	}
	test_field_ALRMBR();
	fn test_field_WPR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<RTC_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).WPR) as usize - ptr as usize
		           },
		           36usize,
		           concat!("Offset of field: ", stringify!(RTC_TypeDef), "::", stringify!(WPR))
		);
	}
	test_field_WPR();
	fn test_field_SSR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<RTC_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).SSR) as usize - ptr as usize
		           },
		           40usize,
		           concat!("Offset of field: ", stringify!(RTC_TypeDef), "::", stringify!(SSR))
		);
	}
	test_field_SSR();
	fn test_field_SHIFTR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<RTC_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).SHIFTR) as usize - ptr as usize
		           },
		           44usize,
		           concat!("Offset of field: ", stringify!(RTC_TypeDef), "::", stringify!(SHIFTR))
		);
	}
	test_field_SHIFTR();
	fn test_field_TSTR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<RTC_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).TSTR) as usize - ptr as usize
		           },
		           48usize,
		           concat!("Offset of field: ", stringify!(RTC_TypeDef), "::", stringify!(TSTR))
		);
	}
	test_field_TSTR();
	fn test_field_TSDR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<RTC_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).TSDR) as usize - ptr as usize
		           },
		           52usize,
		           concat!("Offset of field: ", stringify!(RTC_TypeDef), "::", stringify!(TSDR))
		);
	}
	test_field_TSDR();
	fn test_field_TSSSR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<RTC_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).TSSSR) as usize - ptr as usize
		           },
		           56usize,
		           concat!("Offset of field: ", stringify!(RTC_TypeDef), "::", stringify!(TSSSR))
		);
	}
	test_field_TSSSR();
	fn test_field_CALR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<RTC_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).CALR) as usize - ptr as usize
		           },
		           60usize,
		           concat!("Offset of field: ", stringify!(RTC_TypeDef), "::", stringify!(CALR))
		);
	}
	test_field_CALR();
	fn test_field_TAMPCR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<RTC_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).TAMPCR) as usize - ptr as usize
		           },
		           64usize,
		           concat!("Offset of field: ", stringify!(RTC_TypeDef), "::", stringify!(TAMPCR))
		);
	}
	test_field_TAMPCR();
	fn test_field_ALRMASSR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<RTC_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).ALRMASSR) as usize - ptr as usize
		           },
		           68usize,
		           concat!("Offset of field: ", stringify!(RTC_TypeDef), "::", stringify!(ALRMASSR))
		);
	}
	test_field_ALRMASSR();
	fn test_field_ALRMBSSR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<RTC_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).ALRMBSSR) as usize - ptr as usize
		           },
		           72usize,
		           concat!("Offset of field: ", stringify!(RTC_TypeDef), "::", stringify!(ALRMBSSR))
		);
	}
	test_field_ALRMBSSR();
	fn test_field_OR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<RTC_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).OR) as usize - ptr as usize
		           },
		           76usize,
		           concat!("Offset of field: ", stringify!(RTC_TypeDef), "::", stringify!(OR))
		);
	}
	test_field_OR();
	fn test_field_BKP0R() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<RTC_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).BKP0R) as usize - ptr as usize
		           },
		           80usize,
		           concat!("Offset of field: ", stringify!(RTC_TypeDef), "::", stringify!(BKP0R))
		);
	}
	test_field_BKP0R();
	fn test_field_BKP1R() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<RTC_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).BKP1R) as usize - ptr as usize
		           },
		           84usize,
		           concat!("Offset of field: ", stringify!(RTC_TypeDef), "::", stringify!(BKP1R))
		);
	}
	test_field_BKP1R();
	fn test_field_BKP2R() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<RTC_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).BKP2R) as usize - ptr as usize
		           },
		           88usize,
		           concat!("Offset of field: ", stringify!(RTC_TypeDef), "::", stringify!(BKP2R))
		);
	}
	test_field_BKP2R();
	fn test_field_BKP3R() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<RTC_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).BKP3R) as usize - ptr as usize
		           },
		           92usize,
		           concat!("Offset of field: ", stringify!(RTC_TypeDef), "::", stringify!(BKP3R))
		);
	}
	test_field_BKP3R();
	fn test_field_BKP4R() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<RTC_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).BKP4R) as usize - ptr as usize
		           },
		           96usize,
		           concat!("Offset of field: ", stringify!(RTC_TypeDef), "::", stringify!(BKP4R))
		);
	}
	test_field_BKP4R();
	fn test_field_BKP5R() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<RTC_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).BKP5R) as usize - ptr as usize
		           },
		           100usize,
		           concat!("Offset of field: ", stringify!(RTC_TypeDef), "::", stringify!(BKP5R))
		);
	}
	test_field_BKP5R();
	fn test_field_BKP6R() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<RTC_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).BKP6R) as usize - ptr as usize
		           },
		           104usize,
		           concat!("Offset of field: ", stringify!(RTC_TypeDef), "::", stringify!(BKP6R))
		);
	}
	test_field_BKP6R();
	fn test_field_BKP7R() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<RTC_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).BKP7R) as usize - ptr as usize
		           },
		           108usize,
		           concat!("Offset of field: ", stringify!(RTC_TypeDef), "::", stringify!(BKP7R))
		);
	}
	test_field_BKP7R();
	fn test_field_BKP8R() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<RTC_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).BKP8R) as usize - ptr as usize
		           },
		           112usize,
		           concat!("Offset of field: ", stringify!(RTC_TypeDef), "::", stringify!(BKP8R))
		);
	}
	test_field_BKP8R();
	fn test_field_BKP9R() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<RTC_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).BKP9R) as usize - ptr as usize
		           },
		           116usize,
		           concat!("Offset of field: ", stringify!(RTC_TypeDef), "::", stringify!(BKP9R))
		);
	}
	test_field_BKP9R();
	fn test_field_BKP10R() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<RTC_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).BKP10R) as usize - ptr as usize
		           },
		           120usize,
		           concat!("Offset of field: ", stringify!(RTC_TypeDef), "::", stringify!(BKP10R))
		);
	}
	test_field_BKP10R();
	fn test_field_BKP11R() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<RTC_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).BKP11R) as usize - ptr as usize
		           },
		           124usize,
		           concat!("Offset of field: ", stringify!(RTC_TypeDef), "::", stringify!(BKP11R))
		);
	}
	test_field_BKP11R();
	fn test_field_BKP12R() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<RTC_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).BKP12R) as usize - ptr as usize
		           },
		           128usize,
		           concat!("Offset of field: ", stringify!(RTC_TypeDef), "::", stringify!(BKP12R))
		);
	}
	test_field_BKP12R();
	fn test_field_BKP13R() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<RTC_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).BKP13R) as usize - ptr as usize
		           },
		           132usize,
		           concat!("Offset of field: ", stringify!(RTC_TypeDef), "::", stringify!(BKP13R))
		);
	}
	test_field_BKP13R();
	fn test_field_BKP14R() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<RTC_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).BKP14R) as usize - ptr as usize
		           },
		           136usize,
		           concat!("Offset of field: ", stringify!(RTC_TypeDef), "::", stringify!(BKP14R))
		);
	}
	test_field_BKP14R();
	fn test_field_BKP15R() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<RTC_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).BKP15R) as usize - ptr as usize
		           },
		           140usize,
		           concat!("Offset of field: ", stringify!(RTC_TypeDef), "::", stringify!(BKP15R))
		);
	}
	test_field_BKP15R();
	fn test_field_BKP16R() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<RTC_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).BKP16R) as usize - ptr as usize
		           },
		           144usize,
		           concat!("Offset of field: ", stringify!(RTC_TypeDef), "::", stringify!(BKP16R))
		);
	}
	test_field_BKP16R();
	fn test_field_BKP17R() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<RTC_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).BKP17R) as usize - ptr as usize
		           },
		           148usize,
		           concat!("Offset of field: ", stringify!(RTC_TypeDef), "::", stringify!(BKP17R))
		);
	}
	test_field_BKP17R();
	fn test_field_BKP18R() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<RTC_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).BKP18R) as usize - ptr as usize
		           },
		           152usize,
		           concat!("Offset of field: ", stringify!(RTC_TypeDef), "::", stringify!(BKP18R))
		);
	}
	test_field_BKP18R();
	fn test_field_BKP19R() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<RTC_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).BKP19R) as usize - ptr as usize
		           },
		           156usize,
		           concat!("Offset of field: ", stringify!(RTC_TypeDef), "::", stringify!(BKP19R))
		);
	}
	test_field_BKP19R();
}
#[doc = " @brief Serial Peripheral Interface"]
#[repr(C)]
pub struct SPI_TypeDef {
	#[doc = "< SPI Control register 1,       Address offset: 0x00"]
	pub CR1: u32,
	#[doc = "< SPI Control register 2,       Address offset: 0x04"]
	pub CR2: u32,
	#[doc = "< SPI Status register,          Address offset: 0x08"]
	pub SR: u32,
	#[doc = "< SPI data register,            Address offset: 0x0C"]
	pub DR: u32,
	#[doc = "< SPI CRC polynomial register,  Address offset: 0x10"]
	pub CRCPR: u32,
	#[doc = "< SPI Rx CRC register,          Address offset: 0x14"]
	pub RXCRCR: u32,
	#[doc = "< SPI Tx CRC register,          Address offset: 0x18"]
	pub TXCRCR: u32,
}
#[test]
fn bindgen_test_layout_SPI_TypeDef() {
	assert_eq!(
	           ::core::mem::size_of::<SPI_TypeDef>(),
	           28usize,
	           concat!("Size of: ", stringify!(SPI_TypeDef))
	);
	assert_eq!(
	           ::core::mem::align_of::<SPI_TypeDef>(),
	           4usize,
	           concat!("Alignment of ", stringify!(SPI_TypeDef))
	);
	fn test_field_CR1() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<SPI_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).CR1) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(SPI_TypeDef), "::", stringify!(CR1))
		);
	}
	test_field_CR1();
	fn test_field_CR2() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<SPI_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).CR2) as usize - ptr as usize
		           },
		           4usize,
		           concat!("Offset of field: ", stringify!(SPI_TypeDef), "::", stringify!(CR2))
		);
	}
	test_field_CR2();
	fn test_field_SR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<SPI_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).SR) as usize - ptr as usize
		           },
		           8usize,
		           concat!("Offset of field: ", stringify!(SPI_TypeDef), "::", stringify!(SR))
		);
	}
	test_field_SR();
	fn test_field_DR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<SPI_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).DR) as usize - ptr as usize
		           },
		           12usize,
		           concat!("Offset of field: ", stringify!(SPI_TypeDef), "::", stringify!(DR))
		);
	}
	test_field_DR();
	fn test_field_CRCPR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<SPI_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).CRCPR) as usize - ptr as usize
		           },
		           16usize,
		           concat!("Offset of field: ", stringify!(SPI_TypeDef), "::", stringify!(CRCPR))
		);
	}
	test_field_CRCPR();
	fn test_field_RXCRCR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<SPI_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).RXCRCR) as usize - ptr as usize
		           },
		           20usize,
		           concat!("Offset of field: ", stringify!(SPI_TypeDef), "::", stringify!(RXCRCR))
		);
	}
	test_field_RXCRCR();
	fn test_field_TXCRCR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<SPI_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).TXCRCR) as usize - ptr as usize
		           },
		           24usize,
		           concat!("Offset of field: ", stringify!(SPI_TypeDef), "::", stringify!(TXCRCR))
		);
	}
	test_field_TXCRCR();
}
#[doc = " @brief TIM"]
#[repr(C)]
pub struct TIM_TypeDef {
	#[doc = "< TIM control register 1,                   Address offset: 0x00"]
	pub CR1: u32,
	#[doc = "< TIM control register 2,                   Address offset: 0x04"]
	pub CR2: u32,
	#[doc = "< TIM slave mode control register,          Address offset: 0x08"]
	pub SMCR: u32,
	#[doc = "< TIM DMA/interrupt enable register,        Address offset: 0x0C"]
	pub DIER: u32,
	#[doc = "< TIM status register,                      Address offset: 0x10"]
	pub SR: u32,
	#[doc = "< TIM event generation register,            Address offset: 0x14"]
	pub EGR: u32,
	#[doc = "< TIM capture/compare mode register 1,      Address offset: 0x18"]
	pub CCMR1: u32,
	#[doc = "< TIM capture/compare mode register 2,      Address offset: 0x1C"]
	pub CCMR2: u32,
	#[doc = "< TIM capture/compare enable register,      Address offset: 0x20"]
	pub CCER: u32,
	#[doc = "< TIM counter register,                     Address offset: 0x24"]
	pub CNT: u32,
	#[doc = "< TIM prescaler register,                   Address offset: 0x28"]
	pub PSC: u32,
	#[doc = "< TIM auto-reload register,                 Address offset: 0x2C"]
	pub ARR: u32,
	#[doc = "< TIM repetition counter register,          Address offset: 0x30"]
	pub RCR: u32,
	#[doc = "< TIM capture/compare register 1,           Address offset: 0x34"]
	pub CCR1: u32,
	#[doc = "< TIM capture/compare register 2,           Address offset: 0x38"]
	pub CCR2: u32,
	#[doc = "< TIM capture/compare register 3,           Address offset: 0x3C"]
	pub CCR3: u32,
	#[doc = "< TIM capture/compare register 4,           Address offset: 0x40"]
	pub CCR4: u32,
	#[doc = "< TIM break and dead-time register,         Address offset: 0x44"]
	pub BDTR: u32,
	#[doc = "< TIM DMA control register,                 Address offset: 0x48"]
	pub DCR: u32,
	#[doc = "< TIM DMA address for full transfer,        Address offset: 0x4C"]
	pub DMAR: u32,
	#[doc = "< TIM option register                       Address offset: 0x50"]
	pub OR: u32,
	#[doc = "< TIM capture/compare mode register 3,      Address offset: 0x54"]
	pub CCMR3: u32,
	#[doc = "< TIM capture/compare register5,            Address offset: 0x58"]
	pub CCR5: u32,
	#[doc = "< TIM capture/compare register6,            Address offset: 0x5C"]
	pub CCR6: u32,
	#[doc = "< TIM Alternate function option register 1, Address offset: 0x60"]
	pub AF1: u32,
	#[doc = "< TIM Alternate function option register 2, Address offset: 0x64"]
	pub AF2: u32,
}
#[test]
fn bindgen_test_layout_TIM_TypeDef() {
	assert_eq!(
	           ::core::mem::size_of::<TIM_TypeDef>(),
	           104usize,
	           concat!("Size of: ", stringify!(TIM_TypeDef))
	);
	assert_eq!(
	           ::core::mem::align_of::<TIM_TypeDef>(),
	           4usize,
	           concat!("Alignment of ", stringify!(TIM_TypeDef))
	);
	fn test_field_CR1() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<TIM_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).CR1) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(TIM_TypeDef), "::", stringify!(CR1))
		);
	}
	test_field_CR1();
	fn test_field_CR2() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<TIM_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).CR2) as usize - ptr as usize
		           },
		           4usize,
		           concat!("Offset of field: ", stringify!(TIM_TypeDef), "::", stringify!(CR2))
		);
	}
	test_field_CR2();
	fn test_field_SMCR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<TIM_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).SMCR) as usize - ptr as usize
		           },
		           8usize,
		           concat!("Offset of field: ", stringify!(TIM_TypeDef), "::", stringify!(SMCR))
		);
	}
	test_field_SMCR();
	fn test_field_DIER() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<TIM_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).DIER) as usize - ptr as usize
		           },
		           12usize,
		           concat!("Offset of field: ", stringify!(TIM_TypeDef), "::", stringify!(DIER))
		);
	}
	test_field_DIER();
	fn test_field_SR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<TIM_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).SR) as usize - ptr as usize
		           },
		           16usize,
		           concat!("Offset of field: ", stringify!(TIM_TypeDef), "::", stringify!(SR))
		);
	}
	test_field_SR();
	fn test_field_EGR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<TIM_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).EGR) as usize - ptr as usize
		           },
		           20usize,
		           concat!("Offset of field: ", stringify!(TIM_TypeDef), "::", stringify!(EGR))
		);
	}
	test_field_EGR();
	fn test_field_CCMR1() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<TIM_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).CCMR1) as usize - ptr as usize
		           },
		           24usize,
		           concat!("Offset of field: ", stringify!(TIM_TypeDef), "::", stringify!(CCMR1))
		);
	}
	test_field_CCMR1();
	fn test_field_CCMR2() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<TIM_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).CCMR2) as usize - ptr as usize
		           },
		           28usize,
		           concat!("Offset of field: ", stringify!(TIM_TypeDef), "::", stringify!(CCMR2))
		);
	}
	test_field_CCMR2();
	fn test_field_CCER() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<TIM_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).CCER) as usize - ptr as usize
		           },
		           32usize,
		           concat!("Offset of field: ", stringify!(TIM_TypeDef), "::", stringify!(CCER))
		);
	}
	test_field_CCER();
	fn test_field_CNT() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<TIM_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).CNT) as usize - ptr as usize
		           },
		           36usize,
		           concat!("Offset of field: ", stringify!(TIM_TypeDef), "::", stringify!(CNT))
		);
	}
	test_field_CNT();
	fn test_field_PSC() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<TIM_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).PSC) as usize - ptr as usize
		           },
		           40usize,
		           concat!("Offset of field: ", stringify!(TIM_TypeDef), "::", stringify!(PSC))
		);
	}
	test_field_PSC();
	fn test_field_ARR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<TIM_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).ARR) as usize - ptr as usize
		           },
		           44usize,
		           concat!("Offset of field: ", stringify!(TIM_TypeDef), "::", stringify!(ARR))
		);
	}
	test_field_ARR();
	fn test_field_RCR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<TIM_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).RCR) as usize - ptr as usize
		           },
		           48usize,
		           concat!("Offset of field: ", stringify!(TIM_TypeDef), "::", stringify!(RCR))
		);
	}
	test_field_RCR();
	fn test_field_CCR1() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<TIM_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).CCR1) as usize - ptr as usize
		           },
		           52usize,
		           concat!("Offset of field: ", stringify!(TIM_TypeDef), "::", stringify!(CCR1))
		);
	}
	test_field_CCR1();
	fn test_field_CCR2() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<TIM_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).CCR2) as usize - ptr as usize
		           },
		           56usize,
		           concat!("Offset of field: ", stringify!(TIM_TypeDef), "::", stringify!(CCR2))
		);
	}
	test_field_CCR2();
	fn test_field_CCR3() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<TIM_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).CCR3) as usize - ptr as usize
		           },
		           60usize,
		           concat!("Offset of field: ", stringify!(TIM_TypeDef), "::", stringify!(CCR3))
		);
	}
	test_field_CCR3();
	fn test_field_CCR4() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<TIM_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).CCR4) as usize - ptr as usize
		           },
		           64usize,
		           concat!("Offset of field: ", stringify!(TIM_TypeDef), "::", stringify!(CCR4))
		);
	}
	test_field_CCR4();
	fn test_field_BDTR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<TIM_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).BDTR) as usize - ptr as usize
		           },
		           68usize,
		           concat!("Offset of field: ", stringify!(TIM_TypeDef), "::", stringify!(BDTR))
		);
	}
	test_field_BDTR();
	fn test_field_DCR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<TIM_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).DCR) as usize - ptr as usize
		           },
		           72usize,
		           concat!("Offset of field: ", stringify!(TIM_TypeDef), "::", stringify!(DCR))
		);
	}
	test_field_DCR();
	fn test_field_DMAR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<TIM_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).DMAR) as usize - ptr as usize
		           },
		           76usize,
		           concat!("Offset of field: ", stringify!(TIM_TypeDef), "::", stringify!(DMAR))
		);
	}
	test_field_DMAR();
	fn test_field_OR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<TIM_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).OR) as usize - ptr as usize
		           },
		           80usize,
		           concat!("Offset of field: ", stringify!(TIM_TypeDef), "::", stringify!(OR))
		);
	}
	test_field_OR();
	fn test_field_CCMR3() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<TIM_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).CCMR3) as usize - ptr as usize
		           },
		           84usize,
		           concat!("Offset of field: ", stringify!(TIM_TypeDef), "::", stringify!(CCMR3))
		);
	}
	test_field_CCMR3();
	fn test_field_CCR5() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<TIM_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).CCR5) as usize - ptr as usize
		           },
		           88usize,
		           concat!("Offset of field: ", stringify!(TIM_TypeDef), "::", stringify!(CCR5))
		);
	}
	test_field_CCR5();
	fn test_field_CCR6() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<TIM_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).CCR6) as usize - ptr as usize
		           },
		           92usize,
		           concat!("Offset of field: ", stringify!(TIM_TypeDef), "::", stringify!(CCR6))
		);
	}
	test_field_CCR6();
	fn test_field_AF1() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<TIM_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).AF1) as usize - ptr as usize
		           },
		           96usize,
		           concat!("Offset of field: ", stringify!(TIM_TypeDef), "::", stringify!(AF1))
		);
	}
	test_field_AF1();
	fn test_field_AF2() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<TIM_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).AF2) as usize - ptr as usize
		           },
		           100usize,
		           concat!("Offset of field: ", stringify!(TIM_TypeDef), "::", stringify!(AF2))
		);
	}
	test_field_AF2();
}
#[doc = " @brief Universal Synchronous Asynchronous Receiver Transmitter"]
#[repr(C)]
pub struct USART_TypeDef {
	#[doc = "< USART Control register 1,                 Address offset: 0x00"]
	pub CR1: u32,
	#[doc = "< USART Control register 2,                 Address offset: 0x04"]
	pub CR2: u32,
	#[doc = "< USART Control register 3,                 Address offset: 0x08"]
	pub CR3: u32,
	#[doc = "< USART Baud rate register,                 Address offset: 0x0C"]
	pub BRR: u32,
	#[doc = "< USART Guard time and prescaler register,  Address offset: 0x10"]
	pub GTPR: u32,
	#[doc = "< USART Receiver Time Out register,         Address offset: 0x14"]
	pub RTOR: u32,
	#[doc = "< USART Request register,                   Address offset: 0x18"]
	pub RQR: u32,
	#[doc = "< USART Interrupt and status register,      Address offset: 0x1C"]
	pub ISR: u32,
	#[doc = "< USART Interrupt flag Clear register,      Address offset: 0x20"]
	pub ICR: u32,
	#[doc = "< USART Receive Data register,              Address offset: 0x24"]
	pub RDR: u32,
	#[doc = "< USART Transmit Data register,             Address offset: 0x28"]
	pub TDR: u32,
	#[doc = "< USART Prescaler register,                 Address offset: 0x2C"]
	pub PRESC: u32,
}
#[test]
fn bindgen_test_layout_USART_TypeDef() {
	assert_eq!(
	           ::core::mem::size_of::<USART_TypeDef>(),
	           48usize,
	           concat!("Size of: ", stringify!(USART_TypeDef))
	);
	assert_eq!(
	           ::core::mem::align_of::<USART_TypeDef>(),
	           4usize,
	           concat!("Alignment of ", stringify!(USART_TypeDef))
	);
	fn test_field_CR1() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<USART_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).CR1) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(USART_TypeDef), "::", stringify!(CR1))
		);
	}
	test_field_CR1();
	fn test_field_CR2() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<USART_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).CR2) as usize - ptr as usize
		           },
		           4usize,
		           concat!("Offset of field: ", stringify!(USART_TypeDef), "::", stringify!(CR2))
		);
	}
	test_field_CR2();
	fn test_field_CR3() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<USART_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).CR3) as usize - ptr as usize
		           },
		           8usize,
		           concat!("Offset of field: ", stringify!(USART_TypeDef), "::", stringify!(CR3))
		);
	}
	test_field_CR3();
	fn test_field_BRR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<USART_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).BRR) as usize - ptr as usize
		           },
		           12usize,
		           concat!("Offset of field: ", stringify!(USART_TypeDef), "::", stringify!(BRR))
		);
	}
	test_field_BRR();
	fn test_field_GTPR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<USART_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).GTPR) as usize - ptr as usize
		           },
		           16usize,
		           concat!("Offset of field: ", stringify!(USART_TypeDef), "::", stringify!(GTPR))
		);
	}
	test_field_GTPR();
	fn test_field_RTOR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<USART_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).RTOR) as usize - ptr as usize
		           },
		           20usize,
		           concat!("Offset of field: ", stringify!(USART_TypeDef), "::", stringify!(RTOR))
		);
	}
	test_field_RTOR();
	fn test_field_RQR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<USART_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).RQR) as usize - ptr as usize
		           },
		           24usize,
		           concat!("Offset of field: ", stringify!(USART_TypeDef), "::", stringify!(RQR))
		);
	}
	test_field_RQR();
	fn test_field_ISR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<USART_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).ISR) as usize - ptr as usize
		           },
		           28usize,
		           concat!("Offset of field: ", stringify!(USART_TypeDef), "::", stringify!(ISR))
		);
	}
	test_field_ISR();
	fn test_field_ICR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<USART_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).ICR) as usize - ptr as usize
		           },
		           32usize,
		           concat!("Offset of field: ", stringify!(USART_TypeDef), "::", stringify!(ICR))
		);
	}
	test_field_ICR();
	fn test_field_RDR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<USART_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).RDR) as usize - ptr as usize
		           },
		           36usize,
		           concat!("Offset of field: ", stringify!(USART_TypeDef), "::", stringify!(RDR))
		);
	}
	test_field_RDR();
	fn test_field_TDR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<USART_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).TDR) as usize - ptr as usize
		           },
		           40usize,
		           concat!("Offset of field: ", stringify!(USART_TypeDef), "::", stringify!(TDR))
		);
	}
	test_field_TDR();
	fn test_field_PRESC() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<USART_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).PRESC) as usize - ptr as usize
		           },
		           44usize,
		           concat!("Offset of field: ", stringify!(USART_TypeDef), "::", stringify!(PRESC))
		);
	}
	test_field_PRESC();
}
#[doc = " @brief RNG"]
#[repr(C)]
pub struct RNG_TypeDef {
	#[doc = "< RNG control register, Address offset: 0x00"]
	pub CR: u32,
	#[doc = "< RNG status register,  Address offset: 0x04"]
	pub SR: u32,
	#[doc = "< RNG data register,    Address offset: 0x08"]
	pub DR: u32,
}
#[test]
fn bindgen_test_layout_RNG_TypeDef() {
	assert_eq!(
	           ::core::mem::size_of::<RNG_TypeDef>(),
	           12usize,
	           concat!("Size of: ", stringify!(RNG_TypeDef))
	);
	assert_eq!(
	           ::core::mem::align_of::<RNG_TypeDef>(),
	           4usize,
	           concat!("Alignment of ", stringify!(RNG_TypeDef))
	);
	fn test_field_CR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<RNG_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).CR) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(RNG_TypeDef), "::", stringify!(CR))
		);
	}
	test_field_CR();
	fn test_field_SR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<RNG_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).SR) as usize - ptr as usize
		           },
		           4usize,
		           concat!("Offset of field: ", stringify!(RNG_TypeDef), "::", stringify!(SR))
		);
	}
	test_field_SR();
	fn test_field_DR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<RNG_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).DR) as usize - ptr as usize
		           },
		           8usize,
		           concat!("Offset of field: ", stringify!(RNG_TypeDef), "::", stringify!(DR))
		);
	}
	test_field_DR();
}
#[doc = " @brief Public Key Accelerator (PKA)"]
#[repr(C)]
pub struct PKA_TypeDef {
	#[doc = "< PKA control register,                 Address offset: 0x00"]
	pub CR: u32,
	#[doc = "< PKA status register,                  Address offset: 0x04"]
	pub SR: u32,
	#[doc = "< PKA clear flag register,              Address offset: 0x08"]
	pub CLRFR: u32,
	#[doc = "< Reserved                              Address offset: 0x000C-0x03FC"]
	pub Reserved1: [u32; 253usize],
	#[doc = "< PKA RAM,                              Address offset: 0x0400-0x11F4"]
	pub RAM: [u32; 894usize],
}
#[test]
fn bindgen_test_layout_PKA_TypeDef() {
	assert_eq!(
	           ::core::mem::size_of::<PKA_TypeDef>(),
	           4600usize,
	           concat!("Size of: ", stringify!(PKA_TypeDef))
	);
	assert_eq!(
	           ::core::mem::align_of::<PKA_TypeDef>(),
	           4usize,
	           concat!("Alignment of ", stringify!(PKA_TypeDef))
	);
	fn test_field_CR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<PKA_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).CR) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(PKA_TypeDef), "::", stringify!(CR))
		);
	}
	test_field_CR();
	fn test_field_SR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<PKA_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).SR) as usize - ptr as usize
		           },
		           4usize,
		           concat!("Offset of field: ", stringify!(PKA_TypeDef), "::", stringify!(SR))
		);
	}
	test_field_SR();
	fn test_field_CLRFR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<PKA_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).CLRFR) as usize - ptr as usize
		           },
		           8usize,
		           concat!("Offset of field: ", stringify!(PKA_TypeDef), "::", stringify!(CLRFR))
		);
	}
	test_field_CLRFR();
	fn test_field_Reserved1() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<PKA_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).Reserved1) as usize - ptr as usize
		           },
		           12usize,
		           concat!("Offset of field: ", stringify!(PKA_TypeDef), "::", stringify!(Reserved1))
		);
	}
	test_field_Reserved1();
	fn test_field_RAM() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<PKA_TypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).RAM) as usize - ptr as usize
		           },
		           1024usize,
		           concat!("Offset of field: ", stringify!(PKA_TypeDef), "::", stringify!(RAM))
		);
	}
	test_field_RAM();
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum FunctionalState {
	DISABLE = 0,
	ENABLE = 1,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum ErrorStatus {
	SUCCESS = 0,
	ERROR = 1,
}
#[doc = " @brief LL GPIO Init Structure definition"]
#[repr(C)]
pub struct LL_GPIO_InitTypeDef {
	#[doc = "< Specifies the GPIO pins to be configured."]
	#[doc = "This parameter can be any value of @ref GPIO_LL_EC_PIN"]
	pub Pin: u32,
	#[doc = "< Specifies the operating mode for the selected pins."]
	#[doc = "This parameter can be a value of @ref GPIO_LL_EC_MODE."]
	#[doc = ""]
	#[doc = "GPIO HW configuration can be modified afterwards using unitary function @ref LL_GPIO_SetPinMode()."]
	pub Mode: u32,
	#[doc = "< Specifies the speed for the selected pins."]
	#[doc = "This parameter can be a value of @ref GPIO_LL_EC_SPEED."]
	#[doc = ""]
	#[doc = "GPIO HW configuration can be modified afterwards using unitary function @ref LL_GPIO_SetPinSpeed()."]
	pub Speed: u32,
	#[doc = "< Specifies the operating output type for the selected pins."]
	#[doc = "This parameter can be a value of @ref GPIO_LL_EC_OUTPUT."]
	#[doc = ""]
	#[doc = "GPIO HW configuration can be modified afterwards using unitary function @ref LL_GPIO_SetPinOutputType()."]
	pub OutputType: u32,
	#[doc = "< Specifies the operating Pull-up/Pull down for the selected pins."]
	#[doc = "This parameter can be a value of @ref GPIO_LL_EC_PULL."]
	#[doc = ""]
	#[doc = "GPIO HW configuration can be modified afterwards using unitary function @ref LL_GPIO_SetPinPull()."]
	pub Pull: u32,
	#[doc = "< Specifies the Peripheral to be connected to the selected pins."]
	#[doc = "This parameter can be a value of @ref GPIO_LL_EC_AF."]
	#[doc = ""]
	#[doc = "GPIO HW configuration can be modified afterwards using unitary function @ref LL_GPIO_SetAFPin_0_7() and LL_GPIO_SetAFPin_8_15()."]
	pub Alternate: u32,
}
#[test]
fn bindgen_test_layout_LL_GPIO_InitTypeDef() {
	assert_eq!(
	           ::core::mem::size_of::<LL_GPIO_InitTypeDef>(),
	           24usize,
	           concat!("Size of: ", stringify!(LL_GPIO_InitTypeDef))
	);
	assert_eq!(
	           ::core::mem::align_of::<LL_GPIO_InitTypeDef>(),
	           4usize,
	           concat!("Alignment of ", stringify!(LL_GPIO_InitTypeDef))
	);
	fn test_field_Pin() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_GPIO_InitTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).Pin) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(LL_GPIO_InitTypeDef), "::", stringify!(Pin))
		);
	}
	test_field_Pin();
	fn test_field_Mode() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_GPIO_InitTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).Mode) as usize - ptr as usize
		           },
		           4usize,
		           concat!("Offset of field: ", stringify!(LL_GPIO_InitTypeDef), "::", stringify!(Mode))
		);
	}
	test_field_Mode();
	fn test_field_Speed() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_GPIO_InitTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).Speed) as usize - ptr as usize
		           },
		           8usize,
		           concat!("Offset of field: ", stringify!(LL_GPIO_InitTypeDef), "::", stringify!(Speed))
		);
	}
	test_field_Speed();
	fn test_field_OutputType() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_GPIO_InitTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).OutputType) as usize - ptr as usize
		           },
		           12usize,
		           concat!(
			"Offset of field: ",
			stringify!(LL_GPIO_InitTypeDef),
			"::",
			stringify!(OutputType)
		)
		);
	}
	test_field_OutputType();
	fn test_field_Pull() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_GPIO_InitTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).Pull) as usize - ptr as usize
		           },
		           16usize,
		           concat!("Offset of field: ", stringify!(LL_GPIO_InitTypeDef), "::", stringify!(Pull))
		);
	}
	test_field_Pull();
	fn test_field_Alternate() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_GPIO_InitTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).Alternate) as usize - ptr as usize
		           },
		           20usize,
		           concat!(
			"Offset of field: ",
			stringify!(LL_GPIO_InitTypeDef),
			"::",
			stringify!(Alternate)
		)
		);
	}
	test_field_Alternate();
}
extern "C" {
	#[doc = " @defgroup GPIO_LL_EF_Init Initialization and de-initialization functions"]
	#[doc = " @{"]
	pub fn LL_GPIO_DeInit(GPIOx: *mut GPIO_TypeDef) -> ErrorStatus;
}
extern "C" {
	pub fn LL_GPIO_Init(GPIOx: *mut GPIO_TypeDef, GPIO_InitStruct: *mut LL_GPIO_InitTypeDef) -> ErrorStatus;
}
extern "C" {
	pub fn LL_GPIO_StructInit(GPIO_InitStruct: *mut LL_GPIO_InitTypeDef);
}
#[doc = " @defgroup EXTI_LL_ES_INIT EXTI Exported Init structure"]
#[doc = " @{"]
#[repr(C)]
pub struct LL_EXTI_InitTypeDef {
	#[doc = "< Specifies the EXTI lines to be enabled or disabled for Lines in range 0 to 31"]
	#[doc = "This parameter can be any combination of @ref EXTI_LL_EC_LINE"]
	pub Line_0_31: u32,
	#[doc = "< Specifies the EXTI lines to be enabled or disabled for Lines in range 32 to 63"]
	#[doc = "This parameter can be any combination of @ref EXTI_LL_EC_LINE"]
	pub Line_32_63: u32,
	#[doc = "< Specifies the new state of the selected EXTI lines."]
	#[doc = "This parameter can be set either to ENABLE or DISABLE"]
	pub LineCommand: FunctionalState,
	#[doc = "< Specifies the mode for the EXTI lines."]
	#[doc = "This parameter can be a value of @ref EXTI_LL_EC_MODE."]
	pub Mode: u8,
	#[doc = "< Specifies the trigger signal active edge for the EXTI lines."]
	#[doc = "This parameter can be a value of @ref EXTI_LL_EC_TRIGGER."]
	pub Trigger: u8,
}
#[test]
fn bindgen_test_layout_LL_EXTI_InitTypeDef() {
	assert_eq!(
	           ::core::mem::size_of::<LL_EXTI_InitTypeDef>(),
	           16usize,
	           concat!("Size of: ", stringify!(LL_EXTI_InitTypeDef))
	);
	assert_eq!(
	           ::core::mem::align_of::<LL_EXTI_InitTypeDef>(),
	           4usize,
	           concat!("Alignment of ", stringify!(LL_EXTI_InitTypeDef))
	);
	fn test_field_Line_0_31() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_EXTI_InitTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).Line_0_31) as usize - ptr as usize
		           },
		           0usize,
		           concat!(
			"Offset of field: ",
			stringify!(LL_EXTI_InitTypeDef),
			"::",
			stringify!(Line_0_31)
		)
		);
	}
	test_field_Line_0_31();
	fn test_field_Line_32_63() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_EXTI_InitTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).Line_32_63) as usize - ptr as usize
		           },
		           4usize,
		           concat!(
			"Offset of field: ",
			stringify!(LL_EXTI_InitTypeDef),
			"::",
			stringify!(Line_32_63)
		)
		);
	}
	test_field_Line_32_63();
	fn test_field_LineCommand() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_EXTI_InitTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).LineCommand) as usize - ptr as usize
		           },
		           8usize,
		           concat!(
			"Offset of field: ",
			stringify!(LL_EXTI_InitTypeDef),
			"::",
			stringify!(LineCommand)
		)
		);
	}
	test_field_LineCommand();
	fn test_field_Mode() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_EXTI_InitTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).Mode) as usize - ptr as usize
		           },
		           12usize,
		           concat!("Offset of field: ", stringify!(LL_EXTI_InitTypeDef), "::", stringify!(Mode))
		);
	}
	test_field_Mode();
	fn test_field_Trigger() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_EXTI_InitTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).Trigger) as usize - ptr as usize
		           },
		           13usize,
		           concat!(
			"Offset of field: ",
			stringify!(LL_EXTI_InitTypeDef),
			"::",
			stringify!(Trigger)
		)
		);
	}
	test_field_Trigger();
}
extern "C" {
	#[doc = " @defgroup EXTI_LL_EF_Init Initialization and de-initialization functions"]
	#[doc = " @{"]
	pub fn LL_EXTI_Init(EXTI_InitStruct: *mut LL_EXTI_InitTypeDef) -> ErrorStatus;
}
extern "C" {
	pub fn LL_EXTI_DeInit() -> ErrorStatus;
}
extern "C" {
	pub fn LL_EXTI_StructInit(EXTI_InitStruct: *mut LL_EXTI_InitTypeDef);
}
#[doc = " Interrupt callback prototype"]
pub type GpioExtiCallback = ::core::option::Option<unsafe extern "C" fn(ctx: *mut core::ffi::c_void)>;
#[repr(u32)]
#[non_exhaustive]
#[doc = " Gpio modes"]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum GpioMode {
	GpioModeInput = 0,
	GpioModeOutputPushPull = 1,
	GpioModeOutputOpenDrain = 2,
	GpioModeAltFunctionPushPull = 3,
	GpioModeAltFunctionOpenDrain = 4,
	GpioModeAnalog = 5,
	GpioModeInterruptRise = 6,
	GpioModeInterruptFall = 7,
	GpioModeInterruptRiseFall = 8,
	GpioModeEventRise = 9,
	GpioModeEventFall = 10,
	GpioModeEventRiseFall = 11,
}
#[repr(u32)]
#[non_exhaustive]
#[doc = " Gpio pull modes"]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum GpioPull {
	GpioPullNo = 0,
	GpioPullUp = 1,
	GpioPullDown = 2,
}
#[repr(u32)]
#[non_exhaustive]
#[doc = " Gpio speed modes"]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum GpioSpeed {
	GpioSpeedLow = 0,
	GpioSpeedMedium = 1,
	GpioSpeedHigh = 2,
	GpioSpeedVeryHigh = 3,
}
impl GpioAltFn {
	pub const GpioAltFn0LSCO: GpioAltFn = GpioAltFn::GpioAltFn0MCO;
}
impl GpioAltFn {
	pub const GpioAltFn0JTMS_SWDIO: GpioAltFn = GpioAltFn::GpioAltFn0MCO;
}
impl GpioAltFn {
	pub const GpioAltFn0JTCK_SWCLK: GpioAltFn = GpioAltFn::GpioAltFn0MCO;
}
impl GpioAltFn {
	pub const GpioAltFn0JTDI: GpioAltFn = GpioAltFn::GpioAltFn0MCO;
}
impl GpioAltFn {
	pub const GpioAltFn0RTC_OUT: GpioAltFn = GpioAltFn::GpioAltFn0MCO;
}
impl GpioAltFn {
	pub const GpioAltFn0JTD_TRACE: GpioAltFn = GpioAltFn::GpioAltFn0MCO;
}
impl GpioAltFn {
	pub const GpioAltFn0NJTRST: GpioAltFn = GpioAltFn::GpioAltFn0MCO;
}
impl GpioAltFn {
	pub const GpioAltFn0RTC_REFIN: GpioAltFn = GpioAltFn::GpioAltFn0MCO;
}
impl GpioAltFn {
	pub const GpioAltFn0TRACED0: GpioAltFn = GpioAltFn::GpioAltFn0MCO;
}
impl GpioAltFn {
	pub const GpioAltFn0TRACED1: GpioAltFn = GpioAltFn::GpioAltFn0MCO;
}
impl GpioAltFn {
	pub const GpioAltFn0TRACED2: GpioAltFn = GpioAltFn::GpioAltFn0MCO;
}
impl GpioAltFn {
	pub const GpioAltFn0TRACED3: GpioAltFn = GpioAltFn::GpioAltFn0MCO;
}
impl GpioAltFn {
	pub const GpioAltFn0TRIG_INOUT: GpioAltFn = GpioAltFn::GpioAltFn0MCO;
}
impl GpioAltFn {
	pub const GpioAltFn0TRACECK: GpioAltFn = GpioAltFn::GpioAltFn0MCO;
}
impl GpioAltFn {
	pub const GpioAltFn0SYS: GpioAltFn = GpioAltFn::GpioAltFn0MCO;
}
impl GpioAltFn {
	pub const GpioAltFn1TIM2: GpioAltFn = GpioAltFn::GpioAltFn1TIM1;
}
impl GpioAltFn {
	pub const GpioAltFn1LPTIM1: GpioAltFn = GpioAltFn::GpioAltFn1TIM1;
}
impl GpioAltFn {
	pub const GpioAltFn2TIM1: GpioAltFn = GpioAltFn::GpioAltFn2TIM2;
}
impl GpioAltFn {
	pub const GpioAltFn3SPI2: GpioAltFn = GpioAltFn::GpioAltFn3SAI1;
}
impl GpioAltFn {
	pub const GpioAltFn3TIM1: GpioAltFn = GpioAltFn::GpioAltFn3SAI1;
}
impl GpioAltFn {
	pub const GpioAltFn4I2C3: GpioAltFn = GpioAltFn::GpioAltFn4I2C1;
}
impl GpioAltFn {
	pub const GpioAltFn5SPI2: GpioAltFn = GpioAltFn::GpioAltFn5SPI1;
}
impl GpioAltFn {
	pub const GpioAltFn6LSCO: GpioAltFn = GpioAltFn::GpioAltFn6MCO;
}
impl GpioAltFn {
	pub const GpioAltFn6RF_DTB0: GpioAltFn = GpioAltFn::GpioAltFn6MCO;
}
impl GpioAltFn {
	pub const GpioAltFn6RF_DTB1: GpioAltFn = GpioAltFn::GpioAltFn6MCO;
}
impl GpioAltFn {
	pub const GpioAltFn6RF_DTB2: GpioAltFn = GpioAltFn::GpioAltFn6MCO;
}
impl GpioAltFn {
	pub const GpioAltFn6RF_DTB3: GpioAltFn = GpioAltFn::GpioAltFn6MCO;
}
impl GpioAltFn {
	pub const GpioAltFn6RF_DTB4: GpioAltFn = GpioAltFn::GpioAltFn6MCO;
}
impl GpioAltFn {
	pub const GpioAltFn6RF_DTB5: GpioAltFn = GpioAltFn::GpioAltFn6MCO;
}
impl GpioAltFn {
	pub const GpioAltFn6RF_DTB6: GpioAltFn = GpioAltFn::GpioAltFn6MCO;
}
impl GpioAltFn {
	pub const GpioAltFn6RF_DTB7: GpioAltFn = GpioAltFn::GpioAltFn6MCO;
}
impl GpioAltFn {
	pub const GpioAltFn6RF_DTB8: GpioAltFn = GpioAltFn::GpioAltFn6MCO;
}
impl GpioAltFn {
	pub const GpioAltFn6RF_DTB9: GpioAltFn = GpioAltFn::GpioAltFn6MCO;
}
impl GpioAltFn {
	pub const GpioAltFn6RF_DTB10: GpioAltFn = GpioAltFn::GpioAltFn6MCO;
}
impl GpioAltFn {
	pub const GpioAltFn6RF_DTB11: GpioAltFn = GpioAltFn::GpioAltFn6MCO;
}
impl GpioAltFn {
	pub const GpioAltFn6RF_DTB12: GpioAltFn = GpioAltFn::GpioAltFn6MCO;
}
impl GpioAltFn {
	pub const GpioAltFn6RF_DTB13: GpioAltFn = GpioAltFn::GpioAltFn6MCO;
}
impl GpioAltFn {
	pub const GpioAltFn6RF_DTB14: GpioAltFn = GpioAltFn::GpioAltFn6MCO;
}
impl GpioAltFn {
	pub const GpioAltFn6RF_DTB15: GpioAltFn = GpioAltFn::GpioAltFn6MCO;
}
impl GpioAltFn {
	pub const GpioAltFn6RF_DTB16: GpioAltFn = GpioAltFn::GpioAltFn6MCO;
}
impl GpioAltFn {
	pub const GpioAltFn6RF_DTB17: GpioAltFn = GpioAltFn::GpioAltFn6MCO;
}
impl GpioAltFn {
	pub const GpioAltFn6RF_DTB18: GpioAltFn = GpioAltFn::GpioAltFn6MCO;
}
impl GpioAltFn {
	pub const GpioAltFn6RF_MISO: GpioAltFn = GpioAltFn::GpioAltFn6MCO;
}
impl GpioAltFn {
	pub const GpioAltFn6RF_MOSI: GpioAltFn = GpioAltFn::GpioAltFn6MCO;
}
impl GpioAltFn {
	pub const GpioAltFn6RF_SCK: GpioAltFn = GpioAltFn::GpioAltFn6MCO;
}
impl GpioAltFn {
	pub const GpioAltFn6RF_NSS: GpioAltFn = GpioAltFn::GpioAltFn6MCO;
}
impl GpioAltFn {
	pub const GpioAltFn8IR: GpioAltFn = GpioAltFn::GpioAltFn8LPUART1;
}
impl GpioAltFn {
	pub const GpioAltFn10USB: GpioAltFn = GpioAltFn::GpioAltFn10QUADSPI;
}
impl GpioAltFn {
	pub const GpioAltFn12COMP2: GpioAltFn = GpioAltFn::GpioAltFn12COMP1;
}
impl GpioAltFn {
	pub const GpioAltFn12TIM1: GpioAltFn = GpioAltFn::GpioAltFn12COMP1;
}
impl GpioAltFn {
	pub const GpioAltFn14TIM16: GpioAltFn = GpioAltFn::GpioAltFn14TIM2;
}
impl GpioAltFn {
	pub const GpioAltFn14TIM17: GpioAltFn = GpioAltFn::GpioAltFn14TIM2;
}
impl GpioAltFn {
	pub const GpioAltFn14LPTIM2: GpioAltFn = GpioAltFn::GpioAltFn14TIM2;
}
#[repr(u32)]
#[non_exhaustive]
#[doc = " Gpio alternate functions"]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum GpioAltFn {
	#[doc = "< MCO Alternate Function mapping"]
	GpioAltFn0MCO = 0,
	#[doc = "< TIM1 Alternate Function mapping"]
	GpioAltFn1TIM1 = 1,
	#[doc = "< TIM2 Alternate Function mapping"]
	GpioAltFn2TIM2 = 2,
	#[doc = "< SAI1_CK1 Alternate Function mapping"]
	GpioAltFn3SAI1 = 3,
	#[doc = "< I2C1 Alternate Function mapping"]
	GpioAltFn4I2C1 = 4,
	#[doc = "< SPI1 Alternate Function mapping"]
	GpioAltFn5SPI1 = 5,
	#[doc = "< MCO Alternate Function mapping"]
	GpioAltFn6MCO = 6,
	#[doc = "< USART1 Alternate Function mapping"]
	GpioAltFn7USART1 = 7,
	#[doc = "< LPUART1 Alternate Function mapping"]
	GpioAltFn8LPUART1 = 8,
	#[doc = "< TSC Alternate Function mapping"]
	GpioAltFn9TSC = 9,
	#[doc = "< QUADSPI Alternate Function mapping"]
	GpioAltFn10QUADSPI = 10,
	#[doc = "< LCD Alternate Function mapping"]
	GpioAltFn11LCD = 11,
	#[doc = "< COMP1 Alternate Function mapping"]
	GpioAltFn12COMP1 = 12,
	#[doc = "< SAI1 Alternate Function mapping"]
	GpioAltFn13SAI1 = 13,
	#[doc = "< TIM2 Alternate Function mapping"]
	GpioAltFn14TIM2 = 14,
	#[doc = "< EVENTOUT Alternate Function mapping"]
	GpioAltFn15EVENTOUT = 15,
	#[doc = "< just dummy value"]
	GpioAltFnUnused = 16,
}
#[doc = " Gpio structure"]
#[repr(C)]
pub struct GpioPin {
	pub port: *mut GPIO_TypeDef,
	pub pin: u16,
}
#[test]
fn bindgen_test_layout_GpioPin() {
	assert_eq!(
	           ::core::mem::size_of::<GpioPin>(),
	           8usize,
	           concat!("Size of: ", stringify!(GpioPin))
	);
	assert_eq!(
	           ::core::mem::align_of::<GpioPin>(),
	           4usize,
	           concat!("Alignment of ", stringify!(GpioPin))
	);
	fn test_field_port() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<GpioPin>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).port) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(GpioPin), "::", stringify!(port))
		);
	}
	test_field_port();
	fn test_field_pin() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<GpioPin>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).pin) as usize - ptr as usize
		           },
		           4usize,
		           concat!("Offset of field: ", stringify!(GpioPin), "::", stringify!(pin))
		);
	}
	test_field_pin();
}
extern "C" {
	#[doc = " GPIO initialization function, simple version"]
	#[doc = " @param gpio  GpioPin"]
	#[doc = " @param mode  GpioMode"]
	pub fn furi_hal_gpio_init_simple(gpio: *const GpioPin, mode: GpioMode);
}
extern "C" {
	#[doc = " GPIO initialization function, normal version"]
	#[doc = " @param gpio  GpioPin"]
	#[doc = " @param mode  GpioMode"]
	#[doc = " @param pull  GpioPull"]
	#[doc = " @param speed GpioSpeed"]
	pub fn furi_hal_gpio_init(gpio: *const GpioPin, mode: GpioMode, pull: GpioPull, speed: GpioSpeed);
}
extern "C" {
	#[doc = " GPIO initialization function, extended version"]
	#[doc = " @param gpio  GpioPin"]
	#[doc = " @param mode  GpioMode"]
	#[doc = " @param pull  GpioPull"]
	#[doc = " @param speed GpioSpeed"]
	#[doc = " @param alt_fn GpioAltFn"]
	pub fn furi_hal_gpio_init_ex(gpio: *const GpioPin, mode: GpioMode, pull: GpioPull, speed: GpioSpeed, alt_fn: GpioAltFn);
}
extern "C" {
	#[doc = " Add and enable interrupt"]
	#[doc = " @param gpio GpioPin"]
	#[doc = " @param cb   GpioExtiCallback"]
	#[doc = " @param ctx  context for callback"]
	pub fn furi_hal_gpio_add_int_callback(gpio: *const GpioPin, cb: GpioExtiCallback, ctx: *mut core::ffi::c_void);
}
extern "C" {
	#[doc = " Enable interrupt"]
	#[doc = " @param gpio GpioPin"]
	pub fn furi_hal_gpio_enable_int_callback(gpio: *const GpioPin);
}
extern "C" {
	#[doc = " Disable interrupt"]
	#[doc = " @param gpio GpioPin"]
	pub fn furi_hal_gpio_disable_int_callback(gpio: *const GpioPin);
}
extern "C" {
	#[doc = " Remove interrupt"]
	#[doc = " @param gpio GpioPin"]
	pub fn furi_hal_gpio_remove_int_callback(gpio: *const GpioPin);
}
#[doc = " Type by which software timers are referenced.  For example, a call to"]
#[doc = " xTimerCreate() returns an TimerHandle_t variable that can then be used to"]
#[doc = " reference the subject timer in calls to other software timer API functions"]
#[doc = " (for example, xTimerStart(), xTimerReset(), etc.)."]
#[repr(C)]
pub struct tmrTimerControl {
	_unused: [u8; 0],
}
pub type TimerHandle_t = *mut tmrTimerControl;
pub type TimerCallbackFunction_t = ::core::option::Option<unsafe extern "C" fn(xTimer: TimerHandle_t)>;
pub type PendedFunction_t = ::core::option::Option<unsafe extern "C" fn(arg1: *mut core::ffi::c_void, arg2: u32)>;
extern "C" {
	pub fn xTimerCreate(pcTimerName: *const core::ffi::c_char,
	                    xTimerPeriodInTicks: TickType_t,
	                    uxAutoReload: UBaseType_t,
	                    pvTimerID: *mut core::ffi::c_void,
	                    pxCallbackFunction: TimerCallbackFunction_t)
	                    -> TimerHandle_t;
}
extern "C" {
	pub fn xTimerCreateStatic(pcTimerName: *const core::ffi::c_char,
	                          xTimerPeriodInTicks: TickType_t,
	                          uxAutoReload: UBaseType_t,
	                          pvTimerID: *mut core::ffi::c_void,
	                          pxCallbackFunction: TimerCallbackFunction_t,
	                          pxTimerBuffer: *mut StaticTimer_t)
	                          -> TimerHandle_t;
}
extern "C" {
	#[doc = " void *pvTimerGetTimerID( TimerHandle_t xTimer );"]
	#[doc = ""]
	#[doc = " Returns the ID assigned to the timer."]
	#[doc = ""]
	#[doc = " IDs are assigned to timers using the pvTimerID parameter of the call to"]
	#[doc = " xTimerCreated() that was used to create the timer, and by calling the"]
	#[doc = " vTimerSetTimerID() API function."]
	#[doc = ""]
	#[doc = " If the same callback function is assigned to multiple timers then the timer"]
	#[doc = " ID can be used as time specific (timer local) storage."]
	#[doc = ""]
	#[doc = " @param xTimer The timer being queried."]
	#[doc = ""]
	#[doc = " @return The ID assigned to the timer being queried."]
	#[doc = ""]
	#[doc = " Example usage:"]
	#[doc = ""]
	#[doc = " See the xTimerCreate() API function example usage scenario."]
	pub fn pvTimerGetTimerID(xTimer: TimerHandle_t) -> *mut core::ffi::c_void;
}
extern "C" {
	#[doc = " void vTimerSetTimerID( TimerHandle_t xTimer, void *pvNewID );"]
	#[doc = ""]
	#[doc = " Sets the ID assigned to the timer."]
	#[doc = ""]
	#[doc = " IDs are assigned to timers using the pvTimerID parameter of the call to"]
	#[doc = " xTimerCreated() that was used to create the timer."]
	#[doc = ""]
	#[doc = " If the same callback function is assigned to multiple timers then the timer"]
	#[doc = " ID can be used as time specific (timer local) storage."]
	#[doc = ""]
	#[doc = " @param xTimer The timer being updated."]
	#[doc = ""]
	#[doc = " @param pvNewID The ID to assign to the timer."]
	#[doc = ""]
	#[doc = " Example usage:"]
	#[doc = ""]
	#[doc = " See the xTimerCreate() API function example usage scenario."]
	pub fn vTimerSetTimerID(xTimer: TimerHandle_t, pvNewID: *mut core::ffi::c_void);
}
extern "C" {
	#[doc = " BaseType_t xTimerIsTimerActive( TimerHandle_t xTimer );"]
	#[doc = ""]
	#[doc = " Queries a timer to see if it is active or dormant."]
	#[doc = ""]
	#[doc = " A timer will be dormant if:"]
	#[doc = "     1) It has been created but not started, or"]
	#[doc = "     2) It is an expired one-shot timer that has not been restarted."]
	#[doc = ""]
	#[doc = " Timers are created in the dormant state.  The xTimerStart(), xTimerReset(),"]
	#[doc = " xTimerStartFromISR(), xTimerResetFromISR(), xTimerChangePeriod() and"]
	#[doc = " xTimerChangePeriodFromISR() API functions can all be used to transition a timer into the"]
	#[doc = " active state."]
	#[doc = ""]
	#[doc = " @param xTimer The timer being queried."]
	#[doc = ""]
	#[doc = " @return pdFALSE will be returned if the timer is dormant.  A value other than"]
	#[doc = " pdFALSE will be returned if the timer is active."]
	#[doc = ""]
	#[doc = " Example usage:"]
	#[doc = " @verbatim"]
	#[doc = " // This function assumes xTimer has already been created."]
	#[doc = " void vAFunction( TimerHandle_t xTimer )"]
	#[doc = " {"]
	#[doc = "     if( xTimerIsTimerActive( xTimer ) != pdFALSE ) // or more simply and equivalently \"if( xTimerIsTimerActive( xTimer ) )\""]
	#[doc = "     {"]
	#[doc = "         // xTimer is active, do something."]
	#[doc = "     }"]
	#[doc = "     else"]
	#[doc = "     {"]
	#[doc = "         // xTimer is not active, do something else."]
	#[doc = "     }"]
	#[doc = " }"]
	#[doc = " @endverbatim"]
	pub fn xTimerIsTimerActive(xTimer: TimerHandle_t) -> BaseType_t;
}
extern "C" {
	#[doc = " TaskHandle_t xTimerGetTimerDaemonTaskHandle( void );"]
	#[doc = ""]
	#[doc = " Simply returns the handle of the timer service/daemon task.  It it not valid"]
	#[doc = " to call xTimerGetTimerDaemonTaskHandle() before the scheduler has been started."]
	pub fn xTimerGetTimerDaemonTaskHandle() -> TaskHandle_t;
}
extern "C" {
	#[doc = " BaseType_t xTimerPendFunctionCallFromISR( PendedFunction_t xFunctionToPend,"]
	#[doc = "                                          void *pvParameter1,"]
	#[doc = "                                          uint32_t ulParameter2,"]
	#[doc = "                                          BaseType_t *pxHigherPriorityTaskWoken );"]
	#[doc = ""]
	#[doc = ""]
	#[doc = " Used from application interrupt service routines to defer the execution of a"]
	#[doc = " function to the RTOS daemon task (the timer service task, hence this function"]
	#[doc = " is implemented in timers.c and is prefixed with 'Timer')."]
	#[doc = ""]
	#[doc = " Ideally an interrupt service routine (ISR) is kept as short as possible, but"]
	#[doc = " sometimes an ISR either has a lot of processing to do, or needs to perform"]
	#[doc = " processing that is not deterministic.  In these cases"]
	#[doc = " xTimerPendFunctionCallFromISR() can be used to defer processing of a function"]
	#[doc = " to the RTOS daemon task."]
	#[doc = ""]
	#[doc = " A mechanism is provided that allows the interrupt to return directly to the"]
	#[doc = " task that will subsequently execute the pended callback function.  This"]
	#[doc = " allows the callback function to execute contiguously in time with the"]
	#[doc = " interrupt - just as if the callback had executed in the interrupt itself."]
	#[doc = ""]
	#[doc = " @param xFunctionToPend The function to execute from the timer service/"]
	#[doc = " daemon task.  The function must conform to the PendedFunction_t"]
	#[doc = " prototype."]
	#[doc = ""]
	#[doc = " @param pvParameter1 The value of the callback function's first parameter."]
	#[doc = " The parameter has a void * type to allow it to be used to pass any type."]
	#[doc = " For example, unsigned longs can be cast to a void *, or the void * can be"]
	#[doc = " used to point to a structure."]
	#[doc = ""]
	#[doc = " @param ulParameter2 The value of the callback function's second parameter."]
	#[doc = ""]
	#[doc = " @param pxHigherPriorityTaskWoken As mentioned above, calling this function"]
	#[doc = " will result in a message being sent to the timer daemon task.  If the"]
	#[doc = " priority of the timer daemon task (which is set using"]
	#[doc = " configTIMER_TASK_PRIORITY in FreeRTOSConfig.h) is higher than the priority of"]
	#[doc = " the currently running task (the task the interrupt interrupted) then"]
	#[doc = " *pxHigherPriorityTaskWoken will be set to pdTRUE within"]
	#[doc = " xTimerPendFunctionCallFromISR(), indicating that a context switch should be"]
	#[doc = " requested before the interrupt exits.  For that reason"]
	#[doc = " *pxHigherPriorityTaskWoken must be initialised to pdFALSE.  See the"]
	#[doc = " example code below."]
	#[doc = ""]
	#[doc = " @return pdPASS is returned if the message was successfully sent to the"]
	#[doc = " timer daemon task, otherwise pdFALSE is returned."]
	#[doc = ""]
	#[doc = " Example usage:"]
	#[doc = " @verbatim"]
	#[doc = ""]
	#[doc = "  // The callback function that will execute in the context of the daemon task."]
	#[doc = "  // Note callback functions must all use this same prototype."]
	#[doc = "  void vProcessInterface( void *pvParameter1, uint32_t ulParameter2 )"]
	#[doc = "  {"]
	#[doc = "      BaseType_t xInterfaceToService;"]
	#[doc = ""]
	#[doc = "      // The interface that requires servicing is passed in the second"]
	#[doc = "      // parameter.  The first parameter is not used in this case."]
	#[doc = "      xInterfaceToService = ( BaseType_t ) ulParameter2;"]
	#[doc = ""]
	#[doc = "      // ...Perform the processing here..."]
	#[doc = "  }"]
	#[doc = ""]
	#[doc = "  // An ISR that receives data packets from multiple interfaces"]
	#[doc = "  void vAnISR( void )"]
	#[doc = "  {"]
	#[doc = "      BaseType_t xInterfaceToService, xHigherPriorityTaskWoken;"]
	#[doc = ""]
	#[doc = "      // Query the hardware to determine which interface needs processing."]
	#[doc = "      xInterfaceToService = prvCheckInterfaces();"]
	#[doc = ""]
	#[doc = "      // The actual processing is to be deferred to a task.  Request the"]
	#[doc = "      // vProcessInterface() callback function is executed, passing in the"]
	#[doc = "      // number of the interface that needs processing.  The interface to"]
	#[doc = "      // service is passed in the second parameter.  The first parameter is"]
	#[doc = "      // not used in this case."]
	#[doc = "      xHigherPriorityTaskWoken = pdFALSE;"]
	#[doc = "      xTimerPendFunctionCallFromISR( vProcessInterface, NULL, ( uint32_t ) xInterfaceToService, &xHigherPriorityTaskWoken );"]
	#[doc = ""]
	#[doc = "      // If xHigherPriorityTaskWoken is now set to pdTRUE then a context"]
	#[doc = "      // switch should be requested.  The macro used is port specific and will"]
	#[doc = "      // be either portYIELD_FROM_ISR() or portEND_SWITCHING_ISR() - refer to"]
	#[doc = "      // the documentation page for the port being used."]
	#[doc = "      portYIELD_FROM_ISR( xHigherPriorityTaskWoken );"]
	#[doc = ""]
	#[doc = "  }"]
	#[doc = " @endverbatim"]
	pub fn xTimerPendFunctionCallFromISR(xFunctionToPend: PendedFunction_t,
	                                     pvParameter1: *mut core::ffi::c_void,
	                                     ulParameter2: u32,
	                                     pxHigherPriorityTaskWoken: *mut BaseType_t)
	                                     -> BaseType_t;
}
extern "C" {
	#[doc = " BaseType_t xTimerPendFunctionCall( PendedFunction_t xFunctionToPend,"]
	#[doc = "                                    void *pvParameter1,"]
	#[doc = "                                    uint32_t ulParameter2,"]
	#[doc = "                                    TickType_t xTicksToWait );"]
	#[doc = ""]
	#[doc = ""]
	#[doc = " Used to defer the execution of a function to the RTOS daemon task (the timer"]
	#[doc = " service task, hence this function is implemented in timers.c and is prefixed"]
	#[doc = " with 'Timer')."]
	#[doc = ""]
	#[doc = " @param xFunctionToPend The function to execute from the timer service/"]
	#[doc = " daemon task.  The function must conform to the PendedFunction_t"]
	#[doc = " prototype."]
	#[doc = ""]
	#[doc = " @param pvParameter1 The value of the callback function's first parameter."]
	#[doc = " The parameter has a void * type to allow it to be used to pass any type."]
	#[doc = " For example, unsigned longs can be cast to a void *, or the void * can be"]
	#[doc = " used to point to a structure."]
	#[doc = ""]
	#[doc = " @param ulParameter2 The value of the callback function's second parameter."]
	#[doc = ""]
	#[doc = " @param xTicksToWait Calling this function will result in a message being"]
	#[doc = " sent to the timer daemon task on a queue.  xTicksToWait is the amount of"]
	#[doc = " time the calling task should remain in the Blocked state (so not using any"]
	#[doc = " processing time) for space to become available on the timer queue if the"]
	#[doc = " queue is found to be full."]
	#[doc = ""]
	#[doc = " @return pdPASS is returned if the message was successfully sent to the"]
	#[doc = " timer daemon task, otherwise pdFALSE is returned."]
	#[doc = ""]
	pub fn xTimerPendFunctionCall(xFunctionToPend: PendedFunction_t,
	                              pvParameter1: *mut core::ffi::c_void,
	                              ulParameter2: u32,
	                              xTicksToWait: TickType_t)
	                              -> BaseType_t;
}
extern "C" {
	#[doc = " const char * const pcTimerGetName( TimerHandle_t xTimer );"]
	#[doc = ""]
	#[doc = " Returns the name that was assigned to a timer when the timer was created."]
	#[doc = ""]
	#[doc = " @param xTimer The handle of the timer being queried."]
	#[doc = ""]
	#[doc = " @return The name assigned to the timer specified by the xTimer parameter."]
	pub fn pcTimerGetName(xTimer: TimerHandle_t) -> *const core::ffi::c_char;
}
extern "C" {
	#[doc = " void vTimerSetReloadMode( TimerHandle_t xTimer, const UBaseType_t uxAutoReload );"]
	#[doc = ""]
	#[doc = " Updates a timer to be either an auto-reload timer, in which case the timer"]
	#[doc = " automatically resets itself each time it expires, or a one-shot timer, in"]
	#[doc = " which case the timer will only expire once unless it is manually restarted."]
	#[doc = ""]
	#[doc = " @param xTimer The handle of the timer being updated."]
	#[doc = ""]
	#[doc = " @param uxAutoReload If uxAutoReload is set to pdTRUE then the timer will"]
	#[doc = " expire repeatedly with a frequency set by the timer's period (see the"]
	#[doc = " xTimerPeriodInTicks parameter of the xTimerCreate() API function).  If"]
	#[doc = " uxAutoReload is set to pdFALSE then the timer will be a one-shot timer and"]
	#[doc = " enter the dormant state after it expires."]
	pub fn vTimerSetReloadMode(xTimer: TimerHandle_t, uxAutoReload: UBaseType_t);
}
extern "C" {
	#[doc = " UBaseType_t uxTimerGetReloadMode( TimerHandle_t xTimer );"]
	#[doc = ""]
	#[doc = " Queries a timer to determine if it is an auto-reload timer, in which case the timer"]
	#[doc = " automatically resets itself each time it expires, or a one-shot timer, in"]
	#[doc = " which case the timer will only expire once unless it is manually restarted."]
	#[doc = ""]
	#[doc = " @param xTimer The handle of the timer being queried."]
	#[doc = ""]
	#[doc = " @return If the timer is an auto-reload timer then pdTRUE is returned, otherwise"]
	#[doc = " pdFALSE is returned."]
	pub fn uxTimerGetReloadMode(xTimer: TimerHandle_t) -> UBaseType_t;
}
extern "C" {
	#[doc = " TickType_t xTimerGetPeriod( TimerHandle_t xTimer );"]
	#[doc = ""]
	#[doc = " Returns the period of a timer."]
	#[doc = ""]
	#[doc = " @param xTimer The handle of the timer being queried."]
	#[doc = ""]
	#[doc = " @return The period of the timer in ticks."]
	pub fn xTimerGetPeriod(xTimer: TimerHandle_t) -> TickType_t;
}
extern "C" {
	#[doc = " TickType_t xTimerGetExpiryTime( TimerHandle_t xTimer );"]
	#[doc = ""]
	#[doc = " Returns the time in ticks at which the timer will expire.  If this is less"]
	#[doc = " than the current tick count then the expiry time has overflowed from the"]
	#[doc = " current time."]
	#[doc = ""]
	#[doc = " @param xTimer The handle of the timer being queried."]
	#[doc = ""]
	#[doc = " @return If the timer is running then the time in ticks at which the timer"]
	#[doc = " will next expire is returned.  If the timer is not running then the return"]
	#[doc = " value is undefined."]
	pub fn xTimerGetExpiryTime(xTimer: TimerHandle_t) -> TickType_t;
}
extern "C" {
	pub fn xTimerCreateTimerTask() -> BaseType_t;
}
extern "C" {
	pub fn xTimerGenericCommand(xTimer: TimerHandle_t,
	                            xCommandID: BaseType_t,
	                            xOptionalValue: TickType_t,
	                            pxHigherPriorityTaskWoken: *mut BaseType_t,
	                            xTicksToWait: TickType_t)
	                            -> BaseType_t;
}
extern "C" {
	pub fn vTimerSetTimerNumber(xTimer: TimerHandle_t, uxTimerNumber: UBaseType_t);
}
extern "C" {
	pub fn uxTimerGetTimerNumber(xTimer: TimerHandle_t) -> UBaseType_t;
}
extern "C" {
	#[doc = " task.h"]
	#[doc = " @code{c}"]
	#[doc = " void vApplicationGetTimerTaskMemory( StaticTask_t ** ppxTimerTaskTCBBuffer, StackType_t ** ppxTimerTaskStackBuffer, uint32_t *pulTimerTaskStackSize )"]
	#[doc = " @endcode"]
	#[doc = ""]
	#[doc = " This function is used to provide a statically allocated block of memory to FreeRTOS to hold the Timer Task TCB.  This function is required when"]
	#[doc = " configSUPPORT_STATIC_ALLOCATION is set.  For more information see this URI: https://www.FreeRTOS.org/a00110.html#configSUPPORT_STATIC_ALLOCATION"]
	#[doc = ""]
	#[doc = " @param ppxTimerTaskTCBBuffer   A handle to a statically allocated TCB buffer"]
	#[doc = " @param ppxTimerTaskStackBuffer A handle to a statically allocated Stack buffer for thie idle task"]
	#[doc = " @param pulTimerTaskStackSize   A pointer to the number of elements that will fit in the allocated stack buffer"]
	pub fn vApplicationGetTimerTaskMemory(ppxTimerTaskTCBBuffer: *mut *mut StaticTask_t,
	                                      ppxTimerTaskStackBuffer: *mut *mut StackType_t,
	                                      pulTimerTaskStackSize: *mut u32);
}
extern "C" {
	pub fn furi_init();
}
extern "C" {
	pub fn furi_run();
}
#[repr(C)]
pub struct Icon {
	_unused: [u8; 0],
}
extern "C" {
	#[doc = " Get icon width"]
	#[doc = ""]
	#[doc = " @param[in]  instance  pointer to Icon data"]
	#[doc = ""]
	#[doc = " @return     width in pixels"]
	pub fn icon_get_width(instance: *const Icon) -> u8;
}
extern "C" {
	#[doc = " Get icon height"]
	#[doc = ""]
	#[doc = " @param[in]  instance  pointer to Icon data"]
	#[doc = ""]
	#[doc = " @return     height in pixels"]
	pub fn icon_get_height(instance: *const Icon) -> u8;
}
extern "C" {
	#[doc = " Get Icon XBM bitmap data"]
	#[doc = ""]
	#[doc = " @param[in]  instance  pointer to Icon data"]
	#[doc = ""]
	#[doc = " @return     pointer to XBM bitmap data"]
	pub fn icon_get_data(instance: *const Icon) -> *const u8;
}
extern "C" {
	pub static A_125khz_14: Icon;
}
extern "C" {
	pub static A_BadUsb_14: Icon;
}
extern "C" {
	pub static A_Debug_14: Icon;
}
extern "C" {
	pub static A_FileManager_14: Icon;
}
extern "C" {
	pub static A_GPIO_14: Icon;
}
extern "C" {
	pub static A_Infrared_14: Icon;
}
extern "C" {
	pub static A_Levelup1_128x64: Icon;
}
extern "C" {
	pub static A_Levelup2_128x64: Icon;
}
extern "C" {
	pub static A_Loading_24: Icon;
}
extern "C" {
	pub static A_NFC_14: Icon;
}
extern "C" {
	pub static A_Plugins_14: Icon;
}
extern "C" {
	pub static A_Round_loader_8x8: Icon;
}
extern "C" {
	pub static A_Settings_14: Icon;
}
extern "C" {
	pub static A_Sub1ghz_14: Icon;
}
extern "C" {
	pub static A_U2F_14: Icon;
}
extern "C" {
	pub static A_iButton_14: Icon;
}
extern "C" {
	pub static I_125_10px: Icon;
}
extern "C" {
	pub static I_ActiveConnection_50x64: Icon;
}
extern "C" {
	pub static I_ArrowC_1_36x36: Icon;
}
extern "C" {
	pub static I_ArrowDownEmpty_14x15: Icon;
}
extern "C" {
	pub static I_ArrowDownFilled_14x15: Icon;
}
extern "C" {
	pub static I_ArrowUpEmpty_14x15: Icon;
}
extern "C" {
	pub static I_ArrowUpFilled_14x15: Icon;
}
extern "C" {
	pub static I_Attention_5x8: Icon;
}
extern "C" {
	pub static I_Auth_62x31: Icon;
}
extern "C" {
	pub static I_BLE_Pairing_128x64: Icon;
}
extern "C" {
	pub static I_Background_128x11: Icon;
}
extern "C" {
	pub static I_BatteryBody_52x28: Icon;
}
extern "C" {
	pub static I_Battery_16x16: Icon;
}
extern "C" {
	pub static I_Battery_26x8: Icon;
}
extern "C" {
	pub static I_Ble_connected_15x15: Icon;
}
extern "C" {
	pub static I_Ble_disconnected_15x15: Icon;
}
extern "C" {
	pub static I_Bluetooth_Connected_16x8: Icon;
}
extern "C" {
	pub static I_Bluetooth_Idle_5x8: Icon;
}
extern "C" {
	pub static I_ButtonCenter_7x7: Icon;
}
extern "C" {
	pub static I_ButtonDown_7x4: Icon;
}
extern "C" {
	pub static I_ButtonLeftSmall_3x5: Icon;
}
extern "C" {
	pub static I_ButtonLeft_4x7: Icon;
}
extern "C" {
	pub static I_ButtonRightSmall_3x5: Icon;
}
extern "C" {
	pub static I_ButtonRight_4x7: Icon;
}
extern "C" {
	pub static I_ButtonUp_7x4: Icon;
}
extern "C" {
	pub static I_Button_18x18: Icon;
}
extern "C" {
	pub static I_Certification1_103x56: Icon;
}
extern "C" {
	pub static I_Certification2_98x33: Icon;
}
extern "C" {
	pub static I_Charging_lightning_9x10: Icon;
}
extern "C" {
	pub static I_Charging_lightning_mask_9x10: Icon;
}
extern "C" {
	pub static I_Circles_47x47: Icon;
}
extern "C" {
	pub static I_Clock_18x18: Icon;
}
extern "C" {
	pub static I_Connect_me_62x31: Icon;
}
extern "C" {
	pub static I_Connected_62x31: Icon;
}
extern "C" {
	pub static I_CoolHi_25x27: Icon;
}
extern "C" {
	pub static I_CoolHi_hvr_25x27: Icon;
}
extern "C" {
	pub static I_CoolLo_25x27: Icon;
}
extern "C" {
	pub static I_CoolLo_hvr_25x27: Icon;
}
extern "C" {
	pub static I_Cry_dolph_55x52: Icon;
}
extern "C" {
	pub static I_DFU_128x50: Icon;
}
extern "C" {
	pub static I_Dehumidify_25x27: Icon;
}
extern "C" {
	pub static I_Dehumidify_hvr_25x27: Icon;
}
extern "C" {
	pub static I_Detailed_chip_17x13: Icon;
}
extern "C" {
	pub static I_DolphinCommon_56x48: Icon;
}
extern "C" {
	pub static I_DolphinMafia_115x62: Icon;
}
extern "C" {
	pub static I_DolphinNice_96x59: Icon;
}
extern "C" {
	pub static I_DolphinReadingSuccess_59x63: Icon;
}
extern "C" {
	pub static I_DolphinWait_61x59: Icon;
}
extern "C" {
	pub static I_DoorLeft_70x55: Icon;
}
extern "C" {
	pub static I_DoorRight_70x55: Icon;
}
extern "C" {
	pub static I_Down_25x27: Icon;
}
extern "C" {
	pub static I_Down_hvr_25x27: Icon;
}
extern "C" {
	pub static I_Drive_112x35: Icon;
}
extern "C" {
	pub static I_Error_18x18: Icon;
}
extern "C" {
	pub static I_Error_62x31: Icon;
}
extern "C" {
	pub static I_EviSmile1_18x21: Icon;
}
extern "C" {
	pub static I_EviSmile2_18x21: Icon;
}
extern "C" {
	pub static I_EviWaiting1_18x21: Icon;
}
extern "C" {
	pub static I_EviWaiting2_18x21: Icon;
}
extern "C" {
	pub static I_FaceCharging_29x14: Icon;
}
extern "C" {
	pub static I_FaceConfused_29x14: Icon;
}
extern "C" {
	pub static I_FaceNopower_29x14: Icon;
}
extern "C" {
	pub static I_FaceNormal_29x14: Icon;
}
extern "C" {
	pub static I_GameMode_11x8: Icon;
}
extern "C" {
	pub static I_Health_16x16: Icon;
}
extern "C" {
	pub static I_HeatHi_25x27: Icon;
}
extern "C" {
	pub static I_HeatHi_hvr_25x27: Icon;
}
extern "C" {
	pub static I_HeatLo_25x27: Icon;
}
extern "C" {
	pub static I_HeatLo_hvr_25x27: Icon;
}
extern "C" {
	pub static I_InfraredArrowDown_4x8: Icon;
}
extern "C" {
	pub static I_InfraredArrowUp_4x8: Icon;
}
extern "C" {
	pub static I_InfraredLearnShort_128x31: Icon;
}
extern "C" {
	pub static I_KeyBackspaceSelected_16x9: Icon;
}
extern "C" {
	pub static I_KeyBackspace_16x9: Icon;
}
extern "C" {
	pub static I_KeySaveSelected_24x11: Icon;
}
extern "C" {
	pub static I_KeySave_24x11: Icon;
}
extern "C" {
	pub static I_Keychain_39x36: Icon;
}
extern "C" {
	pub static I_Left_mouse_icon_9x9: Icon;
}
extern "C" {
	pub static I_Lock_7x8: Icon;
}
extern "C" {
	pub static I_Lock_8x8: Icon;
}
extern "C" {
	pub static I_MHz_25x11: Icon;
}
extern "C" {
	pub static I_Medium_chip_22x21: Icon;
}
extern "C" {
	pub static I_Mute_25x27: Icon;
}
extern "C" {
	pub static I_Mute_hvr_25x27: Icon;
}
extern "C" {
	pub static I_NFC_manual_60x50: Icon;
}
extern "C" {
	pub static I_Nfc_10px: Icon;
}
extern "C" {
	pub static I_Off_25x27: Icon;
}
extern "C" {
	pub static I_Off_hvr_25x27: Icon;
}
extern "C" {
	pub static I_Ok_btn_9x9: Icon;
}
extern "C" {
	pub static I_Ok_btn_pressed_13x13: Icon;
}
extern "C" {
	pub static I_Percent_10x14: Icon;
}
extern "C" {
	pub static I_Pin_arrow_down_7x9: Icon;
}
extern "C" {
	pub static I_Pin_arrow_left_9x7: Icon;
}
extern "C" {
	pub static I_Pin_arrow_right_9x7: Icon;
}
extern "C" {
	pub static I_Pin_arrow_up_7x9: Icon;
}
extern "C" {
	pub static I_Pin_attention_dpad_29x29: Icon;
}
extern "C" {
	pub static I_Pin_back_arrow_10x8: Icon;
}
extern "C" {
	pub static I_Pin_back_full_40x8: Icon;
}
extern "C" {
	pub static I_Pin_pointer_5x3: Icon;
}
extern "C" {
	pub static I_Pin_star_7x7: Icon;
}
extern "C" {
	pub static I_Power_25x27: Icon;
}
extern "C" {
	pub static I_Power_hvr_25x27: Icon;
}
extern "C" {
	pub static I_Pressed_Button_13x13: Icon;
}
extern "C" {
	pub static I_Quest_7x8: Icon;
}
extern "C" {
	pub static I_RFIDBigChip_37x36: Icon;
}
extern "C" {
	pub static I_RFIDDolphinReceive_97x61: Icon;
}
extern "C" {
	pub static I_RFIDDolphinSend_97x61: Icon;
}
extern "C" {
	pub static I_RFIDDolphinSuccess_108x57: Icon;
}
extern "C" {
	pub static I_Reader_detect_43x40: Icon;
}
extern "C" {
	pub static I_Restoring_38x32: Icon;
}
extern "C" {
	pub static I_Right_mouse_icon_9x9: Icon;
}
extern "C" {
	pub static I_SDQuestion_35x43: Icon;
}
extern "C" {
	pub static I_SDcardFail_11x8: Icon;
}
extern "C" {
	pub static I_SDcardMounted_11x8: Icon;
}
extern "C" {
	pub static I_Scanning_123x52: Icon;
}
extern "C" {
	pub static I_SmallArrowDown_4x7: Icon;
}
extern "C" {
	pub static I_SmallArrowUp_4x7: Icon;
}
extern "C" {
	pub static I_Smile_18x18: Icon;
}
extern "C" {
	pub static I_Space_65x18: Icon;
}
extern "C" {
	pub static I_Tap_reader_36x38: Icon;
}
extern "C" {
	pub static I_Temperature_16x16: Icon;
}
extern "C" {
	pub static I_Unlock_7x8: Icon;
}
extern "C" {
	pub static I_Unplug_bg_bottom_128x10: Icon;
}
extern "C" {
	pub static I_Unplug_bg_top_128x14: Icon;
}
extern "C" {
	pub static I_Up_25x27: Icon;
}
extern "C" {
	pub static I_Up_hvr_25x27: Icon;
}
extern "C" {
	pub static I_Updating_32x40: Icon;
}
extern "C" {
	pub static I_UsbTree_48x22: Icon;
}
extern "C" {
	pub static I_Vol_down_25x27: Icon;
}
extern "C" {
	pub static I_Vol_down_hvr_25x27: Icon;
}
extern "C" {
	pub static I_Vol_up_25x27: Icon;
}
extern "C" {
	pub static I_Vol_up_hvr_25x27: Icon;
}
extern "C" {
	pub static I_Voldwn_6x6: Icon;
}
extern "C" {
	pub static I_Voltage_16x16: Icon;
}
extern "C" {
	pub static I_Volup_8x6: Icon;
}
extern "C" {
	pub static I_WarningDolphin_45x42: Icon;
}
extern "C" {
	pub static I_Warning_30x23: Icon;
}
extern "C" {
	pub static I_back_10px: Icon;
}
extern "C" {
	pub static I_badusb_10px: Icon;
}
extern "C" {
	pub static I_dir_10px: Icon;
}
extern "C" {
	pub static I_iButtonDolphinVerySuccess_108x52: Icon;
}
extern "C" {
	pub static I_iButtonKey_49x44: Icon;
}
extern "C" {
	pub static I_ibutt_10px: Icon;
}
extern "C" {
	pub static I_ir_10px: Icon;
}
extern "C" {
	pub static I_loading_10px: Icon;
}
extern "C" {
	pub static I_music_10px: Icon;
}
extern "C" {
	pub static I_passport_bad1_46x49: Icon;
}
extern "C" {
	pub static I_passport_bad2_46x49: Icon;
}
extern "C" {
	pub static I_passport_bad3_46x49: Icon;
}
extern "C" {
	pub static I_passport_bottom_128x18: Icon;
}
extern "C" {
	pub static I_passport_happy1_46x49: Icon;
}
extern "C" {
	pub static I_passport_happy2_46x49: Icon;
}
extern "C" {
	pub static I_passport_happy3_46x49: Icon;
}
extern "C" {
	pub static I_passport_left_6x46: Icon;
}
extern "C" {
	pub static I_passport_okay1_46x49: Icon;
}
extern "C" {
	pub static I_passport_okay2_46x49: Icon;
}
extern "C" {
	pub static I_passport_okay3_46x49: Icon;
}
extern "C" {
	pub static I_sub1_10px: Icon;
}
extern "C" {
	pub static I_u2f_10px: Icon;
}
extern "C" {
	pub static I_unknown_10px: Icon;
}
extern "C" {
	pub static I_update_10px: Icon;
}
#[repr(C)]
pub struct IconAnimation {
	_unused: [u8; 0],
}
#[doc = " Icon Animation Callback. Used for update notification"]
pub type IconAnimationCallback =
	::core::option::Option<unsafe extern "C" fn(instance: *mut IconAnimation, context: *mut core::ffi::c_void)>;
extern "C" {
	#[doc = " Allocate icon animation instance with const icon data."]
	#[doc = ""]
	#[doc = " always returns Icon or stops system if not enough memory"]
	#[doc = ""]
	#[doc = " @param[in]  icon  pointer to Icon data"]
	#[doc = ""]
	#[doc = " @return     IconAnimation instance"]
	pub fn icon_animation_alloc(icon: *const Icon) -> *mut IconAnimation;
}
extern "C" {
	#[doc = " Release icon animation instance"]
	#[doc = ""]
	#[doc = " @param      instance  IconAnimation instance"]
	pub fn icon_animation_free(instance: *mut IconAnimation);
}
extern "C" {
	#[doc = " Set IconAnimation update callback"]
	#[doc = ""]
	#[doc = " Normally you do not need to use this function, use view_tie_icon_animation"]
	#[doc = " instead."]
	#[doc = ""]
	#[doc = " @param      instance  IconAnimation instance"]
	#[doc = " @param[in]  callback  IconAnimationCallback"]
	#[doc = " @param      context   callback context"]
	pub fn icon_animation_set_update_callback(instance: *mut IconAnimation,
	                                          callback: IconAnimationCallback,
	                                          context: *mut core::ffi::c_void);
}
extern "C" {
	#[doc = " Get icon animation width"]
	#[doc = ""]
	#[doc = " @param      instance  IconAnimation instance"]
	#[doc = ""]
	#[doc = " @return     width in pixels"]
	pub fn icon_animation_get_width(instance: *mut IconAnimation) -> u8;
}
extern "C" {
	#[doc = " Get icon animation height"]
	#[doc = ""]
	#[doc = " @param      instance  IconAnimation instance"]
	#[doc = ""]
	#[doc = " @return     height in pixels"]
	pub fn icon_animation_get_height(instance: *mut IconAnimation) -> u8;
}
extern "C" {
	#[doc = " Start icon animation"]
	#[doc = ""]
	#[doc = " @param      instance  IconAnimation instance"]
	pub fn icon_animation_start(instance: *mut IconAnimation);
}
extern "C" {
	#[doc = " Stop icon animation"]
	#[doc = ""]
	#[doc = " @param      instance  IconAnimation instance"]
	pub fn icon_animation_stop(instance: *mut IconAnimation);
}
extern "C" {
	#[doc = " Returns true if current frame is a last one"]
	#[doc = ""]
	#[doc = " @param      instance  IconAnimation instance"]
	#[doc = ""]
	#[doc = " @return     true if last frame"]
	pub fn icon_animation_is_last_frame(instance: *mut IconAnimation) -> bool;
}
#[repr(u32)]
#[non_exhaustive]
#[doc = " Color enumeration"]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum Color {
	ColorWhite = 0,
	ColorBlack = 1,
}
#[repr(u32)]
#[non_exhaustive]
#[doc = " Fonts enumeration"]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum Font {
	FontPrimary = 0,
	FontSecondary = 1,
	FontKeyboard = 2,
	FontBigNumbers = 3,
	FontTotalNumber = 4,
}
#[repr(u32)]
#[non_exhaustive]
#[doc = " Alignment enumeration"]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum Align {
	AlignLeft = 0,
	AlignRight = 1,
	AlignTop = 2,
	AlignBottom = 3,
	AlignCenter = 4,
}
#[repr(u32)]
#[non_exhaustive]
#[doc = " Font Direction"]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum CanvasDirection {
	CanvasDirectionLeftToRight = 0,
	CanvasDirectionTopToBottom = 1,
	CanvasDirectionRightToLeft = 2,
	CanvasDirectionBottomToTop = 3,
}
#[doc = " Font parameters"]
#[repr(C)]
pub struct CanvasFontParameters {
	pub leading_default: u8,
	pub leading_min: u8,
	pub height: u8,
	pub descender: u8,
}
#[test]
fn bindgen_test_layout_CanvasFontParameters() {
	assert_eq!(
	           ::core::mem::size_of::<CanvasFontParameters>(),
	           4usize,
	           concat!("Size of: ", stringify!(CanvasFontParameters))
	);
	assert_eq!(
	           ::core::mem::align_of::<CanvasFontParameters>(),
	           1usize,
	           concat!("Alignment of ", stringify!(CanvasFontParameters))
	);
	fn test_field_leading_default() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<CanvasFontParameters>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).leading_default) as usize - ptr as usize
		           },
		           0usize,
		           concat!(
			"Offset of field: ",
			stringify!(CanvasFontParameters),
			"::",
			stringify!(leading_default)
		)
		);
	}
	test_field_leading_default();
	fn test_field_leading_min() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<CanvasFontParameters>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).leading_min) as usize - ptr as usize
		           },
		           1usize,
		           concat!(
			"Offset of field: ",
			stringify!(CanvasFontParameters),
			"::",
			stringify!(leading_min)
		)
		);
	}
	test_field_leading_min();
	fn test_field_height() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<CanvasFontParameters>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).height) as usize - ptr as usize
		           },
		           2usize,
		           concat!(
			"Offset of field: ",
			stringify!(CanvasFontParameters),
			"::",
			stringify!(height)
		)
		);
	}
	test_field_height();
	fn test_field_descender() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<CanvasFontParameters>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).descender) as usize - ptr as usize
		           },
		           3usize,
		           concat!(
			"Offset of field: ",
			stringify!(CanvasFontParameters),
			"::",
			stringify!(descender)
		)
		);
	}
	test_field_descender();
}
#[repr(C)]
pub struct Canvas {
	_unused: [u8; 0],
}
extern "C" {
	#[doc = " Get Canvas width"]
	#[doc = ""]
	#[doc = " @param      canvas  Canvas instance"]
	#[doc = ""]
	#[doc = " @return     width in pixels."]
	pub fn canvas_width(canvas: *mut Canvas) -> u8;
}
extern "C" {
	#[doc = " Get Canvas height"]
	#[doc = ""]
	#[doc = " @param      canvas  Canvas instance"]
	#[doc = ""]
	#[doc = " @return     height in pixels."]
	pub fn canvas_height(canvas: *mut Canvas) -> u8;
}
extern "C" {
	#[doc = " Get current font height"]
	#[doc = ""]
	#[doc = " @param      canvas  Canvas instance"]
	#[doc = ""]
	#[doc = " @return     height in pixels."]
	pub fn canvas_current_font_height(canvas: *mut Canvas) -> u8;
}
extern "C" {
	#[doc = " Get font parameters"]
	#[doc = ""]
	#[doc = " @param      canvas  Canvas instance"]
	#[doc = " @param      font    Font"]
	#[doc = ""]
	#[doc = " @return     pointer to CanvasFontParameters structure"]
	pub fn canvas_get_font_params(canvas: *mut Canvas, font: Font) -> *mut CanvasFontParameters;
}
extern "C" {
	#[doc = " Clear canvas"]
	#[doc = ""]
	#[doc = " @param      canvas  Canvas instance"]
	pub fn canvas_clear(canvas: *mut Canvas);
}
extern "C" {
	#[doc = " Set drawing color"]
	#[doc = ""]
	#[doc = " @param      canvas  Canvas instance"]
	#[doc = " @param      color   Color"]
	pub fn canvas_set_color(canvas: *mut Canvas, color: Color);
}
extern "C" {
	#[doc = " Set font swap"]
	#[doc = " Argument String Rotation Description"]
	#[doc = ""]
	#[doc = " @param      canvas  Canvas instance"]
	#[doc = " @param      dir     Direction font"]
	pub fn canvas_set_font_direction(canvas: *mut Canvas, dir: CanvasDirection);
}
extern "C" {
	#[doc = " Invert drawing color"]
	#[doc = ""]
	#[doc = " @param      canvas  Canvas instance"]
	pub fn canvas_invert_color(canvas: *mut Canvas);
}
extern "C" {
	#[doc = " Set drawing font"]
	#[doc = ""]
	#[doc = " @param      canvas  Canvas instance"]
	#[doc = " @param      font    Font"]
	pub fn canvas_set_font(canvas: *mut Canvas, font: Font);
}
extern "C" {
	#[doc = " Draw string at position of baseline defined by x, y."]
	#[doc = ""]
	#[doc = " @param      canvas  Canvas instance"]
	#[doc = " @param      x       anchor point x coordinate"]
	#[doc = " @param      y       anchor point y coordinate"]
	#[doc = " @param      str     C-string"]
	pub fn canvas_draw_str(canvas: *mut Canvas, x: u8, y: u8, str_: *const core::ffi::c_char);
}
extern "C" {
	#[doc = " Draw aligned string defined by x, y."]
	#[doc = ""]
	#[doc = " Align calculated from position of baseline, string width and ascent (height"]
	#[doc = " of the glyphs above the baseline)"]
	#[doc = ""]
	#[doc = " @param      canvas      Canvas instance"]
	#[doc = " @param      x           anchor point x coordinate"]
	#[doc = " @param      y           anchor point y coordinate"]
	#[doc = " @param      horizontal  horizontal alignment"]
	#[doc = " @param      vertical    vertical alignment"]
	#[doc = " @param      str         C-string"]
	pub fn canvas_draw_str_aligned(canvas: *mut Canvas,
	                               x: u8,
	                               y: u8,
	                               horizontal: Align,
	                               vertical: Align,
	                               str_: *const core::ffi::c_char);
}
extern "C" {
	#[doc = " Get string width"]
	#[doc = ""]
	#[doc = " @param      canvas  Canvas instance"]
	#[doc = " @param      str     C-string"]
	#[doc = ""]
	#[doc = " @return     width in pixels."]
	pub fn canvas_string_width(canvas: *mut Canvas, str_: *const core::ffi::c_char) -> u16;
}
extern "C" {
	#[doc = " Get glyph width"]
	#[doc = ""]
	#[doc = " @param      canvas  Canvas instance"]
	#[doc = " @param[in]  symbol  character"]
	#[doc = ""]
	#[doc = " @return     width in pixels"]
	pub fn canvas_glyph_width(canvas: *mut Canvas, symbol: core::ffi::c_char) -> u8;
}
extern "C" {
	#[doc = " Draw bitmap picture at position defined by x,y."]
	#[doc = ""]
	#[doc = " @param      canvas                   Canvas instance"]
	#[doc = " @param      x                        x coordinate"]
	#[doc = " @param      y                        y coordinate"]
	#[doc = " @param      width                    width of bitmap"]
	#[doc = " @param      height                   height of bitmap"]
	#[doc = " @param      compressed_bitmap_data   compressed bitmap data"]
	pub fn canvas_draw_bitmap(canvas: *mut Canvas, x: u8, y: u8, width: u8, height: u8, compressed_bitmap_data: *const u8);
}
extern "C" {
	#[doc = " Draw animation at position defined by x,y."]
	#[doc = ""]
	#[doc = " @param      canvas          Canvas instance"]
	#[doc = " @param      x               x coordinate"]
	#[doc = " @param      y               y coordinate"]
	#[doc = " @param      icon_animation  IconAnimation instance"]
	pub fn canvas_draw_icon_animation(canvas: *mut Canvas, x: u8, y: u8, icon_animation: *mut IconAnimation);
}
extern "C" {
	#[doc = " Draw icon at position defined by x,y."]
	#[doc = ""]
	#[doc = " @param      canvas  Canvas instance"]
	#[doc = " @param      x       x coordinate"]
	#[doc = " @param      y       y coordinate"]
	#[doc = " @param      icon    Icon instance"]
	pub fn canvas_draw_icon(canvas: *mut Canvas, x: u8, y: u8, icon: *const Icon);
}
extern "C" {
	#[doc = " Draw XBM bitmap"]
	#[doc = ""]
	#[doc = " @param      canvas  Canvas instance"]
	#[doc = " @param      x       x coordinate"]
	#[doc = " @param      y       y coordinate"]
	#[doc = " @param      w       bitmap width"]
	#[doc = " @param      h       bitmap height"]
	#[doc = " @param      bitmap  pointer to XBM bitmap data"]
	pub fn canvas_draw_xbm(canvas: *mut Canvas, x: u8, y: u8, w: u8, h: u8, bitmap: *const u8);
}
extern "C" {
	#[doc = " Draw dot at x,y"]
	#[doc = ""]
	#[doc = " @param      canvas  Canvas instance"]
	#[doc = " @param      x       x coordinate"]
	#[doc = " @param      y       y coordinate"]
	pub fn canvas_draw_dot(canvas: *mut Canvas, x: u8, y: u8);
}
extern "C" {
	#[doc = " Draw box of width, height at x,y"]
	#[doc = ""]
	#[doc = " @param      canvas  Canvas instance"]
	#[doc = " @param      x       x coordinate"]
	#[doc = " @param      y       y coordinate"]
	#[doc = " @param      width   box width"]
	#[doc = " @param      height  box height"]
	pub fn canvas_draw_box(canvas: *mut Canvas, x: u8, y: u8, width: u8, height: u8);
}
extern "C" {
	#[doc = " Draw frame of width, height at x,y"]
	#[doc = ""]
	#[doc = " @param      canvas  Canvas instance"]
	#[doc = " @param      x       x coordinate"]
	#[doc = " @param      y       y coordinate"]
	#[doc = " @param      width   frame width"]
	#[doc = " @param      height  frame height"]
	pub fn canvas_draw_frame(canvas: *mut Canvas, x: u8, y: u8, width: u8, height: u8);
}
extern "C" {
	#[doc = " Draw line from x1,y1 to x2,y2"]
	#[doc = ""]
	#[doc = " @param      canvas  Canvas instance"]
	#[doc = " @param      x1      x1 coordinate"]
	#[doc = " @param      y1      y1 coordinate"]
	#[doc = " @param      x2      x2 coordinate"]
	#[doc = " @param      y2      y2 coordinate"]
	pub fn canvas_draw_line(canvas: *mut Canvas, x1: u8, y1: u8, x2: u8, y2: u8);
}
extern "C" {
	#[doc = " Draw circle at x,y with radius r"]
	#[doc = ""]
	#[doc = " @param      canvas  Canvas instance"]
	#[doc = " @param      x       x coordinate"]
	#[doc = " @param      y       y coordinate"]
	#[doc = " @param      r       radius"]
	pub fn canvas_draw_circle(canvas: *mut Canvas, x: u8, y: u8, r: u8);
}
extern "C" {
	#[doc = " Draw disc at x,y with radius r"]
	#[doc = ""]
	#[doc = " @param      canvas  Canvas instance"]
	#[doc = " @param      x       x coordinate"]
	#[doc = " @param      y       y coordinate"]
	#[doc = " @param      r       radius"]
	pub fn canvas_draw_disc(canvas: *mut Canvas, x: u8, y: u8, r: u8);
}
extern "C" {
	#[doc = " Draw triangle with given base and height lengths and their intersection coordinate"]
	#[doc = ""]
	#[doc = " @param       canvas  Canvas instance"]
	#[doc = " @param       x       x coordinate of base and height intersection"]
	#[doc = " @param       y       y coordinate of base and height intersection"]
	#[doc = " @param       base    length of triangle side"]
	#[doc = " @param       height  length of triangle height"]
	#[doc = " @param       dir     CanvasDirection triangle orientation"]
	pub fn canvas_draw_triangle(canvas: *mut Canvas, x: u8, y: u8, base: u8, height: u8, dir: CanvasDirection);
}
extern "C" {
	#[doc = " Draw glyph"]
	#[doc = ""]
	#[doc = " @param      canvas  Canvas instance"]
	#[doc = " @param      x       x coordinate"]
	#[doc = " @param      y       y coordinate"]
	#[doc = " @param      ch      character"]
	pub fn canvas_draw_glyph(canvas: *mut Canvas, x: u8, y: u8, ch: u16);
}
extern "C" {
	#[doc = " Set transparency mode"]
	#[doc = ""]
	#[doc = " @param      canvas  Canvas instance"]
	#[doc = " @param      alpha   transparency mode"]
	pub fn canvas_set_bitmap_mode(canvas: *mut Canvas, alpha: bool);
}
extern "C" {
	#[doc = " Draw rounded-corner frame of width, height at x,y, with round value radius"]
	#[doc = ""]
	#[doc = " @param      canvas  Canvas instance"]
	#[doc = " @param      x       x coordinate"]
	#[doc = " @param      y       y coordinate"]
	#[doc = " @param      width   frame width"]
	#[doc = " @param      height  frame height"]
	#[doc = " @param      radius  frame corner radius"]
	pub fn canvas_draw_rframe(canvas: *mut Canvas, x: u8, y: u8, width: u8, height: u8, radius: u8);
}
extern "C" {
	#[doc = " Draw rounded-corner box of width, height at x,y, with round value raduis"]
	#[doc = ""]
	#[doc = " @param      canvas  Canvas instance"]
	#[doc = " @param      x       x coordinate"]
	#[doc = " @param      y       y coordinate"]
	#[doc = " @param      width   box width"]
	#[doc = " @param      height  box height"]
	#[doc = " @param      radius  box corner radius"]
	pub fn canvas_draw_rbox(canvas: *mut Canvas, x: u8, y: u8, width: u8, height: u8, radius: u8);
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum InputKey {
	InputKeyUp = 0,
	InputKeyDown = 1,
	InputKeyRight = 2,
	InputKeyLeft = 3,
	InputKeyOk = 4,
	InputKeyBack = 5,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum Light {
	LightRed = 1,
	LightGreen = 2,
	LightBlue = 4,
	LightBacklight = 8,
}
#[repr(C)]
pub struct InputPin {
	pub gpio: *const GpioPin,
	pub key: InputKey,
	pub inverted: bool,
	pub name: *const core::ffi::c_char,
}
#[test]
fn bindgen_test_layout_InputPin() {
	assert_eq!(
	           ::core::mem::size_of::<InputPin>(),
	           16usize,
	           concat!("Size of: ", stringify!(InputPin))
	);
	assert_eq!(
	           ::core::mem::align_of::<InputPin>(),
	           4usize,
	           concat!("Alignment of ", stringify!(InputPin))
	);
	fn test_field_gpio() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<InputPin>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).gpio) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(InputPin), "::", stringify!(gpio))
		);
	}
	test_field_gpio();
	fn test_field_key() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<InputPin>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).key) as usize - ptr as usize
		           },
		           4usize,
		           concat!("Offset of field: ", stringify!(InputPin), "::", stringify!(key))
		);
	}
	test_field_key();
	fn test_field_inverted() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<InputPin>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).inverted) as usize - ptr as usize
		           },
		           8usize,
		           concat!("Offset of field: ", stringify!(InputPin), "::", stringify!(inverted))
		);
	}
	test_field_inverted();
	fn test_field_name() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<InputPin>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).name) as usize - ptr as usize
		           },
		           12usize,
		           concat!("Offset of field: ", stringify!(InputPin), "::", stringify!(name))
		);
	}
	test_field_name();
}
extern "C" {
	pub static mut input_pins: [InputPin; 0usize];
}
extern "C" {
	pub static input_pins_count: usize;
}
extern "C" {
	pub static vibro_gpio: GpioPin;
}
extern "C" {
	pub static ibutton_gpio: GpioPin;
}
extern "C" {
	pub static gpio_cc1101_g0: GpioPin;
}
extern "C" {
	pub static gpio_rf_sw_0: GpioPin;
}
extern "C" {
	pub static gpio_subghz_cs: GpioPin;
}
extern "C" {
	pub static gpio_display_cs: GpioPin;
}
extern "C" {
	pub static gpio_display_rst_n: GpioPin;
}
extern "C" {
	pub static gpio_display_di: GpioPin;
}
extern "C" {
	pub static gpio_sdcard_cs: GpioPin;
}
extern "C" {
	pub static gpio_sdcard_cd: GpioPin;
}
extern "C" {
	pub static gpio_nfc_cs: GpioPin;
}
extern "C" {
	pub static gpio_button_up: GpioPin;
}
extern "C" {
	pub static gpio_button_down: GpioPin;
}
extern "C" {
	pub static gpio_button_right: GpioPin;
}
extern "C" {
	pub static gpio_button_left: GpioPin;
}
extern "C" {
	pub static gpio_button_ok: GpioPin;
}
extern "C" {
	pub static gpio_button_back: GpioPin;
}
extern "C" {
	pub static gpio_spi_d_miso: GpioPin;
}
extern "C" {
	pub static gpio_spi_d_mosi: GpioPin;
}
extern "C" {
	pub static gpio_spi_d_sck: GpioPin;
}
extern "C" {
	pub static gpio_spi_r_miso: GpioPin;
}
extern "C" {
	pub static gpio_spi_r_mosi: GpioPin;
}
extern "C" {
	pub static gpio_spi_r_sck: GpioPin;
}
extern "C" {
	pub static gpio_ext_pc0: GpioPin;
}
extern "C" {
	pub static gpio_ext_pc1: GpioPin;
}
extern "C" {
	pub static gpio_ext_pc3: GpioPin;
}
extern "C" {
	pub static gpio_ext_pb2: GpioPin;
}
extern "C" {
	pub static gpio_ext_pb3: GpioPin;
}
extern "C" {
	pub static gpio_ext_pa4: GpioPin;
}
extern "C" {
	pub static gpio_ext_pa6: GpioPin;
}
extern "C" {
	pub static gpio_ext_pa7: GpioPin;
}
extern "C" {
	pub static gpio_nfc_irq_rfid_pull: GpioPin;
}
extern "C" {
	pub static gpio_rfid_carrier_out: GpioPin;
}
extern "C" {
	pub static gpio_rfid_data_in: GpioPin;
}
extern "C" {
	pub static gpio_rfid_carrier: GpioPin;
}
extern "C" {
	pub static gpio_infrared_rx: GpioPin;
}
extern "C" {
	pub static gpio_infrared_tx: GpioPin;
}
extern "C" {
	pub static gpio_usart_tx: GpioPin;
}
extern "C" {
	pub static gpio_usart_rx: GpioPin;
}
extern "C" {
	pub static gpio_i2c_power_sda: GpioPin;
}
extern "C" {
	pub static gpio_i2c_power_scl: GpioPin;
}
extern "C" {
	pub static gpio_speaker: GpioPin;
}
extern "C" {
	pub static periph_power: GpioPin;
}
extern "C" {
	pub static gpio_usb_dm: GpioPin;
}
extern "C" {
	pub static gpio_usb_dp: GpioPin;
}
extern "C" {
	pub fn furi_hal_resources_init_early();
}
extern "C" {
	pub fn furi_hal_resources_deinit_early();
}
extern "C" {
	pub fn furi_hal_resources_init();
}
#[repr(u32)]
#[non_exhaustive]
#[doc = " Input Types"]
#[doc = " Some of them are physical events and some logical"]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum InputType {
	#[doc = "< Press event, emitted after debounce"]
	InputTypePress = 0,
	#[doc = "< Release event, emitted after debounce"]
	InputTypeRelease = 1,
	#[doc = "< Short event, emitted after InputTypeRelease done withing INPUT_LONG_PRESS interval"]
	InputTypeShort = 2,
	#[doc = "< Long event, emmited after INPUT_LONG_PRESS interval, asynchronouse to InputTypeRelease"]
	InputTypeLong = 3,
	#[doc = "< Repeat event, emmited with INPUT_REPEATE_PRESS period after InputTypeLong event"]
	InputTypeRepeat = 4,
}
#[doc = " Input Event, dispatches with FuriPubSub"]
#[repr(C)]
pub struct InputEvent {
	pub sequence: u32,
	pub key: InputKey,
	pub type_: InputType,
}
#[test]
fn bindgen_test_layout_InputEvent() {
	assert_eq!(
	           ::core::mem::size_of::<InputEvent>(),
	           12usize,
	           concat!("Size of: ", stringify!(InputEvent))
	);
	assert_eq!(
	           ::core::mem::align_of::<InputEvent>(),
	           4usize,
	           concat!("Alignment of ", stringify!(InputEvent))
	);
	fn test_field_sequence() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<InputEvent>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).sequence) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(InputEvent), "::", stringify!(sequence))
		);
	}
	test_field_sequence();
	fn test_field_key() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<InputEvent>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).key) as usize - ptr as usize
		           },
		           4usize,
		           concat!("Offset of field: ", stringify!(InputEvent), "::", stringify!(key))
		);
	}
	test_field_key();
	fn test_field_type() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<InputEvent>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize
		           },
		           8usize,
		           concat!("Offset of field: ", stringify!(InputEvent), "::", stringify!(type_))
		);
	}
	test_field_type();
}
extern "C" {
	#[doc = " Get human readable input key name"]
	#[doc = " @param key - InputKey"]
	#[doc = " @return string"]
	pub fn input_get_key_name(key: InputKey) -> *const core::ffi::c_char;
}
extern "C" {
	#[doc = " Get human readable input type name"]
	#[doc = " @param type - InputType"]
	#[doc = " @return string"]
	pub fn input_get_type_name(type_: InputType) -> *const core::ffi::c_char;
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum ViewOrientation {
	ViewOrientationHorizontal = 0,
	ViewOrientationVertical = 1,
}
#[repr(C)]
pub struct View {
	_unused: [u8; 0],
}
#[doc = " View Draw callback"]
#[doc = " @param      canvas,      pointer to canvas"]
#[doc = " @param      view_model,  pointer to context"]
#[doc = " @warning    called from GUI thread"]
pub type ViewDrawCallback = ::core::option::Option<unsafe extern "C" fn(canvas: *mut Canvas, model: *mut core::ffi::c_void)>;
#[doc = " View Input callback"]
#[doc = " @param      event,    pointer to input event data"]
#[doc = " @param      context,  pointer to context"]
#[doc = " @return     true if event handled, false if event ignored"]
#[doc = " @warning    called from GUI thread"]
pub type ViewInputCallback =
	::core::option::Option<unsafe extern "C" fn(event: *mut InputEvent, context: *mut core::ffi::c_void) -> bool>;
#[doc = " View Custom callback"]
#[doc = " @param      event,    number of custom event"]
#[doc = " @param      context,  pointer to context"]
#[doc = " @return     true if event handled, false if event ignored"]
pub type ViewCustomCallback = ::core::option::Option<unsafe extern "C" fn(event: u32, context: *mut core::ffi::c_void) -> bool>;
#[doc = " View navigation callback"]
#[doc = " @param      context,  pointer to context"]
#[doc = " @return     next view id"]
#[doc = " @warning    called from GUI thread"]
pub type ViewNavigationCallback = ::core::option::Option<unsafe extern "C" fn(context: *mut core::ffi::c_void) -> u32>;
#[doc = " View callback"]
#[doc = " @param      context,  pointer to context"]
#[doc = " @warning    called from GUI thread"]
pub type ViewCallback = ::core::option::Option<unsafe extern "C" fn(context: *mut core::ffi::c_void)>;
#[doc = " View Update Callback Called upon model change, need to be propagated to GUI"]
#[doc = " throw ViewPort update"]
#[doc = " @param      view,     pointer to view"]
#[doc = " @param      context,  pointer to context"]
#[doc = " @warning    called from GUI thread"]
pub type ViewUpdateCallback = ::core::option::Option<unsafe extern "C" fn(view: *mut View, context: *mut core::ffi::c_void)>;
#[repr(u32)]
#[non_exhaustive]
#[doc = " View model types"]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum ViewModelType {
	#[doc = " Model is not allocated"]
	ViewModelTypeNone = 0,
	#[doc = " Model consist of atomic types and/or partial update is not critical for rendering."]
	#[doc = " Lock free."]
	ViewModelTypeLockFree = 1,
	#[doc = " Model access is guarded with mutex."]
	#[doc = " Locking gui thread."]
	ViewModelTypeLocking = 2,
}
extern "C" {
	#[doc = " Allocate and init View"]
	#[doc = " @return View instance"]
	pub fn view_alloc() -> *mut View;
}
extern "C" {
	#[doc = " Free View"]
	#[doc = ""]
	#[doc = " @param      view  instance"]
	pub fn view_free(view: *mut View);
}
extern "C" {
	#[doc = " Tie IconAnimation with View"]
	#[doc = ""]
	#[doc = " @param      view            View instance"]
	#[doc = " @param      icon_animation  IconAnimation instance"]
	pub fn view_tie_icon_animation(view: *mut View, icon_animation: *mut IconAnimation);
}
extern "C" {
	#[doc = " Set View Draw callback"]
	#[doc = ""]
	#[doc = " @param      view      View instance"]
	#[doc = " @param      callback  draw callback"]
	pub fn view_set_draw_callback(view: *mut View, callback: ViewDrawCallback);
}
extern "C" {
	#[doc = " Set View Input callback"]
	#[doc = ""]
	#[doc = " @param      view      View instance"]
	#[doc = " @param      callback  input callback"]
	pub fn view_set_input_callback(view: *mut View, callback: ViewInputCallback);
}
extern "C" {
	#[doc = " Set View Custom callback"]
	#[doc = ""]
	#[doc = " @param      view      View instance"]
	#[doc = " @param      callback  input callback"]
	pub fn view_set_custom_callback(view: *mut View, callback: ViewCustomCallback);
}
extern "C" {
	#[doc = " Set Navigation Previous callback"]
	#[doc = ""]
	#[doc = " @param      view      View instance"]
	#[doc = " @param      callback  input callback"]
	pub fn view_set_previous_callback(view: *mut View, callback: ViewNavigationCallback);
}
extern "C" {
	#[doc = " Set Enter callback"]
	#[doc = ""]
	#[doc = " @param      view      View instance"]
	#[doc = " @param      callback  callback"]
	pub fn view_set_enter_callback(view: *mut View, callback: ViewCallback);
}
extern "C" {
	#[doc = " Set Exit callback"]
	#[doc = ""]
	#[doc = " @param      view      View instance"]
	#[doc = " @param      callback  callback"]
	pub fn view_set_exit_callback(view: *mut View, callback: ViewCallback);
}
extern "C" {
	#[doc = " Set Update callback"]
	#[doc = ""]
	#[doc = " @param      view      View instance"]
	#[doc = " @param      callback  callback"]
	pub fn view_set_update_callback(view: *mut View, callback: ViewUpdateCallback);
}
extern "C" {
	#[doc = " Set View Draw callback"]
	#[doc = ""]
	#[doc = " @param      view     View instance"]
	#[doc = " @param      context  context for callbacks"]
	pub fn view_set_update_callback_context(view: *mut View, context: *mut core::ffi::c_void);
}
extern "C" {
	#[doc = " Set View Draw callback"]
	#[doc = ""]
	#[doc = " @param      view     View instance"]
	#[doc = " @param      context  context for callbacks"]
	pub fn view_set_context(view: *mut View, context: *mut core::ffi::c_void);
}
extern "C" {
	#[doc = " Set View Orientation"]
	#[doc = ""]
	#[doc = " @param      view         View instance"]
	#[doc = " @param      orientation  either vertical or horizontal"]
	pub fn view_set_orientation(view: *mut View, orientation: ViewOrientation);
}
extern "C" {
	#[doc = " Allocate view model."]
	#[doc = ""]
	#[doc = " @param      view  View instance"]
	#[doc = " @param      type  View Model Type"]
	#[doc = " @param      size  size"]
	pub fn view_allocate_model(view: *mut View, type_: ViewModelType, size: usize);
}
extern "C" {
	#[doc = " Free view model data memory."]
	#[doc = ""]
	#[doc = " @param      view  View instance"]
	pub fn view_free_model(view: *mut View);
}
extern "C" {
	#[doc = " Get view model data"]
	#[doc = ""]
	#[doc = " @param      view  View instance"]
	#[doc = ""]
	#[doc = " @return     pointer to model data"]
	#[doc = " @warning    Don't forget to commit model changes"]
	pub fn view_get_model(view: *mut View) -> *mut core::ffi::c_void;
}
extern "C" {
	#[doc = " Commit view model"]
	#[doc = ""]
	#[doc = " @param      view    View instance"]
	#[doc = " @param      update  true if you want to emit view update, false otherwise"]
	pub fn view_commit_model(view: *mut View, update: bool);
}
#[repr(C)]
pub struct FileBrowser {
	_unused: [u8; 0],
}
pub type FileBrowserCallback = ::core::option::Option<unsafe extern "C" fn(context: *mut core::ffi::c_void)>;
pub type FileBrowserLoadItemCallback = ::core::option::Option<unsafe extern "C" fn(path: *mut string_t,
                                                                                   context: *mut core::ffi::c_void,
                                                                                   icon: *mut *mut u8,
                                                                                   item_name: *mut string_t)
                                                                                   -> bool>;
extern "C" {
	pub fn file_browser_alloc(result_path: string_ptr) -> *mut FileBrowser;
}
extern "C" {
	pub fn file_browser_free(browser: *mut FileBrowser);
}
extern "C" {
	pub fn file_browser_get_view(browser: *mut FileBrowser) -> *mut View;
}
extern "C" {
	pub fn file_browser_configure(browser: *mut FileBrowser,
	                              extension: *const core::ffi::c_char,
	                              skip_assets: bool,
	                              file_icon: *const Icon,
	                              hide_ext: bool);
}
extern "C" {
	pub fn file_browser_start(browser: *mut FileBrowser, path: *mut string_t);
}
extern "C" {
	pub fn file_browser_stop(browser: *mut FileBrowser);
}
extern "C" {
	pub fn file_browser_set_callback(browser: *mut FileBrowser, callback: FileBrowserCallback, context: *mut core::ffi::c_void);
}
extern "C" {
	pub fn file_browser_set_item_callback(browser: *mut FileBrowser,
	                                      callback: FileBrowserLoadItemCallback,
	                                      context: *mut core::ffi::c_void);
}
#[repr(C)]
pub struct DialogsApp {
	_unused: [u8; 0],
}
#[doc = " File browser dialog extra options"]
#[doc = " @param extension file extension to be offered for selection"]
#[doc = " @param skip_assets true - do not show assets folders"]
#[doc = " @param icon file icon pointer, NULL for default icon"]
#[doc = " @param hide_ext true - hide extensions for files"]
#[doc = " @param item_loader_callback callback function for providing custom icon & entry name"]
#[doc = " @param hide_ext callback context"]
#[repr(C)]
pub struct DialogsFileBrowserOptions {
	pub extension: *const core::ffi::c_char,
	pub skip_assets: bool,
	pub icon: *const Icon,
	pub hide_ext: bool,
	pub item_loader_callback: FileBrowserLoadItemCallback,
	pub item_loader_context: *mut core::ffi::c_void,
}
#[test]
fn bindgen_test_layout_DialogsFileBrowserOptions() {
	assert_eq!(
	           ::core::mem::size_of::<DialogsFileBrowserOptions>(),
	           24usize,
	           concat!("Size of: ", stringify!(DialogsFileBrowserOptions))
	);
	assert_eq!(
	           ::core::mem::align_of::<DialogsFileBrowserOptions>(),
	           4usize,
	           concat!("Alignment of ", stringify!(DialogsFileBrowserOptions))
	);
	fn test_field_extension() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<DialogsFileBrowserOptions>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).extension) as usize - ptr as usize
		           },
		           0usize,
		           concat!(
			"Offset of field: ",
			stringify!(DialogsFileBrowserOptions),
			"::",
			stringify!(extension)
		)
		);
	}
	test_field_extension();
	fn test_field_skip_assets() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<DialogsFileBrowserOptions>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).skip_assets) as usize - ptr as usize
		           },
		           4usize,
		           concat!(
			"Offset of field: ",
			stringify!(DialogsFileBrowserOptions),
			"::",
			stringify!(skip_assets)
		)
		);
	}
	test_field_skip_assets();
	fn test_field_icon() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<DialogsFileBrowserOptions>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).icon) as usize - ptr as usize
		           },
		           8usize,
		           concat!(
			"Offset of field: ",
			stringify!(DialogsFileBrowserOptions),
			"::",
			stringify!(icon)
		)
		);
	}
	test_field_icon();
	fn test_field_hide_ext() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<DialogsFileBrowserOptions>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).hide_ext) as usize - ptr as usize
		           },
		           12usize,
		           concat!(
			"Offset of field: ",
			stringify!(DialogsFileBrowserOptions),
			"::",
			stringify!(hide_ext)
		)
		);
	}
	test_field_hide_ext();
	fn test_field_item_loader_callback() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<DialogsFileBrowserOptions>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).item_loader_callback) as usize - ptr as usize
		           },
		           16usize,
		           concat!(
			"Offset of field: ",
			stringify!(DialogsFileBrowserOptions),
			"::",
			stringify!(item_loader_callback)
		)
		);
	}
	test_field_item_loader_callback();
	fn test_field_item_loader_context() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<DialogsFileBrowserOptions>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).item_loader_context) as usize - ptr as usize
		           },
		           20usize,
		           concat!(
			"Offset of field: ",
			stringify!(DialogsFileBrowserOptions),
			"::",
			stringify!(item_loader_context)
		)
		);
	}
	test_field_item_loader_context();
}
extern "C" {
	#[doc = " Initialize file browser dialog options"]
	#[doc = " and set default values"]
	#[doc = " @param options pointer to options structure"]
	#[doc = " @param extension file extension to filter"]
	#[doc = " @param icon file icon pointer, NULL for default icon"]
	pub fn dialog_file_browser_set_basic_options(options: *mut DialogsFileBrowserOptions,
	                                             extension: *const core::ffi::c_char,
	                                             icon: *const Icon);
}
extern "C" {
	#[doc = " Shows and processes the file browser dialog"]
	#[doc = " @param context api pointer"]
	#[doc = " @param result_path selected file path string pointer"]
	#[doc = " @param path preselected file path string pointer"]
	#[doc = " @param options file browser dialog extra options, may be null"]
	#[doc = " @return bool whether a file was selected"]
	pub fn dialog_file_browser_show(context: *mut DialogsApp,
	                                result_path: string_ptr,
	                                path: string_ptr,
	                                options: *const DialogsFileBrowserOptions)
	                                -> bool;
}
#[repr(u32)]
#[non_exhaustive]
#[doc = " Message result type"]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum DialogMessageButton {
	DialogMessageButtonBack = 0,
	DialogMessageButtonLeft = 1,
	DialogMessageButtonCenter = 2,
	DialogMessageButtonRight = 3,
}
#[repr(C)]
pub struct DialogMessage {
	_unused: [u8; 0],
}
extern "C" {
	#[doc = " Allocate and fill message"]
	#[doc = " @return DialogMessage*"]
	pub fn dialog_message_alloc() -> *mut DialogMessage;
}
extern "C" {
	#[doc = " Free message struct"]
	#[doc = " @param message message pointer"]
	pub fn dialog_message_free(message: *mut DialogMessage);
}
extern "C" {
	#[doc = " Set message text"]
	#[doc = " @param message message pointer"]
	#[doc = " @param text text, can be NULL if you don't want to display the text"]
	#[doc = " @param x x position"]
	#[doc = " @param y y position"]
	#[doc = " @param horizontal horizontal alignment"]
	#[doc = " @param vertical vertical alignment"]
	pub fn dialog_message_set_text(message: *mut DialogMessage,
	                               text: *const core::ffi::c_char,
	                               x: u8,
	                               y: u8,
	                               horizontal: Align,
	                               vertical: Align);
}
extern "C" {
	#[doc = " Set message header"]
	#[doc = " @param message message pointer"]
	#[doc = " @param text text, can be NULL if you don't want to display the header"]
	#[doc = " @param x x position"]
	#[doc = " @param y y position"]
	#[doc = " @param horizontal horizontal alignment"]
	#[doc = " @param vertical vertical alignment"]
	pub fn dialog_message_set_header(message: *mut DialogMessage,
	                                 text: *const core::ffi::c_char,
	                                 x: u8,
	                                 y: u8,
	                                 horizontal: Align,
	                                 vertical: Align);
}
extern "C" {
	#[doc = " Set message icon"]
	#[doc = " @param message message pointer"]
	#[doc = " @param icon icon pointer, can be NULL if you don't want to display the icon"]
	#[doc = " @param x x position"]
	#[doc = " @param y y position"]
	pub fn dialog_message_set_icon(message: *mut DialogMessage, icon: *const Icon, x: u8, y: u8);
}
extern "C" {
	#[doc = " Set message buttons text, button text can be NULL if you don't want to display and process some buttons"]
	#[doc = " @param message message pointer"]
	#[doc = " @param left left button text, can be NULL if you don't want to display the left button"]
	#[doc = " @param center center button text, can be NULL if you don't want to display the center button"]
	#[doc = " @param right right button text, can be NULL if you don't want to display the right button"]
	pub fn dialog_message_set_buttons(message: *mut DialogMessage,
	                                  left: *const core::ffi::c_char,
	                                  center: *const core::ffi::c_char,
	                                  right: *const core::ffi::c_char);
}
extern "C" {
	#[doc = " Show message from filled struct"]
	#[doc = " @param context api pointer"]
	#[doc = " @param message message struct pointer to be shown"]
	#[doc = " @return DialogMessageButton type"]
	pub fn dialog_message_show(context: *mut DialogsApp, message: *const DialogMessage) -> DialogMessageButton;
}
extern "C" {
	#[doc = " Show SD error message (with question sign)"]
	#[doc = " @param context"]
	#[doc = " @param error_text"]
	pub fn dialog_message_show_storage_error(context: *mut DialogsApp, error_text: *const core::ffi::c_char);
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum DolphinApp {
	DolphinAppSubGhz = 0,
	DolphinAppRfid = 1,
	DolphinAppNfc = 2,
	DolphinAppIr = 3,
	DolphinAppIbutton = 4,
	DolphinAppBadusb = 5,
	DolphinAppU2f = 6,
	DolphinAppMAX = 7,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum DolphinDeed {
	DolphinDeedSubGhzReceiverInfo = 0,
	DolphinDeedSubGhzSave = 1,
	DolphinDeedSubGhzRawRec = 2,
	DolphinDeedSubGhzAddManually = 3,
	DolphinDeedSubGhzSend = 4,
	DolphinDeedSubGhzFrequencyAnalyzer = 5,
	DolphinDeedRfidRead = 6,
	DolphinDeedRfidReadSuccess = 7,
	DolphinDeedRfidSave = 8,
	DolphinDeedRfidEmulate = 9,
	DolphinDeedRfidAdd = 10,
	DolphinDeedNfcRead = 11,
	DolphinDeedNfcReadSuccess = 12,
	DolphinDeedNfcSave = 13,
	DolphinDeedNfcEmulate = 14,
	DolphinDeedNfcAdd = 15,
	DolphinDeedIrSend = 16,
	DolphinDeedIrLearnSuccess = 17,
	DolphinDeedIrSave = 18,
	DolphinDeedIrBruteForce = 19,
	DolphinDeedIbuttonRead = 20,
	DolphinDeedIbuttonReadSuccess = 21,
	DolphinDeedIbuttonSave = 22,
	DolphinDeedIbuttonEmulate = 23,
	DolphinDeedIbuttonAdd = 24,
	DolphinDeedBadUsbPlayScript = 25,
	DolphinDeedU2fAuthorized = 26,
	DolphinDeedMAX = 27,
	DolphinDeedTestLeft = 28,
	DolphinDeedTestRight = 29,
}
extern "C" {
	pub fn dolphin_deed_get_app(deed: DolphinDeed) -> DolphinApp;
}
extern "C" {
	pub fn dolphin_deed_get_app_limit(app: DolphinApp) -> u8;
}
extern "C" {
	pub fn dolphin_deed_get_weight(deed: DolphinDeed) -> u8;
}
#[repr(C)]
pub struct Dolphin {
	_unused: [u8; 0],
}
#[repr(C)]
pub struct DolphinStats {
	pub icounter: u32,
	pub butthurt: u32,
	pub timestamp: u64,
	pub level: u8,
	pub level_up_is_pending: bool,
}
#[test]
fn bindgen_test_layout_DolphinStats() {
	assert_eq!(
	           ::core::mem::size_of::<DolphinStats>(),
	           24usize,
	           concat!("Size of: ", stringify!(DolphinStats))
	);
	assert_eq!(
	           ::core::mem::align_of::<DolphinStats>(),
	           8usize,
	           concat!("Alignment of ", stringify!(DolphinStats))
	);
	fn test_field_icounter() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<DolphinStats>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).icounter) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(DolphinStats), "::", stringify!(icounter))
		);
	}
	test_field_icounter();
	fn test_field_butthurt() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<DolphinStats>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).butthurt) as usize - ptr as usize
		           },
		           4usize,
		           concat!("Offset of field: ", stringify!(DolphinStats), "::", stringify!(butthurt))
		);
	}
	test_field_butthurt();
	fn test_field_timestamp() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<DolphinStats>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).timestamp) as usize - ptr as usize
		           },
		           8usize,
		           concat!("Offset of field: ", stringify!(DolphinStats), "::", stringify!(timestamp))
		);
	}
	test_field_timestamp();
	fn test_field_level() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<DolphinStats>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).level) as usize - ptr as usize
		           },
		           16usize,
		           concat!("Offset of field: ", stringify!(DolphinStats), "::", stringify!(level))
		);
	}
	test_field_level();
	fn test_field_level_up_is_pending() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<DolphinStats>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).level_up_is_pending) as usize - ptr as usize
		           },
		           17usize,
		           concat!(
			"Offset of field: ",
			stringify!(DolphinStats),
			"::",
			stringify!(level_up_is_pending)
		)
		);
	}
	test_field_level_up_is_pending();
}
extern "C" {
	#[doc = " Deed complete notification. Call it on deed completion."]
	#[doc = " See dolphin_deed.h for available deeds. In futures it will become part of assets."]
	#[doc = " Thread safe, async"]
	pub fn dolphin_deed(dolphin: *mut Dolphin, deed: DolphinDeed);
}
extern "C" {
	#[doc = " Retrieve dolphin stats"]
	#[doc = " Thread safe, blocking"]
	pub fn dolphin_stats(dolphin: *mut Dolphin) -> DolphinStats;
}
extern "C" {
	#[doc = " Flush dolphin queue and save state"]
	#[doc = " Thread safe, blocking"]
	pub fn dolphin_flush(dolphin: *mut Dolphin);
}
extern "C" {
	pub fn dolphin_upgrade_level(dolphin: *mut Dolphin);
}
extern "C" {
	pub fn dolphin_get_pubsub(dolphin: *mut Dolphin) -> *mut FuriPubSub;
}
extern "C" {
	#[doc = " Draw progress bar."]
	#[doc = ""]
	#[doc = " @param   canvas      Canvas instance"]
	#[doc = " @param   x           progress bar position on X axis"]
	#[doc = " @param   y           progress bar position on Y axis"]
	#[doc = " @param   width       progress bar width"]
	#[doc = " @param   progress    progress (0.0 - 1.0)"]
	pub fn elements_progress_bar(canvas: *mut Canvas, x: u8, y: u8, width: u8, progress: core::ffi::c_float);
}
extern "C" {
	#[doc = " Draw scrollbar on canvas at specific position."]
	#[doc = ""]
	#[doc = " @param   canvas  Canvas instance"]
	#[doc = " @param   x       scrollbar position on X axis"]
	#[doc = " @param   y       scrollbar position on Y axis"]
	#[doc = " @param   height  scrollbar height"]
	#[doc = " @param   pos     current element"]
	#[doc = " @param   total   total elements"]
	pub fn elements_scrollbar_pos(canvas: *mut Canvas, x: u8, y: u8, height: u8, pos: u16, total: u16);
}
extern "C" {
	#[doc = " Draw scrollbar on canvas."]
	#[doc = " @note    width 3px, height equal to canvas height"]
	#[doc = ""]
	#[doc = " @param   canvas  Canvas instance"]
	#[doc = " @param   pos     current element of total elements"]
	#[doc = " @param   total   total elements"]
	pub fn elements_scrollbar(canvas: *mut Canvas, pos: u16, total: u16);
}
extern "C" {
	#[doc = " Draw rounded frame"]
	#[doc = ""]
	#[doc = " @param   canvas          Canvas instance"]
	#[doc = " @param   x, y            top left corner coordinates"]
	#[doc = " @param   width, height   frame width and height"]
	pub fn elements_frame(canvas: *mut Canvas, x: u8, y: u8, width: u8, height: u8);
}
extern "C" {
	#[doc = " Draw button in left corner"]
	#[doc = ""]
	#[doc = " @param   canvas  Canvas instance"]
	#[doc = " @param   str     button text"]
	pub fn elements_button_left(canvas: *mut Canvas, str_: *const core::ffi::c_char);
}
extern "C" {
	#[doc = " Draw button in right corner"]
	#[doc = ""]
	#[doc = " @param   canvas  Canvas instance"]
	#[doc = " @param   str     button text"]
	pub fn elements_button_right(canvas: *mut Canvas, str_: *const core::ffi::c_char);
}
extern "C" {
	#[doc = " Draw button in center"]
	#[doc = ""]
	#[doc = " @param   canvas  Canvas instance"]
	#[doc = " @param   str     button text"]
	pub fn elements_button_center(canvas: *mut Canvas, str_: *const core::ffi::c_char);
}
extern "C" {
	#[doc = " Draw aligned multiline text"]
	#[doc = ""]
	#[doc = " @param   canvas                  Canvas instance"]
	#[doc = " @param   x, y                    coordinates based on align param"]
	#[doc = " @param   horizontal, vertical    aligment of multiline text"]
	#[doc = " @param   text                    string (possible multiline)"]
	pub fn elements_multiline_text_aligned(canvas: *mut Canvas,
	                                       x: u8,
	                                       y: u8,
	                                       horizontal: Align,
	                                       vertical: Align,
	                                       text: *const core::ffi::c_char);
}
extern "C" {
	#[doc = " Draw multiline text"]
	#[doc = ""]
	#[doc = " @param   canvas  Canvas instance"]
	#[doc = " @param   x, y    top left corner coordinates"]
	#[doc = " @param   text    string (possible multiline)"]
	pub fn elements_multiline_text(canvas: *mut Canvas, x: u8, y: u8, text: *const core::ffi::c_char);
}
extern "C" {
	#[doc = " Draw framed multiline text"]
	#[doc = ""]
	#[doc = " @param   canvas  Canvas instance"]
	#[doc = " @param   x, y    top left corner coordinates"]
	#[doc = " @param   text    string (possible multiline)"]
	pub fn elements_multiline_text_framed(canvas: *mut Canvas, x: u8, y: u8, text: *const core::ffi::c_char);
}
extern "C" {
	#[doc = " Draw slightly rounded frame"]
	#[doc = ""]
	#[doc = " @param   canvas          Canvas instance"]
	#[doc = " @param   x, y            top left corner coordinates"]
	#[doc = " @param   width, height   size of frame"]
	pub fn elements_slightly_rounded_frame(canvas: *mut Canvas, x: u8, y: u8, width: u8, height: u8);
}
extern "C" {
	#[doc = " Draw slightly rounded box"]
	#[doc = ""]
	#[doc = " @param   canvas          Canvas instance"]
	#[doc = " @param   x, y            top left corner coordinates"]
	#[doc = " @param   width, height   size of box"]
	pub fn elements_slightly_rounded_box(canvas: *mut Canvas, x: u8, y: u8, width: u8, height: u8);
}
extern "C" {
	#[doc = " Draw bold rounded frame"]
	#[doc = ""]
	#[doc = " @param   canvas          Canvas instance"]
	#[doc = " @param   x, y            top left corner coordinates"]
	#[doc = " @param   width, height   size of frame"]
	pub fn elements_bold_rounded_frame(canvas: *mut Canvas, x: u8, y: u8, width: u8, height: u8);
}
extern "C" {
	#[doc = " Draw bubble frame for text"]
	#[doc = ""]
	#[doc = " @param   canvas  Canvas instance"]
	#[doc = " @param   x       left x coordinates"]
	#[doc = " @param   y       top y coordinate"]
	#[doc = " @param   width   bubble width"]
	#[doc = " @param   height  bubble height"]
	pub fn elements_bubble(canvas: *mut Canvas, x: u8, y: u8, width: u8, height: u8);
}
extern "C" {
	#[doc = " Draw bubble frame for text with corner"]
	#[doc = ""]
	#[doc = " @param   canvas      Canvas instance"]
	#[doc = " @param   x           left x coordinates"]
	#[doc = " @param   y           top y coordinate"]
	#[doc = " @param   width       bubble width"]
	#[doc = " @param   height      bubble height"]
	#[doc = " @param   horizontal  horizontal aligning"]
	#[doc = " @param   vertical    aligning"]
	pub fn elements_bubble_str(canvas: *mut Canvas, x: u8, y: u8, text: *const core::ffi::c_char, horizontal: Align, vertical: Align);
}
extern "C" {
	#[doc = " Trim string buffer to fit width in pixels"]
	#[doc = ""]
	#[doc = " @param   canvas  Canvas instance"]
	#[doc = " @param   string  string to trim"]
	#[doc = " @param   width   max width"]
	pub fn elements_string_fit_width(canvas: *mut Canvas, string: *mut string_t, width: u8);
}
extern "C" {
	#[doc = " Draw text box element"]
	#[doc = ""]
	#[doc = " @param       canvas          Canvas instance"]
	#[doc = " @param       x               x coordinate"]
	#[doc = " @param       y               y coordinate"]
	#[doc = " @param       width           width to fit text"]
	#[doc = " @param       height          height to fit text"]
	#[doc = " @param       horizontal      Align instance"]
	#[doc = " @param       vertical        Align instance"]
	#[doc = " @param[in]   text            Formatted text. The following formats are available:"]
	#[doc = "                              \"\\e#Bold text\\e#\" - bold font is used"]
	#[doc = "                              \"\\e*Monospaced text\\e*\" - monospaced font is used"]
	#[doc = "                              \"\\e!Inversed text\\e!\" - white text on black background"]
	#[doc = " @param      strip_to_dots    Strip text to ... if does not fit to width"]
	pub fn elements_text_box(canvas: *mut Canvas,
	                         x: u8,
	                         y: u8,
	                         width: u8,
	                         height: u8,
	                         horizontal: Align,
	                         vertical: Align,
	                         text: *const core::ffi::c_char,
	                         strip_to_dots: bool);
}
#[repr(C)]
pub struct ViewPort {
	_unused: [u8; 0],
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum ViewPortOrientation {
	ViewPortOrientationHorizontal = 0,
	ViewPortOrientationVertical = 1,
}
#[doc = " ViewPort Draw callback"]
#[doc = " @warning    called from GUI thread"]
pub type ViewPortDrawCallback = ::core::option::Option<unsafe extern "C" fn(canvas: *mut Canvas, context: *mut core::ffi::c_void)>;
#[doc = " ViewPort Input callback"]
#[doc = " @warning    called from GUI thread"]
pub type ViewPortInputCallback =
	::core::option::Option<unsafe extern "C" fn(event: *mut InputEvent, context: *mut core::ffi::c_void)>;
extern "C" {
	#[doc = " ViewPort allocator"]
	#[doc = ""]
	#[doc = " always returns view_port or stops system if not enough memory."]
	#[doc = ""]
	#[doc = " @return     ViewPort instance"]
	pub fn view_port_alloc() -> *mut ViewPort;
}
extern "C" {
	#[doc = " ViewPort deallocator"]
	#[doc = ""]
	#[doc = " Ensure that view_port was unregistered in GUI system before use."]
	#[doc = ""]
	#[doc = " @param      view_port  ViewPort instance"]
	pub fn view_port_free(view_port: *mut ViewPort);
}
extern "C" {
	#[doc = " Set view_port width."]
	#[doc = ""]
	#[doc = " Will be used to limit canvas drawing area and autolayout feature."]
	#[doc = ""]
	#[doc = " @param      view_port  ViewPort instance"]
	#[doc = " @param      width      wanted width, 0 - auto."]
	pub fn view_port_set_width(view_port: *mut ViewPort, width: u8);
}
extern "C" {
	pub fn view_port_get_width(view_port: *mut ViewPort) -> u8;
}
extern "C" {
	#[doc = " Set view_port height."]
	#[doc = ""]
	#[doc = " Will be used to limit canvas drawing area and autolayout feature."]
	#[doc = ""]
	#[doc = " @param      view_port  ViewPort instance"]
	#[doc = " @param      height     wanted height, 0 - auto."]
	pub fn view_port_set_height(view_port: *mut ViewPort, height: u8);
}
extern "C" {
	pub fn view_port_get_height(view_port: *mut ViewPort) -> u8;
}
extern "C" {
	#[doc = " Enable or disable view_port rendering."]
	#[doc = ""]
	#[doc = " @param      view_port  ViewPort instance"]
	#[doc = " @param      enabled    Indicates if enabled"]
	#[doc = " @warning    automatically dispatches update event"]
	pub fn view_port_enabled_set(view_port: *mut ViewPort, enabled: bool);
}
extern "C" {
	pub fn view_port_is_enabled(view_port: *mut ViewPort) -> bool;
}
extern "C" {
	#[doc = " ViewPort event callbacks"]
	#[doc = ""]
	#[doc = " @param      view_port  ViewPort instance"]
	#[doc = " @param      callback   appropriate callback function"]
	#[doc = " @param      context    context to pass to callback"]
	pub fn view_port_draw_callback_set(view_port: *mut ViewPort, callback: ViewPortDrawCallback, context: *mut core::ffi::c_void);
}
extern "C" {
	pub fn view_port_input_callback_set(view_port: *mut ViewPort, callback: ViewPortInputCallback, context: *mut core::ffi::c_void);
}
extern "C" {
	#[doc = " Emit update signal to GUI system."]
	#[doc = ""]
	#[doc = " Rendering will happen later after GUI system process signal."]
	#[doc = ""]
	#[doc = " @param      view_port  ViewPort instance"]
	pub fn view_port_update(view_port: *mut ViewPort);
}
extern "C" {
	#[doc = " Set ViewPort orientation."]
	#[doc = ""]
	#[doc = " @param      view_port    ViewPort instance"]
	#[doc = " @param      orientation  display orientation, horizontal or vertical."]
	pub fn view_port_set_orientation(view_port: *mut ViewPort, orientation: ViewPortOrientation);
}
extern "C" {
	pub fn view_port_get_orientation(view_port: *const ViewPort) -> ViewPortOrientation;
}
#[repr(u32)]
#[non_exhaustive]
#[doc = " Gui layers"]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum GuiLayer {
	#[doc = "< Desktop layer for internal use. Like fullscreen but with status bar"]
	GuiLayerDesktop = 0,
	#[doc = "< Window layer, status bar is shown"]
	GuiLayerWindow = 1,
	#[doc = "< Status bar left-side layer, auto-layout"]
	GuiLayerStatusBarLeft = 2,
	#[doc = "< Status bar right-side layer, auto-layout"]
	GuiLayerStatusBarRight = 3,
	#[doc = "< Fullscreen layer, no status bar"]
	GuiLayerFullscreen = 4,
	#[doc = "< Don't use or move, special value"]
	GuiLayerMAX = 5,
}
#[doc = " Gui Canvas Commit Callback"]
pub type GuiCanvasCommitCallback =
	::core::option::Option<unsafe extern "C" fn(data: *mut u8, size: usize, context: *mut core::ffi::c_void)>;
#[repr(C)]
pub struct Gui {
	_unused: [u8; 0],
}
extern "C" {
	#[doc = " Add view_port to view_port tree"]
	#[doc = ""]
	#[doc = " @remark     thread safe"]
	#[doc = ""]
	#[doc = " @param      gui        Gui instance"]
	#[doc = " @param      view_port  ViewPort instance"]
	#[doc = " @param[in]  layer      GuiLayer where to place view_port"]
	pub fn gui_add_view_port(gui: *mut Gui, view_port: *mut ViewPort, layer: GuiLayer);
}
extern "C" {
	#[doc = " Remove view_port from rendering tree"]
	#[doc = ""]
	#[doc = " @remark     thread safe"]
	#[doc = ""]
	#[doc = " @param      gui        Gui instance"]
	#[doc = " @param      view_port  ViewPort instance"]
	pub fn gui_remove_view_port(gui: *mut Gui, view_port: *mut ViewPort);
}
extern "C" {
	#[doc = " Send ViewPort to the front"]
	#[doc = ""]
	#[doc = " Places selected ViewPort to the top of the drawing stack"]
	#[doc = ""]
	#[doc = " @param      gui        Gui instance"]
	#[doc = " @param      view_port  ViewPort instance"]
	pub fn gui_view_port_send_to_front(gui: *mut Gui, view_port: *mut ViewPort);
}
extern "C" {
	#[doc = " Send ViewPort to the back"]
	#[doc = ""]
	#[doc = " Places selected ViewPort to the bottom of the drawing stack"]
	#[doc = ""]
	#[doc = " @param      gui        Gui instance"]
	#[doc = " @param      view_port  ViewPort instance"]
	pub fn gui_view_port_send_to_back(gui: *mut Gui, view_port: *mut ViewPort);
}
extern "C" {
	#[doc = " Add gui canvas commit callback"]
	#[doc = ""]
	#[doc = " This callback will be called upon Canvas commit Callback dispatched from GUI"]
	#[doc = " thread and is time critical"]
	#[doc = ""]
	#[doc = " @param      gui       Gui instance"]
	#[doc = " @param      callback  GuiCanvasCommitCallback"]
	#[doc = " @param      context   GuiCanvasCommitCallback context"]
	pub fn gui_add_framebuffer_callback(gui: *mut Gui, callback: GuiCanvasCommitCallback, context: *mut core::ffi::c_void);
}
extern "C" {
	#[doc = " Remove gui canvas commit callback"]
	#[doc = ""]
	#[doc = " @param      gui       Gui instance"]
	#[doc = " @param      callback  GuiCanvasCommitCallback"]
	#[doc = " @param      context   GuiCanvasCommitCallback context"]
	pub fn gui_remove_framebuffer_callback(gui: *mut Gui, callback: GuiCanvasCommitCallback, context: *mut core::ffi::c_void);
}
extern "C" {
	#[doc = " Get gui canvas frame buffer size"]
	#[doc = " *"]
	#[doc = " @param      gui       Gui instance"]
	#[doc = " @return     size_t    size of frame buffer in bytes"]
	pub fn gui_get_framebuffer_size(gui: *mut Gui) -> usize;
}
extern "C" {
	#[doc = " Set lockdown mode"]
	#[doc = ""]
	#[doc = " When lockdown mode is enabled, only GuiLayerDesktop is shown."]
	#[doc = " This feature prevents services from showing sensitive information when flipper is locked."]
	#[doc = ""]
	#[doc = " @param      gui       Gui instance"]
	#[doc = " @param      lockdown  bool, true if enabled"]
	pub fn gui_set_lockdown(gui: *mut Gui, lockdown: bool);
}
#[repr(C)]
pub struct ButtonMenu {
	_unused: [u8; 0],
}
#[repr(C)]
pub struct ButtonMenuItem {
	_unused: [u8; 0],
}
#[doc = " Callback for any button menu actions"]
pub type ButtonMenuItemCallback =
	::core::option::Option<unsafe extern "C" fn(context: *mut core::ffi::c_void, index: i32, type_: InputType)>;
#[repr(u32)]
#[non_exhaustive]
#[doc = " Type of button. Difference in drawing buttons."]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum ButtonMenuItemType {
	ButtonMenuItemTypeCommon = 0,
	ButtonMenuItemTypeControl = 1,
}
extern "C" {
	#[doc = " Get button menu view"]
	#[doc = ""]
	#[doc = " @param      button_menu  ButtonMenu instance"]
	#[doc = ""]
	#[doc = " @return     View instance that can be used for embedding"]
	pub fn button_menu_get_view(button_menu: *mut ButtonMenu) -> *mut View;
}
extern "C" {
	#[doc = " Clean button menu"]
	#[doc = ""]
	#[doc = " @param      button_menu  ButtonMenu instance"]
	pub fn button_menu_reset(button_menu: *mut ButtonMenu);
}
extern "C" {
	#[doc = " Add item to button menu instance"]
	#[doc = ""]
	#[doc = " @param      button_menu       ButtonMenu instance"]
	#[doc = " @param      label             text inside new button"]
	#[doc = " @param      index             value to distinct between buttons inside"]
	#[doc = "                               ButtonMenuItemCallback"]
	#[doc = " @param      callback          The callback"]
	#[doc = " @param      type              type of button to create. Differ by button"]
	#[doc = "                               drawing. Control buttons have no frames, and"]
	#[doc = "                               have more squared borders."]
	#[doc = " @param      callback_context  The callback context"]
	#[doc = ""]
	#[doc = " @return     pointer to just-created item"]
	pub fn button_menu_add_item(button_menu: *mut ButtonMenu,
	                            label: *const core::ffi::c_char,
	                            index: i32,
	                            callback: ButtonMenuItemCallback,
	                            type_: ButtonMenuItemType,
	                            callback_context: *mut core::ffi::c_void)
	                            -> *mut ButtonMenuItem;
}
extern "C" {
	#[doc = " Allocate and initialize new instance of ButtonMenu model"]
	#[doc = ""]
	#[doc = " @return     just-created ButtonMenu model"]
	pub fn button_menu_alloc() -> *mut ButtonMenu;
}
extern "C" {
	#[doc = " Free ButtonMenu element"]
	#[doc = ""]
	#[doc = " @param      button_menu  ButtonMenu instance"]
	pub fn button_menu_free(button_menu: *mut ButtonMenu);
}
extern "C" {
	#[doc = " Set ButtonMenu header on top of canvas"]
	#[doc = ""]
	#[doc = " @param      button_menu  ButtonMenu instance"]
	#[doc = " @param      header       header on the top of button menu"]
	pub fn button_menu_set_header(button_menu: *mut ButtonMenu, header: *const core::ffi::c_char);
}
extern "C" {
	#[doc = " Set selected item"]
	#[doc = ""]
	#[doc = " @param      button_menu  ButtonMenu instance"]
	#[doc = " @param      index        index of ButtonMenu to be selected"]
	pub fn button_menu_set_selected_item(button_menu: *mut ButtonMenu, index: u32);
}
#[repr(C)]
pub struct ButtonPanel {
	_unused: [u8; 0],
}
#[doc = " Callback type to call for handling selecting button_panel items"]
pub type ButtonItemCallback = ::core::option::Option<unsafe extern "C" fn(context: *mut core::ffi::c_void, index: u32)>;
extern "C" {
	#[doc = " Allocate new button_panel module."]
	#[doc = ""]
	#[doc = " @return     ButtonPanel instance"]
	pub fn button_panel_alloc() -> *mut ButtonPanel;
}
extern "C" {
	#[doc = " Free button_panel module."]
	#[doc = ""]
	#[doc = " @param      button_panel  ButtonPanel instance"]
	pub fn button_panel_free(button_panel: *mut ButtonPanel);
}
extern "C" {
	#[doc = " Free items from button_panel module. Preallocated matrix stays unchanged."]
	#[doc = ""]
	#[doc = " @param      button_panel  ButtonPanel instance"]
	pub fn button_panel_reset(button_panel: *mut ButtonPanel);
}
extern "C" {
	#[doc = " Reserve space for adding items."]
	#[doc = ""]
	#[doc = " One does not simply use button_panel_add_item() without this function. It"]
	#[doc = " should be allocated space for it first."]
	#[doc = ""]
	#[doc = " @param      button_panel  ButtonPanel instance"]
	#[doc = " @param      reserve_x     number of columns in button_panel"]
	#[doc = " @param      reserve_y     number of rows in button_panel"]
	pub fn button_panel_reserve(button_panel: *mut ButtonPanel, reserve_x: usize, reserve_y: usize);
}
extern "C" {
	#[doc = " Add item to button_panel module."]
	#[doc = ""]
	#[doc = " Have to set element in bounds of allocated size by X and by Y."]
	#[doc = ""]
	#[doc = " @param      button_panel        ButtonPanel instance"]
	#[doc = " @param      index               value to pass to callback"]
	#[doc = " @param      matrix_place_x      coordinates by x-axis on virtual grid, it"]
	#[doc = "                                 is only used for navigation"]
	#[doc = " @param      matrix_place_y      coordinates by y-axis on virtual grid, it"]
	#[doc = "                                 is only used for naviagation"]
	#[doc = " @param      x                   x-coordinate to draw icon on"]
	#[doc = " @param      y                   y-coordinate to draw icon on"]
	#[doc = " @param      icon_name           name of the icon to draw"]
	#[doc = " @param      icon_name_selected  name of the icon to draw when current"]
	#[doc = "                                 element is selected"]
	#[doc = " @param      callback            function to call when specific element is"]
	#[doc = "                                 selected (pressed Ok on selected item)"]
	#[doc = " @param      callback_context    context to pass to callback"]
	pub fn button_panel_add_item(button_panel: *mut ButtonPanel,
	                             index: u32,
	                             matrix_place_x: u16,
	                             matrix_place_y: u16,
	                             x: u16,
	                             y: u16,
	                             icon_name: *const Icon,
	                             icon_name_selected: *const Icon,
	                             callback: ButtonItemCallback,
	                             callback_context: *mut core::ffi::c_void);
}
extern "C" {
	#[doc = " Get button_panel view."]
	#[doc = ""]
	#[doc = " @param      button_panel  ButtonPanel instance"]
	#[doc = ""]
	#[doc = " @return     acquired view"]
	pub fn button_panel_get_view(button_panel: *mut ButtonPanel) -> *mut View;
}
extern "C" {
	#[doc = " Add label to button_panel module."]
	#[doc = ""]
	#[doc = " @param      button_panel  ButtonPanel instance"]
	#[doc = " @param      x             x-coordinate to place label"]
	#[doc = " @param      y             y-coordinate to place label"]
	#[doc = " @param      font          font to write label with"]
	#[doc = " @param      label_str     string label to write"]
	pub fn button_panel_add_label(button_panel: *mut ButtonPanel, x: u16, y: u16, font: Font, label_str: *const core::ffi::c_char);
}
#[repr(C)]
pub struct ByteInput {
	_unused: [u8; 0],
}
#[doc = " callback that is executed on save button press"]
pub type ByteInputCallback = ::core::option::Option<unsafe extern "C" fn(context: *mut core::ffi::c_void)>;
#[doc = " callback that is executed when byte buffer is changed"]
pub type ByteChangedCallback = ::core::option::Option<unsafe extern "C" fn(context: *mut core::ffi::c_void)>;
extern "C" {
	#[doc = " Allocate and initialize byte input. This byte input is used to enter bytes."]
	#[doc = ""]
	#[doc = " @return     ByteInput instance pointer"]
	pub fn byte_input_alloc() -> *mut ByteInput;
}
extern "C" {
	#[doc = " Deinitialize and free byte input"]
	#[doc = ""]
	#[doc = " @param      byte_input  Byte input instance"]
	pub fn byte_input_free(byte_input: *mut ByteInput);
}
extern "C" {
	#[doc = " Get byte input view"]
	#[doc = ""]
	#[doc = " @param      byte_input  byte input instance"]
	#[doc = ""]
	#[doc = " @return     View instance that can be used for embedding"]
	pub fn byte_input_get_view(byte_input: *mut ByteInput) -> *mut View;
}
extern "C" {
	#[doc = " Set byte input result callback"]
	#[doc = ""]
	#[doc = " @param      byte_input        byte input instance"]
	#[doc = " @param      input_callback    input callback fn"]
	#[doc = " @param      changed_callback  changed callback fn"]
	#[doc = " @param      callback_context  callback context"]
	#[doc = " @param      bytes             buffer to use"]
	#[doc = " @param      bytes_count       buffer length"]
	pub fn byte_input_set_result_callback(byte_input: *mut ByteInput,
	                                      input_callback: ByteInputCallback,
	                                      changed_callback: ByteChangedCallback,
	                                      callback_context: *mut core::ffi::c_void,
	                                      bytes: *mut u8,
	                                      bytes_count: u8);
}
extern "C" {
	#[doc = " Set byte input header text"]
	#[doc = ""]
	#[doc = " @param      byte_input  byte input instance"]
	#[doc = " @param      text        text to be shown"]
	pub fn byte_input_set_header_text(byte_input: *mut ByteInput, text: *const core::ffi::c_char);
}
#[repr(C)]
pub struct DialogEx {
	_unused: [u8; 0],
}
#[repr(u32)]
#[non_exhaustive]
#[doc = " DialogEx result"]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum DialogExResult {
	DialogExResultLeft = 0,
	DialogExResultCenter = 1,
	DialogExResultRight = 2,
	DialogExPressLeft = 3,
	DialogExPressCenter = 4,
	DialogExPressRight = 5,
	DialogExReleaseLeft = 6,
	DialogExReleaseCenter = 7,
	DialogExReleaseRight = 8,
}
#[doc = " DialogEx result callback type"]
#[doc = " @warning comes from GUI thread"]
pub type DialogExResultCallback =
	::core::option::Option<unsafe extern "C" fn(result: DialogExResult, context: *mut core::ffi::c_void)>;
extern "C" {
	#[doc = " Allocate and initialize dialog"]
	#[doc = ""]
	#[doc = " This dialog used to ask simple questions"]
	#[doc = ""]
	#[doc = " @return     DialogEx instance"]
	pub fn dialog_ex_alloc() -> *mut DialogEx;
}
extern "C" {
	#[doc = " Deinitialize and free dialog"]
	#[doc = ""]
	#[doc = " @param      dialog_ex  DialogEx instance"]
	pub fn dialog_ex_free(dialog_ex: *mut DialogEx);
}
extern "C" {
	#[doc = " Get dialog view"]
	#[doc = ""]
	#[doc = " @param      dialog_ex  DialogEx instance"]
	#[doc = ""]
	#[doc = " @return     View instance that can be used for embedding"]
	pub fn dialog_ex_get_view(dialog_ex: *mut DialogEx) -> *mut View;
}
extern "C" {
	#[doc = " Set dialog result callback"]
	#[doc = ""]
	#[doc = " @param      dialog_ex  DialogEx instance"]
	#[doc = " @param      callback   result callback function"]
	pub fn dialog_ex_set_result_callback(dialog_ex: *mut DialogEx, callback: DialogExResultCallback);
}
extern "C" {
	#[doc = " Set dialog context"]
	#[doc = ""]
	#[doc = " @param      dialog_ex  DialogEx instance"]
	#[doc = " @param      context    context pointer, will be passed to result callback"]
	pub fn dialog_ex_set_context(dialog_ex: *mut DialogEx, context: *mut core::ffi::c_void);
}
extern "C" {
	#[doc = " Set dialog header text"]
	#[doc = ""]
	#[doc = " If text is null, dialog header will not be rendered"]
	#[doc = ""]
	#[doc = " @param      dialog_ex   DialogEx instance"]
	#[doc = " @param      text        text to be shown, can be multiline"]
	#[doc = " @param      x           x position"]
	#[doc = " @param      y           y position"]
	#[doc = " @param      horizontal  horizontal text aligment"]
	#[doc = " @param      vertical    vertical text aligment"]
	pub fn dialog_ex_set_header(dialog_ex: *mut DialogEx,
	                            text: *const core::ffi::c_char,
	                            x: u8,
	                            y: u8,
	                            horizontal: Align,
	                            vertical: Align);
}
extern "C" {
	#[doc = " Set dialog text"]
	#[doc = ""]
	#[doc = " If text is null, dialog text will not be rendered"]
	#[doc = ""]
	#[doc = " @param      dialog_ex   DialogEx instance"]
	#[doc = " @param      text        text to be shown, can be multiline"]
	#[doc = " @param      x           x position"]
	#[doc = " @param      y           y position"]
	#[doc = " @param      horizontal  horizontal text aligment"]
	#[doc = " @param      vertical    vertical text aligment"]
	pub fn dialog_ex_set_text(dialog_ex: *mut DialogEx,
	                          text: *const core::ffi::c_char,
	                          x: u8,
	                          y: u8,
	                          horizontal: Align,
	                          vertical: Align);
}
extern "C" {
	#[doc = " Set dialog icon"]
	#[doc = ""]
	#[doc = " If x or y is negative, dialog icon will not be rendered"]
	#[doc = ""]
	#[doc = " @param      dialog_ex  DialogEx instance"]
	#[doc = " @param      x          x position"]
	#[doc = " @param      y          y position"]
	#[doc = " @param      icon       The icon"]
	#[doc = " @param      name  icon to be shown"]
	pub fn dialog_ex_set_icon(dialog_ex: *mut DialogEx, x: u8, y: u8, icon: *const Icon);
}
extern "C" {
	#[doc = " Set left button text"]
	#[doc = ""]
	#[doc = " If text is null, left button will not be rendered and processed"]
	#[doc = ""]
	#[doc = " @param      dialog_ex  DialogEx instance"]
	#[doc = " @param      text       text to be shown"]
	pub fn dialog_ex_set_left_button_text(dialog_ex: *mut DialogEx, text: *const core::ffi::c_char);
}
extern "C" {
	#[doc = " Set center button text"]
	#[doc = ""]
	#[doc = " If text is null, center button will not be rendered and processed"]
	#[doc = ""]
	#[doc = " @param      dialog_ex  DialogEx instance"]
	#[doc = " @param      text       text to be shown"]
	pub fn dialog_ex_set_center_button_text(dialog_ex: *mut DialogEx, text: *const core::ffi::c_char);
}
extern "C" {
	#[doc = " Set right button text"]
	#[doc = ""]
	#[doc = " If text is null, right button will not be rendered and processed"]
	#[doc = ""]
	#[doc = " @param      dialog_ex  DialogEx instance"]
	#[doc = " @param      text       text to be shown"]
	pub fn dialog_ex_set_right_button_text(dialog_ex: *mut DialogEx, text: *const core::ffi::c_char);
}
extern "C" {
	#[doc = " Clean dialog"]
	#[doc = ""]
	#[doc = " @param      dialog_ex  DialogEx instance"]
	pub fn dialog_ex_reset(dialog_ex: *mut DialogEx);
}
extern "C" {
	#[doc = " Enable press/release events"]
	#[doc = ""]
	#[doc = " @param      dialog_ex  DialogEx instance"]
	pub fn dialog_ex_enable_extended_events(dialog_ex: *mut DialogEx);
}
extern "C" {
	#[doc = " Disable press/release events"]
	#[doc = ""]
	#[doc = " @param      dialog_ex  DialogEx instance"]
	pub fn dialog_ex_disable_extended_events(dialog_ex: *mut DialogEx);
}
#[repr(C)]
pub struct EmptyScreen {
	_unused: [u8; 0],
}
extern "C" {
	#[doc = " Allocate and initialize empty screen"]
	#[doc = ""]
	#[doc = " This empty screen used to ask simple questions like Yes/"]
	#[doc = ""]
	#[doc = " @return     EmptyScreen instance"]
	pub fn empty_screen_alloc() -> *mut EmptyScreen;
}
extern "C" {
	#[doc = " Deinitialize and free empty screen"]
	#[doc = ""]
	#[doc = " @param      empty_screen  Empty screen instance"]
	pub fn empty_screen_free(empty_screen: *mut EmptyScreen);
}
extern "C" {
	#[doc = " Get empty screen view"]
	#[doc = ""]
	#[doc = " @param      empty_screen  Empty screen instance"]
	#[doc = ""]
	#[doc = " @return     View instance that can be used for embedding"]
	pub fn empty_screen_get_view(empty_screen: *mut EmptyScreen) -> *mut View;
}
#[repr(C)]
pub struct BrowserWorker {
	_unused: [u8; 0],
}
pub type BrowserWorkerFolderOpenCallback =
	::core::option::Option<unsafe extern "C" fn(context: *mut core::ffi::c_void, item_cnt: u32, file_idx: i32, is_root: bool)>;
pub type BrowserWorkerListLoadCallback =
	::core::option::Option<unsafe extern "C" fn(context: *mut core::ffi::c_void, list_load_offset: u32)>;
pub type BrowserWorkerListItemCallback = ::core::option::Option<unsafe extern "C" fn(context: *mut core::ffi::c_void,
                                                                                     item_path: *mut string_t,
                                                                                     is_folder: bool,
                                                                                     is_last: bool)>;
pub type BrowserWorkerLongLoadCallback = ::core::option::Option<unsafe extern "C" fn(context: *mut core::ffi::c_void)>;
extern "C" {
	pub fn file_browser_worker_alloc(path: *mut string_t,
	                                 filter_ext: *const core::ffi::c_char,
	                                 skip_assets: bool)
	                                 -> *mut BrowserWorker;
}
extern "C" {
	pub fn file_browser_worker_free(browser: *mut BrowserWorker);
}
extern "C" {
	pub fn file_browser_worker_set_callback_context(browser: *mut BrowserWorker, context: *mut core::ffi::c_void);
}
extern "C" {
	pub fn file_browser_worker_set_folder_callback(browser: *mut BrowserWorker, cb: BrowserWorkerFolderOpenCallback);
}
extern "C" {
	pub fn file_browser_worker_set_list_callback(browser: *mut BrowserWorker, cb: BrowserWorkerListLoadCallback);
}
extern "C" {
	pub fn file_browser_worker_set_item_callback(browser: *mut BrowserWorker, cb: BrowserWorkerListItemCallback);
}
extern "C" {
	pub fn file_browser_worker_set_long_load_callback(browser: *mut BrowserWorker, cb: BrowserWorkerLongLoadCallback);
}
extern "C" {
	pub fn file_browser_worker_set_config(browser: *mut BrowserWorker,
	                                      path: *mut string_t,
	                                      filter_ext: *const core::ffi::c_char,
	                                      skip_assets: bool);
}
extern "C" {
	pub fn file_browser_worker_folder_enter(browser: *mut BrowserWorker, path: *mut string_t, item_idx: i32);
}
extern "C" {
	pub fn file_browser_worker_folder_exit(browser: *mut BrowserWorker);
}
extern "C" {
	pub fn file_browser_worker_folder_refresh(browser: *mut BrowserWorker, item_idx: i32);
}
extern "C" {
	pub fn file_browser_worker_load(browser: *mut BrowserWorker, offset: u32, count: u32);
}
#[repr(C)]
pub struct Loading {
	_unused: [u8; 0],
}
extern "C" {
	#[doc = " Allocate and initialize"]
	#[doc = ""]
	#[doc = " This View used to show system is doing some processing"]
	#[doc = ""]
	#[doc = " @return     Loading View instance"]
	pub fn loading_alloc() -> *mut Loading;
}
extern "C" {
	#[doc = " Deinitialize and free Loading View"]
	#[doc = ""]
	#[doc = " @param      instance  Loading instance"]
	pub fn loading_free(instance: *mut Loading);
}
extern "C" {
	#[doc = " Get Loading view"]
	#[doc = ""]
	#[doc = " @param      instance  Loading instance"]
	#[doc = ""]
	#[doc = " @return     View instance that can be used for embedding"]
	pub fn loading_get_view(instance: *mut Loading) -> *mut View;
}
#[repr(C)]
pub struct Menu {
	_unused: [u8; 0],
}
#[doc = " Menu Item Callback"]
pub type MenuItemCallback = ::core::option::Option<unsafe extern "C" fn(context: *mut core::ffi::c_void, index: u32)>;
extern "C" {
	#[doc = " Menu allocation and initialization"]
	#[doc = ""]
	#[doc = " @return     Menu instance"]
	pub fn menu_alloc() -> *mut Menu;
}
extern "C" {
	#[doc = " Free menu"]
	#[doc = ""]
	#[doc = " @param      menu  Menu instance"]
	pub fn menu_free(menu: *mut Menu);
}
extern "C" {
	#[doc = " Get Menu view"]
	#[doc = ""]
	#[doc = " @param      menu  Menu instance"]
	#[doc = ""]
	#[doc = " @return     View instance"]
	pub fn menu_get_view(menu: *mut Menu) -> *mut View;
}
extern "C" {
	#[doc = " Add item to menu"]
	#[doc = ""]
	#[doc = " @param      menu      Menu instance"]
	#[doc = " @param      label     menu item string label"]
	#[doc = " @param      icon      IconAnimation instance"]
	#[doc = " @param      index     menu item index"]
	#[doc = " @param      callback  MenuItemCallback instance"]
	#[doc = " @param      context   pointer to context"]
	pub fn menu_add_item(menu: *mut Menu,
	                     label: *const core::ffi::c_char,
	                     icon: *const Icon,
	                     index: u32,
	                     callback: MenuItemCallback,
	                     context: *mut core::ffi::c_void);
}
extern "C" {
	#[doc = " Clean menu"]
	#[doc = " @note       this function does not free menu instance"]
	#[doc = ""]
	#[doc = " @param      menu  Menu instance"]
	pub fn menu_reset(menu: *mut Menu);
}
extern "C" {
	#[doc = " Set current menu item"]
	#[doc = ""]
	#[doc = " @param      menu   Menu instance"]
	#[doc = " @param      index  The index"]
	pub fn menu_set_selected_item(menu: *mut Menu, index: u32);
}
#[repr(C)]
pub struct Popup {
	_unused: [u8; 0],
}
#[doc = " Popup result callback type"]
#[doc = " @warning    comes from GUI thread"]
pub type PopupCallback = ::core::option::Option<unsafe extern "C" fn(context: *mut core::ffi::c_void)>;
extern "C" {
	#[doc = " Allocate and initialize popup"]
	#[doc = ""]
	#[doc = " This popup used to ask simple questions like Yes/"]
	#[doc = ""]
	#[doc = " @return     Popup instance"]
	pub fn popup_alloc() -> *mut Popup;
}
extern "C" {
	#[doc = " Deinitialize and free popup"]
	#[doc = ""]
	#[doc = " @param      popup  Popup instance"]
	pub fn popup_free(popup: *mut Popup);
}
extern "C" {
	#[doc = " Get popup view"]
	#[doc = ""]
	#[doc = " @param      popup  Popup instance"]
	#[doc = ""]
	#[doc = " @return     View instance that can be used for embedding"]
	pub fn popup_get_view(popup: *mut Popup) -> *mut View;
}
extern "C" {
	#[doc = " Set popup header text"]
	#[doc = ""]
	#[doc = " @param      popup     Popup instance"]
	#[doc = " @param      callback  PopupCallback"]
	pub fn popup_set_callback(popup: *mut Popup, callback: PopupCallback);
}
extern "C" {
	#[doc = " Set popup context"]
	#[doc = ""]
	#[doc = " @param      popup    Popup instance"]
	#[doc = " @param      context  context pointer, will be passed to result callback"]
	pub fn popup_set_context(popup: *mut Popup, context: *mut core::ffi::c_void);
}
extern "C" {
	#[doc = " Set popup header text"]
	#[doc = ""]
	#[doc = " If text is null, popup header will not be rendered"]
	#[doc = ""]
	#[doc = " @param      popup       Popup instance"]
	#[doc = " @param      text        text to be shown, can be multiline"]
	#[doc = " @param      x           x position"]
	#[doc = " @param      y           y position"]
	#[doc = " @param      horizontal  horizontal alignment"]
	#[doc = " @param      vertical    vertical aligment"]
	pub fn popup_set_header(popup: *mut Popup, text: *const core::ffi::c_char, x: u8, y: u8, horizontal: Align, vertical: Align);
}
extern "C" {
	#[doc = " Set popup text"]
	#[doc = ""]
	#[doc = " If text is null, popup text will not be rendered"]
	#[doc = ""]
	#[doc = " @param      popup       Popup instance"]
	#[doc = " @param      text        text to be shown, can be multiline"]
	#[doc = " @param      x           x position"]
	#[doc = " @param      y           y position"]
	#[doc = " @param      horizontal  horizontal alignment"]
	#[doc = " @param      vertical    vertical aligment"]
	pub fn popup_set_text(popup: *mut Popup, text: *const core::ffi::c_char, x: u8, y: u8, horizontal: Align, vertical: Align);
}
extern "C" {
	#[doc = " Set popup icon"]
	#[doc = ""]
	#[doc = " If icon position is negative, popup icon will not be rendered"]
	#[doc = ""]
	#[doc = " @param      popup  Popup instance"]
	#[doc = " @param      x      x position"]
	#[doc = " @param      y      y position"]
	#[doc = " @param      icon   pointer to Icon data"]
	pub fn popup_set_icon(popup: *mut Popup, x: u8, y: u8, icon: *const Icon);
}
extern "C" {
	#[doc = " Set popup timeout"]
	#[doc = ""]
	#[doc = " @param      popup          Popup instance"]
	#[doc = " @param      timeout_in_ms  popup timeout value in milliseconds"]
	pub fn popup_set_timeout(popup: *mut Popup, timeout_in_ms: u32);
}
extern "C" {
	#[doc = " Enable popup timeout"]
	#[doc = ""]
	#[doc = " @param      popup  Popup instance"]
	pub fn popup_enable_timeout(popup: *mut Popup);
}
extern "C" {
	#[doc = " Disable popup timeout"]
	#[doc = ""]
	#[doc = " @param      popup  Popup instance"]
	pub fn popup_disable_timeout(popup: *mut Popup);
}
extern "C" {
	#[doc = " Reset popup instance state"]
	#[doc = ""]
	#[doc = " @param       popup Popup instance"]
	pub fn popup_reset(popup: *mut Popup);
}
#[repr(C)]
pub struct Submenu {
	_unused: [u8; 0],
}
pub type SubmenuItemCallback = ::core::option::Option<unsafe extern "C" fn(context: *mut core::ffi::c_void, index: u32)>;
extern "C" {
	#[doc = " Allocate and initialize submenu"]
	#[doc = ""]
	#[doc = " This submenu is used to select one option"]
	#[doc = ""]
	#[doc = " @return     Submenu instance"]
	pub fn submenu_alloc() -> *mut Submenu;
}
extern "C" {
	#[doc = " Deinitialize and free submenu"]
	#[doc = ""]
	#[doc = " @param      submenu  Submenu instance"]
	pub fn submenu_free(submenu: *mut Submenu);
}
extern "C" {
	#[doc = " Get submenu view"]
	#[doc = ""]
	#[doc = " @param      submenu  Submenu instance"]
	#[doc = ""]
	#[doc = " @return     View instance that can be used for embedding"]
	pub fn submenu_get_view(submenu: *mut Submenu) -> *mut View;
}
extern "C" {
	#[doc = " Add item to submenu"]
	#[doc = ""]
	#[doc = " @param      submenu           Submenu instance"]
	#[doc = " @param      label             menu item label"]
	#[doc = " @param      index             menu item index, used for callback, may be"]
	#[doc = "                               the same with other items"]
	#[doc = " @param      callback          menu item callback"]
	#[doc = " @param      callback_context  menu item callback context"]
	pub fn submenu_add_item(submenu: *mut Submenu,
	                        label: *const core::ffi::c_char,
	                        index: u32,
	                        callback: SubmenuItemCallback,
	                        callback_context: *mut core::ffi::c_void);
}
extern "C" {
	#[doc = " Remove all items from submenu"]
	#[doc = ""]
	#[doc = " @param      submenu  Submenu instance"]
	pub fn submenu_reset(submenu: *mut Submenu);
}
extern "C" {
	#[doc = " Set submenu item selector"]
	#[doc = ""]
	#[doc = " @param      submenu  Submenu instance"]
	#[doc = " @param      index    The index"]
	pub fn submenu_set_selected_item(submenu: *mut Submenu, index: u32);
}
extern "C" {
	#[doc = " Set optional header for submenu"]
	#[doc = ""]
	#[doc = " @param      submenu  Submenu instance"]
	#[doc = " @param      header   header to set"]
	pub fn submenu_set_header(submenu: *mut Submenu, header: *const core::ffi::c_char);
}
#[repr(C)]
pub struct TextBox {
	_unused: [u8; 0],
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum TextBoxFont {
	TextBoxFontText = 0,
	TextBoxFontHex = 1,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum TextBoxFocus {
	TextBoxFocusStart = 0,
	TextBoxFocusEnd = 1,
}
extern "C" {
	#[doc = " Allocate and initialize text_box"]
	#[doc = ""]
	#[doc = " @return     TextBox instance"]
	pub fn text_box_alloc() -> *mut TextBox;
}
extern "C" {
	#[doc = " Deinitialize and free text_box"]
	#[doc = ""]
	#[doc = " @param      text_box  text_box instance"]
	pub fn text_box_free(text_box: *mut TextBox);
}
extern "C" {
	#[doc = " Get text_box view"]
	#[doc = ""]
	#[doc = " @param      text_box  TextBox instance"]
	#[doc = ""]
	#[doc = " @return     View instance that can be used for embedding"]
	pub fn text_box_get_view(text_box: *mut TextBox) -> *mut View;
}
extern "C" {
	#[doc = " Clean text_box"]
	#[doc = ""]
	#[doc = " @param      text_box  TextBox instance"]
	pub fn text_box_reset(text_box: *mut TextBox);
}
extern "C" {
	#[doc = " Set text for text_box"]
	#[doc = ""]
	#[doc = " @param      text_box  TextBox instance"]
	#[doc = " @param      text      text to set"]
	pub fn text_box_set_text(text_box: *mut TextBox, text: *const core::ffi::c_char);
}
extern "C" {
	#[doc = " Set TextBox font"]
	#[doc = ""]
	#[doc = " @param      text_box  TextBox instance"]
	#[doc = " @param      font      TextBoxFont instance"]
	pub fn text_box_set_font(text_box: *mut TextBox, font: TextBoxFont);
}
extern "C" {
	#[doc = " Set TextBox focus"]
	#[doc = " @note Use to display from start or from end"]
	#[doc = ""]
	#[doc = " @param      text_box  TextBox instance"]
	#[doc = " @param      focus     TextBoxFocus instance"]
	pub fn text_box_set_focus(text_box: *mut TextBox, focus: TextBoxFocus);
}
#[repr(C)]
pub struct ValidatorIsFile {
	_unused: [u8; 0],
}
extern "C" {
	pub fn validator_is_file_alloc_init(app_path_folder: *const core::ffi::c_char,
	                                    app_extension: *const core::ffi::c_char,
	                                    current_name: *const core::ffi::c_char)
	                                    -> *mut ValidatorIsFile;
}
extern "C" {
	pub fn validator_is_file_free(instance: *mut ValidatorIsFile);
}
extern "C" {
	pub fn validator_is_file_callback(text: *const core::ffi::c_char, error: *mut string_t, context: *mut core::ffi::c_void) -> bool;
}
#[repr(C)]
pub struct TextInput {
	_unused: [u8; 0],
}
pub type TextInputCallback = ::core::option::Option<unsafe extern "C" fn(context: *mut core::ffi::c_void)>;
pub type TextInputValidatorCallback = ::core::option::Option<unsafe extern "C" fn(text: *const core::ffi::c_char,
                                                                                  error: *mut string_t,
                                                                                  context: *mut core::ffi::c_void)
                                                                                  -> bool>;
extern "C" {
	#[doc = " Allocate and initialize text input"]
	#[doc = ""]
	#[doc = " This text input is used to enter string"]
	#[doc = ""]
	#[doc = " @return     TextInput instance"]
	pub fn text_input_alloc() -> *mut TextInput;
}
extern "C" {
	#[doc = " Deinitialize and free text input"]
	#[doc = ""]
	#[doc = " @param      text_input  TextInput instance"]
	pub fn text_input_free(text_input: *mut TextInput);
}
extern "C" {
	#[doc = " Clean text input view Note: this function does not free memory"]
	#[doc = ""]
	#[doc = " @param      text_input  Text input instance"]
	pub fn text_input_reset(text_input: *mut TextInput);
}
extern "C" {
	#[doc = " Get text input view"]
	#[doc = ""]
	#[doc = " @param      text_input  TextInput instance"]
	#[doc = ""]
	#[doc = " @return     View instance that can be used for embedding"]
	pub fn text_input_get_view(text_input: *mut TextInput) -> *mut View;
}
extern "C" {
	#[doc = " Set text input result callback"]
	#[doc = ""]
	#[doc = " @param      text_input          TextInput instance"]
	#[doc = " @param      callback            callback fn"]
	#[doc = " @param      callback_context    callback context"]
	#[doc = " @param      text_buffer         pointer to YOUR text buffer, that we going"]
	#[doc = "                                 to modify"]
	#[doc = " @param      text_buffer_size    YOUR text buffer size in bytes. Max string"]
	#[doc = "                                 length will be text_buffer_size-1."]
	#[doc = " @param      clear_default_text  clear text from text_buffer on first OK"]
	#[doc = "                                 event"]
	pub fn text_input_set_result_callback(text_input: *mut TextInput,
	                                      callback: TextInputCallback,
	                                      callback_context: *mut core::ffi::c_void,
	                                      text_buffer: *mut core::ffi::c_char,
	                                      text_buffer_size: usize,
	                                      clear_default_text: bool);
}
extern "C" {
	pub fn text_input_set_validator(text_input: *mut TextInput,
	                                callback: TextInputValidatorCallback,
	                                callback_context: *mut core::ffi::c_void);
}
extern "C" {
	pub fn text_input_get_validator_callback(text_input: *mut TextInput) -> TextInputValidatorCallback;
}
extern "C" {
	pub fn text_input_get_validator_callback_context(text_input: *mut TextInput) -> *mut core::ffi::c_void;
}
extern "C" {
	#[doc = " Set text input header text"]
	#[doc = ""]
	#[doc = " @param      text_input  TextInput instance"]
	#[doc = " @param      text        text to be shown"]
	pub fn text_input_set_header_text(text_input: *mut TextInput, text: *const core::ffi::c_char);
}
#[repr(C)]
pub struct VariableItemList {
	_unused: [u8; 0],
}
#[repr(C)]
pub struct VariableItem {
	_unused: [u8; 0],
}
pub type VariableItemChangeCallback = ::core::option::Option<unsafe extern "C" fn(item: *mut VariableItem)>;
pub type VariableItemListEnterCallback = ::core::option::Option<unsafe extern "C" fn(context: *mut core::ffi::c_void, index: u32)>;
extern "C" {
	#[doc = " Allocate and initialize VariableItemList"]
	#[doc = ""]
	#[doc = " @return     VariableItemList*"]
	pub fn variable_item_list_alloc() -> *mut VariableItemList;
}
extern "C" {
	#[doc = " Deinitialize and free VariableItemList"]
	#[doc = ""]
	#[doc = " @param      variable_item_list  VariableItemList instance"]
	pub fn variable_item_list_free(variable_item_list: *mut VariableItemList);
}
extern "C" {
	#[doc = " Clear all elements from list"]
	#[doc = ""]
	#[doc = " @param      variable_item_list  VariableItemList instance"]
	pub fn variable_item_list_reset(variable_item_list: *mut VariableItemList);
}
extern "C" {
	#[doc = " Get VariableItemList View instance"]
	#[doc = ""]
	#[doc = " @param      variable_item_list  VariableItemList instance"]
	#[doc = ""]
	#[doc = " @return     View instance"]
	pub fn variable_item_list_get_view(variable_item_list: *mut VariableItemList) -> *mut View;
}
extern "C" {
	#[doc = " Add item to VariableItemList"]
	#[doc = ""]
	#[doc = " @param      variable_item_list  VariableItemList instance"]
	#[doc = " @param      label               item name"]
	#[doc = " @param      values_count        item values count"]
	#[doc = " @param      change_callback     called on value change in gui"]
	#[doc = " @param      context             item context"]
	#[doc = ""]
	#[doc = " @return     VariableItem* item instance"]
	pub fn variable_item_list_add(variable_item_list: *mut VariableItemList,
	                              label: *const core::ffi::c_char,
	                              values_count: u8,
	                              change_callback: VariableItemChangeCallback,
	                              context: *mut core::ffi::c_void)
	                              -> *mut VariableItem;
}
extern "C" {
	#[doc = " Set enter callback"]
	#[doc = ""]
	#[doc = " @param      variable_item_list  VariableItemList instance"]
	#[doc = " @param      callback            VariableItemListEnterCallback instance"]
	#[doc = " @param      context             pointer to context"]
	pub fn variable_item_list_set_enter_callback(variable_item_list: *mut VariableItemList,
	                                             callback: VariableItemListEnterCallback,
	                                             context: *mut core::ffi::c_void);
}
extern "C" {
	pub fn variable_item_list_set_selected_item(variable_item_list: *mut VariableItemList, index: u8);
}
extern "C" {
	pub fn variable_item_list_get_selected_item_index(variable_item_list: *mut VariableItemList) -> u8;
}
extern "C" {
	#[doc = " Set item current selected index"]
	#[doc = ""]
	#[doc = " @param      item                 VariableItem* instance"]
	#[doc = " @param      current_value_index  The current value index"]
	pub fn variable_item_set_current_value_index(item: *mut VariableItem, current_value_index: u8);
}
extern "C" {
	#[doc = " Set item current selected text"]
	#[doc = ""]
	#[doc = " @param      item                VariableItem* instance"]
	#[doc = " @param      current_value_text  The current value text"]
	pub fn variable_item_set_current_value_text(item: *mut VariableItem, current_value_text: *const core::ffi::c_char);
}
extern "C" {
	#[doc = " Get item current selected index"]
	#[doc = ""]
	#[doc = " @param      item  VariableItem* instance"]
	#[doc = ""]
	#[doc = " @return     uint8_t current selected index"]
	pub fn variable_item_get_current_value_index(item: *mut VariableItem) -> u8;
}
extern "C" {
	#[doc = " Get item context"]
	#[doc = ""]
	#[doc = " @param      item  VariableItem* instance"]
	#[doc = ""]
	#[doc = " @return     void* item context"]
	pub fn variable_item_get_context(item: *mut VariableItem) -> *mut core::ffi::c_void;
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum GuiButtonType {
	GuiButtonTypeLeft = 0,
	GuiButtonTypeCenter = 1,
	GuiButtonTypeRight = 2,
}
pub type ButtonCallback =
	::core::option::Option<unsafe extern "C" fn(result: GuiButtonType, type_: InputType, context: *mut core::ffi::c_void)>;
#[repr(C)]
pub struct Widget {
	_unused: [u8; 0],
}
extern "C" {
	#[doc = " Allocate Widget that holds Widget Elements"]
	#[doc = ""]
	#[doc = " @return     Widget instance"]
	pub fn widget_alloc() -> *mut Widget;
}
extern "C" {
	#[doc = " Free Widget"]
	#[doc = " @note       this function free allocated Widget Elements"]
	#[doc = ""]
	#[doc = " @param      widget  Widget instance"]
	pub fn widget_free(widget: *mut Widget);
}
extern "C" {
	#[doc = " Reset Widget"]
	#[doc = ""]
	#[doc = " @param      widget  Widget instance"]
	pub fn widget_reset(widget: *mut Widget);
}
extern "C" {
	#[doc = " Get Widget view"]
	#[doc = ""]
	#[doc = " @param      widget  Widget instance"]
	#[doc = ""]
	#[doc = " @return     View instance"]
	pub fn widget_get_view(widget: *mut Widget) -> *mut View;
}
extern "C" {
	#[doc = " Add Multi String Element"]
	#[doc = ""]
	#[doc = " @param      widget      Widget instance"]
	#[doc = " @param      x           x coordinate"]
	#[doc = " @param      y           y coordinate"]
	#[doc = " @param      horizontal  Align instance"]
	#[doc = " @param      vertical    Align instance"]
	#[doc = " @param      font        Font instance"]
	#[doc = " @param[in]  text        The text"]
	pub fn widget_add_string_multiline_element(widget: *mut Widget,
	                                           x: u8,
	                                           y: u8,
	                                           horizontal: Align,
	                                           vertical: Align,
	                                           font: Font,
	                                           text: *const core::ffi::c_char);
}
extern "C" {
	#[doc = " Add String Element"]
	#[doc = ""]
	#[doc = " @param      widget      Widget instance"]
	#[doc = " @param      x           x coordinate"]
	#[doc = " @param      y           y coordinate"]
	#[doc = " @param      horizontal  Align instance"]
	#[doc = " @param      vertical    Align instance"]
	#[doc = " @param      font        Font instance"]
	#[doc = " @param[in]  text        The text"]
	pub fn widget_add_string_element(widget: *mut Widget,
	                                 x: u8,
	                                 y: u8,
	                                 horizontal: Align,
	                                 vertical: Align,
	                                 font: Font,
	                                 text: *const core::ffi::c_char);
}
extern "C" {
	#[doc = " Add Text Box Element"]
	#[doc = ""]
	#[doc = " @param      widget           Widget instance"]
	#[doc = " @param      x                x coordinate"]
	#[doc = " @param      y                y coordinate"]
	#[doc = " @param      width            width to fit text"]
	#[doc = " @param      height           height to fit text"]
	#[doc = " @param      horizontal       Align instance"]
	#[doc = " @param      vertical         Align instance"]
	#[doc = " @param[in]  text             Formatted text. The following formats are available:"]
	#[doc = "                               \"\\e#Bold text\\e#\" - bold font is used"]
	#[doc = "                               \"\\e*Monospaced text\\e*\" - monospaced font is used"]
	#[doc = "                               \"\\e#Inversed text\\e#\" - white text on black background"]
	#[doc = " @param      strip_to_dots    Strip text to ... if does not fit to width"]
	pub fn widget_add_text_box_element(widget: *mut Widget,
	                                   x: u8,
	                                   y: u8,
	                                   width: u8,
	                                   height: u8,
	                                   horizontal: Align,
	                                   vertical: Align,
	                                   text: *const core::ffi::c_char,
	                                   strip_to_dots: bool);
}
extern "C" {
	#[doc = " Add Text Scroll Element"]
	#[doc = ""]
	#[doc = " @param      widget           Widget instance"]
	#[doc = " @param      x                x coordinate"]
	#[doc = " @param      y                y coordinate"]
	#[doc = " @param      width            width to fit text"]
	#[doc = " @param      height           height to fit text"]
	#[doc = " @param[in]  text             Formatted text. Default format: align left, Secondary font."]
	#[doc = "                              The following formats are available:"]
	#[doc = "                               \"\\e#Bold text\" - sets bold font before until next '\\n' symbol"]
	#[doc = "                               \"\\ecCenter-aligned text\" - sets center horizontal align until the next '\\n' symbol"]
	#[doc = "                               \"\\erRight-aligned text\" - sets right horizontal align until the next '\\n' symbol"]
	pub fn widget_add_text_scroll_element(widget: *mut Widget, x: u8, y: u8, width: u8, height: u8, text: *const core::ffi::c_char);
}
extern "C" {
	#[doc = " Add Button Element"]
	#[doc = ""]
	#[doc = " @param      widget       Widget instance"]
	#[doc = " @param      button_type  GuiButtonType instance"]
	#[doc = " @param      text         text on allocated button"]
	#[doc = " @param      callback     ButtonCallback instance"]
	#[doc = " @param      context      pointer to context"]
	pub fn widget_add_button_element(widget: *mut Widget,
	                                 button_type: GuiButtonType,
	                                 text: *const core::ffi::c_char,
	                                 callback: ButtonCallback,
	                                 context: *mut core::ffi::c_void);
}
extern "C" {
	#[doc = " Add Icon Element"]
	#[doc = ""]
	#[doc = " @param      widget  Widget instance"]
	#[doc = " @param      x       top left x coordinate"]
	#[doc = " @param      y       top left y coordinate"]
	#[doc = " @param      icon    Icon instance"]
	pub fn widget_add_icon_element(widget: *mut Widget, x: u8, y: u8, icon: *const Icon);
}
extern "C" {
	#[doc = " Add Frame Element"]
	#[doc = ""]
	#[doc = " @param      widget  Widget instance"]
	#[doc = " @param      x       top left x coordinate"]
	#[doc = " @param      y       top left y coordinate"]
	#[doc = " @param      width   frame width"]
	#[doc = " @param      height  frame height"]
	#[doc = " @param      radius  frame radius"]
	pub fn widget_add_frame_element(widget: *mut Widget, x: u8, y: u8, width: u8, height: u8, radius: u8);
}
#[repr(u32)]
#[non_exhaustive]
#[doc = " Scene Manager events type"]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum SceneManagerEventType {
	SceneManagerEventTypeCustom = 0,
	SceneManagerEventTypeBack = 1,
	SceneManagerEventTypeTick = 2,
}
#[doc = " Scene Manager event"]
#[repr(C)]
pub struct SceneManagerEvent {
	pub type_: SceneManagerEventType,
	pub event: u32,
}
#[test]
fn bindgen_test_layout_SceneManagerEvent() {
	assert_eq!(
	           ::core::mem::size_of::<SceneManagerEvent>(),
	           8usize,
	           concat!("Size of: ", stringify!(SceneManagerEvent))
	);
	assert_eq!(
	           ::core::mem::align_of::<SceneManagerEvent>(),
	           4usize,
	           concat!("Alignment of ", stringify!(SceneManagerEvent))
	);
	fn test_field_type() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<SceneManagerEvent>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(SceneManagerEvent), "::", stringify!(type_))
		);
	}
	test_field_type();
	fn test_field_event() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<SceneManagerEvent>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).event) as usize - ptr as usize
		           },
		           4usize,
		           concat!("Offset of field: ", stringify!(SceneManagerEvent), "::", stringify!(event))
		);
	}
	test_field_event();
}
#[doc = " Prototype for Scene on_enter handler"]
pub type AppSceneOnEnterCallback = ::core::option::Option<unsafe extern "C" fn(context: *mut core::ffi::c_void)>;
#[doc = " Prototype for Scene on_event handler"]
pub type AppSceneOnEventCallback =
	::core::option::Option<unsafe extern "C" fn(context: *mut core::ffi::c_void, event: SceneManagerEvent) -> bool>;
#[doc = " Prototype for Scene on_exit handler"]
pub type AppSceneOnExitCallback = ::core::option::Option<unsafe extern "C" fn(context: *mut core::ffi::c_void)>;
#[doc = " Scene Manager configuration structure"]
#[doc = " Contains array of Scene handlers"]
#[repr(C)]
pub struct SceneManagerHandlers {
	pub on_enter_handlers: *const AppSceneOnEnterCallback,
	pub on_event_handlers: *const AppSceneOnEventCallback,
	pub on_exit_handlers: *const AppSceneOnExitCallback,
	pub scene_num: u32,
}
#[test]
fn bindgen_test_layout_SceneManagerHandlers() {
	assert_eq!(
	           ::core::mem::size_of::<SceneManagerHandlers>(),
	           16usize,
	           concat!("Size of: ", stringify!(SceneManagerHandlers))
	);
	assert_eq!(
	           ::core::mem::align_of::<SceneManagerHandlers>(),
	           4usize,
	           concat!("Alignment of ", stringify!(SceneManagerHandlers))
	);
	fn test_field_on_enter_handlers() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<SceneManagerHandlers>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).on_enter_handlers) as usize - ptr as usize
		           },
		           0usize,
		           concat!(
			"Offset of field: ",
			stringify!(SceneManagerHandlers),
			"::",
			stringify!(on_enter_handlers)
		)
		);
	}
	test_field_on_enter_handlers();
	fn test_field_on_event_handlers() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<SceneManagerHandlers>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).on_event_handlers) as usize - ptr as usize
		           },
		           4usize,
		           concat!(
			"Offset of field: ",
			stringify!(SceneManagerHandlers),
			"::",
			stringify!(on_event_handlers)
		)
		);
	}
	test_field_on_event_handlers();
	fn test_field_on_exit_handlers() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<SceneManagerHandlers>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).on_exit_handlers) as usize - ptr as usize
		           },
		           8usize,
		           concat!(
			"Offset of field: ",
			stringify!(SceneManagerHandlers),
			"::",
			stringify!(on_exit_handlers)
		)
		);
	}
	test_field_on_exit_handlers();
	fn test_field_scene_num() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<SceneManagerHandlers>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).scene_num) as usize - ptr as usize
		           },
		           12usize,
		           concat!(
			"Offset of field: ",
			stringify!(SceneManagerHandlers),
			"::",
			stringify!(scene_num)
		)
		);
	}
	test_field_scene_num();
}
#[repr(C)]
pub struct SceneManager {
	_unused: [u8; 0],
}
extern "C" {
	#[doc = " Set Scene state"]
	#[doc = ""]
	#[doc = " @param      scene_manager  SceneManager instance"]
	#[doc = " @param      scene_id       Scene ID"]
	#[doc = " @param      state          Scene new state"]
	pub fn scene_manager_set_scene_state(scene_manager: *mut SceneManager, scene_id: u32, state: u32);
}
extern "C" {
	#[doc = " Get Scene state"]
	#[doc = ""]
	#[doc = " @param      scene_manager  SceneManager instance"]
	#[doc = " @param      scene_id       Scene ID"]
	#[doc = ""]
	#[doc = " @return     Scene state"]
	pub fn scene_manager_get_scene_state(scene_manager: *mut SceneManager, scene_id: u32) -> u32;
}
extern "C" {
	#[doc = " Scene Manager allocation and configuration"]
	#[doc = ""]
	#[doc = " Scene Manager allocates all scenes internally"]
	#[doc = ""]
	#[doc = " @param      app_scene_handlers  SceneManagerHandlers instance"]
	#[doc = " @param      context             context to be set on Scene handlers calls"]
	#[doc = ""]
	#[doc = " @return     SceneManager instance"]
	pub fn scene_manager_alloc(app_scene_handlers: *const SceneManagerHandlers, context: *mut core::ffi::c_void) -> *mut SceneManager;
}
extern "C" {
	#[doc = " Free Scene Manager with allocated Scenes"]
	#[doc = ""]
	#[doc = " @param      scene_manager  SceneManager instance"]
	pub fn scene_manager_free(scene_manager: *mut SceneManager);
}
extern "C" {
	#[doc = " Custom event handler"]
	#[doc = ""]
	#[doc = " Calls Scene event handler with Custom event parameter"]
	#[doc = ""]
	#[doc = " @param      scene_manager  SceneManager instance"]
	#[doc = " @param      custom_event   Custom event code"]
	#[doc = ""]
	#[doc = " @return     true if event was consumed, false otherwise"]
	pub fn scene_manager_handle_custom_event(scene_manager: *mut SceneManager, custom_event: u32) -> bool;
}
extern "C" {
	#[doc = " Back event handler"]
	#[doc = ""]
	#[doc = " Calls Scene event handler with Back event parameter"]
	#[doc = ""]
	#[doc = " @param      scene_manager  SceneManager instance"]
	#[doc = ""]
	#[doc = " @return     true if event was consumed, false otherwise"]
	pub fn scene_manager_handle_back_event(scene_manager: *mut SceneManager) -> bool;
}
extern "C" {
	#[doc = " Tick event handler"]
	#[doc = ""]
	#[doc = " Calls Scene event handler with Tick event parameter"]
	#[doc = ""]
	#[doc = " @param      scene_manager  SceneManager instance"]
	#[doc = " @return     true if event was consumed, false otherwise"]
	pub fn scene_manager_handle_tick_event(scene_manager: *mut SceneManager);
}
extern "C" {
	#[doc = " Add and run next Scene"]
	#[doc = ""]
	#[doc = " @param      scene_manager  SceneManager instance"]
	#[doc = " @param      next_scene_id  next Scene ID"]
	pub fn scene_manager_next_scene(scene_manager: *mut SceneManager, next_scene_id: u32);
}
extern "C" {
	#[doc = " Run previous Scene"]
	#[doc = ""]
	#[doc = " @param      scene_manager  SceneManager instance"]
	#[doc = ""]
	#[doc = " @return     true if previous scene was found, false otherwise"]
	pub fn scene_manager_previous_scene(scene_manager: *mut SceneManager) -> bool;
}
extern "C" {
	#[doc = " Search previous Scene"]
	#[doc = ""]
	#[doc = " @param      scene_manager  SceneManager instance"]
	#[doc = " @param      scene_id       Scene ID"]
	#[doc = ""]
	#[doc = " @return     true if previous scene was found, false otherwise"]
	pub fn scene_manager_has_previous_scene(scene_manager: *mut SceneManager, scene_id: u32) -> bool;
}
extern "C" {
	#[doc = " Search and switch to previous Scene"]
	#[doc = ""]
	#[doc = " @param      scene_manager  SceneManager instance"]
	#[doc = " @param      scene_id       Scene ID"]
	#[doc = ""]
	#[doc = " @return     true if previous scene was found, false otherwise"]
	pub fn scene_manager_search_and_switch_to_previous_scene(scene_manager: *mut SceneManager, scene_id: u32) -> bool;
}
extern "C" {
	#[doc = " Search and switch to previous Scene, multiple choice"]
	#[doc = ""]
	#[doc = " @param      scene_manager    SceneManager instance"]
	#[doc = " @param      scene_ids        Array of scene IDs"]
	#[doc = " @param      scene_ids_size   Array of scene IDs size"]
	#[doc = ""]
	#[doc = " @return     true if one of previous scenes was found, false otherwise"]
	pub fn scene_manager_search_and_switch_to_previous_scene_one_of(scene_manager: *mut SceneManager,
	                                                                scene_ids: *const u32,
	                                                                scene_ids_size: usize)
	                                                                -> bool;
}
extern "C" {
	#[doc = " Clear Scene stack and switch to another Scene"]
	#[doc = ""]
	#[doc = " @param      scene_manager  SceneManager instance"]
	#[doc = " @param      scene_id       Scene ID"]
	#[doc = ""]
	#[doc = " @return     true if previous scene was found, false otherwise"]
	pub fn scene_manager_search_and_switch_to_another_scene(scene_manager: *mut SceneManager, scene_id: u32) -> bool;
}
extern "C" {
	#[doc = " Exit from current scene"]
	#[doc = ""]
	#[doc = " @param      scene_manager  SceneManager instance"]
	pub fn scene_manager_stop(scene_manager: *mut SceneManager);
}
#[repr(u32)]
#[non_exhaustive]
#[doc = " ViewDispatcher view_port placement"]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum ViewDispatcherType {
	#[doc = "< Desktop layer: fullscreen with status bar on top of it. For internal usage."]
	ViewDispatcherTypeDesktop = 0,
	#[doc = "< Window layer: with status bar"]
	ViewDispatcherTypeWindow = 1,
	#[doc = "< Fullscreen layer: without status bar"]
	ViewDispatcherTypeFullscreen = 2,
}
#[repr(C)]
pub struct ViewDispatcher {
	_unused: [u8; 0],
}
#[doc = " Prototype for custom event callback"]
pub type ViewDispatcherCustomEventCallback =
	::core::option::Option<unsafe extern "C" fn(context: *mut core::ffi::c_void, event: u32) -> bool>;
#[doc = " Prototype for navigation event callback"]
pub type ViewDispatcherNavigationEventCallback =
	::core::option::Option<unsafe extern "C" fn(context: *mut core::ffi::c_void) -> bool>;
#[doc = " Prototype for tick event callback"]
pub type ViewDispatcherTickEventCallback = ::core::option::Option<unsafe extern "C" fn(context: *mut core::ffi::c_void)>;
extern "C" {
	#[doc = " Allocate ViewDispatcher instance"]
	#[doc = ""]
	#[doc = " @return     pointer to ViewDispatcher instance"]
	pub fn view_dispatcher_alloc() -> *mut ViewDispatcher;
}
extern "C" {
	#[doc = " Free ViewDispatcher instance"]
	#[doc = ""]
	#[doc = " @param      view_dispatcher  pointer to ViewDispatcher"]
	pub fn view_dispatcher_free(view_dispatcher: *mut ViewDispatcher);
}
extern "C" {
	#[doc = " Enable queue support"]
	#[doc = ""]
	#[doc = " If queue enabled all input and custom events will be dispatched throw"]
	#[doc = " internal queue"]
	#[doc = ""]
	#[doc = " @param      view_dispatcher  ViewDispatcher instance"]
	pub fn view_dispatcher_enable_queue(view_dispatcher: *mut ViewDispatcher);
}
extern "C" {
	#[doc = " Send custom event"]
	#[doc = ""]
	#[doc = " @param      view_dispatcher  ViewDispatcher instance"]
	#[doc = " @param[in]  event            The event"]
	pub fn view_dispatcher_send_custom_event(view_dispatcher: *mut ViewDispatcher, event: u32);
}
extern "C" {
	#[doc = " Set custom event handler"]
	#[doc = ""]
	#[doc = " Called on Custom Event, if it is not consumed by view"]
	#[doc = ""]
	#[doc = " @param      view_dispatcher  ViewDispatcher instance"]
	#[doc = " @param      callback         ViewDispatcherCustomEventCallback instance"]
	pub fn view_dispatcher_set_custom_event_callback(view_dispatcher: *mut ViewDispatcher,
	                                                 callback: ViewDispatcherCustomEventCallback);
}
extern "C" {
	#[doc = " Set navigation event handler"]
	#[doc = ""]
	#[doc = " Called on Input Short Back Event, if it is not consumed by view"]
	#[doc = ""]
	#[doc = " @param      view_dispatcher  ViewDispatcher instance"]
	#[doc = " @param      callback         ViewDispatcherNavigationEventCallback instance"]
	pub fn view_dispatcher_set_navigation_event_callback(view_dispatcher: *mut ViewDispatcher,
	                                                     callback: ViewDispatcherNavigationEventCallback);
}
extern "C" {
	#[doc = " Set tick event handler"]
	#[doc = ""]
	#[doc = " @param      view_dispatcher  ViewDispatcher instance"]
	#[doc = " @param      callback         ViewDispatcherTickEventCallback"]
	#[doc = " @param      tick_period      callback call period"]
	pub fn view_dispatcher_set_tick_event_callback(view_dispatcher: *mut ViewDispatcher,
	                                               callback: ViewDispatcherTickEventCallback,
	                                               tick_period: u32);
}
extern "C" {
	#[doc = " Set event callback context"]
	#[doc = ""]
	#[doc = " @param      view_dispatcher  ViewDispatcher instance"]
	#[doc = " @param      context          pointer to context"]
	pub fn view_dispatcher_set_event_callback_context(view_dispatcher: *mut ViewDispatcher, context: *mut core::ffi::c_void);
}
extern "C" {
	#[doc = " Run ViewDispatcher"]
	#[doc = ""]
	#[doc = " Use only after queue enabled"]
	#[doc = ""]
	#[doc = " @param      view_dispatcher  ViewDispatcher instance"]
	pub fn view_dispatcher_run(view_dispatcher: *mut ViewDispatcher);
}
extern "C" {
	#[doc = " Stop ViewDispatcher"]
	#[doc = ""]
	#[doc = " Use only after queue enabled"]
	#[doc = ""]
	#[doc = " @param      view_dispatcher  ViewDispatcher instance"]
	pub fn view_dispatcher_stop(view_dispatcher: *mut ViewDispatcher);
}
extern "C" {
	#[doc = " Add view to ViewDispatcher"]
	#[doc = ""]
	#[doc = " @param      view_dispatcher  ViewDispatcher instance"]
	#[doc = " @param      view_id          View id to register"]
	#[doc = " @param      view             View instance"]
	pub fn view_dispatcher_add_view(view_dispatcher: *mut ViewDispatcher, view_id: u32, view: *mut View);
}
extern "C" {
	#[doc = " Remove view from ViewDispatcher"]
	#[doc = ""]
	#[doc = " @param      view_dispatcher  ViewDispatcher instance"]
	#[doc = " @param      view_id          View id to remove"]
	pub fn view_dispatcher_remove_view(view_dispatcher: *mut ViewDispatcher, view_id: u32);
}
extern "C" {
	#[doc = " Switch to View"]
	#[doc = ""]
	#[doc = " @param      view_dispatcher  ViewDispatcher instance"]
	#[doc = " @param      view_id          View id to register"]
	#[doc = " @warning    switching may be delayed till input events complementarity"]
	#[doc = "             reached"]
	pub fn view_dispatcher_switch_to_view(view_dispatcher: *mut ViewDispatcher, view_id: u32);
}
extern "C" {
	#[doc = " Send ViewPort of this ViewDispatcher instance to front"]
	#[doc = ""]
	#[doc = " @param      view_dispatcher  ViewDispatcher instance"]
	pub fn view_dispatcher_send_to_front(view_dispatcher: *mut ViewDispatcher);
}
extern "C" {
	#[doc = " Send ViewPort of this ViewDispatcher instance to back"]
	#[doc = ""]
	#[doc = " @param      view_dispatcher  ViewDispatcher instance"]
	pub fn view_dispatcher_send_to_back(view_dispatcher: *mut ViewDispatcher);
}
extern "C" {
	#[doc = " Attach ViewDispatcher to GUI"]
	#[doc = ""]
	#[doc = " @param      view_dispatcher  ViewDispatcher instance"]
	#[doc = " @param      gui              GUI instance to attach to"]
	#[doc = " @param[in]  type             The type"]
	pub fn view_dispatcher_attach_to_gui(view_dispatcher: *mut ViewDispatcher, gui: *mut Gui, type_: ViewDispatcherType);
}
#[repr(C)]
pub struct ViewStack {
	_unused: [u8; 0],
}
extern "C" {
	#[doc = " Allocate and init ViewStack"]
	#[doc = ""]
	#[doc = " @return      ViewStack instance"]
	pub fn view_stack_alloc() -> *mut ViewStack;
}
extern "C" {
	#[doc = " Free ViewStack instance"]
	#[doc = ""]
	#[doc = " @param       view_stack  instance"]
	pub fn view_stack_free(view_stack: *mut ViewStack);
}
extern "C" {
	#[doc = " Get View of ViewStack."]
	#[doc = " Should this View to any view manager such as"]
	#[doc = " ViewDispatcher or ViewHolder."]
	#[doc = ""]
	#[doc = " @param       view_stack  instance"]
	pub fn view_stack_get_view(view_stack: *mut ViewStack) -> *mut View;
}
extern "C" {
	#[doc = " Add View to ViewStack."]
	#[doc = " Adds View on top of ViewStack."]
	#[doc = ""]
	#[doc = " @param       view_stack  instance"]
	#[doc = " @view        view        view to add"]
	pub fn view_stack_add_view(view_stack: *mut ViewStack, view: *mut View);
}
extern "C" {
	#[doc = " Remove any View in ViewStack."]
	#[doc = " If no View to remove found - ignore."]
	#[doc = ""]
	#[doc = " @param       view_stack  instance"]
	#[doc = " @view        view        view to remove"]
	pub fn view_stack_remove_view(view_stack: *mut ViewStack, view: *mut View);
}
#[repr(C)]
pub struct Loader {
	_unused: [u8; 0],
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum LoaderStatus {
	LoaderStatusOk = 0,
	LoaderStatusErrorAppStarted = 1,
	LoaderStatusErrorUnknownApp = 2,
	LoaderStatusErrorInternal = 3,
}
extern "C" {
	#[doc = " Start application"]
	#[doc = " @param name - application name"]
	#[doc = " @param args - application arguments"]
	#[doc = " @retval true on success"]
	pub fn loader_start(instance: *mut Loader, name: *const core::ffi::c_char, args: *const core::ffi::c_char) -> LoaderStatus;
}
extern "C" {
	#[doc = " Lock application start"]
	#[doc = " @retval true on success"]
	pub fn loader_lock(instance: *mut Loader) -> bool;
}
extern "C" {
	#[doc = " Unlock application start"]
	pub fn loader_unlock(instance: *mut Loader);
}
extern "C" {
	#[doc = " Get loader lock status"]
	pub fn loader_is_locked(instance: *mut Loader) -> bool;
}
extern "C" {
	#[doc = " Show primary loader"]
	pub fn loader_show_menu();
}
extern "C" {
	#[doc = " Show primary loader"]
	pub fn loader_update_menu();
}
extern "C" {
	#[doc = " Show primary loader"]
	pub fn loader_get_pubsub(instance: *mut Loader) -> *mut FuriPubSub;
}
#[repr(C)]
pub struct NotificationApp {
	_unused: [u8; 0],
}
#[repr(C)]
pub struct NotificationMessageDataSound {
	pub frequency: core::ffi::c_float,
	pub volume: core::ffi::c_float,
}
#[test]
fn bindgen_test_layout_NotificationMessageDataSound() {
	assert_eq!(
	           ::core::mem::size_of::<NotificationMessageDataSound>(),
	           8usize,
	           concat!("Size of: ", stringify!(NotificationMessageDataSound))
	);
	assert_eq!(
	           ::core::mem::align_of::<NotificationMessageDataSound>(),
	           4usize,
	           concat!("Alignment of ", stringify!(NotificationMessageDataSound))
	);
	fn test_field_frequency() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<NotificationMessageDataSound>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).frequency) as usize - ptr as usize
		           },
		           0usize,
		           concat!(
			"Offset of field: ",
			stringify!(NotificationMessageDataSound),
			"::",
			stringify!(frequency)
		)
		);
	}
	test_field_frequency();
	fn test_field_volume() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<NotificationMessageDataSound>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).volume) as usize - ptr as usize
		           },
		           4usize,
		           concat!(
			"Offset of field: ",
			stringify!(NotificationMessageDataSound),
			"::",
			stringify!(volume)
		)
		);
	}
	test_field_volume();
}
#[repr(C)]
pub struct NotificationMessageDataLed {
	pub value: u8,
}
#[test]
fn bindgen_test_layout_NotificationMessageDataLed() {
	assert_eq!(
	           ::core::mem::size_of::<NotificationMessageDataLed>(),
	           1usize,
	           concat!("Size of: ", stringify!(NotificationMessageDataLed))
	);
	assert_eq!(
	           ::core::mem::align_of::<NotificationMessageDataLed>(),
	           1usize,
	           concat!("Alignment of ", stringify!(NotificationMessageDataLed))
	);
	fn test_field_value() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<NotificationMessageDataLed>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).value) as usize - ptr as usize
		           },
		           0usize,
		           concat!(
			"Offset of field: ",
			stringify!(NotificationMessageDataLed),
			"::",
			stringify!(value)
		)
		);
	}
	test_field_value();
}
#[repr(C)]
pub struct NotificationMessageDataVibro {
	pub on: bool,
}
#[test]
fn bindgen_test_layout_NotificationMessageDataVibro() {
	assert_eq!(
	           ::core::mem::size_of::<NotificationMessageDataVibro>(),
	           1usize,
	           concat!("Size of: ", stringify!(NotificationMessageDataVibro))
	);
	assert_eq!(
	           ::core::mem::align_of::<NotificationMessageDataVibro>(),
	           1usize,
	           concat!("Alignment of ", stringify!(NotificationMessageDataVibro))
	);
	fn test_field_on() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<NotificationMessageDataVibro>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).on) as usize - ptr as usize
		           },
		           0usize,
		           concat!(
			"Offset of field: ",
			stringify!(NotificationMessageDataVibro),
			"::",
			stringify!(on)
		)
		);
	}
	test_field_on();
}
#[repr(C)]
pub struct NotificationMessageDataDelay {
	pub length: u32,
}
#[test]
fn bindgen_test_layout_NotificationMessageDataDelay() {
	assert_eq!(
	           ::core::mem::size_of::<NotificationMessageDataDelay>(),
	           4usize,
	           concat!("Size of: ", stringify!(NotificationMessageDataDelay))
	);
	assert_eq!(
	           ::core::mem::align_of::<NotificationMessageDataDelay>(),
	           4usize,
	           concat!("Alignment of ", stringify!(NotificationMessageDataDelay))
	);
	fn test_field_length() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<NotificationMessageDataDelay>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).length) as usize - ptr as usize
		           },
		           0usize,
		           concat!(
			"Offset of field: ",
			stringify!(NotificationMessageDataDelay),
			"::",
			stringify!(length)
		)
		);
	}
	test_field_length();
}
#[repr(C)]
pub struct NotificationMessageDataForcedSettings {
	pub speaker_volume: core::ffi::c_float,
	pub vibro: bool,
	pub display_brightness: core::ffi::c_float,
}
#[test]
fn bindgen_test_layout_NotificationMessageDataForcedSettings() {
	assert_eq!(
	           ::core::mem::size_of::<NotificationMessageDataForcedSettings>(),
	           12usize,
	           concat!("Size of: ", stringify!(NotificationMessageDataForcedSettings))
	);
	assert_eq!(
	           ::core::mem::align_of::<NotificationMessageDataForcedSettings>(),
	           4usize,
	           concat!("Alignment of ", stringify!(NotificationMessageDataForcedSettings))
	);
	fn test_field_speaker_volume() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<NotificationMessageDataForcedSettings>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).speaker_volume) as usize - ptr as usize
		           },
		           0usize,
		           concat!(
			"Offset of field: ",
			stringify!(NotificationMessageDataForcedSettings),
			"::",
			stringify!(speaker_volume)
		)
		);
	}
	test_field_speaker_volume();
	fn test_field_vibro() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<NotificationMessageDataForcedSettings>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).vibro) as usize - ptr as usize
		           },
		           4usize,
		           concat!(
			"Offset of field: ",
			stringify!(NotificationMessageDataForcedSettings),
			"::",
			stringify!(vibro)
		)
		);
	}
	test_field_vibro();
	fn test_field_display_brightness() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<NotificationMessageDataForcedSettings>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).display_brightness) as usize - ptr as usize
		           },
		           8usize,
		           concat!(
			"Offset of field: ",
			stringify!(NotificationMessageDataForcedSettings),
			"::",
			stringify!(display_brightness)
		)
		);
	}
	test_field_display_brightness();
}
#[repr(C)]
pub struct NotificationMessageDataLedBlink {
	pub on_time: u16,
	pub period: u16,
	pub color: Light,
}
#[test]
fn bindgen_test_layout_NotificationMessageDataLedBlink() {
	assert_eq!(
	           ::core::mem::size_of::<NotificationMessageDataLedBlink>(),
	           8usize,
	           concat!("Size of: ", stringify!(NotificationMessageDataLedBlink))
	);
	assert_eq!(
	           ::core::mem::align_of::<NotificationMessageDataLedBlink>(),
	           4usize,
	           concat!("Alignment of ", stringify!(NotificationMessageDataLedBlink))
	);
	fn test_field_on_time() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<NotificationMessageDataLedBlink>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).on_time) as usize - ptr as usize
		           },
		           0usize,
		           concat!(
			"Offset of field: ",
			stringify!(NotificationMessageDataLedBlink),
			"::",
			stringify!(on_time)
		)
		);
	}
	test_field_on_time();
	fn test_field_period() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<NotificationMessageDataLedBlink>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).period) as usize - ptr as usize
		           },
		           2usize,
		           concat!(
			"Offset of field: ",
			stringify!(NotificationMessageDataLedBlink),
			"::",
			stringify!(period)
		)
		);
	}
	test_field_period();
	fn test_field_color() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<NotificationMessageDataLedBlink>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).color) as usize - ptr as usize
		           },
		           4usize,
		           concat!(
			"Offset of field: ",
			stringify!(NotificationMessageDataLedBlink),
			"::",
			stringify!(color)
		)
		);
	}
	test_field_color();
}
#[repr(C)]
pub struct NotificationMessageData {
	pub sound: __BindgenUnionField<NotificationMessageDataSound>,
	pub led: __BindgenUnionField<NotificationMessageDataLed>,
	pub led_blink: __BindgenUnionField<NotificationMessageDataLedBlink>,
	pub vibro: __BindgenUnionField<NotificationMessageDataVibro>,
	pub delay: __BindgenUnionField<NotificationMessageDataDelay>,
	pub forced_settings: __BindgenUnionField<NotificationMessageDataForcedSettings>,
	pub bindgen_union_field: [u32; 3usize],
}
#[test]
fn bindgen_test_layout_NotificationMessageData() {
	assert_eq!(
	           ::core::mem::size_of::<NotificationMessageData>(),
	           12usize,
	           concat!("Size of: ", stringify!(NotificationMessageData))
	);
	assert_eq!(
	           ::core::mem::align_of::<NotificationMessageData>(),
	           4usize,
	           concat!("Alignment of ", stringify!(NotificationMessageData))
	);
	fn test_field_sound() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<NotificationMessageData>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).sound) as usize - ptr as usize
		           },
		           0usize,
		           concat!(
			"Offset of field: ",
			stringify!(NotificationMessageData),
			"::",
			stringify!(sound)
		)
		);
	}
	test_field_sound();
	fn test_field_led() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<NotificationMessageData>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).led) as usize - ptr as usize
		           },
		           0usize,
		           concat!(
			"Offset of field: ",
			stringify!(NotificationMessageData),
			"::",
			stringify!(led)
		)
		);
	}
	test_field_led();
	fn test_field_led_blink() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<NotificationMessageData>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).led_blink) as usize - ptr as usize
		           },
		           0usize,
		           concat!(
			"Offset of field: ",
			stringify!(NotificationMessageData),
			"::",
			stringify!(led_blink)
		)
		);
	}
	test_field_led_blink();
	fn test_field_vibro() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<NotificationMessageData>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).vibro) as usize - ptr as usize
		           },
		           0usize,
		           concat!(
			"Offset of field: ",
			stringify!(NotificationMessageData),
			"::",
			stringify!(vibro)
		)
		);
	}
	test_field_vibro();
	fn test_field_delay() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<NotificationMessageData>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).delay) as usize - ptr as usize
		           },
		           0usize,
		           concat!(
			"Offset of field: ",
			stringify!(NotificationMessageData),
			"::",
			stringify!(delay)
		)
		);
	}
	test_field_delay();
	fn test_field_forced_settings() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<NotificationMessageData>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).forced_settings) as usize - ptr as usize
		           },
		           0usize,
		           concat!(
			"Offset of field: ",
			stringify!(NotificationMessageData),
			"::",
			stringify!(forced_settings)
		)
		);
	}
	test_field_forced_settings();
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum NotificationMessageType {
	NotificationMessageTypeVibro = 0,
	NotificationMessageTypeSoundOn = 1,
	NotificationMessageTypeSoundOff = 2,
	NotificationMessageTypeLedRed = 3,
	NotificationMessageTypeLedGreen = 4,
	NotificationMessageTypeLedBlue = 5,
	NotificationMessageTypeLedBlinkStart = 6,
	NotificationMessageTypeLedBlinkStop = 7,
	NotificationMessageTypeLedBlinkColor = 8,
	NotificationMessageTypeDelay = 9,
	NotificationMessageTypeLedDisplayBacklight = 10,
	NotificationMessageTypeLedDisplayBacklightEnforceOn = 11,
	NotificationMessageTypeLedDisplayBacklightEnforceAuto = 12,
	NotificationMessageTypeDoNotReset = 13,
	NotificationMessageTypeForceSpeakerVolumeSetting = 14,
	NotificationMessageTypeForceVibroSetting = 15,
	NotificationMessageTypeForceDisplayBrightnessSetting = 16,
	NotificationMessageTypeLedBrightnessSettingApply = 17,
}
#[repr(C)]
pub struct NotificationMessage {
	pub type_: NotificationMessageType,
	pub data: NotificationMessageData,
}
#[test]
fn bindgen_test_layout_NotificationMessage() {
	assert_eq!(
	           ::core::mem::size_of::<NotificationMessage>(),
	           16usize,
	           concat!("Size of: ", stringify!(NotificationMessage))
	);
	assert_eq!(
	           ::core::mem::align_of::<NotificationMessage>(),
	           4usize,
	           concat!("Alignment of ", stringify!(NotificationMessage))
	);
	fn test_field_type() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<NotificationMessage>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(NotificationMessage), "::", stringify!(type_))
		);
	}
	test_field_type();
	fn test_field_data() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<NotificationMessage>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).data) as usize - ptr as usize
		           },
		           4usize,
		           concat!("Offset of field: ", stringify!(NotificationMessage), "::", stringify!(data))
		);
	}
	test_field_data();
}
pub type NotificationSequence = [*const NotificationMessage; 0usize];
extern "C" {
	pub fn notification_message(app: *mut NotificationApp, sequence: *const NotificationSequence);
}
extern "C" {
	pub fn notification_message_block(app: *mut NotificationApp, sequence: *const NotificationSequence);
}
extern "C" {
	#[doc = " @brief Send internal (apply to permanent layer) notification message. Think twice before use."]
	#[doc = ""]
	#[doc = " @param app notification record content"]
	#[doc = " @param sequence notification sequence"]
	pub fn notification_internal_message(app: *mut NotificationApp, sequence: *const NotificationSequence);
}
extern "C" {
	#[doc = " @brief Send internal (apply to permanent layer) notification message and wait for notification end. Think twice before use."]
	#[doc = ""]
	#[doc = " @param app notification record content"]
	#[doc = " @param sequence notification sequence"]
	pub fn notification_internal_message_block(app: *mut NotificationApp, sequence: *const NotificationSequence);
}
extern "C" {
	pub static message_click: NotificationMessage;
}
extern "C" {
	pub static message_note_c0: NotificationMessage;
}
extern "C" {
	pub static message_note_cs0: NotificationMessage;
}
extern "C" {
	pub static message_note_d0: NotificationMessage;
}
extern "C" {
	pub static message_note_ds0: NotificationMessage;
}
extern "C" {
	pub static message_note_e0: NotificationMessage;
}
extern "C" {
	pub static message_note_f0: NotificationMessage;
}
extern "C" {
	pub static message_note_fs0: NotificationMessage;
}
extern "C" {
	pub static message_note_g0: NotificationMessage;
}
extern "C" {
	pub static message_note_gs0: NotificationMessage;
}
extern "C" {
	pub static message_note_a0: NotificationMessage;
}
extern "C" {
	pub static message_note_as0: NotificationMessage;
}
extern "C" {
	pub static message_note_b0: NotificationMessage;
}
extern "C" {
	pub static message_note_c1: NotificationMessage;
}
extern "C" {
	pub static message_note_cs1: NotificationMessage;
}
extern "C" {
	pub static message_note_d1: NotificationMessage;
}
extern "C" {
	pub static message_note_ds1: NotificationMessage;
}
extern "C" {
	pub static message_note_e1: NotificationMessage;
}
extern "C" {
	pub static message_note_f1: NotificationMessage;
}
extern "C" {
	pub static message_note_fs1: NotificationMessage;
}
extern "C" {
	pub static message_note_g1: NotificationMessage;
}
extern "C" {
	pub static message_note_gs1: NotificationMessage;
}
extern "C" {
	pub static message_note_a1: NotificationMessage;
}
extern "C" {
	pub static message_note_as1: NotificationMessage;
}
extern "C" {
	pub static message_note_b1: NotificationMessage;
}
extern "C" {
	pub static message_note_c2: NotificationMessage;
}
extern "C" {
	pub static message_note_cs2: NotificationMessage;
}
extern "C" {
	pub static message_note_d2: NotificationMessage;
}
extern "C" {
	pub static message_note_ds2: NotificationMessage;
}
extern "C" {
	pub static message_note_e2: NotificationMessage;
}
extern "C" {
	pub static message_note_f2: NotificationMessage;
}
extern "C" {
	pub static message_note_fs2: NotificationMessage;
}
extern "C" {
	pub static message_note_g2: NotificationMessage;
}
extern "C" {
	pub static message_note_gs2: NotificationMessage;
}
extern "C" {
	pub static message_note_a2: NotificationMessage;
}
extern "C" {
	pub static message_note_as2: NotificationMessage;
}
extern "C" {
	pub static message_note_b2: NotificationMessage;
}
extern "C" {
	pub static message_note_c3: NotificationMessage;
}
extern "C" {
	pub static message_note_cs3: NotificationMessage;
}
extern "C" {
	pub static message_note_d3: NotificationMessage;
}
extern "C" {
	pub static message_note_ds3: NotificationMessage;
}
extern "C" {
	pub static message_note_e3: NotificationMessage;
}
extern "C" {
	pub static message_note_f3: NotificationMessage;
}
extern "C" {
	pub static message_note_fs3: NotificationMessage;
}
extern "C" {
	pub static message_note_g3: NotificationMessage;
}
extern "C" {
	pub static message_note_gs3: NotificationMessage;
}
extern "C" {
	pub static message_note_a3: NotificationMessage;
}
extern "C" {
	pub static message_note_as3: NotificationMessage;
}
extern "C" {
	pub static message_note_b3: NotificationMessage;
}
extern "C" {
	pub static message_note_c4: NotificationMessage;
}
extern "C" {
	pub static message_note_cs4: NotificationMessage;
}
extern "C" {
	pub static message_note_d4: NotificationMessage;
}
extern "C" {
	pub static message_note_ds4: NotificationMessage;
}
extern "C" {
	pub static message_note_e4: NotificationMessage;
}
extern "C" {
	pub static message_note_f4: NotificationMessage;
}
extern "C" {
	pub static message_note_fs4: NotificationMessage;
}
extern "C" {
	pub static message_note_g4: NotificationMessage;
}
extern "C" {
	pub static message_note_gs4: NotificationMessage;
}
extern "C" {
	pub static message_note_a4: NotificationMessage;
}
extern "C" {
	pub static message_note_as4: NotificationMessage;
}
extern "C" {
	pub static message_note_b4: NotificationMessage;
}
extern "C" {
	pub static message_note_c5: NotificationMessage;
}
extern "C" {
	pub static message_note_cs5: NotificationMessage;
}
extern "C" {
	pub static message_note_d5: NotificationMessage;
}
extern "C" {
	pub static message_note_ds5: NotificationMessage;
}
extern "C" {
	pub static message_note_e5: NotificationMessage;
}
extern "C" {
	pub static message_note_f5: NotificationMessage;
}
extern "C" {
	pub static message_note_fs5: NotificationMessage;
}
extern "C" {
	pub static message_note_g5: NotificationMessage;
}
extern "C" {
	pub static message_note_gs5: NotificationMessage;
}
extern "C" {
	pub static message_note_a5: NotificationMessage;
}
extern "C" {
	pub static message_note_as5: NotificationMessage;
}
extern "C" {
	pub static message_note_b5: NotificationMessage;
}
extern "C" {
	pub static message_note_c6: NotificationMessage;
}
extern "C" {
	pub static message_note_cs6: NotificationMessage;
}
extern "C" {
	pub static message_note_d6: NotificationMessage;
}
extern "C" {
	pub static message_note_ds6: NotificationMessage;
}
extern "C" {
	pub static message_note_e6: NotificationMessage;
}
extern "C" {
	pub static message_note_f6: NotificationMessage;
}
extern "C" {
	pub static message_note_fs6: NotificationMessage;
}
extern "C" {
	pub static message_note_g6: NotificationMessage;
}
extern "C" {
	pub static message_note_gs6: NotificationMessage;
}
extern "C" {
	pub static message_note_a6: NotificationMessage;
}
extern "C" {
	pub static message_note_as6: NotificationMessage;
}
extern "C" {
	pub static message_note_b6: NotificationMessage;
}
extern "C" {
	pub static message_note_c7: NotificationMessage;
}
extern "C" {
	pub static message_note_cs7: NotificationMessage;
}
extern "C" {
	pub static message_note_d7: NotificationMessage;
}
extern "C" {
	pub static message_note_ds7: NotificationMessage;
}
extern "C" {
	pub static message_note_e7: NotificationMessage;
}
extern "C" {
	pub static message_note_f7: NotificationMessage;
}
extern "C" {
	pub static message_note_fs7: NotificationMessage;
}
extern "C" {
	pub static message_note_g7: NotificationMessage;
}
extern "C" {
	pub static message_note_gs7: NotificationMessage;
}
extern "C" {
	pub static message_note_a7: NotificationMessage;
}
extern "C" {
	pub static message_note_as7: NotificationMessage;
}
extern "C" {
	pub static message_note_b7: NotificationMessage;
}
extern "C" {
	pub static message_note_c8: NotificationMessage;
}
extern "C" {
	pub static message_note_cs8: NotificationMessage;
}
extern "C" {
	pub static message_note_d8: NotificationMessage;
}
extern "C" {
	pub static message_note_ds8: NotificationMessage;
}
extern "C" {
	pub static message_note_e8: NotificationMessage;
}
extern "C" {
	pub static message_note_f8: NotificationMessage;
}
extern "C" {
	pub static message_note_fs8: NotificationMessage;
}
extern "C" {
	pub static message_note_g8: NotificationMessage;
}
extern "C" {
	pub static message_note_gs8: NotificationMessage;
}
extern "C" {
	pub static message_note_a8: NotificationMessage;
}
extern "C" {
	pub static message_note_as8: NotificationMessage;
}
extern "C" {
	pub static message_note_b8: NotificationMessage;
}
extern "C" {
	#[doc = " Messages"]
	pub static message_display_backlight_on: NotificationMessage;
}
extern "C" {
	pub static message_display_backlight_off: NotificationMessage;
}
extern "C" {
	pub static message_display_backlight_enforce_on: NotificationMessage;
}
extern "C" {
	pub static message_display_backlight_enforce_auto: NotificationMessage;
}
extern "C" {
	pub static message_red_255: NotificationMessage;
}
extern "C" {
	pub static message_green_255: NotificationMessage;
}
extern "C" {
	pub static message_blue_255: NotificationMessage;
}
extern "C" {
	pub static message_red_0: NotificationMessage;
}
extern "C" {
	pub static message_green_0: NotificationMessage;
}
extern "C" {
	pub static message_blue_0: NotificationMessage;
}
extern "C" {
	pub static message_blink_start_10: NotificationMessage;
}
extern "C" {
	pub static message_blink_start_100: NotificationMessage;
}
extern "C" {
	pub static message_blink_stop: NotificationMessage;
}
extern "C" {
	pub static message_blink_set_color_red: NotificationMessage;
}
extern "C" {
	pub static message_blink_set_color_green: NotificationMessage;
}
extern "C" {
	pub static message_blink_set_color_blue: NotificationMessage;
}
extern "C" {
	pub static message_blink_set_color_cyan: NotificationMessage;
}
extern "C" {
	pub static message_blink_set_color_magenta: NotificationMessage;
}
extern "C" {
	pub static message_blink_set_color_yellow: NotificationMessage;
}
extern "C" {
	pub static message_blink_set_color_white: NotificationMessage;
}
extern "C" {
	pub static message_delay_1: NotificationMessage;
}
extern "C" {
	pub static message_delay_10: NotificationMessage;
}
extern "C" {
	pub static message_delay_25: NotificationMessage;
}
extern "C" {
	pub static message_delay_50: NotificationMessage;
}
extern "C" {
	pub static message_delay_100: NotificationMessage;
}
extern "C" {
	pub static message_delay_250: NotificationMessage;
}
extern "C" {
	pub static message_delay_500: NotificationMessage;
}
extern "C" {
	pub static message_delay_1000: NotificationMessage;
}
extern "C" {
	pub static message_sound_off: NotificationMessage;
}
extern "C" {
	pub static message_vibro_on: NotificationMessage;
}
extern "C" {
	pub static message_vibro_off: NotificationMessage;
}
extern "C" {
	pub static message_do_not_reset: NotificationMessage;
}
extern "C" {
	pub static message_force_speaker_volume_setting_1f: NotificationMessage;
}
extern "C" {
	pub static message_force_vibro_setting_on: NotificationMessage;
}
extern "C" {
	pub static message_force_vibro_setting_off: NotificationMessage;
}
extern "C" {
	pub static message_force_display_brightness_setting_1f: NotificationMessage;
}
extern "C" {
	#[doc = " Message sequences"]
	pub static sequence_reset_red: NotificationSequence;
}
extern "C" {
	pub static sequence_reset_green: NotificationSequence;
}
extern "C" {
	pub static sequence_reset_blue: NotificationSequence;
}
extern "C" {
	pub static sequence_reset_rgb: NotificationSequence;
}
extern "C" {
	pub static sequence_reset_display: NotificationSequence;
}
extern "C" {
	pub static sequence_reset_sound: NotificationSequence;
}
extern "C" {
	pub static sequence_reset_vibro: NotificationSequence;
}
extern "C" {
	pub static sequence_set_vibro_on: NotificationSequence;
}
extern "C" {
	#[doc = " Display: backlight wakeup"]
	pub static sequence_display_backlight_on: NotificationSequence;
}
extern "C" {
	#[doc = " Display: backlight force off"]
	pub static sequence_display_backlight_off: NotificationSequence;
}
extern "C" {
	#[doc = " Display: backlight force off after a delay of 1000ms"]
	pub static sequence_display_backlight_off_delay_1000: NotificationSequence;
}
extern "C" {
	#[doc = " Display: backlight always on lock"]
	pub static sequence_display_backlight_enforce_on: NotificationSequence;
}
extern "C" {
	#[doc = " Display: backlight always on unlock"]
	pub static sequence_display_backlight_enforce_auto: NotificationSequence;
}
extern "C" {
	pub static sequence_charging: NotificationSequence;
}
extern "C" {
	pub static sequence_charged: NotificationSequence;
}
extern "C" {
	pub static sequence_not_charging: NotificationSequence;
}
extern "C" {
	pub static sequence_set_only_red_255: NotificationSequence;
}
extern "C" {
	pub static sequence_set_only_green_255: NotificationSequence;
}
extern "C" {
	pub static sequence_set_only_blue_255: NotificationSequence;
}
extern "C" {
	pub static sequence_set_red_255: NotificationSequence;
}
extern "C" {
	pub static sequence_set_green_255: NotificationSequence;
}
extern "C" {
	pub static sequence_set_blue_255: NotificationSequence;
}
extern "C" {
	pub static sequence_solid_yellow: NotificationSequence;
}
extern "C" {
	pub static sequence_blink_blue_10: NotificationSequence;
}
extern "C" {
	pub static sequence_blink_red_10: NotificationSequence;
}
extern "C" {
	pub static sequence_blink_green_10: NotificationSequence;
}
extern "C" {
	pub static sequence_blink_yellow_10: NotificationSequence;
}
extern "C" {
	pub static sequence_blink_cyan_10: NotificationSequence;
}
extern "C" {
	pub static sequence_blink_magenta_10: NotificationSequence;
}
extern "C" {
	pub static sequence_blink_red_100: NotificationSequence;
}
extern "C" {
	pub static sequence_blink_green_100: NotificationSequence;
}
extern "C" {
	pub static sequence_blink_blue_100: NotificationSequence;
}
extern "C" {
	pub static sequence_blink_yellow_100: NotificationSequence;
}
extern "C" {
	pub static sequence_blink_cyan_100: NotificationSequence;
}
extern "C" {
	pub static sequence_blink_magenta_100: NotificationSequence;
}
extern "C" {
	pub static sequence_blink_white_100: NotificationSequence;
}
extern "C" {
	pub static sequence_blink_start_blue: NotificationSequence;
}
extern "C" {
	pub static sequence_blink_start_red: NotificationSequence;
}
extern "C" {
	pub static sequence_blink_start_green: NotificationSequence;
}
extern "C" {
	pub static sequence_blink_start_yellow: NotificationSequence;
}
extern "C" {
	pub static sequence_blink_start_cyan: NotificationSequence;
}
extern "C" {
	pub static sequence_blink_start_magenta: NotificationSequence;
}
extern "C" {
	pub static sequence_blink_stop: NotificationSequence;
}
extern "C" {
	pub static sequence_single_vibro: NotificationSequence;
}
extern "C" {
	pub static sequence_double_vibro: NotificationSequence;
}
extern "C" {
	pub static sequence_success: NotificationSequence;
}
extern "C" {
	pub static sequence_error: NotificationSequence;
}
extern "C" {
	pub static sequence_audiovisual_alert: NotificationSequence;
}
#[repr(C)]
pub struct Power {
	_unused: [u8; 0],
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum PowerBootMode {
	PowerBootModeNormal = 0,
	PowerBootModeDfu = 1,
	PowerBootModeUpdateStart = 2,
}
#[repr(C)]
pub struct PowerInfo {
	pub gauge_is_ok: bool,
	pub is_charging: bool,
	pub current_charger: core::ffi::c_float,
	pub current_gauge: core::ffi::c_float,
	pub voltage_charger: core::ffi::c_float,
	pub voltage_gauge: core::ffi::c_float,
	pub voltage_vbus: core::ffi::c_float,
	pub capacity_remaining: u32,
	pub capacity_full: u32,
	pub temperature_charger: core::ffi::c_float,
	pub temperature_gauge: core::ffi::c_float,
	pub charge: u8,
	pub health: u8,
}
#[test]
fn bindgen_test_layout_PowerInfo() {
	assert_eq!(
	           ::core::mem::size_of::<PowerInfo>(),
	           44usize,
	           concat!("Size of: ", stringify!(PowerInfo))
	);
	assert_eq!(
	           ::core::mem::align_of::<PowerInfo>(),
	           4usize,
	           concat!("Alignment of ", stringify!(PowerInfo))
	);
	fn test_field_gauge_is_ok() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<PowerInfo>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).gauge_is_ok) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(PowerInfo), "::", stringify!(gauge_is_ok))
		);
	}
	test_field_gauge_is_ok();
	fn test_field_is_charging() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<PowerInfo>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).is_charging) as usize - ptr as usize
		           },
		           1usize,
		           concat!("Offset of field: ", stringify!(PowerInfo), "::", stringify!(is_charging))
		);
	}
	test_field_is_charging();
	fn test_field_current_charger() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<PowerInfo>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).current_charger) as usize - ptr as usize
		           },
		           4usize,
		           concat!("Offset of field: ", stringify!(PowerInfo), "::", stringify!(current_charger))
		);
	}
	test_field_current_charger();
	fn test_field_current_gauge() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<PowerInfo>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).current_gauge) as usize - ptr as usize
		           },
		           8usize,
		           concat!("Offset of field: ", stringify!(PowerInfo), "::", stringify!(current_gauge))
		);
	}
	test_field_current_gauge();
	fn test_field_voltage_charger() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<PowerInfo>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).voltage_charger) as usize - ptr as usize
		           },
		           12usize,
		           concat!("Offset of field: ", stringify!(PowerInfo), "::", stringify!(voltage_charger))
		);
	}
	test_field_voltage_charger();
	fn test_field_voltage_gauge() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<PowerInfo>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).voltage_gauge) as usize - ptr as usize
		           },
		           16usize,
		           concat!("Offset of field: ", stringify!(PowerInfo), "::", stringify!(voltage_gauge))
		);
	}
	test_field_voltage_gauge();
	fn test_field_voltage_vbus() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<PowerInfo>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).voltage_vbus) as usize - ptr as usize
		           },
		           20usize,
		           concat!("Offset of field: ", stringify!(PowerInfo), "::", stringify!(voltage_vbus))
		);
	}
	test_field_voltage_vbus();
	fn test_field_capacity_remaining() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<PowerInfo>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).capacity_remaining) as usize - ptr as usize
		           },
		           24usize,
		           concat!(
			"Offset of field: ",
			stringify!(PowerInfo),
			"::",
			stringify!(capacity_remaining)
		)
		);
	}
	test_field_capacity_remaining();
	fn test_field_capacity_full() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<PowerInfo>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).capacity_full) as usize - ptr as usize
		           },
		           28usize,
		           concat!("Offset of field: ", stringify!(PowerInfo), "::", stringify!(capacity_full))
		);
	}
	test_field_capacity_full();
	fn test_field_temperature_charger() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<PowerInfo>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).temperature_charger) as usize - ptr as usize
		           },
		           32usize,
		           concat!(
			"Offset of field: ",
			stringify!(PowerInfo),
			"::",
			stringify!(temperature_charger)
		)
		);
	}
	test_field_temperature_charger();
	fn test_field_temperature_gauge() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<PowerInfo>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).temperature_gauge) as usize - ptr as usize
		           },
		           36usize,
		           concat!(
			"Offset of field: ",
			stringify!(PowerInfo),
			"::",
			stringify!(temperature_gauge)
		)
		);
	}
	test_field_temperature_gauge();
	fn test_field_charge() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<PowerInfo>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).charge) as usize - ptr as usize
		           },
		           40usize,
		           concat!("Offset of field: ", stringify!(PowerInfo), "::", stringify!(charge))
		);
	}
	test_field_charge();
	fn test_field_health() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<PowerInfo>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).health) as usize - ptr as usize
		           },
		           41usize,
		           concat!("Offset of field: ", stringify!(PowerInfo), "::", stringify!(health))
		);
	}
	test_field_health();
}
extern "C" {
	#[doc = " Power off device"]
	pub fn power_off(power: *mut Power);
}
extern "C" {
	#[doc = " Reboot device"]
	#[doc = ""]
	#[doc = " @param mode      PowerBootMode"]
	pub fn power_reboot(mode: PowerBootMode);
}
extern "C" {
	#[doc = " Get power info"]
	#[doc = ""]
	#[doc = " @param power     Power instance"]
	#[doc = " @param info      PowerInfo instance"]
	pub fn power_get_info(power: *mut Power, info: *mut PowerInfo);
}
extern "C" {
	#[doc = " Get power event pubsub handler"]
	#[doc = ""]
	#[doc = " @param power     Power instance"]
	#[doc = ""]
	#[doc = " @return          FuriPubSub instance"]
	pub fn power_get_pubsub(power: *mut Power) -> *mut FuriPubSub;
}
extern "C" {
	#[doc = " Check battery health"]
	#[doc = ""]
	#[doc = " @return          true if battery is healthy"]
	pub fn power_is_battery_healthy(power: *mut Power) -> bool;
}
extern "C" {
	#[doc = " Enable or disable battery low level notification mesage"]
	#[doc = ""]
	#[doc = " @param power     Power instance"]
	#[doc = " @param enable    true - enable, false - disable"]
	pub fn power_enable_low_battery_level_notification(power: *mut Power, enable: bool);
}
#[repr(C)]
pub struct Rpc {
	_unused: [u8; 0],
}
#[repr(C)]
pub struct RpcSession {
	_unused: [u8; 0],
}
#[doc = " Callback to send to client any data (e.g. response to command)"]
pub type RpcSendBytesCallback =
	::core::option::Option<unsafe extern "C" fn(context: *mut core::ffi::c_void, bytes: *mut u8, bytes_len: usize)>;
#[doc = " Callback to notify client that buffer is empty"]
pub type RpcBufferIsEmptyCallback = ::core::option::Option<unsafe extern "C" fn(context: *mut core::ffi::c_void)>;
#[doc = " Callback to notify transport layer that close_session command"]
#[doc = " is received. Any other actions lays on transport layer."]
#[doc = " No destruction or session close preformed."]
pub type RpcSessionClosedCallback = ::core::option::Option<unsafe extern "C" fn(context: *mut core::ffi::c_void)>;
#[doc = " Callback to notify transport layer that session was closed"]
#[doc = " and all operations were finished"]
pub type RpcSessionTerminatedCallback = ::core::option::Option<unsafe extern "C" fn(context: *mut core::ffi::c_void)>;
extern "C" {
	#[doc = " Open RPC session"]
	#[doc = ""]
	#[doc = " USAGE:"]
	#[doc = " 1) rpc_session_open();"]
	#[doc = " 2) rpc_session_set_context();"]
	#[doc = " 3) rpc_session_set_send_bytes_callback();"]
	#[doc = " 4) rpc_session_set_close_callback();"]
	#[doc = " 5) while(1) {"]
	#[doc = "      rpc_session_feed();"]
	#[doc = "    }"]
	#[doc = " 6) rpc_session_close();"]
	#[doc = ""]
	#[doc = ""]
	#[doc = " @param   rpc     instance"]
	#[doc = " @return          pointer to RpcSession descriptor, or"]
	#[doc = "                  NULL if RPC is busy and can't open session now"]
	pub fn rpc_session_open(rpc: *mut Rpc) -> *mut RpcSession;
}
extern "C" {
	#[doc = " Close RPC session"]
	#[doc = " It is guaranteed that no callbacks will be called"]
	#[doc = " as soon as session is closed. So no need in setting"]
	#[doc = " callbacks to NULL after session close."]
	#[doc = ""]
	#[doc = " @param   session     pointer to RpcSession descriptor"]
	pub fn rpc_session_close(session: *mut RpcSession);
}
extern "C" {
	#[doc = " Set session context for callbacks to pass"]
	#[doc = ""]
	#[doc = " @param   session     pointer to RpcSession descriptor"]
	#[doc = " @param   context     context to pass to callbacks"]
	pub fn rpc_session_set_context(session: *mut RpcSession, context: *mut core::ffi::c_void);
}
extern "C" {
	#[doc = " Set callback to send bytes to client"]
	#[doc = "  WARN: It's forbidden to call RPC API within RpcSendBytesCallback"]
	#[doc = ""]
	#[doc = " @param   session     pointer to RpcSession descriptor"]
	#[doc = " @param   callback    callback to send bytes to client (can be NULL)"]
	pub fn rpc_session_set_send_bytes_callback(session: *mut RpcSession, callback: RpcSendBytesCallback);
}
extern "C" {
	#[doc = " Set callback to notify that buffer is empty"]
	#[doc = ""]
	#[doc = " @param   session     pointer to RpcSession descriptor"]
	#[doc = " @param   callback    callback to notify client that buffer is empty (can be NULL)"]
	pub fn rpc_session_set_buffer_is_empty_callback(session: *mut RpcSession, callback: RpcBufferIsEmptyCallback);
}
extern "C" {
	#[doc = " Set callback to be called when RPC command to close session is received"]
	#[doc = "  WARN: It's forbidden to call RPC API within RpcSessionClosedCallback"]
	#[doc = ""]
	#[doc = " @param   session     pointer to RpcSession descriptor"]
	#[doc = " @param   callback    callback to inform about RPC close session command (can be NULL)"]
	pub fn rpc_session_set_close_callback(session: *mut RpcSession, callback: RpcSessionClosedCallback);
}
extern "C" {
	#[doc = " Set callback to be called when RPC session is closed"]
	#[doc = ""]
	#[doc = " @param   session     pointer to RpcSession descriptor"]
	#[doc = " @param   callback    callback to inform about RPC session state"]
	pub fn rpc_session_set_terminated_callback(session: *mut RpcSession, callback: RpcSessionTerminatedCallback);
}
extern "C" {
	#[doc = " Give bytes to RPC service to decode them and perform command"]
	#[doc = ""]
	#[doc = " @param   session     pointer to RpcSession descriptor"]
	#[doc = " @param   buffer      buffer to provide to RPC service"]
	#[doc = " @param   size        size of buffer"]
	#[doc = " @param   timeout     max timeout to wait till all buffer will be consumed"]
	#[doc = ""]
	#[doc = " @return              actually consumed bytes"]
	pub fn rpc_session_feed(session: *mut RpcSession, buffer: *mut u8, size: usize, timeout: TickType_t) -> usize;
}
extern "C" {
	#[doc = " Get available size of RPC buffer"]
	#[doc = ""]
	#[doc = " @param   session     pointer to RpcSession descriptor"]
	#[doc = ""]
	#[doc = " @return              bytes available in buffer"]
	pub fn rpc_session_get_available_size(session: *mut RpcSession) -> usize;
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum RpcAppSystemEvent {
	RpcAppEventSessionClose = 0,
	RpcAppEventAppExit = 1,
	RpcAppEventLoadFile = 2,
	RpcAppEventButtonPress = 3,
	RpcAppEventButtonRelease = 4,
}
pub type RpcAppSystemCallback =
	::core::option::Option<unsafe extern "C" fn(event: RpcAppSystemEvent, context: *mut core::ffi::c_void)>;
#[repr(C)]
pub struct RpcAppSystem {
	_unused: [u8; 0],
}
extern "C" {
	pub fn rpc_system_app_set_callback(rpc_app: *mut RpcAppSystem, callback: RpcAppSystemCallback, ctx: *mut core::ffi::c_void);
}
extern "C" {
	pub fn rpc_system_app_send_started(rpc_app: *mut RpcAppSystem);
}
extern "C" {
	pub fn rpc_system_app_send_exited(rpc_app: *mut RpcAppSystem);
}
extern "C" {
	pub fn rpc_system_app_get_data(rpc_app: *mut RpcAppSystem) -> *const core::ffi::c_char;
}
extern "C" {
	pub fn rpc_system_app_confirm(rpc_app: *mut RpcAppSystem, event: RpcAppSystemEvent, result: bool);
}
#[repr(u32)]
#[non_exhaustive]
#[doc = " Access mode flags"]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum FS_AccessMode {
	#[doc = "< Read access"]
	FSAM_READ = 1,
	#[doc = "< Write access"]
	FSAM_WRITE = 2,
	#[doc = "< Read and write access"]
	FSAM_READ_WRITE = 3,
}
#[repr(u32)]
#[non_exhaustive]
#[doc = " Open mode flags"]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum FS_OpenMode {
	#[doc = "< Open file, fail if file doesn't exist"]
	FSOM_OPEN_EXISTING = 1,
	#[doc = "< Open file. Create new file if not exist"]
	FSOM_OPEN_ALWAYS = 2,
	#[doc = "< Open file. Create new file if not exist. Set R/W pointer to EOF"]
	FSOM_OPEN_APPEND = 4,
	#[doc = "< Creates a new file. Fails if the file is exist"]
	FSOM_CREATE_NEW = 8,
	#[doc = "< Creates a new file. If file exist, truncate to zero size"]
	FSOM_CREATE_ALWAYS = 16,
}
#[repr(u32)]
#[non_exhaustive]
#[doc = " API errors enumeration"]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum FS_Error {
	#[doc = "< No error"]
	FSE_OK = 0,
	#[doc = "< FS not ready"]
	FSE_NOT_READY = 1,
	#[doc = "< File/Dir alrady exist"]
	FSE_EXIST = 2,
	#[doc = "< File/Dir does not exist"]
	FSE_NOT_EXIST = 3,
	#[doc = "< Invalid API parameter"]
	FSE_INVALID_PARAMETER = 4,
	#[doc = "< Access denied"]
	FSE_DENIED = 5,
	#[doc = "< Invalid name/path"]
	FSE_INVALID_NAME = 6,
	#[doc = "< Internal error"]
	FSE_INTERNAL = 7,
	#[doc = "< Functon not implemented"]
	FSE_NOT_IMPLEMENTED = 8,
	#[doc = "< File/Dir already opened"]
	FSE_ALREADY_OPEN = 9,
}
#[repr(C)]
pub struct File {
	_unused: [u8; 0],
}
#[doc = "  Structure that hold file info"]
#[repr(C)]
pub struct FileInfo {
	#[doc = "< flags from FS_Flags enum"]
	pub flags: u8,
	#[doc = "< file size"]
	pub size: u64,
}
#[test]
fn bindgen_test_layout_FileInfo() {
	assert_eq!(
	           ::core::mem::size_of::<FileInfo>(),
	           16usize,
	           concat!("Size of: ", stringify!(FileInfo))
	);
	assert_eq!(
	           ::core::mem::align_of::<FileInfo>(),
	           8usize,
	           concat!("Alignment of ", stringify!(FileInfo))
	);
	fn test_field_flags() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<FileInfo>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(FileInfo), "::", stringify!(flags))
		);
	}
	test_field_flags();
	fn test_field_size() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<FileInfo>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).size) as usize - ptr as usize
		           },
		           8usize,
		           concat!("Offset of field: ", stringify!(FileInfo), "::", stringify!(size))
		);
	}
	test_field_size();
}
extern "C" {
	#[doc = " Gets the error text from FS_Error"]
	#[doc = " @param error_id error id"]
	#[doc = " @return const char* error text"]
	pub fn filesystem_api_error_get_desc(error_id: FS_Error) -> *const core::ffi::c_char;
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum SDFsType {
	FST_UNKNOWN = 0,
	FST_FAT12 = 1,
	FST_FAT16 = 2,
	FST_FAT32 = 3,
	FST_EXFAT = 4,
}
#[repr(C)]
pub struct SDInfo {
	pub fs_type: SDFsType,
	pub kb_total: u32,
	pub kb_free: u32,
	pub cluster_size: u16,
	pub sector_size: u16,
	pub label: [core::ffi::c_char; 34usize],
	pub error: FS_Error,
}
#[test]
fn bindgen_test_layout_SDInfo() {
	assert_eq!(
	           ::core::mem::size_of::<SDInfo>(),
	           56usize,
	           concat!("Size of: ", stringify!(SDInfo))
	);
	assert_eq!(
	           ::core::mem::align_of::<SDInfo>(),
	           4usize,
	           concat!("Alignment of ", stringify!(SDInfo))
	);
	fn test_field_fs_type() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<SDInfo>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).fs_type) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(SDInfo), "::", stringify!(fs_type))
		);
	}
	test_field_fs_type();
	fn test_field_kb_total() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<SDInfo>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).kb_total) as usize - ptr as usize
		           },
		           4usize,
		           concat!("Offset of field: ", stringify!(SDInfo), "::", stringify!(kb_total))
		);
	}
	test_field_kb_total();
	fn test_field_kb_free() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<SDInfo>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).kb_free) as usize - ptr as usize
		           },
		           8usize,
		           concat!("Offset of field: ", stringify!(SDInfo), "::", stringify!(kb_free))
		);
	}
	test_field_kb_free();
	fn test_field_cluster_size() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<SDInfo>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).cluster_size) as usize - ptr as usize
		           },
		           12usize,
		           concat!("Offset of field: ", stringify!(SDInfo), "::", stringify!(cluster_size))
		);
	}
	test_field_cluster_size();
	fn test_field_sector_size() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<SDInfo>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).sector_size) as usize - ptr as usize
		           },
		           14usize,
		           concat!("Offset of field: ", stringify!(SDInfo), "::", stringify!(sector_size))
		);
	}
	test_field_sector_size();
	fn test_field_label() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<SDInfo>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).label) as usize - ptr as usize
		           },
		           16usize,
		           concat!("Offset of field: ", stringify!(SDInfo), "::", stringify!(label))
		);
	}
	test_field_label();
	fn test_field_error() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<SDInfo>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).error) as usize - ptr as usize
		           },
		           52usize,
		           concat!("Offset of field: ", stringify!(SDInfo), "::", stringify!(error))
		);
	}
	test_field_error();
}
extern "C" {
	pub fn sd_api_get_fs_type_text(fs_type: SDFsType) -> *const core::ffi::c_char;
}
#[repr(C)]
pub struct Storage {
	_unused: [u8; 0],
}
extern "C" {
	#[doc = " Allocates and initializes a file descriptor"]
	#[doc = " @return File*"]
	pub fn storage_file_alloc(storage: *mut Storage) -> *mut File;
}
extern "C" {
	#[doc = " Frees the file descriptor. Closes the file if it was open."]
	pub fn storage_file_free(file: *mut File);
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum StorageEventType {
	StorageEventTypeCardMount = 0,
	StorageEventTypeCardUnmount = 1,
	StorageEventTypeCardMountError = 2,
	StorageEventTypeFileClose = 3,
	StorageEventTypeDirClose = 4,
}
#[repr(C)]
pub struct StorageEvent {
	pub type_: StorageEventType,
}
#[test]
fn bindgen_test_layout_StorageEvent() {
	assert_eq!(
	           ::core::mem::size_of::<StorageEvent>(),
	           4usize,
	           concat!("Size of: ", stringify!(StorageEvent))
	);
	assert_eq!(
	           ::core::mem::align_of::<StorageEvent>(),
	           4usize,
	           concat!("Alignment of ", stringify!(StorageEvent))
	);
	fn test_field_type() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<StorageEvent>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(StorageEvent), "::", stringify!(type_))
		);
	}
	test_field_type();
}
extern "C" {
	#[doc = " Get storage pubsub."]
	#[doc = " Storage will send StorageEvent messages."]
	#[doc = " @param storage"]
	#[doc = " @return FuriPubSub*"]
	pub fn storage_get_pubsub(storage: *mut Storage) -> *mut FuriPubSub;
}
extern "C" {
	#[doc = " Opens an existing file or create a new one."]
	#[doc = " @param file pointer to file object."]
	#[doc = " @param path path to file"]
	#[doc = " @param access_mode access mode from FS_AccessMode"]
	#[doc = " @param open_mode open mode from FS_OpenMode"]
	#[doc = " @return success flag. You need to close the file even if the open operation failed."]
	pub fn storage_file_open(file: *mut File,
	                         path: *const core::ffi::c_char,
	                         access_mode: FS_AccessMode,
	                         open_mode: FS_OpenMode)
	                         -> bool;
}
extern "C" {
	#[doc = " Close the file."]
	#[doc = " @param file pointer to a file object, the file object will be freed."]
	#[doc = " @return success flag"]
	pub fn storage_file_close(file: *mut File) -> bool;
}
extern "C" {
	#[doc = " Tells if the file is open"]
	#[doc = " @param file pointer to a file object"]
	#[doc = " @return bool true if file is open"]
	pub fn storage_file_is_open(file: *mut File) -> bool;
}
extern "C" {
	#[doc = " Tells if the file is a directory"]
	#[doc = " @param file pointer to a file object"]
	#[doc = " @return bool true if file is a directory"]
	pub fn storage_file_is_dir(file: *mut File) -> bool;
}
extern "C" {
	#[doc = " Reads bytes from a file into a buffer"]
	#[doc = " @param file pointer to file object."]
	#[doc = " @param buff pointer to a buffer, for reading"]
	#[doc = " @param bytes_to_read how many bytes to read. Must be less than or equal to the size of the buffer."]
	#[doc = " @return uint16_t how many bytes were actually read"]
	pub fn storage_file_read(file: *mut File, buff: *mut core::ffi::c_void, bytes_to_read: u16) -> u16;
}
extern "C" {
	#[doc = " Writes bytes from a buffer to a file"]
	#[doc = " @param file pointer to file object."]
	#[doc = " @param buff pointer to buffer, for writing"]
	#[doc = " @param bytes_to_write how many bytes to write. Must be less than or equal to the size of the buffer."]
	#[doc = " @return uint16_t how many bytes were actually written"]
	pub fn storage_file_write(file: *mut File, buff: *const core::ffi::c_void, bytes_to_write: u16) -> u16;
}
extern "C" {
	#[doc = " Moves the r/w pointer"]
	#[doc = " @param file pointer to file object."]
	#[doc = " @param offset offset to move the r/w pointer"]
	#[doc = " @param from_start set an offset from the start or from the current position"]
	#[doc = " @return success flag"]
	pub fn storage_file_seek(file: *mut File, offset: u32, from_start: bool) -> bool;
}
extern "C" {
	#[doc = " Gets the position of the r/w pointer"]
	#[doc = " @param file pointer to file object."]
	#[doc = " @return uint64_t position of the r/w pointer"]
	pub fn storage_file_tell(file: *mut File) -> u64;
}
extern "C" {
	#[doc = " Truncates the file size to the current position of the r/w pointer"]
	#[doc = " @param file pointer to file object."]
	#[doc = " @return bool success flag"]
	pub fn storage_file_truncate(file: *mut File) -> bool;
}
extern "C" {
	#[doc = " Gets the size of the file"]
	#[doc = " @param file pointer to file object."]
	#[doc = " @return uint64_t size of the file"]
	pub fn storage_file_size(file: *mut File) -> u64;
}
extern "C" {
	#[doc = " Writes file cache to storage"]
	#[doc = " @param file pointer to file object."]
	#[doc = " @return bool success flag"]
	pub fn storage_file_sync(file: *mut File) -> bool;
}
extern "C" {
	#[doc = " Checks that the r/w pointer is at the end of the file"]
	#[doc = " @param file pointer to file object."]
	#[doc = " @return bool success flag"]
	pub fn storage_file_eof(file: *mut File) -> bool;
}
extern "C" {
	#[doc = " @brief Check that file exists"]
	#[doc = ""]
	#[doc = " @param storage"]
	#[doc = " @param path"]
	#[doc = " @return true if file exists"]
	pub fn storage_file_exists(storage: *mut Storage, path: *const core::ffi::c_char) -> bool;
}
extern "C" {
	#[doc = " Opens a directory to get objects from it"]
	#[doc = " @param app pointer to the api"]
	#[doc = " @param file pointer to file object."]
	#[doc = " @param path path to directory"]
	#[doc = " @return bool success flag. You need to close the directory even if the open operation failed."]
	pub fn storage_dir_open(file: *mut File, path: *const core::ffi::c_char) -> bool;
}
extern "C" {
	#[doc = " Close the directory. Also free file handle structure and point it to the NULL."]
	#[doc = " @param file pointer to a file object."]
	#[doc = " @return bool success flag"]
	pub fn storage_dir_close(file: *mut File) -> bool;
}
extern "C" {
	#[doc = " Reads the next object in the directory"]
	#[doc = " @param file pointer to file object."]
	#[doc = " @param fileinfo pointer to the read FileInfo, may be NULL"]
	#[doc = " @param name pointer to name buffer, may be NULL"]
	#[doc = " @param name_length name buffer length"]
	#[doc = " @return success flag (if the next object does not exist, it also returns false and sets the file error id to FSE_NOT_EXIST)"]
	pub fn storage_dir_read(file: *mut File, fileinfo: *mut FileInfo, name: *mut core::ffi::c_char, name_length: u16) -> bool;
}
extern "C" {
	#[doc = " Rewinds the read pointer to first item in the directory"]
	#[doc = " @param file pointer to file object."]
	#[doc = " @return bool success flag"]
	pub fn storage_dir_rewind(file: *mut File) -> bool;
}
extern "C" {
	#[doc = " Retrieves information about a file/directory"]
	#[doc = " @param app pointer to the api"]
	#[doc = " @param path path to file/directory"]
	#[doc = " @param fileinfo pointer to the read FileInfo, may be NULL"]
	#[doc = " @return FS_Error operation result"]
	pub fn storage_common_stat(storage: *mut Storage, path: *const core::ffi::c_char, fileinfo: *mut FileInfo) -> FS_Error;
}
extern "C" {
	#[doc = " Removes a file/directory from the repository, the directory must be empty and the file/directory must not be open"]
	#[doc = " @param app pointer to the api"]
	#[doc = " @param path"]
	#[doc = " @return FS_Error operation result"]
	pub fn storage_common_remove(storage: *mut Storage, path: *const core::ffi::c_char) -> FS_Error;
}
extern "C" {
	#[doc = " Renames file/directory, file/directory must not be open"]
	#[doc = " @param app pointer to the api"]
	#[doc = " @param old_path old path"]
	#[doc = " @param new_path new path"]
	#[doc = " @return FS_Error operation result"]
	pub fn storage_common_rename(storage: *mut Storage,
	                             old_path: *const core::ffi::c_char,
	                             new_path: *const core::ffi::c_char)
	                             -> FS_Error;
}
extern "C" {
	#[doc = " Copy file, file must not be open"]
	#[doc = " @param app pointer to the api"]
	#[doc = " @param old_path old path"]
	#[doc = " @param new_path new path"]
	#[doc = " @return FS_Error operation result"]
	pub fn storage_common_copy(storage: *mut Storage,
	                           old_path: *const core::ffi::c_char,
	                           new_path: *const core::ffi::c_char)
	                           -> FS_Error;
}
extern "C" {
	#[doc = " Copy one folder contents into another with rename of all conflicting files"]
	#[doc = " @param app pointer to the api"]
	#[doc = " @param old_path old path"]
	#[doc = " @param new_path new path"]
	#[doc = " @return FS_Error operation result"]
	pub fn storage_common_merge(storage: *mut Storage,
	                            old_path: *const core::ffi::c_char,
	                            new_path: *const core::ffi::c_char)
	                            -> FS_Error;
}
extern "C" {
	#[doc = " Creates a directory"]
	#[doc = " @param app pointer to the api"]
	#[doc = " @param path directory path"]
	#[doc = " @return FS_Error operation result"]
	pub fn storage_common_mkdir(storage: *mut Storage, path: *const core::ffi::c_char) -> FS_Error;
}
extern "C" {
	#[doc = " Gets general information about the storage"]
	#[doc = " @param app pointer to the api"]
	#[doc = " @param fs_path the path to the storage of interest"]
	#[doc = " @param total_space pointer to total space record, will be filled"]
	#[doc = " @param free_space pointer to free space record, will be filled"]
	#[doc = " @return FS_Error operation result"]
	pub fn storage_common_fs_info(storage: *mut Storage,
	                              fs_path: *const core::ffi::c_char,
	                              total_space: *mut u64,
	                              free_space: *mut u64)
	                              -> FS_Error;
}
extern "C" {
	#[doc = " Retrieves the error text from the error id"]
	#[doc = " @param error_id error id"]
	#[doc = " @return const char* error text"]
	pub fn storage_error_get_desc(error_id: FS_Error) -> *const core::ffi::c_char;
}
extern "C" {
	#[doc = " Retrieves the error id from the file object"]
	#[doc = " @param file pointer to file object. Pointer must not point to NULL. YOU CANNOT RETREIVE THE ERROR ID IF THE FILE HAS BEEN CLOSED"]
	#[doc = " @return FS_Error error id"]
	pub fn storage_file_get_error(file: *mut File) -> FS_Error;
}
extern "C" {
	#[doc = " Retrieves the internal (storage-specific) error id from the file object"]
	#[doc = " @param file pointer to file object. Pointer must not point to NULL. YOU CANNOT RETREIVE THE INTERNAL ERROR ID IF THE FILE HAS BEEN CLOSED"]
	#[doc = " @return FS_Error error id"]
	pub fn storage_file_get_internal_error(file: *mut File) -> i32;
}
extern "C" {
	#[doc = " Retrieves the error text from the file object"]
	#[doc = " @param file pointer to file object. Pointer must not point to NULL. YOU CANNOT RETREIVE THE ERROR TEXT IF THE FILE HAS BEEN CLOSED"]
	#[doc = " @return const char* error text"]
	pub fn storage_file_get_error_desc(file: *mut File) -> *const core::ffi::c_char;
}
extern "C" {
	#[doc = " Formats SD Card"]
	#[doc = " @param api pointer to the api"]
	#[doc = " @return FS_Error operation result"]
	pub fn storage_sd_format(api: *mut Storage) -> FS_Error;
}
extern "C" {
	#[doc = " Will unmount the SD card"]
	#[doc = " @param api pointer to the api"]
	#[doc = " @return FS_Error operation result"]
	pub fn storage_sd_unmount(api: *mut Storage) -> FS_Error;
}
extern "C" {
	#[doc = " Retrieves SD card information"]
	#[doc = " @param api pointer to the api"]
	#[doc = " @param info pointer to the info"]
	#[doc = " @return FS_Error operation result"]
	pub fn storage_sd_info(api: *mut Storage, info: *mut SDInfo) -> FS_Error;
}
extern "C" {
	#[doc = " Retrieves SD card status"]
	#[doc = " @param api pointer to the api"]
	#[doc = " @return FS_Error operation result"]
	pub fn storage_sd_status(api: *mut Storage) -> FS_Error;
}
#[doc = " Internal LFS Functions"]
pub type Storage_name_converter = ::core::option::Option<unsafe extern "C" fn(arg1: *mut string_t)>;
extern "C" {
	#[doc = " Backs up internal storage to a tar archive"]
	#[doc = " @param api pointer to the api"]
	#[doc = " @param dstmane destination archive path"]
	#[doc = " @return FS_Error operation result"]
	pub fn storage_int_backup(api: *mut Storage, dstname: *const core::ffi::c_char) -> FS_Error;
}
extern "C" {
	#[doc = " Restores internal storage from a tar archive"]
	#[doc = " @param api pointer to the api"]
	#[doc = " @param dstmane archive path"]
	#[doc = " @param converter pointer to filename conversion function, may be NULL"]
	#[doc = " @return FS_Error operation result"]
	pub fn storage_int_restore(api: *mut Storage, dstname: *const core::ffi::c_char, converter: Storage_name_converter) -> FS_Error;
}
extern "C" {
	#[doc = " Removes a file/directory, the directory must be empty and the file/directory must not be open"]
	#[doc = " @param storage pointer to the api"]
	#[doc = " @param path"]
	#[doc = " @return true on success or if file/dir is not exist"]
	pub fn storage_simply_remove(storage: *mut Storage, path: *const core::ffi::c_char) -> bool;
}
extern "C" {
	#[doc = " Recursively removes a file/directory, the directory can be not empty"]
	#[doc = " @param storage pointer to the api"]
	#[doc = " @param path"]
	#[doc = " @return true on success or if file/dir is not exist"]
	pub fn storage_simply_remove_recursive(storage: *mut Storage, path: *const core::ffi::c_char) -> bool;
}
extern "C" {
	#[doc = " Creates a directory"]
	#[doc = " @param storage"]
	#[doc = " @param path"]
	#[doc = " @return true on success or if directory is already exist"]
	pub fn storage_simply_mkdir(storage: *mut Storage, path: *const core::ffi::c_char) -> bool;
}
extern "C" {
	#[doc = " @brief Get next free filename."]
	#[doc = ""]
	#[doc = " @param storage"]
	#[doc = " @param dirname"]
	#[doc = " @param filename"]
	#[doc = " @param fileextension"]
	#[doc = " @param nextfilename return name"]
	#[doc = " @param max_len  max len name"]
	pub fn storage_get_next_filename(storage: *mut Storage,
	                                 dirname: *const core::ffi::c_char,
	                                 filename: *const core::ffi::c_char,
	                                 fileextension: *const core::ffi::c_char,
	                                 nextfilename: *mut string_t,
	                                 max_len: u8);
}
#[doc = " @brief  RCC Clocks Frequency Structure"]
#[repr(C)]
pub struct LL_RCC_ClocksTypeDef {
	#[doc = "< SYSCLK clock frequency"]
	pub SYSCLK_Frequency: u32,
	#[doc = "< HCLK1 clock frequency"]
	pub HCLK1_Frequency: u32,
	#[doc = "< HCLK2 clock frequency"]
	pub HCLK2_Frequency: u32,
	#[doc = "< HCLK4 clock frequency"]
	pub HCLK4_Frequency: u32,
	#[doc = "< HCLK5 clock frequency"]
	pub HCLK5_Frequency: u32,
	#[doc = "< PCLK1 clock frequency"]
	pub PCLK1_Frequency: u32,
	#[doc = "< PCLK2 clock frequency"]
	pub PCLK2_Frequency: u32,
}
#[test]
fn bindgen_test_layout_LL_RCC_ClocksTypeDef() {
	assert_eq!(
	           ::core::mem::size_of::<LL_RCC_ClocksTypeDef>(),
	           28usize,
	           concat!("Size of: ", stringify!(LL_RCC_ClocksTypeDef))
	);
	assert_eq!(
	           ::core::mem::align_of::<LL_RCC_ClocksTypeDef>(),
	           4usize,
	           concat!("Alignment of ", stringify!(LL_RCC_ClocksTypeDef))
	);
	fn test_field_SYSCLK_Frequency() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_RCC_ClocksTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).SYSCLK_Frequency) as usize - ptr as usize
		           },
		           0usize,
		           concat!(
			"Offset of field: ",
			stringify!(LL_RCC_ClocksTypeDef),
			"::",
			stringify!(SYSCLK_Frequency)
		)
		);
	}
	test_field_SYSCLK_Frequency();
	fn test_field_HCLK1_Frequency() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_RCC_ClocksTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).HCLK1_Frequency) as usize - ptr as usize
		           },
		           4usize,
		           concat!(
			"Offset of field: ",
			stringify!(LL_RCC_ClocksTypeDef),
			"::",
			stringify!(HCLK1_Frequency)
		)
		);
	}
	test_field_HCLK1_Frequency();
	fn test_field_HCLK2_Frequency() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_RCC_ClocksTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).HCLK2_Frequency) as usize - ptr as usize
		           },
		           8usize,
		           concat!(
			"Offset of field: ",
			stringify!(LL_RCC_ClocksTypeDef),
			"::",
			stringify!(HCLK2_Frequency)
		)
		);
	}
	test_field_HCLK2_Frequency();
	fn test_field_HCLK4_Frequency() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_RCC_ClocksTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).HCLK4_Frequency) as usize - ptr as usize
		           },
		           12usize,
		           concat!(
			"Offset of field: ",
			stringify!(LL_RCC_ClocksTypeDef),
			"::",
			stringify!(HCLK4_Frequency)
		)
		);
	}
	test_field_HCLK4_Frequency();
	fn test_field_HCLK5_Frequency() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_RCC_ClocksTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).HCLK5_Frequency) as usize - ptr as usize
		           },
		           16usize,
		           concat!(
			"Offset of field: ",
			stringify!(LL_RCC_ClocksTypeDef),
			"::",
			stringify!(HCLK5_Frequency)
		)
		);
	}
	test_field_HCLK5_Frequency();
	fn test_field_PCLK1_Frequency() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_RCC_ClocksTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).PCLK1_Frequency) as usize - ptr as usize
		           },
		           20usize,
		           concat!(
			"Offset of field: ",
			stringify!(LL_RCC_ClocksTypeDef),
			"::",
			stringify!(PCLK1_Frequency)
		)
		);
	}
	test_field_PCLK1_Frequency();
	fn test_field_PCLK2_Frequency() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_RCC_ClocksTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).PCLK2_Frequency) as usize - ptr as usize
		           },
		           24usize,
		           concat!(
			"Offset of field: ",
			stringify!(LL_RCC_ClocksTypeDef),
			"::",
			stringify!(PCLK2_Frequency)
		)
		);
	}
	test_field_PCLK2_Frequency();
}
extern "C" {
	#[doc = " @defgroup RCC_LL_EF_Init De-initialization function"]
	#[doc = " @{"]
	pub fn LL_RCC_DeInit() -> ErrorStatus;
}
extern "C" {
	#[doc = " @defgroup RCC_LL_EF_Get_Freq Get system and peripherals clocks frequency functions"]
	#[doc = " @{"]
	pub fn LL_RCC_GetSystemClocksFreq(RCC_Clocks: *mut LL_RCC_ClocksTypeDef);
}
extern "C" {
	pub fn LL_RCC_GetSMPSClockFreq() -> u32;
}
extern "C" {
	pub fn LL_RCC_GetUSARTClockFreq(USARTxSource: u32) -> u32;
}
extern "C" {
	pub fn LL_RCC_GetI2CClockFreq(I2CxSource: u32) -> u32;
}
extern "C" {
	pub fn LL_RCC_GetLPUARTClockFreq(LPUARTxSource: u32) -> u32;
}
extern "C" {
	pub fn LL_RCC_GetLPTIMClockFreq(LPTIMxSource: u32) -> u32;
}
extern "C" {
	pub fn LL_RCC_GetSAIClockFreq(SAIxSource: u32) -> u32;
}
extern "C" {
	pub fn LL_RCC_GetCLK48ClockFreq(CLK48xSource: u32) -> u32;
}
extern "C" {
	pub fn LL_RCC_GetRNGClockFreq(RNGxSource: u32) -> u32;
}
extern "C" {
	pub fn LL_RCC_GetUSBClockFreq(USBxSource: u32) -> u32;
}
extern "C" {
	pub fn LL_RCC_GetADCClockFreq(ADCxSource: u32) -> u32;
}
extern "C" {
	pub fn LL_RCC_GetRTCClockFreq() -> u32;
}
extern "C" {
	pub fn LL_RCC_GetRFWKPClockFreq() -> u32;
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum FuriHalClockMcoSourceId {
	FuriHalClockMcoLse = 0,
	FuriHalClockMcoSysclk = 1,
	FuriHalClockMcoMsi100k = 2,
	FuriHalClockMcoMsi200k = 3,
	FuriHalClockMcoMsi400k = 4,
	FuriHalClockMcoMsi800k = 5,
	FuriHalClockMcoMsi1m = 6,
	FuriHalClockMcoMsi2m = 7,
	FuriHalClockMcoMsi4m = 8,
	FuriHalClockMcoMsi8m = 9,
	FuriHalClockMcoMsi16m = 10,
	FuriHalClockMcoMsi24m = 11,
	FuriHalClockMcoMsi32m = 12,
	FuriHalClockMcoMsi48m = 13,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum FuriHalClockMcoDivisorId {
	FuriHalClockMcoDiv1 = 0,
	FuriHalClockMcoDiv2 = 268435456,
	FuriHalClockMcoDiv4 = 536870912,
	FuriHalClockMcoDiv8 = 805306368,
	FuriHalClockMcoDiv16 = 1073741824,
}
extern "C" {
	#[doc = " Early initialization"]
	pub fn furi_hal_clock_init_early();
}
extern "C" {
	#[doc = " Early deinitialization"]
	pub fn furi_hal_clock_deinit_early();
}
extern "C" {
	#[doc = " Initialize clocks"]
	pub fn furi_hal_clock_init();
}
extern "C" {
	#[doc = " Switch to HSI clock"]
	pub fn furi_hal_clock_switch_to_hsi();
}
extern "C" {
	#[doc = " Switch to PLL clock"]
	pub fn furi_hal_clock_switch_to_pll();
}
extern "C" {
	#[doc = " Stop SysTick counter without resetting"]
	pub fn furi_hal_clock_suspend_tick();
}
extern "C" {
	#[doc = " Continue SysTick counter operation"]
	pub fn furi_hal_clock_resume_tick();
}
extern "C" {
	#[doc = " Enable clock output on MCO pin"]
	#[doc = ""]
	#[doc = " @param      source  MCO clock source"]
	#[doc = " @param      div     MCO clock division"]
	pub fn furi_hal_clock_mco_enable(source: FuriHalClockMcoSourceId, div: FuriHalClockMcoDivisorId);
}
extern "C" {
	#[doc = " Disable clock output on MCO pin"]
	pub fn furi_hal_clock_mco_disable();
}
pub type FuriHalConsoleTxCallback =
	::core::option::Option<unsafe extern "C" fn(buffer: *const u8, size: usize, context: *mut core::ffi::c_void)>;
extern "C" {
	pub fn furi_hal_console_init();
}
extern "C" {
	pub fn furi_hal_console_enable();
}
extern "C" {
	pub fn furi_hal_console_disable();
}
extern "C" {
	pub fn furi_hal_console_set_tx_callback(callback: FuriHalConsoleTxCallback, context: *mut core::ffi::c_void);
}
extern "C" {
	pub fn furi_hal_console_tx(buffer: *const u8, buffer_size: usize);
}
extern "C" {
	pub fn furi_hal_console_tx_with_new_line(buffer: *const u8, buffer_size: usize);
}
extern "C" {
	#[doc = " Printf-like plain uart interface"]
	#[doc = " @warning Will not work in ISR context"]
	#[doc = " @param format"]
	#[doc = " @param ..."]
	pub fn furi_hal_console_printf(format: *const [core::ffi::c_char; 0usize], ...);
}
extern "C" {
	pub fn furi_hal_console_puts(data: *const core::ffi::c_char);
}
#[repr(C)]
pub struct FuriHalFlashRawOptionByteData {
	pub bytes: __BindgenUnionField<[u8; 128usize]>,
	pub obs: __BindgenUnionField<[FuriHalFlashRawOptionByteData__bindgen_ty_1; 16usize]>,
	pub bindgen_union_field: [u64; 16usize],
}
#[repr(C)]
pub struct FuriHalFlashRawOptionByteData__bindgen_ty_1 {
	pub values: __BindgenUnionField<FuriHalFlashRawOptionByteData__bindgen_ty_1__bindgen_ty_1>,
	pub dword: __BindgenUnionField<u64>,
	pub bindgen_union_field: u64,
}
#[repr(C)]
pub struct FuriHalFlashRawOptionByteData__bindgen_ty_1__bindgen_ty_1 {
	pub base: u32,
	pub complementary_value: u32,
}
#[test]
fn bindgen_test_layout_FuriHalFlashRawOptionByteData__bindgen_ty_1__bindgen_ty_1() {
	assert_eq!(
	           ::core::mem::size_of::<FuriHalFlashRawOptionByteData__bindgen_ty_1__bindgen_ty_1>(),
	           8usize,
	           concat!(
		"Size of: ",
		stringify!(FuriHalFlashRawOptionByteData__bindgen_ty_1__bindgen_ty_1)
	)
	);
	assert_eq!(
	           ::core::mem::align_of::<FuriHalFlashRawOptionByteData__bindgen_ty_1__bindgen_ty_1>(),
	           4usize,
	           concat!(
		"Alignment of ",
		stringify!(FuriHalFlashRawOptionByteData__bindgen_ty_1__bindgen_ty_1)
	)
	);
	fn test_field_base() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<FuriHalFlashRawOptionByteData__bindgen_ty_1__bindgen_ty_1>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).base) as usize - ptr as usize
		           },
		           0usize,
		           concat!(
			"Offset of field: ",
			stringify!(FuriHalFlashRawOptionByteData__bindgen_ty_1__bindgen_ty_1),
			"::",
			stringify!(base)
		)
		);
	}
	test_field_base();
	fn test_field_complementary_value() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<FuriHalFlashRawOptionByteData__bindgen_ty_1__bindgen_ty_1>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).complementary_value) as usize - ptr as usize
		           },
		           4usize,
		           concat!(
			"Offset of field: ",
			stringify!(FuriHalFlashRawOptionByteData__bindgen_ty_1__bindgen_ty_1),
			"::",
			stringify!(complementary_value)
		)
		);
	}
	test_field_complementary_value();
}
#[test]
fn bindgen_test_layout_FuriHalFlashRawOptionByteData__bindgen_ty_1() {
	assert_eq!(
	           ::core::mem::size_of::<FuriHalFlashRawOptionByteData__bindgen_ty_1>(),
	           8usize,
	           concat!("Size of: ", stringify!(FuriHalFlashRawOptionByteData__bindgen_ty_1))
	);
	assert_eq!(
	           ::core::mem::align_of::<FuriHalFlashRawOptionByteData__bindgen_ty_1>(),
	           8usize,
	           concat!("Alignment of ", stringify!(FuriHalFlashRawOptionByteData__bindgen_ty_1))
	);
	fn test_field_values() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<FuriHalFlashRawOptionByteData__bindgen_ty_1>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).values) as usize - ptr as usize
		           },
		           0usize,
		           concat!(
			"Offset of field: ",
			stringify!(FuriHalFlashRawOptionByteData__bindgen_ty_1),
			"::",
			stringify!(values)
		)
		);
	}
	test_field_values();
	fn test_field_dword() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<FuriHalFlashRawOptionByteData__bindgen_ty_1>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).dword) as usize - ptr as usize
		           },
		           0usize,
		           concat!(
			"Offset of field: ",
			stringify!(FuriHalFlashRawOptionByteData__bindgen_ty_1),
			"::",
			stringify!(dword)
		)
		);
	}
	test_field_dword();
}
#[test]
fn bindgen_test_layout_FuriHalFlashRawOptionByteData() {
	assert_eq!(
	           ::core::mem::size_of::<FuriHalFlashRawOptionByteData>(),
	           128usize,
	           concat!("Size of: ", stringify!(FuriHalFlashRawOptionByteData))
	);
	assert_eq!(
	           ::core::mem::align_of::<FuriHalFlashRawOptionByteData>(),
	           8usize,
	           concat!("Alignment of ", stringify!(FuriHalFlashRawOptionByteData))
	);
	fn test_field_bytes() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<FuriHalFlashRawOptionByteData>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).bytes) as usize - ptr as usize
		           },
		           0usize,
		           concat!(
			"Offset of field: ",
			stringify!(FuriHalFlashRawOptionByteData),
			"::",
			stringify!(bytes)
		)
		);
	}
	test_field_bytes();
	fn test_field_obs() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<FuriHalFlashRawOptionByteData>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).obs) as usize - ptr as usize
		           },
		           0usize,
		           concat!(
			"Offset of field: ",
			stringify!(FuriHalFlashRawOptionByteData),
			"::",
			stringify!(obs)
		)
		);
	}
	test_field_obs();
}
extern "C" {
	#[doc = " Init flash, applying necessary workarounds"]
	pub fn furi_hal_flash_init();
}
extern "C" {
	#[doc = " Get flash base address"]
	#[doc = ""]
	#[doc = " @return     pointer to flash base"]
	pub fn furi_hal_flash_get_base() -> usize;
}
extern "C" {
	#[doc = " Get flash read block size"]
	#[doc = ""]
	#[doc = " @return     size in bytes"]
	pub fn furi_hal_flash_get_read_block_size() -> usize;
}
extern "C" {
	#[doc = " Get flash write block size"]
	#[doc = ""]
	#[doc = " @return     size in bytes"]
	pub fn furi_hal_flash_get_write_block_size() -> usize;
}
extern "C" {
	#[doc = " Get flash page size"]
	#[doc = ""]
	#[doc = " @return     size in bytes"]
	pub fn furi_hal_flash_get_page_size() -> usize;
}
extern "C" {
	#[doc = " Get expected flash cycles count"]
	#[doc = ""]
	#[doc = " @return     count of erase-write operations"]
	pub fn furi_hal_flash_get_cycles_count() -> usize;
}
extern "C" {
	#[doc = " Get free flash start address"]
	#[doc = ""]
	#[doc = " @return     pointer to free region start"]
	pub fn furi_hal_flash_get_free_start_address() -> *const core::ffi::c_void;
}
extern "C" {
	#[doc = " Get free flash end address"]
	#[doc = ""]
	#[doc = " @return     pointer to free region end"]
	pub fn furi_hal_flash_get_free_end_address() -> *const core::ffi::c_void;
}
extern "C" {
	#[doc = " Get first free page start address"]
	#[doc = ""]
	#[doc = " @return     first free page memory address"]
	pub fn furi_hal_flash_get_free_page_start_address() -> usize;
}
extern "C" {
	#[doc = " Get free page count"]
	#[doc = ""]
	#[doc = " @return     free page count"]
	pub fn furi_hal_flash_get_free_page_count() -> usize;
}
extern "C" {
	#[doc = " Erase Flash"]
	#[doc = ""]
	#[doc = " @warning    locking operation with critical section, stalls execution"]
	#[doc = ""]
	#[doc = " @param      page  The page to erase"]
	pub fn furi_hal_flash_erase(page: u8);
}
extern "C" {
	#[doc = " Write double word (64 bits)"]
	#[doc = ""]
	#[doc = " @warning locking operation with critical section, stalls execution"]
	#[doc = ""]
	#[doc = " @param      address  destination address, must be double word aligned."]
	#[doc = " @param      data     data to write"]
	pub fn furi_hal_flash_write_dword(address: usize, data: u64);
}
extern "C" {
	#[doc = " Write aligned page data (up to page size)"]
	#[doc = ""]
	#[doc = " @warning locking operation with critical section, stalls execution"]
	#[doc = ""]
	#[doc = " @param      address  destination address, must be page aligned."]
	#[doc = " @param      data     data to write"]
	#[doc = " @param      length   data length"]
	pub fn furi_hal_flash_program_page(page: u8, data: *const u8, length: u16);
}
extern "C" {
	#[doc = " Get flash page number for address"]
	#[doc = ""]
	#[doc = " @return     page number, -1 for invalid address"]
	pub fn furi_hal_flash_get_page_number(address: usize) -> i16;
}
extern "C" {
	#[doc = " Writes OB word, using non-compl. index of register in Flash, OPTION_BYTE_BASE"]
	#[doc = ""]
	#[doc = " @warning locking operation with critical section, stalls execution"]
	#[doc = ""]
	#[doc = " @param      word_idx  OB word number"]
	#[doc = " @param      value    data to write"]
	#[doc = " @return     true if value was written, false for read-only word"]
	pub fn furi_hal_flash_ob_set_word(word_idx: usize, value: u32) -> bool;
}
extern "C" {
	#[doc = " Forces a reload of OB data from flash to registers"]
	#[doc = ""]
	#[doc = " @warning Initializes system restart"]
	#[doc = ""]
	pub fn furi_hal_flash_ob_apply();
}
extern "C" {
	#[doc = " Get raw OB storage data"]
	#[doc = ""]
	#[doc = " @return     pointer to read-only data of OB (raw + complementary values)"]
	pub fn furi_hal_flash_ob_get_raw_ptr() -> *const FuriHalFlashRawOptionByteData;
}
#[doc = " @defgroup I2C_LL_ES_INIT I2C Exported Init structure"]
#[doc = " @{"]
#[repr(C)]
pub struct LL_I2C_InitTypeDef {
	#[doc = "< Specifies the peripheral mode."]
	#[doc = "This parameter can be a value of @ref I2C_LL_EC_PERIPHERAL_MODE."]
	#[doc = ""]
	#[doc = "This feature can be modified afterwards using unitary function"]
	#[doc = "@ref LL_I2C_SetMode()."]
	pub PeripheralMode: u32,
	#[doc = "< Specifies the SDA setup, hold time and the SCL high, low period values."]
	#[doc = "This parameter must be set by referring to the STM32CubeMX Tool and"]
	#[doc = "the helper macro @ref __LL_I2C_CONVERT_TIMINGS()."]
	#[doc = ""]
	#[doc = "This feature can be modified afterwards using unitary function"]
	#[doc = "@ref LL_I2C_SetTiming()."]
	pub Timing: u32,
	#[doc = "< Enables or disables analog noise filter."]
	#[doc = "This parameter can be a value of @ref I2C_LL_EC_ANALOGFILTER_SELECTION."]
	#[doc = ""]
	#[doc = "This feature can be modified afterwards using unitary functions"]
	#[doc = "@ref LL_I2C_EnableAnalogFilter() or LL_I2C_DisableAnalogFilter()."]
	pub AnalogFilter: u32,
	#[doc = "< Configures the digital noise filter."]
	#[doc = "This parameter can be a number between Min_Data = 0x00 and Max_Data = 0x0F."]
	#[doc = ""]
	#[doc = "This feature can be modified afterwards using unitary function"]
	#[doc = "@ref LL_I2C_SetDigitalFilter()."]
	pub DigitalFilter: u32,
	#[doc = "< Specifies the device own address 1."]
	#[doc = "This parameter must be a value between Min_Data = 0x00 and Max_Data = 0x3FF."]
	#[doc = ""]
	#[doc = "This feature can be modified afterwards using unitary function"]
	#[doc = "@ref LL_I2C_SetOwnAddress1()."]
	pub OwnAddress1: u32,
	#[doc = "< Specifies the ACKnowledge or Non ACKnowledge condition after the address receive"]
	#[doc = "match code or next received byte."]
	#[doc = "This parameter can be a value of @ref I2C_LL_EC_I2C_ACKNOWLEDGE."]
	#[doc = ""]
	#[doc = "This feature can be modified afterwards using unitary function"]
	#[doc = "@ref LL_I2C_AcknowledgeNextData()."]
	pub TypeAcknowledge: u32,
	#[doc = "< Specifies the device own address 1 size (7-bit or 10-bit)."]
	#[doc = "This parameter can be a value of @ref I2C_LL_EC_OWNADDRESS1."]
	#[doc = ""]
	#[doc = "This feature can be modified afterwards using unitary function"]
	#[doc = "@ref LL_I2C_SetOwnAddress1()."]
	pub OwnAddrSize: u32,
}
#[test]
fn bindgen_test_layout_LL_I2C_InitTypeDef() {
	assert_eq!(
	           ::core::mem::size_of::<LL_I2C_InitTypeDef>(),
	           28usize,
	           concat!("Size of: ", stringify!(LL_I2C_InitTypeDef))
	);
	assert_eq!(
	           ::core::mem::align_of::<LL_I2C_InitTypeDef>(),
	           4usize,
	           concat!("Alignment of ", stringify!(LL_I2C_InitTypeDef))
	);
	fn test_field_PeripheralMode() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_I2C_InitTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).PeripheralMode) as usize - ptr as usize
		           },
		           0usize,
		           concat!(
			"Offset of field: ",
			stringify!(LL_I2C_InitTypeDef),
			"::",
			stringify!(PeripheralMode)
		)
		);
	}
	test_field_PeripheralMode();
	fn test_field_Timing() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_I2C_InitTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).Timing) as usize - ptr as usize
		           },
		           4usize,
		           concat!("Offset of field: ", stringify!(LL_I2C_InitTypeDef), "::", stringify!(Timing))
		);
	}
	test_field_Timing();
	fn test_field_AnalogFilter() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_I2C_InitTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).AnalogFilter) as usize - ptr as usize
		           },
		           8usize,
		           concat!(
			"Offset of field: ",
			stringify!(LL_I2C_InitTypeDef),
			"::",
			stringify!(AnalogFilter)
		)
		);
	}
	test_field_AnalogFilter();
	fn test_field_DigitalFilter() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_I2C_InitTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).DigitalFilter) as usize - ptr as usize
		           },
		           12usize,
		           concat!(
			"Offset of field: ",
			stringify!(LL_I2C_InitTypeDef),
			"::",
			stringify!(DigitalFilter)
		)
		);
	}
	test_field_DigitalFilter();
	fn test_field_OwnAddress1() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_I2C_InitTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).OwnAddress1) as usize - ptr as usize
		           },
		           16usize,
		           concat!(
			"Offset of field: ",
			stringify!(LL_I2C_InitTypeDef),
			"::",
			stringify!(OwnAddress1)
		)
		);
	}
	test_field_OwnAddress1();
	fn test_field_TypeAcknowledge() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_I2C_InitTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).TypeAcknowledge) as usize - ptr as usize
		           },
		           20usize,
		           concat!(
			"Offset of field: ",
			stringify!(LL_I2C_InitTypeDef),
			"::",
			stringify!(TypeAcknowledge)
		)
		);
	}
	test_field_TypeAcknowledge();
	fn test_field_OwnAddrSize() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_I2C_InitTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).OwnAddrSize) as usize - ptr as usize
		           },
		           24usize,
		           concat!(
			"Offset of field: ",
			stringify!(LL_I2C_InitTypeDef),
			"::",
			stringify!(OwnAddrSize)
		)
		);
	}
	test_field_OwnAddrSize();
}
extern "C" {
	#[doc = " @defgroup I2C_LL_EF_Init Initialization and de-initialization functions"]
	#[doc = " @{"]
	pub fn LL_I2C_Init(I2Cx: *mut I2C_TypeDef, I2C_InitStruct: *mut LL_I2C_InitTypeDef) -> ErrorStatus;
}
extern "C" {
	pub fn LL_I2C_DeInit(I2Cx: *mut I2C_TypeDef) -> ErrorStatus;
}
extern "C" {
	pub fn LL_I2C_StructInit(I2C_InitStruct: *mut LL_I2C_InitTypeDef);
}
#[repr(u32)]
#[non_exhaustive]
#[doc = " FuriHal i2c bus states"]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum FuriHalI2cBusEvent {
	#[doc = "< Bus initialization event, called on system start"]
	FuriHalI2cBusEventInit = 0,
	#[doc = "< Bus deinitialization event, called on system stop"]
	FuriHalI2cBusEventDeinit = 1,
	#[doc = "< Bus lock event, called before activation"]
	FuriHalI2cBusEventLock = 2,
	#[doc = "< Bus unlock event, called after deactivation"]
	FuriHalI2cBusEventUnlock = 3,
	#[doc = "< Bus activation event, called before handle activation"]
	FuriHalI2cBusEventActivate = 4,
	#[doc = "< Bus deactivation event, called after handle deactivation"]
	FuriHalI2cBusEventDeactivate = 5,
}
#[doc = " FuriHal i2c bus event callback"]
pub type FuriHalI2cBusEventCallback =
	::core::option::Option<unsafe extern "C" fn(bus: *mut FuriHalI2cBus, event: FuriHalI2cBusEvent)>;
#[doc = " FuriHal i2c bus"]
#[repr(C)]
pub struct FuriHalI2cBus {
	pub i2c: *mut I2C_TypeDef,
	pub current_handle: *mut FuriHalI2cBusHandle,
	pub callback: FuriHalI2cBusEventCallback,
}
#[test]
fn bindgen_test_layout_FuriHalI2cBus() {
	assert_eq!(
	           ::core::mem::size_of::<FuriHalI2cBus>(),
	           12usize,
	           concat!("Size of: ", stringify!(FuriHalI2cBus))
	);
	assert_eq!(
	           ::core::mem::align_of::<FuriHalI2cBus>(),
	           4usize,
	           concat!("Alignment of ", stringify!(FuriHalI2cBus))
	);
	fn test_field_i2c() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<FuriHalI2cBus>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).i2c) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(FuriHalI2cBus), "::", stringify!(i2c))
		);
	}
	test_field_i2c();
	fn test_field_current_handle() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<FuriHalI2cBus>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).current_handle) as usize - ptr as usize
		           },
		           4usize,
		           concat!(
			"Offset of field: ",
			stringify!(FuriHalI2cBus),
			"::",
			stringify!(current_handle)
		)
		);
	}
	test_field_current_handle();
	fn test_field_callback() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<FuriHalI2cBus>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).callback) as usize - ptr as usize
		           },
		           8usize,
		           concat!("Offset of field: ", stringify!(FuriHalI2cBus), "::", stringify!(callback))
		);
	}
	test_field_callback();
}
#[repr(u32)]
#[non_exhaustive]
#[doc = " FuriHal i2c handle states"]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum FuriHalI2cBusHandleEvent {
	#[doc = "< Handle activate: connect gpio and apply bus config"]
	FuriHalI2cBusHandleEventActivate = 0,
	#[doc = "< Handle deactivate: disconnect gpio and reset bus config"]
	FuriHalI2cBusHandleEventDeactivate = 1,
}
#[doc = " FuriHal i2c handle event callback"]
pub type FuriHalI2cBusHandleEventCallback =
	::core::option::Option<unsafe extern "C" fn(handle: *mut FuriHalI2cBusHandle, event: FuriHalI2cBusHandleEvent)>;
#[doc = " FuriHal i2c handle"]
#[repr(C)]
pub struct FuriHalI2cBusHandle {
	pub bus: *mut FuriHalI2cBus,
	pub callback: FuriHalI2cBusHandleEventCallback,
}
#[test]
fn bindgen_test_layout_FuriHalI2cBusHandle() {
	assert_eq!(
	           ::core::mem::size_of::<FuriHalI2cBusHandle>(),
	           8usize,
	           concat!("Size of: ", stringify!(FuriHalI2cBusHandle))
	);
	assert_eq!(
	           ::core::mem::align_of::<FuriHalI2cBusHandle>(),
	           4usize,
	           concat!("Alignment of ", stringify!(FuriHalI2cBusHandle))
	);
	fn test_field_bus() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<FuriHalI2cBusHandle>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).bus) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(FuriHalI2cBusHandle), "::", stringify!(bus))
		);
	}
	test_field_bus();
	fn test_field_callback() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<FuriHalI2cBusHandle>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).callback) as usize - ptr as usize
		           },
		           4usize,
		           concat!(
			"Offset of field: ",
			stringify!(FuriHalI2cBusHandle),
			"::",
			stringify!(callback)
		)
		);
	}
	test_field_callback();
}
extern "C" {
	#[doc = " Internal(power) i2c bus, I2C1, under reset when not used"]
	pub static mut furi_hal_i2c_bus_power: FuriHalI2cBus;
}
extern "C" {
	#[doc = " External i2c bus, I2C3, under reset when not used"]
	pub static mut furi_hal_i2c_bus_external: FuriHalI2cBus;
}
extern "C" {
	#[doc = " Handle for internal(power) i2c bus"]
	#[doc = " Bus: furi_hal_i2c_bus_external"]
	#[doc = " Pins: PA9(SCL) / PA10(SDA), float on release"]
	#[doc = " Params: 400khz"]
	pub static mut furi_hal_i2c_handle_power: FuriHalI2cBusHandle;
}
extern "C" {
	#[doc = " Handle for external i2c bus"]
	#[doc = " Bus: furi_hal_i2c_bus_external"]
	#[doc = " Pins: PC0(SCL) / PC1(SDA), float on release"]
	#[doc = " Params: 100khz"]
	pub static mut furi_hal_i2c_handle_external: FuriHalI2cBusHandle;
}
#[doc = " @brief  LPTIM Init structure definition"]
#[repr(C)]
pub struct LL_LPTIM_InitTypeDef {
	#[doc = "< Specifies the source of the clock used by the LPTIM instance."]
	#[doc = "This parameter can be a value of @ref LPTIM_LL_EC_CLK_SOURCE."]
	#[doc = ""]
	#[doc = "This feature can be modified afterwards using unitary"]
	#[doc = "function @ref LL_LPTIM_SetClockSource()."]
	pub ClockSource: u32,
	#[doc = "< Specifies the prescaler division ratio."]
	#[doc = "This parameter can be a value of @ref LPTIM_LL_EC_PRESCALER."]
	#[doc = ""]
	#[doc = "This feature can be modified afterwards using using unitary"]
	#[doc = "function @ref LL_LPTIM_SetPrescaler()."]
	pub Prescaler: u32,
	#[doc = "< Specifies the waveform shape."]
	#[doc = "This parameter can be a value of @ref LPTIM_LL_EC_OUTPUT_WAVEFORM."]
	#[doc = ""]
	#[doc = "This feature can be modified afterwards using unitary"]
	#[doc = "function @ref LL_LPTIM_ConfigOutput()."]
	pub Waveform: u32,
	#[doc = "< Specifies waveform polarity."]
	#[doc = "This parameter can be a value of @ref LPTIM_LL_EC_OUTPUT_POLARITY."]
	#[doc = ""]
	#[doc = "This feature can be modified afterwards using unitary"]
	#[doc = "function @ref LL_LPTIM_ConfigOutput()."]
	pub Polarity: u32,
}
#[test]
fn bindgen_test_layout_LL_LPTIM_InitTypeDef() {
	assert_eq!(
	           ::core::mem::size_of::<LL_LPTIM_InitTypeDef>(),
	           16usize,
	           concat!("Size of: ", stringify!(LL_LPTIM_InitTypeDef))
	);
	assert_eq!(
	           ::core::mem::align_of::<LL_LPTIM_InitTypeDef>(),
	           4usize,
	           concat!("Alignment of ", stringify!(LL_LPTIM_InitTypeDef))
	);
	fn test_field_ClockSource() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_LPTIM_InitTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).ClockSource) as usize - ptr as usize
		           },
		           0usize,
		           concat!(
			"Offset of field: ",
			stringify!(LL_LPTIM_InitTypeDef),
			"::",
			stringify!(ClockSource)
		)
		);
	}
	test_field_ClockSource();
	fn test_field_Prescaler() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_LPTIM_InitTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).Prescaler) as usize - ptr as usize
		           },
		           4usize,
		           concat!(
			"Offset of field: ",
			stringify!(LL_LPTIM_InitTypeDef),
			"::",
			stringify!(Prescaler)
		)
		);
	}
	test_field_Prescaler();
	fn test_field_Waveform() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_LPTIM_InitTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).Waveform) as usize - ptr as usize
		           },
		           8usize,
		           concat!(
			"Offset of field: ",
			stringify!(LL_LPTIM_InitTypeDef),
			"::",
			stringify!(Waveform)
		)
		);
	}
	test_field_Waveform();
	fn test_field_Polarity() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_LPTIM_InitTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).Polarity) as usize - ptr as usize
		           },
		           12usize,
		           concat!(
			"Offset of field: ",
			stringify!(LL_LPTIM_InitTypeDef),
			"::",
			stringify!(Polarity)
		)
		);
	}
	test_field_Polarity();
}
extern "C" {
	#[doc = " @defgroup LPTIM_LL_EF_Init Initialisation and deinitialisation functions"]
	#[doc = " @{"]
	pub fn LL_LPTIM_DeInit(LPTIMx: *mut LPTIM_TypeDef) -> ErrorStatus;
}
extern "C" {
	pub fn LL_LPTIM_StructInit(LPTIM_InitStruct: *mut LL_LPTIM_InitTypeDef);
}
extern "C" {
	pub fn LL_LPTIM_Init(LPTIMx: *mut LPTIM_TypeDef, LPTIM_InitStruct: *mut LL_LPTIM_InitTypeDef) -> ErrorStatus;
}
extern "C" {
	pub fn LL_LPTIM_Disable(LPTIMx: *mut LPTIM_TypeDef);
}
#[doc = " @brief  TIM Time Base configuration structure definition."]
#[repr(C)]
pub struct LL_TIM_InitTypeDef {
	#[doc = "< Specifies the prescaler value used to divide the TIM clock."]
	#[doc = "This parameter can be a number between Min_Data=0x0000 and Max_Data=0xFFFF."]
	#[doc = ""]
	#[doc = "This feature can be modified afterwards using unitary function"]
	#[doc = "@ref LL_TIM_SetPrescaler()."]
	pub Prescaler: u16,
	#[doc = "< Specifies the counter mode."]
	#[doc = "This parameter can be a value of @ref TIM_LL_EC_COUNTERMODE."]
	#[doc = ""]
	#[doc = "This feature can be modified afterwards using unitary function"]
	#[doc = "@ref LL_TIM_SetCounterMode()."]
	pub CounterMode: u32,
	#[doc = "< Specifies the auto reload value to be loaded into the active"]
	#[doc = "Auto-Reload Register at the next update event."]
	#[doc = "This parameter must be a number between Min_Data=0x0000 and Max_Data=0xFFFF."]
	#[doc = "Some timer instances may support 32 bits counters. In that case this parameter must"]
	#[doc = "be a number between 0x0000 and 0xFFFFFFFF."]
	#[doc = ""]
	#[doc = "This feature can be modified afterwards using unitary function"]
	#[doc = "@ref LL_TIM_SetAutoReload()."]
	pub Autoreload: u32,
	#[doc = "< Specifies the clock division."]
	#[doc = "This parameter can be a value of @ref TIM_LL_EC_CLOCKDIVISION."]
	#[doc = ""]
	#[doc = "This feature can be modified afterwards using unitary function"]
	#[doc = "@ref LL_TIM_SetClockDivision()."]
	pub ClockDivision: u32,
	#[doc = "< Specifies the repetition counter value. Each time the RCR downcounter"]
	#[doc = "reaches zero, an update event is generated and counting restarts"]
	#[doc = "from the RCR value (N)."]
	#[doc = "This means in PWM mode that (N+1) corresponds to:"]
	#[doc = "- the number of PWM periods in edge-aligned mode"]
	#[doc = "- the number of half PWM period in center-aligned mode"]
	#[doc = "GP timers: this parameter must be a number between Min_Data = 0x00 and"]
	#[doc = "Max_Data = 0xFF."]
	#[doc = "Advanced timers: this parameter must be a number between Min_Data = 0x0000 and"]
	#[doc = "Max_Data = 0xFFFF."]
	#[doc = ""]
	#[doc = "This feature can be modified afterwards using unitary function"]
	#[doc = "@ref LL_TIM_SetRepetitionCounter()."]
	pub RepetitionCounter: u32,
}
#[test]
fn bindgen_test_layout_LL_TIM_InitTypeDef() {
	assert_eq!(
	           ::core::mem::size_of::<LL_TIM_InitTypeDef>(),
	           20usize,
	           concat!("Size of: ", stringify!(LL_TIM_InitTypeDef))
	);
	assert_eq!(
	           ::core::mem::align_of::<LL_TIM_InitTypeDef>(),
	           4usize,
	           concat!("Alignment of ", stringify!(LL_TIM_InitTypeDef))
	);
	fn test_field_Prescaler() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_TIM_InitTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).Prescaler) as usize - ptr as usize
		           },
		           0usize,
		           concat!(
			"Offset of field: ",
			stringify!(LL_TIM_InitTypeDef),
			"::",
			stringify!(Prescaler)
		)
		);
	}
	test_field_Prescaler();
	fn test_field_CounterMode() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_TIM_InitTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).CounterMode) as usize - ptr as usize
		           },
		           4usize,
		           concat!(
			"Offset of field: ",
			stringify!(LL_TIM_InitTypeDef),
			"::",
			stringify!(CounterMode)
		)
		);
	}
	test_field_CounterMode();
	fn test_field_Autoreload() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_TIM_InitTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).Autoreload) as usize - ptr as usize
		           },
		           8usize,
		           concat!(
			"Offset of field: ",
			stringify!(LL_TIM_InitTypeDef),
			"::",
			stringify!(Autoreload)
		)
		);
	}
	test_field_Autoreload();
	fn test_field_ClockDivision() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_TIM_InitTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).ClockDivision) as usize - ptr as usize
		           },
		           12usize,
		           concat!(
			"Offset of field: ",
			stringify!(LL_TIM_InitTypeDef),
			"::",
			stringify!(ClockDivision)
		)
		);
	}
	test_field_ClockDivision();
	fn test_field_RepetitionCounter() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_TIM_InitTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).RepetitionCounter) as usize - ptr as usize
		           },
		           16usize,
		           concat!(
			"Offset of field: ",
			stringify!(LL_TIM_InitTypeDef),
			"::",
			stringify!(RepetitionCounter)
		)
		);
	}
	test_field_RepetitionCounter();
}
#[doc = " @brief  TIM Output Compare configuration structure definition."]
#[repr(C)]
pub struct LL_TIM_OC_InitTypeDef {
	#[doc = "< Specifies the output mode."]
	#[doc = "This parameter can be a value of @ref TIM_LL_EC_OCMODE."]
	#[doc = ""]
	#[doc = "This feature can be modified afterwards using unitary function"]
	#[doc = "@ref LL_TIM_OC_SetMode()."]
	pub OCMode: u32,
	#[doc = "< Specifies the TIM Output Compare state."]
	#[doc = "This parameter can be a value of @ref TIM_LL_EC_OCSTATE."]
	#[doc = ""]
	#[doc = "This feature can be modified afterwards using unitary functions"]
	#[doc = "@ref LL_TIM_CC_EnableChannel() or @ref LL_TIM_CC_DisableChannel()."]
	pub OCState: u32,
	#[doc = "< Specifies the TIM complementary Output Compare state."]
	#[doc = "This parameter can be a value of @ref TIM_LL_EC_OCSTATE."]
	#[doc = ""]
	#[doc = "This feature can be modified afterwards using unitary functions"]
	#[doc = "@ref LL_TIM_CC_EnableChannel() or @ref LL_TIM_CC_DisableChannel()."]
	pub OCNState: u32,
	#[doc = "< Specifies the Compare value to be loaded into the Capture Compare Register."]
	#[doc = "This parameter can be a number between Min_Data=0x0000 and Max_Data=0xFFFF."]
	#[doc = ""]
	#[doc = "This feature can be modified afterwards using unitary function"]
	#[doc = "LL_TIM_OC_SetCompareCHx (x=1..6)."]
	pub CompareValue: u32,
	#[doc = "< Specifies the output polarity."]
	#[doc = "This parameter can be a value of @ref TIM_LL_EC_OCPOLARITY."]
	#[doc = ""]
	#[doc = "This feature can be modified afterwards using unitary function"]
	#[doc = "@ref LL_TIM_OC_SetPolarity()."]
	pub OCPolarity: u32,
	#[doc = "< Specifies the complementary output polarity."]
	#[doc = "This parameter can be a value of @ref TIM_LL_EC_OCPOLARITY."]
	#[doc = ""]
	#[doc = "This feature can be modified afterwards using unitary function"]
	#[doc = "@ref LL_TIM_OC_SetPolarity()."]
	pub OCNPolarity: u32,
	#[doc = "< Specifies the TIM Output Compare pin state during Idle state."]
	#[doc = "This parameter can be a value of @ref TIM_LL_EC_OCIDLESTATE."]
	#[doc = ""]
	#[doc = "This feature can be modified afterwards using unitary function"]
	#[doc = "@ref LL_TIM_OC_SetIdleState()."]
	pub OCIdleState: u32,
	#[doc = "< Specifies the TIM Output Compare pin state during Idle state."]
	#[doc = "This parameter can be a value of @ref TIM_LL_EC_OCIDLESTATE."]
	#[doc = ""]
	#[doc = "This feature can be modified afterwards using unitary function"]
	#[doc = "@ref LL_TIM_OC_SetIdleState()."]
	pub OCNIdleState: u32,
}
#[test]
fn bindgen_test_layout_LL_TIM_OC_InitTypeDef() {
	assert_eq!(
	           ::core::mem::size_of::<LL_TIM_OC_InitTypeDef>(),
	           32usize,
	           concat!("Size of: ", stringify!(LL_TIM_OC_InitTypeDef))
	);
	assert_eq!(
	           ::core::mem::align_of::<LL_TIM_OC_InitTypeDef>(),
	           4usize,
	           concat!("Alignment of ", stringify!(LL_TIM_OC_InitTypeDef))
	);
	fn test_field_OCMode() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_TIM_OC_InitTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).OCMode) as usize - ptr as usize
		           },
		           0usize,
		           concat!(
			"Offset of field: ",
			stringify!(LL_TIM_OC_InitTypeDef),
			"::",
			stringify!(OCMode)
		)
		);
	}
	test_field_OCMode();
	fn test_field_OCState() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_TIM_OC_InitTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).OCState) as usize - ptr as usize
		           },
		           4usize,
		           concat!(
			"Offset of field: ",
			stringify!(LL_TIM_OC_InitTypeDef),
			"::",
			stringify!(OCState)
		)
		);
	}
	test_field_OCState();
	fn test_field_OCNState() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_TIM_OC_InitTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).OCNState) as usize - ptr as usize
		           },
		           8usize,
		           concat!(
			"Offset of field: ",
			stringify!(LL_TIM_OC_InitTypeDef),
			"::",
			stringify!(OCNState)
		)
		);
	}
	test_field_OCNState();
	fn test_field_CompareValue() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_TIM_OC_InitTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).CompareValue) as usize - ptr as usize
		           },
		           12usize,
		           concat!(
			"Offset of field: ",
			stringify!(LL_TIM_OC_InitTypeDef),
			"::",
			stringify!(CompareValue)
		)
		);
	}
	test_field_CompareValue();
	fn test_field_OCPolarity() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_TIM_OC_InitTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).OCPolarity) as usize - ptr as usize
		           },
		           16usize,
		           concat!(
			"Offset of field: ",
			stringify!(LL_TIM_OC_InitTypeDef),
			"::",
			stringify!(OCPolarity)
		)
		);
	}
	test_field_OCPolarity();
	fn test_field_OCNPolarity() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_TIM_OC_InitTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).OCNPolarity) as usize - ptr as usize
		           },
		           20usize,
		           concat!(
			"Offset of field: ",
			stringify!(LL_TIM_OC_InitTypeDef),
			"::",
			stringify!(OCNPolarity)
		)
		);
	}
	test_field_OCNPolarity();
	fn test_field_OCIdleState() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_TIM_OC_InitTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).OCIdleState) as usize - ptr as usize
		           },
		           24usize,
		           concat!(
			"Offset of field: ",
			stringify!(LL_TIM_OC_InitTypeDef),
			"::",
			stringify!(OCIdleState)
		)
		);
	}
	test_field_OCIdleState();
	fn test_field_OCNIdleState() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_TIM_OC_InitTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).OCNIdleState) as usize - ptr as usize
		           },
		           28usize,
		           concat!(
			"Offset of field: ",
			stringify!(LL_TIM_OC_InitTypeDef),
			"::",
			stringify!(OCNIdleState)
		)
		);
	}
	test_field_OCNIdleState();
}
#[doc = " @brief  TIM Input Capture configuration structure definition."]
#[repr(C)]
pub struct LL_TIM_IC_InitTypeDef {
	#[doc = "< Specifies the active edge of the input signal."]
	#[doc = "This parameter can be a value of @ref TIM_LL_EC_IC_POLARITY."]
	#[doc = ""]
	#[doc = "This feature can be modified afterwards using unitary function"]
	#[doc = "@ref LL_TIM_IC_SetPolarity()."]
	pub ICPolarity: u32,
	#[doc = "< Specifies the input."]
	#[doc = "This parameter can be a value of @ref TIM_LL_EC_ACTIVEINPUT."]
	#[doc = ""]
	#[doc = "This feature can be modified afterwards using unitary function"]
	#[doc = "@ref LL_TIM_IC_SetActiveInput()."]
	pub ICActiveInput: u32,
	#[doc = "< Specifies the Input Capture Prescaler."]
	#[doc = "This parameter can be a value of @ref TIM_LL_EC_ICPSC."]
	#[doc = ""]
	#[doc = "This feature can be modified afterwards using unitary function"]
	#[doc = "@ref LL_TIM_IC_SetPrescaler()."]
	pub ICPrescaler: u32,
	#[doc = "< Specifies the input capture filter."]
	#[doc = "This parameter can be a value of @ref TIM_LL_EC_IC_FILTER."]
	#[doc = ""]
	#[doc = "This feature can be modified afterwards using unitary function"]
	#[doc = "@ref LL_TIM_IC_SetFilter()."]
	pub ICFilter: u32,
}
#[test]
fn bindgen_test_layout_LL_TIM_IC_InitTypeDef() {
	assert_eq!(
	           ::core::mem::size_of::<LL_TIM_IC_InitTypeDef>(),
	           16usize,
	           concat!("Size of: ", stringify!(LL_TIM_IC_InitTypeDef))
	);
	assert_eq!(
	           ::core::mem::align_of::<LL_TIM_IC_InitTypeDef>(),
	           4usize,
	           concat!("Alignment of ", stringify!(LL_TIM_IC_InitTypeDef))
	);
	fn test_field_ICPolarity() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_TIM_IC_InitTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).ICPolarity) as usize - ptr as usize
		           },
		           0usize,
		           concat!(
			"Offset of field: ",
			stringify!(LL_TIM_IC_InitTypeDef),
			"::",
			stringify!(ICPolarity)
		)
		);
	}
	test_field_ICPolarity();
	fn test_field_ICActiveInput() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_TIM_IC_InitTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).ICActiveInput) as usize - ptr as usize
		           },
		           4usize,
		           concat!(
			"Offset of field: ",
			stringify!(LL_TIM_IC_InitTypeDef),
			"::",
			stringify!(ICActiveInput)
		)
		);
	}
	test_field_ICActiveInput();
	fn test_field_ICPrescaler() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_TIM_IC_InitTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).ICPrescaler) as usize - ptr as usize
		           },
		           8usize,
		           concat!(
			"Offset of field: ",
			stringify!(LL_TIM_IC_InitTypeDef),
			"::",
			stringify!(ICPrescaler)
		)
		);
	}
	test_field_ICPrescaler();
	fn test_field_ICFilter() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_TIM_IC_InitTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).ICFilter) as usize - ptr as usize
		           },
		           12usize,
		           concat!(
			"Offset of field: ",
			stringify!(LL_TIM_IC_InitTypeDef),
			"::",
			stringify!(ICFilter)
		)
		);
	}
	test_field_ICFilter();
}
#[doc = " @brief  TIM Encoder interface configuration structure definition."]
#[repr(C)]
pub struct LL_TIM_ENCODER_InitTypeDef {
	#[doc = "< Specifies the encoder resolution (x2 or x4)."]
	#[doc = "This parameter can be a value of @ref TIM_LL_EC_ENCODERMODE."]
	#[doc = ""]
	#[doc = "This feature can be modified afterwards using unitary function"]
	#[doc = "@ref LL_TIM_SetEncoderMode()."]
	pub EncoderMode: u32,
	#[doc = "< Specifies the active edge of TI1 input."]
	#[doc = "This parameter can be a value of @ref TIM_LL_EC_IC_POLARITY."]
	#[doc = ""]
	#[doc = "This feature can be modified afterwards using unitary function"]
	#[doc = "@ref LL_TIM_IC_SetPolarity()."]
	pub IC1Polarity: u32,
	#[doc = "< Specifies the TI1 input source"]
	#[doc = "This parameter can be a value of @ref TIM_LL_EC_ACTIVEINPUT."]
	#[doc = ""]
	#[doc = "This feature can be modified afterwards using unitary function"]
	#[doc = "@ref LL_TIM_IC_SetActiveInput()."]
	pub IC1ActiveInput: u32,
	#[doc = "< Specifies the TI1 input prescaler value."]
	#[doc = "This parameter can be a value of @ref TIM_LL_EC_ICPSC."]
	#[doc = ""]
	#[doc = "This feature can be modified afterwards using unitary function"]
	#[doc = "@ref LL_TIM_IC_SetPrescaler()."]
	pub IC1Prescaler: u32,
	#[doc = "< Specifies the TI1 input filter."]
	#[doc = "This parameter can be a value of @ref TIM_LL_EC_IC_FILTER."]
	#[doc = ""]
	#[doc = "This feature can be modified afterwards using unitary function"]
	#[doc = "@ref LL_TIM_IC_SetFilter()."]
	pub IC1Filter: u32,
	#[doc = "< Specifies the active edge of TI2 input."]
	#[doc = "This parameter can be a value of @ref TIM_LL_EC_IC_POLARITY."]
	#[doc = ""]
	#[doc = "This feature can be modified afterwards using unitary function"]
	#[doc = "@ref LL_TIM_IC_SetPolarity()."]
	pub IC2Polarity: u32,
	#[doc = "< Specifies the TI2 input source"]
	#[doc = "This parameter can be a value of @ref TIM_LL_EC_ACTIVEINPUT."]
	#[doc = ""]
	#[doc = "This feature can be modified afterwards using unitary function"]
	#[doc = "@ref LL_TIM_IC_SetActiveInput()."]
	pub IC2ActiveInput: u32,
	#[doc = "< Specifies the TI2 input prescaler value."]
	#[doc = "This parameter can be a value of @ref TIM_LL_EC_ICPSC."]
	#[doc = ""]
	#[doc = "This feature can be modified afterwards using unitary function"]
	#[doc = "@ref LL_TIM_IC_SetPrescaler()."]
	pub IC2Prescaler: u32,
	#[doc = "< Specifies the TI2 input filter."]
	#[doc = "This parameter can be a value of @ref TIM_LL_EC_IC_FILTER."]
	#[doc = ""]
	#[doc = "This feature can be modified afterwards using unitary function"]
	#[doc = "@ref LL_TIM_IC_SetFilter()."]
	pub IC2Filter: u32,
}
#[test]
fn bindgen_test_layout_LL_TIM_ENCODER_InitTypeDef() {
	assert_eq!(
	           ::core::mem::size_of::<LL_TIM_ENCODER_InitTypeDef>(),
	           36usize,
	           concat!("Size of: ", stringify!(LL_TIM_ENCODER_InitTypeDef))
	);
	assert_eq!(
	           ::core::mem::align_of::<LL_TIM_ENCODER_InitTypeDef>(),
	           4usize,
	           concat!("Alignment of ", stringify!(LL_TIM_ENCODER_InitTypeDef))
	);
	fn test_field_EncoderMode() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_TIM_ENCODER_InitTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).EncoderMode) as usize - ptr as usize
		           },
		           0usize,
		           concat!(
			"Offset of field: ",
			stringify!(LL_TIM_ENCODER_InitTypeDef),
			"::",
			stringify!(EncoderMode)
		)
		);
	}
	test_field_EncoderMode();
	fn test_field_IC1Polarity() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_TIM_ENCODER_InitTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).IC1Polarity) as usize - ptr as usize
		           },
		           4usize,
		           concat!(
			"Offset of field: ",
			stringify!(LL_TIM_ENCODER_InitTypeDef),
			"::",
			stringify!(IC1Polarity)
		)
		);
	}
	test_field_IC1Polarity();
	fn test_field_IC1ActiveInput() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_TIM_ENCODER_InitTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).IC1ActiveInput) as usize - ptr as usize
		           },
		           8usize,
		           concat!(
			"Offset of field: ",
			stringify!(LL_TIM_ENCODER_InitTypeDef),
			"::",
			stringify!(IC1ActiveInput)
		)
		);
	}
	test_field_IC1ActiveInput();
	fn test_field_IC1Prescaler() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_TIM_ENCODER_InitTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).IC1Prescaler) as usize - ptr as usize
		           },
		           12usize,
		           concat!(
			"Offset of field: ",
			stringify!(LL_TIM_ENCODER_InitTypeDef),
			"::",
			stringify!(IC1Prescaler)
		)
		);
	}
	test_field_IC1Prescaler();
	fn test_field_IC1Filter() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_TIM_ENCODER_InitTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).IC1Filter) as usize - ptr as usize
		           },
		           16usize,
		           concat!(
			"Offset of field: ",
			stringify!(LL_TIM_ENCODER_InitTypeDef),
			"::",
			stringify!(IC1Filter)
		)
		);
	}
	test_field_IC1Filter();
	fn test_field_IC2Polarity() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_TIM_ENCODER_InitTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).IC2Polarity) as usize - ptr as usize
		           },
		           20usize,
		           concat!(
			"Offset of field: ",
			stringify!(LL_TIM_ENCODER_InitTypeDef),
			"::",
			stringify!(IC2Polarity)
		)
		);
	}
	test_field_IC2Polarity();
	fn test_field_IC2ActiveInput() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_TIM_ENCODER_InitTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).IC2ActiveInput) as usize - ptr as usize
		           },
		           24usize,
		           concat!(
			"Offset of field: ",
			stringify!(LL_TIM_ENCODER_InitTypeDef),
			"::",
			stringify!(IC2ActiveInput)
		)
		);
	}
	test_field_IC2ActiveInput();
	fn test_field_IC2Prescaler() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_TIM_ENCODER_InitTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).IC2Prescaler) as usize - ptr as usize
		           },
		           28usize,
		           concat!(
			"Offset of field: ",
			stringify!(LL_TIM_ENCODER_InitTypeDef),
			"::",
			stringify!(IC2Prescaler)
		)
		);
	}
	test_field_IC2Prescaler();
	fn test_field_IC2Filter() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_TIM_ENCODER_InitTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).IC2Filter) as usize - ptr as usize
		           },
		           32usize,
		           concat!(
			"Offset of field: ",
			stringify!(LL_TIM_ENCODER_InitTypeDef),
			"::",
			stringify!(IC2Filter)
		)
		);
	}
	test_field_IC2Filter();
}
#[doc = " @brief  TIM Hall sensor interface configuration structure definition."]
#[repr(C)]
pub struct LL_TIM_HALLSENSOR_InitTypeDef {
	#[doc = "< Specifies the active edge of TI1 input."]
	#[doc = "This parameter can be a value of @ref TIM_LL_EC_IC_POLARITY."]
	#[doc = ""]
	#[doc = "This feature can be modified afterwards using unitary function"]
	#[doc = "@ref LL_TIM_IC_SetPolarity()."]
	pub IC1Polarity: u32,
	#[doc = "< Specifies the TI1 input prescaler value."]
	#[doc = "Prescaler must be set to get a maximum counter period longer than the"]
	#[doc = "time interval between 2 consecutive changes on the Hall inputs."]
	#[doc = "This parameter can be a value of @ref TIM_LL_EC_ICPSC."]
	#[doc = ""]
	#[doc = "This feature can be modified afterwards using unitary function"]
	#[doc = "@ref LL_TIM_IC_SetPrescaler()."]
	pub IC1Prescaler: u32,
	#[doc = "< Specifies the TI1 input filter."]
	#[doc = "This parameter can be a value of"]
	#[doc = "@ref TIM_LL_EC_IC_FILTER."]
	#[doc = ""]
	#[doc = "This feature can be modified afterwards using unitary function"]
	#[doc = "@ref LL_TIM_IC_SetFilter()."]
	pub IC1Filter: u32,
	#[doc = "< Specifies the compare value to be loaded into the Capture Compare Register."]
	#[doc = "A positive pulse (TRGO event) is generated with a programmable delay every time"]
	#[doc = "a change occurs on the Hall inputs."]
	#[doc = "This parameter can be a number between Min_Data = 0x0000 and Max_Data = 0xFFFF."]
	#[doc = ""]
	#[doc = "This feature can be modified afterwards using unitary function"]
	#[doc = "@ref LL_TIM_OC_SetCompareCH2()."]
	pub CommutationDelay: u32,
}
#[test]
fn bindgen_test_layout_LL_TIM_HALLSENSOR_InitTypeDef() {
	assert_eq!(
	           ::core::mem::size_of::<LL_TIM_HALLSENSOR_InitTypeDef>(),
	           16usize,
	           concat!("Size of: ", stringify!(LL_TIM_HALLSENSOR_InitTypeDef))
	);
	assert_eq!(
	           ::core::mem::align_of::<LL_TIM_HALLSENSOR_InitTypeDef>(),
	           4usize,
	           concat!("Alignment of ", stringify!(LL_TIM_HALLSENSOR_InitTypeDef))
	);
	fn test_field_IC1Polarity() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_TIM_HALLSENSOR_InitTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).IC1Polarity) as usize - ptr as usize
		           },
		           0usize,
		           concat!(
			"Offset of field: ",
			stringify!(LL_TIM_HALLSENSOR_InitTypeDef),
			"::",
			stringify!(IC1Polarity)
		)
		);
	}
	test_field_IC1Polarity();
	fn test_field_IC1Prescaler() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_TIM_HALLSENSOR_InitTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).IC1Prescaler) as usize - ptr as usize
		           },
		           4usize,
		           concat!(
			"Offset of field: ",
			stringify!(LL_TIM_HALLSENSOR_InitTypeDef),
			"::",
			stringify!(IC1Prescaler)
		)
		);
	}
	test_field_IC1Prescaler();
	fn test_field_IC1Filter() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_TIM_HALLSENSOR_InitTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).IC1Filter) as usize - ptr as usize
		           },
		           8usize,
		           concat!(
			"Offset of field: ",
			stringify!(LL_TIM_HALLSENSOR_InitTypeDef),
			"::",
			stringify!(IC1Filter)
		)
		);
	}
	test_field_IC1Filter();
	fn test_field_CommutationDelay() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_TIM_HALLSENSOR_InitTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).CommutationDelay) as usize - ptr as usize
		           },
		           12usize,
		           concat!(
			"Offset of field: ",
			stringify!(LL_TIM_HALLSENSOR_InitTypeDef),
			"::",
			stringify!(CommutationDelay)
		)
		);
	}
	test_field_CommutationDelay();
}
#[doc = " @brief  BDTR (Break and Dead Time) structure definition"]
#[repr(C)]
pub struct LL_TIM_BDTR_InitTypeDef {
	#[doc = "< Specifies the Off-State selection used in Run mode."]
	#[doc = "This parameter can be a value of @ref TIM_LL_EC_OSSR"]
	#[doc = ""]
	#[doc = "This feature can be modified afterwards using unitary function"]
	#[doc = "@ref LL_TIM_SetOffStates()"]
	#[doc = ""]
	#[doc = "@note This bit-field cannot be modified as long as LOCK level 2 has been"]
	#[doc = "programmed."]
	pub OSSRState: u32,
	#[doc = "< Specifies the Off-State used in Idle state."]
	#[doc = "This parameter can be a value of @ref TIM_LL_EC_OSSI"]
	#[doc = ""]
	#[doc = "This feature can be modified afterwards using unitary function"]
	#[doc = "@ref LL_TIM_SetOffStates()"]
	#[doc = ""]
	#[doc = "@note This bit-field cannot be modified as long as LOCK level 2 has been"]
	#[doc = "programmed."]
	pub OSSIState: u32,
	#[doc = "< Specifies the LOCK level parameters."]
	#[doc = "This parameter can be a value of @ref TIM_LL_EC_LOCKLEVEL"]
	#[doc = ""]
	#[doc = "@note The LOCK bits can be written only once after the reset. Once the TIMx_BDTR"]
	#[doc = "register has been written, their content is frozen until the next reset."]
	pub LockLevel: u32,
	#[doc = "< Specifies the delay time between the switching-off and the"]
	#[doc = "switching-on of the outputs."]
	#[doc = "This parameter can be a number between Min_Data = 0x00 and Max_Data = 0xFF."]
	#[doc = ""]
	#[doc = "This feature can be modified afterwards using unitary function"]
	#[doc = "@ref LL_TIM_OC_SetDeadTime()"]
	#[doc = ""]
	#[doc = "@note This bit-field can not be modified as long as LOCK level 1, 2 or 3 has been"]
	#[doc = "programmed."]
	pub DeadTime: u8,
	#[doc = "< Specifies whether the TIM Break input is enabled or not."]
	#[doc = "This parameter can be a value of @ref TIM_LL_EC_BREAK_ENABLE"]
	#[doc = ""]
	#[doc = "This feature can be modified afterwards using unitary functions"]
	#[doc = "@ref LL_TIM_EnableBRK() or @ref LL_TIM_DisableBRK()"]
	#[doc = ""]
	#[doc = "@note This bit-field can not be modified as long as LOCK level 1 has been"]
	#[doc = "programmed."]
	pub BreakState: u16,
	#[doc = "< Specifies the TIM Break Input pin polarity."]
	#[doc = "This parameter can be a value of @ref TIM_LL_EC_BREAK_POLARITY"]
	#[doc = ""]
	#[doc = "This feature can be modified afterwards using unitary function"]
	#[doc = "@ref LL_TIM_ConfigBRK()"]
	#[doc = ""]
	#[doc = "@note This bit-field can not be modified as long as LOCK level 1 has been"]
	#[doc = "programmed."]
	pub BreakPolarity: u32,
	#[doc = "< Specifies the TIM Break Filter."]
	#[doc = "This parameter can be a value of @ref TIM_LL_EC_BREAK_FILTER"]
	#[doc = ""]
	#[doc = "This feature can be modified afterwards using unitary function"]
	#[doc = "@ref LL_TIM_ConfigBRK()"]
	#[doc = ""]
	#[doc = "@note This bit-field can not be modified as long as LOCK level 1 has been"]
	#[doc = "programmed."]
	pub BreakFilter: u32,
	#[doc = "< Specifies the alternate function mode of the break input."]
	#[doc = "This parameter can be a value of @ref TIM_LL_EC_BREAK_AFMODE"]
	#[doc = ""]
	#[doc = "This feature can be modified afterwards using unitary functions"]
	#[doc = "@ref LL_TIM_ConfigBRK()"]
	#[doc = ""]
	#[doc = "@note Bidirectional break input is only supported by advanced timers instances."]
	#[doc = ""]
	#[doc = "@note This bit-field can not be modified as long as LOCK level 1 has been"]
	#[doc = "programmed."]
	pub BreakAFMode: u32,
	#[doc = "< Specifies whether the TIM Break2 input is enabled or not."]
	#[doc = "This parameter can be a value of @ref TIM_LL_EC_BREAK2_ENABLE"]
	#[doc = ""]
	#[doc = "This feature can be modified afterwards using unitary functions"]
	#[doc = "@ref LL_TIM_EnableBRK2() or @ref LL_TIM_DisableBRK2()"]
	#[doc = ""]
	#[doc = "@note This bit-field can not be modified as long as LOCK level 1 has been"]
	#[doc = "programmed."]
	pub Break2State: u32,
	#[doc = "< Specifies the TIM Break2 Input pin polarity."]
	#[doc = "This parameter can be a value of @ref TIM_LL_EC_BREAK2_POLARITY"]
	#[doc = ""]
	#[doc = "This feature can be modified afterwards using unitary function"]
	#[doc = "@ref LL_TIM_ConfigBRK2()"]
	#[doc = ""]
	#[doc = "@note This bit-field can not be modified as long as LOCK level 1 has been"]
	#[doc = "programmed."]
	pub Break2Polarity: u32,
	#[doc = "< Specifies the TIM Break2 Filter."]
	#[doc = "This parameter can be a value of @ref TIM_LL_EC_BREAK2_FILTER"]
	#[doc = ""]
	#[doc = "This feature can be modified afterwards using unitary function"]
	#[doc = "@ref LL_TIM_ConfigBRK2()"]
	#[doc = ""]
	#[doc = "@note This bit-field can not be modified as long as LOCK level 1 has been"]
	#[doc = "programmed."]
	pub Break2Filter: u32,
	#[doc = "< Specifies the alternate function mode of the break2 input."]
	#[doc = "This parameter can be a value of @ref TIM_LL_EC_BREAK2_AFMODE"]
	#[doc = ""]
	#[doc = "This feature can be modified afterwards using unitary functions"]
	#[doc = "@ref LL_TIM_ConfigBRK2()"]
	#[doc = ""]
	#[doc = "@note Bidirectional break input is only supported by advanced timers instances."]
	#[doc = ""]
	#[doc = "@note This bit-field can not be modified as long as LOCK level 1 has been"]
	#[doc = "programmed."]
	pub Break2AFMode: u32,
	#[doc = "< Specifies whether the TIM Automatic Output feature is enabled or not."]
	#[doc = "This parameter can be a value of @ref TIM_LL_EC_AUTOMATICOUTPUT_ENABLE"]
	#[doc = ""]
	#[doc = "This feature can be modified afterwards using unitary functions"]
	#[doc = "@ref LL_TIM_EnableAutomaticOutput() or @ref LL_TIM_DisableAutomaticOutput()"]
	#[doc = ""]
	#[doc = "@note This bit-field can not be modified as long as LOCK level 1 has been"]
	#[doc = "programmed."]
	pub AutomaticOutput: u32,
}
#[test]
fn bindgen_test_layout_LL_TIM_BDTR_InitTypeDef() {
	assert_eq!(
	           ::core::mem::size_of::<LL_TIM_BDTR_InitTypeDef>(),
	           48usize,
	           concat!("Size of: ", stringify!(LL_TIM_BDTR_InitTypeDef))
	);
	assert_eq!(
	           ::core::mem::align_of::<LL_TIM_BDTR_InitTypeDef>(),
	           4usize,
	           concat!("Alignment of ", stringify!(LL_TIM_BDTR_InitTypeDef))
	);
	fn test_field_OSSRState() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_TIM_BDTR_InitTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).OSSRState) as usize - ptr as usize
		           },
		           0usize,
		           concat!(
			"Offset of field: ",
			stringify!(LL_TIM_BDTR_InitTypeDef),
			"::",
			stringify!(OSSRState)
		)
		);
	}
	test_field_OSSRState();
	fn test_field_OSSIState() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_TIM_BDTR_InitTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).OSSIState) as usize - ptr as usize
		           },
		           4usize,
		           concat!(
			"Offset of field: ",
			stringify!(LL_TIM_BDTR_InitTypeDef),
			"::",
			stringify!(OSSIState)
		)
		);
	}
	test_field_OSSIState();
	fn test_field_LockLevel() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_TIM_BDTR_InitTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).LockLevel) as usize - ptr as usize
		           },
		           8usize,
		           concat!(
			"Offset of field: ",
			stringify!(LL_TIM_BDTR_InitTypeDef),
			"::",
			stringify!(LockLevel)
		)
		);
	}
	test_field_LockLevel();
	fn test_field_DeadTime() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_TIM_BDTR_InitTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).DeadTime) as usize - ptr as usize
		           },
		           12usize,
		           concat!(
			"Offset of field: ",
			stringify!(LL_TIM_BDTR_InitTypeDef),
			"::",
			stringify!(DeadTime)
		)
		);
	}
	test_field_DeadTime();
	fn test_field_BreakState() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_TIM_BDTR_InitTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).BreakState) as usize - ptr as usize
		           },
		           14usize,
		           concat!(
			"Offset of field: ",
			stringify!(LL_TIM_BDTR_InitTypeDef),
			"::",
			stringify!(BreakState)
		)
		);
	}
	test_field_BreakState();
	fn test_field_BreakPolarity() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_TIM_BDTR_InitTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).BreakPolarity) as usize - ptr as usize
		           },
		           16usize,
		           concat!(
			"Offset of field: ",
			stringify!(LL_TIM_BDTR_InitTypeDef),
			"::",
			stringify!(BreakPolarity)
		)
		);
	}
	test_field_BreakPolarity();
	fn test_field_BreakFilter() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_TIM_BDTR_InitTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).BreakFilter) as usize - ptr as usize
		           },
		           20usize,
		           concat!(
			"Offset of field: ",
			stringify!(LL_TIM_BDTR_InitTypeDef),
			"::",
			stringify!(BreakFilter)
		)
		);
	}
	test_field_BreakFilter();
	fn test_field_BreakAFMode() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_TIM_BDTR_InitTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).BreakAFMode) as usize - ptr as usize
		           },
		           24usize,
		           concat!(
			"Offset of field: ",
			stringify!(LL_TIM_BDTR_InitTypeDef),
			"::",
			stringify!(BreakAFMode)
		)
		);
	}
	test_field_BreakAFMode();
	fn test_field_Break2State() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_TIM_BDTR_InitTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).Break2State) as usize - ptr as usize
		           },
		           28usize,
		           concat!(
			"Offset of field: ",
			stringify!(LL_TIM_BDTR_InitTypeDef),
			"::",
			stringify!(Break2State)
		)
		);
	}
	test_field_Break2State();
	fn test_field_Break2Polarity() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_TIM_BDTR_InitTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).Break2Polarity) as usize - ptr as usize
		           },
		           32usize,
		           concat!(
			"Offset of field: ",
			stringify!(LL_TIM_BDTR_InitTypeDef),
			"::",
			stringify!(Break2Polarity)
		)
		);
	}
	test_field_Break2Polarity();
	fn test_field_Break2Filter() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_TIM_BDTR_InitTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).Break2Filter) as usize - ptr as usize
		           },
		           36usize,
		           concat!(
			"Offset of field: ",
			stringify!(LL_TIM_BDTR_InitTypeDef),
			"::",
			stringify!(Break2Filter)
		)
		);
	}
	test_field_Break2Filter();
	fn test_field_Break2AFMode() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_TIM_BDTR_InitTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).Break2AFMode) as usize - ptr as usize
		           },
		           40usize,
		           concat!(
			"Offset of field: ",
			stringify!(LL_TIM_BDTR_InitTypeDef),
			"::",
			stringify!(Break2AFMode)
		)
		);
	}
	test_field_Break2AFMode();
	fn test_field_AutomaticOutput() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_TIM_BDTR_InitTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).AutomaticOutput) as usize - ptr as usize
		           },
		           44usize,
		           concat!(
			"Offset of field: ",
			stringify!(LL_TIM_BDTR_InitTypeDef),
			"::",
			stringify!(AutomaticOutput)
		)
		);
	}
	test_field_AutomaticOutput();
}
extern "C" {
	#[doc = " @defgroup TIM_LL_EF_Init Initialisation and deinitialisation functions"]
	#[doc = " @{"]
	pub fn LL_TIM_DeInit(TIMx: *mut TIM_TypeDef) -> ErrorStatus;
}
extern "C" {
	pub fn LL_TIM_StructInit(TIM_InitStruct: *mut LL_TIM_InitTypeDef);
}
extern "C" {
	pub fn LL_TIM_Init(TIMx: *mut TIM_TypeDef, TIM_InitStruct: *mut LL_TIM_InitTypeDef) -> ErrorStatus;
}
extern "C" {
	pub fn LL_TIM_OC_StructInit(TIM_OC_InitStruct: *mut LL_TIM_OC_InitTypeDef);
}
extern "C" {
	pub fn LL_TIM_OC_Init(TIMx: *mut TIM_TypeDef, Channel: u32, TIM_OC_InitStruct: *mut LL_TIM_OC_InitTypeDef) -> ErrorStatus;
}
extern "C" {
	pub fn LL_TIM_IC_StructInit(TIM_ICInitStruct: *mut LL_TIM_IC_InitTypeDef);
}
extern "C" {
	pub fn LL_TIM_IC_Init(TIMx: *mut TIM_TypeDef, Channel: u32, TIM_IC_InitStruct: *mut LL_TIM_IC_InitTypeDef) -> ErrorStatus;
}
extern "C" {
	pub fn LL_TIM_ENCODER_StructInit(TIM_EncoderInitStruct: *mut LL_TIM_ENCODER_InitTypeDef);
}
extern "C" {
	pub fn LL_TIM_ENCODER_Init(TIMx: *mut TIM_TypeDef, TIM_EncoderInitStruct: *mut LL_TIM_ENCODER_InitTypeDef) -> ErrorStatus;
}
extern "C" {
	pub fn LL_TIM_HALLSENSOR_StructInit(TIM_HallSensorInitStruct: *mut LL_TIM_HALLSENSOR_InitTypeDef);
}
extern "C" {
	pub fn LL_TIM_HALLSENSOR_Init(TIMx: *mut TIM_TypeDef, TIM_HallSensorInitStruct: *mut LL_TIM_HALLSENSOR_InitTypeDef)
	                              -> ErrorStatus;
}
extern "C" {
	pub fn LL_TIM_BDTR_StructInit(TIM_BDTRInitStruct: *mut LL_TIM_BDTR_InitTypeDef);
}
extern "C" {
	pub fn LL_TIM_BDTR_Init(TIMx: *mut TIM_TypeDef, TIM_BDTRInitStruct: *mut LL_TIM_BDTR_InitTypeDef) -> ErrorStatus;
}
#[doc = " Timer ISR"]
pub type FuriHalInterruptISR = ::core::option::Option<unsafe extern "C" fn(context: *mut core::ffi::c_void)>;
#[repr(u32)]
#[non_exhaustive]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum FuriHalInterruptId {
	FuriHalInterruptIdTim1TrgComTim17 = 0,
	FuriHalInterruptIdTim1Cc = 1,
	FuriHalInterruptIdTim1UpTim16 = 2,
	FuriHalInterruptIdTIM2 = 3,
	FuriHalInterruptIdDma1Ch1 = 4,
	FuriHalInterruptIdDma1Ch2 = 5,
	FuriHalInterruptIdDma1Ch3 = 6,
	FuriHalInterruptIdDma1Ch4 = 7,
	FuriHalInterruptIdDma1Ch5 = 8,
	FuriHalInterruptIdDma1Ch6 = 9,
	FuriHalInterruptIdDma1Ch7 = 10,
	FuriHalInterruptIdDma2Ch1 = 11,
	FuriHalInterruptIdDma2Ch2 = 12,
	FuriHalInterruptIdDma2Ch3 = 13,
	FuriHalInterruptIdDma2Ch4 = 14,
	FuriHalInterruptIdDma2Ch5 = 15,
	FuriHalInterruptIdDma2Ch6 = 16,
	FuriHalInterruptIdDma2Ch7 = 17,
	FuriHalInterruptIdRcc = 18,
	FuriHalInterruptIdCOMP = 19,
	FuriHalInterruptIdHsem = 20,
	FuriHalInterruptIdLpTim1 = 21,
	FuriHalInterruptIdLpTim2 = 22,
	FuriHalInterruptIdMax = 23,
}
extern "C" {
	#[doc = " Initialize interrupt subsystem"]
	pub fn furi_hal_interrupt_init();
}
extern "C" {
	#[doc = " Set ISR and enable interrupt with default priority"]
	#[doc = " We don't clear interrupt flags for you, do it by your self."]
	#[doc = " @param index - interrupt ID"]
	#[doc = " @param isr - your interrupt service routine or use NULL to clear"]
	#[doc = " @param context - isr context"]
	pub fn furi_hal_interrupt_set_isr(index: FuriHalInterruptId, isr: FuriHalInterruptISR, context: *mut core::ffi::c_void);
}
extern "C" {
	#[doc = " Set ISR and enable interrupt with custom priority"]
	#[doc = " We don't clear interrupt flags for you, do it by your self."]
	#[doc = " @param index - interrupt ID"]
	#[doc = " @param priority - 0 to 15, 0 highest"]
	#[doc = " @param isr - your interrupt service routine or use NULL to clear"]
	#[doc = " @param context - isr context"]
	pub fn furi_hal_interrupt_set_isr_ex(index: FuriHalInterruptId,
	                                     priority: u16,
	                                     isr: FuriHalInterruptISR,
	                                     context: *mut core::ffi::c_void);
}
extern "C" {
	pub fn furi_hal_os_init();
}
extern "C" {
	pub fn furi_hal_os_tick();
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum FuriHalPwmOutputId {
	FuriHalPwmOutputIdTim1PA7 = 0,
	FuriHalPwmOutputIdLptim2PA4 = 1,
}
extern "C" {
	#[doc = " Enable PWM channel and set parameters"]
	#[doc = ""]
	#[doc = " @param[in]  channel  PWM channel (FuriHalPwmOutputId)"]
	#[doc = " @param[in]  freq  Frequency in Hz"]
	#[doc = " @param[in]  duty  Duty cycle value in %"]
	pub fn furi_hal_pwm_start(channel: FuriHalPwmOutputId, freq: u32, duty: u8);
}
extern "C" {
	#[doc = " Disable PWM channel"]
	#[doc = ""]
	#[doc = " @param[in]  channel  PWM channel (FuriHalPwmOutputId)"]
	pub fn furi_hal_pwm_stop(channel: FuriHalPwmOutputId);
}
extern "C" {
	#[doc = " Set PWM channel parameters"]
	#[doc = ""]
	#[doc = " @param[in]  channel  PWM channel (FuriHalPwmOutputId)"]
	#[doc = " @param[in]  freq  Frequency in Hz"]
	#[doc = " @param[in]  duty  Duty cycle value in %"]
	pub fn furi_hal_pwm_set_params(channel: FuriHalPwmOutputId, freq: u32, duty: u8);
}
#[doc = " @brief  SPI Init structures definition"]
#[repr(C)]
pub struct LL_SPI_InitTypeDef {
	#[doc = "< Specifies the SPI unidirectional or bidirectional data mode."]
	#[doc = "This parameter can be a value of @ref SPI_LL_EC_TRANSFER_MODE."]
	#[doc = ""]
	#[doc = "This feature can be modified afterwards using unitary function @ref LL_SPI_SetTransferDirection()."]
	pub TransferDirection: u32,
	#[doc = "< Specifies the SPI mode (Master/Slave)."]
	#[doc = "This parameter can be a value of @ref SPI_LL_EC_MODE."]
	#[doc = ""]
	#[doc = "This feature can be modified afterwards using unitary function @ref LL_SPI_SetMode()."]
	pub Mode: u32,
	#[doc = "< Specifies the SPI data width."]
	#[doc = "This parameter can be a value of @ref SPI_LL_EC_DATAWIDTH."]
	#[doc = ""]
	#[doc = "This feature can be modified afterwards using unitary function @ref LL_SPI_SetDataWidth()."]
	pub DataWidth: u32,
	#[doc = "< Specifies the serial clock steady state."]
	#[doc = "This parameter can be a value of @ref SPI_LL_EC_POLARITY."]
	#[doc = ""]
	#[doc = "This feature can be modified afterwards using unitary function @ref LL_SPI_SetClockPolarity()."]
	pub ClockPolarity: u32,
	#[doc = "< Specifies the clock active edge for the bit capture."]
	#[doc = "This parameter can be a value of @ref SPI_LL_EC_PHASE."]
	#[doc = ""]
	#[doc = "This feature can be modified afterwards using unitary function @ref LL_SPI_SetClockPhase()."]
	pub ClockPhase: u32,
	#[doc = "< Specifies whether the NSS signal is managed by hardware (NSS pin) or by software using the SSI bit."]
	#[doc = "This parameter can be a value of @ref SPI_LL_EC_NSS_MODE."]
	#[doc = ""]
	#[doc = "This feature can be modified afterwards using unitary function @ref LL_SPI_SetNSSMode()."]
	pub NSS: u32,
	#[doc = "< Specifies the BaudRate prescaler value which will be used to configure the transmit and receive SCK clock."]
	#[doc = "This parameter can be a value of @ref SPI_LL_EC_BAUDRATEPRESCALER."]
	#[doc = "@note The communication clock is derived from the master clock. The slave clock does not need to be set."]
	#[doc = ""]
	#[doc = "This feature can be modified afterwards using unitary function @ref LL_SPI_SetBaudRatePrescaler()."]
	pub BaudRate: u32,
	#[doc = "< Specifies whether data transfers start from MSB or LSB bit."]
	#[doc = "This parameter can be a value of @ref SPI_LL_EC_BIT_ORDER."]
	#[doc = ""]
	#[doc = "This feature can be modified afterwards using unitary function @ref LL_SPI_SetTransferBitOrder()."]
	pub BitOrder: u32,
	#[doc = "< Specifies if the CRC calculation is enabled or not."]
	#[doc = "This parameter can be a value of @ref SPI_LL_EC_CRC_CALCULATION."]
	#[doc = ""]
	#[doc = "This feature can be modified afterwards using unitary functions @ref LL_SPI_EnableCRC() and @ref LL_SPI_DisableCRC()."]
	pub CRCCalculation: u32,
	#[doc = "< Specifies the polynomial used for the CRC calculation."]
	#[doc = "This parameter must be a number between Min_Data = 0x00 and Max_Data = 0xFFFF."]
	#[doc = ""]
	#[doc = "This feature can be modified afterwards using unitary function @ref LL_SPI_SetCRCPolynomial()."]
	pub CRCPoly: u32,
}
#[test]
fn bindgen_test_layout_LL_SPI_InitTypeDef() {
	assert_eq!(
	           ::core::mem::size_of::<LL_SPI_InitTypeDef>(),
	           40usize,
	           concat!("Size of: ", stringify!(LL_SPI_InitTypeDef))
	);
	assert_eq!(
	           ::core::mem::align_of::<LL_SPI_InitTypeDef>(),
	           4usize,
	           concat!("Alignment of ", stringify!(LL_SPI_InitTypeDef))
	);
	fn test_field_TransferDirection() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_SPI_InitTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).TransferDirection) as usize - ptr as usize
		           },
		           0usize,
		           concat!(
			"Offset of field: ",
			stringify!(LL_SPI_InitTypeDef),
			"::",
			stringify!(TransferDirection)
		)
		);
	}
	test_field_TransferDirection();
	fn test_field_Mode() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_SPI_InitTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).Mode) as usize - ptr as usize
		           },
		           4usize,
		           concat!("Offset of field: ", stringify!(LL_SPI_InitTypeDef), "::", stringify!(Mode))
		);
	}
	test_field_Mode();
	fn test_field_DataWidth() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_SPI_InitTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).DataWidth) as usize - ptr as usize
		           },
		           8usize,
		           concat!(
			"Offset of field: ",
			stringify!(LL_SPI_InitTypeDef),
			"::",
			stringify!(DataWidth)
		)
		);
	}
	test_field_DataWidth();
	fn test_field_ClockPolarity() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_SPI_InitTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).ClockPolarity) as usize - ptr as usize
		           },
		           12usize,
		           concat!(
			"Offset of field: ",
			stringify!(LL_SPI_InitTypeDef),
			"::",
			stringify!(ClockPolarity)
		)
		);
	}
	test_field_ClockPolarity();
	fn test_field_ClockPhase() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_SPI_InitTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).ClockPhase) as usize - ptr as usize
		           },
		           16usize,
		           concat!(
			"Offset of field: ",
			stringify!(LL_SPI_InitTypeDef),
			"::",
			stringify!(ClockPhase)
		)
		);
	}
	test_field_ClockPhase();
	fn test_field_NSS() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_SPI_InitTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).NSS) as usize - ptr as usize
		           },
		           20usize,
		           concat!("Offset of field: ", stringify!(LL_SPI_InitTypeDef), "::", stringify!(NSS))
		);
	}
	test_field_NSS();
	fn test_field_BaudRate() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_SPI_InitTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).BaudRate) as usize - ptr as usize
		           },
		           24usize,
		           concat!(
			"Offset of field: ",
			stringify!(LL_SPI_InitTypeDef),
			"::",
			stringify!(BaudRate)
		)
		);
	}
	test_field_BaudRate();
	fn test_field_BitOrder() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_SPI_InitTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).BitOrder) as usize - ptr as usize
		           },
		           28usize,
		           concat!(
			"Offset of field: ",
			stringify!(LL_SPI_InitTypeDef),
			"::",
			stringify!(BitOrder)
		)
		);
	}
	test_field_BitOrder();
	fn test_field_CRCCalculation() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_SPI_InitTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).CRCCalculation) as usize - ptr as usize
		           },
		           32usize,
		           concat!(
			"Offset of field: ",
			stringify!(LL_SPI_InitTypeDef),
			"::",
			stringify!(CRCCalculation)
		)
		);
	}
	test_field_CRCCalculation();
	fn test_field_CRCPoly() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_SPI_InitTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).CRCPoly) as usize - ptr as usize
		           },
		           36usize,
		           concat!("Offset of field: ", stringify!(LL_SPI_InitTypeDef), "::", stringify!(CRCPoly))
		);
	}
	test_field_CRCPoly();
}
extern "C" {
	#[doc = " @defgroup SPI_LL_EF_Init Initialization and de-initialization functions"]
	#[doc = " @{"]
	pub fn LL_SPI_DeInit(SPIx: *mut SPI_TypeDef) -> ErrorStatus;
}
extern "C" {
	pub fn LL_SPI_Init(SPIx: *mut SPI_TypeDef, SPI_InitStruct: *mut LL_SPI_InitTypeDef) -> ErrorStatus;
}
extern "C" {
	pub fn LL_SPI_StructInit(SPI_InitStruct: *mut LL_SPI_InitTypeDef);
}
#[repr(u32)]
#[non_exhaustive]
#[doc = " FuriHal spi bus states"]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum FuriHalSpiBusEvent {
	#[doc = "< Bus initialization event, called on system start"]
	FuriHalSpiBusEventInit = 0,
	#[doc = "< Bus deinitialization event, called on system stop"]
	FuriHalSpiBusEventDeinit = 1,
	#[doc = "< Bus lock event, called before activation"]
	FuriHalSpiBusEventLock = 2,
	#[doc = "< Bus unlock event, called after deactivation"]
	FuriHalSpiBusEventUnlock = 3,
	#[doc = "< Bus activation event, called before handle activation"]
	FuriHalSpiBusEventActivate = 4,
	#[doc = "< Bus deactivation event, called after handle deactivation"]
	FuriHalSpiBusEventDeactivate = 5,
}
#[doc = " FuriHal spi bus event callback"]
pub type FuriHalSpiBusEventCallback =
	::core::option::Option<unsafe extern "C" fn(bus: *mut FuriHalSpiBus, event: FuriHalSpiBusEvent)>;
#[doc = " FuriHal spi bus"]
#[repr(C)]
pub struct FuriHalSpiBus {
	pub spi: *mut SPI_TypeDef,
	pub callback: FuriHalSpiBusEventCallback,
	pub current_handle: *mut FuriHalSpiBusHandle,
}
#[test]
fn bindgen_test_layout_FuriHalSpiBus() {
	assert_eq!(
	           ::core::mem::size_of::<FuriHalSpiBus>(),
	           12usize,
	           concat!("Size of: ", stringify!(FuriHalSpiBus))
	);
	assert_eq!(
	           ::core::mem::align_of::<FuriHalSpiBus>(),
	           4usize,
	           concat!("Alignment of ", stringify!(FuriHalSpiBus))
	);
	fn test_field_spi() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<FuriHalSpiBus>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).spi) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(FuriHalSpiBus), "::", stringify!(spi))
		);
	}
	test_field_spi();
	fn test_field_callback() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<FuriHalSpiBus>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).callback) as usize - ptr as usize
		           },
		           4usize,
		           concat!("Offset of field: ", stringify!(FuriHalSpiBus), "::", stringify!(callback))
		);
	}
	test_field_callback();
	fn test_field_current_handle() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<FuriHalSpiBus>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).current_handle) as usize - ptr as usize
		           },
		           8usize,
		           concat!(
			"Offset of field: ",
			stringify!(FuriHalSpiBus),
			"::",
			stringify!(current_handle)
		)
		);
	}
	test_field_current_handle();
}
#[repr(u32)]
#[non_exhaustive]
#[doc = " FuriHal spi handle states"]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum FuriHalSpiBusHandleEvent {
	#[doc = "< Handle init, called on system start, initialize gpio for idle state"]
	FuriHalSpiBusHandleEventInit = 0,
	#[doc = "< Handle deinit, called on system stop, deinitialize gpio for default state"]
	FuriHalSpiBusHandleEventDeinit = 1,
	#[doc = "< Handle activate: connect gpio and apply bus config"]
	FuriHalSpiBusHandleEventActivate = 2,
	#[doc = "< Handle deactivate: disconnect gpio and reset bus config"]
	FuriHalSpiBusHandleEventDeactivate = 3,
}
#[doc = " FuriHal spi handle event callback"]
pub type FuriHalSpiBusHandleEventCallback =
	::core::option::Option<unsafe extern "C" fn(handle: *mut FuriHalSpiBusHandle, event: FuriHalSpiBusHandleEvent)>;
#[doc = " FuriHal spi handle"]
#[repr(C)]
pub struct FuriHalSpiBusHandle {
	pub bus: *mut FuriHalSpiBus,
	pub callback: FuriHalSpiBusHandleEventCallback,
	pub miso: *const GpioPin,
	pub mosi: *const GpioPin,
	pub sck: *const GpioPin,
	pub cs: *const GpioPin,
}
#[test]
fn bindgen_test_layout_FuriHalSpiBusHandle() {
	assert_eq!(
	           ::core::mem::size_of::<FuriHalSpiBusHandle>(),
	           24usize,
	           concat!("Size of: ", stringify!(FuriHalSpiBusHandle))
	);
	assert_eq!(
	           ::core::mem::align_of::<FuriHalSpiBusHandle>(),
	           4usize,
	           concat!("Alignment of ", stringify!(FuriHalSpiBusHandle))
	);
	fn test_field_bus() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<FuriHalSpiBusHandle>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).bus) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(FuriHalSpiBusHandle), "::", stringify!(bus))
		);
	}
	test_field_bus();
	fn test_field_callback() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<FuriHalSpiBusHandle>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).callback) as usize - ptr as usize
		           },
		           4usize,
		           concat!(
			"Offset of field: ",
			stringify!(FuriHalSpiBusHandle),
			"::",
			stringify!(callback)
		)
		);
	}
	test_field_callback();
	fn test_field_miso() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<FuriHalSpiBusHandle>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).miso) as usize - ptr as usize
		           },
		           8usize,
		           concat!("Offset of field: ", stringify!(FuriHalSpiBusHandle), "::", stringify!(miso))
		);
	}
	test_field_miso();
	fn test_field_mosi() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<FuriHalSpiBusHandle>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).mosi) as usize - ptr as usize
		           },
		           12usize,
		           concat!("Offset of field: ", stringify!(FuriHalSpiBusHandle), "::", stringify!(mosi))
		);
	}
	test_field_mosi();
	fn test_field_sck() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<FuriHalSpiBusHandle>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).sck) as usize - ptr as usize
		           },
		           16usize,
		           concat!("Offset of field: ", stringify!(FuriHalSpiBusHandle), "::", stringify!(sck))
		);
	}
	test_field_sck();
	fn test_field_cs() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<FuriHalSpiBusHandle>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).cs) as usize - ptr as usize
		           },
		           20usize,
		           concat!("Offset of field: ", stringify!(FuriHalSpiBusHandle), "::", stringify!(cs))
		);
	}
	test_field_cs();
}
extern "C" {
	#[doc = " Preset for ST25R916"]
	pub static furi_hal_spi_preset_2edge_low_8m: LL_SPI_InitTypeDef;
}
extern "C" {
	#[doc = " Preset for CC1101"]
	pub static furi_hal_spi_preset_1edge_low_8m: LL_SPI_InitTypeDef;
}
extern "C" {
	#[doc = " Preset for ST7567 (Display)"]
	pub static furi_hal_spi_preset_1edge_low_4m: LL_SPI_InitTypeDef;
}
extern "C" {
	#[doc = " Preset for SdCard in fast mode"]
	pub static furi_hal_spi_preset_1edge_low_16m: LL_SPI_InitTypeDef;
}
extern "C" {
	#[doc = " Preset for SdCard in slow mode"]
	pub static furi_hal_spi_preset_1edge_low_2m: LL_SPI_InitTypeDef;
}
extern "C" {
	#[doc = " Furi Hal Spi Bus R (Radio: CC1101, Nfc, External)"]
	pub static mut furi_hal_spi_bus_r: FuriHalSpiBus;
}
extern "C" {
	#[doc = " Furi Hal Spi Bus D (Display, SdCard)"]
	pub static mut furi_hal_spi_bus_d: FuriHalSpiBus;
}
extern "C" {
	#[doc = " CC1101 on `furi_hal_spi_bus_r`"]
	pub static mut furi_hal_spi_bus_handle_subghz: FuriHalSpiBusHandle;
}
extern "C" {
	#[doc = " ST25R3916 on `furi_hal_spi_bus_r`"]
	pub static mut furi_hal_spi_bus_handle_nfc: FuriHalSpiBusHandle;
}
extern "C" {
	#[doc = " External on `furi_hal_spi_bus_r`"]
	#[doc = " Preset: `furi_hal_spi_preset_1edge_low_2m`"]
	#[doc = ""]
	#[doc = " miso: pa6"]
	#[doc = " mosi: pa7"]
	#[doc = " sck: pb3"]
	#[doc = " cs:  pa4 (software controlled)"]
	#[doc = ""]
	#[doc = " @warning not initialized by default, call `furi_hal_spi_bus_handle_init` to initialize"]
	#[doc = " Bus pins are floating on inactive state, CS high after initialization"]
	#[doc = ""]
	pub static mut furi_hal_spi_bus_handle_external: FuriHalSpiBusHandle;
}
extern "C" {
	#[doc = " ST7567(Display) on `furi_hal_spi_bus_d`"]
	pub static mut furi_hal_spi_bus_handle_display: FuriHalSpiBusHandle;
}
extern "C" {
	#[doc = " SdCard in fast mode on `furi_hal_spi_bus_d`"]
	pub static mut furi_hal_spi_bus_handle_sd_fast: FuriHalSpiBusHandle;
}
extern "C" {
	#[doc = " SdCard in slow mode on `furi_hal_spi_bus_d`"]
	pub static mut furi_hal_spi_bus_handle_sd_slow: FuriHalSpiBusHandle;
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum CC1101State {
	CC1101StateIDLE = 0,
	#[doc = " IDLE state"]
	CC1101StateRX = 1,
	#[doc = " Receive mode"]
	CC1101StateTX = 2,
	#[doc = " Transmit mode"]
	CC1101StateFSTXON = 3,
	#[doc = " Fast TX ready"]
	CC1101StateCALIBRATE = 4,
	#[doc = " Frequency synthesizer calibration is running"]
	CC1101StateSETTLING = 5,
	#[doc = " PLL is settling"]
	CC1101StateRXFIFO_OVERFLOW = 6,
	#[doc = " RX FIFO has overflowed. Read out any useful data, then flush the FIFO with SFRX"]
	CC1101StateTXFIFO_UNDERFLOW = 7,
}
#[repr(C)]
#[repr(align(4))]
pub struct CC1101Status {
	pub _bitfield_align_1: [u8; 0],
	pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
	pub __bindgen_padding_0: [u8; 3usize],
}
#[test]
fn bindgen_test_layout_CC1101Status() {
	assert_eq!(
	           ::core::mem::size_of::<CC1101Status>(),
	           4usize,
	           concat!("Size of: ", stringify!(CC1101Status))
	);
	assert_eq!(
	           ::core::mem::align_of::<CC1101Status>(),
	           4usize,
	           concat!("Alignment of ", stringify!(CC1101Status))
	);
}
impl CC1101Status {
	#[inline]
	pub fn FIFO_BYTES_AVAILABLE(&self) -> u8 { unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u8) } }
	#[inline]
	pub fn set_FIFO_BYTES_AVAILABLE(&mut self, val: u8) {
		unsafe {
			let val: u8 = ::core::mem::transmute(val);
			self._bitfield_1.set(0usize, 4u8, val as u64)
		}
	}
	#[inline]
	pub fn STATE(&self) -> CC1101State { unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 3u8) as u32) } }
	#[inline]
	pub fn set_STATE(&mut self, val: CC1101State) {
		unsafe {
			let val: u32 = ::core::mem::transmute(val);
			self._bitfield_1.set(4usize, 3u8, val as u64)
		}
	}
	#[inline]
	pub fn CHIP_RDYn(&self) -> bool { unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) } }
	#[inline]
	pub fn set_CHIP_RDYn(&mut self, val: bool) {
		unsafe {
			let val: u8 = ::core::mem::transmute(val);
			self._bitfield_1.set(7usize, 1u8, val as u64)
		}
	}
	#[inline]
	pub fn new_bitfield_1(FIFO_BYTES_AVAILABLE: u8, STATE: CC1101State, CHIP_RDYn: bool) -> __BindgenBitfieldUnit<[u8; 1usize]> {
		let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
		__bindgen_bitfield_unit.set(0usize, 4u8, {
			                       let FIFO_BYTES_AVAILABLE: u8 = unsafe { ::core::mem::transmute(FIFO_BYTES_AVAILABLE) };
			                       FIFO_BYTES_AVAILABLE as u64
		                       });
		__bindgen_bitfield_unit.set(4usize, 3u8, {
			                       let STATE: u32 = unsafe { ::core::mem::transmute(STATE) };
			                       STATE as u64
		                       });
		__bindgen_bitfield_unit.set(7usize, 1u8, {
			                       let CHIP_RDYn: u8 = unsafe { ::core::mem::transmute(CHIP_RDYn) };
			                       CHIP_RDYn as u64
		                       });
		__bindgen_bitfield_unit
	}
}
extern "C" {
	#[doc = " Early initialize SPI HAL"]
	pub fn furi_hal_spi_init_early();
}
extern "C" {
	#[doc = " Early deinitialize SPI HAL"]
	pub fn furi_hal_spi_deinit_early();
}
extern "C" {
	#[doc = " Initialize SPI HAL"]
	pub fn furi_hal_spi_init();
}
extern "C" {
	#[doc = " Initialize SPI Bus"]
	#[doc = ""]
	#[doc = " @param      handle  pointer to FuriHalSpiBus instance"]
	pub fn furi_hal_spi_bus_init(bus: *mut FuriHalSpiBus);
}
extern "C" {
	#[doc = " Deinitialize SPI Bus"]
	#[doc = ""]
	#[doc = " @param      handle  pointer to FuriHalSpiBus instance"]
	pub fn furi_hal_spi_bus_deinit(bus: *mut FuriHalSpiBus);
}
extern "C" {
	#[doc = " Initialize SPI Bus Handle"]
	#[doc = ""]
	#[doc = " @param      handle  pointer to FuriHalSpiBusHandle instance"]
	pub fn furi_hal_spi_bus_handle_init(handle: *mut FuriHalSpiBusHandle);
}
extern "C" {
	#[doc = " Deinitialize SPI Bus Handle"]
	#[doc = ""]
	#[doc = " @param      handle  pointer to FuriHalSpiBusHandle instance"]
	pub fn furi_hal_spi_bus_handle_deinit(handle: *mut FuriHalSpiBusHandle);
}
extern "C" {
	#[doc = " Acquire SPI bus"]
	#[doc = ""]
	#[doc = " @warning blocking, calls `furi_crash` on programming error, CS transition is up to handler event routine"]
	#[doc = ""]
	#[doc = " @param      handle  pointer to FuriHalSpiBusHandle instance"]
	pub fn furi_hal_spi_acquire(handle: *mut FuriHalSpiBusHandle);
}
extern "C" {
	#[doc = " Release SPI bus"]
	#[doc = ""]
	#[doc = " @warning calls `furi_crash` on programming error, CS transition is up to handler event routine"]
	#[doc = ""]
	#[doc = " @param      handle  pointer to FuriHalSpiBusHandle instance"]
	pub fn furi_hal_spi_release(handle: *mut FuriHalSpiBusHandle);
}
extern "C" {
	#[doc = " SPI Receive"]
	#[doc = ""]
	#[doc = " @param      handle   pointer to FuriHalSpiBusHandle instance"]
	#[doc = " @param      buffer   receive buffer"]
	#[doc = " @param      size     transaction size (buffer size)"]
	#[doc = " @param      timeout  operation timeout in ms"]
	#[doc = ""]
	#[doc = " @return     true on sucess"]
	pub fn furi_hal_spi_bus_rx(handle: *mut FuriHalSpiBusHandle, buffer: *mut u8, size: usize, timeout: u32) -> bool;
}
extern "C" {
	#[doc = " SPI Transmit"]
	#[doc = ""]
	#[doc = " @param      handle   pointer to FuriHalSpiBusHandle instance"]
	#[doc = " @param      buffer   transmit buffer"]
	#[doc = " @param      size     transaction size (buffer size)"]
	#[doc = " @param      timeout  operation timeout in ms"]
	#[doc = ""]
	#[doc = " @return     true on success"]
	pub fn furi_hal_spi_bus_tx(handle: *mut FuriHalSpiBusHandle, buffer: *mut u8, size: usize, timeout: u32) -> bool;
}
extern "C" {
	#[doc = " SPI Transmit and Receive"]
	#[doc = ""]
	#[doc = " @param      handle     pointer to FuriHalSpiBusHandle instance"]
	#[doc = " @param      tx_buffer  pointer to tx buffer"]
	#[doc = " @param      rx_buffer  pointer to rx buffer"]
	#[doc = " @param      size       transaction size (buffer size)"]
	#[doc = " @param      timeout    operation timeout in ms"]
	#[doc = ""]
	#[doc = " @return     true on success"]
	pub fn furi_hal_spi_bus_trx(handle: *mut FuriHalSpiBusHandle,
	                            tx_buffer: *mut u8,
	                            rx_buffer: *mut u8,
	                            size: usize,
	                            timeout: u32)
	                            -> bool;
}
extern "C" {
	#[doc = " Strobe command to the device"]
	#[doc = ""]
	#[doc = " @param      handle  - pointer to FuriHalSpiHandle"]
	#[doc = " @param      strobe  - command to execute"]
	#[doc = ""]
	#[doc = " @return     device status"]
	pub fn cc1101_strobe(handle: *mut FuriHalSpiBusHandle, strobe: u8) -> CC1101Status;
}
extern "C" {
	#[doc = " Write device register"]
	#[doc = ""]
	#[doc = " @param      handle  - pointer to FuriHalSpiHandle"]
	#[doc = " @param      reg     - register"]
	#[doc = " @param      data    - data to write"]
	#[doc = ""]
	#[doc = " @return     device status"]
	pub fn cc1101_write_reg(handle: *mut FuriHalSpiBusHandle, reg: u8, data: u8) -> CC1101Status;
}
extern "C" {
	#[doc = " Read device register"]
	#[doc = ""]
	#[doc = " @param      handle  - pointer to FuriHalSpiHandle"]
	#[doc = " @param      reg     - register"]
	#[doc = " @param[out] data    - pointer to data"]
	#[doc = ""]
	#[doc = " @return     device status"]
	pub fn cc1101_read_reg(handle: *mut FuriHalSpiBusHandle, reg: u8, data: *mut u8) -> CC1101Status;
}
extern "C" {
	#[doc = " Reset"]
	#[doc = ""]
	#[doc = " @param      handle  - pointer to FuriHalSpiHandle"]
	pub fn cc1101_reset(handle: *mut FuriHalSpiBusHandle);
}
extern "C" {
	#[doc = " Get status"]
	#[doc = ""]
	#[doc = " @param      handle  - pointer to FuriHalSpiHandle"]
	#[doc = ""]
	#[doc = " @return     CC1101Status structure"]
	pub fn cc1101_get_status(handle: *mut FuriHalSpiBusHandle) -> CC1101Status;
}
extern "C" {
	#[doc = " Enable shutdown mode"]
	#[doc = ""]
	#[doc = " @param      handle  - pointer to FuriHalSpiHandle"]
	pub fn cc1101_shutdown(handle: *mut FuriHalSpiBusHandle);
}
extern "C" {
	#[doc = " Get Partnumber"]
	#[doc = ""]
	#[doc = " @param      handle  - pointer to FuriHalSpiHandle"]
	#[doc = ""]
	#[doc = " @return     part number id"]
	pub fn cc1101_get_partnumber(handle: *mut FuriHalSpiBusHandle) -> u8;
}
extern "C" {
	#[doc = " Get Version"]
	#[doc = ""]
	#[doc = " @param      handle  - pointer to FuriHalSpiHandle"]
	#[doc = ""]
	#[doc = " @return     version"]
	pub fn cc1101_get_version(handle: *mut FuriHalSpiBusHandle) -> u8;
}
extern "C" {
	#[doc = " Get raw RSSI value"]
	#[doc = ""]
	#[doc = " @param      handle  - pointer to FuriHalSpiHandle"]
	#[doc = ""]
	#[doc = " @return     rssi value"]
	pub fn cc1101_get_rssi(handle: *mut FuriHalSpiBusHandle) -> u8;
}
extern "C" {
	#[doc = " Calibrate oscillator"]
	#[doc = ""]
	#[doc = " @param      handle  - pointer to FuriHalSpiHandle"]
	pub fn cc1101_calibrate(handle: *mut FuriHalSpiBusHandle);
}
extern "C" {
	#[doc = " Switch to idle"]
	#[doc = ""]
	#[doc = " @param      handle  - pointer to FuriHalSpiHandle"]
	pub fn cc1101_switch_to_idle(handle: *mut FuriHalSpiBusHandle);
}
extern "C" {
	#[doc = " Switch to RX"]
	#[doc = ""]
	#[doc = " @param      handle  - pointer to FuriHalSpiHandle"]
	pub fn cc1101_switch_to_rx(handle: *mut FuriHalSpiBusHandle);
}
extern "C" {
	#[doc = " Switch to TX"]
	#[doc = ""]
	#[doc = " @param      handle  - pointer to FuriHalSpiHandle"]
	pub fn cc1101_switch_to_tx(handle: *mut FuriHalSpiBusHandle);
}
extern "C" {
	#[doc = " Flush RX FIFO"]
	#[doc = ""]
	#[doc = " @param      handle  - pointer to FuriHalSpiHandle"]
	pub fn cc1101_flush_rx(handle: *mut FuriHalSpiBusHandle);
}
extern "C" {
	#[doc = " Flush TX FIFO"]
	#[doc = ""]
	#[doc = " @param      handle  - pointer to FuriHalSpiHandle"]
	pub fn cc1101_flush_tx(handle: *mut FuriHalSpiBusHandle);
}
extern "C" {
	#[doc = " Set Frequency"]
	#[doc = ""]
	#[doc = " @param      handle  - pointer to FuriHalSpiHandle"]
	#[doc = " @param      value   - frequency in herz"]
	#[doc = ""]
	#[doc = " @return     real frequency that were synthesized"]
	pub fn cc1101_set_frequency(handle: *mut FuriHalSpiBusHandle, value: u32) -> u32;
}
extern "C" {
	#[doc = " Set Intermediate Frequency"]
	#[doc = ""]
	#[doc = " @param      handle  - pointer to FuriHalSpiHandle"]
	#[doc = " @param      value   - frequency in herz"]
	#[doc = ""]
	#[doc = " @return     real inermediate frequency that were synthesized"]
	pub fn cc1101_set_intermediate_frequency(handle: *mut FuriHalSpiBusHandle, value: u32) -> u32;
}
extern "C" {
	#[doc = " Set Power Amplifier level table, ramp"]
	#[doc = ""]
	#[doc = " @param      handle  - pointer to FuriHalSpiHandle"]
	#[doc = " @param      value   - array of power level values"]
	pub fn cc1101_set_pa_table(handle: *mut FuriHalSpiBusHandle, value: *const [u8; 8usize]);
}
extern "C" {
	#[doc = " Write FIFO"]
	#[doc = ""]
	#[doc = " @param      handle  - pointer to FuriHalSpiHandle"]
	#[doc = " @param      data    pointer to byte array"]
	#[doc = " @param      size    write bytes count"]
	#[doc = ""]
	#[doc = " @return     size, written bytes count"]
	pub fn cc1101_write_fifo(handle: *mut FuriHalSpiBusHandle, data: *const u8, size: u8) -> u8;
}
extern "C" {
	#[doc = " Read FIFO"]
	#[doc = ""]
	#[doc = " @param      handle  - pointer to FuriHalSpiHandle"]
	#[doc = " @param      data    pointer to byte array"]
	#[doc = " @param      size    bytes to read from fifo"]
	#[doc = ""]
	#[doc = " @return     size, read bytes count"]
	pub fn cc1101_read_fifo(handle: *mut FuriHalSpiBusHandle, data: *mut u8, size: *mut u8) -> u8;
}
#[repr(u32)]
#[non_exhaustive]
#[doc = " UART channels"]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum FuriHalUartId {
	FuriHalUartIdUSART1 = 0,
	FuriHalUartIdLPUART1 = 1,
}
#[repr(u32)]
#[non_exhaustive]
#[doc = " UART events"]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum UartIrqEvent {
	UartIrqEventRXNE = 0,
}
extern "C" {
	#[doc = " Init UART"]
	#[doc = " Configures GPIO to UART function, onfigures UART hardware, enables UART hardware"]
	#[doc = " @param channel UART channel"]
	#[doc = " @param baud baudrate"]
	pub fn furi_hal_uart_init(channel: FuriHalUartId, baud: u32);
}
extern "C" {
	#[doc = " Deinit UART"]
	#[doc = " Configures GPIO to analog, clears callback and callback context, disables UART hardware"]
	#[doc = " @param channel UART channel"]
	pub fn furi_hal_uart_deinit(channel: FuriHalUartId);
}
extern "C" {
	#[doc = " Suspend UART operation"]
	#[doc = " Disables UART hardware, settings and callbacks are preserved"]
	#[doc = " @param channel UART channel"]
	pub fn furi_hal_uart_suspend(channel: FuriHalUartId);
}
extern "C" {
	#[doc = " Resume UART operation"]
	#[doc = " Resumes UART hardware from suspended state"]
	#[doc = " @param channel UART channel"]
	pub fn furi_hal_uart_resume(channel: FuriHalUartId);
}
extern "C" {
	#[doc = " Changes UART baudrate"]
	#[doc = " @param channel UART channel"]
	#[doc = " @param baud baudrate"]
	pub fn furi_hal_uart_set_br(channel: FuriHalUartId, baud: u32);
}
extern "C" {
	#[doc = " Transmits data"]
	#[doc = " @param channel UART channel"]
	#[doc = " @param buffer data"]
	#[doc = " @param buffer_size data size (in bytes)"]
	pub fn furi_hal_uart_tx(channel: FuriHalUartId, buffer: *mut u8, buffer_size: usize);
}
extern "C" {
	#[doc = " Sets UART event callback"]
	#[doc = " @param channel UART channel"]
	#[doc = " @param callback callback pointer"]
	#[doc = " @param context callback context"]
	pub fn furi_hal_uart_set_irq_cb(channel: FuriHalUartId,
	                                callback: ::core::option::Option<unsafe extern "C" fn(event: UartIrqEvent,
	                                                                            data: u8,
	                                                                            context: *mut core::ffi::c_void)>,
	                                context: *mut core::ffi::c_void);
}
#[doc = "\\brief Line Coding Structure"]
#[repr(C, packed)]
pub struct usb_cdc_line_coding {
	#[doc = "<\\brief Data terminal rate, in bits per second."]
	pub dwDTERate: u32,
	#[doc = "<\\brief Stop bits."]
	pub bCharFormat: u8,
	#[doc = "<\\brief Parity."]
	pub bParityType: u8,
	#[doc = "<\\brief Data bits (5,6,7,8 or 16)."]
	pub bDataBits: u8,
}
#[test]
fn bindgen_test_layout_usb_cdc_line_coding() {
	assert_eq!(
	           ::core::mem::size_of::<usb_cdc_line_coding>(),
	           7usize,
	           concat!("Size of: ", stringify!(usb_cdc_line_coding))
	);
	assert_eq!(
	           ::core::mem::align_of::<usb_cdc_line_coding>(),
	           1usize,
	           concat!("Alignment of ", stringify!(usb_cdc_line_coding))
	);
	fn test_field_dwDTERate() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<usb_cdc_line_coding>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).dwDTERate) as usize - ptr as usize
		           },
		           0usize,
		           concat!(
			"Offset of field: ",
			stringify!(usb_cdc_line_coding),
			"::",
			stringify!(dwDTERate)
		)
		);
	}
	test_field_dwDTERate();
	fn test_field_bCharFormat() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<usb_cdc_line_coding>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).bCharFormat) as usize - ptr as usize
		           },
		           4usize,
		           concat!(
			"Offset of field: ",
			stringify!(usb_cdc_line_coding),
			"::",
			stringify!(bCharFormat)
		)
		);
	}
	test_field_bCharFormat();
	fn test_field_bParityType() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<usb_cdc_line_coding>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).bParityType) as usize - ptr as usize
		           },
		           5usize,
		           concat!(
			"Offset of field: ",
			stringify!(usb_cdc_line_coding),
			"::",
			stringify!(bParityType)
		)
		);
	}
	test_field_bParityType();
	fn test_field_bDataBits() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<usb_cdc_line_coding>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).bDataBits) as usize - ptr as usize
		           },
		           6usize,
		           concat!(
			"Offset of field: ",
			stringify!(usb_cdc_line_coding),
			"::",
			stringify!(bDataBits)
		)
		);
	}
	test_field_bDataBits();
}
#[repr(C)]
pub struct CdcCallbacks {
	pub tx_ep_callback: ::core::option::Option<unsafe extern "C" fn(context: *mut core::ffi::c_void)>,
	pub rx_ep_callback: ::core::option::Option<unsafe extern "C" fn(context: *mut core::ffi::c_void)>,
	pub state_callback: ::core::option::Option<unsafe extern "C" fn(context: *mut core::ffi::c_void, state: u8)>,
	pub ctrl_line_callback: ::core::option::Option<unsafe extern "C" fn(context: *mut core::ffi::c_void, state: u8)>,
	pub config_callback:
		::core::option::Option<unsafe extern "C" fn(context: *mut core::ffi::c_void, config: *mut usb_cdc_line_coding)>,
}
#[test]
fn bindgen_test_layout_CdcCallbacks() {
	assert_eq!(
	           ::core::mem::size_of::<CdcCallbacks>(),
	           20usize,
	           concat!("Size of: ", stringify!(CdcCallbacks))
	);
	assert_eq!(
	           ::core::mem::align_of::<CdcCallbacks>(),
	           4usize,
	           concat!("Alignment of ", stringify!(CdcCallbacks))
	);
	fn test_field_tx_ep_callback() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<CdcCallbacks>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).tx_ep_callback) as usize - ptr as usize
		           },
		           0usize,
		           concat!(
			"Offset of field: ",
			stringify!(CdcCallbacks),
			"::",
			stringify!(tx_ep_callback)
		)
		);
	}
	test_field_tx_ep_callback();
	fn test_field_rx_ep_callback() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<CdcCallbacks>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).rx_ep_callback) as usize - ptr as usize
		           },
		           4usize,
		           concat!(
			"Offset of field: ",
			stringify!(CdcCallbacks),
			"::",
			stringify!(rx_ep_callback)
		)
		);
	}
	test_field_rx_ep_callback();
	fn test_field_state_callback() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<CdcCallbacks>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).state_callback) as usize - ptr as usize
		           },
		           8usize,
		           concat!(
			"Offset of field: ",
			stringify!(CdcCallbacks),
			"::",
			stringify!(state_callback)
		)
		);
	}
	test_field_state_callback();
	fn test_field_ctrl_line_callback() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<CdcCallbacks>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).ctrl_line_callback) as usize - ptr as usize
		           },
		           12usize,
		           concat!(
			"Offset of field: ",
			stringify!(CdcCallbacks),
			"::",
			stringify!(ctrl_line_callback)
		)
		);
	}
	test_field_ctrl_line_callback();
	fn test_field_config_callback() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<CdcCallbacks>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).config_callback) as usize - ptr as usize
		           },
		           16usize,
		           concat!(
			"Offset of field: ",
			stringify!(CdcCallbacks),
			"::",
			stringify!(config_callback)
		)
		);
	}
	test_field_config_callback();
}
extern "C" {
	pub fn furi_hal_cdc_set_callbacks(if_num: u8, cb: *mut CdcCallbacks, context: *mut core::ffi::c_void);
}
extern "C" {
	pub fn furi_hal_cdc_get_port_settings(if_num: u8) -> *mut usb_cdc_line_coding;
}
extern "C" {
	pub fn furi_hal_cdc_get_ctrl_line_state(if_num: u8) -> u8;
}
extern "C" {
	pub fn furi_hal_cdc_send(if_num: u8, buf: *mut u8, len: u16);
}
extern "C" {
	pub fn furi_hal_cdc_receive(if_num: u8, buf: *mut u8, max_len: u16) -> i32;
}
extern "C" {
	pub fn __errno() -> *mut core::ffi::c_int;
}
extern "C" {
	pub static mut _sys_errlist: [*const core::ffi::c_char; 0usize];
}
extern "C" {
	pub static mut _sys_nerr: core::ffi::c_int;
}
extern "C" {
	pub fn __clear_cache(arg1: *mut core::ffi::c_void, arg2: *mut core::ffi::c_void);
}
extern "C" {
	#[doc = " Early init stage for cortex"]
	pub fn furi_hal_cortex_init_early();
}
extern "C" {
	#[doc = " Microseconds delay"]
	#[doc = ""]
	#[doc = " @param[in]  microseconds  The microseconds to wait"]
	pub fn furi_hal_cortex_delay_us(microseconds: u32);
}
extern "C" {
	#[doc = " Get instructions per microsecond count"]
	#[doc = ""]
	#[doc = " @return     instructions per microsecond count"]
	pub fn furi_hal_cortex_instructions_per_microsecond() -> u32;
}
#[repr(u32)]
#[non_exhaustive]
#[doc = " FuriHalCryptoKey Type"]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum FuriHalCryptoKeyType {
	#[doc = "< Master key"]
	FuriHalCryptoKeyTypeMaster = 0,
	#[doc = "< Simple enencrypted key"]
	FuriHalCryptoKeyTypeSimple = 1,
	#[doc = "< Encrypted with Master key"]
	FuriHalCryptoKeyTypeEncrypted = 2,
}
#[repr(u32)]
#[non_exhaustive]
#[doc = " FuriHalCryptoKey Size in bits"]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum FuriHalCryptoKeySize {
	FuriHalCryptoKeySize128 = 0,
	FuriHalCryptoKeySize256 = 1,
}
#[doc = " FuriHalCryptoKey"]
#[repr(C)]
pub struct FuriHalCryptoKey {
	pub type_: FuriHalCryptoKeyType,
	pub size: FuriHalCryptoKeySize,
	pub data: *mut u8,
}
#[test]
fn bindgen_test_layout_FuriHalCryptoKey() {
	assert_eq!(
	           ::core::mem::size_of::<FuriHalCryptoKey>(),
	           12usize,
	           concat!("Size of: ", stringify!(FuriHalCryptoKey))
	);
	assert_eq!(
	           ::core::mem::align_of::<FuriHalCryptoKey>(),
	           4usize,
	           concat!("Alignment of ", stringify!(FuriHalCryptoKey))
	);
	fn test_field_type() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<FuriHalCryptoKey>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(FuriHalCryptoKey), "::", stringify!(type_))
		);
	}
	test_field_type();
	fn test_field_size() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<FuriHalCryptoKey>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).size) as usize - ptr as usize
		           },
		           4usize,
		           concat!("Offset of field: ", stringify!(FuriHalCryptoKey), "::", stringify!(size))
		);
	}
	test_field_size();
	fn test_field_data() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<FuriHalCryptoKey>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).data) as usize - ptr as usize
		           },
		           8usize,
		           concat!("Offset of field: ", stringify!(FuriHalCryptoKey), "::", stringify!(data))
		);
	}
	test_field_data();
}
extern "C" {
	#[doc = " Initialize cryptography layer This includes AES engines, PKA and RNG"]
	pub fn furi_hal_crypto_init();
}
extern "C" {
	pub fn furi_hal_crypto_verify_enclave(keys_nb: *mut u8, valid_keys_nb: *mut u8) -> bool;
}
extern "C" {
	pub fn furi_hal_crypto_verify_key(key_slot: u8) -> bool;
}
extern "C" {
	#[doc = " Store key in crypto storage"]
	#[doc = ""]
	#[doc = " @param      key   FuriHalCryptoKey to store. Only Master, Simple or"]
	#[doc = "                   Encrypted"]
	#[doc = " @param      slot  pinter to int where store slot number will be saved"]
	#[doc = ""]
	#[doc = " @return     true on success"]
	pub fn furi_hal_crypto_store_add_key(key: *mut FuriHalCryptoKey, slot: *mut u8) -> bool;
}
extern "C" {
	#[doc = " Init AES engine and load key from crypto store"]
	#[doc = ""]
	#[doc = " @param      slot  store slot number"]
	#[doc = " @param[in]  iv    pointer to 16 bytes Initialization Vector data"]
	#[doc = ""]
	#[doc = " @return     true on success"]
	pub fn furi_hal_crypto_store_load_key(slot: u8, iv: *const u8) -> bool;
}
extern "C" {
	#[doc = " Unload key engine and deinit AES engine"]
	#[doc = ""]
	#[doc = " @param      slot  store slot number"]
	#[doc = ""]
	#[doc = " @return     true on success"]
	pub fn furi_hal_crypto_store_unload_key(slot: u8) -> bool;
}
extern "C" {
	#[doc = " Encrypt data"]
	#[doc = ""]
	#[doc = " @param      input   pointer to input data"]
	#[doc = " @param      output  pointer to output data"]
	#[doc = " @param      size    input/output buffer size in bytes"]
	#[doc = ""]
	#[doc = " @return     true on success"]
	pub fn furi_hal_crypto_encrypt(input: *const u8, output: *mut u8, size: usize) -> bool;
}
extern "C" {
	#[doc = " Decrypt data"]
	#[doc = ""]
	#[doc = " @param      input   pointer to input data"]
	#[doc = " @param      output  pointer to output data"]
	#[doc = " @param      size    input/output buffer size in bytes"]
	#[doc = ""]
	#[doc = " @return     true on success"]
	pub fn furi_hal_crypto_decrypt(input: *const u8, output: *mut u8, size: usize) -> bool;
}
extern "C" {
	#[doc = " Enable MCU debug"]
	pub fn furi_hal_debug_enable();
}
extern "C" {
	#[doc = " Disable MCU debug"]
	pub fn furi_hal_debug_disable();
}
extern "C" {
	#[doc = " Init SD card detect"]
	pub fn hal_sd_detect_init();
}
extern "C" {
	#[doc = " Set SD card detect pin to low"]
	pub fn hal_sd_detect_set_low();
}
extern "C" {
	#[doc = " Get SD card status"]
	#[doc = ""]
	#[doc = " @return     true if SD card present, false if SD card not present"]
	pub fn hal_sd_detect() -> bool;
}
extern "C" {
	#[doc = " Pointer to currently used SPI Handle"]
	pub static mut furi_hal_sd_spi_handle: *mut FuriHalSpiBusHandle;
}
extern "C" {
	#[doc = " Early Init I2C"]
	pub fn furi_hal_i2c_init_early();
}
extern "C" {
	#[doc = " Early DeInit I2C"]
	pub fn furi_hal_i2c_deinit_early();
}
extern "C" {
	#[doc = " Init I2C"]
	pub fn furi_hal_i2c_init();
}
extern "C" {
	#[doc = " Acquire i2c bus handle"]
	#[doc = ""]
	#[doc = " @return     Instance of FuriHalI2cBus"]
	pub fn furi_hal_i2c_acquire(handle: *mut FuriHalI2cBusHandle);
}
extern "C" {
	#[doc = " Release i2c bus handle"]
	#[doc = ""]
	#[doc = " @param      bus   instance of FuriHalI2cBus aquired in `furi_hal_i2c_acquire`"]
	pub fn furi_hal_i2c_release(handle: *mut FuriHalI2cBusHandle);
}
extern "C" {
	#[doc = " Perform I2C tx transfer"]
	#[doc = ""]
	#[doc = " @param      handle   pointer to FuriHalI2cBusHandle instance"]
	#[doc = " @param      address  I2C slave address"]
	#[doc = " @param      data     pointer to data buffer"]
	#[doc = " @param      size     size of data buffer"]
	#[doc = " @param      timeout  timeout in ticks"]
	#[doc = ""]
	#[doc = " @return     true on successful transfer, false otherwise"]
	pub fn furi_hal_i2c_tx(handle: *mut FuriHalI2cBusHandle, address: u8, data: *const u8, size: u8, timeout: u32) -> bool;
}
extern "C" {
	#[doc = " Perform I2C rx transfer"]
	#[doc = ""]
	#[doc = " @param      handle   pointer to FuriHalI2cBusHandle instance"]
	#[doc = " @param      address  I2C slave address"]
	#[doc = " @param      data     pointer to data buffer"]
	#[doc = " @param      size     size of data buffer"]
	#[doc = " @param      timeout  timeout in ticks"]
	#[doc = ""]
	#[doc = " @return     true on successful transfer, false otherwise"]
	pub fn furi_hal_i2c_rx(handle: *mut FuriHalI2cBusHandle, address: u8, data: *mut u8, size: u8, timeout: u32) -> bool;
}
extern "C" {
	#[doc = " Perform I2C tx and rx transfers"]
	#[doc = ""]
	#[doc = " @param      handle   pointer to FuriHalI2cBusHandle instance"]
	#[doc = " @param      address  I2C slave address"]
	#[doc = " @param      tx_data  pointer to tx data buffer"]
	#[doc = " @param      tx_size  size of tx data buffer"]
	#[doc = " @param      rx_data  pointer to rx data buffer"]
	#[doc = " @param      rx_size  size of rx data buffer"]
	#[doc = " @param      timeout  timeout in ticks"]
	#[doc = ""]
	#[doc = " @return     true on successful transfer, false otherwise"]
	pub fn furi_hal_i2c_trx(handle: *mut FuriHalI2cBusHandle,
	                        address: u8,
	                        tx_data: *const u8,
	                        tx_size: u8,
	                        rx_data: *mut u8,
	                        rx_size: u8,
	                        timeout: u32)
	                        -> bool;
}
extern "C" {
	#[doc = " Check if I2C device presents on bus"]
	#[doc = ""]
	#[doc = " @param      handle   pointer to FuriHalI2cBusHandle instance"]
	#[doc = " @param      i2c_addr I2C slave address"]
	#[doc = " @param      timeout  timeout in ticks"]
	#[doc = ""]
	#[doc = " @return     true if device present and is ready, false otherwise"]
	pub fn furi_hal_i2c_is_device_ready(handle: *mut FuriHalI2cBusHandle, i2c_addr: u8, timeout: u32) -> bool;
}
extern "C" {
	#[doc = " Perform I2C device register read (8-bit)"]
	#[doc = ""]
	#[doc = " @param      handle   pointer to FuriHalI2cBusHandle instance"]
	#[doc = " @param      i2c_addr I2C slave address"]
	#[doc = " @param      reg_addr register address"]
	#[doc = " @param      data     pointer to register value"]
	#[doc = " @param      timeout  timeout in ticks"]
	#[doc = ""]
	#[doc = " @return     true on successful transfer, false otherwise"]
	pub fn furi_hal_i2c_read_reg_8(handle: *mut FuriHalI2cBusHandle, i2c_addr: u8, reg_addr: u8, data: *mut u8, timeout: u32) -> bool;
}
extern "C" {
	#[doc = " Perform I2C device register read (16-bit)"]
	#[doc = ""]
	#[doc = " @param      handle   pointer to FuriHalI2cBusHandle instance"]
	#[doc = " @param      i2c_addr I2C slave address"]
	#[doc = " @param      reg_addr register address"]
	#[doc = " @param      data     pointer to register value"]
	#[doc = " @param      timeout  timeout in ticks"]
	#[doc = ""]
	#[doc = " @return     true on successful transfer, false otherwise"]
	pub fn furi_hal_i2c_read_reg_16(handle: *mut FuriHalI2cBusHandle,
	                                i2c_addr: u8,
	                                reg_addr: u8,
	                                data: *mut u16,
	                                timeout: u32)
	                                -> bool;
}
extern "C" {
	#[doc = " Perform I2C device memory read"]
	#[doc = ""]
	#[doc = " @param      handle   pointer to FuriHalI2cBusHandle instance"]
	#[doc = " @param      i2c_addr I2C slave address"]
	#[doc = " @param      mem_addr memory start address"]
	#[doc = " @param      data     pointer to data buffer"]
	#[doc = " @param      len      size of data buffer"]
	#[doc = " @param      timeout  timeout in ticks"]
	#[doc = ""]
	#[doc = " @return     true on successful transfer, false otherwise"]
	pub fn furi_hal_i2c_read_mem(handle: *mut FuriHalI2cBusHandle,
	                             i2c_addr: u8,
	                             mem_addr: u8,
	                             data: *mut u8,
	                             len: u8,
	                             timeout: u32)
	                             -> bool;
}
extern "C" {
	#[doc = " Perform I2C device register write (8-bit)"]
	#[doc = ""]
	#[doc = " @param      handle   pointer to FuriHalI2cBusHandle instance"]
	#[doc = " @param      i2c_addr I2C slave address"]
	#[doc = " @param      reg_addr register address"]
	#[doc = " @param      data     register value"]
	#[doc = " @param      timeout  timeout in ticks"]
	#[doc = ""]
	#[doc = " @return     true on successful transfer, false otherwise"]
	pub fn furi_hal_i2c_write_reg_8(handle: *mut FuriHalI2cBusHandle, i2c_addr: u8, reg_addr: u8, data: u8, timeout: u32) -> bool;
}
extern "C" {
	#[doc = " Perform I2C device register write (16-bit)"]
	#[doc = ""]
	#[doc = " @param      handle   pointer to FuriHalI2cBusHandle instance"]
	#[doc = " @param      i2c_addr I2C slave address"]
	#[doc = " @param      reg_addr register address"]
	#[doc = " @param      data     register value"]
	#[doc = " @param      timeout  timeout in ticks"]
	#[doc = ""]
	#[doc = " @return     true on successful transfer, false otherwise"]
	pub fn furi_hal_i2c_write_reg_16(handle: *mut FuriHalI2cBusHandle, i2c_addr: u8, reg_addr: u8, data: u16, timeout: u32) -> bool;
}
extern "C" {
	#[doc = " Perform I2C device memory"]
	#[doc = ""]
	#[doc = " @param      handle   pointer to FuriHalI2cBusHandle instance"]
	#[doc = " @param      i2c_addr I2C slave address"]
	#[doc = " @param      mem_addr memory start address"]
	#[doc = " @param      data     pointer to data buffer"]
	#[doc = " @param      len      size of data buffer"]
	#[doc = " @param      timeout  timeout in ticks"]
	#[doc = ""]
	#[doc = " @return     true on successful transfer, false otherwise"]
	pub fn furi_hal_i2c_write_mem(handle: *mut FuriHalI2cBusHandle,
	                              i2c_addr: u8,
	                              mem_addr: u8,
	                              data: *mut u8,
	                              len: u8,
	                              timeout: u32)
	                              -> bool;
}
#[repr(C)]
pub struct FuriHalRegionBand {
	pub start: u32,
	pub end: u32,
	pub power_limit: i8,
	pub duty_cycle: u8,
}
#[test]
fn bindgen_test_layout_FuriHalRegionBand() {
	assert_eq!(
	           ::core::mem::size_of::<FuriHalRegionBand>(),
	           12usize,
	           concat!("Size of: ", stringify!(FuriHalRegionBand))
	);
	assert_eq!(
	           ::core::mem::align_of::<FuriHalRegionBand>(),
	           4usize,
	           concat!("Alignment of ", stringify!(FuriHalRegionBand))
	);
	fn test_field_start() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<FuriHalRegionBand>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).start) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(FuriHalRegionBand), "::", stringify!(start))
		);
	}
	test_field_start();
	fn test_field_end() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<FuriHalRegionBand>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).end) as usize - ptr as usize
		           },
		           4usize,
		           concat!("Offset of field: ", stringify!(FuriHalRegionBand), "::", stringify!(end))
		);
	}
	test_field_end();
	fn test_field_power_limit() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<FuriHalRegionBand>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).power_limit) as usize - ptr as usize
		           },
		           8usize,
		           concat!(
			"Offset of field: ",
			stringify!(FuriHalRegionBand),
			"::",
			stringify!(power_limit)
		)
		);
	}
	test_field_power_limit();
	fn test_field_duty_cycle() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<FuriHalRegionBand>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).duty_cycle) as usize - ptr as usize
		           },
		           9usize,
		           concat!(
			"Offset of field: ",
			stringify!(FuriHalRegionBand),
			"::",
			stringify!(duty_cycle)
		)
		);
	}
	test_field_duty_cycle();
}
#[repr(C)]
pub struct FuriHalRegion {
	pub country_code: [core::ffi::c_char; 4usize],
	pub bands_count: u16,
	pub bands: __IncompleteArrayField<FuriHalRegionBand>,
}
#[test]
fn bindgen_test_layout_FuriHalRegion() {
	assert_eq!(
	           ::core::mem::size_of::<FuriHalRegion>(),
	           8usize,
	           concat!("Size of: ", stringify!(FuriHalRegion))
	);
	assert_eq!(
	           ::core::mem::align_of::<FuriHalRegion>(),
	           4usize,
	           concat!("Alignment of ", stringify!(FuriHalRegion))
	);
	fn test_field_country_code() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<FuriHalRegion>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).country_code) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(FuriHalRegion), "::", stringify!(country_code))
		);
	}
	test_field_country_code();
	fn test_field_bands_count() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<FuriHalRegion>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).bands_count) as usize - ptr as usize
		           },
		           4usize,
		           concat!("Offset of field: ", stringify!(FuriHalRegion), "::", stringify!(bands_count))
		);
	}
	test_field_bands_count();
	fn test_field_bands() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<FuriHalRegion>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).bands) as usize - ptr as usize
		           },
		           8usize,
		           concat!("Offset of field: ", stringify!(FuriHalRegion), "::", stringify!(bands))
		);
	}
	test_field_bands();
}
extern "C" {
	#[doc = " Initialize region"]
	pub fn furi_hal_region_init();
}
extern "C" {
	#[doc = " Get Region Data."]
	#[doc = ""]
	#[doc = " Region data may be allocated in Flash or in RAM."]
	#[doc = " Keep in mind that we don't do memory management on our side."]
	#[doc = ""]
	#[doc = " @return     pointer to FuriHalRegion instance (in RAM or Flash, check before freeing on region update)"]
	pub fn furi_hal_region_get() -> *const FuriHalRegion;
}
extern "C" {
	#[doc = " Set device region data"]
	#[doc = ""]
	#[doc = " @param      region  pointer to the FuriHalRegion"]
	pub fn furi_hal_region_set(region: *mut FuriHalRegion);
}
extern "C" {
	#[doc = " Check if region data provisioned"]
	#[doc = ""]
	#[doc = " @return     true if provisioned, false otherwise"]
	pub fn furi_hal_region_is_provisioned() -> bool;
}
extern "C" {
	#[doc = " Get region name"]
	#[doc = ""]
	#[doc = " 2 letter Region code according to iso 3166 standard"]
	#[doc = " There are 2 extra values that we use in special cases:"]
	#[doc = " - \"00\" - developer edition, unlocked"]
	#[doc = " - \"WW\" - world wide, region provisioned by default"]
	#[doc = " - \"--\" - no provisioned region"]
	#[doc = ""]
	#[doc = " @return     Pointer to string"]
	pub fn furi_hal_region_get_name() -> *const core::ffi::c_char;
}
extern "C" {
	#[doc = " heck if transmission is allowed on this frequency for your flipper region"]
	#[doc = ""]
	#[doc = " @param[in]  frequency  The frequency"]
	#[doc = " @param      value  frequency in Hz"]
	#[doc = ""]
	#[doc = " @return     true if allowed"]
	pub fn furi_hal_region_is_frequency_allowed(frequency: u32) -> bool;
}
extern "C" {
	#[doc = " Get band data for frequency"]
	#[doc = ""]
	#[doc = ""]
	#[doc = ""]
	#[doc = " @param[in]  frequency  The frequency"]
	#[doc = ""]
	#[doc = " @return     { description_of_the_return_value }"]
	pub fn furi_hal_region_get_band(frequency: u32) -> *const FuriHalRegionBand;
}
#[repr(C)]
pub struct FuriHalRtcDateTime {
	#[doc = "< Hour in 24H format: 0-23"]
	pub hour: u8,
	#[doc = "< Minute: 0-59"]
	pub minute: u8,
	#[doc = "< Second: 0-59"]
	pub second: u8,
	#[doc = "< Current day: 1-31"]
	pub day: u8,
	#[doc = "< Current month: 1-12"]
	pub month: u8,
	#[doc = "< Current year: 2000-2099"]
	pub year: u16,
	#[doc = "< Current weekday: 1-7"]
	pub weekday: u8,
}
#[test]
fn bindgen_test_layout_FuriHalRtcDateTime() {
	assert_eq!(
	           ::core::mem::size_of::<FuriHalRtcDateTime>(),
	           10usize,
	           concat!("Size of: ", stringify!(FuriHalRtcDateTime))
	);
	assert_eq!(
	           ::core::mem::align_of::<FuriHalRtcDateTime>(),
	           2usize,
	           concat!("Alignment of ", stringify!(FuriHalRtcDateTime))
	);
	fn test_field_hour() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<FuriHalRtcDateTime>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).hour) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(FuriHalRtcDateTime), "::", stringify!(hour))
		);
	}
	test_field_hour();
	fn test_field_minute() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<FuriHalRtcDateTime>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).minute) as usize - ptr as usize
		           },
		           1usize,
		           concat!("Offset of field: ", stringify!(FuriHalRtcDateTime), "::", stringify!(minute))
		);
	}
	test_field_minute();
	fn test_field_second() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<FuriHalRtcDateTime>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).second) as usize - ptr as usize
		           },
		           2usize,
		           concat!("Offset of field: ", stringify!(FuriHalRtcDateTime), "::", stringify!(second))
		);
	}
	test_field_second();
	fn test_field_day() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<FuriHalRtcDateTime>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).day) as usize - ptr as usize
		           },
		           3usize,
		           concat!("Offset of field: ", stringify!(FuriHalRtcDateTime), "::", stringify!(day))
		);
	}
	test_field_day();
	fn test_field_month() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<FuriHalRtcDateTime>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).month) as usize - ptr as usize
		           },
		           4usize,
		           concat!("Offset of field: ", stringify!(FuriHalRtcDateTime), "::", stringify!(month))
		);
	}
	test_field_month();
	fn test_field_year() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<FuriHalRtcDateTime>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).year) as usize - ptr as usize
		           },
		           6usize,
		           concat!("Offset of field: ", stringify!(FuriHalRtcDateTime), "::", stringify!(year))
		);
	}
	test_field_year();
	fn test_field_weekday() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<FuriHalRtcDateTime>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).weekday) as usize - ptr as usize
		           },
		           8usize,
		           concat!("Offset of field: ", stringify!(FuriHalRtcDateTime), "::", stringify!(weekday))
		);
	}
	test_field_weekday();
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum FuriHalRtcFlag {
	FuriHalRtcFlagDebug = 1,
	FuriHalRtcFlagFactoryReset = 2,
	FuriHalRtcFlagLock = 4,
	FuriHalRtcFlagC2Update = 8,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum FuriHalRtcBootMode {
	#[doc = "< Normal boot mode, default value"]
	FuriHalRtcBootModeNormal = 0,
	#[doc = "< Boot to DFU (MCU bootloader by ST)"]
	FuriHalRtcBootModeDfu = 1,
	#[doc = "< Boot to Update, pre update"]
	FuriHalRtcBootModePreUpdate = 2,
	#[doc = "< Boot to Update, main"]
	FuriHalRtcBootModeUpdate = 3,
	#[doc = "< Boot to Update, post update"]
	FuriHalRtcBootModePostUpdate = 4,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum FuriHalRtcRegister {
	#[doc = "< RTC structure header"]
	FuriHalRtcRegisterHeader = 0,
	#[doc = "< Various system bits"]
	FuriHalRtcRegisterSystem = 1,
	#[doc = "< Pointer to Version"]
	FuriHalRtcRegisterVersion = 2,
	#[doc = "< LFS geometry fingerprint"]
	FuriHalRtcRegisterLfsFingerprint = 3,
	#[doc = "< Pointer to last fault message"]
	FuriHalRtcRegisterFaultData = 4,
	#[doc = "< Failed pins count"]
	FuriHalRtcRegisterPinFails = 5,
	FuriHalRtcRegisterUpdateFolderFSIndex = 6,
	#[doc = "< Service value, do not use"]
	FuriHalRtcRegisterMAX = 7,
}
extern "C" {
	#[doc = " Early initialization"]
	pub fn furi_hal_rtc_init_early();
}
extern "C" {
	#[doc = " Early deinitialization"]
	pub fn furi_hal_rtc_deinit_early();
}
extern "C" {
	#[doc = " Initialize RTC subsystem"]
	pub fn furi_hal_rtc_init();
}
extern "C" {
	pub fn furi_hal_rtc_get_register(reg: FuriHalRtcRegister) -> u32;
}
extern "C" {
	pub fn furi_hal_rtc_set_register(reg: FuriHalRtcRegister, value: u32);
}
extern "C" {
	pub fn furi_hal_rtc_set_log_level(level: u8);
}
extern "C" {
	pub fn furi_hal_rtc_get_log_level() -> u8;
}
extern "C" {
	pub fn furi_hal_rtc_set_flag(flag: FuriHalRtcFlag);
}
extern "C" {
	pub fn furi_hal_rtc_reset_flag(flag: FuriHalRtcFlag);
}
extern "C" {
	pub fn furi_hal_rtc_is_flag_set(flag: FuriHalRtcFlag) -> bool;
}
extern "C" {
	pub fn furi_hal_rtc_set_boot_mode(mode: FuriHalRtcBootMode);
}
extern "C" {
	pub fn furi_hal_rtc_get_boot_mode() -> FuriHalRtcBootMode;
}
extern "C" {
	pub fn furi_hal_rtc_set_datetime(datetime: *mut FuriHalRtcDateTime);
}
extern "C" {
	pub fn furi_hal_rtc_get_datetime(datetime: *mut FuriHalRtcDateTime);
}
extern "C" {
	pub fn furi_hal_rtc_validate_datetime(datetime: *mut FuriHalRtcDateTime) -> bool;
}
extern "C" {
	pub fn furi_hal_rtc_set_fault_data(value: u32);
}
extern "C" {
	pub fn furi_hal_rtc_get_fault_data() -> u32;
}
extern "C" {
	pub fn furi_hal_rtc_set_pin_fails(value: u32);
}
extern "C" {
	pub fn furi_hal_rtc_get_pin_fails() -> u32;
}
extern "C" {
	pub fn furi_hal_rtc_datetime_to_timestamp(datetime: *mut FuriHalRtcDateTime) -> u32;
}
extern "C" {
	pub fn furi_hal_speaker_init();
}
extern "C" {
	pub fn furi_hal_speaker_start(frequency: core::ffi::c_float, volume: core::ffi::c_float);
}
extern "C" {
	pub fn furi_hal_speaker_set_volume(volume: core::ffi::c_float);
}
extern "C" {
	pub fn furi_hal_speaker_stop();
}
extern "C" {
	#[doc = " Init light driver"]
	pub fn furi_hal_light_init();
}
extern "C" {
	#[doc = " Set light value"]
	#[doc = ""]
	#[doc = " @param      light  Light"]
	#[doc = " @param      value  light brightness [0-255]"]
	pub fn furi_hal_light_set(light: Light, value: u8);
}
extern "C" {
	#[doc = " Start hardware LED blinking mode"]
	#[doc = ""]
	#[doc = " @param      light  Light"]
	#[doc = " @param      brightness  light brightness [0-255]"]
	#[doc = " @param      on_time  LED on time in ms"]
	#[doc = " @param      period  LED blink period in ms"]
	pub fn furi_hal_light_blink_start(light: Light, brightness: u8, on_time: u16, period: u16);
}
extern "C" {
	#[doc = " Stop hardware LED blinking mode"]
	pub fn furi_hal_light_blink_stop();
}
extern "C" {
	#[doc = " Set color in hardware LED blinking mode"]
	#[doc = ""]
	#[doc = " @param      light  Light"]
	pub fn furi_hal_light_blink_set_color(light: Light);
}
extern "C" {
	#[doc = " Execute sequence"]
	#[doc = ""]
	#[doc = " @param      sequence  Sequence to execute"]
	pub fn furi_hal_light_sequence(sequence: *const core::ffi::c_char);
}
#[repr(u32)]
#[non_exhaustive]
#[doc = " Power IC type"]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum FuriHalPowerIC {
	FuriHalPowerICCharger = 0,
	FuriHalPowerICFuelGauge = 1,
}
extern "C" {
	#[doc = " Initialize drivers"]
	pub fn furi_hal_power_init();
}
extern "C" {
	#[doc = " Check if gauge is ok"]
	#[doc = ""]
	#[doc = " Verifies that:"]
	#[doc = " - gauge is alive"]
	#[doc = " - correct profile loaded"]
	#[doc = " - self diagnostic status is good"]
	#[doc = ""]
	#[doc = " @return true if gauge is ok"]
	pub fn furi_hal_power_gauge_is_ok() -> bool;
}
extern "C" {
	#[doc = " Get current insomnia level"]
	#[doc = ""]
	#[doc = " @return     insomnia level: 0 - no insomnia, >0 - insomnia, bearer count."]
	pub fn furi_hal_power_insomnia_level() -> u16;
}
extern "C" {
	#[doc = " Enter insomnia mode Prevents device from going to sleep"]
	#[doc = " @warning    Internally increases insomnia level Must be paired with"]
	#[doc = "             furi_hal_power_insomnia_exit"]
	pub fn furi_hal_power_insomnia_enter();
}
extern "C" {
	#[doc = " Exit insomnia mode Allow device to go to sleep"]
	#[doc = " @warning    Internally decreases insomnia level. Must be paired with"]
	#[doc = "             furi_hal_power_insomnia_enter"]
	pub fn furi_hal_power_insomnia_exit();
}
extern "C" {
	#[doc = " Check if sleep availble"]
	#[doc = ""]
	#[doc = " @return     true if available"]
	pub fn furi_hal_power_sleep_available() -> bool;
}
extern "C" {
	#[doc = " Check if deep sleep availble"]
	#[doc = ""]
	#[doc = " @return     true if available"]
	pub fn furi_hal_power_deep_sleep_available() -> bool;
}
extern "C" {
	#[doc = " Go to sleep"]
	pub fn furi_hal_power_sleep();
}
extern "C" {
	#[doc = " Get predicted remaining battery capacity in percents"]
	#[doc = ""]
	#[doc = " @return     remaining battery capacity in percents"]
	pub fn furi_hal_power_get_pct() -> u8;
}
extern "C" {
	#[doc = " Get battery health state in percents"]
	#[doc = ""]
	#[doc = " @return     health in percents"]
	pub fn furi_hal_power_get_bat_health_pct() -> u8;
}
extern "C" {
	#[doc = " Get charging status"]
	#[doc = ""]
	#[doc = " @return     true if charging"]
	pub fn furi_hal_power_is_charging() -> bool;
}
extern "C" {
	#[doc = " Get charge complete status"]
	#[doc = ""]
	#[doc = " @return     true if done charging and connected to charger"]
	pub fn furi_hal_power_is_charging_done() -> bool;
}
extern "C" {
	#[doc = " Switch MCU to SHUTDOWN"]
	pub fn furi_hal_power_shutdown();
}
extern "C" {
	#[doc = " Poweroff device"]
	pub fn furi_hal_power_off();
}
extern "C" {
	#[doc = " Reset device"]
	pub fn furi_hal_power_reset();
}
extern "C" {
	#[doc = " OTG enable"]
	pub fn furi_hal_power_enable_otg();
}
extern "C" {
	#[doc = " OTG disable"]
	pub fn furi_hal_power_disable_otg();
}
extern "C" {
	#[doc = " Check OTG status and disable it if falt happened"]
	pub fn furi_hal_power_check_otg_status();
}
extern "C" {
	#[doc = " Get OTG status"]
	#[doc = ""]
	#[doc = " @return     true if enabled"]
	pub fn furi_hal_power_is_otg_enabled() -> bool;
}
extern "C" {
	#[doc = " Get remaining battery battery capacity in mAh"]
	#[doc = ""]
	#[doc = " @return     capacity in mAh"]
	pub fn furi_hal_power_get_battery_remaining_capacity() -> u32;
}
extern "C" {
	#[doc = " Get full charge battery capacity in mAh"]
	#[doc = ""]
	#[doc = " @return     capacity in mAh"]
	pub fn furi_hal_power_get_battery_full_capacity() -> u32;
}
extern "C" {
	#[doc = " Get battery capacity in mAh from battery profile"]
	#[doc = ""]
	#[doc = " @return     capacity in mAh"]
	pub fn furi_hal_power_get_battery_design_capacity() -> u32;
}
extern "C" {
	#[doc = " Get battery voltage in V"]
	#[doc = ""]
	#[doc = " @param      ic    FuriHalPowerIc to get measurment"]
	#[doc = ""]
	#[doc = " @return     voltage in V"]
	pub fn furi_hal_power_get_battery_voltage(ic: FuriHalPowerIC) -> core::ffi::c_float;
}
extern "C" {
	#[doc = " Get battery current in A"]
	#[doc = ""]
	#[doc = " @param      ic    FuriHalPowerIc to get measurment"]
	#[doc = ""]
	#[doc = " @return     current in A"]
	pub fn furi_hal_power_get_battery_current(ic: FuriHalPowerIC) -> core::ffi::c_float;
}
extern "C" {
	#[doc = " Get temperature in C"]
	#[doc = ""]
	#[doc = " @param      ic    FuriHalPowerIc to get measurment"]
	#[doc = ""]
	#[doc = " @return     temperature in C"]
	pub fn furi_hal_power_get_battery_temperature(ic: FuriHalPowerIC) -> core::ffi::c_float;
}
extern "C" {
	#[doc = " Get USB voltage in V"]
	#[doc = ""]
	#[doc = " @return     voltage in V"]
	pub fn furi_hal_power_get_usb_voltage() -> core::ffi::c_float;
}
extern "C" {
	#[doc = " Get power system component state"]
	pub fn furi_hal_power_dump_state();
}
extern "C" {
	#[doc = " Enable 3.3v on external gpio and sd card"]
	pub fn furi_hal_power_enable_external_3_3v();
}
extern "C" {
	#[doc = " Disable 3.3v on external gpio and sd card"]
	pub fn furi_hal_power_disable_external_3_3v();
}
extern "C" {
	#[doc = " Enter supress charge mode."]
	#[doc = ""]
	#[doc = " Use this function when your application need clean power supply."]
	pub fn furi_hal_power_suppress_charge_enter();
}
extern "C" {
	#[doc = " Exit supress charge mode"]
	pub fn furi_hal_power_suppress_charge_exit();
}
#[doc = " Callback type called by furi_hal_power_info_get every time another key-value pair of information is ready"]
#[doc = ""]
#[doc = " @param      key[in]      power information type identifier"]
#[doc = " @param      value[in]    power information value"]
#[doc = " @param      last[in]     whether the passed key-value pair is the last one"]
#[doc = " @param      context[in]  to pass to callback"]
pub type FuriHalPowerInfoCallback = ::core::option::Option<unsafe extern "C" fn(key: *const core::ffi::c_char,
                                                                                value: *const core::ffi::c_char,
                                                                                last: bool,
                                                                                context: *mut core::ffi::c_void)>;
extern "C" {
	#[doc = " Get power information"]
	#[doc = ""]
	#[doc = " @param[in]  callback     callback to provide with new data"]
	#[doc = " @param[in]  context      context to pass to callback"]
	pub fn furi_hal_power_info_get(callback: FuriHalPowerInfoCallback, context: *mut core::ffi::c_void);
}
#[repr(C)]
pub struct Version {
	_unused: [u8; 0],
}
extern "C" {
	#[doc = " Get current running firmware version handle."]
	#[doc = ""]
	#[doc = " You can store it somewhere. But if you want to retrieve data, you have to use"]
	#[doc = " 'version_*_get()' set of functions. Also, 'version_*_get()' imply to use this"]
	#[doc = " handle if no handle (NULL_PTR) provided."]
	#[doc = ""]
	#[doc = " @return     pointer to Version data."]
	pub fn version_get() -> *const Version;
}
extern "C" {
	#[doc = " Get git commit hash."]
	#[doc = ""]
	#[doc = " @param      v     pointer to Version data. NULL for currently running"]
	#[doc = "                   software."]
	#[doc = ""]
	#[doc = " @return     git hash"]
	pub fn version_get_githash(v: *const Version) -> *const core::ffi::c_char;
}
extern "C" {
	#[doc = " Get git branch."]
	#[doc = ""]
	#[doc = " @param      v     pointer to Version data. NULL for currently running"]
	#[doc = "                   software."]
	#[doc = ""]
	#[doc = " @return     git branch"]
	pub fn version_get_gitbranch(v: *const Version) -> *const core::ffi::c_char;
}
extern "C" {
	#[doc = " Get number of commit in git branch."]
	#[doc = ""]
	#[doc = " @param      v     pointer to Version data. NULL for currently running"]
	#[doc = "                   software."]
	#[doc = ""]
	#[doc = " @return     number of commit"]
	pub fn version_get_gitbranchnum(v: *const Version) -> *const core::ffi::c_char;
}
extern "C" {
	#[doc = " Get build date."]
	#[doc = ""]
	#[doc = " @param      v     pointer to Version data. NULL for currently running"]
	#[doc = "                   software."]
	#[doc = ""]
	#[doc = " @return     build date"]
	pub fn version_get_builddate(v: *const Version) -> *const core::ffi::c_char;
}
extern "C" {
	#[doc = " Get build version. Build version is last tag in git history."]
	#[doc = ""]
	#[doc = " @param      v     pointer to Version data. NULL for currently running"]
	#[doc = "                   software."]
	#[doc = ""]
	#[doc = " @return     build date"]
	pub fn version_get_version(v: *const Version) -> *const core::ffi::c_char;
}
extern "C" {
	#[doc = " Get hardware target this firmware was built for"]
	#[doc = ""]
	#[doc = " @param      v     pointer to Version data. NULL for currently running"]
	#[doc = "                   software."]
	#[doc = ""]
	#[doc = " @return     build date"]
	pub fn version_get_target(v: *const Version) -> u8;
}
extern "C" {
	#[doc = " Get flag indicating if this build is \"dirty\" (source code had uncommited changes)"]
	#[doc = ""]
	#[doc = " @param      v     pointer to Version data. NULL for currently running"]
	#[doc = "                   software."]
	#[doc = ""]
	#[doc = " @return     build date"]
	pub fn version_get_dirty_flag(v: *const Version) -> bool;
}
#[repr(u32)]
#[non_exhaustive]
#[doc = " OTP Versions enum"]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum FuriHalVersionOtpVersion {
	FuriHalVersionOtpVersion0 = 0,
	FuriHalVersionOtpVersion1 = 1,
	FuriHalVersionOtpVersion2 = 2,
	FuriHalVersionOtpVersionEmpty = 4294967294,
	FuriHalVersionOtpVersionUnknown = 4294967295,
}
#[repr(u32)]
#[non_exhaustive]
#[doc = " Device Colors"]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum FuriHalVersionColor {
	FuriHalVersionColorUnknown = 0,
	FuriHalVersionColorBlack = 1,
	FuriHalVersionColorWhite = 2,
}
#[repr(u32)]
#[non_exhaustive]
#[doc = " Device Regions"]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum FuriHalVersionRegion {
	FuriHalVersionRegionUnknown = 0,
	FuriHalVersionRegionEuRu = 1,
	FuriHalVersionRegionUsCaAu = 2,
	FuriHalVersionRegionJp = 3,
	FuriHalVersionRegionWorld = 4,
}
#[repr(u32)]
#[non_exhaustive]
#[doc = " Device Display"]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum FuriHalVersionDisplay {
	FuriHalVersionDisplayUnknown = 0,
	FuriHalVersionDisplayErc = 1,
	FuriHalVersionDisplayMgg = 2,
}
extern "C" {
	#[doc = " Init flipper version"]
	pub fn furi_hal_version_init();
}
extern "C" {
	#[doc = " Check target firmware version"]
	#[doc = ""]
	#[doc = " @return     true if target and real matches"]
	pub fn furi_hal_version_do_i_belong_here() -> bool;
}
extern "C" {
	#[doc = " Get model name"]
	#[doc = ""]
	#[doc = " @return     model name C-string"]
	pub fn furi_hal_version_get_model_name() -> *const core::ffi::c_char;
}
extern "C" {
	#[doc = " Get OTP version"]
	#[doc = ""]
	#[doc = " @return     OTP Version"]
	pub fn furi_hal_version_get_otp_version() -> FuriHalVersionOtpVersion;
}
extern "C" {
	#[doc = " Get hardware version"]
	#[doc = ""]
	#[doc = " @return     Hardware Version"]
	pub fn furi_hal_version_get_hw_version() -> u8;
}
extern "C" {
	#[doc = " Get hardware target"]
	#[doc = ""]
	#[doc = " @return     Hardware Target"]
	pub fn furi_hal_version_get_hw_target() -> u8;
}
extern "C" {
	#[doc = " Get hardware body"]
	#[doc = ""]
	#[doc = " @return     Hardware Body"]
	pub fn furi_hal_version_get_hw_body() -> u8;
}
extern "C" {
	#[doc = " Get hardware body color"]
	#[doc = ""]
	#[doc = " @return     Hardware Color"]
	pub fn furi_hal_version_get_hw_color() -> FuriHalVersionColor;
}
extern "C" {
	#[doc = " Get hardware connect"]
	#[doc = ""]
	#[doc = " @return     Hardware Interconnect"]
	pub fn furi_hal_version_get_hw_connect() -> u8;
}
extern "C" {
	#[doc = " Get hardware region"]
	#[doc = ""]
	#[doc = " @return     Hardware Region"]
	pub fn furi_hal_version_get_hw_region() -> FuriHalVersionRegion;
}
extern "C" {
	#[doc = " Get hardware region name"]
	#[doc = ""]
	#[doc = " @return     Hardware Region name"]
	pub fn furi_hal_version_get_hw_region_name() -> *const core::ffi::c_char;
}
extern "C" {
	#[doc = " Get hardware display id"]
	#[doc = ""]
	#[doc = " @return     Display id"]
	pub fn furi_hal_version_get_hw_display() -> FuriHalVersionDisplay;
}
extern "C" {
	#[doc = " Get hardware timestamp"]
	#[doc = ""]
	#[doc = " @return     Hardware Manufacture timestamp"]
	pub fn furi_hal_version_get_hw_timestamp() -> u32;
}
extern "C" {
	#[doc = " Get pointer to target name"]
	#[doc = ""]
	#[doc = " @return     Hardware Name C-string"]
	pub fn furi_hal_version_get_name_ptr() -> *const core::ffi::c_char;
}
extern "C" {
	#[doc = " Get pointer to target device name"]
	#[doc = ""]
	#[doc = " @return     Hardware Device Name C-string"]
	pub fn furi_hal_version_get_device_name_ptr() -> *const core::ffi::c_char;
}
extern "C" {
	#[doc = " Get pointer to target ble local device name"]
	#[doc = ""]
	#[doc = " @return     Ble Device Name C-string"]
	pub fn furi_hal_version_get_ble_local_device_name_ptr() -> *const core::ffi::c_char;
}
extern "C" {
	#[doc = " Get BLE MAC address"]
	#[doc = ""]
	#[doc = " @return     pointer to BLE MAC address"]
	pub fn furi_hal_version_get_ble_mac() -> *const u8;
}
extern "C" {
	#[doc = " Get address of version structure of firmware."]
	#[doc = ""]
	#[doc = " @return     Address of firmware version structure."]
	pub fn furi_hal_version_get_firmware_version() -> *const Version;
}
extern "C" {
	#[doc = " Get platform UID size in bytes"]
	#[doc = ""]
	#[doc = " @return     UID size in bytes"]
	pub fn furi_hal_version_uid_size() -> usize;
}
extern "C" {
	#[doc = " Get const pointer to UID"]
	#[doc = ""]
	#[doc = " @return     pointer to UID"]
	pub fn furi_hal_version_uid() -> *const u8;
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum GapEventType {
	GapEventTypeConnected = 0,
	GapEventTypeDisconnected = 1,
	GapEventTypeStartAdvertising = 2,
	GapEventTypeStopAdvertising = 3,
	GapEventTypePinCodeShow = 4,
	GapEventTypePinCodeVerify = 5,
	GapEventTypeUpdateMTU = 6,
}
#[repr(C)]
pub struct GapEventData {
	pub pin_code: __BindgenUnionField<u32>,
	pub max_packet_size: __BindgenUnionField<u16>,
	pub bindgen_union_field: u32,
}
#[test]
fn bindgen_test_layout_GapEventData() {
	assert_eq!(
	           ::core::mem::size_of::<GapEventData>(),
	           4usize,
	           concat!("Size of: ", stringify!(GapEventData))
	);
	assert_eq!(
	           ::core::mem::align_of::<GapEventData>(),
	           4usize,
	           concat!("Alignment of ", stringify!(GapEventData))
	);
	fn test_field_pin_code() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<GapEventData>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).pin_code) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(GapEventData), "::", stringify!(pin_code))
		);
	}
	test_field_pin_code();
	fn test_field_max_packet_size() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<GapEventData>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).max_packet_size) as usize - ptr as usize
		           },
		           0usize,
		           concat!(
			"Offset of field: ",
			stringify!(GapEventData),
			"::",
			stringify!(max_packet_size)
		)
		);
	}
	test_field_max_packet_size();
}
#[repr(C)]
pub struct GapEvent {
	pub type_: GapEventType,
	pub data: GapEventData,
}
#[test]
fn bindgen_test_layout_GapEvent() {
	assert_eq!(
	           ::core::mem::size_of::<GapEvent>(),
	           8usize,
	           concat!("Size of: ", stringify!(GapEvent))
	);
	assert_eq!(
	           ::core::mem::align_of::<GapEvent>(),
	           4usize,
	           concat!("Alignment of ", stringify!(GapEvent))
	);
	fn test_field_type() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<GapEvent>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(GapEvent), "::", stringify!(type_))
		);
	}
	test_field_type();
	fn test_field_data() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<GapEvent>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).data) as usize - ptr as usize
		           },
		           4usize,
		           concat!("Offset of field: ", stringify!(GapEvent), "::", stringify!(data))
		);
	}
	test_field_data();
}
pub type GapEventCallback = ::core::option::Option<unsafe extern "C" fn(event: GapEvent, context: *mut core::ffi::c_void) -> bool>;
#[repr(u32)]
#[non_exhaustive]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum GapState {
	GapStateUninitialized = 0,
	GapStateIdle = 1,
	GapStateStartingAdv = 2,
	GapStateAdvFast = 3,
	GapStateAdvLowPower = 4,
	GapStateConnected = 5,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum GapPairing {
	GapPairingNone = 0,
	GapPairingPinCodeShow = 1,
	GapPairingPinCodeVerifyYesNo = 2,
}
#[repr(C)]
pub struct GapConnectionParamsRequest {
	pub conn_int_min: u16,
	pub conn_int_max: u16,
	pub slave_latency: u16,
	pub supervisor_timeout: u16,
}
#[test]
fn bindgen_test_layout_GapConnectionParamsRequest() {
	assert_eq!(
	           ::core::mem::size_of::<GapConnectionParamsRequest>(),
	           8usize,
	           concat!("Size of: ", stringify!(GapConnectionParamsRequest))
	);
	assert_eq!(
	           ::core::mem::align_of::<GapConnectionParamsRequest>(),
	           2usize,
	           concat!("Alignment of ", stringify!(GapConnectionParamsRequest))
	);
	fn test_field_conn_int_min() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<GapConnectionParamsRequest>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).conn_int_min) as usize - ptr as usize
		           },
		           0usize,
		           concat!(
			"Offset of field: ",
			stringify!(GapConnectionParamsRequest),
			"::",
			stringify!(conn_int_min)
		)
		);
	}
	test_field_conn_int_min();
	fn test_field_conn_int_max() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<GapConnectionParamsRequest>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).conn_int_max) as usize - ptr as usize
		           },
		           2usize,
		           concat!(
			"Offset of field: ",
			stringify!(GapConnectionParamsRequest),
			"::",
			stringify!(conn_int_max)
		)
		);
	}
	test_field_conn_int_max();
	fn test_field_slave_latency() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<GapConnectionParamsRequest>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).slave_latency) as usize - ptr as usize
		           },
		           4usize,
		           concat!(
			"Offset of field: ",
			stringify!(GapConnectionParamsRequest),
			"::",
			stringify!(slave_latency)
		)
		);
	}
	test_field_slave_latency();
	fn test_field_supervisor_timeout() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<GapConnectionParamsRequest>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).supervisor_timeout) as usize - ptr as usize
		           },
		           6usize,
		           concat!(
			"Offset of field: ",
			stringify!(GapConnectionParamsRequest),
			"::",
			stringify!(supervisor_timeout)
		)
		);
	}
	test_field_supervisor_timeout();
}
#[repr(C)]
pub struct GapConfig {
	pub adv_service_uuid: u16,
	pub appearance_char: u16,
	pub bonding_mode: bool,
	pub pairing_method: GapPairing,
	pub mac_address: [u8; 6usize],
	pub adv_name: [core::ffi::c_char; 18usize],
	pub conn_param: GapConnectionParamsRequest,
}
#[test]
fn bindgen_test_layout_GapConfig() {
	assert_eq!(
	           ::core::mem::size_of::<GapConfig>(),
	           44usize,
	           concat!("Size of: ", stringify!(GapConfig))
	);
	assert_eq!(
	           ::core::mem::align_of::<GapConfig>(),
	           4usize,
	           concat!("Alignment of ", stringify!(GapConfig))
	);
	fn test_field_adv_service_uuid() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<GapConfig>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).adv_service_uuid) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(GapConfig), "::", stringify!(adv_service_uuid))
		);
	}
	test_field_adv_service_uuid();
	fn test_field_appearance_char() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<GapConfig>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).appearance_char) as usize - ptr as usize
		           },
		           2usize,
		           concat!("Offset of field: ", stringify!(GapConfig), "::", stringify!(appearance_char))
		);
	}
	test_field_appearance_char();
	fn test_field_bonding_mode() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<GapConfig>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).bonding_mode) as usize - ptr as usize
		           },
		           4usize,
		           concat!("Offset of field: ", stringify!(GapConfig), "::", stringify!(bonding_mode))
		);
	}
	test_field_bonding_mode();
	fn test_field_pairing_method() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<GapConfig>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).pairing_method) as usize - ptr as usize
		           },
		           8usize,
		           concat!("Offset of field: ", stringify!(GapConfig), "::", stringify!(pairing_method))
		);
	}
	test_field_pairing_method();
	fn test_field_mac_address() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<GapConfig>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).mac_address) as usize - ptr as usize
		           },
		           12usize,
		           concat!("Offset of field: ", stringify!(GapConfig), "::", stringify!(mac_address))
		);
	}
	test_field_mac_address();
	fn test_field_adv_name() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<GapConfig>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).adv_name) as usize - ptr as usize
		           },
		           18usize,
		           concat!("Offset of field: ", stringify!(GapConfig), "::", stringify!(adv_name))
		);
	}
	test_field_adv_name();
	fn test_field_conn_param() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<GapConfig>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).conn_param) as usize - ptr as usize
		           },
		           36usize,
		           concat!("Offset of field: ", stringify!(GapConfig), "::", stringify!(conn_param))
		);
	}
	test_field_conn_param();
}
extern "C" {
	pub fn gap_init(config: *mut GapConfig, on_event_cb: GapEventCallback, context: *mut core::ffi::c_void) -> bool;
}
extern "C" {
	pub fn gap_start_advertising();
}
extern "C" {
	pub fn gap_stop_advertising();
}
extern "C" {
	pub fn gap_get_state() -> GapState;
}
extern "C" {
	pub fn gap_thread_stop();
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum SerialServiceEventType {
	SerialServiceEventTypeDataReceived = 0,
	SerialServiceEventTypeDataSent = 1,
}
#[repr(C)]
pub struct SerialServiceData {
	pub buffer: *mut u8,
	pub size: u16,
}
#[test]
fn bindgen_test_layout_SerialServiceData() {
	assert_eq!(
	           ::core::mem::size_of::<SerialServiceData>(),
	           8usize,
	           concat!("Size of: ", stringify!(SerialServiceData))
	);
	assert_eq!(
	           ::core::mem::align_of::<SerialServiceData>(),
	           4usize,
	           concat!("Alignment of ", stringify!(SerialServiceData))
	);
	fn test_field_buffer() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<SerialServiceData>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).buffer) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(SerialServiceData), "::", stringify!(buffer))
		);
	}
	test_field_buffer();
	fn test_field_size() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<SerialServiceData>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).size) as usize - ptr as usize
		           },
		           4usize,
		           concat!("Offset of field: ", stringify!(SerialServiceData), "::", stringify!(size))
		);
	}
	test_field_size();
}
#[repr(C)]
pub struct SerialServiceEvent {
	pub event: SerialServiceEventType,
	pub data: SerialServiceData,
}
#[test]
fn bindgen_test_layout_SerialServiceEvent() {
	assert_eq!(
	           ::core::mem::size_of::<SerialServiceEvent>(),
	           12usize,
	           concat!("Size of: ", stringify!(SerialServiceEvent))
	);
	assert_eq!(
	           ::core::mem::align_of::<SerialServiceEvent>(),
	           4usize,
	           concat!("Alignment of ", stringify!(SerialServiceEvent))
	);
	fn test_field_event() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<SerialServiceEvent>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).event) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(SerialServiceEvent), "::", stringify!(event))
		);
	}
	test_field_event();
	fn test_field_data() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<SerialServiceEvent>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).data) as usize - ptr as usize
		           },
		           4usize,
		           concat!("Offset of field: ", stringify!(SerialServiceEvent), "::", stringify!(data))
		);
	}
	test_field_data();
}
pub type SerialServiceEventCallback =
	::core::option::Option<unsafe extern "C" fn(event: SerialServiceEvent, context: *mut core::ffi::c_void) -> u16>;
extern "C" {
	pub fn serial_svc_start();
}
extern "C" {
	pub fn serial_svc_set_callbacks(buff_size: u16, callback: SerialServiceEventCallback, context: *mut core::ffi::c_void);
}
extern "C" {
	pub fn serial_svc_notify_buffer_is_empty();
}
extern "C" {
	pub fn serial_svc_stop();
}
extern "C" {
	pub fn serial_svc_is_started() -> bool;
}
extern "C" {
	pub fn serial_svc_update_tx(data: *mut u8, data_len: u16) -> bool;
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum BleGlueC2Mode {
	BleGlueC2ModeUnknown = 0,
	BleGlueC2ModeFUS = 1,
	BleGlueC2ModeStack = 2,
}
#[repr(C)]
pub struct BleGlueC2Info {
	pub mode: BleGlueC2Mode,
	#[doc = " Wireless Info"]
	pub VersionMajor: u8,
	pub VersionMinor: u8,
	pub VersionSub: u8,
	pub VersionBranch: u8,
	pub VersionReleaseType: u8,
	pub MemorySizeSram2B: u8,
	pub MemorySizeSram2A: u8,
	pub MemorySizeSram1: u8,
	pub MemorySizeFlash: u8,
	pub StackType: u8,
	pub StackTypeString: [core::ffi::c_char; 20usize],
	#[doc = " Fus Info"]
	pub FusVersionMajor: u8,
	pub FusVersionMinor: u8,
	pub FusVersionSub: u8,
	pub FusMemorySizeSram2B: u8,
	pub FusMemorySizeSram2A: u8,
	pub FusMemorySizeFlash: u8,
}
#[test]
fn bindgen_test_layout_BleGlueC2Info() {
	assert_eq!(
	           ::core::mem::size_of::<BleGlueC2Info>(),
	           40usize,
	           concat!("Size of: ", stringify!(BleGlueC2Info))
	);
	assert_eq!(
	           ::core::mem::align_of::<BleGlueC2Info>(),
	           4usize,
	           concat!("Alignment of ", stringify!(BleGlueC2Info))
	);
	fn test_field_mode() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<BleGlueC2Info>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).mode) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(BleGlueC2Info), "::", stringify!(mode))
		);
	}
	test_field_mode();
	fn test_field_VersionMajor() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<BleGlueC2Info>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).VersionMajor) as usize - ptr as usize
		           },
		           4usize,
		           concat!("Offset of field: ", stringify!(BleGlueC2Info), "::", stringify!(VersionMajor))
		);
	}
	test_field_VersionMajor();
	fn test_field_VersionMinor() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<BleGlueC2Info>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).VersionMinor) as usize - ptr as usize
		           },
		           5usize,
		           concat!("Offset of field: ", stringify!(BleGlueC2Info), "::", stringify!(VersionMinor))
		);
	}
	test_field_VersionMinor();
	fn test_field_VersionSub() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<BleGlueC2Info>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).VersionSub) as usize - ptr as usize
		           },
		           6usize,
		           concat!("Offset of field: ", stringify!(BleGlueC2Info), "::", stringify!(VersionSub))
		);
	}
	test_field_VersionSub();
	fn test_field_VersionBranch() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<BleGlueC2Info>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).VersionBranch) as usize - ptr as usize
		           },
		           7usize,
		           concat!(
			"Offset of field: ",
			stringify!(BleGlueC2Info),
			"::",
			stringify!(VersionBranch)
		)
		);
	}
	test_field_VersionBranch();
	fn test_field_VersionReleaseType() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<BleGlueC2Info>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).VersionReleaseType) as usize - ptr as usize
		           },
		           8usize,
		           concat!(
			"Offset of field: ",
			stringify!(BleGlueC2Info),
			"::",
			stringify!(VersionReleaseType)
		)
		);
	}
	test_field_VersionReleaseType();
	fn test_field_MemorySizeSram2B() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<BleGlueC2Info>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).MemorySizeSram2B) as usize - ptr as usize
		           },
		           9usize,
		           concat!(
			"Offset of field: ",
			stringify!(BleGlueC2Info),
			"::",
			stringify!(MemorySizeSram2B)
		)
		);
	}
	test_field_MemorySizeSram2B();
	fn test_field_MemorySizeSram2A() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<BleGlueC2Info>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).MemorySizeSram2A) as usize - ptr as usize
		           },
		           10usize,
		           concat!(
			"Offset of field: ",
			stringify!(BleGlueC2Info),
			"::",
			stringify!(MemorySizeSram2A)
		)
		);
	}
	test_field_MemorySizeSram2A();
	fn test_field_MemorySizeSram1() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<BleGlueC2Info>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).MemorySizeSram1) as usize - ptr as usize
		           },
		           11usize,
		           concat!(
			"Offset of field: ",
			stringify!(BleGlueC2Info),
			"::",
			stringify!(MemorySizeSram1)
		)
		);
	}
	test_field_MemorySizeSram1();
	fn test_field_MemorySizeFlash() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<BleGlueC2Info>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).MemorySizeFlash) as usize - ptr as usize
		           },
		           12usize,
		           concat!(
			"Offset of field: ",
			stringify!(BleGlueC2Info),
			"::",
			stringify!(MemorySizeFlash)
		)
		);
	}
	test_field_MemorySizeFlash();
	fn test_field_StackType() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<BleGlueC2Info>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).StackType) as usize - ptr as usize
		           },
		           13usize,
		           concat!("Offset of field: ", stringify!(BleGlueC2Info), "::", stringify!(StackType))
		);
	}
	test_field_StackType();
	fn test_field_StackTypeString() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<BleGlueC2Info>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).StackTypeString) as usize - ptr as usize
		           },
		           14usize,
		           concat!(
			"Offset of field: ",
			stringify!(BleGlueC2Info),
			"::",
			stringify!(StackTypeString)
		)
		);
	}
	test_field_StackTypeString();
	fn test_field_FusVersionMajor() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<BleGlueC2Info>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).FusVersionMajor) as usize - ptr as usize
		           },
		           34usize,
		           concat!(
			"Offset of field: ",
			stringify!(BleGlueC2Info),
			"::",
			stringify!(FusVersionMajor)
		)
		);
	}
	test_field_FusVersionMajor();
	fn test_field_FusVersionMinor() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<BleGlueC2Info>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).FusVersionMinor) as usize - ptr as usize
		           },
		           35usize,
		           concat!(
			"Offset of field: ",
			stringify!(BleGlueC2Info),
			"::",
			stringify!(FusVersionMinor)
		)
		);
	}
	test_field_FusVersionMinor();
	fn test_field_FusVersionSub() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<BleGlueC2Info>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).FusVersionSub) as usize - ptr as usize
		           },
		           36usize,
		           concat!(
			"Offset of field: ",
			stringify!(BleGlueC2Info),
			"::",
			stringify!(FusVersionSub)
		)
		);
	}
	test_field_FusVersionSub();
	fn test_field_FusMemorySizeSram2B() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<BleGlueC2Info>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).FusMemorySizeSram2B) as usize - ptr as usize
		           },
		           37usize,
		           concat!(
			"Offset of field: ",
			stringify!(BleGlueC2Info),
			"::",
			stringify!(FusMemorySizeSram2B)
		)
		);
	}
	test_field_FusMemorySizeSram2B();
	fn test_field_FusMemorySizeSram2A() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<BleGlueC2Info>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).FusMemorySizeSram2A) as usize - ptr as usize
		           },
		           38usize,
		           concat!(
			"Offset of field: ",
			stringify!(BleGlueC2Info),
			"::",
			stringify!(FusMemorySizeSram2A)
		)
		);
	}
	test_field_FusMemorySizeSram2A();
	fn test_field_FusMemorySizeFlash() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<BleGlueC2Info>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).FusMemorySizeFlash) as usize - ptr as usize
		           },
		           39usize,
		           concat!(
			"Offset of field: ",
			stringify!(BleGlueC2Info),
			"::",
			stringify!(FusMemorySizeFlash)
		)
		);
	}
	test_field_FusMemorySizeFlash();
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum BleGlueStatus {
	BleGlueStatusStartup = 0,
	BleGlueStatusBroken = 1,
	BleGlueStatusC2Started = 2,
	BleGlueStatusRadioStackRunning = 3,
	BleGlueStatusRadioStackMissing = 4,
}
pub type BleGlueKeyStorageChangedCallback =
	::core::option::Option<unsafe extern "C" fn(change_addr_start: *mut u8, size: u16, context: *mut core::ffi::c_void)>;
extern "C" {
	#[doc = " Initialize start core2 and initialize transport"]
	pub fn ble_glue_init();
}
extern "C" {
	#[doc = " Start Core2 Radio stack"]
	#[doc = ""]
	#[doc = " @return     true on success"]
	pub fn ble_glue_start() -> bool;
}
extern "C" {
	#[doc = " Is core2 alive and at least FUS is running"]
	#[doc = ""]
	#[doc = " @return     true if core2 is alive"]
	pub fn ble_glue_is_alive() -> bool;
}
extern "C" {
	#[doc = " Waits for C2 to reports its mode to callback"]
	#[doc = ""]
	#[doc = " @return     true if it reported before reaching timeout"]
	pub fn ble_glue_wait_for_c2_start(timeout: i32) -> bool;
}
extern "C" {
	pub fn ble_glue_get_c2_status() -> BleGlueStatus;
}
extern "C" {
	pub fn ble_glue_get_c2_info() -> *const BleGlueC2Info;
}
extern "C" {
	#[doc = " Is core2 radio stack present and ready"]
	#[doc = ""]
	#[doc = " @return     true if present and ready"]
	pub fn ble_glue_is_radio_stack_ready() -> bool;
}
extern "C" {
	#[doc = " Set callback for NVM in RAM changes"]
	#[doc = ""]
	#[doc = " @param[in]  callback  The callback to call on NVM change"]
	#[doc = " @param      context   The context for callback"]
	pub fn ble_glue_set_key_storage_changed_callback(callback: BleGlueKeyStorageChangedCallback, context: *mut core::ffi::c_void);
}
extern "C" {
	#[doc = " Stop SHCI thread"]
	pub fn ble_glue_thread_stop();
}
extern "C" {
	pub fn ble_glue_reinit_c2() -> bool;
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum BleGlueCommandResult {
	BleGlueCommandResultUnknown = 0,
	BleGlueCommandResultOK = 1,
	BleGlueCommandResultError = 2,
	BleGlueCommandResultRestartPending = 3,
	BleGlueCommandResultOperationOngoing = 4,
}
extern "C" {
	#[doc = " Restart MCU to launch radio stack firmware if necessary"]
	#[doc = ""]
	#[doc = " @return      true on radio stack start command"]
	pub fn ble_glue_force_c2_mode(mode: BleGlueC2Mode) -> BleGlueCommandResult;
}
extern "C" {
	pub fn ble_glue_fus_stack_delete() -> BleGlueCommandResult;
}
extern "C" {
	pub fn ble_glue_fus_stack_install(src_addr: u32, dst_addr: u32) -> BleGlueCommandResult;
}
extern "C" {
	pub fn ble_glue_fus_get_status() -> BleGlueCommandResult;
}
extern "C" {
	pub fn ble_glue_fus_wait_operation() -> BleGlueCommandResult;
}
extern "C" {
	pub fn ble_app_init() -> bool;
}
extern "C" {
	pub fn ble_app_get_key_storage_buff(addr: *mut *mut u8, size: *mut u16);
}
extern "C" {
	pub fn ble_app_thread_stop();
}
#[doc = " Serial service callback type"]
pub type FuriHalBtSerialCallback = SerialServiceEventCallback;
extern "C" {
	#[doc = " Start Serial Profile"]
	pub fn furi_hal_bt_serial_start();
}
extern "C" {
	#[doc = " Stop Serial Profile"]
	pub fn furi_hal_bt_serial_stop();
}
extern "C" {
	#[doc = " Set Serial service events callback"]
	#[doc = ""]
	#[doc = " @param buffer_size   Applicaition buffer size"]
	#[doc = " @param calback       FuriHalBtSerialCallback instance"]
	#[doc = " @param context       pointer to context"]
	pub fn furi_hal_bt_serial_set_event_callback(buff_size: u16, callback: FuriHalBtSerialCallback, context: *mut core::ffi::c_void);
}
extern "C" {
	#[doc = " Notify that application buffer is empty"]
	pub fn furi_hal_bt_serial_notify_buffer_is_empty();
}
extern "C" {
	#[doc = " Send data through BLE"]
	#[doc = ""]
	#[doc = " @param data  data buffer"]
	#[doc = " @param size  data buffer size"]
	#[doc = ""]
	#[doc = " @return      true on success"]
	pub fn furi_hal_bt_serial_tx(data: *mut u8, size: u16) -> bool;
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum FuriHalBtStack {
	FuriHalBtStackUnknown = 0,
	FuriHalBtStackLight = 1,
	FuriHalBtStackFull = 2,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum FuriHalBtProfile {
	FuriHalBtProfileSerial = 0,
	FuriHalBtProfileHidKeyboard = 1,
	FuriHalBtProfileNumber = 2,
}
extern "C" {
	#[doc = " Initialize"]
	pub fn furi_hal_bt_init();
}
extern "C" {
	#[doc = " Lock core2 state transition"]
	pub fn furi_hal_bt_lock_core2();
}
extern "C" {
	#[doc = " Lock core2 state transition"]
	pub fn furi_hal_bt_unlock_core2();
}
extern "C" {
	#[doc = " Start radio stack"]
	#[doc = ""]
	#[doc = " @return  true on successfull radio stack start"]
	pub fn furi_hal_bt_start_radio_stack() -> bool;
}
extern "C" {
	#[doc = " Get radio stack type"]
	#[doc = ""]
	#[doc = " @return  FuriHalBtStack instance"]
	pub fn furi_hal_bt_get_radio_stack() -> FuriHalBtStack;
}
extern "C" {
	#[doc = " Check if radio stack supports BLE GAT/GAP"]
	#[doc = ""]
	#[doc = " @return  true if supported"]
	pub fn furi_hal_bt_is_ble_gatt_gap_supported() -> bool;
}
extern "C" {
	#[doc = " Check if radio stack supports testing"]
	#[doc = ""]
	#[doc = " @return  true if supported"]
	pub fn furi_hal_bt_is_testing_supported() -> bool;
}
extern "C" {
	#[doc = " Start BLE app"]
	#[doc = ""]
	#[doc = " @param profile   FuriHalBtProfile instance"]
	#[doc = " @param event_cb  GapEventCallback instance"]
	#[doc = " @param context   pointer to context"]
	#[doc = ""]
	#[doc = " @return          true on success"]
	pub fn furi_hal_bt_start_app(profile: FuriHalBtProfile, event_cb: GapEventCallback, context: *mut core::ffi::c_void) -> bool;
}
extern "C" {
	#[doc = " Reinitialize core2"]
	#[doc = ""]
	#[doc = " Also can be used to prepare core2 for stop modes"]
	pub fn furi_hal_bt_reinit();
}
extern "C" {
	#[doc = " Change BLE app"]
	#[doc = " Restarts 2nd core"]
	#[doc = ""]
	#[doc = " @param profile   FuriHalBtProfile instance"]
	#[doc = " @param event_cb  GapEventCallback instance"]
	#[doc = " @param context   pointer to context"]
	#[doc = ""]
	#[doc = " @return          true on success"]
	pub fn furi_hal_bt_change_app(profile: FuriHalBtProfile, event_cb: GapEventCallback, context: *mut core::ffi::c_void) -> bool;
}
extern "C" {
	#[doc = " Update battery level"]
	#[doc = ""]
	#[doc = " @param battery_level battery level"]
	pub fn furi_hal_bt_update_battery_level(battery_level: u8);
}
extern "C" {
	#[doc = " Update battery power state"]
	pub fn furi_hal_bt_update_power_state();
}
extern "C" {
	#[doc = " Checks if BLE state is active"]
	#[doc = ""]
	#[doc = " @return          true if device is connected or advertising, false otherwise"]
	pub fn furi_hal_bt_is_active() -> bool;
}
extern "C" {
	#[doc = " Start advertising"]
	pub fn furi_hal_bt_start_advertising();
}
extern "C" {
	#[doc = " Stop advertising"]
	pub fn furi_hal_bt_stop_advertising();
}
extern "C" {
	#[doc = " Get BT/BLE system component state"]
	#[doc = ""]
	#[doc = " @param[in]  buffer  string_t buffer to write to"]
	pub fn furi_hal_bt_dump_state(buffer: *mut string_t);
}
extern "C" {
	#[doc = " Get BT/BLE system component state"]
	#[doc = ""]
	#[doc = " @return     true if core2 is alive"]
	pub fn furi_hal_bt_is_alive() -> bool;
}
extern "C" {
	#[doc = " Get key storage buffer address and size"]
	#[doc = ""]
	#[doc = " @param      key_buff_addr  pointer to store buffer address"]
	#[doc = " @param      key_buff_size  pointer to store buffer size"]
	pub fn furi_hal_bt_get_key_storage_buff(key_buff_addr: *mut *mut u8, key_buff_size: *mut u16);
}
extern "C" {
	#[doc = " Get SRAM2 hardware semaphore"]
	#[doc = " @note Must be called before SRAM2 read/write operations"]
	pub fn furi_hal_bt_nvm_sram_sem_acquire();
}
extern "C" {
	#[doc = " Release SRAM2 hardware semaphore"]
	#[doc = " @note Must be called after SRAM2 read/write operations"]
	pub fn furi_hal_bt_nvm_sram_sem_release();
}
extern "C" {
	#[doc = " Clear key storage"]
	#[doc = ""]
	#[doc = " @return      true on success"]
	pub fn furi_hal_bt_clear_white_list() -> bool;
}
extern "C" {
	#[doc = " Set key storage change callback"]
	#[doc = ""]
	#[doc = " @param       callback    BleGlueKeyStorageChangedCallback instance"]
	#[doc = " @param       context     pointer to context"]
	pub fn furi_hal_bt_set_key_storage_change_callback(callback: BleGlueKeyStorageChangedCallback, context: *mut core::ffi::c_void);
}
extern "C" {
	#[doc = " Start ble tone tx at given channel and power"]
	#[doc = ""]
	#[doc = " @param[in]  channel  The channel"]
	#[doc = " @param[in]  power    The power"]
	pub fn furi_hal_bt_start_tone_tx(channel: u8, power: u8);
}
extern "C" {
	#[doc = " Stop ble tone tx"]
	pub fn furi_hal_bt_stop_tone_tx();
}
extern "C" {
	#[doc = " Start sending ble packets at a given frequency and datarate"]
	#[doc = ""]
	#[doc = " @param[in]  channel   The channel"]
	#[doc = " @param[in]  pattern   The pattern"]
	#[doc = " @param[in]  datarate  The datarate"]
	pub fn furi_hal_bt_start_packet_tx(channel: u8, pattern: u8, datarate: u8);
}
extern "C" {
	#[doc = " Stop sending ble packets"]
	#[doc = ""]
	#[doc = " @return     sent packet count"]
	pub fn furi_hal_bt_stop_packet_test() -> u16;
}
extern "C" {
	#[doc = " Start receiving packets"]
	#[doc = ""]
	#[doc = " @param[in]  channel   RX channel"]
	#[doc = " @param[in]  datarate  Datarate"]
	pub fn furi_hal_bt_start_packet_rx(channel: u8, datarate: u8);
}
extern "C" {
	#[doc = " Set up the RF to listen to a given RF channel"]
	#[doc = ""]
	#[doc = " @param[in]  channel  RX channel"]
	pub fn furi_hal_bt_start_rx(channel: u8);
}
extern "C" {
	#[doc = " Stop RF listenning"]
	pub fn furi_hal_bt_stop_rx();
}
extern "C" {
	#[doc = " Get RSSI"]
	#[doc = ""]
	#[doc = " @return     RSSI in dBm"]
	pub fn furi_hal_bt_get_rssi() -> core::ffi::c_float;
}
extern "C" {
	#[doc = " Get number of transmitted packets"]
	#[doc = ""]
	#[doc = " @return     packet count"]
	pub fn furi_hal_bt_get_transmitted_packets() -> u32;
}
extern "C" {
	#[doc = " Check & switch C2 to given mode"]
	#[doc = ""]
	#[doc = " @param[in]  mode  mode to switch into"]
	pub fn furi_hal_bt_ensure_c2_mode(mode: BleGlueC2Mode) -> bool;
}
#[repr(C)]
pub struct LevelDuration {
	pub level: u32,
	pub duration: u32,
}
#[test]
fn bindgen_test_layout_LevelDuration() {
	assert_eq!(
	           ::core::mem::size_of::<LevelDuration>(),
	           8usize,
	           concat!("Size of: ", stringify!(LevelDuration))
	);
	assert_eq!(
	           ::core::mem::align_of::<LevelDuration>(),
	           4usize,
	           concat!("Alignment of ", stringify!(LevelDuration))
	);
	fn test_field_level() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LevelDuration>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).level) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(LevelDuration), "::", stringify!(level))
		);
	}
	test_field_level();
	fn test_field_duration() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LevelDuration>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).duration) as usize - ptr as usize
		           },
		           4usize,
		           concat!("Offset of field: ", stringify!(LevelDuration), "::", stringify!(duration))
		);
	}
	test_field_duration();
}
#[repr(u32)]
#[non_exhaustive]
#[doc = " Radio Presets"]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum FuriHalSubGhzPreset {
	#[doc = "< default configuration"]
	FuriHalSubGhzPresetIDLE = 0,
	#[doc = "< OOK, bandwidth 270kHz, asynchronous"]
	FuriHalSubGhzPresetOok270Async = 1,
	#[doc = "< OOK, bandwidth 650kHz, asynchronous"]
	FuriHalSubGhzPresetOok650Async = 2,
	#[doc = "< FM, deviation 2.380371 kHz, asynchronous"]
	FuriHalSubGhzPreset2FSKDev238Async = 3,
	#[doc = "< FM, deviation 47.60742 kHz, asynchronous"]
	FuriHalSubGhzPreset2FSKDev476Async = 4,
	#[doc = "< MSK, deviation 47.60742 kHz, 99.97Kb/s, asynchronous"]
	FuriHalSubGhzPresetMSK99_97KbAsync = 5,
	#[doc = "< GFSK, deviation 19.042969 kHz, 9.996Kb/s, asynchronous"]
	FuriHalSubGhzPresetGFSK9_99KbAsync = 6,
	FuriHalSubGhzPresetCustom = 7,
}
#[repr(u32)]
#[non_exhaustive]
#[doc = " Switchable Radio Paths"]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum FuriHalSubGhzPath {
	#[doc = "< Isolate Radio from antenna"]
	FuriHalSubGhzPathIsolate = 0,
	#[doc = "< Center Frquency: 433MHz. Path 1: SW1RF1-SW2RF2, LCLCL"]
	FuriHalSubGhzPath433 = 1,
	#[doc = "< Center Frquency: 315MHz. Path 2: SW1RF2-SW2RF1, LCLCLCL"]
	FuriHalSubGhzPath315 = 2,
	#[doc = "< Center Frquency: 868MHz. Path 3: SW1RF3-SW2RF3, LCLC"]
	FuriHalSubGhzPath868 = 3,
}
extern "C" {
	#[doc = " Initialize and switch to power save mode Used by internal API-HAL"]
	#[doc = " initalization routine Can be used to reinitialize device to safe state and"]
	#[doc = " send it to sleep"]
	pub fn furi_hal_subghz_init();
}
extern "C" {
	#[doc = " Send device to sleep mode"]
	pub fn furi_hal_subghz_sleep();
}
extern "C" {
	#[doc = " Dump info to stdout"]
	pub fn furi_hal_subghz_dump_state();
}
extern "C" {
	#[doc = " Load registers from preset by preset name"]
	#[doc = ""]
	#[doc = " @param      preset  to load"]
	pub fn furi_hal_subghz_load_preset(preset: FuriHalSubGhzPreset);
}
extern "C" {
	#[doc = " Load custom registers from preset"]
	#[doc = ""]
	#[doc = " @param      preset_data   registers to load"]
	pub fn furi_hal_subghz_load_custom_preset(preset_data: *mut u8);
}
extern "C" {
	#[doc = " Load registers"]
	#[doc = ""]
	#[doc = " @param      data  Registers data"]
	pub fn furi_hal_subghz_load_registers(data: *mut u8);
}
extern "C" {
	#[doc = " Load PATABLE"]
	#[doc = ""]
	#[doc = " @param      data  8 uint8_t values"]
	pub fn furi_hal_subghz_load_patable(data: *const [u8; 8usize]);
}
extern "C" {
	#[doc = " Write packet to FIFO"]
	#[doc = ""]
	#[doc = " @param      data  bytes array"]
	#[doc = " @param      size  size"]
	pub fn furi_hal_subghz_write_packet(data: *const u8, size: u8);
}
extern "C" {
	#[doc = " Check if recieve pipe is not empty"]
	#[doc = ""]
	#[doc = " @return     true if not empty"]
	pub fn furi_hal_subghz_rx_pipe_not_empty() -> bool;
}
extern "C" {
	#[doc = " Check if recieved data crc is valid"]
	#[doc = ""]
	#[doc = " @return     true if valid"]
	pub fn furi_hal_subghz_is_rx_data_crc_valid() -> bool;
}
extern "C" {
	#[doc = " Read packet from FIFO"]
	#[doc = ""]
	#[doc = " @param      data  pointer"]
	#[doc = " @param      size  size"]
	pub fn furi_hal_subghz_read_packet(data: *mut u8, size: *mut u8);
}
extern "C" {
	#[doc = " Flush rx FIFO buffer"]
	pub fn furi_hal_subghz_flush_rx();
}
extern "C" {
	#[doc = " Flush tx FIFO buffer"]
	pub fn furi_hal_subghz_flush_tx();
}
extern "C" {
	#[doc = " Shutdown Issue spwd command"]
	#[doc = " @warning    registers content will be lost"]
	pub fn furi_hal_subghz_shutdown();
}
extern "C" {
	#[doc = " Reset Issue reset command"]
	#[doc = " @warning    registers content will be lost"]
	pub fn furi_hal_subghz_reset();
}
extern "C" {
	#[doc = " Switch to Idle"]
	pub fn furi_hal_subghz_idle();
}
extern "C" {
	#[doc = " Switch to Recieve"]
	pub fn furi_hal_subghz_rx();
}
extern "C" {
	#[doc = " Switch to Transmit"]
	#[doc = ""]
	#[doc = " @return     true if the transfer is allowed by belonging to the region"]
	pub fn furi_hal_subghz_tx() -> bool;
}
extern "C" {
	#[doc = " Get RSSI value in dBm"]
	#[doc = ""]
	#[doc = " @return     RSSI value"]
	pub fn furi_hal_subghz_get_rssi() -> core::ffi::c_float;
}
extern "C" {
	#[doc = " Get LQI"]
	#[doc = ""]
	#[doc = " @return     LQI value"]
	pub fn furi_hal_subghz_get_lqi() -> u8;
}
extern "C" {
	#[doc = " Check if frequency is in valid range"]
	#[doc = ""]
	#[doc = " @param      value  frequency in Hz"]
	#[doc = ""]
	#[doc = " @return     true if frequncy is valid, otherwise false"]
	pub fn furi_hal_subghz_is_frequency_valid(value: u32) -> bool;
}
extern "C" {
	#[doc = " Set frequency and path This function automatically selects antenna matching"]
	#[doc = " network"]
	#[doc = ""]
	#[doc = " @param      value  frequency in Hz"]
	#[doc = ""]
	#[doc = " @return     real frequency in herz"]
	pub fn furi_hal_subghz_set_frequency_and_path(value: u32) -> u32;
}
extern "C" {
	#[doc = " Set frequency"]
	#[doc = ""]
	#[doc = " @param      value  frequency in Hz"]
	#[doc = ""]
	#[doc = " @return     real frequency in herz"]
	pub fn furi_hal_subghz_set_frequency(value: u32) -> u32;
}
extern "C" {
	#[doc = " Set path"]
	#[doc = ""]
	#[doc = " @param      path  path to use"]
	pub fn furi_hal_subghz_set_path(path: FuriHalSubGhzPath);
}
#[doc = " Signal Timings Capture callback"]
pub type FuriHalSubGhzCaptureCallback =
	::core::option::Option<unsafe extern "C" fn(level: bool, duration: u32, context: *mut core::ffi::c_void)>;
extern "C" {
	#[doc = " Enable signal timings capture Initializes GPIO and TIM2 for timings capture"]
	#[doc = ""]
	#[doc = " @param      callback  FuriHalSubGhzCaptureCallback"]
	#[doc = " @param      context   callback context"]
	pub fn furi_hal_subghz_start_async_rx(callback: FuriHalSubGhzCaptureCallback, context: *mut core::ffi::c_void);
}
extern "C" {
	#[doc = " Disable signal timings capture Resets GPIO and TIM2"]
	pub fn furi_hal_subghz_stop_async_rx();
}
#[doc = " Async TX callback type"]
#[doc = " @param      context  callback context"]
#[doc = " @return     LevelDuration"]
pub type FuriHalSubGhzAsyncTxCallback =
	::core::option::Option<unsafe extern "C" fn(context: *mut core::ffi::c_void) -> LevelDuration>;
extern "C" {
	#[doc = " Start async TX Initializes GPIO, TIM2 and DMA1 for signal output"]
	#[doc = ""]
	#[doc = " @param      callback  FuriHalSubGhzAsyncTxCallback"]
	#[doc = " @param      context   callback context"]
	#[doc = ""]
	#[doc = " @return     true if the transfer is allowed by belonging to the region"]
	pub fn furi_hal_subghz_start_async_tx(callback: FuriHalSubGhzAsyncTxCallback, context: *mut core::ffi::c_void) -> bool;
}
extern "C" {
	#[doc = " Wait for async transmission to complete"]
	#[doc = ""]
	#[doc = " @return     true if TX complete"]
	pub fn furi_hal_subghz_is_async_tx_complete() -> bool;
}
extern "C" {
	#[doc = " Stop async transmission and cleanup resources Resets GPIO, TIM2, and DMA1"]
	pub fn furi_hal_subghz_stop_async_tx();
}
extern "C" {
	#[doc = " Initialize vibro"]
	pub fn furi_hal_vibro_init();
}
extern "C" {
	#[doc = " Turn on/off vibro"]
	#[doc = ""]
	#[doc = " @param[in]  value  new state"]
	pub fn furi_hal_vibro_on(value: bool);
}
pub type FuriHalIbuttonEmulateCallback = ::core::option::Option<unsafe extern "C" fn(context: *mut core::ffi::c_void)>;
extern "C" {
	#[doc = " Initialize"]
	pub fn furi_hal_ibutton_init();
}
extern "C" {
	pub fn furi_hal_ibutton_emulate_start(period: u32, callback: FuriHalIbuttonEmulateCallback, context: *mut core::ffi::c_void);
}
extern "C" {
	pub fn furi_hal_ibutton_emulate_set_next(period: u32);
}
extern "C" {
	pub fn furi_hal_ibutton_emulate_stop();
}
extern "C" {
	#[doc = " Sets the pin to normal mode (open collector), and sets it to float"]
	pub fn furi_hal_ibutton_start_drive();
}
extern "C" {
	#[doc = " Sets the pin to normal mode (open collector), and clears pin EXTI interrupt."]
	#[doc = " Used in EXTI interrupt context."]
	pub fn furi_hal_ibutton_start_drive_in_isr();
}
extern "C" {
	#[doc = " Sets the pin to interrupt mode (EXTI interrupt on rise or fall), and sets it to float"]
	pub fn furi_hal_ibutton_start_interrupt();
}
extern "C" {
	#[doc = " Sets the pin to interrupt mode (EXTI interrupt on rise or fall), and clears pin EXTI interrupt."]
	#[doc = " Used in EXTI interrupt context."]
	pub fn furi_hal_ibutton_start_interrupt_in_isr();
}
extern "C" {
	#[doc = " Sets the pin to analog mode, and sets it to float"]
	pub fn furi_hal_ibutton_stop();
}
extern "C" {
	#[doc = " Attach interrupt callback to iButton pin"]
	#[doc = " @param cb callback"]
	#[doc = " @param context context"]
	pub fn furi_hal_ibutton_add_interrupt(cb: GpioExtiCallback, context: *mut core::ffi::c_void);
}
extern "C" {
	#[doc = " Remove interrupt callback from iButton pin"]
	pub fn furi_hal_ibutton_remove_interrupt();
}
extern "C" {
	#[doc = " Sets the pin to low"]
	pub fn furi_hal_ibutton_pin_low();
}
extern "C" {
	#[doc = " Sets the pin to high (float in iButton pin modes)"]
	pub fn furi_hal_ibutton_pin_high();
}
extern "C" {
	#[doc = " Get pin level"]
	#[doc = " @return true if level is high"]
	#[doc = " @return false if level is low"]
	pub fn furi_hal_ibutton_pin_get_level() -> bool;
}
extern "C" {
	#[doc = " Initialize RFID subsystem"]
	pub fn furi_hal_rfid_init();
}
extern "C" {
	#[doc = " Config rfid pins to reset state"]
	pub fn furi_hal_rfid_pins_reset();
}
extern "C" {
	#[doc = " Config rfid pins to emulate state"]
	pub fn furi_hal_rfid_pins_emulate();
}
extern "C" {
	#[doc = " Config rfid pins to read state"]
	pub fn furi_hal_rfid_pins_read();
}
extern "C" {
	#[doc = " Release rfid pull pin"]
	pub fn furi_hal_rfid_pin_pull_release();
}
extern "C" {
	#[doc = " Pulldown rfid pull pin"]
	pub fn furi_hal_rfid_pin_pull_pulldown();
}
extern "C" {
	#[doc = " Config rfid timer to read state"]
	#[doc = ""]
	#[doc = " @param      freq        timer frequency"]
	#[doc = " @param      duty_cycle  timer duty cycle, 0.0-1.0"]
	pub fn furi_hal_rfid_tim_read(freq: core::ffi::c_float, duty_cycle: core::ffi::c_float);
}
extern "C" {
	#[doc = " Start read timer"]
	pub fn furi_hal_rfid_tim_read_start();
}
extern "C" {
	#[doc = " Stop read timer"]
	pub fn furi_hal_rfid_tim_read_stop();
}
extern "C" {
	#[doc = " Config rfid timer to emulate state"]
	#[doc = ""]
	#[doc = " @param      freq  timer frequency"]
	pub fn furi_hal_rfid_tim_emulate(freq: core::ffi::c_float);
}
pub type FuriHalRfidEmulateCallback = ::core::option::Option<unsafe extern "C" fn(context: *mut core::ffi::c_void)>;
extern "C" {
	#[doc = " Start emulation timer"]
	pub fn furi_hal_rfid_tim_emulate_start(callback: FuriHalRfidEmulateCallback, context: *mut core::ffi::c_void);
}
pub type FuriHalRfidReadCaptureCallback =
	::core::option::Option<unsafe extern "C" fn(level: bool, duration: u32, context: *mut core::ffi::c_void)>;
extern "C" {
	pub fn furi_hal_rfid_tim_read_capture_start(callback: FuriHalRfidReadCaptureCallback, context: *mut core::ffi::c_void);
}
extern "C" {
	pub fn furi_hal_rfid_tim_read_capture_stop();
}
pub type FuriHalRfidDMACallback = ::core::option::Option<unsafe extern "C" fn(half: bool, context: *mut core::ffi::c_void)>;
extern "C" {
	pub fn furi_hal_rfid_tim_emulate_dma_start(duration: *mut u32,
	                                           pulse: *mut u32,
	                                           length: usize,
	                                           callback: FuriHalRfidDMACallback,
	                                           context: *mut core::ffi::c_void);
}
extern "C" {
	pub fn furi_hal_rfid_tim_emulate_dma_stop();
}
extern "C" {
	#[doc = " Stop emulation timer"]
	pub fn furi_hal_rfid_tim_emulate_stop();
}
extern "C" {
	#[doc = " Config rfid timers to reset state"]
	pub fn furi_hal_rfid_tim_reset();
}
extern "C" {
	#[doc = " Set emulation timer period"]
	#[doc = ""]
	#[doc = " @param      period  overall duration"]
	pub fn furi_hal_rfid_set_emulate_period(period: u32);
}
extern "C" {
	#[doc = " Set emulation timer pulse"]
	#[doc = ""]
	#[doc = " @param      pulse  duration of high level"]
	pub fn furi_hal_rfid_set_emulate_pulse(pulse: u32);
}
extern "C" {
	#[doc = " Set read timer period"]
	#[doc = ""]
	#[doc = " @param      period  overall duration"]
	pub fn furi_hal_rfid_set_read_period(period: u32);
}
extern "C" {
	#[doc = " Set read timer pulse"]
	#[doc = ""]
	#[doc = " @param      pulse  duration of high level"]
	pub fn furi_hal_rfid_set_read_pulse(pulse: u32);
}
extern "C" {
	#[doc = " hanges the configuration of the RFID timer \"on a fly\""]
	#[doc = ""]
	#[doc = " @param      freq        new frequency"]
	#[doc = " @param      duty_cycle  new duty cycle"]
	pub fn furi_hal_rfid_change_read_config(freq: core::ffi::c_float, duty_cycle: core::ffi::c_float);
}
extern "C" {
	#[doc = " Start/Enable comparator"]
	pub fn furi_hal_rfid_comp_start();
}
extern "C" {
	#[doc = " Stop/Disable comparator"]
	pub fn furi_hal_rfid_comp_stop();
}
pub type FuriHalRfidCompCallback = ::core::option::Option<unsafe extern "C" fn(level: bool, context: *mut core::ffi::c_void)>;
extern "C" {
	#[doc = " Set comparator callback"]
	pub fn furi_hal_rfid_comp_set_callback(callback: FuriHalRfidCompCallback, context: *mut core::ffi::c_void);
}
pub type ReturnCode = u16;
extern "C" {
	#[doc = " \\brief  Calculate Timer"]
	#[doc = ""]
	#[doc = " This method calculates when the timer will be expired given the amount"]
	#[doc = " time in milliseconds /a tOut."]
	#[doc = " Once the timer has been calculated it will then be used to check when"]
	#[doc = " it expires."]
	#[doc = ""]
	#[doc = " \\see timersIsExpired"]
	#[doc = ""]
	#[doc = " \\param[in]  time : time/duration in Milliseconds for the timer"]
	#[doc = ""]
	#[doc = " \\return u32 : The new timer calculated based on the given time"]
	#[doc = ""]
	pub fn timerCalculateTimer(time: u16) -> u32;
}
extern "C" {
	#[doc = " \\brief  Checks if a Timer is Expired"]
	#[doc = ""]
	#[doc = " This method checks if a timer has already expired."]
	#[doc = " Based on the given timer previously calculated it checks if this timer"]
	#[doc = " has already elapsed"]
	#[doc = ""]
	#[doc = " \\see timersCalculateTimer"]
	#[doc = ""]
	#[doc = " \\param[in]  timer : the timer to check"]
	#[doc = ""]
	#[doc = " \\return true  : timer has already expired"]
	#[doc = " \\return false : timer is still running"]
	#[doc = ""]
	pub fn timerIsExpired(timer: u32) -> bool;
}
extern "C" {
	#[doc = " \\brief  Performs a Delay"]
	#[doc = ""]
	#[doc = " This method performs a delay for the given amount of time in Milliseconds"]
	#[doc = ""]
	#[doc = " \\param[in]  time : time/duration in Milliseconds of the delay"]
	#[doc = ""]
	#[doc = ""]
	pub fn timerDelay(time: u16);
}
extern "C" {
	#[doc = " \\brief  Stopwatch start"]
	#[doc = ""]
	#[doc = " This method initiates the stopwatch to later measure the time in ms"]
	#[doc = ""]
	#[doc = ""]
	pub fn timerStopwatchStart();
}
extern "C" {
	#[doc = " \\brief  Stopwatch Measure"]
	#[doc = ""]
	#[doc = " This method returns the elapsed time in ms since the stopwatch was initiated"]
	#[doc = ""]
	#[doc = " \\return The time in ms since the stopwatch was started"]
	#[doc = ""]
	pub fn timerStopwatchMeasure() -> u32;
}
extern "C" {
	pub fn atan(arg1: core::ffi::c_double) -> core::ffi::c_double;
}
extern "C" {
	pub fn cos(arg1: core::ffi::c_double) -> core::ffi::c_double;
}
extern "C" {
	pub fn sin(arg1: core::ffi::c_double) -> core::ffi::c_double;
}
extern "C" {
	pub fn tan(arg1: core::ffi::c_double) -> core::ffi::c_double;
}
extern "C" {
	pub fn tanh(arg1: core::ffi::c_double) -> core::ffi::c_double;
}
extern "C" {
	pub fn frexp(arg1: core::ffi::c_double, arg2: *mut core::ffi::c_int) -> core::ffi::c_double;
}
extern "C" {
	pub fn modf(arg1: core::ffi::c_double, arg2: *mut core::ffi::c_double) -> core::ffi::c_double;
}
extern "C" {
	pub fn ceil(arg1: core::ffi::c_double) -> core::ffi::c_double;
}
extern "C" {
	pub fn fabs(arg1: core::ffi::c_double) -> core::ffi::c_double;
}
extern "C" {
	pub fn floor(arg1: core::ffi::c_double) -> core::ffi::c_double;
}
extern "C" {
	pub fn acos(arg1: core::ffi::c_double) -> core::ffi::c_double;
}
extern "C" {
	pub fn asin(arg1: core::ffi::c_double) -> core::ffi::c_double;
}
extern "C" {
	pub fn atan2(arg1: core::ffi::c_double, arg2: core::ffi::c_double) -> core::ffi::c_double;
}
extern "C" {
	pub fn cosh(arg1: core::ffi::c_double) -> core::ffi::c_double;
}
extern "C" {
	pub fn sinh(arg1: core::ffi::c_double) -> core::ffi::c_double;
}
extern "C" {
	pub fn exp(arg1: core::ffi::c_double) -> core::ffi::c_double;
}
extern "C" {
	pub fn ldexp(arg1: core::ffi::c_double, arg2: core::ffi::c_int) -> core::ffi::c_double;
}
extern "C" {
	pub fn log(arg1: core::ffi::c_double) -> core::ffi::c_double;
}
extern "C" {
	pub fn log10(arg1: core::ffi::c_double) -> core::ffi::c_double;
}
extern "C" {
	pub fn pow(arg1: core::ffi::c_double, arg2: core::ffi::c_double) -> core::ffi::c_double;
}
extern "C" {
	pub fn sqrt(arg1: core::ffi::c_double) -> core::ffi::c_double;
}
extern "C" {
	pub fn fmod(arg1: core::ffi::c_double, arg2: core::ffi::c_double) -> core::ffi::c_double;
}
extern "C" {
	pub fn finite(arg1: core::ffi::c_double) -> core::ffi::c_int;
}
extern "C" {
	pub fn finitef(arg1: core::ffi::c_float) -> core::ffi::c_int;
}
extern "C" {
	pub fn finitel(arg1: f64) -> core::ffi::c_int;
}
extern "C" {
	pub fn isinff(arg1: core::ffi::c_float) -> core::ffi::c_int;
}
extern "C" {
	pub fn isnanf(arg1: core::ffi::c_float) -> core::ffi::c_int;
}
extern "C" {
	pub fn isinf(arg1: core::ffi::c_double) -> core::ffi::c_int;
}
extern "C" {
	pub fn isnan(arg1: core::ffi::c_double) -> core::ffi::c_int;
}
extern "C" {
	pub fn __isinff(arg1: core::ffi::c_float) -> core::ffi::c_int;
}
extern "C" {
	pub fn __isinfd(arg1: core::ffi::c_double) -> core::ffi::c_int;
}
extern "C" {
	pub fn __isnanf(arg1: core::ffi::c_float) -> core::ffi::c_int;
}
extern "C" {
	pub fn __isnand(arg1: core::ffi::c_double) -> core::ffi::c_int;
}
extern "C" {
	pub fn __fpclassifyf(arg1: core::ffi::c_float) -> core::ffi::c_int;
}
extern "C" {
	pub fn __fpclassifyd(arg1: core::ffi::c_double) -> core::ffi::c_int;
}
extern "C" {
	pub fn __signbitf(arg1: core::ffi::c_float) -> core::ffi::c_int;
}
extern "C" {
	pub fn __signbitd(arg1: core::ffi::c_double) -> core::ffi::c_int;
}
extern "C" {
	pub fn infinity() -> core::ffi::c_double;
}
extern "C" {
	pub fn nan(arg1: *const core::ffi::c_char) -> core::ffi::c_double;
}
extern "C" {
	pub fn copysign(arg1: core::ffi::c_double, arg2: core::ffi::c_double) -> core::ffi::c_double;
}
extern "C" {
	pub fn logb(arg1: core::ffi::c_double) -> core::ffi::c_double;
}
extern "C" {
	pub fn ilogb(arg1: core::ffi::c_double) -> core::ffi::c_int;
}
extern "C" {
	pub fn asinh(arg1: core::ffi::c_double) -> core::ffi::c_double;
}
extern "C" {
	pub fn cbrt(arg1: core::ffi::c_double) -> core::ffi::c_double;
}
extern "C" {
	pub fn nextafter(arg1: core::ffi::c_double, arg2: core::ffi::c_double) -> core::ffi::c_double;
}
extern "C" {
	pub fn rint(arg1: core::ffi::c_double) -> core::ffi::c_double;
}
extern "C" {
	pub fn scalbn(arg1: core::ffi::c_double, arg2: core::ffi::c_int) -> core::ffi::c_double;
}
extern "C" {
	pub fn exp2(arg1: core::ffi::c_double) -> core::ffi::c_double;
}
extern "C" {
	pub fn scalbln(arg1: core::ffi::c_double, arg2: core::ffi::c_long) -> core::ffi::c_double;
}
extern "C" {
	pub fn tgamma(arg1: core::ffi::c_double) -> core::ffi::c_double;
}
extern "C" {
	pub fn nearbyint(arg1: core::ffi::c_double) -> core::ffi::c_double;
}
extern "C" {
	pub fn lrint(arg1: core::ffi::c_double) -> core::ffi::c_long;
}
extern "C" {
	pub fn llrint(arg1: core::ffi::c_double) -> core::ffi::c_longlong;
}
extern "C" {
	pub fn round(arg1: core::ffi::c_double) -> core::ffi::c_double;
}
extern "C" {
	pub fn lround(arg1: core::ffi::c_double) -> core::ffi::c_long;
}
extern "C" {
	pub fn llround(arg1: core::ffi::c_double) -> core::ffi::c_longlong;
}
extern "C" {
	pub fn trunc(arg1: core::ffi::c_double) -> core::ffi::c_double;
}
extern "C" {
	pub fn remquo(arg1: core::ffi::c_double, arg2: core::ffi::c_double, arg3: *mut core::ffi::c_int) -> core::ffi::c_double;
}
extern "C" {
	pub fn fdim(arg1: core::ffi::c_double, arg2: core::ffi::c_double) -> core::ffi::c_double;
}
extern "C" {
	pub fn fmax(arg1: core::ffi::c_double, arg2: core::ffi::c_double) -> core::ffi::c_double;
}
extern "C" {
	pub fn fmin(arg1: core::ffi::c_double, arg2: core::ffi::c_double) -> core::ffi::c_double;
}
extern "C" {
	pub fn fma(arg1: core::ffi::c_double, arg2: core::ffi::c_double, arg3: core::ffi::c_double) -> core::ffi::c_double;
}
extern "C" {
	pub fn log1p(arg1: core::ffi::c_double) -> core::ffi::c_double;
}
extern "C" {
	pub fn expm1(arg1: core::ffi::c_double) -> core::ffi::c_double;
}
extern "C" {
	pub fn acosh(arg1: core::ffi::c_double) -> core::ffi::c_double;
}
extern "C" {
	pub fn atanh(arg1: core::ffi::c_double) -> core::ffi::c_double;
}
extern "C" {
	pub fn remainder(arg1: core::ffi::c_double, arg2: core::ffi::c_double) -> core::ffi::c_double;
}
extern "C" {
	pub fn gamma(arg1: core::ffi::c_double) -> core::ffi::c_double;
}
extern "C" {
	pub fn lgamma(arg1: core::ffi::c_double) -> core::ffi::c_double;
}
extern "C" {
	pub fn erf(arg1: core::ffi::c_double) -> core::ffi::c_double;
}
extern "C" {
	pub fn erfc(arg1: core::ffi::c_double) -> core::ffi::c_double;
}
extern "C" {
	pub fn log2(arg1: core::ffi::c_double) -> core::ffi::c_double;
}
extern "C" {
	pub fn hypot(arg1: core::ffi::c_double, arg2: core::ffi::c_double) -> core::ffi::c_double;
}
extern "C" {
	pub fn atanf(arg1: core::ffi::c_float) -> core::ffi::c_float;
}
extern "C" {
	pub fn cosf(arg1: core::ffi::c_float) -> core::ffi::c_float;
}
extern "C" {
	pub fn sinf(arg1: core::ffi::c_float) -> core::ffi::c_float;
}
extern "C" {
	pub fn tanf(arg1: core::ffi::c_float) -> core::ffi::c_float;
}
extern "C" {
	pub fn tanhf(arg1: core::ffi::c_float) -> core::ffi::c_float;
}
extern "C" {
	pub fn frexpf(arg1: core::ffi::c_float, arg2: *mut core::ffi::c_int) -> core::ffi::c_float;
}
extern "C" {
	pub fn modff(arg1: core::ffi::c_float, arg2: *mut core::ffi::c_float) -> core::ffi::c_float;
}
extern "C" {
	pub fn ceilf(arg1: core::ffi::c_float) -> core::ffi::c_float;
}
extern "C" {
	pub fn fabsf(arg1: core::ffi::c_float) -> core::ffi::c_float;
}
extern "C" {
	pub fn floorf(arg1: core::ffi::c_float) -> core::ffi::c_float;
}
extern "C" {
	pub fn acosf(arg1: core::ffi::c_float) -> core::ffi::c_float;
}
extern "C" {
	pub fn asinf(arg1: core::ffi::c_float) -> core::ffi::c_float;
}
extern "C" {
	pub fn atan2f(arg1: core::ffi::c_float, arg2: core::ffi::c_float) -> core::ffi::c_float;
}
extern "C" {
	pub fn coshf(arg1: core::ffi::c_float) -> core::ffi::c_float;
}
extern "C" {
	pub fn sinhf(arg1: core::ffi::c_float) -> core::ffi::c_float;
}
extern "C" {
	pub fn expf(arg1: core::ffi::c_float) -> core::ffi::c_float;
}
extern "C" {
	pub fn ldexpf(arg1: core::ffi::c_float, arg2: core::ffi::c_int) -> core::ffi::c_float;
}
extern "C" {
	pub fn logf(arg1: core::ffi::c_float) -> core::ffi::c_float;
}
extern "C" {
	pub fn log10f(arg1: core::ffi::c_float) -> core::ffi::c_float;
}
extern "C" {
	pub fn powf(arg1: core::ffi::c_float, arg2: core::ffi::c_float) -> core::ffi::c_float;
}
extern "C" {
	pub fn sqrtf(arg1: core::ffi::c_float) -> core::ffi::c_float;
}
extern "C" {
	pub fn fmodf(arg1: core::ffi::c_float, arg2: core::ffi::c_float) -> core::ffi::c_float;
}
extern "C" {
	pub fn exp2f(arg1: core::ffi::c_float) -> core::ffi::c_float;
}
extern "C" {
	pub fn scalblnf(arg1: core::ffi::c_float, arg2: core::ffi::c_long) -> core::ffi::c_float;
}
extern "C" {
	pub fn tgammaf(arg1: core::ffi::c_float) -> core::ffi::c_float;
}
extern "C" {
	pub fn nearbyintf(arg1: core::ffi::c_float) -> core::ffi::c_float;
}
extern "C" {
	pub fn lrintf(arg1: core::ffi::c_float) -> core::ffi::c_long;
}
extern "C" {
	pub fn llrintf(arg1: core::ffi::c_float) -> core::ffi::c_longlong;
}
extern "C" {
	pub fn roundf(arg1: core::ffi::c_float) -> core::ffi::c_float;
}
extern "C" {
	pub fn lroundf(arg1: core::ffi::c_float) -> core::ffi::c_long;
}
extern "C" {
	pub fn llroundf(arg1: core::ffi::c_float) -> core::ffi::c_longlong;
}
extern "C" {
	pub fn truncf(arg1: core::ffi::c_float) -> core::ffi::c_float;
}
extern "C" {
	pub fn remquof(arg1: core::ffi::c_float, arg2: core::ffi::c_float, arg3: *mut core::ffi::c_int) -> core::ffi::c_float;
}
extern "C" {
	pub fn fdimf(arg1: core::ffi::c_float, arg2: core::ffi::c_float) -> core::ffi::c_float;
}
extern "C" {
	pub fn fmaxf(arg1: core::ffi::c_float, arg2: core::ffi::c_float) -> core::ffi::c_float;
}
extern "C" {
	pub fn fminf(arg1: core::ffi::c_float, arg2: core::ffi::c_float) -> core::ffi::c_float;
}
extern "C" {
	pub fn fmaf(arg1: core::ffi::c_float, arg2: core::ffi::c_float, arg3: core::ffi::c_float) -> core::ffi::c_float;
}
extern "C" {
	pub fn infinityf() -> core::ffi::c_float;
}
extern "C" {
	pub fn nanf(arg1: *const core::ffi::c_char) -> core::ffi::c_float;
}
extern "C" {
	pub fn copysignf(arg1: core::ffi::c_float, arg2: core::ffi::c_float) -> core::ffi::c_float;
}
extern "C" {
	pub fn logbf(arg1: core::ffi::c_float) -> core::ffi::c_float;
}
extern "C" {
	pub fn ilogbf(arg1: core::ffi::c_float) -> core::ffi::c_int;
}
extern "C" {
	pub fn asinhf(arg1: core::ffi::c_float) -> core::ffi::c_float;
}
extern "C" {
	pub fn cbrtf(arg1: core::ffi::c_float) -> core::ffi::c_float;
}
extern "C" {
	pub fn nextafterf(arg1: core::ffi::c_float, arg2: core::ffi::c_float) -> core::ffi::c_float;
}
extern "C" {
	pub fn rintf(arg1: core::ffi::c_float) -> core::ffi::c_float;
}
extern "C" {
	pub fn scalbnf(arg1: core::ffi::c_float, arg2: core::ffi::c_int) -> core::ffi::c_float;
}
extern "C" {
	pub fn log1pf(arg1: core::ffi::c_float) -> core::ffi::c_float;
}
extern "C" {
	pub fn expm1f(arg1: core::ffi::c_float) -> core::ffi::c_float;
}
extern "C" {
	pub fn acoshf(arg1: core::ffi::c_float) -> core::ffi::c_float;
}
extern "C" {
	pub fn atanhf(arg1: core::ffi::c_float) -> core::ffi::c_float;
}
extern "C" {
	pub fn remainderf(arg1: core::ffi::c_float, arg2: core::ffi::c_float) -> core::ffi::c_float;
}
extern "C" {
	pub fn gammaf(arg1: core::ffi::c_float) -> core::ffi::c_float;
}
extern "C" {
	pub fn lgammaf(arg1: core::ffi::c_float) -> core::ffi::c_float;
}
extern "C" {
	pub fn erff(arg1: core::ffi::c_float) -> core::ffi::c_float;
}
extern "C" {
	pub fn erfcf(arg1: core::ffi::c_float) -> core::ffi::c_float;
}
extern "C" {
	pub fn log2f(arg1: core::ffi::c_float) -> core::ffi::c_float;
}
extern "C" {
	pub fn hypotf(arg1: core::ffi::c_float, arg2: core::ffi::c_float) -> core::ffi::c_float;
}
extern "C" {
	pub fn atanl(arg1: f64) -> f64;
}
extern "C" {
	pub fn cosl(arg1: f64) -> f64;
}
extern "C" {
	pub fn sinl(arg1: f64) -> f64;
}
extern "C" {
	pub fn tanl(arg1: f64) -> f64;
}
extern "C" {
	pub fn tanhl(arg1: f64) -> f64;
}
extern "C" {
	pub fn frexpl(arg1: f64, arg2: *mut core::ffi::c_int) -> f64;
}
extern "C" {
	pub fn modfl(arg1: f64, arg2: *mut f64) -> f64;
}
extern "C" {
	pub fn ceill(arg1: f64) -> f64;
}
extern "C" {
	pub fn fabsl(arg1: f64) -> f64;
}
extern "C" {
	pub fn floorl(arg1: f64) -> f64;
}
extern "C" {
	pub fn log1pl(arg1: f64) -> f64;
}
extern "C" {
	pub fn expm1l(arg1: f64) -> f64;
}
extern "C" {
	pub fn acosl(arg1: f64) -> f64;
}
extern "C" {
	pub fn asinl(arg1: f64) -> f64;
}
extern "C" {
	pub fn atan2l(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
	pub fn coshl(arg1: f64) -> f64;
}
extern "C" {
	pub fn sinhl(arg1: f64) -> f64;
}
extern "C" {
	pub fn expl(arg1: f64) -> f64;
}
extern "C" {
	pub fn ldexpl(arg1: f64, arg2: core::ffi::c_int) -> f64;
}
extern "C" {
	pub fn logl(arg1: f64) -> f64;
}
extern "C" {
	pub fn log10l(arg1: f64) -> f64;
}
extern "C" {
	pub fn powl(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
	pub fn sqrtl(arg1: f64) -> f64;
}
extern "C" {
	pub fn fmodl(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
	pub fn hypotl(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
	pub fn copysignl(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
	pub fn nanl(arg1: *const core::ffi::c_char) -> f64;
}
extern "C" {
	pub fn ilogbl(arg1: f64) -> core::ffi::c_int;
}
extern "C" {
	pub fn asinhl(arg1: f64) -> f64;
}
extern "C" {
	pub fn cbrtl(arg1: f64) -> f64;
}
extern "C" {
	pub fn nextafterl(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
	pub fn nexttowardf(arg1: core::ffi::c_float, arg2: f64) -> core::ffi::c_float;
}
extern "C" {
	pub fn nexttoward(arg1: core::ffi::c_double, arg2: f64) -> core::ffi::c_double;
}
extern "C" {
	pub fn nexttowardl(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
	pub fn logbl(arg1: f64) -> f64;
}
extern "C" {
	pub fn log2l(arg1: f64) -> f64;
}
extern "C" {
	pub fn rintl(arg1: f64) -> f64;
}
extern "C" {
	pub fn scalbnl(arg1: f64, arg2: core::ffi::c_int) -> f64;
}
extern "C" {
	pub fn exp2l(arg1: f64) -> f64;
}
extern "C" {
	pub fn scalblnl(arg1: f64, arg2: core::ffi::c_long) -> f64;
}
extern "C" {
	pub fn tgammal(arg1: f64) -> f64;
}
extern "C" {
	pub fn nearbyintl(arg1: f64) -> f64;
}
extern "C" {
	pub fn lrintl(arg1: f64) -> core::ffi::c_long;
}
extern "C" {
	pub fn llrintl(arg1: f64) -> core::ffi::c_longlong;
}
extern "C" {
	pub fn roundl(arg1: f64) -> f64;
}
extern "C" {
	pub fn lroundl(arg1: f64) -> core::ffi::c_long;
}
extern "C" {
	pub fn llroundl(arg1: f64) -> core::ffi::c_longlong;
}
extern "C" {
	pub fn truncl(arg1: f64) -> f64;
}
extern "C" {
	pub fn remquol(arg1: f64, arg2: f64, arg3: *mut core::ffi::c_int) -> f64;
}
extern "C" {
	pub fn fdiml(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
	pub fn fmaxl(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
	pub fn fminl(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
	pub fn fmal(arg1: f64, arg2: f64, arg3: f64) -> f64;
}
extern "C" {
	pub fn acoshl(arg1: f64) -> f64;
}
extern "C" {
	pub fn atanhl(arg1: f64) -> f64;
}
extern "C" {
	pub fn remainderl(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
	pub fn lgammal(arg1: f64) -> f64;
}
extern "C" {
	pub fn erfl(arg1: f64) -> f64;
}
extern "C" {
	pub fn erfcl(arg1: f64) -> f64;
}
extern "C" {
	pub fn drem(arg1: core::ffi::c_double, arg2: core::ffi::c_double) -> core::ffi::c_double;
}
extern "C" {
	pub fn dremf(arg1: core::ffi::c_float, arg2: core::ffi::c_float) -> core::ffi::c_float;
}
extern "C" {
	pub fn gamma_r(arg1: core::ffi::c_double, arg2: *mut core::ffi::c_int) -> core::ffi::c_double;
}
extern "C" {
	pub fn lgamma_r(arg1: core::ffi::c_double, arg2: *mut core::ffi::c_int) -> core::ffi::c_double;
}
extern "C" {
	pub fn gammaf_r(arg1: core::ffi::c_float, arg2: *mut core::ffi::c_int) -> core::ffi::c_float;
}
extern "C" {
	pub fn lgammaf_r(arg1: core::ffi::c_float, arg2: *mut core::ffi::c_int) -> core::ffi::c_float;
}
extern "C" {
	pub fn y0(arg1: core::ffi::c_double) -> core::ffi::c_double;
}
extern "C" {
	pub fn y1(arg1: core::ffi::c_double) -> core::ffi::c_double;
}
extern "C" {
	pub fn yn(arg1: core::ffi::c_int, arg2: core::ffi::c_double) -> core::ffi::c_double;
}
extern "C" {
	pub fn j0(arg1: core::ffi::c_double) -> core::ffi::c_double;
}
extern "C" {
	pub fn j1(arg1: core::ffi::c_double) -> core::ffi::c_double;
}
extern "C" {
	pub fn jn(arg1: core::ffi::c_int, arg2: core::ffi::c_double) -> core::ffi::c_double;
}
extern "C" {
	pub fn y0f(arg1: core::ffi::c_float) -> core::ffi::c_float;
}
extern "C" {
	pub fn y1f(arg1: core::ffi::c_float) -> core::ffi::c_float;
}
extern "C" {
	pub fn ynf(arg1: core::ffi::c_int, arg2: core::ffi::c_float) -> core::ffi::c_float;
}
extern "C" {
	pub fn j0f(arg1: core::ffi::c_float) -> core::ffi::c_float;
}
extern "C" {
	pub fn j1f(arg1: core::ffi::c_float) -> core::ffi::c_float;
}
extern "C" {
	pub fn jnf(arg1: core::ffi::c_int, arg2: core::ffi::c_float) -> core::ffi::c_float;
}
extern "C" {
	pub fn __signgam() -> *mut core::ffi::c_int;
}
pub type PlatformIrqCallback = ::core::option::Option<unsafe extern "C" fn()>;
extern "C" {
	pub fn platformSetIrqCallback(cb: PlatformIrqCallback);
}
extern "C" {
	pub fn platformEnableIrqCallback();
}
extern "C" {
	pub fn platformDisableIrqCallback();
}
extern "C" {
	pub fn platformSpiTxRx(txBuf: *const u8, rxBuf: *mut u8, len: u16) -> bool;
}
extern "C" {
	pub fn platformProtectST25RComm();
}
extern "C" {
	pub fn platformUnprotectST25RComm();
}
extern "C" {
	pub fn rfal_platform_spi_acquire();
}
extern "C" {
	pub fn rfal_platform_spi_release();
}
#[repr(u32)]
#[non_exhaustive]
#[doc = " RFAL modes"]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum rfalMode {
	#[doc = "< No mode selected/defined"]
	RFAL_MODE_NONE = 0,
	RFAL_MODE_POLL_NFCA = 1,
	RFAL_MODE_POLL_NFCA_T1T = 2,
	RFAL_MODE_POLL_NFCB = 3,
	RFAL_MODE_POLL_B_PRIME = 4,
	RFAL_MODE_POLL_B_CTS = 5,
	RFAL_MODE_POLL_NFCF = 6,
	RFAL_MODE_POLL_NFCV = 7,
	RFAL_MODE_POLL_PICOPASS = 8,
	RFAL_MODE_POLL_ACTIVE_P2P = 9,
	RFAL_MODE_LISTEN_NFCA = 10,
	RFAL_MODE_LISTEN_NFCB = 11,
	RFAL_MODE_LISTEN_NFCF = 12,
	RFAL_MODE_LISTEN_ACTIVE_P2P = 13,
}
#[repr(u32)]
#[non_exhaustive]
#[doc = " RFAL Bit rates"]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum rfalBitRate {
	#[doc = "< Bit Rate 106 kbit/s (fc/128)"]
	RFAL_BR_106 = 0,
	#[doc = "< Bit Rate 212 kbit/s (fc/64)"]
	RFAL_BR_212 = 1,
	#[doc = "< Bit Rate 424 kbit/s (fc/32)"]
	RFAL_BR_424 = 2,
	#[doc = "< Bit Rate 848 kbit/s (fc/16)"]
	RFAL_BR_848 = 3,
	#[doc = "< Bit Rate 1695 kbit/s (fc/8)"]
	RFAL_BR_1695 = 4,
	#[doc = "< Bit Rate 3390 kbit/s (fc/4)"]
	RFAL_BR_3390 = 5,
	#[doc = "< Bit Rate 6780 kbit/s (fc/2)"]
	RFAL_BR_6780 = 6,
	#[doc = "< Bit Rate 13560 kbit/s (fc)"]
	RFAL_BR_13560 = 7,
	#[doc = "< Bit Rate 52.97 kbit/s (fc/256) Fast Mode VICC->VCD"]
	RFAL_BR_52p97 = 235,
	#[doc = "< Bit Rate 26,48 kbit/s (fc/512) NFCV VICC->VCD & VCD->VICC 1of4"]
	RFAL_BR_26p48 = 236,
	#[doc = "< Bit Rate 1,66 kbit/s (fc/8192) NFCV VCD->VICC 1of256"]
	RFAL_BR_1p66 = 237,
	#[doc = "< Value indicating to keep the same previous bit rate"]
	RFAL_BR_KEEP = 255,
}
#[repr(u32)]
#[non_exhaustive]
#[doc = " RFAL Compliance modes for upper modules"]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum rfalComplianceMode {
	#[doc = "< Perform with NFC Forum 1.1 compliance"]
	RFAL_COMPLIANCE_MODE_NFC = 0,
	#[doc = "< Perform with EMVCo compliance"]
	RFAL_COMPLIANCE_MODE_EMV = 1,
	#[doc = "< Perform with ISO10373 compliance"]
	RFAL_COMPLIANCE_MODE_ISO = 2,
}
#[repr(u32)]
#[non_exhaustive]
#[doc = " RFAL transceive states"]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum rfalTransceiveState {
	RFAL_TXRX_STATE_IDLE = 0,
	RFAL_TXRX_STATE_INIT = 1,
	RFAL_TXRX_STATE_START = 2,
	RFAL_TXRX_STATE_TX_IDLE = 11,
	RFAL_TXRX_STATE_TX_WAIT_GT = 12,
	RFAL_TXRX_STATE_TX_WAIT_FDT = 13,
	RFAL_TXRX_STATE_TX_TRANSMIT = 14,
	RFAL_TXRX_STATE_TX_WAIT_WL = 15,
	RFAL_TXRX_STATE_TX_RELOAD_FIFO = 16,
	RFAL_TXRX_STATE_TX_WAIT_TXE = 17,
	RFAL_TXRX_STATE_TX_DONE = 18,
	RFAL_TXRX_STATE_TX_FAIL = 19,
	RFAL_TXRX_STATE_RX_IDLE = 81,
	RFAL_TXRX_STATE_RX_WAIT_EON = 82,
	RFAL_TXRX_STATE_RX_WAIT_RXS = 83,
	RFAL_TXRX_STATE_RX_WAIT_RXE = 84,
	RFAL_TXRX_STATE_RX_READ_FIFO = 85,
	RFAL_TXRX_STATE_RX_ERR_CHECK = 86,
	RFAL_TXRX_STATE_RX_READ_DATA = 87,
	RFAL_TXRX_STATE_RX_WAIT_EOF = 88,
	RFAL_TXRX_STATE_RX_DONE = 89,
	RFAL_TXRX_STATE_RX_FAIL = 90,
}
#[repr(u32)]
#[non_exhaustive]
#[doc = " RFAL error handling"]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum rfalEHandling {
	RFAL_ERRORHANDLING_NONE = 0,
	RFAL_ERRORHANDLING_NFC = 1,
	RFAL_ERRORHANDLING_EMVCO = 2,
}
#[doc = " Struct that holds all context to be used on a Transceive"]
#[repr(C)]
pub struct rfalTransceiveContext {
	#[doc = "< (In)  Buffer where outgoing message is located"]
	pub txBuf: *mut u8,
	#[doc = "< (In)  Length of the outgoing message in bits"]
	pub txBufLen: u16,
	#[doc = "< (Out) Buffer where incoming message will be placed"]
	pub rxBuf: *mut u8,
	#[doc = "< (In)  Maximum length of the incoming message in bits"]
	pub rxBufLen: u16,
	#[doc = "< (Out) Actual received length in bits"]
	pub rxRcvdLen: *mut u16,
	#[doc = "< (In)  TransceiveFlags indication special handling"]
	pub flags: u32,
	#[doc = "< (In)  Frame Waiting Time in 1/fc"]
	pub fwt: u32,
}
#[test]
fn bindgen_test_layout_rfalTransceiveContext() {
	assert_eq!(
	           ::core::mem::size_of::<rfalTransceiveContext>(),
	           28usize,
	           concat!("Size of: ", stringify!(rfalTransceiveContext))
	);
	assert_eq!(
	           ::core::mem::align_of::<rfalTransceiveContext>(),
	           4usize,
	           concat!("Alignment of ", stringify!(rfalTransceiveContext))
	);
	fn test_field_txBuf() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalTransceiveContext>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).txBuf) as usize - ptr as usize
		           },
		           0usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalTransceiveContext),
			"::",
			stringify!(txBuf)
		)
		);
	}
	test_field_txBuf();
	fn test_field_txBufLen() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalTransceiveContext>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).txBufLen) as usize - ptr as usize
		           },
		           4usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalTransceiveContext),
			"::",
			stringify!(txBufLen)
		)
		);
	}
	test_field_txBufLen();
	fn test_field_rxBuf() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalTransceiveContext>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).rxBuf) as usize - ptr as usize
		           },
		           8usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalTransceiveContext),
			"::",
			stringify!(rxBuf)
		)
		);
	}
	test_field_rxBuf();
	fn test_field_rxBufLen() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalTransceiveContext>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).rxBufLen) as usize - ptr as usize
		           },
		           12usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalTransceiveContext),
			"::",
			stringify!(rxBufLen)
		)
		);
	}
	test_field_rxBufLen();
	fn test_field_rxRcvdLen() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalTransceiveContext>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).rxRcvdLen) as usize - ptr as usize
		           },
		           16usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalTransceiveContext),
			"::",
			stringify!(rxRcvdLen)
		)
		);
	}
	test_field_rxRcvdLen();
	fn test_field_flags() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalTransceiveContext>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize
		           },
		           20usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalTransceiveContext),
			"::",
			stringify!(flags)
		)
		);
	}
	test_field_flags();
	fn test_field_fwt() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalTransceiveContext>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).fwt) as usize - ptr as usize
		           },
		           24usize,
		           concat!("Offset of field: ", stringify!(rfalTransceiveContext), "::", stringify!(fwt))
		);
	}
	test_field_fwt();
}
#[doc = " System callback to indicate an event that requires a system reRun"]
pub type rfalUpperLayerCallback = ::core::option::Option<unsafe extern "C" fn()>;
#[doc = " Callback to be executed before a Transceive"]
pub type rfalPreTxRxCallback = ::core::option::Option<unsafe extern "C" fn(context: *mut core::ffi::c_void)>;
#[doc = " Callback to be executed after a Transceive"]
pub type rfalPostTxRxCallback = ::core::option::Option<unsafe extern "C" fn(context: *mut core::ffi::c_void)>;
#[doc = " Callback to be executed on each RFAL state change"]
pub type RfalStateChangedCallback = ::core::option::Option<unsafe extern "C" fn(context: *mut core::ffi::c_void)>;
#[repr(u32)]
#[non_exhaustive]
#[doc = " RFAL ISO 14443A Short Frame Command"]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum rfal14443AShortFrameCmd {
	#[doc = "< ISO14443A WUPA / NFC-A ALL_REQ"]
	RFAL_14443A_SHORTFRAME_CMD_WUPA = 82,
	#[doc = "< ISO14443A REQA / NFC-A SENS_REQ"]
	RFAL_14443A_SHORTFRAME_CMD_REQA = 38,
}
#[repr(u32)]
#[non_exhaustive]
#[doc = " NFC-F TSN (Time Slot Number) codes  NFC Forum Digital 1.1 Table 43"]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum rfalFeliCaPollSlots {
	#[doc = "< TSN with number of Time Slots: 1"]
	RFAL_FELICA_1_SLOT = 0,
	#[doc = "< TSN with number of Time Slots: 2"]
	RFAL_FELICA_2_SLOTS = 1,
	#[doc = "< TSN with number of Time Slots: 4"]
	RFAL_FELICA_4_SLOTS = 3,
	#[doc = "< TSN with number of Time Slots: 8"]
	RFAL_FELICA_8_SLOTS = 7,
	#[doc = "< TSN with number of Time Slots: 16"]
	RFAL_FELICA_16_SLOTS = 15,
}
#[doc = " NFCF Poll Response  NFC Forum Digital 1.1 Table 44"]
pub type rfalFeliCaPollRes = [u8; 20usize];
#[repr(u32)]
#[non_exhaustive]
#[doc = " RFAL Listen Mode NFCID Length"]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum rfalLmNfcidLen {
	#[doc = "< Listen mode indicates  4 byte NFCID"]
	RFAL_LM_NFCID_LEN_04 = 4,
	#[doc = "< Listen mode indicates  7 byte NFCID"]
	RFAL_LM_NFCID_LEN_07 = 7,
	#[doc = "< Listen mode indicates 10 byte NFCID"]
	RFAL_LM_NFCID_LEN_10 = 10,
}
#[repr(u32)]
#[non_exhaustive]
#[doc = " RFAL Listen Mode States"]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum rfalLmState {
	#[doc = "< Not Initialized state"]
	RFAL_LM_STATE_NOT_INIT = 0,
	#[doc = "< Power Off state"]
	RFAL_LM_STATE_POWER_OFF = 1,
	#[doc = "< Idle state  Activity 1.1  5.2"]
	RFAL_LM_STATE_IDLE = 2,
	#[doc = "< Ready A state  Activity 1.1  5.3 5.4 & 5.5"]
	RFAL_LM_STATE_READY_A = 3,
	#[doc = "< Ready B state  Activity 1.1  5.11 5.12"]
	RFAL_LM_STATE_READY_B = 4,
	#[doc = "< Ready F state  Activity 1.1  5.15"]
	RFAL_LM_STATE_READY_F = 5,
	#[doc = "< Active A state  Activity 1.1  5.6"]
	RFAL_LM_STATE_ACTIVE_A = 6,
	#[doc = "< Card Emulation 4A state  Activity 1.1  5.10"]
	RFAL_LM_STATE_CARDEMU_4A = 7,
	#[doc = "< Card Emulation 4B state  Activity 1.1  5.14"]
	RFAL_LM_STATE_CARDEMU_4B = 8,
	#[doc = "< Card Emulation 3 state  Activity 1.1  5.18"]
	RFAL_LM_STATE_CARDEMU_3 = 9,
	#[doc = "< Target A state  Activity 1.1  5.9"]
	RFAL_LM_STATE_TARGET_A = 10,
	#[doc = "< Target F state  Activity 1.1  5.17"]
	RFAL_LM_STATE_TARGET_F = 11,
	#[doc = "< Sleep A state  Activity 1.1  5.7"]
	RFAL_LM_STATE_SLEEP_A = 12,
	#[doc = "< Sleep B state  Activity 1.1  5.13"]
	RFAL_LM_STATE_SLEEP_B = 13,
	#[doc = "< Ready A* state  Activity 1.1  5.3 5.4 & 5.5"]
	RFAL_LM_STATE_READY_Ax = 14,
	#[doc = "< Active A* state  Activity 1.1  5.6"]
	RFAL_LM_STATE_ACTIVE_Ax = 15,
	#[doc = "< Sleep AF state  Activity 1.1  5.19"]
	RFAL_LM_STATE_SLEEP_AF = 16,
}
#[doc = " RFAL Listen Mode Passive A configs"]
#[repr(C)]
pub struct rfalLmConfPA {
	#[doc = "< NFCID Len (4, 7 or 10 bytes)"]
	pub nfcidLen: rfalLmNfcidLen,
	#[doc = "< NFCID"]
	pub nfcid: [u8; 10usize],
	#[doc = "< NFC-106k; SENS_REQ Response"]
	pub SENS_RES: [u8; 2usize],
	#[doc = "< SEL_RES (SAK) with complete NFCID1 (UID)"]
	pub SEL_RES: u8,
}
#[test]
fn bindgen_test_layout_rfalLmConfPA() {
	assert_eq!(
	           ::core::mem::size_of::<rfalLmConfPA>(),
	           20usize,
	           concat!("Size of: ", stringify!(rfalLmConfPA))
	);
	assert_eq!(
	           ::core::mem::align_of::<rfalLmConfPA>(),
	           4usize,
	           concat!("Alignment of ", stringify!(rfalLmConfPA))
	);
	fn test_field_nfcidLen() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalLmConfPA>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).nfcidLen) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(rfalLmConfPA), "::", stringify!(nfcidLen))
		);
	}
	test_field_nfcidLen();
	fn test_field_nfcid() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalLmConfPA>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).nfcid) as usize - ptr as usize
		           },
		           4usize,
		           concat!("Offset of field: ", stringify!(rfalLmConfPA), "::", stringify!(nfcid))
		);
	}
	test_field_nfcid();
	fn test_field_SENS_RES() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalLmConfPA>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).SENS_RES) as usize - ptr as usize
		           },
		           14usize,
		           concat!("Offset of field: ", stringify!(rfalLmConfPA), "::", stringify!(SENS_RES))
		);
	}
	test_field_SENS_RES();
	fn test_field_SEL_RES() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalLmConfPA>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).SEL_RES) as usize - ptr as usize
		           },
		           16usize,
		           concat!("Offset of field: ", stringify!(rfalLmConfPA), "::", stringify!(SEL_RES))
		);
	}
	test_field_SEL_RES();
}
#[doc = " RFAL Listen Mode Passive B configs"]
#[repr(C)]
pub struct rfalLmConfPB {
	#[doc = "< SENSF_RES"]
	pub SENSB_RES: [u8; 13usize],
}
#[test]
fn bindgen_test_layout_rfalLmConfPB() {
	assert_eq!(
	           ::core::mem::size_of::<rfalLmConfPB>(),
	           13usize,
	           concat!("Size of: ", stringify!(rfalLmConfPB))
	);
	assert_eq!(
	           ::core::mem::align_of::<rfalLmConfPB>(),
	           1usize,
	           concat!("Alignment of ", stringify!(rfalLmConfPB))
	);
	fn test_field_SENSB_RES() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalLmConfPB>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).SENSB_RES) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(rfalLmConfPB), "::", stringify!(SENSB_RES))
		);
	}
	test_field_SENSB_RES();
}
#[doc = " RFAL Listen Mode Passive F configs"]
#[repr(C)]
pub struct rfalLmConfPF {
	#[doc = "< System Code to listen for"]
	pub SC: [u8; 2usize],
	#[doc = "< SENSF_RES"]
	pub SENSF_RES: [u8; 19usize],
}
#[test]
fn bindgen_test_layout_rfalLmConfPF() {
	assert_eq!(
	           ::core::mem::size_of::<rfalLmConfPF>(),
	           21usize,
	           concat!("Size of: ", stringify!(rfalLmConfPF))
	);
	assert_eq!(
	           ::core::mem::align_of::<rfalLmConfPF>(),
	           1usize,
	           concat!("Alignment of ", stringify!(rfalLmConfPF))
	);
	fn test_field_SC() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalLmConfPF>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).SC) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(rfalLmConfPF), "::", stringify!(SC))
		);
	}
	test_field_SC();
	fn test_field_SENSF_RES() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalLmConfPF>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).SENSF_RES) as usize - ptr as usize
		           },
		           2usize,
		           concat!("Offset of field: ", stringify!(rfalLmConfPF), "::", stringify!(SENSF_RES))
		);
	}
	test_field_SENSF_RES();
}
#[repr(u32)]
#[non_exhaustive]
#[doc = " RFAL Wake-Up Period/Timer"]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum rfalWumPeriod {
	#[doc = "< Wake-Up timer 10ms"]
	RFAL_WUM_PERIOD_10MS = 0,
	#[doc = "< Wake-Up timer 20ms"]
	RFAL_WUM_PERIOD_20MS = 1,
	#[doc = "< Wake-Up timer 30ms"]
	RFAL_WUM_PERIOD_30MS = 2,
	#[doc = "< Wake-Up timer 40ms"]
	RFAL_WUM_PERIOD_40MS = 3,
	#[doc = "< Wake-Up timer 50ms"]
	RFAL_WUM_PERIOD_50MS = 4,
	#[doc = "< Wake-Up timer 60ms"]
	RFAL_WUM_PERIOD_60MS = 5,
	#[doc = "< Wake-Up timer 70ms"]
	RFAL_WUM_PERIOD_70MS = 6,
	#[doc = "< Wake-Up timer 80ms"]
	RFAL_WUM_PERIOD_80MS = 7,
	#[doc = "< Wake-Up timer 100ms"]
	RFAL_WUM_PERIOD_100MS = 16,
	#[doc = "< Wake-Up timer 200ms"]
	RFAL_WUM_PERIOD_200MS = 17,
	#[doc = "< Wake-Up timer 300ms"]
	RFAL_WUM_PERIOD_300MS = 18,
	#[doc = "< Wake-Up timer 400ms"]
	RFAL_WUM_PERIOD_400MS = 19,
	#[doc = "< Wake-Up timer 500ms"]
	RFAL_WUM_PERIOD_500MS = 20,
	#[doc = "< Wake-Up timer 600ms"]
	RFAL_WUM_PERIOD_600MS = 21,
	#[doc = "< Wake-Up timer 700ms"]
	RFAL_WUM_PERIOD_700MS = 22,
	#[doc = "< Wake-Up timer 800ms"]
	RFAL_WUM_PERIOD_800MS = 23,
}
#[repr(u32)]
#[non_exhaustive]
#[doc = " RFAL Wake-Up Period/Timer"]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum rfalWumAAWeight {
	#[doc = "< Wake-Up Auto Average Weight 4"]
	RFAL_WUM_AA_WEIGHT_4 = 0,
	#[doc = "< Wake-Up Auto Average Weight 8"]
	RFAL_WUM_AA_WEIGHT_8 = 1,
	#[doc = "< Wake-Up Auto Average Weight 16"]
	RFAL_WUM_AA_WEIGHT_16 = 2,
	#[doc = "< Wake-Up Auto Average Weight 32"]
	RFAL_WUM_AA_WEIGHT_32 = 3,
}
#[doc = " RFAL Wake-Up Mode configuration"]
#[repr(C)]
pub struct rfalWakeUpConfig {
	#[doc = "< Wake-Up Timer period;how often measurement(s) is performed"]
	pub period: rfalWumPeriod,
	#[doc = "< IRQ at every timeout will refresh the measurement(s)"]
	pub irqTout: bool,
	#[doc = "< Use SW Tag Detection instead of HW Wake-Up mode"]
	pub swTagDetect: bool,
	#[doc = "< Inductive Amplitude Configuration"]
	pub indAmp: rfalWakeUpConfig__bindgen_ty_1,
	#[doc = "< Inductive Phase Configuration"]
	pub indPha: rfalWakeUpConfig__bindgen_ty_2,
	#[doc = "< Capacitive Configuration"]
	pub cap: rfalWakeUpConfig__bindgen_ty_3,
}
#[repr(C)]
pub struct rfalWakeUpConfig__bindgen_ty_1 {
	#[doc = "< Inductive Amplitude measurement enabled"]
	pub enabled: bool,
	#[doc = "< Delta between the reference and measurement to wake-up"]
	pub delta: u8,
	#[doc = "< Reference to be used;RFAL_WUM_REFERENCE_AUTO sets it auto"]
	pub reference: u16,
	#[doc = "< Use the HW Auto Averaging feature"]
	pub autoAvg: bool,
	#[doc = "< When AutoAvg is enabled, include IRQ measurement"]
	pub aaInclMeas: bool,
	#[doc = "< When AutoAvg is enabled, last measure weight"]
	pub aaWeight: rfalWumAAWeight,
}
#[test]
fn bindgen_test_layout_rfalWakeUpConfig__bindgen_ty_1() {
	assert_eq!(
	           ::core::mem::size_of::<rfalWakeUpConfig__bindgen_ty_1>(),
	           12usize,
	           concat!("Size of: ", stringify!(rfalWakeUpConfig__bindgen_ty_1))
	);
	assert_eq!(
	           ::core::mem::align_of::<rfalWakeUpConfig__bindgen_ty_1>(),
	           4usize,
	           concat!("Alignment of ", stringify!(rfalWakeUpConfig__bindgen_ty_1))
	);
	fn test_field_enabled() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalWakeUpConfig__bindgen_ty_1>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).enabled) as usize - ptr as usize
		           },
		           0usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalWakeUpConfig__bindgen_ty_1),
			"::",
			stringify!(enabled)
		)
		);
	}
	test_field_enabled();
	fn test_field_delta() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalWakeUpConfig__bindgen_ty_1>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).delta) as usize - ptr as usize
		           },
		           1usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalWakeUpConfig__bindgen_ty_1),
			"::",
			stringify!(delta)
		)
		);
	}
	test_field_delta();
	fn test_field_reference() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalWakeUpConfig__bindgen_ty_1>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).reference) as usize - ptr as usize
		           },
		           2usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalWakeUpConfig__bindgen_ty_1),
			"::",
			stringify!(reference)
		)
		);
	}
	test_field_reference();
	fn test_field_autoAvg() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalWakeUpConfig__bindgen_ty_1>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).autoAvg) as usize - ptr as usize
		           },
		           4usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalWakeUpConfig__bindgen_ty_1),
			"::",
			stringify!(autoAvg)
		)
		);
	}
	test_field_autoAvg();
	fn test_field_aaInclMeas() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalWakeUpConfig__bindgen_ty_1>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).aaInclMeas) as usize - ptr as usize
		           },
		           5usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalWakeUpConfig__bindgen_ty_1),
			"::",
			stringify!(aaInclMeas)
		)
		);
	}
	test_field_aaInclMeas();
	fn test_field_aaWeight() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalWakeUpConfig__bindgen_ty_1>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).aaWeight) as usize - ptr as usize
		           },
		           8usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalWakeUpConfig__bindgen_ty_1),
			"::",
			stringify!(aaWeight)
		)
		);
	}
	test_field_aaWeight();
}
#[repr(C)]
pub struct rfalWakeUpConfig__bindgen_ty_2 {
	#[doc = "< Inductive Phase measurement enabled"]
	pub enabled: bool,
	#[doc = "< Delta between the reference and measurement to wake-up"]
	pub delta: u8,
	#[doc = "< Reference to be used;RFAL_WUM_REFERENCE_AUTO sets it auto"]
	pub reference: u16,
	#[doc = "< Use the HW Auto Averaging feature"]
	pub autoAvg: bool,
	#[doc = "< When AutoAvg is enabled, include IRQ measurement"]
	pub aaInclMeas: bool,
	#[doc = "< When AutoAvg is enabled, last measure weight"]
	pub aaWeight: rfalWumAAWeight,
}
#[test]
fn bindgen_test_layout_rfalWakeUpConfig__bindgen_ty_2() {
	assert_eq!(
	           ::core::mem::size_of::<rfalWakeUpConfig__bindgen_ty_2>(),
	           12usize,
	           concat!("Size of: ", stringify!(rfalWakeUpConfig__bindgen_ty_2))
	);
	assert_eq!(
	           ::core::mem::align_of::<rfalWakeUpConfig__bindgen_ty_2>(),
	           4usize,
	           concat!("Alignment of ", stringify!(rfalWakeUpConfig__bindgen_ty_2))
	);
	fn test_field_enabled() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalWakeUpConfig__bindgen_ty_2>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).enabled) as usize - ptr as usize
		           },
		           0usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalWakeUpConfig__bindgen_ty_2),
			"::",
			stringify!(enabled)
		)
		);
	}
	test_field_enabled();
	fn test_field_delta() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalWakeUpConfig__bindgen_ty_2>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).delta) as usize - ptr as usize
		           },
		           1usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalWakeUpConfig__bindgen_ty_2),
			"::",
			stringify!(delta)
		)
		);
	}
	test_field_delta();
	fn test_field_reference() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalWakeUpConfig__bindgen_ty_2>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).reference) as usize - ptr as usize
		           },
		           2usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalWakeUpConfig__bindgen_ty_2),
			"::",
			stringify!(reference)
		)
		);
	}
	test_field_reference();
	fn test_field_autoAvg() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalWakeUpConfig__bindgen_ty_2>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).autoAvg) as usize - ptr as usize
		           },
		           4usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalWakeUpConfig__bindgen_ty_2),
			"::",
			stringify!(autoAvg)
		)
		);
	}
	test_field_autoAvg();
	fn test_field_aaInclMeas() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalWakeUpConfig__bindgen_ty_2>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).aaInclMeas) as usize - ptr as usize
		           },
		           5usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalWakeUpConfig__bindgen_ty_2),
			"::",
			stringify!(aaInclMeas)
		)
		);
	}
	test_field_aaInclMeas();
	fn test_field_aaWeight() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalWakeUpConfig__bindgen_ty_2>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).aaWeight) as usize - ptr as usize
		           },
		           8usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalWakeUpConfig__bindgen_ty_2),
			"::",
			stringify!(aaWeight)
		)
		);
	}
	test_field_aaWeight();
}
#[repr(C)]
pub struct rfalWakeUpConfig__bindgen_ty_3 {
	#[doc = "< Capacitive measurement enabled"]
	pub enabled: bool,
	#[doc = "< Delta between the reference and measurement to wake-up"]
	pub delta: u8,
	#[doc = "< Reference to be used;RFAL_WUM_REFERENCE_AUTO sets it auto"]
	pub reference: u16,
	#[doc = "< Use the HW Auto Averaging feature"]
	pub autoAvg: bool,
	#[doc = "< When AutoAvg is enabled, include IRQ measurement"]
	pub aaInclMeas: bool,
	#[doc = "< When AutoAvg is enabled, last measure weight"]
	pub aaWeight: rfalWumAAWeight,
}
#[test]
fn bindgen_test_layout_rfalWakeUpConfig__bindgen_ty_3() {
	assert_eq!(
	           ::core::mem::size_of::<rfalWakeUpConfig__bindgen_ty_3>(),
	           12usize,
	           concat!("Size of: ", stringify!(rfalWakeUpConfig__bindgen_ty_3))
	);
	assert_eq!(
	           ::core::mem::align_of::<rfalWakeUpConfig__bindgen_ty_3>(),
	           4usize,
	           concat!("Alignment of ", stringify!(rfalWakeUpConfig__bindgen_ty_3))
	);
	fn test_field_enabled() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalWakeUpConfig__bindgen_ty_3>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).enabled) as usize - ptr as usize
		           },
		           0usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalWakeUpConfig__bindgen_ty_3),
			"::",
			stringify!(enabled)
		)
		);
	}
	test_field_enabled();
	fn test_field_delta() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalWakeUpConfig__bindgen_ty_3>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).delta) as usize - ptr as usize
		           },
		           1usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalWakeUpConfig__bindgen_ty_3),
			"::",
			stringify!(delta)
		)
		);
	}
	test_field_delta();
	fn test_field_reference() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalWakeUpConfig__bindgen_ty_3>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).reference) as usize - ptr as usize
		           },
		           2usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalWakeUpConfig__bindgen_ty_3),
			"::",
			stringify!(reference)
		)
		);
	}
	test_field_reference();
	fn test_field_autoAvg() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalWakeUpConfig__bindgen_ty_3>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).autoAvg) as usize - ptr as usize
		           },
		           4usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalWakeUpConfig__bindgen_ty_3),
			"::",
			stringify!(autoAvg)
		)
		);
	}
	test_field_autoAvg();
	fn test_field_aaInclMeas() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalWakeUpConfig__bindgen_ty_3>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).aaInclMeas) as usize - ptr as usize
		           },
		           5usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalWakeUpConfig__bindgen_ty_3),
			"::",
			stringify!(aaInclMeas)
		)
		);
	}
	test_field_aaInclMeas();
	fn test_field_aaWeight() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalWakeUpConfig__bindgen_ty_3>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).aaWeight) as usize - ptr as usize
		           },
		           8usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalWakeUpConfig__bindgen_ty_3),
			"::",
			stringify!(aaWeight)
		)
		);
	}
	test_field_aaWeight();
}
#[test]
fn bindgen_test_layout_rfalWakeUpConfig() {
	assert_eq!(
	           ::core::mem::size_of::<rfalWakeUpConfig>(),
	           44usize,
	           concat!("Size of: ", stringify!(rfalWakeUpConfig))
	);
	assert_eq!(
	           ::core::mem::align_of::<rfalWakeUpConfig>(),
	           4usize,
	           concat!("Alignment of ", stringify!(rfalWakeUpConfig))
	);
	fn test_field_period() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalWakeUpConfig>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).period) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(rfalWakeUpConfig), "::", stringify!(period))
		);
	}
	test_field_period();
	fn test_field_irqTout() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalWakeUpConfig>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).irqTout) as usize - ptr as usize
		           },
		           4usize,
		           concat!("Offset of field: ", stringify!(rfalWakeUpConfig), "::", stringify!(irqTout))
		);
	}
	test_field_irqTout();
	fn test_field_swTagDetect() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalWakeUpConfig>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).swTagDetect) as usize - ptr as usize
		           },
		           5usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalWakeUpConfig),
			"::",
			stringify!(swTagDetect)
		)
		);
	}
	test_field_swTagDetect();
	fn test_field_indAmp() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalWakeUpConfig>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).indAmp) as usize - ptr as usize
		           },
		           8usize,
		           concat!("Offset of field: ", stringify!(rfalWakeUpConfig), "::", stringify!(indAmp))
		);
	}
	test_field_indAmp();
	fn test_field_indPha() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalWakeUpConfig>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).indPha) as usize - ptr as usize
		           },
		           20usize,
		           concat!("Offset of field: ", stringify!(rfalWakeUpConfig), "::", stringify!(indPha))
		);
	}
	test_field_indPha();
	fn test_field_cap() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalWakeUpConfig>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).cap) as usize - ptr as usize
		           },
		           32usize,
		           concat!("Offset of field: ", stringify!(rfalWakeUpConfig), "::", stringify!(cap))
		);
	}
	test_field_cap();
}
extern "C" {
	#[doc = " \\brief  RFAL Initialize"]
	#[doc = ""]
	#[doc = " Initializes RFAL layer and the ST25R391x"]
	#[doc = " Ensures that ST25R391x is properly connected and returns error if any problem"]
	#[doc = " is detected"]
	#[doc = ""]
	#[doc = " \\warning rfalAnalogConfigInitialize() should be called before so that"]
	#[doc = "           the Analog config table has been previously initialized."]
	#[doc = ""]
	#[doc = " \\return ERR_HW_MISMATCH  : Expected HW do not match or communication error"]
	#[doc = " \\return ERR_NONE         : No error"]
	#[doc = ""]
	pub fn rfalInitialize() -> ReturnCode;
}
extern "C" {
	#[doc = " \\brief  RFAL Calibrate"]
	#[doc = ""]
	#[doc = " Performs necessary calibration of RF chip in case it is indicated by current"]
	#[doc = " register settings. E.g. antenna calibration and regulator calibration"]
	#[doc = ""]
	#[doc = " \\return ERR_WRONG_STATE  : RFAL not initialized"]
	#[doc = " \\return ERR_NONE         : No error"]
	#[doc = ""]
	#[doc = ""]
	pub fn rfalCalibrate() -> ReturnCode;
}
extern "C" {
	#[doc = " \\brief  RFAL Adjust Regulators"]
	#[doc = ""]
	#[doc = " Adjusts ST25R391x regulators"]
	#[doc = ""]
	#[doc = " \\param[out]  result : the result of the calibrate antenna in mV"]
	#[doc = "                       NULL if result not requested"]
	#[doc = ""]
	#[doc = " \\return ERR_WRONG_STATE  : RFAL not initialized"]
	#[doc = " \\return ERR_NONE         : No error"]
	#[doc = ""]
	#[doc = ""]
	pub fn rfalAdjustRegulators(result: *mut u16) -> ReturnCode;
}
extern "C" {
	#[doc = " \\brief RFAL Set System Callback"]
	#[doc = ""]
	#[doc = " Sets a callback for the driver to call when an event has occurred that"]
	#[doc = " may require the system to be notified"]
	#[doc = ""]
	#[doc = " \\param[in]  pFunc : method pointer for the upper layer callback"]
	#[doc = ""]
	#[doc = ""]
	pub fn rfalSetUpperLayerCallback(pFunc: rfalUpperLayerCallback);
}
extern "C" {
	#[doc = " \\brief RFAL Set Pre Tx Callback"]
	#[doc = ""]
	#[doc = " Sets a callback for the driver to call before a Transceive"]
	#[doc = ""]
	#[doc = " \\param[in]  pFunc : method pointer for the Pre Tx callback"]
	#[doc = ""]
	#[doc = ""]
	pub fn rfalSetPreTxRxCallback(pFunc: rfalPreTxRxCallback);
}
extern "C" {
	#[doc = " \\brief RFAL Set Post Tx Callback"]
	#[doc = ""]
	#[doc = " Sets a callback for the driver to call after a Transceive"]
	#[doc = ""]
	#[doc = " \\param[in]  pFunc : method pointer for the Post Tx callback"]
	#[doc = ""]
	#[doc = ""]
	pub fn rfalSetPostTxRxCallback(pFunc: rfalPostTxRxCallback);
}
extern "C" {
	#[doc = " Set RFAL state changed callback"]
	#[doc = ""]
	#[doc = " @param cb    RfalStateChangedCallback instance"]
	#[doc = " @param ctx   pointer to context"]
	pub fn rfal_set_state_changed_callback(callback: RfalStateChangedCallback);
}
extern "C" {
	#[doc = " Set callback context"]
	#[doc = ""]
	#[doc = " @param ctx pointer to context"]
	pub fn rfal_set_callback_context(context: *mut core::ffi::c_void);
}
extern "C" {
	#[doc = " \\brief  RFAL Deinitialize"]
	#[doc = ""]
	#[doc = " Deinitializes RFAL layer and the ST25R391x"]
	#[doc = ""]
	#[doc = " \\return ERR_NONE : No error"]
	#[doc = ""]
	#[doc = ""]
	pub fn rfalDeinitialize() -> ReturnCode;
}
extern "C" {
	#[doc = " \\brief  RFAL Set Mode"]
	#[doc = ""]
	#[doc = " Sets the mode that RFAL will operate on the following communications."]
	#[doc = " Proper initializations will be performed on the ST25R391x"]
	#[doc = ""]
	#[doc = " \\warning bit rate value RFAL_BR_KEEP is not allowed, only in rfalSetBitRate()"]
	#[doc = ""]
	#[doc = " \\warning the mode will be applied immediately on the RFchip regardless of"]
	#[doc = "          any ongoing operations like Transceive, ListenMode"]
	#[doc = ""]
	#[doc = " \\param[in]  mode : mode for the RFAL/RFchip to perform"]
	#[doc = " \\param[in]  txBR : transmit bit rate"]
	#[doc = " \\param[in]  rxBR : receive bit rate"]
	#[doc = ""]
	#[doc = " \\see rfalIsGTExpired"]
	#[doc = " \\see rfalMode"]
	#[doc = ""]
	#[doc = " \\return ERR_WRONG_STATE  : RFAL not initialized"]
	#[doc = " \\return ERR_PARAM        : Invalid parameter"]
	#[doc = " \\return ERR_NONE         : No error"]
	#[doc = ""]
	#[doc = ""]
	pub fn rfalSetMode(mode: rfalMode, txBR: rfalBitRate, rxBR: rfalBitRate) -> ReturnCode;
}
extern "C" {
	#[doc = " \\brief  RFAL Get Mode"]
	#[doc = ""]
	#[doc = " Gets the mode that RFAL is set to operate"]
	#[doc = ""]
	#[doc = " \\see rfalMode"]
	#[doc = ""]
	#[doc = " \\return rfalMode : The current RFAL mode"]
	#[doc = ""]
	pub fn rfalGetMode() -> rfalMode;
}
extern "C" {
	#[doc = " \\brief  RFAL Set Bit Rate"]
	#[doc = ""]
	#[doc = " Sets the Tx and Rx bit rates with the given values"]
	#[doc = " The bit rate change is applied on the RF chip remaining in the same"]
	#[doc = " mode previous defined with rfalSetMode()"]
	#[doc = ""]
	#[doc = " If no mode is defined bit rates will not be applied and an error"]
	#[doc = " is returned"]
	#[doc = ""]
	#[doc = " \\param[in]  txBR : transmit bit rate"]
	#[doc = " \\param[in]  rxBR : receive bit rate"]
	#[doc = ""]
	#[doc = " \\see rfalSetMode"]
	#[doc = " \\see rfalMode"]
	#[doc = " \\see rfalBitRate"]
	#[doc = ""]
	#[doc = " \\return ERR_WRONG_STATE     : RFAL not initialized"]
	#[doc = " \\return ERR_PARAM           : Invalid parameter"]
	#[doc = " \\return ERR_NOT_IMPLEMENTED : Mode not implemented"]
	#[doc = " \\return ERR_NONE            : No error"]
	#[doc = ""]
	#[doc = ""]
	pub fn rfalSetBitRate(txBR: rfalBitRate, rxBR: rfalBitRate) -> ReturnCode;
}
extern "C" {
	#[doc = " \\brief  RFAL Get Bit Rate"]
	#[doc = ""]
	#[doc = " Gets the Tx and Rx current bit rates"]
	#[doc = ""]
	#[doc = " If RFAL is not initialized or mode not set the bit rates return will"]
	#[doc = " be invalid RFAL_BR_KEEP"]
	#[doc = ""]
	#[doc = " \\param[out]  txBR : RFAL's current Tx Bit Rate"]
	#[doc = " \\param[out]  rxBR : RFAL's current Rx Bit Rate"]
	#[doc = ""]
	#[doc = " \\see rfalSetBitRate"]
	#[doc = " \\see rfalBitRate"]
	#[doc = ""]
	#[doc = " \\return ERR_WRONG_STATE  : RFAL not initialized or mode not set"]
	#[doc = " \\return ERR_NONE         : No error"]
	#[doc = ""]
	pub fn rfalGetBitRate(txBR: *mut rfalBitRate, rxBR: *mut rfalBitRate) -> ReturnCode;
}
extern "C" {
	#[doc = " \\brief Set Error Handling Mode"]
	#[doc = ""]
	#[doc = "  Sets the error handling mode to be used by the RFAL"]
	#[doc = ""]
	#[doc = " \\param[in]  eHandling : the error handling mode"]
	#[doc = ""]
	#[doc = ""]
	pub fn rfalSetErrorHandling(eHandling: rfalEHandling);
}
extern "C" {
	#[doc = " \\brief Get Error Handling Mode"]
	#[doc = ""]
	#[doc = "  Gets the error handling mode currently used by the RFAL"]
	#[doc = ""]
	#[doc = " \\return rfalEHandling : Current error handling mode"]
	#[doc = ""]
	pub fn rfalGetErrorHandling() -> rfalEHandling;
}
extern "C" {
	#[doc = " \\brief Set Observation Mode"]
	#[doc = ""]
	#[doc = " Sets ST25R391x observation modes for RF debug purposes"]
	#[doc = ""]
	#[doc = " \\param[in]  txMode : the observation mode to be used during transmission"]
	#[doc = " \\param[in]  rxMode : the observation mode to be used during reception"]
	#[doc = ""]
	#[doc = " \\warning The Observation Mode is an advanced feature and should be set"]
	#[doc = "          according to the documentation of the part number in use."]
	#[doc = "          Please refer to the corresponding Datasheet or Application Note(s)"]
	#[doc = ""]
	pub fn rfalSetObsvMode(txMode: u8, rxMode: u8);
}
extern "C" {
	#[doc = " \\brief Get Observation Mode"]
	#[doc = ""]
	#[doc = " Gets ST25R391x the current configured observation modes"]
	#[doc = ""]
	#[doc = " \\param[in]  txMode : the current observation mode configured for transmission"]
	#[doc = " \\param[in]  rxMode : the current observation mode configured for reception"]
	#[doc = ""]
	#[doc = ""]
	pub fn rfalGetObsvMode(txMode: *mut u8, rxMode: *mut u8);
}
extern "C" {
	#[doc = " \\brief Disable Observation Mode"]
	#[doc = ""]
	#[doc = " Disables the ST25R391x observation mode"]
	#[doc = ""]
	pub fn rfalDisableObsvMode();
}
extern "C" {
	#[doc = " \\brief  RFAL Set FDT Poll"]
	#[doc = ""]
	#[doc = " Sets the Frame Delay Time (FDT) to be used on the following"]
	#[doc = " communications."]
	#[doc = ""]
	#[doc = " FDT Poll is the minimum time following a Poll Frame during"]
	#[doc = " which no subsequent Poll Frame can be sent (without a response from"]
	#[doc = " the Listener in between)"]
	#[doc = " FDTx,PP,MIN - Digital 1.1  6.10.2  &  7.9.2  &  8.7.2"]
	#[doc = ""]
	#[doc = " \\param[in]  FDTPoll : Frame Delay Time in 1/fc cycles"]
	#[doc = ""]
	#[doc = ""]
	pub fn rfalSetFDTPoll(FDTPoll: u32);
}
extern "C" {
	#[doc = " \\brief  RFAL Set FDT Poll"]
	#[doc = ""]
	#[doc = " Gets the current Frame Delay Time (FDT)"]
	#[doc = ""]
	#[doc = " FDT Poll is the minimum time following a Poll Frame during"]
	#[doc = " which no subsequent Poll Frame can be sent (without a response from"]
	#[doc = " the Listener in between)"]
	#[doc = " FDTx,PP,MIN - Digital 1.1  6.10.2  &  7.9.2  &  8.7.2"]
	#[doc = ""]
	#[doc = " \\return FDT : current FDT value in 1/fc cycles"]
	#[doc = ""]
	#[doc = ""]
	pub fn rfalGetFDTPoll() -> u32;
}
extern "C" {
	#[doc = " \\brief  RFAL Set FDT Listen"]
	#[doc = ""]
	#[doc = " Sets the Frame Delay Time (FDT) Listen minimum to be used on the"]
	#[doc = " following communications."]
	#[doc = ""]
	#[doc = " FDT Listen is the minimum time between a Poll Frame and a Listen Frame"]
	#[doc = " FDTx,LISTEN,MIN - Digital 1.1  6.10.1  &  7.9.1  &  8.7.1"]
	#[doc = ""]
	#[doc = " \\param[in]  FDTListen : Frame Delay Time in 1/fc cycles"]
	#[doc = ""]
	#[doc = ""]
	pub fn rfalSetFDTListen(FDTListen: u32);
}
extern "C" {
	#[doc = " \\brief  RFAL Set FDT Listen"]
	#[doc = ""]
	#[doc = " Gets the Frame Delay Time (FDT) Listen minimum"]
	#[doc = ""]
	#[doc = " FDT Listen is the minimum time between a Poll Frame and a Listen Frame"]
	#[doc = " FDTx,LISTEN,MIN - Digital 1.1  6.10.1  &  7.9.1  &  8.7.1"]
	#[doc = ""]
	#[doc = " \\return FDT : current FDT value in 1/fc cycles"]
	#[doc = ""]
	#[doc = ""]
	pub fn rfalGetFDTListen() -> u32;
}
extern "C" {
	#[doc = " \\brief  RFAL Get GT"]
	#[doc = ""]
	#[doc = " Gets the current Guard Time (GT)"]
	#[doc = ""]
	#[doc = " GT is the minimum time when a device in Listen Mode is exposed to an"]
	#[doc = " unmodulated carrier"]
	#[doc = ""]
	#[doc = " \\return GT :  Guard Time in 1/fc cycles"]
	#[doc = ""]
	#[doc = ""]
	pub fn rfalGetGT() -> u32;
}
extern "C" {
	#[doc = " \\brief  RFAL Set GT"]
	#[doc = ""]
	#[doc = " Sets the Guard Time (GT) to be used on the following communications."]
	#[doc = ""]
	#[doc = " GT is the minimum time when a device in Listen Mode is exposed to an"]
	#[doc = " unmodulated carrier"]
	#[doc = ""]
	#[doc = " \\param[in]  GT : Guard Time in 1/fc cycles"]
	#[doc = "                  RFAL_GT_NONE if no GT should be applied"]
	#[doc = ""]
	#[doc = ""]
	pub fn rfalSetGT(GT: u32);
}
extern "C" {
	#[doc = " \\brief  RFAL Is GT expired"]
	#[doc = ""]
	#[doc = " Checks whether the GT timer has expired"]
	#[doc = ""]
	#[doc = " \\return true  : GT has expired or not running"]
	#[doc = " \\return false : GT is still running"]
	#[doc = ""]
	#[doc = ""]
	pub fn rfalIsGTExpired() -> bool;
}
extern "C" {
	#[doc = " \\brief  RFAL Turn Field On and Start GT"]
	#[doc = ""]
	#[doc = " Turns the Field On, performing Initial Collision Avoidance"]
	#[doc = ""]
	#[doc = " After Field On, if GT was set before, it starts the GT timer to be"]
	#[doc = " used on the following communications."]
	#[doc = ""]
	#[doc = " \\return ERR_RF_COLLISION : External field detected"]
	#[doc = " \\return ERR_NONE         : Field turned On"]
	#[doc = ""]
	#[doc = ""]
	pub fn rfalFieldOnAndStartGT() -> ReturnCode;
}
extern "C" {
	#[doc = " \\brief  RFAL Turn Field Off"]
	#[doc = ""]
	#[doc = " Turns the Field Off"]
	#[doc = ""]
	#[doc = " \\return ERR_NONE : Field turned Off"]
	#[doc = ""]
	pub fn rfalFieldOff() -> ReturnCode;
}
extern "C" {
	#[doc = " \\brief  RFAL Set transceive context"]
	#[doc = ""]
	#[doc = " Set the context that will be used for the following Transceive"]
	#[doc = " Output and input buffers have to be passed and all other details prior to"]
	#[doc = " the Transceive itself has been started"]
	#[doc = ""]
	#[doc = " This method only sets the context, once set rfalWorker has"]
	#[doc = " to be executed until is done"]
	#[doc = ""]
	#[doc = " \\param[in]  ctx : the context for the following Transceive"]
	#[doc = ""]
	#[doc = " \\see  rfalWorker"]
	#[doc = " \\see  rfalGetTransceiveStatus"]
	#[doc = ""]
	#[doc = " \\return ERR_NONE        : Done with no error"]
	#[doc = " \\return ERR_WRONG_STATE : Not initialized properly"]
	#[doc = " \\return ERR_PARAM       : Invalid parameter or configuration"]
	#[doc = ""]
	pub fn rfalStartTransceive(ctx: *const rfalTransceiveContext) -> ReturnCode;
}
extern "C" {
	#[doc = " \\brief  Get Transceive State"]
	#[doc = ""]
	#[doc = " Gets current Transceive internal State"]
	#[doc = ""]
	#[doc = " \\return rfalTransceiveState : the current Transceive internal State"]
	#[doc = ""]
	pub fn rfalGetTransceiveState() -> rfalTransceiveState;
}
extern "C" {
	#[doc = " \\brief  Get Transceive Status"]
	#[doc = ""]
	#[doc = " Gets current Transceive status"]
	#[doc = ""]
	#[doc = " \\return  ERR_NONE         : Transceive done with no error"]
	#[doc = " \\return  ERR_BUSY         : Transceive ongoing"]
	#[doc = " \\return  ERR_XXXX         : Error occurred"]
	#[doc = " \\return  ERR_TIMEOUT      : No response"]
	#[doc = " \\return  ERR_FRAMING      : Framing error detected"]
	#[doc = " \\return  ERR_PAR          : Parity error detected"]
	#[doc = " \\return  ERR_CRC          : CRC error detected"]
	#[doc = " \\return  ERR_LINK_LOSS    : Link Loss - External Field is Off"]
	#[doc = " \\return  ERR_RF_COLLISION : Collision detected"]
	#[doc = " \\return  ERR_IO           : Internal error"]
	#[doc = ""]
	pub fn rfalGetTransceiveStatus() -> ReturnCode;
}
extern "C" {
	#[doc = " \\brief  Is Transceive in Tx"]
	#[doc = ""]
	#[doc = " Checks if Transceive is in Transmission state"]
	#[doc = ""]
	#[doc = " \\return true   Transmission ongoing"]
	#[doc = " \\return false  Not in transmission state"]
	#[doc = ""]
	pub fn rfalIsTransceiveInTx() -> bool;
}
extern "C" {
	#[doc = " \\brief  Is Transceive in Rx"]
	#[doc = ""]
	#[doc = " Checks if Transceive is in Reception state"]
	#[doc = ""]
	#[doc = " \\return true   Transmission done/reception ongoing"]
	#[doc = " \\return false  Not in reception state"]
	#[doc = ""]
	pub fn rfalIsTransceiveInRx() -> bool;
}
extern "C" {
	#[doc = " \\brief  Get Transceive RSSI"]
	#[doc = ""]
	#[doc = " Gets the RSSI value of the last executed Transceive in mV"]
	#[doc = ""]
	#[doc = " \\param[out]  rssi : RSSI value"]
	#[doc = ""]
	#[doc = " \\return  ERR_NOTSUPP : Feature not supported"]
	#[doc = " \\return  ERR_PARAM   : Invalid parameter"]
	#[doc = " \\return  ERR_NONE    : No error"]
	#[doc = ""]
	pub fn rfalGetTransceiveRSSI(rssi: *mut u16) -> ReturnCode;
}
extern "C" {
	#[doc = "  \\brief RFAL Worker"]
	#[doc = ""]
	#[doc = "  This runs RFAL layer, which drives the actual Transceive procedure"]
	#[doc = "  It MUST be executed frequently in order to execute the RFAL internal"]
	#[doc = "  states and perform the requested operations"]
	#[doc = ""]
	#[doc = ""]
	pub fn rfalWorker();
}
extern "C" {
	#[doc = "  \\brief Transceives an ISO14443A ShortFrame"]
	#[doc = ""]
	#[doc = "  Sends REQA to detect if there is any PICC in the field"]
	#[doc = ""]
	#[doc = " \\param[in]  txCmd:     Command to be sent:"]
	#[doc = "                           0x52 WUPA / ALL_REQ"]
	#[doc = "                           0x26 REQA / SENS_REQ"]
	#[doc = ""]
	#[doc = " \\param[in]  txCmd    : type of short frame to be sent REQA or WUPA"]
	#[doc = " \\param[out] rxBuf    : buffer to place the response"]
	#[doc = " \\param[in]  rxBufLen : length of rxBuf"]
	#[doc = " \\param[out] rxRcvdLen: received length"]
	#[doc = " \\param[in]  fwt      : Frame Waiting Time in 1/fc"]
	#[doc = ""]
	#[doc = " \\warning If fwt is set to RFAL_FWT_NONE it will make endlessly for"]
	#[doc = "         a response, which on a blocking method may not be the"]
	#[doc = "         desired usage"]
	#[doc = ""]
	#[doc = " \\return ERR_NONE if there is response"]
	#[doc = " \\return ERR_TIMEOUT if there is no response"]
	#[doc = " \\return ERR_COLLISION collision has occurred"]
	#[doc = ""]
	#[doc = ""]
	pub fn rfalISO14443ATransceiveShortFrame(txCmd: rfal14443AShortFrameCmd,
	                                         rxBuf: *mut u8,
	                                         rxBufLen: u8,
	                                         rxRcvdLen: *mut u16,
	                                         fwt: u32)
	                                         -> ReturnCode;
}
extern "C" {
	#[doc = " \\brief Sends an ISO14443A Anticollision Frame"]
	#[doc = ""]
	#[doc = " This is use to perform ISO14443A anti-collision."]
	#[doc = " \\note Anticollision is sent without CRC"]
	#[doc = ""]
	#[doc = ""]
	#[doc = " \\param[in]   buf        : reference to ANTICOLLISION command (with known UID if any) to be sent (also out param)"]
	#[doc = "                           reception will be place on this buf after bytesToSend"]
	#[doc = " \\param[in]   bytesToSend: reference number of full bytes to be sent (including CMD byte and SEL_PAR)"]
	#[doc = "                           if a collision occurs will contain the number of clear bytes"]
	#[doc = " \\param[in]   bitsToSend : reference to number of bits (0-7) to be sent; and received (also out param)"]
	#[doc = "                           if a collision occurs will indicate the number of clear bits (also out param)"]
	#[doc = " \\param[out]  rxLength   : reference to the return the received length"]
	#[doc = " \\param[in]   fwt        : Frame Waiting Time in 1/fc"]
	#[doc = ""]
	#[doc = " \\return ERR_NONE if there is no error"]
	#[doc = ""]
	pub fn rfalISO14443ATransceiveAnticollisionFrame(buf: *mut u8,
	                                                 bytesToSend: *mut u8,
	                                                 bitsToSend: *mut u8,
	                                                 rxLength: *mut u16,
	                                                 fwt: u32)
	                                                 -> ReturnCode;
}
extern "C" {
	#[doc = " \\brief FeliCa Poll"]
	#[doc = ""]
	#[doc = " Sends a Poll Request and collects all Poll Responses according to the"]
	#[doc = " given slots"]
	#[doc = ""]
	#[doc = ""]
	#[doc = " \\param[in]   slots             : number of slots for the Poll Request"]
	#[doc = " \\param[in]   sysCode           : system code (SC) for the Poll Request"]
	#[doc = " \\param[in]   reqCode           : request code (RC) for the Poll Request"]
	#[doc = " \\param[out]  pollResList       : list of all responses"]
	#[doc = " \\param[in]   pollResListSize   : number of responses that can be placed in pollResList"]
	#[doc = " \\param[out]  devicesDetected   : number of cards found"]
	#[doc = " \\param[out]  collisionsDetected: number of collisions detected"]
	#[doc = ""]
	#[doc = " \\return ERR_NONE if there is no error"]
	#[doc = " \\return ERR_TIMEOUT if there is no response"]
	#[doc = ""]
	pub fn rfalFeliCaPoll(slots: rfalFeliCaPollSlots,
	                      sysCode: u16,
	                      reqCode: u8,
	                      pollResList: *mut rfalFeliCaPollRes,
	                      pollResListSize: u8,
	                      devicesDetected: *mut u8,
	                      collisionsDetected: *mut u8)
	                      -> ReturnCode;
}
extern "C" {
	#[doc = " \\brief Sends an ISO15693 Anticollision Frame"]
	#[doc = ""]
	#[doc = " This send the Anticollision|Inventory frame (INVENTORY_REQ)"]
	#[doc = ""]
	#[doc = " \\warning rxBuf must be able to contain the payload and CRC"]
	#[doc = ""]
	#[doc = " \\param[in]  txBuf        : Buffer where outgoing message is located"]
	#[doc = " \\param[in]  txBufLen     : Length of the outgoing message in bytes"]
	#[doc = " \\param[out] rxBuf        : Buffer where incoming message will be placed"]
	#[doc = " \\param[in]  rxBufLen     : Maximum length of the incoming message in bytes"]
	#[doc = " \\param[out] actLen       : Actual received length in bits"]
	#[doc = ""]
	#[doc = " \\return  ERR_NONE        : Transceive done with no error"]
	#[doc = " \\return  ERR_WRONG_STATE : RFAL not initialized or mode not set"]
	#[doc = " \\return  ERR_IO          : Internal error"]
	#[doc = ""]
	pub fn rfalISO15693TransceiveAnticollisionFrame(txBuf: *mut u8,
	                                                txBufLen: u8,
	                                                rxBuf: *mut u8,
	                                                rxBufLen: u8,
	                                                actLen: *mut u16)
	                                                -> ReturnCode;
}
extern "C" {
	#[doc = " \\brief Sends an ISO15693 Anticollision EOF"]
	#[doc = ""]
	#[doc = " This sends the Anticollision|Inventory EOF used as a slot marker"]
	#[doc = ""]
	#[doc = " \\warning rxBuf must be able to contain the payload and CRC"]
	#[doc = ""]
	#[doc = " \\param[out] rxBuf        : Buffer where incoming message will be placed"]
	#[doc = " \\param[in] rxBufLen      : Maximum length of the incoming message in bytes"]
	#[doc = " \\param[out] actLen       : Actual received length in bits"]
	#[doc = ""]
	#[doc = " \\return  ERR_NONE        : Transceive done with no error"]
	#[doc = " \\return  ERR_WRONG_STATE : RFAL not initialized or mode not set"]
	#[doc = " \\return  ERR_IO          : Internal error"]
	#[doc = ""]
	pub fn rfalISO15693TransceiveEOFAnticollision(rxBuf: *mut u8, rxBufLen: u8, actLen: *mut u16) -> ReturnCode;
}
extern "C" {
	#[doc = " \\brief Sends an ISO15693 EOF"]
	#[doc = ""]
	#[doc = " This is method sends an ISO15693 (EoF) used for a Write operation"]
	#[doc = ""]
	#[doc = " \\warning rxBuf must be able to contain the payload and CRC"]
	#[doc = ""]
	#[doc = " \\param[out] rxBuf        : Buffer where incoming message will be placed"]
	#[doc = " \\param[in] rxBufLen      : Maximum length of the incoming message in bytes"]
	#[doc = " \\param[out] actLen       : Actual received length in bytes"]
	#[doc = ""]
	#[doc = " \\return  ERR_NONE        : Transceive done with no error"]
	#[doc = " \\return  ERR_IO          : Internal error"]
	#[doc = ""]
	pub fn rfalISO15693TransceiveEOF(rxBuf: *mut u8, rxBufLen: u8, actLen: *mut u16) -> ReturnCode;
}
extern "C" {
	#[doc = " \\brief Transceive Blocking Tx"]
	#[doc = ""]
	#[doc = " This is method triggers a Transceive and executes it blocking until the"]
	#[doc = " Tx has been completed"]
	#[doc = ""]
	#[doc = " \\param[in]  txBuf    : Buffer where outgoing message is located"]
	#[doc = " \\param[in]  txBufLen : Length of the outgoing message in bytes"]
	#[doc = " \\param[out] rxBuf    : Buffer where incoming message will be placed"]
	#[doc = " \\param[in]  rxBufLen : Maximum length of the incoming message in bytes"]
	#[doc = " \\param[out] actLen   : Actual received length in bits"]
	#[doc = " \\param[in]  flags    : TransceiveFlags indication special handling"]
	#[doc = " \\param[in]  fwt      : Frame Waiting Time in 1/fc"]
	#[doc = ""]
	#[doc = " \\return  ERR_NONE         : Transceive done with no error"]
	#[doc = " \\return  ERR_BUSY         : Transceive ongoing"]
	#[doc = " \\return  ERR_XXXX         : Error occurred"]
	#[doc = " \\return  ERR_LINK_LOSS    : Link Loss - External Field is Off"]
	#[doc = " \\return  ERR_RF_COLLISION : Collision detected"]
	#[doc = " \\return  ERR_IO           : Internal error"]
	#[doc = ""]
	pub fn rfalTransceiveBlockingTx(txBuf: *mut u8,
	                                txBufLen: u16,
	                                rxBuf: *mut u8,
	                                rxBufLen: u16,
	                                actLen: *mut u16,
	                                flags: u32,
	                                fwt: u32)
	                                -> ReturnCode;
}
extern "C" {
	#[doc = " \\brief Transceive Blocking Rx"]
	#[doc = ""]
	#[doc = " This is method executes the reception of an ongoing Transceive triggered"]
	#[doc = " before by rfalTransceiveBlockingTx()"]
	#[doc = ""]
	#[doc = " \\return  ERR_NONE         : Transceive done with no error"]
	#[doc = " \\return  ERR_BUSY         : Transceive ongoing"]
	#[doc = " \\return  ERR_XXXX         : Error occurred"]
	#[doc = " \\return  ERR_TIMEOUT      : No response"]
	#[doc = " \\return  ERR_FRAMING      : Framing error detected"]
	#[doc = " \\return  ERR_PAR          : Parity error detected"]
	#[doc = " \\return  ERR_CRC          : CRC error detected"]
	#[doc = " \\return  ERR_LINK_LOSS    : Link Loss - External Field is Off"]
	#[doc = " \\return  ERR_RF_COLLISION : Collision detected"]
	#[doc = " \\return  ERR_IO           : Internal error"]
	#[doc = ""]
	pub fn rfalTransceiveBlockingRx() -> ReturnCode;
}
extern "C" {
	#[doc = " \\brief Transceive Blocking"]
	#[doc = ""]
	#[doc = " This is method triggers a Transceive and executes it blocking until it"]
	#[doc = " has been completed"]
	#[doc = ""]
	#[doc = " \\param[in]  txBuf    : Buffer where outgoing message is located"]
	#[doc = " \\param[in]  txBufLen : Length of the outgoing message in bytes"]
	#[doc = " \\param[out] rxBuf    : Buffer where incoming message will be placed"]
	#[doc = " \\param[in]  rxBufLen : Maximum length of the incoming message in bytes"]
	#[doc = " \\param[out] actLen   : Actual received length in bytes"]
	#[doc = " \\param[in]  flags    : TransceiveFlags indication special handling"]
	#[doc = " \\param[in]  fwt      : Frame Waiting Time in 1/fc"]
	#[doc = ""]
	#[doc = " \\return  ERR_NONE         : Transceive done with no error"]
	#[doc = " \\return  ERR_BUSY         : Transceive ongoing"]
	#[doc = " \\return  ERR_XXXX         : Error occurred"]
	#[doc = " \\return  ERR_TIMEOUT      : No response"]
	#[doc = " \\return  ERR_FRAMING      : Framing error detected"]
	#[doc = " \\return  ERR_PAR          : Parity error detected"]
	#[doc = " \\return  ERR_CRC          : CRC error detected"]
	#[doc = " \\return  ERR_LINK_LOSS    : Link Loss - External Field is Off"]
	#[doc = " \\return  ERR_RF_COLLISION : Collision detected"]
	#[doc = " \\return  ERR_IO           : Internal error"]
	#[doc = ""]
	pub fn rfalTransceiveBlockingTxRx(txBuf: *mut u8,
	                                  txBufLen: u16,
	                                  rxBuf: *mut u8,
	                                  rxBufLen: u16,
	                                  actLen: *mut u16,
	                                  flags: u32,
	                                  fwt: u32)
	                                  -> ReturnCode;
}
extern "C" {
	pub fn rfalTransceiveBitsBlockingTx(txBuf: *mut u8,
	                                    txBufLen: u16,
	                                    rxBuf: *mut u8,
	                                    rxBufLen: u16,
	                                    actLen: *mut u16,
	                                    flags: u32,
	                                    fwt: u32)
	                                    -> ReturnCode;
}
extern "C" {
	#[doc = " \\brief Is external Field On"]
	#[doc = ""]
	#[doc = " Checks if external field (other peer/device) is on/detected"]
	#[doc = ""]
	#[doc = " \\return true  External field is On"]
	#[doc = " \\return false No external field is detected"]
	#[doc = ""]
	#[doc = ""]
	pub fn rfalIsExtFieldOn() -> bool;
}
extern "C" {
	#[doc = " \\brief Listen Mode start"]
	#[doc = ""]
	#[doc = " Configures RF Chip to go into listen mode enabling the given technologies"]
	#[doc = ""]
	#[doc = ""]
	#[doc = " \\param[in]  lmMask:    mask with the enabled/disabled listen modes"]
	#[doc = "                        use: RFAL_LM_MASK_NFCA ; RFAL_LM_MASK_NFCB ;"]
	#[doc = "                             RFAL_LM_MASK_NFCF ; RFAL_LM_MASK_ACTIVE_P2P"]
	#[doc = " \\param[in]  confA:     pointer to Passive A configurations (NULL if disabled)"]
	#[doc = " \\param[in]  confB:     pointer to Passive B configurations (NULL if disabled)"]
	#[doc = " \\param[in]  confF:     pointer to Passive F configurations (NULL if disabled)"]
	#[doc = " \\param[in]  rxBuf:     buffer to place incoming data"]
	#[doc = " \\param[in]  rxBufLen:  length in bits of rxBuf"]
	#[doc = " \\param[in]  rxLen:     pointer to write the data length in bits placed into rxBuf"]
	#[doc = ""]
	#[doc = ""]
	#[doc = " \\return ERR_PARAM    Invalid parameter"]
	#[doc = " \\return ERR_REQUEST  Invalid listen mode mask"]
	#[doc = " \\return ERR_NONE     Done with no error"]
	#[doc = ""]
	#[doc = ""]
	pub fn rfalListenStart(lmMask: u32,
	                       confA: *const rfalLmConfPA,
	                       confB: *const rfalLmConfPB,
	                       confF: *const rfalLmConfPF,
	                       rxBuf: *mut u8,
	                       rxBufLen: u16,
	                       rxLen: *mut u16)
	                       -> ReturnCode;
}
extern "C" {
	#[doc = " \\brief Listen Mode start Sleeping"]
	#[doc = ""]
	#[doc = ""]
	#[doc = ""]
	pub fn rfalListenSleepStart(sleepSt: rfalLmState, rxBuf: *mut u8, rxBufLen: u16, rxLen: *mut u16) -> ReturnCode;
}
extern "C" {
	#[doc = " \\brief Listen Mode Stop"]
	#[doc = ""]
	#[doc = " Disables the listen mode on the RF Chip"]
	#[doc = ""]
	#[doc = " \\warning the listen mode will be disabled immediately on the RFchip regardless"]
	#[doc = "          of any ongoing operations like Transceive"]
	#[doc = ""]
	#[doc = " \\return ERR_NONE Done with no error"]
	#[doc = ""]
	#[doc = ""]
	pub fn rfalListenStop() -> ReturnCode;
}
extern "C" {
	#[doc = " \\brief Listen Mode get state"]
	#[doc = ""]
	#[doc = " Sets the new state of the Listen Mode and applies the necessary changes"]
	#[doc = " on the RF Chip"]
	#[doc = ""]
	#[doc = " \\param[out]  dataFlag: indicates that Listen Mode has rcvd data and caller"]
	#[doc = "                         must process it. The received message is located"]
	#[doc = "                         at the rxBuf passed on rfalListenStart()."]
	#[doc = "                         rfalListenSetState() will clear this flag"]
	#[doc = "                         if NULL output parameter will no be written/returned"]
	#[doc = " \\param[out]  lastBR:   bit rate detected  of the last initiator request"]
	#[doc = "                         if NULL output parameter will no be written/returned"]
	#[doc = ""]
	#[doc = " \\return rfalLmState  RFAL_LM_STATE_NOT_INIT : LM not initialized properly"]
	#[doc = "                      Any Other              : LM State"]
	#[doc = ""]
	#[doc = ""]
	pub fn rfalListenGetState(dataFlag: *mut bool, lastBR: *mut rfalBitRate) -> rfalLmState;
}
extern "C" {
	#[doc = " \\brief Listen Mode set state"]
	#[doc = ""]
	#[doc = " Sets the new state of the Listen Mode and applies the necessary changes"]
	#[doc = " on the RF Chip"]
	#[doc = ""]
	#[doc = " \\param[in] newSt : New state to go to"]
	#[doc = ""]
	#[doc = " \\return ERR_WRONG_STATE : Not initialized properly"]
	#[doc = " \\return ERR_PARAM       : Invalid parameter"]
	#[doc = " \\return ERR_NONE        : Done with no error"]
	#[doc = ""]
	#[doc = ""]
	pub fn rfalListenSetState(newSt: rfalLmState) -> ReturnCode;
}
extern "C" {
	#[doc = " \\brief Wake-Up Mode Start"]
	#[doc = ""]
	#[doc = " Sets the RF Chip in Low Power Wake-Up Mode according to the given"]
	#[doc = " configuration."]
	#[doc = ""]
	#[doc = " \\param[in] config       : Generic Wake-Up configuration provided by lower"]
	#[doc = "                            layers. If NULL will automatically configure the"]
	#[doc = "                            Wake-Up mode"]
	#[doc = ""]
	#[doc = " \\return ERR_WRONG_STATE : Not initialized properly"]
	#[doc = " \\return ERR_PARAM       : Invalid parameter"]
	#[doc = " \\return ERR_NONE        : Done with no error"]
	#[doc = ""]
	#[doc = ""]
	pub fn rfalWakeUpModeStart(config: *const rfalWakeUpConfig) -> ReturnCode;
}
extern "C" {
	#[doc = " \\brief Wake-Up Has Woke"]
	#[doc = ""]
	#[doc = " Returns true if the Wake-Up mode is enabled and it has already received"]
	#[doc = " the indication from the RF Chip that the surrounding environment has changed"]
	#[doc = " and flagged at least one wake-Up interrupt"]
	#[doc = ""]
	#[doc = " \\return true  : Wake-Up mode enabled and has received a wake-up IRQ"]
	#[doc = " \\return false : no Wake-Up IRQ has been received"]
	#[doc = ""]
	#[doc = ""]
	pub fn rfalWakeUpModeHasWoke() -> bool;
}
extern "C" {
	#[doc = " \\brief Wake-Up Mode Stop"]
	#[doc = ""]
	#[doc = " Stops the Wake-Up Mode"]
	#[doc = ""]
	#[doc = " \\return ERR_WRONG_STATE : Not initialized properly"]
	#[doc = " \\return ERR_PARAM       : Invalid parameter"]
	#[doc = " \\return ERR_NONE        : Done with no error"]
	#[doc = ""]
	#[doc = ""]
	pub fn rfalWakeUpModeStop() -> ReturnCode;
}
extern "C" {
	#[doc = " \\brief Low Power Mode Start"]
	#[doc = ""]
	#[doc = " Sets the RF Chip in Low Power Mode."]
	#[doc = " In this mode the RF Chip is placed in Low Power Mode, similar to Wake-up"]
	#[doc = " mode but no operation nor period measurement is performed."]
	#[doc = " Mode must be terminated by rfalLowPowerModeStop()"]
	#[doc = ""]
	#[doc = " \\return ERR_WRONG_STATE : Not initialized properly"]
	#[doc = " \\return ERR_PARAM       : Invalid parameter"]
	#[doc = " \\return ERR_NONE        : Done with no error"]
	#[doc = ""]
	#[doc = ""]
	pub fn rfalLowPowerModeStart() -> ReturnCode;
}
extern "C" {
	#[doc = " \\brief Low Power Mode Stop"]
	#[doc = ""]
	#[doc = " Stops the Low Power Mode re-enabling the device"]
	#[doc = ""]
	#[doc = " \\return ERR_WRONG_STATE : Not initialized properly"]
	#[doc = " \\return ERR_PARAM       : Invalid parameter"]
	#[doc = " \\return ERR_NONE        : Done with no error"]
	#[doc = ""]
	#[doc = ""]
	pub fn rfalLowPowerModeStop() -> ReturnCode;
}
#[doc = " NFC-A T1T (Topaz) RID_RES  Digital 1.1  10.6.2 & Table 50"]
#[repr(C)]
pub struct rfalT1TRidRes {
	#[doc = "< T1T Header ROM: HR0"]
	pub hr0: u8,
	#[doc = "< T1T Header ROM: HR1"]
	pub hr1: u8,
	#[doc = "< T1T UID"]
	pub uid: [u8; 4usize],
}
#[test]
fn bindgen_test_layout_rfalT1TRidRes() {
	assert_eq!(
	           ::core::mem::size_of::<rfalT1TRidRes>(),
	           6usize,
	           concat!("Size of: ", stringify!(rfalT1TRidRes))
	);
	assert_eq!(
	           ::core::mem::align_of::<rfalT1TRidRes>(),
	           1usize,
	           concat!("Alignment of ", stringify!(rfalT1TRidRes))
	);
	fn test_field_hr0() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalT1TRidRes>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).hr0) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(rfalT1TRidRes), "::", stringify!(hr0))
		);
	}
	test_field_hr0();
	fn test_field_hr1() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalT1TRidRes>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).hr1) as usize - ptr as usize
		           },
		           1usize,
		           concat!("Offset of field: ", stringify!(rfalT1TRidRes), "::", stringify!(hr1))
		);
	}
	test_field_hr1();
	fn test_field_uid() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalT1TRidRes>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).uid) as usize - ptr as usize
		           },
		           2usize,
		           concat!("Offset of field: ", stringify!(rfalT1TRidRes), "::", stringify!(uid))
		);
	}
	test_field_uid();
}
extern "C" {
	#[doc = " \\brief  Initialize NFC-A T1T Poller mode"]
	#[doc = ""]
	#[doc = " This methods configures RFAL RF layer to perform as a"]
	#[doc = " NFC-A T1T Poller/RW (Topaz) including all default timings"]
	#[doc = ""]
	#[doc = " \\return ERR_WRONG_STATE  : RFAL not initialized or mode not set"]
	#[doc = " \\return ERR_NONE         : No error"]
	#[doc = ""]
	pub fn rfalT1TPollerInitialize() -> ReturnCode;
}
extern "C" {
	#[doc = " \\brief  NFC-A T1T Poller RID"]
	#[doc = ""]
	#[doc = " This method reads the UID of a NFC-A T1T Listener device"]
	#[doc = ""]
	#[doc = ""]
	#[doc = " \\param[out]  ridRes : pointer to place the RID_RES"]
	#[doc = ""]
	#[doc = " \\return ERR_WRONG_STATE  : RFAL not initialized or mode not set"]
	#[doc = " \\return ERR_PARAM        : Invalid parameter"]
	#[doc = " \\return ERR_NONE         : No error"]
	#[doc = ""]
	pub fn rfalT1TPollerRid(ridRes: *mut rfalT1TRidRes) -> ReturnCode;
}
extern "C" {
	#[doc = " \\brief  NFC-A T1T Poller RALL"]
	#[doc = ""]
	#[doc = " This method send a Read All command to a NFC-A T1T Listener device"]
	#[doc = ""]
	#[doc = ""]
	#[doc = " \\param[in]   uid       : the UID of the device to read data"]
	#[doc = " \\param[out]  rxBuf     : pointer to place the read data"]
	#[doc = " \\param[in]   rxBufLen  : size of rxBuf"]
	#[doc = " \\param[out]  rxRcvdLen : actual received data"]
	#[doc = ""]
	#[doc = " \\return ERR_WRONG_STATE  : RFAL not initialized or mode not set"]
	#[doc = " \\return ERR_PARAM        : Invalid parameter"]
	#[doc = " \\return ERR_NONE         : No error"]
	#[doc = ""]
	pub fn rfalT1TPollerRall(uid: *const u8, rxBuf: *mut u8, rxBufLen: u16, rxRcvdLen: *mut u16) -> ReturnCode;
}
extern "C" {
	#[doc = " \\brief  NFC-A T1T Poller Write"]
	#[doc = ""]
	#[doc = " This method writes the given data on the address of a NFC-A T1T Listener device"]
	#[doc = ""]
	#[doc = ""]
	#[doc = " \\param[in]   uid       : the UID of the device to read data"]
	#[doc = " \\param[in]   address   : address to write the data"]
	#[doc = " \\param[in]   data      : the data to be written"]
	#[doc = ""]
	#[doc = " \\return ERR_WRONG_STATE  : RFAL not initialized or mode not set"]
	#[doc = " \\return ERR_PARAM        : Invalid parameter"]
	#[doc = " \\return ERR_NONE         : No error"]
	#[doc = ""]
	pub fn rfalT1TPollerWrite(uid: *const u8, address: u8, data: u8) -> ReturnCode;
}
#[repr(u32)]
#[non_exhaustive]
#[doc = " NFC-A Listen device types"]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum rfalNfcaListenDeviceType {
	RFAL_NFCA_T1T = 1,
	RFAL_NFCA_T2T = 0,
	RFAL_NFCA_T4T = 32,
	RFAL_NFCA_NFCDEP = 64,
	RFAL_NFCA_T4T_NFCDEP = 96,
}
#[doc = " SENS_RES (ATQA) format  Digital 1.1  6.6.3 & Table 7"]
#[repr(C)]
pub struct rfalNfcaSensRes {
	#[doc = "< SENS_RES Anticollision Information"]
	pub anticollisionInfo: u8,
	#[doc = "< SENS_RES Platform Information"]
	pub platformInfo: u8,
}
#[test]
fn bindgen_test_layout_rfalNfcaSensRes() {
	assert_eq!(
	           ::core::mem::size_of::<rfalNfcaSensRes>(),
	           2usize,
	           concat!("Size of: ", stringify!(rfalNfcaSensRes))
	);
	assert_eq!(
	           ::core::mem::align_of::<rfalNfcaSensRes>(),
	           1usize,
	           concat!("Alignment of ", stringify!(rfalNfcaSensRes))
	);
	fn test_field_anticollisionInfo() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcaSensRes>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).anticollisionInfo) as usize - ptr as usize
		           },
		           0usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalNfcaSensRes),
			"::",
			stringify!(anticollisionInfo)
		)
		);
	}
	test_field_anticollisionInfo();
	fn test_field_platformInfo() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcaSensRes>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).platformInfo) as usize - ptr as usize
		           },
		           1usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalNfcaSensRes),
			"::",
			stringify!(platformInfo)
		)
		);
	}
	test_field_platformInfo();
}
#[doc = " SEL_RES (SAK) format   Digital 1.1  6.8.2 & Table 19"]
#[repr(C)]
pub struct rfalNfcaSelRes {
	#[doc = "< Select Acknowledge"]
	pub sak: u8,
}
#[test]
fn bindgen_test_layout_rfalNfcaSelRes() {
	assert_eq!(
	           ::core::mem::size_of::<rfalNfcaSelRes>(),
	           1usize,
	           concat!("Size of: ", stringify!(rfalNfcaSelRes))
	);
	assert_eq!(
	           ::core::mem::align_of::<rfalNfcaSelRes>(),
	           1usize,
	           concat!("Alignment of ", stringify!(rfalNfcaSelRes))
	);
	fn test_field_sak() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcaSelRes>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).sak) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(rfalNfcaSelRes), "::", stringify!(sak))
		);
	}
	test_field_sak();
}
#[doc = " NFC-A listener device (PICC) struct"]
#[repr(C)]
pub struct rfalNfcaListenDevice {
	#[doc = "< NFC-A Listen device type"]
	pub type_: rfalNfcaListenDeviceType,
	#[doc = "< SENS_RES (ATQA)"]
	pub sensRes: rfalNfcaSensRes,
	#[doc = "< SEL_RES  (SAK)"]
	pub selRes: rfalNfcaSelRes,
	#[doc = "< NFCID1 Length"]
	pub nfcId1Len: u8,
	pub nfcId1: [u8; 10usize],
	#[doc = "< RID_RES"]
	pub ridRes: rfalT1TRidRes,
	#[doc = "< Device sleeping flag"]
	pub isSleep: bool,
}
#[test]
fn bindgen_test_layout_rfalNfcaListenDevice() {
	assert_eq!(
	           ::core::mem::size_of::<rfalNfcaListenDevice>(),
	           28usize,
	           concat!("Size of: ", stringify!(rfalNfcaListenDevice))
	);
	assert_eq!(
	           ::core::mem::align_of::<rfalNfcaListenDevice>(),
	           4usize,
	           concat!("Alignment of ", stringify!(rfalNfcaListenDevice))
	);
	fn test_field_type() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcaListenDevice>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(rfalNfcaListenDevice), "::", stringify!(type_))
		);
	}
	test_field_type();
	fn test_field_sensRes() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcaListenDevice>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).sensRes) as usize - ptr as usize
		           },
		           4usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalNfcaListenDevice),
			"::",
			stringify!(sensRes)
		)
		);
	}
	test_field_sensRes();
	fn test_field_selRes() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcaListenDevice>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).selRes) as usize - ptr as usize
		           },
		           6usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalNfcaListenDevice),
			"::",
			stringify!(selRes)
		)
		);
	}
	test_field_selRes();
	fn test_field_nfcId1Len() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcaListenDevice>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).nfcId1Len) as usize - ptr as usize
		           },
		           7usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalNfcaListenDevice),
			"::",
			stringify!(nfcId1Len)
		)
		);
	}
	test_field_nfcId1Len();
	fn test_field_nfcId1() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcaListenDevice>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).nfcId1) as usize - ptr as usize
		           },
		           8usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalNfcaListenDevice),
			"::",
			stringify!(nfcId1)
		)
		);
	}
	test_field_nfcId1();
	fn test_field_ridRes() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcaListenDevice>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).ridRes) as usize - ptr as usize
		           },
		           18usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalNfcaListenDevice),
			"::",
			stringify!(ridRes)
		)
		);
	}
	test_field_ridRes();
	fn test_field_isSleep() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcaListenDevice>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).isSleep) as usize - ptr as usize
		           },
		           24usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalNfcaListenDevice),
			"::",
			stringify!(isSleep)
		)
		);
	}
	test_field_isSleep();
}
extern "C" {
	#[doc = " \\brief  Initialize NFC-A Poller mode"]
	#[doc = ""]
	#[doc = " This methods configures RFAL RF layer to perform as a"]
	#[doc = " NFC-A Poller/RW (ISO14443A PCD) including all default timings and bit rate"]
	#[doc = " to 106 kbps"]
	#[doc = ""]
	#[doc = ""]
	#[doc = " \\return ERR_WRONG_STATE  : RFAL not initialized or mode not set"]
	#[doc = " \\return ERR_NONE         : No error"]
	#[doc = ""]
	pub fn rfalNfcaPollerInitialize() -> ReturnCode;
}
extern "C" {
	#[doc = " \\brief  NFC-A Poller Check Presence"]
	#[doc = ""]
	#[doc = " This method checks if a NFC-A Listen device (PICC) is present on the field"]
	#[doc = " by sending an ALL_REQ (WUPA) or SENS_REQ (REQA)"]
	#[doc = ""]
	#[doc = " \\param[in]  cmd     : Indicate if to send an ALL_REQ or a SENS_REQ"]
	#[doc = " \\param[out] sensRes : If received, the SENS_RES"]
	#[doc = ""]
	#[doc = " \\return ERR_WRONG_STATE  : RFAL not initialized or incorrect mode"]
	#[doc = " \\return ERR_PARAM        : Invalid parameters"]
	#[doc = " \\return ERR_IO           : Generic internal error"]
	#[doc = " \\return ERR_RF_COLLISION : Collision detected one or more device in the field"]
	#[doc = " \\return ERR_PAR          : Parity error detected, one or more device in the field"]
	#[doc = " \\return ERR_CRC          : CRC error detected, one or more device in the field"]
	#[doc = " \\return ERR_FRAMING      : Framing error detected, one or more device in the field"]
	#[doc = " \\return ERR_PROTO        : Protocol error detected, one or more device in the field"]
	#[doc = " \\return ERR_TIMEOUT      : Timeout error, no listener device detected"]
	#[doc = " \\return ERR_NONE         : No error, one or more device in the field"]
	#[doc = ""]
	pub fn rfalNfcaPollerCheckPresence(cmd: rfal14443AShortFrameCmd, sensRes: *mut rfalNfcaSensRes) -> ReturnCode;
}
extern "C" {
	#[doc = " \\brief  NFC-A Poller Select"]
	#[doc = ""]
	#[doc = " This method selects a NFC-A Listener device (PICC)"]
	#[doc = ""]
	#[doc = " \\param[in]  nfcid1   : Listener device NFCID1 to be selected"]
	#[doc = " \\param[in]  nfcidLen : Length of the NFCID1 to be selected"]
	#[doc = " \\param[out] selRes   : pointer to place the SEL_RES"]
	#[doc = ""]
	#[doc = " \\return ERR_WRONG_STATE  : RFAL not initialized or incorrect mode"]
	#[doc = " \\return ERR_PARAM        : Invalid parameters"]
	#[doc = " \\return ERR_IO           : Generic internal error"]
	#[doc = " \\return ERR_TIMEOUT      : Timeout error"]
	#[doc = " \\return ERR_PAR          : Parity error detected"]
	#[doc = " \\return ERR_CRC          : CRC error detected"]
	#[doc = " \\return ERR_FRAMING      : Framing error detected"]
	#[doc = " \\return ERR_PROTO        : Protocol error detected"]
	#[doc = " \\return ERR_NONE         : No error, SEL_RES received"]
	#[doc = ""]
	pub fn rfalNfcaPollerSelect(nfcid1: *const u8, nfcidLen: u8, selRes: *mut rfalNfcaSelRes) -> ReturnCode;
}
extern "C" {
	#[doc = " \\brief  NFC-A Poller Sleep"]
	#[doc = ""]
	#[doc = " This method sends a SLP_REQ (HLTA)"]
	#[doc = " No response is expected afterwards   Digital 1.1  6.9.2.1"]
	#[doc = ""]
	#[doc = " \\return ERR_WRONG_STATE  : RFAL not initialized or incorrect mode"]
	#[doc = " \\return ERR_PARAM        : Invalid parameters"]
	#[doc = " \\return ERR_IO           : Generic internal error"]
	#[doc = " \\return ERR_NONE         : No error"]
	#[doc = ""]
	pub fn rfalNfcaPollerSleep() -> ReturnCode;
}
extern "C" {
	#[doc = " \\brief  NFC-A Technology Detection"]
	#[doc = ""]
	#[doc = " This method performs NFC-A Technology Detection as defined in the spec"]
	#[doc = " given in the compliance mode"]
	#[doc = ""]
	#[doc = " \\param[in]  compMode  : compliance mode to be performed"]
	#[doc = " \\param[out] sensRes   : location to store the SENS_RES, if received"]
	#[doc = ""]
	#[doc = " When compMode is set to ISO compliance a SLP_REQ (HLTA) is not sent"]
	#[doc = " after detection. When set to EMV a ALL_REQ (WUPA) is sent instead of"]
	#[doc = " a SENS_REQ (REQA)"]
	#[doc = ""]
	#[doc = " \\return ERR_WRONG_STATE  : RFAL not initialized or incorrect mode"]
	#[doc = " \\return ERR_PARAM        : Invalid parameters"]
	#[doc = " \\return ERR_IO           : Generic internal error"]
	#[doc = " \\return ERR_NONE         : No error, one or more device in the field"]
	#[doc = ""]
	pub fn rfalNfcaPollerTechnologyDetection(compMode: rfalComplianceMode, sensRes: *mut rfalNfcaSensRes) -> ReturnCode;
}
extern "C" {
	#[doc = " \\brief  NFC-A Poller Collision Resolution"]
	#[doc = ""]
	#[doc = " Collision resolution for one NFC-A Listener device/card (PICC) as"]
	#[doc = " defined in Activity 2.1  9.3.4"]
	#[doc = ""]
	#[doc = " This method executes anti collision loop and select the device with higher NFCID1"]
	#[doc = ""]
	#[doc = " When devLimit = 0 it is configured to perform collision detection only. Once a collision"]
	#[doc = " is detected the collision resolution is aborted immidiatly. If only one device is found"]
	#[doc = " with no collisions, it will properly resolved."]
	#[doc = ""]
	#[doc = " \\param[in]  devLimit    : device limit value (CON_DEVICES_LIMIT)"]
	#[doc = " \\param[out] collPending : pointer to collision pending flag (INT_COLL_PEND)"]
	#[doc = " \\param[out] selRes      : location to store the last Select Response from listener device (PICC)"]
	#[doc = " \\param[out] nfcId1      : location to store the NFCID1 (UID), ensure RFAL_NFCA_CASCADE_3_UID_LEN"]
	#[doc = " \\param[out] nfcId1Len   : pointer to length of NFCID1 (UID)"]
	#[doc = ""]
	#[doc = " \\return ERR_WRONG_STATE  : RFAL not initialized or mode not set"]
	#[doc = " \\return ERR_PARAM        : Invalid parameters"]
	#[doc = " \\return ERR_IO           : Generic internal error"]
	#[doc = " \\return ERR_PROTO        : Card length invalid"]
	#[doc = " \\return ERR_IGNORE       : conDevLimit is 0 and there is a collision"]
	#[doc = " \\return ERR_NONE         : No error"]
	#[doc = ""]
	pub fn rfalNfcaPollerSingleCollisionResolution(devLimit: u8,
	                                               collPending: *mut bool,
	                                               selRes: *mut rfalNfcaSelRes,
	                                               nfcId1: *mut u8,
	                                               nfcId1Len: *mut u8)
	                                               -> ReturnCode;
}
extern "C" {
	#[doc = " \\brief  NFC-A Poller Full Collision Resolution"]
	#[doc = ""]
	#[doc = " Performs a full Collision resolution as defined in Activity 2.1  9.3.4"]
	#[doc = ""]
	#[doc = " \\param[in]  compMode    : compliance mode to be performed"]
	#[doc = " \\param[in]  devLimit    : device limit value, and size nfcaDevList"]
	#[doc = " \\param[out] nfcaDevList : NFC-A listener device info"]
	#[doc = " \\param[out] devCnt      : Devices found counter"]
	#[doc = ""]
	#[doc = " When compMode is set to ISO compliance it assumes that the device is"]
	#[doc = " not sleeping and therefore no ALL_REQ (WUPA) is sent at the beginning."]
	#[doc = " When compMode is set to NFC compliance an additional ALL_REQ (WUPA) is sent"]
	#[doc = " at the beginning."]
	#[doc = ""]
	#[doc = ""]
	#[doc = " When devLimit = 0 it is configured to perform collision detection only. Once a collision"]
	#[doc = " is detected the collision resolution is aborted immidiatly. If only one device is found"]
	#[doc = " with no collisions, it will properly resolved."]
	#[doc = ""]
	#[doc = ""]
	#[doc = " \\return ERR_WRONG_STATE  : RFAL not initialized or mode not set"]
	#[doc = " \\return ERR_PARAM        : Invalid parameters"]
	#[doc = " \\return ERR_IO           : Generic internal error"]
	#[doc = " \\return ERR_NONE         : No error"]
	#[doc = ""]
	pub fn rfalNfcaPollerFullCollisionResolution(compMode: rfalComplianceMode,
	                                             devLimit: u8,
	                                             nfcaDevList: *mut rfalNfcaListenDevice,
	                                             devCnt: *mut u8)
	                                             -> ReturnCode;
}
extern "C" {
	#[doc = " \\brief  NFC-A Poller Full Collision Resolution with Sleep"]
	#[doc = ""]
	#[doc = " Performs a full Collision resolution similar to rfalNfcaPollerFullCollisionResolution"]
	#[doc = " but an additional SLP_REQ (HLTA) -> SENS_RES (REQA) is sent regardless if there"]
	#[doc = " was a collision."]
	#[doc = " This proprietary behaviour ensures proper activation of certain devices that suffer"]
	#[doc = " from influence of Type B commands as foreseen in ISO14443-3 5.2.3 or were somehow"]
	#[doc = " not detected by the first round of collision resolution"]
	#[doc = ""]
	#[doc = " \\param[in]  devLimit    : device limit value, and size nfcaDevList"]
	#[doc = " \\param[out] nfcaDevList : NFC-A listener device info"]
	#[doc = " \\param[out] devCnt      : Devices found counter"]
	#[doc = ""]
	#[doc = ""]
	#[doc = " \\return ERR_WRONG_STATE  : RFAL not initialized or mode not set"]
	#[doc = " \\return ERR_PARAM        : Invalid parameters"]
	#[doc = " \\return ERR_IO           : Generic internal error"]
	#[doc = " \\return ERR_NONE         : No error"]
	#[doc = ""]
	pub fn rfalNfcaPollerSleepFullCollisionResolution(devLimit: u8,
	                                                  nfcaDevList: *mut rfalNfcaListenDevice,
	                                                  devCnt: *mut u8)
	                                                  -> ReturnCode;
}
extern "C" {
	#[doc = " \\brief  NFC-A Poller Start Full Collision Resolution"]
	#[doc = ""]
	#[doc = " This method starts the full Collision resolution as defined"]
	#[doc = " in Activity 1.0 or 1.1  9.3.4"]
	#[doc = ""]
	#[doc = " \\param[in]  compMode    : compliance mode to be performed"]
	#[doc = " \\param[in]  devLimit    : device limit value, and size nfcaDevList"]
	#[doc = " \\param[out] nfcaDevList : NFC-A listener device info"]
	#[doc = " \\param[out] devCnt      : Devices found counter"]
	#[doc = ""]
	#[doc = " When compMode is set to ISO compliance it assumes that the device is"]
	#[doc = " not sleeping and therefore no ALL_REQ (WUPA) is sent at the beginning."]
	#[doc = " When compMode is set to NFC compliance an additional ALL_REQ (WUPA) is sent at"]
	#[doc = " the beginning."]
	#[doc = ""]
	#[doc = ""]
	#[doc = " When devLimit = 0 it is configured to perform collision detection only. Once a collision"]
	#[doc = " is detected the collision resolution is aborted immidiatly. If only one device is found"]
	#[doc = " with no collisions, it will properly resolved."]
	#[doc = ""]
	#[doc = ""]
	#[doc = " \\return ERR_WRONG_STATE  : RFAL not initialized or mode not set"]
	#[doc = " \\return ERR_PARAM        : Invalid parameters"]
	#[doc = " \\return ERR_IO           : Generic internal error"]
	#[doc = " \\return ERR_NONE         : No error"]
	#[doc = ""]
	pub fn rfalNfcaPollerStartFullCollisionResolution(compMode: rfalComplianceMode,
	                                                  devLimit: u8,
	                                                  nfcaDevList: *mut rfalNfcaListenDevice,
	                                                  devCnt: *mut u8)
	                                                  -> ReturnCode;
}
extern "C" {
	#[doc = "  \\brief  NFC-A Get Full Collision Resolution Status"]
	#[doc = ""]
	#[doc = "  Returns the Collision Resolution status"]
	#[doc = ""]
	#[doc = "  \\return ERR_BUSY         : Operation is ongoing"]
	#[doc = "  \\return ERR_WRONG_STATE  : RFAL not initialized or incorrect mode"]
	#[doc = "  \\return ERR_PARAM        : Invalid parameters"]
	#[doc = "  \\return ERR_IO           : Generic internal error"]
	#[doc = "  \\return ERR_TIMEOUT      : Timeout error"]
	#[doc = "  \\return ERR_PAR          : Parity error detected"]
	#[doc = "  \\return ERR_CRC          : CRC error detected"]
	#[doc = "  \\return ERR_FRAMING      : Framing error detected"]
	#[doc = "  \\return ERR_PROTO        : Protocol error detected"]
	#[doc = "  \\return ERR_NONE         : No error, activation successful"]
	#[doc = ""]
	pub fn rfalNfcaPollerGetFullCollisionResolutionStatus() -> ReturnCode;
}
extern "C" {
	#[doc = " \\brief NFC-A Listener is SLP_REQ"]
	#[doc = ""]
	#[doc = " Checks if the given buffer contains valid NFC-A SLP_REQ (HALT)"]
	#[doc = ""]
	#[doc = " \\param[in] buf: buffer containing data"]
	#[doc = " \\param[in] bufLen: length of the data in buffer to be checked"]
	#[doc = ""]
	#[doc = " \\return true if data in buf contains a SLP_REQ ; false otherwise"]
	#[doc = ""]
	pub fn rfalNfcaListenerIsSleepReq(buf: *const u8, bufLen: u16) -> bool;
}
#[repr(u32)]
#[non_exhaustive]
#[doc = " SENSB_REQ and ALLB_REQ param   Digital 1.1 7.6.1"]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum rfalNfcbSensCmd {
	#[doc = "< ALLB_REQ  (WUPB)"]
	RFAL_NFCB_SENS_CMD_ALLB_REQ = 8,
	#[doc = "< SENSB_REQ (REQB)"]
	RFAL_NFCB_SENS_CMD_SENSB_REQ = 0,
}
#[repr(u32)]
#[non_exhaustive]
#[doc = " Number of Slots (NI) codes used for NFC-B anti collision  Digital 1.1 Table 26"]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum rfalNfcbSlots {
	#[doc = "< N=0 :  1 slot"]
	RFAL_NFCB_SLOT_NUM_1 = 0,
	#[doc = "< N=1 :  2 slots"]
	RFAL_NFCB_SLOT_NUM_2 = 1,
	#[doc = "< N=2 :  4 slots"]
	RFAL_NFCB_SLOT_NUM_4 = 2,
	#[doc = "< N=3 :  8 slots"]
	RFAL_NFCB_SLOT_NUM_8 = 3,
	#[doc = "< N=4 : 16 slots"]
	RFAL_NFCB_SLOT_NUM_16 = 4,
}
#[doc = " SENSB_RES (ATQB) Application Data Format   Digital 1.1 Table 28"]
#[repr(C)]
pub struct rfalNfcbSensbResAppData {
	#[doc = "< Application Family Identifier"]
	pub AFI: u8,
	#[doc = "< CRC_B of AID"]
	pub CRC_B: [u8; 2usize],
	#[doc = "< Number of Applications"]
	pub numApps: u8,
}
#[test]
fn bindgen_test_layout_rfalNfcbSensbResAppData() {
	assert_eq!(
	           ::core::mem::size_of::<rfalNfcbSensbResAppData>(),
	           4usize,
	           concat!("Size of: ", stringify!(rfalNfcbSensbResAppData))
	);
	assert_eq!(
	           ::core::mem::align_of::<rfalNfcbSensbResAppData>(),
	           1usize,
	           concat!("Alignment of ", stringify!(rfalNfcbSensbResAppData))
	);
	fn test_field_AFI() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcbSensbResAppData>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).AFI) as usize - ptr as usize
		           },
		           0usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalNfcbSensbResAppData),
			"::",
			stringify!(AFI)
		)
		);
	}
	test_field_AFI();
	fn test_field_CRC_B() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcbSensbResAppData>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).CRC_B) as usize - ptr as usize
		           },
		           1usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalNfcbSensbResAppData),
			"::",
			stringify!(CRC_B)
		)
		);
	}
	test_field_CRC_B();
	fn test_field_numApps() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcbSensbResAppData>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).numApps) as usize - ptr as usize
		           },
		           3usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalNfcbSensbResAppData),
			"::",
			stringify!(numApps)
		)
		);
	}
	test_field_numApps();
}
#[doc = " SENSB_RES Protocol Info format Digital 1.1 Table 29"]
#[repr(C)]
pub struct rfalNfcbSensbResProtocolInfo {
	#[doc = "< Bit Rate Capability"]
	pub BRC: u8,
	#[doc = "< Frame Size Card Integer [4b] | Protocol Type[4 bits]"]
	pub FsciProType: u8,
	#[doc = "< Frame Waiting Integer [4b] | Application Data Coding [2b] | Frame Options [2b]"]
	pub FwiAdcFo: u8,
	#[doc = "< Optional: Start-Up Frame Guard Time Integer[4b] | RFU [4b]"]
	pub SFGI: u8,
}
#[test]
fn bindgen_test_layout_rfalNfcbSensbResProtocolInfo() {
	assert_eq!(
	           ::core::mem::size_of::<rfalNfcbSensbResProtocolInfo>(),
	           4usize,
	           concat!("Size of: ", stringify!(rfalNfcbSensbResProtocolInfo))
	);
	assert_eq!(
	           ::core::mem::align_of::<rfalNfcbSensbResProtocolInfo>(),
	           1usize,
	           concat!("Alignment of ", stringify!(rfalNfcbSensbResProtocolInfo))
	);
	fn test_field_BRC() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcbSensbResProtocolInfo>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).BRC) as usize - ptr as usize
		           },
		           0usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalNfcbSensbResProtocolInfo),
			"::",
			stringify!(BRC)
		)
		);
	}
	test_field_BRC();
	fn test_field_FsciProType() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcbSensbResProtocolInfo>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).FsciProType) as usize - ptr as usize
		           },
		           1usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalNfcbSensbResProtocolInfo),
			"::",
			stringify!(FsciProType)
		)
		);
	}
	test_field_FsciProType();
	fn test_field_FwiAdcFo() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcbSensbResProtocolInfo>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).FwiAdcFo) as usize - ptr as usize
		           },
		           2usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalNfcbSensbResProtocolInfo),
			"::",
			stringify!(FwiAdcFo)
		)
		);
	}
	test_field_FwiAdcFo();
	fn test_field_SFGI() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcbSensbResProtocolInfo>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).SFGI) as usize - ptr as usize
		           },
		           3usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalNfcbSensbResProtocolInfo),
			"::",
			stringify!(SFGI)
		)
		);
	}
	test_field_SFGI();
}
#[doc = " SENSB_RES format   Digital 1.1  7.6.2"]
#[repr(C)]
pub struct rfalNfcbSensbRes {
	#[doc = "< SENSB_RES: 50h"]
	pub cmd: u8,
	#[doc = "< NFC Identifier (PUPI)"]
	pub nfcid0: [u8; 4usize],
	#[doc = "< Application Data"]
	pub appData: rfalNfcbSensbResAppData,
	#[doc = "< Protocol Information"]
	pub protInfo: rfalNfcbSensbResProtocolInfo,
}
#[test]
fn bindgen_test_layout_rfalNfcbSensbRes() {
	assert_eq!(
	           ::core::mem::size_of::<rfalNfcbSensbRes>(),
	           13usize,
	           concat!("Size of: ", stringify!(rfalNfcbSensbRes))
	);
	assert_eq!(
	           ::core::mem::align_of::<rfalNfcbSensbRes>(),
	           1usize,
	           concat!("Alignment of ", stringify!(rfalNfcbSensbRes))
	);
	fn test_field_cmd() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcbSensbRes>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).cmd) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(rfalNfcbSensbRes), "::", stringify!(cmd))
		);
	}
	test_field_cmd();
	fn test_field_nfcid0() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcbSensbRes>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).nfcid0) as usize - ptr as usize
		           },
		           1usize,
		           concat!("Offset of field: ", stringify!(rfalNfcbSensbRes), "::", stringify!(nfcid0))
		);
	}
	test_field_nfcid0();
	fn test_field_appData() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcbSensbRes>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).appData) as usize - ptr as usize
		           },
		           5usize,
		           concat!("Offset of field: ", stringify!(rfalNfcbSensbRes), "::", stringify!(appData))
		);
	}
	test_field_appData();
	fn test_field_protInfo() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcbSensbRes>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).protInfo) as usize - ptr as usize
		           },
		           9usize,
		           concat!("Offset of field: ", stringify!(rfalNfcbSensbRes), "::", stringify!(protInfo))
		);
	}
	test_field_protInfo();
}
#[doc = " NFC-B listener device (PICC) struct"]
#[repr(C)]
pub struct rfalNfcbListenDevice {
	#[doc = "< SENSB_RES length"]
	pub sensbResLen: u8,
	#[doc = "< SENSB_RES"]
	pub sensbRes: rfalNfcbSensbRes,
	#[doc = "< Device sleeping flag"]
	pub isSleep: bool,
}
#[test]
fn bindgen_test_layout_rfalNfcbListenDevice() {
	assert_eq!(
	           ::core::mem::size_of::<rfalNfcbListenDevice>(),
	           15usize,
	           concat!("Size of: ", stringify!(rfalNfcbListenDevice))
	);
	assert_eq!(
	           ::core::mem::align_of::<rfalNfcbListenDevice>(),
	           1usize,
	           concat!("Alignment of ", stringify!(rfalNfcbListenDevice))
	);
	fn test_field_sensbResLen() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcbListenDevice>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).sensbResLen) as usize - ptr as usize
		           },
		           0usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalNfcbListenDevice),
			"::",
			stringify!(sensbResLen)
		)
		);
	}
	test_field_sensbResLen();
	fn test_field_sensbRes() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcbListenDevice>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).sensbRes) as usize - ptr as usize
		           },
		           1usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalNfcbListenDevice),
			"::",
			stringify!(sensbRes)
		)
		);
	}
	test_field_sensbRes();
	fn test_field_isSleep() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcbListenDevice>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).isSleep) as usize - ptr as usize
		           },
		           14usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalNfcbListenDevice),
			"::",
			stringify!(isSleep)
		)
		);
	}
	test_field_isSleep();
}
extern "C" {
	#[doc = " \\brief  Initialize NFC-B Poller mode"]
	#[doc = ""]
	#[doc = " This methods configures RFAL RF layer to perform as a"]
	#[doc = " NFC-B Poller/RW (ISO14443B PCD) including all default timings"]
	#[doc = ""]
	#[doc = " It sets NFC-B parameters (AFI, PARAM) to default values"]
	#[doc = ""]
	#[doc = " \\return ERR_WRONG_STATE  : RFAL not initialized or mode not set"]
	#[doc = " \\return ERR_NONE         : No error"]
	#[doc = ""]
	pub fn rfalNfcbPollerInitialize() -> ReturnCode;
}
extern "C" {
	#[doc = " \\brief  Set NFC-B Poller parameters"]
	#[doc = ""]
	#[doc = " This methods configures RFAL RF layer to perform as a"]
	#[doc = " NFCA Poller/RW (ISO14443A PCD) including all default timings"]
	#[doc = ""]
	#[doc = " Additionally configures NFC-B specific parameters to be used on the"]
	#[doc = " following communications"]
	#[doc = ""]
	#[doc = " \\param[in]  AFI   : Application Family Identifier to be used"]
	#[doc = " \\param[in]  PARAM : PARAM to be used, it announces whether Advanced"]
	#[doc = "                     Features or Extended SENSB_RES is supported"]
	#[doc = ""]
	#[doc = " \\return ERR_WRONG_STATE  : RFAL not initialized or mode not set"]
	#[doc = " \\return ERR_NONE         : No error"]
	#[doc = ""]
	pub fn rfalNfcbPollerInitializeWithParams(AFI: u8, PARAM: u8) -> ReturnCode;
}
extern "C" {
	#[doc = " \\brief  NFC-B Poller Check Presence"]
	#[doc = ""]
	#[doc = " This method checks if a NFC-B Listen device (PICC) is present on the field"]
	#[doc = " by sending an ALLB_REQ (WUPB) or SENSB_REQ (REQB)"]
	#[doc = ""]
	#[doc = " \\param[in]  cmd         : Indicate if to send an ALL_REQ or a SENS_REQ"]
	#[doc = " \\param[in]  slots       : The number of slots to be announced"]
	#[doc = " \\param[out] sensbRes    : If received, the SENSB_RES"]
	#[doc = " \\param[out] sensbResLen : If received, the SENSB_RES length"]
	#[doc = ""]
	#[doc = ""]
	#[doc = " \\return ERR_WRONG_STATE  : RFAL not initialized or incorrect mode"]
	#[doc = " \\return ERR_PARAM        : Invalid parameters"]
	#[doc = " \\return ERR_IO           : Generic internal error"]
	#[doc = " \\return ERR_TIMEOUT      : Timeout error, no listener device detected"]
	#[doc = " \\return ERR_RF_COLLISION : Collision detected one or more device in the field"]
	#[doc = " \\return ERR_PAR          : Parity error detected, one or more device in the field"]
	#[doc = " \\return ERR_CRC          : CRC error detected, one or more device in the field"]
	#[doc = " \\return ERR_FRAMING      : Framing error detected, one or more device in the field"]
	#[doc = " \\return ERR_PROTO        : Protocol error detected, invalid SENSB_RES received"]
	#[doc = " \\return ERR_NONE         : No error, SENSB_RES received"]
	#[doc = ""]
	pub fn rfalNfcbPollerCheckPresence(cmd: rfalNfcbSensCmd,
	                                   slots: rfalNfcbSlots,
	                                   sensbRes: *mut rfalNfcbSensbRes,
	                                   sensbResLen: *mut u8)
	                                   -> ReturnCode;
}
extern "C" {
	#[doc = " \\brief  NFC-B Poller Sleep"]
	#[doc = ""]
	#[doc = " This function is used to send the SLPB_REQ (HLTB) command to put the PICC with"]
	#[doc = " the given NFCID0 to state HALT so that they do not reply to further SENSB_REQ"]
	#[doc = " commands (only to ALLB_REQ)"]
	#[doc = ""]
	#[doc = " \\param[in]  nfcid0       : NFCID of the device to be put to Sleep"]
	#[doc = ""]
	#[doc = " \\return ERR_WRONG_STATE  : RFAL not initialized or incorrect mode"]
	#[doc = " \\return ERR_PARAM        : Invalid parameters"]
	#[doc = " \\return ERR_IO           : Generic internal error"]
	#[doc = " \\return ERR_NONE         : No error"]
	#[doc = ""]
	pub fn rfalNfcbPollerSleep(nfcid0: *const u8) -> ReturnCode;
}
extern "C" {
	#[doc = " \\brief  NFC-B Poller Slot Marker"]
	#[doc = ""]
	#[doc = " This method selects a NFC-B Slot marker frame"]
	#[doc = ""]
	#[doc = " \\param[in]  slotCode     : Slot Code [1-15]"]
	#[doc = " \\param[out] sensbRes     : If received, the SENSB_RES"]
	#[doc = " \\param[out] sensbResLen  : If received, the SENSB_RES length"]
	#[doc = ""]
	#[doc = " \\return ERR_WRONG_STATE  : RFAL not initialized or incorrect mode"]
	#[doc = " \\return ERR_PARAM        : Invalid parameters"]
	#[doc = " \\return ERR_IO           : Generic internal error"]
	#[doc = " \\return ERR_TIMEOUT      : Timeout error"]
	#[doc = " \\return ERR_PAR          : Parity error detected"]
	#[doc = " \\return ERR_CRC          : CRC error detected"]
	#[doc = " \\return ERR_FRAMING      : Framing error detected"]
	#[doc = " \\return ERR_PROTO        : Protocol error detected"]
	#[doc = " \\return ERR_NONE         : No error, SEL_RES received"]
	#[doc = ""]
	pub fn rfalNfcbPollerSlotMarker(slotCode: u8, sensbRes: *mut rfalNfcbSensbRes, sensbResLen: *mut u8) -> ReturnCode;
}
extern "C" {
	#[doc = " \\brief  NFC-B Technology Detection"]
	#[doc = ""]
	#[doc = " This method performs NFC-B Technology Detection as defined in the spec"]
	#[doc = " given in the compliance mode"]
	#[doc = ""]
	#[doc = " \\param[in]  compMode    : compliance mode to be performed"]
	#[doc = " \\param[out] sensbRes    : location to store the SENSB_RES, if received"]
	#[doc = " \\param[out] sensbResLen : length of the SENSB_RES, if received"]
	#[doc = ""]
	#[doc = " \\return ERR_WRONG_STATE  : RFAL not initialized or incorrect mode"]
	#[doc = " \\return ERR_PARAM        : Invalid parameters"]
	#[doc = " \\return ERR_IO           : Generic internal error"]
	#[doc = " \\return ERR_NONE         : No error, one or more device in the field"]
	#[doc = ""]
	pub fn rfalNfcbPollerTechnologyDetection(compMode: rfalComplianceMode,
	                                         sensbRes: *mut rfalNfcbSensbRes,
	                                         sensbResLen: *mut u8)
	                                         -> ReturnCode;
}
extern "C" {
	#[doc = " \\brief  NFC-B Poller Collision Resolution"]
	#[doc = ""]
	#[doc = " NFC-B Collision resolution  Listener device/card (PICC) as"]
	#[doc = " defined in Activity 1.1  9.3.5"]
	#[doc = ""]
	#[doc = " This function is used to perform collision resolution for detection in case"]
	#[doc = " of multiple NFC Forum Devices with Technology B detected."]
	#[doc = " Target with valid SENSB_RES will be stored in devInfo and nfcbDevCount incremented."]
	#[doc = ""]
	#[doc = " \\param[in]  compMode    : compliance mode to be performed"]
	#[doc = " \\param[in]  devLimit    : device limit value, and size nfcbDevList"]
	#[doc = " \\param[out] nfcbDevList : NFC-B listener device info"]
	#[doc = " \\param[out] devCnt      : devices found counter"]
	#[doc = ""]
	#[doc = " \\return ERR_WRONG_STATE  : RFAL not initialized or mode not set"]
	#[doc = " \\return ERR_PARAM        : Invalid parameters"]
	#[doc = " \\return ERR_IO           : Generic internal error"]
	#[doc = " \\return ERR_PROTO        : Protocol error detected"]
	#[doc = " \\return ERR_NONE         : No error"]
	#[doc = ""]
	pub fn rfalNfcbPollerCollisionResolution(compMode: rfalComplianceMode,
	                                         devLimit: u8,
	                                         nfcbDevList: *mut rfalNfcbListenDevice,
	                                         devCnt: *mut u8)
	                                         -> ReturnCode;
}
extern "C" {
	#[doc = " \\brief  NFC-B Poller Collision Resolution Slotted"]
	#[doc = ""]
	#[doc = " NFC-B Collision resolution  Listener device/card (PICC). The sequence can"]
	#[doc = " be configured to be according to NFC Forum Activity 1.1  9.3.5, ISO10373"]
	#[doc = " or EMVCo"]
	#[doc = ""]
	#[doc = " This function is used to perform collision resolution for detection in case"]
	#[doc = " of multiple NFC Forum Devices with Technology B are detected."]
	#[doc = " Target with valid SENSB_RES will be stored in devInfo and nfcbDevCount incremented."]
	#[doc = ""]
	#[doc = " This method provides the means to perform a collision resolution loop with specific"]
	#[doc = " initial and end number of slots. This allows to user to start the loop already with"]
	#[doc = " greater number of slots, and or limit the end number of slots. At the end a flag"]
	#[doc = " indicating whether there were collisions pending is returned."]
	#[doc = ""]
	#[doc = " If RFAL_COMPLIANCE_MODE_ISO is used \\a initSlots must be set to RFAL_NFCB_SLOT_NUM_1"]
	#[doc = ""]
	#[doc = ""]
	#[doc = " \\param[in]  compMode    : compliance mode to be performed"]
	#[doc = " \\param[in]  devLimit    : device limit value, and size nfcbDevList"]
	#[doc = " \\param[in]  initSlots   : number of slots to open initially"]
	#[doc = " \\param[in]  endSlots    : number of slots when to stop collision resolution"]
	#[doc = " \\param[out] nfcbDevList : NFC-B listener device info"]
	#[doc = " \\param[out] devCnt      : devices found counter"]
	#[doc = " \\param[out] colPending  : flag indicating whether collision are still pending"]
	#[doc = ""]
	#[doc = " \\return ERR_WRONG_STATE  : RFAL not initialized or mode not set"]
	#[doc = " \\return ERR_PARAM        : Invalid parameters"]
	#[doc = " \\return ERR_IO           : Generic internal error"]
	#[doc = " \\return ERR_PROTO        : Protocol error detected"]
	#[doc = " \\return ERR_NONE         : No error"]
	#[doc = ""]
	pub fn rfalNfcbPollerSlottedCollisionResolution(compMode: rfalComplianceMode,
	                                                devLimit: u8,
	                                                initSlots: rfalNfcbSlots,
	                                                endSlots: rfalNfcbSlots,
	                                                nfcbDevList: *mut rfalNfcbListenDevice,
	                                                devCnt: *mut u8,
	                                                colPending: *mut bool)
	                                                -> ReturnCode;
}
extern "C" {
	#[doc = " \\brief  NFC-B TR2 code to FDT"]
	#[doc = ""]
	#[doc = "  Converts the TR2 code as defined in Digital 1.1 Table 33 Minimum"]
	#[doc = "  TR2 Coding to Frame Delay Time (FDT) in 1/Fc"]
	#[doc = ""]
	#[doc = " \\param[in]  tr2Code : TR2 code as defined in Digital 1.1 Table 33"]
	#[doc = ""]
	#[doc = " \\return FDT in 1/Fc"]
	#[doc = ""]
	pub fn rfalNfcbTR2ToFDT(tr2Code: u8) -> u32;
}
#[doc = " NFC-F SENSF_RES format  Digital 1.1  8.6.2"]
#[repr(C)]
pub struct rfalNfcfSensfRes {
	#[doc = "< Command Code: 01h"]
	pub CMD: u8,
	#[doc = "< NFCID2"]
	pub NFCID2: [u8; 8usize],
	#[doc = "< PAD0"]
	pub PAD0: [u8; 2usize],
	#[doc = "< PAD1"]
	pub PAD1: [u8; 2usize],
	#[doc = "< MRTIcheck"]
	pub MRTIcheck: u8,
	#[doc = "< MRTIupdate"]
	pub MRTIupdate: u8,
	#[doc = "< PAD2"]
	pub PAD2: u8,
	#[doc = "< Request Data"]
	pub RD: [u8; 2usize],
}
#[test]
fn bindgen_test_layout_rfalNfcfSensfRes() {
	assert_eq!(
	           ::core::mem::size_of::<rfalNfcfSensfRes>(),
	           18usize,
	           concat!("Size of: ", stringify!(rfalNfcfSensfRes))
	);
	assert_eq!(
	           ::core::mem::align_of::<rfalNfcfSensfRes>(),
	           1usize,
	           concat!("Alignment of ", stringify!(rfalNfcfSensfRes))
	);
	fn test_field_CMD() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcfSensfRes>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).CMD) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(rfalNfcfSensfRes), "::", stringify!(CMD))
		);
	}
	test_field_CMD();
	fn test_field_NFCID2() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcfSensfRes>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).NFCID2) as usize - ptr as usize
		           },
		           1usize,
		           concat!("Offset of field: ", stringify!(rfalNfcfSensfRes), "::", stringify!(NFCID2))
		);
	}
	test_field_NFCID2();
	fn test_field_PAD0() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcfSensfRes>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).PAD0) as usize - ptr as usize
		           },
		           9usize,
		           concat!("Offset of field: ", stringify!(rfalNfcfSensfRes), "::", stringify!(PAD0))
		);
	}
	test_field_PAD0();
	fn test_field_PAD1() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcfSensfRes>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).PAD1) as usize - ptr as usize
		           },
		           11usize,
		           concat!("Offset of field: ", stringify!(rfalNfcfSensfRes), "::", stringify!(PAD1))
		);
	}
	test_field_PAD1();
	fn test_field_MRTIcheck() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcfSensfRes>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).MRTIcheck) as usize - ptr as usize
		           },
		           13usize,
		           concat!("Offset of field: ", stringify!(rfalNfcfSensfRes), "::", stringify!(MRTIcheck))
		);
	}
	test_field_MRTIcheck();
	fn test_field_MRTIupdate() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcfSensfRes>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).MRTIupdate) as usize - ptr as usize
		           },
		           14usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalNfcfSensfRes),
			"::",
			stringify!(MRTIupdate)
		)
		);
	}
	test_field_MRTIupdate();
	fn test_field_PAD2() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcfSensfRes>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).PAD2) as usize - ptr as usize
		           },
		           15usize,
		           concat!("Offset of field: ", stringify!(rfalNfcfSensfRes), "::", stringify!(PAD2))
		);
	}
	test_field_PAD2();
	fn test_field_RD() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcfSensfRes>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).RD) as usize - ptr as usize
		           },
		           16usize,
		           concat!("Offset of field: ", stringify!(rfalNfcfSensfRes), "::", stringify!(RD))
		);
	}
	test_field_RD();
}
#[doc = " NFC-F listener device (PICC) struct"]
#[repr(C)]
pub struct rfalNfcfListenDevice {
	#[doc = "< SENF_RES length"]
	pub sensfResLen: u8,
	#[doc = "< SENF_RES"]
	pub sensfRes: rfalNfcfSensfRes,
}
#[test]
fn bindgen_test_layout_rfalNfcfListenDevice() {
	assert_eq!(
	           ::core::mem::size_of::<rfalNfcfListenDevice>(),
	           19usize,
	           concat!("Size of: ", stringify!(rfalNfcfListenDevice))
	);
	assert_eq!(
	           ::core::mem::align_of::<rfalNfcfListenDevice>(),
	           1usize,
	           concat!("Alignment of ", stringify!(rfalNfcfListenDevice))
	);
	fn test_field_sensfResLen() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcfListenDevice>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).sensfResLen) as usize - ptr as usize
		           },
		           0usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalNfcfListenDevice),
			"::",
			stringify!(sensfResLen)
		)
		);
	}
	test_field_sensfResLen();
	fn test_field_sensfRes() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcfListenDevice>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).sensfRes) as usize - ptr as usize
		           },
		           1usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalNfcfListenDevice),
			"::",
			stringify!(sensfRes)
		)
		);
	}
	test_field_sensfRes();
}
pub type rfalNfcfServ = u16;
#[doc = " NFC-F Block List Element (2 or 3 bytes element)       T3T 1.0 5.6.1"]
#[repr(C)]
pub struct rfalNfcfBlockListElem {
	#[doc = "<  Access Mode | Serv Code List Order"]
	pub conf: u8,
	#[doc = "<  Block Number"]
	pub blockNum: u16,
}
#[test]
fn bindgen_test_layout_rfalNfcfBlockListElem() {
	assert_eq!(
	           ::core::mem::size_of::<rfalNfcfBlockListElem>(),
	           4usize,
	           concat!("Size of: ", stringify!(rfalNfcfBlockListElem))
	);
	assert_eq!(
	           ::core::mem::align_of::<rfalNfcfBlockListElem>(),
	           2usize,
	           concat!("Alignment of ", stringify!(rfalNfcfBlockListElem))
	);
	fn test_field_conf() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcfBlockListElem>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).conf) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(rfalNfcfBlockListElem), "::", stringify!(conf))
		);
	}
	test_field_conf();
	fn test_field_blockNum() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcfBlockListElem>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).blockNum) as usize - ptr as usize
		           },
		           2usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalNfcfBlockListElem),
			"::",
			stringify!(blockNum)
		)
		);
	}
	test_field_blockNum();
}
#[doc = " Check Update Service list and Block list parameter"]
#[repr(C)]
pub struct rfalNfcfServBlockListParam {
	#[doc = "< Number of Services"]
	pub numServ: u8,
	#[doc = "< Service Code List"]
	pub servList: *mut rfalNfcfServ,
	#[doc = "< Number of Blocks"]
	pub numBlock: u8,
	#[doc = "< Block Number List"]
	pub blockList: *mut rfalNfcfBlockListElem,
}
#[test]
fn bindgen_test_layout_rfalNfcfServBlockListParam() {
	assert_eq!(
	           ::core::mem::size_of::<rfalNfcfServBlockListParam>(),
	           16usize,
	           concat!("Size of: ", stringify!(rfalNfcfServBlockListParam))
	);
	assert_eq!(
	           ::core::mem::align_of::<rfalNfcfServBlockListParam>(),
	           4usize,
	           concat!("Alignment of ", stringify!(rfalNfcfServBlockListParam))
	);
	fn test_field_numServ() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcfServBlockListParam>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).numServ) as usize - ptr as usize
		           },
		           0usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalNfcfServBlockListParam),
			"::",
			stringify!(numServ)
		)
		);
	}
	test_field_numServ();
	fn test_field_servList() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcfServBlockListParam>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).servList) as usize - ptr as usize
		           },
		           4usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalNfcfServBlockListParam),
			"::",
			stringify!(servList)
		)
		);
	}
	test_field_servList();
	fn test_field_numBlock() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcfServBlockListParam>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).numBlock) as usize - ptr as usize
		           },
		           8usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalNfcfServBlockListParam),
			"::",
			stringify!(numBlock)
		)
		);
	}
	test_field_numBlock();
	fn test_field_blockList() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcfServBlockListParam>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).blockList) as usize - ptr as usize
		           },
		           12usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalNfcfServBlockListParam),
			"::",
			stringify!(blockList)
		)
		);
	}
	test_field_blockList();
}
extern "C" {
	#[doc = " \\brief  Initialize NFC-F Poller mode"]
	#[doc = ""]
	#[doc = " This methods configures RFAL RF layer to perform as a"]
	#[doc = " NFC-F Poller/RW (FeliCa PCD) including all default timings"]
	#[doc = ""]
	#[doc = " \\param[in]  bitRate      : NFC-F bitrate to be initialize (212 or 424)"]
	#[doc = ""]
	#[doc = " \\return ERR_WRONG_STATE  : RFAL not initialized or mode not set"]
	#[doc = " \\return ERR_PARAM        : Incorrect bitrate"]
	#[doc = " \\return ERR_NONE         : No error"]
	#[doc = ""]
	pub fn rfalNfcfPollerInitialize(bitRate: rfalBitRate) -> ReturnCode;
}
extern "C" {
	#[doc = "  \\brief NFC-F Poller Check Presence"]
	#[doc = ""]
	#[doc = "  This function sends a Poll/SENSF command according to NFC Activity spec"]
	#[doc = "  It detects if a NCF-F device is within range"]
	#[doc = ""]
	#[doc = " \\return ERR_WRONG_STATE  : RFAL not initialized or incorrect mode"]
	#[doc = " \\return ERR_PARAM        : Invalid parameters"]
	#[doc = " \\return ERR_IO           : Generic internal error"]
	#[doc = " \\return ERR_CRC          : CRC error detected"]
	#[doc = " \\return ERR_FRAMING      : Framing error detected"]
	#[doc = " \\return ERR_PROTO        : Protocol error detected"]
	#[doc = " \\return ERR_TIMEOUT      : Timeout error, no listener device detected"]
	#[doc = " \\return ERR_NONE         : No error and some NFC-F device was detected"]
	#[doc = ""]
	#[doc = ""]
	pub fn rfalNfcfPollerCheckPresence() -> ReturnCode;
}
extern "C" {
	#[doc = " \\brief NFC-F Poller Poll"]
	#[doc = ""]
	#[doc = " This function sends to all PICCs in field the POLL command with the given"]
	#[doc = " number of slots."]
	#[doc = ""]
	#[doc = " \\param[in]  slots      : the number of slots to be performed"]
	#[doc = " \\param[in]  sysCode    : as given in FeliCa poll command"]
	#[doc = " \\param[in]  reqCode    : FeliCa communication parameters"]
	#[doc = " \\param[out] cardList   : Parameter of type rfalFeliCaPollRes which will hold the cards found"]
	#[doc = " \\param[out] devCnt     : actual number of cards found"]
	#[doc = " \\param[out] collisions : number of collisions encountered"]
	#[doc = ""]
	#[doc = " \\warning the list cardList has to be as big as the number of slots for the Poll"]
	#[doc = ""]
	#[doc = " \\return ERR_WRONG_STATE  : RFAL not initialized or incorrect mode"]
	#[doc = " \\return ERR_PARAM        : Invalid parameters"]
	#[doc = " \\return ERR_IO           : Generic internal error"]
	#[doc = " \\return ERR_CRC          : CRC error detected"]
	#[doc = " \\return ERR_FRAMING      : Framing error detected"]
	#[doc = " \\return ERR_PROTO        : Protocol error detected"]
	#[doc = " \\return ERR_TIMEOUT      : Timeout error, no listener device detected"]
	#[doc = " \\return ERR_NONE         : No error and some NFC-F device was detected"]
	#[doc = ""]
	#[doc = ""]
	pub fn rfalNfcfPollerPoll(slots: rfalFeliCaPollSlots,
	                          sysCode: u16,
	                          reqCode: u8,
	                          cardList: *mut rfalFeliCaPollRes,
	                          devCnt: *mut u8,
	                          collisions: *mut u8)
	                          -> ReturnCode;
}
extern "C" {
	#[doc = " \\brief  NFC-F Poller Full Collision Resolution"]
	#[doc = ""]
	#[doc = " Performs a full Collision resolution as defined in Activity 1.1  9.3.4"]
	#[doc = ""]
	#[doc = " \\param[in]  compMode    : compliance mode to be performed"]
	#[doc = " \\param[in]  devLimit    : device limit value, and size nfcaDevList"]
	#[doc = " \\param[out] nfcfDevList : NFC-F listener devices list"]
	#[doc = " \\param[out] devCnt      : Devices found counter"]
	#[doc = ""]
	#[doc = " \\return ERR_WRONG_STATE  : RFAL not initialized or mode not set"]
	#[doc = " \\return ERR_PARAM        : Invalid parameters"]
	#[doc = " \\return ERR_IO           : Generic internal error"]
	#[doc = " \\return ERR_NONE         : No error"]
	#[doc = ""]
	pub fn rfalNfcfPollerCollisionResolution(compMode: rfalComplianceMode,
	                                         devLimit: u8,
	                                         nfcfDevList: *mut rfalNfcfListenDevice,
	                                         devCnt: *mut u8)
	                                         -> ReturnCode;
}
extern "C" {
	#[doc = " \\brief  NFC-F Poller Check/Read"]
	#[doc = ""]
	#[doc = " It computes a Check / Read command accoring to T3T 1.0 and JIS X6319-4 and"]
	#[doc = " sends it to PICC. If sucessfully, the rxBuf will contain the the number of"]
	#[doc = " blocks in the first byte followed by the blocks data."]
	#[doc = ""]
	#[doc = " \\param[in]  nfcid2      : nfcid2 of the device"]
	#[doc = " \\param[in]  servBlock   : parameter containing the list of Services and"]
	#[doc = "                           Blocks to be addressed by this command"]
	#[doc = " \\param[out] rxBuf       : buffer to place check/read data"]
	#[doc = " \\param[in]  rxBufLen    : size of the rxBuf"]
	#[doc = " \\param[out] rcvdLen     : length of data placed in rxBuf"]
	#[doc = ""]
	#[doc = " \\return ERR_WRONG_STATE  : RFAL not initialized or mode not set"]
	#[doc = " \\return ERR_PARAM        : Invalid parameters"]
	#[doc = " \\return ERR_IO           : Generic internal error"]
	#[doc = " \\return ERR_REQUEST      : The request was executed with error"]
	#[doc = " \\return ERR_NONE         : No error"]
	#[doc = ""]
	pub fn rfalNfcfPollerCheck(nfcid2: *const u8,
	                           servBlock: *const rfalNfcfServBlockListParam,
	                           rxBuf: *mut u8,
	                           rxBufLen: u16,
	                           rcvdLen: *mut u16)
	                           -> ReturnCode;
}
extern "C" {
	#[doc = " \\brief  NFC-F Poller Update/Write"]
	#[doc = ""]
	#[doc = " It computes a Update / Write command accoring to T3T 1.0 and JIS X6319-4 and"]
	#[doc = " sends it to PICC."]
	#[doc = ""]
	#[doc = " \\param[in]  nfcid2      : nfcid2 of the device"]
	#[doc = " \\param[in]  servBlock   : parameter containing the list of Services and"]
	#[doc = "                           Blocks to be addressed by this command"]
	#[doc = " \\param[in]  txBuf       : buffer where the request will be composed"]
	#[doc = " \\param[in]  txBufLen    : size of txBuf"]
	#[doc = " \\param[in]  blockData   : data to written on the given block(s)"]
	#[doc = " \\param[out] rxBuf       : buffer to place check/read data"]
	#[doc = " \\param[in]  rxBufLen    : size of the rxBuf"]
	#[doc = ""]
	#[doc = " \\return ERR_WRONG_STATE  : RFAL not initialized or mode not set"]
	#[doc = " \\return ERR_PARAM        : Invalid parameters"]
	#[doc = " \\return ERR_IO           : Generic internal error"]
	#[doc = " \\return ERR_REQUEST      : The request was executed with error"]
	#[doc = " \\return ERR_NONE         : No error"]
	#[doc = ""]
	pub fn rfalNfcfPollerUpdate(nfcid2: *const u8,
	                            servBlock: *const rfalNfcfServBlockListParam,
	                            txBuf: *mut u8,
	                            txBufLen: u16,
	                            blockData: *const u8,
	                            rxBuf: *mut u8,
	                            rxBufLen: u16)
	                            -> ReturnCode;
}
extern "C" {
	#[doc = " \\brief NFC-F Listener is T3T Request"]
	#[doc = ""]
	#[doc = " This method checks if the given data is a valid T3T command (Read or Write)"]
	#[doc = " and in case a valid request has been received it may output the request's NFCID2"]
	#[doc = ""]
	#[doc = " \\param[in]   buf : buffer holding Initiator's received command"]
	#[doc = " \\param[in]   bufLen : length of received command in bytes"]
	#[doc = " \\param[out]  nfcid2 : pointer to where the NFCID2 may be outputed,"]
	#[doc = "                       nfcid2 has NFCF_SENSF_NFCID2_LEN as length"]
	#[doc = "                       Pass NULL if output parameter not desired"]
	#[doc = ""]
	#[doc = " \\return true  : Valid T3T command (Read or Write) received"]
	#[doc = " \\return false : Invalid protocol request"]
	#[doc = ""]
	#[doc = ""]
	pub fn rfalNfcfListenerIsT3TReq(buf: *const u8, bufLen: u16, nfcid2: *mut u8) -> bool;
}
#[repr(u32)]
#[non_exhaustive]
#[doc = " NFC-V Number of slots  Digital 2.0  9.6.1"]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum rfalNfcvNumSlots {
	#[doc = "< Number of slots: 1"]
	RFAL_NFCV_NUM_SLOTS_1 = 32,
	#[doc = "< Number of slots: 16"]
	RFAL_NFCV_NUM_SLOTS_16 = 0,
}
#[doc = " NFC-V INVENTORY_RES format   Digital 2.0  9.6.2"]
#[repr(C)]
pub struct rfalNfcvInventoryRes {
	#[doc = "< Response Flags"]
	pub RES_FLAG: u8,
	#[doc = "< Data Storage Format Identifier"]
	pub DSFID: u8,
	#[doc = "< NFC-V device UID"]
	pub UID: [u8; 8usize],
	#[doc = "< CRC"]
	pub crc: [u8; 2usize],
}
#[test]
fn bindgen_test_layout_rfalNfcvInventoryRes() {
	assert_eq!(
	           ::core::mem::size_of::<rfalNfcvInventoryRes>(),
	           12usize,
	           concat!("Size of: ", stringify!(rfalNfcvInventoryRes))
	);
	assert_eq!(
	           ::core::mem::align_of::<rfalNfcvInventoryRes>(),
	           1usize,
	           concat!("Alignment of ", stringify!(rfalNfcvInventoryRes))
	);
	fn test_field_RES_FLAG() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcvInventoryRes>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).RES_FLAG) as usize - ptr as usize
		           },
		           0usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalNfcvInventoryRes),
			"::",
			stringify!(RES_FLAG)
		)
		);
	}
	test_field_RES_FLAG();
	fn test_field_DSFID() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcvInventoryRes>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).DSFID) as usize - ptr as usize
		           },
		           1usize,
		           concat!("Offset of field: ", stringify!(rfalNfcvInventoryRes), "::", stringify!(DSFID))
		);
	}
	test_field_DSFID();
	fn test_field_UID() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcvInventoryRes>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).UID) as usize - ptr as usize
		           },
		           2usize,
		           concat!("Offset of field: ", stringify!(rfalNfcvInventoryRes), "::", stringify!(UID))
		);
	}
	test_field_UID();
	fn test_field_crc() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcvInventoryRes>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).crc) as usize - ptr as usize
		           },
		           10usize,
		           concat!("Offset of field: ", stringify!(rfalNfcvInventoryRes), "::", stringify!(crc))
		);
	}
	test_field_crc();
}
#[doc = " NFC-V listener device (VICC) struct"]
#[repr(C)]
pub struct rfalNfcvListenDevice {
	#[doc = "< INVENTORY_RES"]
	pub InvRes: rfalNfcvInventoryRes,
	#[doc = "< Device sleeping flag"]
	pub isSleep: bool,
}
#[test]
fn bindgen_test_layout_rfalNfcvListenDevice() {
	assert_eq!(
	           ::core::mem::size_of::<rfalNfcvListenDevice>(),
	           13usize,
	           concat!("Size of: ", stringify!(rfalNfcvListenDevice))
	);
	assert_eq!(
	           ::core::mem::align_of::<rfalNfcvListenDevice>(),
	           1usize,
	           concat!("Alignment of ", stringify!(rfalNfcvListenDevice))
	);
	fn test_field_InvRes() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcvListenDevice>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).InvRes) as usize - ptr as usize
		           },
		           0usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalNfcvListenDevice),
			"::",
			stringify!(InvRes)
		)
		);
	}
	test_field_InvRes();
	fn test_field_isSleep() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcvListenDevice>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).isSleep) as usize - ptr as usize
		           },
		           12usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalNfcvListenDevice),
			"::",
			stringify!(isSleep)
		)
		);
	}
	test_field_isSleep();
}
extern "C" {
	#[doc = " \\brief  Initialize NFC-V Poller mode"]
	#[doc = ""]
	#[doc = " This methods configures RFAL RF layer to perform as a"]
	#[doc = " NFC-F Poller/RW (ISO15693) including all default timings"]
	#[doc = ""]
	#[doc = " \\return ERR_WRONG_STATE  : RFAL not initialized or mode not set"]
	#[doc = " \\return ERR_PARAM        : Incorrect bitrate"]
	#[doc = " \\return ERR_NONE         : No error"]
	#[doc = ""]
	pub fn rfalNfcvPollerInitialize() -> ReturnCode;
}
extern "C" {
	#[doc = " \\brief  NFC-V Poller Check Presence"]
	#[doc = ""]
	#[doc = " This method checks if a NFC-V Listen device (VICC) is present on the field"]
	#[doc = " by sending an Inventory (INVENTORY_REQ)"]
	#[doc = ""]
	#[doc = " \\param[out] invRes : If received, the INVENTORY_RES"]
	#[doc = ""]
	#[doc = " \\return ERR_WRONG_STATE  : RFAL not initialized or incorrect mode"]
	#[doc = " \\return ERR_PARAM        : Invalid parameters"]
	#[doc = " \\return ERR_IO           : Generic internal error"]
	#[doc = " \\return ERR_TIMEOUT      : Timeout error, no listener device detectedd"]
	#[doc = " \\return ERR_NONE         : No error, one or more device in the field"]
	#[doc = ""]
	pub fn rfalNfcvPollerCheckPresence(invRes: *mut rfalNfcvInventoryRes) -> ReturnCode;
}
extern "C" {
	#[doc = " \\brief NFC-F Poller Poll"]
	#[doc = ""]
	#[doc = " This function sends to all VICCs in field the INVENTORY command with the"]
	#[doc = " given number of slots"]
	#[doc = ""]
	#[doc = " If more than one slot is used the following EOF need to be handled"]
	#[doc = " by the caller using rfalISO15693TransceiveEOFAnticollision()"]
	#[doc = ""]
	#[doc = " \\param[in]  nSlots  : Number of Slots to be sent (1 or 16)"]
	#[doc = " \\param[in]  maskLen : Number bits on the Mask value"]
	#[doc = " \\param[in]  maskVal : location of the Mask value"]
	#[doc = " \\param[out] invRes  : location to place the INVENTORY_RES"]
	#[doc = " \\param[out] rcvdLen : number of bits received (without collision)"]
	#[doc = ""]
	#[doc = " \\return ERR_WRONG_STATE  : RFAL not initialized or incorrect mode"]
	#[doc = " \\return ERR_PARAM        : Invalid parameters"]
	#[doc = " \\return ERR_IO           : Generic internal error"]
	#[doc = " \\return ERR_RF_COLLISION : Collision detected"]
	#[doc = " \\return ERR_CRC          : CRC error detected"]
	#[doc = " \\return ERR_PROTO        : Protocol error detected"]
	#[doc = " \\return ERR_NONE         : No error"]
	#[doc = ""]
	pub fn rfalNfcvPollerInventory(nSlots: rfalNfcvNumSlots,
	                               maskLen: u8,
	                               maskVal: *const u8,
	                               invRes: *mut rfalNfcvInventoryRes,
	                               rcvdLen: *mut u16)
	                               -> ReturnCode;
}
extern "C" {
	#[doc = " \\brief  NFC-V Poller Full Collision Resolution"]
	#[doc = ""]
	#[doc = " Performs a full Collision resolution as defined in Activity 2.0   9.3.7"]
	#[doc = " Once done, the devCnt will indicate how many (if any) devices have"]
	#[doc = " been identified and their details are contained on nfcvDevList"]
	#[doc = ""]
	#[doc = " \\param[in]  compMode     : compliance mode to be performed"]
	#[doc = " \\param[in]  devLimit     : device limit value, and size nfcaDevList"]
	#[doc = " \\param[out] nfcvDevList  : NFC-v listener devices list"]
	#[doc = " \\param[out] devCnt       : Devices found counter"]
	#[doc = ""]
	#[doc = " When compMode is set to ISO the function immediately goes to 16 slots improving"]
	#[doc = " chances to detect more than only one strong card."]
	#[doc = ""]
	#[doc = " \\return ERR_WRONG_STATE  : RFAL not initialized or mode not set"]
	#[doc = " \\return ERR_PARAM        : Invalid parameters"]
	#[doc = " \\return ERR_IO           : Generic internal error"]
	#[doc = " \\return ERR_NONE         : No error"]
	#[doc = ""]
	pub fn rfalNfcvPollerCollisionResolution(compMode: rfalComplianceMode,
	                                         devLimit: u8,
	                                         nfcvDevList: *mut rfalNfcvListenDevice,
	                                         devCnt: *mut u8)
	                                         -> ReturnCode;
}
extern "C" {
	#[doc = " \\brief  NFC-V Poller Full Collision Resolution With Sleep"]
	#[doc = ""]
	#[doc = " Performs a full Collision resolution which is different from Activity 2.0 9.3.7."]
	#[doc = " The implementation uses SLPV (StayQuiet) command to make sure all cards are found."]
	#[doc = " Once done, the devCnt will indicate how many (if any) devices have"]
	#[doc = " been identified and their details are contained on nfcvDevList"]
	#[doc = ""]
	#[doc = " \\param[in]  devLimit     : device limit value, and size nfcaDevList"]
	#[doc = " \\param[out] nfcvDevList  : NFC-v listener devices list"]
	#[doc = " \\param[out] devCnt       : Devices found counter"]
	#[doc = ""]
	#[doc = " \\return ERR_WRONG_STATE  : RFAL not initialized or mode not set"]
	#[doc = " \\return ERR_PARAM        : Invalid parameters"]
	#[doc = " \\return ERR_IO           : Generic internal error"]
	#[doc = " \\return ERR_NONE         : No error"]
	#[doc = ""]
	pub fn rfalNfcvPollerSleepCollisionResolution(devLimit: u8, nfcvDevList: *mut rfalNfcvListenDevice, devCnt: *mut u8)
	                                              -> ReturnCode;
}
extern "C" {
	#[doc = " \\brief  NFC-V Poller Sleep"]
	#[doc = ""]
	#[doc = " This function is used to send the SLPV_REQ (Stay Quiet) command to put the VICC"]
	#[doc = " with the given UID to state QUIET so that they do not reply to more Inventory"]
	#[doc = ""]
	#[doc = " \\param[in]  flags        : Flags to be used: Sub-carrier; Data_rate; Option"]
	#[doc = "                            for NFC-Forum use: RFAL_NFCV_REQ_FLAG_DEFAULT"]
	#[doc = " \\param[in]  uid          : UID of the device to be put to Sleep"]
	#[doc = ""]
	#[doc = " \\return ERR_WRONG_STATE  : RFAL not initialized or incorrect mode"]
	#[doc = " \\return ERR_PARAM        : Invalid parameters"]
	#[doc = " \\return ERR_IO           : Generic internal error"]
	#[doc = " \\return ERR_NONE         : No error"]
	#[doc = ""]
	pub fn rfalNfcvPollerSleep(flags: u8, uid: *const u8) -> ReturnCode;
}
extern "C" {
	#[doc = " \\brief  NFC-V Poller Select"]
	#[doc = ""]
	#[doc = " Selects a device (VICC) by its UID"]
	#[doc = ""]
	#[doc = " \\param[in]  flags        : Flags to be used: Sub-carrier; Data_rate; Option"]
	#[doc = "                            for NFC-Forum use: RFAL_NFCV_REQ_FLAG_DEFAULT"]
	#[doc = " \\param[in]  uid          : UID of the device to be put to be Selected"]
	#[doc = ""]
	#[doc = " \\return ERR_WRONG_STATE  : RFAL not initialized or incorrect mode"]
	#[doc = " \\return ERR_PARAM        : Invalid parameters"]
	#[doc = " \\return ERR_IO           : Generic internal error"]
	#[doc = " \\return ERR_CRC          : CRC error detected"]
	#[doc = " \\return ERR_FRAMING      : Framing error detected"]
	#[doc = " \\return ERR_PROTO        : Protocol error detected"]
	#[doc = " \\return ERR_TIMEOUT      : Timeout error"]
	#[doc = " \\return ERR_NONE         : No error"]
	#[doc = ""]
	pub fn rfalNfcvPollerSelect(flags: u8, uid: *const u8) -> ReturnCode;
}
extern "C" {
	#[doc = " \\brief  NFC-V Poller Read Single Block"]
	#[doc = ""]
	#[doc = " Reads a Single Block from a device (VICC)"]
	#[doc = ""]
	#[doc = " \\param[in]  flags        : Flags to be used: Sub-carrier; Data_rate; Option"]
	#[doc = "                            for NFC-Forum use: RFAL_NFCV_REQ_FLAG_DEFAULT"]
	#[doc = " \\param[in]  uid          : UID of the device to be put to be read"]
	#[doc = "                             if UID is provided Addressed mode will be used"]
	#[doc = " \\param[in]  blockNum     : Number of the block to read"]
	#[doc = " \\param[out] rxBuf        : buffer to store response (also with RES_FLAGS)"]
	#[doc = " \\param[in]  rxBufLen     : length of rxBuf"]
	#[doc = " \\param[out] rcvLen       : number of bytes received"]
	#[doc = ""]
	#[doc = " \\return ERR_WRONG_STATE  : RFAL not initialized or incorrect mode"]
	#[doc = " \\return ERR_PARAM        : Invalid parameters"]
	#[doc = " \\return ERR_IO           : Generic internal error"]
	#[doc = " \\return ERR_CRC          : CRC error detected"]
	#[doc = " \\return ERR_FRAMING      : Framing error detected"]
	#[doc = " \\return ERR_PROTO        : Protocol error detected"]
	#[doc = " \\return ERR_TIMEOUT      : Timeout error"]
	#[doc = " \\return ERR_NONE         : No error"]
	#[doc = ""]
	pub fn rfalNfcvPollerReadSingleBlock(flags: u8,
	                                     uid: *const u8,
	                                     blockNum: u8,
	                                     rxBuf: *mut u8,
	                                     rxBufLen: u16,
	                                     rcvLen: *mut u16)
	                                     -> ReturnCode;
}
extern "C" {
	#[doc = " \\brief  NFC-V Poller Write Single Block"]
	#[doc = ""]
	#[doc = " Writes a Single Block from a device (VICC)"]
	#[doc = ""]
	#[doc = " \\param[in]  flags        : Flags to be used: Sub-carrier; Data_rate; Option"]
	#[doc = "                            for NFC-Forum use: RFAL_NFCV_REQ_FLAG_DEFAULT"]
	#[doc = " \\param[in]  uid          : UID of the device to be put to be written"]
	#[doc = "                             if UID is provided Addressed mode will be used"]
	#[doc = " \\param[in]  blockNum     : Number of the block to write"]
	#[doc = " \\param[in]  wrData       : data to be written on the given block"]
	#[doc = " \\param[in]  blockLen     : number of bytes of a block"]
	#[doc = ""]
	#[doc = " \\return ERR_WRONG_STATE  : RFAL not initialized or incorrect mode"]
	#[doc = " \\return ERR_PARAM        : Invalid parameters"]
	#[doc = " \\return ERR_IO           : Generic internal error"]
	#[doc = " \\return ERR_CRC          : CRC error detected"]
	#[doc = " \\return ERR_FRAMING      : Framing error detected"]
	#[doc = " \\return ERR_PROTO        : Protocol error detected"]
	#[doc = " \\return ERR_TIMEOUT      : Timeout error"]
	#[doc = " \\return ERR_NONE         : No error"]
	#[doc = ""]
	pub fn rfalNfcvPollerWriteSingleBlock(flags: u8, uid: *const u8, blockNum: u8, wrData: *const u8, blockLen: u8) -> ReturnCode;
}
extern "C" {
	#[doc = " \\brief  NFC-V Poller Read Multiple Blocks"]
	#[doc = ""]
	#[doc = " Reads Multiple Blocks from a device (VICC)"]
	#[doc = ""]
	#[doc = " \\param[in]  flags          : Flags to be used: Sub-carrier; Data_rate; Option"]
	#[doc = "                              for NFC-Forum use: RFAL_NFCV_REQ_FLAG_DEFAULT"]
	#[doc = " \\param[in]  uid            : UID of the device to be put to be read"]
	#[doc = "                               if UID is provided Addressed mode will be used"]
	#[doc = " \\param[in]  firstBlockNum  : first block to be read"]
	#[doc = " \\param[in]  numOfBlocks    : number of block to read"]
	#[doc = " \\param[out] rxBuf          : buffer to store response (also with RES_FLAGS)"]
	#[doc = " \\param[in]  rxBufLen       : length of rxBuf"]
	#[doc = " \\param[out] rcvLen         : number of bytes received"]
	#[doc = ""]
	#[doc = " \\return ERR_WRONG_STATE    : RFAL not initialized or incorrect mode"]
	#[doc = " \\return ERR_PARAM          : Invalid parameters"]
	#[doc = " \\return ERR_IO             : Generic internal error"]
	#[doc = " \\return ERR_CRC            : CRC error detected"]
	#[doc = " \\return ERR_FRAMING        : Framing error detected"]
	#[doc = " \\return ERR_PROTO          : Protocol error detected"]
	#[doc = " \\return ERR_TIMEOUT        : Timeout error"]
	#[doc = " \\return ERR_NONE           : No error"]
	#[doc = ""]
	pub fn rfalNfcvPollerReadMultipleBlocks(flags: u8,
	                                        uid: *const u8,
	                                        firstBlockNum: u8,
	                                        numOfBlocks: u8,
	                                        rxBuf: *mut u8,
	                                        rxBufLen: u16,
	                                        rcvLen: *mut u16)
	                                        -> ReturnCode;
}
extern "C" {
	#[doc = " \\brief  NFC-V Poller Write Multiple Blocks"]
	#[doc = ""]
	#[doc = " Reads Multiple Blocks from a device (VICC)"]
	#[doc = " In order to not limit the length of the Write multiple command, a buffer"]
	#[doc = " must be provided where the request will be composed and then sent."]
	#[doc = ""]
	#[doc = " \\param[in]  flags          : Flags to be used: Sub-carrier; Data_rate; Option"]
	#[doc = "                              for NFC-Forum use: RFAL_NFCV_REQ_FLAG_DEFAULT"]
	#[doc = " \\param[in]  uid            : UID of the device to be put to be read"]
	#[doc = "                               if UID is provided Addressed mode will be used"]
	#[doc = " \\param[in]  firstBlockNum  : first block to be write"]
	#[doc = " \\param[in]  numOfBlocks    : number of consecutive blocks to write"]
	#[doc = " \\param[in]  txBuf          : buffer where the request will be composed"]
	#[doc = " \\param[in]  txBufLen       : length of txBuf"]
	#[doc = " \\param[in]  blockLen       : number of bytes of a block"]
	#[doc = " \\param[in]  wrData         : data to be written"]
	#[doc = " \\param[in]  wrDataLen      : length of the data do be written. Must be"]
	#[doc = "                              aligned with number of blocks to write and"]
	#[doc = "                              the size of a block"]
	#[doc = ""]
	#[doc = " \\return ERR_WRONG_STATE    : RFAL not initialized or incorrect mode"]
	#[doc = " \\return ERR_PARAM          : Invalid parameters"]
	#[doc = " \\return ERR_IO             : Generic internal error"]
	#[doc = " \\return ERR_CRC            : CRC error detected"]
	#[doc = " \\return ERR_FRAMING        : Framing error detected"]
	#[doc = " \\return ERR_PROTO          : Protocol error detected"]
	#[doc = " \\return ERR_TIMEOUT        : Timeout error"]
	#[doc = " \\return ERR_NONE           : No error"]
	#[doc = ""]
	pub fn rfalNfcvPollerWriteMultipleBlocks(flags: u8,
	                                         uid: *const u8,
	                                         firstBlockNum: u8,
	                                         numOfBlocks: u8,
	                                         txBuf: *mut u8,
	                                         txBufLen: u16,
	                                         blockLen: u8,
	                                         wrData: *const u8,
	                                         wrDataLen: u16)
	                                         -> ReturnCode;
}
extern "C" {
	#[doc = " \\brief  NFC-V Poller Extended Lock Single Block"]
	#[doc = ""]
	#[doc = " Blocks a Single Block from a device (VICC) supporting extended commands"]
	#[doc = ""]
	#[doc = " \\param[in]  flags        : Flags to be used: Sub-carrier; Data_rate; Option"]
	#[doc = "                            for NFC-Forum use: RFAL_NFCV_REQ_FLAG_DEFAULT"]
	#[doc = " \\param[in]  uid          : UID of the device"]
	#[doc = "                             if UID is provided Addressed mode will be used"]
	#[doc = " \\param[in]  blockNum     : Number of the block to be locked"]
	#[doc = ""]
	#[doc = " \\return ERR_WRONG_STATE  : RFAL not initialized or incorrect mode"]
	#[doc = " \\return ERR_PARAM        : Invalid parameters"]
	#[doc = " \\return ERR_IO           : Generic internal error"]
	#[doc = " \\return ERR_CRC          : CRC error detected"]
	#[doc = " \\return ERR_FRAMING      : Framing error detected"]
	#[doc = " \\return ERR_PROTO        : Protocol error detected"]
	#[doc = " \\return ERR_TIMEOUT      : Timeout error"]
	#[doc = " \\return ERR_NONE         : No error"]
	#[doc = ""]
	pub fn rfalNfcvPollerLockBlock(flags: u8, uid: *const u8, blockNum: u8) -> ReturnCode;
}
extern "C" {
	#[doc = " \\brief  NFC-V Poller Extended Lock Single Block"]
	#[doc = ""]
	#[doc = " Blocks a Single Block from a device (VICC) supporting extended commands"]
	#[doc = ""]
	#[doc = " \\param[in]  flags        : Flags to be used: Sub-carrier; Data_rate; Option"]
	#[doc = "                            for NFC-Forum use: RFAL_NFCV_REQ_FLAG_DEFAULT"]
	#[doc = " \\param[in]  uid          : UID of the device"]
	#[doc = "                             if UID is provided Addressed mode will be used"]
	#[doc = " \\param[in]  blockNum     : Number of the block to be locked (16 bits)"]
	#[doc = ""]
	#[doc = " \\return ERR_WRONG_STATE  : RFAL not initialized or incorrect mode"]
	#[doc = " \\return ERR_PARAM        : Invalid parameters"]
	#[doc = " \\return ERR_IO           : Generic internal error"]
	#[doc = " \\return ERR_CRC          : CRC error detected"]
	#[doc = " \\return ERR_FRAMING      : Framing error detected"]
	#[doc = " \\return ERR_PROTO        : Protocol error detected"]
	#[doc = " \\return ERR_TIMEOUT      : Timeout error"]
	#[doc = " \\return ERR_NONE         : No error"]
	#[doc = ""]
	pub fn rfalNfcvPollerExtendedLockSingleBlock(flags: u8, uid: *const u8, blockNum: u16) -> ReturnCode;
}
extern "C" {
	#[doc = " \\brief  NFC-V Poller Extended Read Single Block"]
	#[doc = ""]
	#[doc = " Reads a Single Block from a device (VICC) supporting extended commands"]
	#[doc = ""]
	#[doc = " \\param[in]  flags        : Flags to be used: Sub-carrier; Data_rate; Option"]
	#[doc = "                            for NFC-Forum use: RFAL_NFCV_REQ_FLAG_DEFAULT"]
	#[doc = " \\param[in]  uid          : UID of the device to be put to be read"]
	#[doc = "                             if UID is provided Addressed mode will be used"]
	#[doc = " \\param[in]  blockNum     : Number of the block to read (16 bits)"]
	#[doc = " \\param[out] rxBuf        : buffer to store response (also with RES_FLAGS)"]
	#[doc = " \\param[in]  rxBufLen     : length of rxBuf"]
	#[doc = " \\param[out] rcvLen       : number of bytes received"]
	#[doc = ""]
	#[doc = " \\return ERR_WRONG_STATE  : RFAL not initialized or incorrect mode"]
	#[doc = " \\return ERR_PARAM        : Invalid parameters"]
	#[doc = " \\return ERR_IO           : Generic internal error"]
	#[doc = " \\return ERR_CRC          : CRC error detected"]
	#[doc = " \\return ERR_FRAMING      : Framing error detected"]
	#[doc = " \\return ERR_PROTO        : Protocol error detected"]
	#[doc = " \\return ERR_TIMEOUT      : Timeout error"]
	#[doc = " \\return ERR_NONE         : No error"]
	#[doc = ""]
	pub fn rfalNfcvPollerExtendedReadSingleBlock(flags: u8,
	                                             uid: *const u8,
	                                             blockNum: u16,
	                                             rxBuf: *mut u8,
	                                             rxBufLen: u16,
	                                             rcvLen: *mut u16)
	                                             -> ReturnCode;
}
extern "C" {
	#[doc = " \\brief  NFC-V Poller Extended Write Single Block"]
	#[doc = ""]
	#[doc = " Writes a Single Block from a device (VICC) supporting extended commands"]
	#[doc = ""]
	#[doc = " \\param[in]  flags        : Flags to be used: Sub-carrier; Data_rate; Option"]
	#[doc = "                            for NFC-Forum use: RFAL_NFCV_REQ_FLAG_DEFAULT"]
	#[doc = " \\param[in]  uid          : UID of the device"]
	#[doc = "                             if UID is provided Addressed mode will be used"]
	#[doc = " \\param[in]  blockNum     : Number of the block to write (16 bits)"]
	#[doc = " \\param[in]  wrData       : data to be written on the given block"]
	#[doc = " \\param[in]  blockLen     : number of bytes of a block"]
	#[doc = ""]
	#[doc = " \\return ERR_WRONG_STATE  : RFAL not initialized or incorrect mode"]
	#[doc = " \\return ERR_PARAM        : Invalid parameters"]
	#[doc = " \\return ERR_IO           : Generic internal error"]
	#[doc = " \\return ERR_CRC          : CRC error detected"]
	#[doc = " \\return ERR_FRAMING      : Framing error detected"]
	#[doc = " \\return ERR_PROTO        : Protocol error detected"]
	#[doc = " \\return ERR_TIMEOUT      : Timeout error"]
	#[doc = " \\return ERR_NONE         : No error"]
	#[doc = ""]
	pub fn rfalNfcvPollerExtendedWriteSingleBlock(flags: u8,
	                                              uid: *const u8,
	                                              blockNum: u16,
	                                              wrData: *const u8,
	                                              blockLen: u8)
	                                              -> ReturnCode;
}
extern "C" {
	#[doc = " \\brief  NFC-V Poller Extended Read Multiple Blocks"]
	#[doc = ""]
	#[doc = " Reads Multiple Blocks from a device (VICC) supporting extended commands"]
	#[doc = ""]
	#[doc = " \\param[in]  flags          : Flags to be used: Sub-carrier; Data_rate; Option"]
	#[doc = "                              for NFC-Forum use: RFAL_NFCV_REQ_FLAG_DEFAULT"]
	#[doc = " \\param[in]  uid            : UID of the device to be put to be read"]
	#[doc = "                               if UID is provided Addressed mode will be used"]
	#[doc = " \\param[in]  firstBlockNum  : first block to be read (16 bits)"]
	#[doc = " \\param[in]  numOfBlocks    : number of consecutive blocks to read (16 bits)"]
	#[doc = " \\param[out] rxBuf          : buffer to store response (also with RES_FLAGS)"]
	#[doc = " \\param[in]  rxBufLen       : length of rxBuf"]
	#[doc = " \\param[out] rcvLen         : number of bytes received"]
	#[doc = ""]
	#[doc = " \\return ERR_WRONG_STATE    : RFAL not initialized or incorrect mode"]
	#[doc = " \\return ERR_PARAM          : Invalid parameters"]
	#[doc = " \\return ERR_IO             : Generic internal error"]
	#[doc = " \\return ERR_CRC            : CRC error detected"]
	#[doc = " \\return ERR_FRAMING        : Framing error detected"]
	#[doc = " \\return ERR_PROTO          : Protocol error detected"]
	#[doc = " \\return ERR_TIMEOUT        : Timeout error"]
	#[doc = " \\return ERR_NONE           : No error"]
	#[doc = ""]
	pub fn rfalNfcvPollerExtendedReadMultipleBlocks(flags: u8,
	                                                uid: *const u8,
	                                                firstBlockNum: u16,
	                                                numOfBlocks: u16,
	                                                rxBuf: *mut u8,
	                                                rxBufLen: u16,
	                                                rcvLen: *mut u16)
	                                                -> ReturnCode;
}
extern "C" {
	#[doc = " \\brief  NFC-V Poller Extended Write Multiple Blocks"]
	#[doc = ""]
	#[doc = " Writes Multiple Blocks from a device (VICC) supporting extended commands"]
	#[doc = " In order to not limit the length of the Write multiple command, a buffer"]
	#[doc = " must be provided where the request will be composed and then sent."]
	#[doc = ""]
	#[doc = " \\param[in]  flags          : Flags to be used: Sub-carrier; Data_rate; Option"]
	#[doc = "                              for NFC-Forum use: RFAL_NFCV_REQ_FLAG_DEFAULT"]
	#[doc = " \\param[in]  uid            : UID of the device to be put to be read"]
	#[doc = "                               if UID is provided Addressed mode will be used"]
	#[doc = " \\param[in]  firstBlockNum  : first block to be write (16 bits)"]
	#[doc = " \\param[in]  numOfBlocks    : number of consecutive blocks to write (16 bits)"]
	#[doc = " \\param[in]  txBuf          : buffer where the request will be composed"]
	#[doc = " \\param[in]  txBufLen       : length of txBuf"]
	#[doc = " \\param[in]  blockLen       : number of bytes of a block"]
	#[doc = " \\param[in]  wrData         : data to be written"]
	#[doc = " \\param[in]  wrDataLen      : length of the data do be written. Must be"]
	#[doc = "                              aligned with number of blocks to write and"]
	#[doc = "                              the size of a block"]
	#[doc = ""]
	#[doc = " \\return ERR_WRONG_STATE    : RFAL not initialized or incorrect mode"]
	#[doc = " \\return ERR_PARAM          : Invalid parameters"]
	#[doc = " \\return ERR_IO             : Generic internal error"]
	#[doc = " \\return ERR_CRC            : CRC error detected"]
	#[doc = " \\return ERR_FRAMING        : Framing error detected"]
	#[doc = " \\return ERR_PROTO          : Protocol error detected"]
	#[doc = " \\return ERR_TIMEOUT        : Timeout error"]
	#[doc = " \\return ERR_NONE           : No error"]
	#[doc = ""]
	pub fn rfalNfcvPollerExtendedWriteMultipleBlocks(flags: u8,
	                                                 uid: *const u8,
	                                                 firstBlockNum: u16,
	                                                 numOfBlocks: u16,
	                                                 txBuf: *mut u8,
	                                                 txBufLen: u16,
	                                                 blockLen: u8,
	                                                 wrData: *const u8,
	                                                 wrDataLen: u16)
	                                                 -> ReturnCode;
}
extern "C" {
	#[doc = " \\brief  NFC-V Get System Information"]
	#[doc = ""]
	#[doc = " Sends Get System Information command"]
	#[doc = ""]
	#[doc = " \\param[in]  flags          : Flags to be used: Sub-carrier; Data_rate; Option"]
	#[doc = "                              for NFC-Forum use: RFAL_NFCV_REQ_FLAG_DEFAULT"]
	#[doc = " \\param[in]  uid            : UID of the device to be put to be read"]
	#[doc = "                               if UID is provided Addressed mode will be used"]
	#[doc = " \\param[out] rxBuf          : buffer to store response (also with RES_FLAGS)"]
	#[doc = " \\param[in]  rxBufLen       : length of rxBuf"]
	#[doc = " \\param[out] rcvLen         : number of bytes received"]
	#[doc = ""]
	#[doc = " \\return ERR_WRONG_STATE    : RFAL not initialized or incorrect mode"]
	#[doc = " \\return ERR_PARAM          : Invalid parameters"]
	#[doc = " \\return ERR_IO             : Generic internal error"]
	#[doc = " \\return ERR_CRC            : CRC error detected"]
	#[doc = " \\return ERR_FRAMING        : Framing error detected"]
	#[doc = " \\return ERR_PROTO          : Protocol error detected"]
	#[doc = " \\return ERR_TIMEOUT        : Timeout error"]
	#[doc = " \\return ERR_NONE           : No error"]
	#[doc = ""]
	pub fn rfalNfcvPollerGetSystemInformation(flags: u8,
	                                          uid: *const u8,
	                                          rxBuf: *mut u8,
	                                          rxBufLen: u16,
	                                          rcvLen: *mut u16)
	                                          -> ReturnCode;
}
extern "C" {
	#[doc = " \\brief  NFC-V Extended Get System Information"]
	#[doc = ""]
	#[doc = " Sends Extended Get System Information command"]
	#[doc = ""]
	#[doc = " \\param[in]  flags          : Flags to be used: Sub-carrier; Data_rate; Option"]
	#[doc = "                              for NFC-Forum use: RFAL_NFCV_REQ_FLAG_DEFAULT"]
	#[doc = " \\param[in]  uid            : UID of the device to be put to be read"]
	#[doc = "                               if UID is provided Addressed mode will be used"]
	#[doc = " \\param[in]  requestField   : Get System info parameter request field"]
	#[doc = " \\param[out] rxBuf          : buffer to store response (also with RES_FLAGS)"]
	#[doc = " \\param[in]  rxBufLen       : length of rxBuf"]
	#[doc = " \\param[out] rcvLen         : number of bytes received"]
	#[doc = ""]
	#[doc = " \\return ERR_WRONG_STATE    : RFAL not initialized or incorrect mode"]
	#[doc = " \\return ERR_PARAM          : Invalid parameters"]
	#[doc = " \\return ERR_IO             : Generic internal error"]
	#[doc = " \\return ERR_CRC            : CRC error detected"]
	#[doc = " \\return ERR_FRAMING        : Framing error detected"]
	#[doc = " \\return ERR_PROTO          : Protocol error detected"]
	#[doc = " \\return ERR_TIMEOUT        : Timeout error"]
	#[doc = " \\return ERR_NONE           : No error"]
	#[doc = ""]
	pub fn rfalNfcvPollerExtendedGetSystemInformation(flags: u8,
	                                                  uid: *const u8,
	                                                  requestField: u8,
	                                                  rxBuf: *mut u8,
	                                                  rxBufLen: u16,
	                                                  rcvLen: *mut u16)
	                                                  -> ReturnCode;
}
extern "C" {
	#[doc = " \\brief  NFC-V Transceive Request"]
	#[doc = ""]
	#[doc = " Performs a generic transceive with an ISO15693 tag"]
	#[doc = ""]
	#[doc = " \\param[in]  cmd            : NFC-V command"]
	#[doc = " \\param[in]  flags          : Flags to be used: Sub-carrier; Data_rate; Option"]
	#[doc = "                              for NFC-Forum use: RFAL_NFCV_REQ_FLAG_DEFAULT"]
	#[doc = " \\param[in]  param          : Prepend parameter on certain proprietary requests"]
	#[doc = "                              For default commands skip: RFAL_NFCV_PARAM_SKIP"]
	#[doc = " \\param[in]  uid            : UID of the device to be put to be read"]
	#[doc = "                               if UID is provided Addressed mode will be used"]
	#[doc = " \\param[in]  data           : command parameters append after UID"]
	#[doc = " \\param[in]  dataLen        : command parameters Len"]
	#[doc = " \\param[out] rxBuf          : buffer to store response (also with RES_FLAGS)"]
	#[doc = " \\param[in]  rxBufLen       : length of rxBuf"]
	#[doc = " \\param[out] rcvLen         : number of bytes received"]
	#[doc = ""]
	#[doc = " \\return ERR_WRONG_STATE    : RFAL not initialized or incorrect mode"]
	#[doc = " \\return ERR_PARAM          : Invalid parameters"]
	#[doc = " \\return ERR_IO             : Generic internal error"]
	#[doc = " \\return ERR_CRC            : CRC error detected"]
	#[doc = " \\return ERR_FRAMING        : Framing error detected"]
	#[doc = " \\return ERR_PROTO          : Protocol error detected"]
	#[doc = " \\return ERR_TIMEOUT        : Timeout error"]
	#[doc = " \\return ERR_NONE           : No error"]
	#[doc = ""]
	pub fn rfalNfcvPollerTransceiveReq(cmd: u8,
	                                   flags: u8,
	                                   param: u8,
	                                   uid: *const u8,
	                                   data: *const u8,
	                                   dataLen: u16,
	                                   rxBuf: *mut u8,
	                                   rxBufLen: u16,
	                                   rcvLen: *mut u16)
	                                   -> ReturnCode;
}
pub type rfalSt25tbUID = [u8; 8usize];
pub type rfalSt25tbBlock = [u8; 4usize];
#[doc = " ST25TB listener device (PICC) struct"]
#[repr(C)]
pub struct rfalSt25tbListenDevice {
	#[doc = "< Device's session Chip ID"]
	pub chipID: u8,
	#[doc = "< Device's UID"]
	pub UID: rfalSt25tbUID,
	#[doc = "< Device deselect flag"]
	pub isDeselected: bool,
}
#[test]
fn bindgen_test_layout_rfalSt25tbListenDevice() {
	assert_eq!(
	           ::core::mem::size_of::<rfalSt25tbListenDevice>(),
	           10usize,
	           concat!("Size of: ", stringify!(rfalSt25tbListenDevice))
	);
	assert_eq!(
	           ::core::mem::align_of::<rfalSt25tbListenDevice>(),
	           1usize,
	           concat!("Alignment of ", stringify!(rfalSt25tbListenDevice))
	);
	fn test_field_chipID() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalSt25tbListenDevice>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).chipID) as usize - ptr as usize
		           },
		           0usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalSt25tbListenDevice),
			"::",
			stringify!(chipID)
		)
		);
	}
	test_field_chipID();
	fn test_field_UID() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalSt25tbListenDevice>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).UID) as usize - ptr as usize
		           },
		           1usize,
		           concat!("Offset of field: ", stringify!(rfalSt25tbListenDevice), "::", stringify!(UID))
		);
	}
	test_field_UID();
	fn test_field_isDeselected() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalSt25tbListenDevice>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).isDeselected) as usize - ptr as usize
		           },
		           9usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalSt25tbListenDevice),
			"::",
			stringify!(isDeselected)
		)
		);
	}
	test_field_isDeselected();
}
extern "C" {
	#[doc = " \\brief  Initialize ST25TB Poller mode"]
	#[doc = ""]
	#[doc = " This methods configures RFAL RF layer to perform as a"]
	#[doc = " ST25TB Poller/RW including all default timings"]
	#[doc = ""]
	#[doc = " \\return ERR_WRONG_STATE  : RFAL not initialized or mode not set"]
	#[doc = " \\return ERR_NONE         : No error"]
	#[doc = ""]
	pub fn rfalSt25tbPollerInitialize() -> ReturnCode;
}
extern "C" {
	#[doc = " \\brief  ST25TB Poller Check Presence"]
	#[doc = ""]
	#[doc = " This method checks if a ST25TB Listen device (PICC) is present on the field"]
	#[doc = " by sending an Initiate command"]
	#[doc = ""]
	#[doc = " \\param[out] chipId : if successfully retrieved, the device's chip ID"]
	#[doc = ""]
	#[doc = " \\return ERR_WRONG_STATE  : RFAL not initialized or incorrect mode"]
	#[doc = " \\return ERR_PARAM        : Invalid parameters"]
	#[doc = " \\return ERR_IO           : Generic internal error"]
	#[doc = " \\return ERR_TIMEOUT      : Timeout error, no listener device detected"]
	#[doc = " \\return ERR_RF_COLLISION : Collision detected one or more device in the field"]
	#[doc = " \\return ERR_PROTO        : Protocol error detected"]
	#[doc = " \\return ERR_NONE         : No error"]
	#[doc = ""]
	pub fn rfalSt25tbPollerCheckPresence(chipId: *mut u8) -> ReturnCode;
}
extern "C" {
	#[doc = " \\brief  ST25TB Poller Collision Resolution"]
	#[doc = ""]
	#[doc = " This method performs ST25TB Collision resolution, selects the each device,"]
	#[doc = " retrieves its UID and then deselects."]
	#[doc = " In case only one device is identified the ST25TB device is left in select"]
	#[doc = " state."]
	#[doc = ""]
	#[doc = " \\param[in]  devLimit      : device limit value, and size st25tbDevList"]
	#[doc = " \\param[out] st25tbDevList : ST35TB listener device info"]
	#[doc = " \\param[out] devCnt        : Devices found counter"]
	#[doc = ""]
	#[doc = " \\return ERR_WRONG_STATE  : RFAL not initialized or incorrect mode"]
	#[doc = " \\return ERR_PARAM        : Invalid parameters"]
	#[doc = " \\return ERR_IO           : Generic internal error"]
	#[doc = " \\return ERR_TIMEOUT      : Timeout error, no listener device detected"]
	#[doc = " \\return ERR_RF_COLLISION : Collision detected one or more device in the field"]
	#[doc = " \\return ERR_PROTO        : Protocol error detected"]
	#[doc = " \\return ERR_NONE         : No error"]
	#[doc = ""]
	pub fn rfalSt25tbPollerCollisionResolution(devLimit: u8,
	                                           st25tbDevList: *mut rfalSt25tbListenDevice,
	                                           devCnt: *mut u8)
	                                           -> ReturnCode;
}
extern "C" {
	#[doc = " \\brief  ST25TB Poller Initiate"]
	#[doc = ""]
	#[doc = " This method sends an Initiate command"]
	#[doc = ""]
	#[doc = " If a single device responds the chip ID will be retrieved"]
	#[doc = ""]
	#[doc = " \\param[out]  chipId      : chip ID of the device"]
	#[doc = ""]
	#[doc = " \\return ERR_WRONG_STATE  : RFAL not initialized or incorrect mode"]
	#[doc = " \\return ERR_PARAM        : Invalid parameters"]
	#[doc = " \\return ERR_IO           : Generic internal error"]
	#[doc = " \\return ERR_TIMEOUT      : Timeout error, no listener device detected"]
	#[doc = " \\return ERR_PROTO        : Protocol error detected"]
	#[doc = " \\return ERR_NONE         : No error"]
	#[doc = ""]
	pub fn rfalSt25tbPollerInitiate(chipId: *mut u8) -> ReturnCode;
}
extern "C" {
	#[doc = " \\brief  ST25TB Poller Pcall"]
	#[doc = ""]
	#[doc = " This method sends a Pcall command"]
	#[doc = " If successful the device's chip ID will be retrieved"]
	#[doc = ""]
	#[doc = " \\param[out]  chipId      : Chip ID of the device"]
	#[doc = ""]
	#[doc = " \\return ERR_WRONG_STATE  : RFAL not initialized or incorrect mode"]
	#[doc = " \\return ERR_PARAM        : Invalid parameters"]
	#[doc = " \\return ERR_IO           : Generic internal error"]
	#[doc = " \\return ERR_TIMEOUT      : Timeout error, no listener device detected"]
	#[doc = " \\return ERR_PROTO        : Protocol error detected"]
	#[doc = " \\return ERR_NONE         : No error"]
	#[doc = ""]
	pub fn rfalSt25tbPollerPcall(chipId: *mut u8) -> ReturnCode;
}
extern "C" {
	#[doc = " \\brief  ST25TB Poller Slot Marker"]
	#[doc = ""]
	#[doc = " This method sends a Slot Marker"]
	#[doc = ""]
	#[doc = " If a single device responds the chip ID will be retrieved"]
	#[doc = ""]
	#[doc = " \\param[in]  slotNum      : Slot Number"]
	#[doc = " \\param[out]  chipIdRes   : Chip ID of the device"]
	#[doc = ""]
	#[doc = " \\return ERR_WRONG_STATE  : RFAL not initialized or incorrect mode"]
	#[doc = " \\return ERR_PARAM        : Invalid parameters"]
	#[doc = " \\return ERR_IO           : Generic internal error"]
	#[doc = " \\return ERR_TIMEOUT      : Timeout error, no listener device detected"]
	#[doc = " \\return ERR_PROTO        : Protocol error detected"]
	#[doc = " \\return ERR_NONE         : No error"]
	#[doc = ""]
	pub fn rfalSt25tbPollerSlotMarker(slotNum: u8, chipIdRes: *mut u8) -> ReturnCode;
}
extern "C" {
	#[doc = " \\brief  ST25TB Poller Select"]
	#[doc = ""]
	#[doc = " This method sends a ST25TB Select command with the given chip ID."]
	#[doc = ""]
	#[doc = " If the device is already in Selected state and receives an incorrect chip"]
	#[doc = " ID, it goes into Deselected state"]
	#[doc = ""]
	#[doc = " \\param[in]  chipId       : chip ID of the device to be selected"]
	#[doc = ""]
	#[doc = " \\return ERR_WRONG_STATE  : RFAL not initialized or incorrect mode"]
	#[doc = " \\return ERR_PARAM        : Invalid parameters"]
	#[doc = " \\return ERR_IO           : Generic internal error"]
	#[doc = " \\return ERR_TIMEOUT      : Timeout error, no listener device detected"]
	#[doc = " \\return ERR_PROTO        : Protocol error detected"]
	#[doc = " \\return ERR_NONE         : No error"]
	#[doc = ""]
	pub fn rfalSt25tbPollerSelect(chipId: u8) -> ReturnCode;
}
extern "C" {
	#[doc = " \\brief  ST25TB Get UID"]
	#[doc = ""]
	#[doc = " This method sends a Get_UID command"]
	#[doc = ""]
	#[doc = " If a single device responds the chip UID will be retrieved"]
	#[doc = ""]
	#[doc = " \\param[out]  UID      : UID of the found device"]
	#[doc = ""]
	#[doc = " \\return ERR_WRONG_STATE  : RFAL not initialized or incorrect mode"]
	#[doc = " \\return ERR_PARAM        : Invalid parameters"]
	#[doc = " \\return ERR_IO           : Generic internal error"]
	#[doc = " \\return ERR_TIMEOUT      : Timeout error, no listener device detected"]
	#[doc = " \\return ERR_PROTO        : Protocol error detected"]
	#[doc = " \\return ERR_NONE         : No error"]
	#[doc = ""]
	pub fn rfalSt25tbPollerGetUID(UID: *mut rfalSt25tbUID) -> ReturnCode;
}
extern "C" {
	#[doc = " \\brief  ST25TB Poller Read Block"]
	#[doc = ""]
	#[doc = " This method reads a block of the ST25TB"]
	#[doc = ""]
	#[doc = " \\param[in]   blockAddress : address of the block to be read"]
	#[doc = " \\param[out]  blockData    : location to place the data read from block"]
	#[doc = ""]
	#[doc = " \\return ERR_WRONG_STATE  : RFAL not initialized or incorrect mode"]
	#[doc = " \\return ERR_PARAM        : Invalid parameters"]
	#[doc = " \\return ERR_IO           : Generic internal error"]
	#[doc = " \\return ERR_TIMEOUT      : Timeout error, no listener device detected"]
	#[doc = " \\return ERR_PROTO        : Protocol error detected"]
	#[doc = " \\return ERR_NONE         : No error"]
	#[doc = ""]
	pub fn rfalSt25tbPollerReadBlock(blockAddress: u8, blockData: *mut rfalSt25tbBlock) -> ReturnCode;
}
extern "C" {
	#[doc = " \\brief  ST25TB Poller Write Block"]
	#[doc = ""]
	#[doc = " This method writes a block of the ST25TB"]
	#[doc = ""]
	#[doc = " \\param[in]  blockAddress : address of the block to be written"]
	#[doc = " \\param[in]  blockData    : data to be written on the block"]
	#[doc = ""]
	#[doc = " \\return ERR_WRONG_STATE  : RFAL not initialized or incorrect mode"]
	#[doc = " \\return ERR_PARAM        : Invalid parameters"]
	#[doc = " \\return ERR_IO           : Generic internal error"]
	#[doc = " \\return ERR_TIMEOUT      : Timeout error, no listener device detected"]
	#[doc = " \\return ERR_PROTO        : Protocol error detected"]
	#[doc = " \\return ERR_NONE         : No error"]
	#[doc = ""]
	pub fn rfalSt25tbPollerWriteBlock(blockAddress: u8, blockData: *const rfalSt25tbBlock) -> ReturnCode;
}
extern "C" {
	#[doc = " \\brief  ST25TB Poller Completion"]
	#[doc = ""]
	#[doc = " This method sends a completion command to the ST25TB. After the"]
	#[doc = " completion the card no longer will reply to any command."]
	#[doc = ""]
	#[doc = " \\return ERR_WRONG_STATE  : RFAL not initialized or incorrect mode"]
	#[doc = " \\return ERR_PARAM        : Invalid parameters"]
	#[doc = " \\return ERR_IO           : Generic internal error"]
	#[doc = " \\return ERR_TIMEOUT      : Timeout error, no listener device detected"]
	#[doc = " \\return ERR_PROTO        : Protocol error detected, invalid SENSB_RES received"]
	#[doc = " \\return ERR_NONE         : No error"]
	#[doc = ""]
	pub fn rfalSt25tbPollerCompletion() -> ReturnCode;
}
extern "C" {
	#[doc = " \\brief  ST25TB Poller Reset to Inventory"]
	#[doc = ""]
	#[doc = " This method sends a Reset to Inventory command to the ST25TB."]
	#[doc = ""]
	#[doc = " \\return ERR_WRONG_STATE  : RFAL not initialized or incorrect mode"]
	#[doc = " \\return ERR_PARAM        : Invalid parameters"]
	#[doc = " \\return ERR_IO           : Generic internal error"]
	#[doc = " \\return ERR_TIMEOUT      : Timeout error, no listener device detected"]
	#[doc = " \\return ERR_PROTO        : Protocol error detected, invalid SENSB_RES received"]
	#[doc = " \\return ERR_NONE         : No error"]
	#[doc = ""]
	pub fn rfalSt25tbPollerResetToInventory() -> ReturnCode;
}
#[doc = " NFC-DEP callback to check if upper layer has deactivation pending"]
pub type rfalNfcDepDeactCallback = ::core::option::Option<unsafe extern "C" fn() -> bool>;
#[repr(u32)]
#[non_exhaustive]
#[doc = " Enumeration of the nfcip communication modes"]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum rfalNfcDepCommMode {
	#[doc = "< Passive communication mode"]
	RFAL_NFCDEP_COMM_PASSIVE = 0,
	#[doc = "< Active communication mode"]
	RFAL_NFCDEP_COMM_ACTIVE = 1,
}
#[doc = " ATR_REQ command    Digital 1.1 16.6.2"]
#[repr(C)]
pub struct rfalNfcDepAtrReq {
	#[doc = "< Command format 0xD4"]
	pub CMD1: u8,
	#[doc = "< Command Value"]
	pub CMD2: u8,
	#[doc = "< NFCID3 value"]
	pub NFCID3: [u8; 10usize],
	#[doc = "< DID"]
	pub DID: u8,
	#[doc = "< Sending Bitrate for Initiator"]
	pub BSi: u8,
	#[doc = "< Receiving Bitrate for Initiator"]
	pub BRi: u8,
	#[doc = "< Optional Parameters presence indicator"]
	pub PPi: u8,
	#[doc = "< General Bytes"]
	pub GBi: [u8; 48usize],
}
#[test]
fn bindgen_test_layout_rfalNfcDepAtrReq() {
	assert_eq!(
	           ::core::mem::size_of::<rfalNfcDepAtrReq>(),
	           64usize,
	           concat!("Size of: ", stringify!(rfalNfcDepAtrReq))
	);
	assert_eq!(
	           ::core::mem::align_of::<rfalNfcDepAtrReq>(),
	           1usize,
	           concat!("Alignment of ", stringify!(rfalNfcDepAtrReq))
	);
	fn test_field_CMD1() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcDepAtrReq>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).CMD1) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(rfalNfcDepAtrReq), "::", stringify!(CMD1))
		);
	}
	test_field_CMD1();
	fn test_field_CMD2() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcDepAtrReq>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).CMD2) as usize - ptr as usize
		           },
		           1usize,
		           concat!("Offset of field: ", stringify!(rfalNfcDepAtrReq), "::", stringify!(CMD2))
		);
	}
	test_field_CMD2();
	fn test_field_NFCID3() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcDepAtrReq>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).NFCID3) as usize - ptr as usize
		           },
		           2usize,
		           concat!("Offset of field: ", stringify!(rfalNfcDepAtrReq), "::", stringify!(NFCID3))
		);
	}
	test_field_NFCID3();
	fn test_field_DID() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcDepAtrReq>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).DID) as usize - ptr as usize
		           },
		           12usize,
		           concat!("Offset of field: ", stringify!(rfalNfcDepAtrReq), "::", stringify!(DID))
		);
	}
	test_field_DID();
	fn test_field_BSi() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcDepAtrReq>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).BSi) as usize - ptr as usize
		           },
		           13usize,
		           concat!("Offset of field: ", stringify!(rfalNfcDepAtrReq), "::", stringify!(BSi))
		);
	}
	test_field_BSi();
	fn test_field_BRi() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcDepAtrReq>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).BRi) as usize - ptr as usize
		           },
		           14usize,
		           concat!("Offset of field: ", stringify!(rfalNfcDepAtrReq), "::", stringify!(BRi))
		);
	}
	test_field_BRi();
	fn test_field_PPi() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcDepAtrReq>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).PPi) as usize - ptr as usize
		           },
		           15usize,
		           concat!("Offset of field: ", stringify!(rfalNfcDepAtrReq), "::", stringify!(PPi))
		);
	}
	test_field_PPi();
	fn test_field_GBi() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcDepAtrReq>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).GBi) as usize - ptr as usize
		           },
		           16usize,
		           concat!("Offset of field: ", stringify!(rfalNfcDepAtrReq), "::", stringify!(GBi))
		);
	}
	test_field_GBi();
}
#[doc = " ATR_RES response    Digital 1.1 16.6.3"]
#[repr(C)]
pub struct rfalNfcDepAtrRes {
	#[doc = "< Response Byte 0xD5"]
	pub CMD1: u8,
	#[doc = "< Command Value"]
	pub CMD2: u8,
	#[doc = "< NFCID3 value"]
	pub NFCID3: [u8; 10usize],
	#[doc = "< DID"]
	pub DID: u8,
	#[doc = "< Sending Bitrate for Initiator"]
	pub BSt: u8,
	#[doc = "< Receiving Bitrate for Initiator"]
	pub BRt: u8,
	#[doc = "< Timeout"]
	pub TO: u8,
	#[doc = "< Optional Parameters presence indicator"]
	pub PPt: u8,
	#[doc = "< General Bytes"]
	pub GBt: [u8; 48usize],
}
#[test]
fn bindgen_test_layout_rfalNfcDepAtrRes() {
	assert_eq!(
	           ::core::mem::size_of::<rfalNfcDepAtrRes>(),
	           65usize,
	           concat!("Size of: ", stringify!(rfalNfcDepAtrRes))
	);
	assert_eq!(
	           ::core::mem::align_of::<rfalNfcDepAtrRes>(),
	           1usize,
	           concat!("Alignment of ", stringify!(rfalNfcDepAtrRes))
	);
	fn test_field_CMD1() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcDepAtrRes>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).CMD1) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(rfalNfcDepAtrRes), "::", stringify!(CMD1))
		);
	}
	test_field_CMD1();
	fn test_field_CMD2() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcDepAtrRes>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).CMD2) as usize - ptr as usize
		           },
		           1usize,
		           concat!("Offset of field: ", stringify!(rfalNfcDepAtrRes), "::", stringify!(CMD2))
		);
	}
	test_field_CMD2();
	fn test_field_NFCID3() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcDepAtrRes>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).NFCID3) as usize - ptr as usize
		           },
		           2usize,
		           concat!("Offset of field: ", stringify!(rfalNfcDepAtrRes), "::", stringify!(NFCID3))
		);
	}
	test_field_NFCID3();
	fn test_field_DID() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcDepAtrRes>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).DID) as usize - ptr as usize
		           },
		           12usize,
		           concat!("Offset of field: ", stringify!(rfalNfcDepAtrRes), "::", stringify!(DID))
		);
	}
	test_field_DID();
	fn test_field_BSt() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcDepAtrRes>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).BSt) as usize - ptr as usize
		           },
		           13usize,
		           concat!("Offset of field: ", stringify!(rfalNfcDepAtrRes), "::", stringify!(BSt))
		);
	}
	test_field_BSt();
	fn test_field_BRt() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcDepAtrRes>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).BRt) as usize - ptr as usize
		           },
		           14usize,
		           concat!("Offset of field: ", stringify!(rfalNfcDepAtrRes), "::", stringify!(BRt))
		);
	}
	test_field_BRt();
	fn test_field_TO() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcDepAtrRes>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).TO) as usize - ptr as usize
		           },
		           15usize,
		           concat!("Offset of field: ", stringify!(rfalNfcDepAtrRes), "::", stringify!(TO))
		);
	}
	test_field_TO();
	fn test_field_PPt() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcDepAtrRes>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).PPt) as usize - ptr as usize
		           },
		           16usize,
		           concat!("Offset of field: ", stringify!(rfalNfcDepAtrRes), "::", stringify!(PPt))
		);
	}
	test_field_PPt();
	fn test_field_GBt() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcDepAtrRes>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).GBt) as usize - ptr as usize
		           },
		           17usize,
		           concat!("Offset of field: ", stringify!(rfalNfcDepAtrRes), "::", stringify!(GBt))
		);
	}
	test_field_GBt();
}
#[doc = " Structure of transmit I-PDU Buffer format from caller"]
#[repr(C)]
pub struct rfalNfcDepBufFormat {
	#[doc = "< Prologue space for NFC-DEP header"]
	pub prologue: [u8; 5usize],
	#[doc = "< INF | Data area of the buffer"]
	pub inf: [u8; 254usize],
}
#[test]
fn bindgen_test_layout_rfalNfcDepBufFormat() {
	assert_eq!(
	           ::core::mem::size_of::<rfalNfcDepBufFormat>(),
	           259usize,
	           concat!("Size of: ", stringify!(rfalNfcDepBufFormat))
	);
	assert_eq!(
	           ::core::mem::align_of::<rfalNfcDepBufFormat>(),
	           1usize,
	           concat!("Alignment of ", stringify!(rfalNfcDepBufFormat))
	);
	fn test_field_prologue() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcDepBufFormat>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).prologue) as usize - ptr as usize
		           },
		           0usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalNfcDepBufFormat),
			"::",
			stringify!(prologue)
		)
		);
	}
	test_field_prologue();
	fn test_field_inf() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcDepBufFormat>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).inf) as usize - ptr as usize
		           },
		           5usize,
		           concat!("Offset of field: ", stringify!(rfalNfcDepBufFormat), "::", stringify!(inf))
		);
	}
	test_field_inf();
}
#[doc = " Structure of APDU Buffer format from caller"]
#[repr(C)]
pub struct rfalNfcDepPduBufFormat {
	#[doc = "< Prologue/SoD buffer"]
	pub prologue: [u8; 5usize],
	#[doc = "< Complete PDU/Payload buffer"]
	pub pdu: [u8; 512usize],
}
#[test]
fn bindgen_test_layout_rfalNfcDepPduBufFormat() {
	assert_eq!(
	           ::core::mem::size_of::<rfalNfcDepPduBufFormat>(),
	           517usize,
	           concat!("Size of: ", stringify!(rfalNfcDepPduBufFormat))
	);
	assert_eq!(
	           ::core::mem::align_of::<rfalNfcDepPduBufFormat>(),
	           1usize,
	           concat!("Alignment of ", stringify!(rfalNfcDepPduBufFormat))
	);
	fn test_field_prologue() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcDepPduBufFormat>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).prologue) as usize - ptr as usize
		           },
		           0usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalNfcDepPduBufFormat),
			"::",
			stringify!(prologue)
		)
		);
	}
	test_field_prologue();
	fn test_field_pdu() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcDepPduBufFormat>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).pdu) as usize - ptr as usize
		           },
		           5usize,
		           concat!("Offset of field: ", stringify!(rfalNfcDepPduBufFormat), "::", stringify!(pdu))
		);
	}
	test_field_pdu();
}
#[doc = " Activation info as Initiator and Target"]
#[repr(C)]
pub struct rfalNfcDepActivation {
	#[doc = "< Target"]
	pub Target: __BindgenUnionField<rfalNfcDepActivation__bindgen_ty_1>,
	#[doc = "< Initiator"]
	pub Initiator: __BindgenUnionField<rfalNfcDepActivation__bindgen_ty_2>,
	pub bindgen_union_field: [u8; 66usize],
}
#[repr(C)]
pub struct rfalNfcDepActivation__bindgen_ty_1 {
	#[doc = "< ATR RES            (Initiator mode)"]
	pub ATR_RES: rfalNfcDepAtrRes,
	#[doc = "< ATR RES length     (Initiator mode)"]
	pub ATR_RESLen: u8,
}
#[test]
fn bindgen_test_layout_rfalNfcDepActivation__bindgen_ty_1() {
	assert_eq!(
	           ::core::mem::size_of::<rfalNfcDepActivation__bindgen_ty_1>(),
	           66usize,
	           concat!("Size of: ", stringify!(rfalNfcDepActivation__bindgen_ty_1))
	);
	assert_eq!(
	           ::core::mem::align_of::<rfalNfcDepActivation__bindgen_ty_1>(),
	           1usize,
	           concat!("Alignment of ", stringify!(rfalNfcDepActivation__bindgen_ty_1))
	);
	fn test_field_ATR_RES() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcDepActivation__bindgen_ty_1>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).ATR_RES) as usize - ptr as usize
		           },
		           0usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalNfcDepActivation__bindgen_ty_1),
			"::",
			stringify!(ATR_RES)
		)
		);
	}
	test_field_ATR_RES();
	fn test_field_ATR_RESLen() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcDepActivation__bindgen_ty_1>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).ATR_RESLen) as usize - ptr as usize
		           },
		           65usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalNfcDepActivation__bindgen_ty_1),
			"::",
			stringify!(ATR_RESLen)
		)
		);
	}
	test_field_ATR_RESLen();
}
#[repr(C)]
pub struct rfalNfcDepActivation__bindgen_ty_2 {
	#[doc = "< ATR REQ            (Target mode)"]
	pub ATR_REQ: rfalNfcDepAtrReq,
	#[doc = "< ATR REQ length     (Target mode)"]
	pub ATR_REQLen: u8,
}
#[test]
fn bindgen_test_layout_rfalNfcDepActivation__bindgen_ty_2() {
	assert_eq!(
	           ::core::mem::size_of::<rfalNfcDepActivation__bindgen_ty_2>(),
	           65usize,
	           concat!("Size of: ", stringify!(rfalNfcDepActivation__bindgen_ty_2))
	);
	assert_eq!(
	           ::core::mem::align_of::<rfalNfcDepActivation__bindgen_ty_2>(),
	           1usize,
	           concat!("Alignment of ", stringify!(rfalNfcDepActivation__bindgen_ty_2))
	);
	fn test_field_ATR_REQ() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcDepActivation__bindgen_ty_2>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).ATR_REQ) as usize - ptr as usize
		           },
		           0usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalNfcDepActivation__bindgen_ty_2),
			"::",
			stringify!(ATR_REQ)
		)
		);
	}
	test_field_ATR_REQ();
	fn test_field_ATR_REQLen() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcDepActivation__bindgen_ty_2>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).ATR_REQLen) as usize - ptr as usize
		           },
		           64usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalNfcDepActivation__bindgen_ty_2),
			"::",
			stringify!(ATR_REQLen)
		)
		);
	}
	test_field_ATR_REQLen();
}
#[test]
fn bindgen_test_layout_rfalNfcDepActivation() {
	assert_eq!(
	           ::core::mem::size_of::<rfalNfcDepActivation>(),
	           66usize,
	           concat!("Size of: ", stringify!(rfalNfcDepActivation))
	);
	assert_eq!(
	           ::core::mem::align_of::<rfalNfcDepActivation>(),
	           1usize,
	           concat!("Alignment of ", stringify!(rfalNfcDepActivation))
	);
	fn test_field_Target() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcDepActivation>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).Target) as usize - ptr as usize
		           },
		           0usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalNfcDepActivation),
			"::",
			stringify!(Target)
		)
		);
	}
	test_field_Target();
	fn test_field_Initiator() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcDepActivation>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).Initiator) as usize - ptr as usize
		           },
		           0usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalNfcDepActivation),
			"::",
			stringify!(Initiator)
		)
		);
	}
	test_field_Initiator();
}
#[doc = " NFC-DEP device Info"]
#[repr(C)]
pub struct rfalNfcDepInfo {
	#[doc = "< General Bytes length"]
	pub GBLen: u8,
	#[doc = "< WT to be used (ignored in Listen Mode)"]
	pub WT: u8,
	#[doc = "< FWT to be used (1/fc)(ignored Listen Mode)"]
	pub FWT: u32,
	#[doc = "< Delta FWT to be used (1/fc)"]
	pub dFWT: u32,
	#[doc = "< Length Reduction coding the max payload"]
	pub LR: u8,
	#[doc = "< Frame Size"]
	pub FS: u16,
	#[doc = "< Bit Rate coding from Initiator  to Target"]
	pub DSI: rfalBitRate,
	#[doc = "< Bit Rate coding from Target to Initiator"]
	pub DRI: rfalBitRate,
	#[doc = "< Device ID (RFAL_NFCDEP_DID_NO if no DID)"]
	pub DID: u8,
	#[doc = "< Node ADdress (RFAL_NFCDEP_NAD_NO if no NAD)"]
	pub NAD: u8,
}
#[test]
fn bindgen_test_layout_rfalNfcDepInfo() {
	assert_eq!(
	           ::core::mem::size_of::<rfalNfcDepInfo>(),
	           28usize,
	           concat!("Size of: ", stringify!(rfalNfcDepInfo))
	);
	assert_eq!(
	           ::core::mem::align_of::<rfalNfcDepInfo>(),
	           4usize,
	           concat!("Alignment of ", stringify!(rfalNfcDepInfo))
	);
	fn test_field_GBLen() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcDepInfo>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).GBLen) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(rfalNfcDepInfo), "::", stringify!(GBLen))
		);
	}
	test_field_GBLen();
	fn test_field_WT() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcDepInfo>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).WT) as usize - ptr as usize
		           },
		           1usize,
		           concat!("Offset of field: ", stringify!(rfalNfcDepInfo), "::", stringify!(WT))
		);
	}
	test_field_WT();
	fn test_field_FWT() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcDepInfo>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).FWT) as usize - ptr as usize
		           },
		           4usize,
		           concat!("Offset of field: ", stringify!(rfalNfcDepInfo), "::", stringify!(FWT))
		);
	}
	test_field_FWT();
	fn test_field_dFWT() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcDepInfo>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).dFWT) as usize - ptr as usize
		           },
		           8usize,
		           concat!("Offset of field: ", stringify!(rfalNfcDepInfo), "::", stringify!(dFWT))
		);
	}
	test_field_dFWT();
	fn test_field_LR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcDepInfo>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).LR) as usize - ptr as usize
		           },
		           12usize,
		           concat!("Offset of field: ", stringify!(rfalNfcDepInfo), "::", stringify!(LR))
		);
	}
	test_field_LR();
	fn test_field_FS() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcDepInfo>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).FS) as usize - ptr as usize
		           },
		           14usize,
		           concat!("Offset of field: ", stringify!(rfalNfcDepInfo), "::", stringify!(FS))
		);
	}
	test_field_FS();
	fn test_field_DSI() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcDepInfo>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).DSI) as usize - ptr as usize
		           },
		           16usize,
		           concat!("Offset of field: ", stringify!(rfalNfcDepInfo), "::", stringify!(DSI))
		);
	}
	test_field_DSI();
	fn test_field_DRI() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcDepInfo>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).DRI) as usize - ptr as usize
		           },
		           20usize,
		           concat!("Offset of field: ", stringify!(rfalNfcDepInfo), "::", stringify!(DRI))
		);
	}
	test_field_DRI();
	fn test_field_DID() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcDepInfo>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).DID) as usize - ptr as usize
		           },
		           24usize,
		           concat!("Offset of field: ", stringify!(rfalNfcDepInfo), "::", stringify!(DID))
		);
	}
	test_field_DID();
	fn test_field_NAD() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcDepInfo>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).NAD) as usize - ptr as usize
		           },
		           25usize,
		           concat!("Offset of field: ", stringify!(rfalNfcDepInfo), "::", stringify!(NAD))
		);
	}
	test_field_NAD();
}
#[doc = " NFC-DEP Device structure"]
#[repr(C)]
pub struct rfalNfcDepDevice {
	#[doc = "< Activation Info"]
	pub activation: rfalNfcDepActivation,
	#[doc = "< NFC-DEP device Info"]
	pub info: rfalNfcDepInfo,
}
#[test]
fn bindgen_test_layout_rfalNfcDepDevice() {
	assert_eq!(
	           ::core::mem::size_of::<rfalNfcDepDevice>(),
	           96usize,
	           concat!("Size of: ", stringify!(rfalNfcDepDevice))
	);
	assert_eq!(
	           ::core::mem::align_of::<rfalNfcDepDevice>(),
	           4usize,
	           concat!("Alignment of ", stringify!(rfalNfcDepDevice))
	);
	fn test_field_activation() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcDepDevice>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).activation) as usize - ptr as usize
		           },
		           0usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalNfcDepDevice),
			"::",
			stringify!(activation)
		)
		);
	}
	test_field_activation();
	fn test_field_info() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcDepDevice>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).info) as usize - ptr as usize
		           },
		           68usize,
		           concat!("Offset of field: ", stringify!(rfalNfcDepDevice), "::", stringify!(info))
		);
	}
	test_field_info();
}
#[doc = " NFCIP Protocol structure for P2P Target"]
#[doc = ""]
#[doc = "   operParam : derives from NFC-Forum NCI NFC-DEP Operation Parameter"]
#[doc = "               NCI 1.1 Table 86: NFC-DEP Operation Parameter"]
#[doc = "               and it's a bit mask composed as:"]
#[doc = "                  [ 0000b"]
#[doc = "                    | Chain SHALL use max. Transport Data Byte[1b]"]
#[doc = "                    | I-PDU with no Transport Data SHALL NOT be sent [1b]"]
#[doc = "                    | NFC-DEP Target SHALL NOT send RTOX request [1b]"]
#[doc = "                  ]"]
#[doc = ""]
#[repr(C)]
pub struct rfalNfcDepAtrParam {
	#[doc = "< Initiator in Active P2P or Passive P2P"]
	pub commMode: rfalNfcDepCommMode,
	#[doc = "< NFC-DEP Operation Parameter"]
	pub operParam: u8,
	#[doc = "< Initiator's NFCID2 or NFCID3"]
	pub nfcid: *mut u8,
	#[doc = "< Initiator's NFCID length (NFCID2/3)"]
	pub nfcidLen: u8,
	#[doc = "< Initiator's Device ID DID"]
	pub DID: u8,
	#[doc = "< Initiator's Node ID NAD"]
	pub NAD: u8,
	#[doc = "< Initiator's Bit Rates supported in Tx"]
	pub BS: u8,
	#[doc = "< Initiator's Bit Rates supported in Rx"]
	pub BR: u8,
	#[doc = "< Initiator's Length reduction"]
	pub LR: u8,
	#[doc = "< Initiator's General Bytes (Gi)"]
	pub GB: *mut u8,
	#[doc = "< Initiator's General Bytes length"]
	pub GBLen: u8,
}
#[test]
fn bindgen_test_layout_rfalNfcDepAtrParam() {
	assert_eq!(
	           ::core::mem::size_of::<rfalNfcDepAtrParam>(),
	           28usize,
	           concat!("Size of: ", stringify!(rfalNfcDepAtrParam))
	);
	assert_eq!(
	           ::core::mem::align_of::<rfalNfcDepAtrParam>(),
	           4usize,
	           concat!("Alignment of ", stringify!(rfalNfcDepAtrParam))
	);
	fn test_field_commMode() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcDepAtrParam>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).commMode) as usize - ptr as usize
		           },
		           0usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalNfcDepAtrParam),
			"::",
			stringify!(commMode)
		)
		);
	}
	test_field_commMode();
	fn test_field_operParam() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcDepAtrParam>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).operParam) as usize - ptr as usize
		           },
		           4usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalNfcDepAtrParam),
			"::",
			stringify!(operParam)
		)
		);
	}
	test_field_operParam();
	fn test_field_nfcid() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcDepAtrParam>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).nfcid) as usize - ptr as usize
		           },
		           8usize,
		           concat!("Offset of field: ", stringify!(rfalNfcDepAtrParam), "::", stringify!(nfcid))
		);
	}
	test_field_nfcid();
	fn test_field_nfcidLen() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcDepAtrParam>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).nfcidLen) as usize - ptr as usize
		           },
		           12usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalNfcDepAtrParam),
			"::",
			stringify!(nfcidLen)
		)
		);
	}
	test_field_nfcidLen();
	fn test_field_DID() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcDepAtrParam>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).DID) as usize - ptr as usize
		           },
		           13usize,
		           concat!("Offset of field: ", stringify!(rfalNfcDepAtrParam), "::", stringify!(DID))
		);
	}
	test_field_DID();
	fn test_field_NAD() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcDepAtrParam>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).NAD) as usize - ptr as usize
		           },
		           14usize,
		           concat!("Offset of field: ", stringify!(rfalNfcDepAtrParam), "::", stringify!(NAD))
		);
	}
	test_field_NAD();
	fn test_field_BS() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcDepAtrParam>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).BS) as usize - ptr as usize
		           },
		           15usize,
		           concat!("Offset of field: ", stringify!(rfalNfcDepAtrParam), "::", stringify!(BS))
		);
	}
	test_field_BS();
	fn test_field_BR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcDepAtrParam>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).BR) as usize - ptr as usize
		           },
		           16usize,
		           concat!("Offset of field: ", stringify!(rfalNfcDepAtrParam), "::", stringify!(BR))
		);
	}
	test_field_BR();
	fn test_field_LR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcDepAtrParam>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).LR) as usize - ptr as usize
		           },
		           17usize,
		           concat!("Offset of field: ", stringify!(rfalNfcDepAtrParam), "::", stringify!(LR))
		);
	}
	test_field_LR();
	fn test_field_GB() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcDepAtrParam>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).GB) as usize - ptr as usize
		           },
		           20usize,
		           concat!("Offset of field: ", stringify!(rfalNfcDepAtrParam), "::", stringify!(GB))
		);
	}
	test_field_GB();
	fn test_field_GBLen() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcDepAtrParam>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).GBLen) as usize - ptr as usize
		           },
		           24usize,
		           concat!("Offset of field: ", stringify!(rfalNfcDepAtrParam), "::", stringify!(GBLen))
		);
	}
	test_field_GBLen();
}
#[doc = " Structure of parameters to be passed in for nfcDepListenStartActivation"]
#[repr(C)]
pub struct rfalNfcDepListenActvParam {
	#[doc = "< Receive Buffer struct reference"]
	pub rxBuf: *mut rfalNfcDepBufFormat,
	#[doc = "< Receive INF data length in bytes"]
	pub rxLen: *mut u16,
	#[doc = "< Received data is not complete"]
	pub isRxChaining: *mut bool,
	#[doc = "< NFC-DEP device info"]
	pub nfcDepDev: *mut rfalNfcDepDevice,
}
#[test]
fn bindgen_test_layout_rfalNfcDepListenActvParam() {
	assert_eq!(
	           ::core::mem::size_of::<rfalNfcDepListenActvParam>(),
	           16usize,
	           concat!("Size of: ", stringify!(rfalNfcDepListenActvParam))
	);
	assert_eq!(
	           ::core::mem::align_of::<rfalNfcDepListenActvParam>(),
	           4usize,
	           concat!("Alignment of ", stringify!(rfalNfcDepListenActvParam))
	);
	fn test_field_rxBuf() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcDepListenActvParam>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).rxBuf) as usize - ptr as usize
		           },
		           0usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalNfcDepListenActvParam),
			"::",
			stringify!(rxBuf)
		)
		);
	}
	test_field_rxBuf();
	fn test_field_rxLen() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcDepListenActvParam>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).rxLen) as usize - ptr as usize
		           },
		           4usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalNfcDepListenActvParam),
			"::",
			stringify!(rxLen)
		)
		);
	}
	test_field_rxLen();
	fn test_field_isRxChaining() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcDepListenActvParam>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).isRxChaining) as usize - ptr as usize
		           },
		           8usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalNfcDepListenActvParam),
			"::",
			stringify!(isRxChaining)
		)
		);
	}
	test_field_isRxChaining();
	fn test_field_nfcDepDev() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcDepListenActvParam>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).nfcDepDev) as usize - ptr as usize
		           },
		           12usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalNfcDepListenActvParam),
			"::",
			stringify!(nfcDepDev)
		)
		);
	}
	test_field_nfcDepDev();
}
#[doc = " NFCIP Protocol structure for P2P Target"]
#[doc = ""]
#[doc = "   operParam : derives from NFC-Forum NCI NFC-DEP Operation Parameter"]
#[doc = "               NCI 1.1 Table 86: NFC-DEP Operation Parameter"]
#[doc = "               and it's a bit mask composed as:"]
#[doc = "                  [ 0000b"]
#[doc = "                    | Chain SHALL use max. Transport Data Byte[1b]"]
#[doc = "                    | I-PDU with no Transport Data SHALL NOT be sent [1b]"]
#[doc = "                    | NFC-DEP Target SHALL NOT send RTOX request [1b]"]
#[doc = "                  ]"]
#[doc = ""]
#[repr(C)]
pub struct rfalNfcDepTargetParam {
	#[doc = "< Target in Active P2P or Passive P2P"]
	pub commMode: rfalNfcDepCommMode,
	#[doc = "< Target's NFCID3"]
	pub nfcid3: [u8; 10usize],
	#[doc = "< Target's Bit Rates supported in Tx"]
	pub bst: u8,
	#[doc = "< Target's Bit Rates supported in Rx"]
	pub brt: u8,
	#[doc = "< Target's timeout (TO) value"]
	pub to: u8,
	#[doc = "< Target's Presence optional Params(PPt)"]
	pub ppt: u8,
	#[doc = "< Target's General Bytes (Gt)"]
	pub GBt: [u8; 48usize],
	#[doc = "< Target's General Bytes length"]
	pub GBtLen: u8,
	#[doc = "< NFC-DEP Operation Parameter"]
	pub operParam: u8,
}
#[test]
fn bindgen_test_layout_rfalNfcDepTargetParam() {
	assert_eq!(
	           ::core::mem::size_of::<rfalNfcDepTargetParam>(),
	           68usize,
	           concat!("Size of: ", stringify!(rfalNfcDepTargetParam))
	);
	assert_eq!(
	           ::core::mem::align_of::<rfalNfcDepTargetParam>(),
	           4usize,
	           concat!("Alignment of ", stringify!(rfalNfcDepTargetParam))
	);
	fn test_field_commMode() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcDepTargetParam>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).commMode) as usize - ptr as usize
		           },
		           0usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalNfcDepTargetParam),
			"::",
			stringify!(commMode)
		)
		);
	}
	test_field_commMode();
	fn test_field_nfcid3() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcDepTargetParam>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).nfcid3) as usize - ptr as usize
		           },
		           4usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalNfcDepTargetParam),
			"::",
			stringify!(nfcid3)
		)
		);
	}
	test_field_nfcid3();
	fn test_field_bst() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcDepTargetParam>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).bst) as usize - ptr as usize
		           },
		           14usize,
		           concat!("Offset of field: ", stringify!(rfalNfcDepTargetParam), "::", stringify!(bst))
		);
	}
	test_field_bst();
	fn test_field_brt() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcDepTargetParam>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).brt) as usize - ptr as usize
		           },
		           15usize,
		           concat!("Offset of field: ", stringify!(rfalNfcDepTargetParam), "::", stringify!(brt))
		);
	}
	test_field_brt();
	fn test_field_to() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcDepTargetParam>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).to) as usize - ptr as usize
		           },
		           16usize,
		           concat!("Offset of field: ", stringify!(rfalNfcDepTargetParam), "::", stringify!(to))
		);
	}
	test_field_to();
	fn test_field_ppt() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcDepTargetParam>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).ppt) as usize - ptr as usize
		           },
		           17usize,
		           concat!("Offset of field: ", stringify!(rfalNfcDepTargetParam), "::", stringify!(ppt))
		);
	}
	test_field_ppt();
	fn test_field_GBt() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcDepTargetParam>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).GBt) as usize - ptr as usize
		           },
		           18usize,
		           concat!("Offset of field: ", stringify!(rfalNfcDepTargetParam), "::", stringify!(GBt))
		);
	}
	test_field_GBt();
	fn test_field_GBtLen() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcDepTargetParam>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).GBtLen) as usize - ptr as usize
		           },
		           66usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalNfcDepTargetParam),
			"::",
			stringify!(GBtLen)
		)
		);
	}
	test_field_GBtLen();
	fn test_field_operParam() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcDepTargetParam>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).operParam) as usize - ptr as usize
		           },
		           67usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalNfcDepTargetParam),
			"::",
			stringify!(operParam)
		)
		);
	}
	test_field_operParam();
}
#[doc = " Structure of parameters to be passed in for nfcDepStartIpduTransceive"]
#[repr(C)]
pub struct rfalNfcDepTxRxParam {
	#[doc = "< Transmit Buffer struct reference"]
	pub txBuf: *mut rfalNfcDepBufFormat,
	#[doc = "< Transmit Buffer INF field length in bytes"]
	pub txBufLen: u16,
	#[doc = "< Transmit data is not complete"]
	pub isTxChaining: bool,
	#[doc = "< Receive Buffer struct reference"]
	pub rxBuf: *mut rfalNfcDepBufFormat,
	#[doc = "< Receive INF data length"]
	pub rxLen: *mut u16,
	#[doc = "< Received data is not complete"]
	pub isRxChaining: *mut bool,
	#[doc = "< FWT to be used (ignored in Listen Mode)"]
	pub FWT: u32,
	#[doc = "< Delta FWT to be used"]
	pub dFWT: u32,
	#[doc = "< Other device Frame Size (FSD or FSC)"]
	pub FSx: u16,
	#[doc = "< Device ID (RFAL_ISODEP_NO_DID if no DID)"]
	pub DID: u8,
}
#[test]
fn bindgen_test_layout_rfalNfcDepTxRxParam() {
	assert_eq!(
	           ::core::mem::size_of::<rfalNfcDepTxRxParam>(),
	           32usize,
	           concat!("Size of: ", stringify!(rfalNfcDepTxRxParam))
	);
	assert_eq!(
	           ::core::mem::align_of::<rfalNfcDepTxRxParam>(),
	           4usize,
	           concat!("Alignment of ", stringify!(rfalNfcDepTxRxParam))
	);
	fn test_field_txBuf() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcDepTxRxParam>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).txBuf) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(rfalNfcDepTxRxParam), "::", stringify!(txBuf))
		);
	}
	test_field_txBuf();
	fn test_field_txBufLen() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcDepTxRxParam>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).txBufLen) as usize - ptr as usize
		           },
		           4usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalNfcDepTxRxParam),
			"::",
			stringify!(txBufLen)
		)
		);
	}
	test_field_txBufLen();
	fn test_field_isTxChaining() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcDepTxRxParam>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).isTxChaining) as usize - ptr as usize
		           },
		           6usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalNfcDepTxRxParam),
			"::",
			stringify!(isTxChaining)
		)
		);
	}
	test_field_isTxChaining();
	fn test_field_rxBuf() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcDepTxRxParam>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).rxBuf) as usize - ptr as usize
		           },
		           8usize,
		           concat!("Offset of field: ", stringify!(rfalNfcDepTxRxParam), "::", stringify!(rxBuf))
		);
	}
	test_field_rxBuf();
	fn test_field_rxLen() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcDepTxRxParam>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).rxLen) as usize - ptr as usize
		           },
		           12usize,
		           concat!("Offset of field: ", stringify!(rfalNfcDepTxRxParam), "::", stringify!(rxLen))
		);
	}
	test_field_rxLen();
	fn test_field_isRxChaining() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcDepTxRxParam>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).isRxChaining) as usize - ptr as usize
		           },
		           16usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalNfcDepTxRxParam),
			"::",
			stringify!(isRxChaining)
		)
		);
	}
	test_field_isRxChaining();
	fn test_field_FWT() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcDepTxRxParam>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).FWT) as usize - ptr as usize
		           },
		           20usize,
		           concat!("Offset of field: ", stringify!(rfalNfcDepTxRxParam), "::", stringify!(FWT))
		);
	}
	test_field_FWT();
	fn test_field_dFWT() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcDepTxRxParam>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).dFWT) as usize - ptr as usize
		           },
		           24usize,
		           concat!("Offset of field: ", stringify!(rfalNfcDepTxRxParam), "::", stringify!(dFWT))
		);
	}
	test_field_dFWT();
	fn test_field_FSx() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcDepTxRxParam>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).FSx) as usize - ptr as usize
		           },
		           28usize,
		           concat!("Offset of field: ", stringify!(rfalNfcDepTxRxParam), "::", stringify!(FSx))
		);
	}
	test_field_FSx();
	fn test_field_DID() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcDepTxRxParam>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).DID) as usize - ptr as usize
		           },
		           30usize,
		           concat!("Offset of field: ", stringify!(rfalNfcDepTxRxParam), "::", stringify!(DID))
		);
	}
	test_field_DID();
}
#[doc = " Structure of parameters used on NFC DEP PDU Transceive"]
#[repr(C)]
pub struct rfalNfcDepPduTxRxParam {
	#[doc = "< Transmit Buffer struct reference"]
	pub txBuf: *mut rfalNfcDepPduBufFormat,
	#[doc = "< Transmit Buffer INF field length in Bytes"]
	pub txBufLen: u16,
	#[doc = "< Receive Buffer struct reference in Bytes"]
	pub rxBuf: *mut rfalNfcDepPduBufFormat,
	#[doc = "< Received INF data length in Bytes"]
	pub rxLen: *mut u16,
	#[doc = "< Temp buffer for single PDUs (internal)"]
	pub tmpBuf: *mut rfalNfcDepBufFormat,
	#[doc = "< FWT to be used (ignored in Listen Mode)"]
	pub FWT: u32,
	#[doc = "< Delta FWT to be used"]
	pub dFWT: u32,
	#[doc = "< Other device Frame Size (FSD or FSC)"]
	pub FSx: u16,
	#[doc = "< Device ID (RFAL_ISODEP_NO_DID if no DID)"]
	pub DID: u8,
}
#[test]
fn bindgen_test_layout_rfalNfcDepPduTxRxParam() {
	assert_eq!(
	           ::core::mem::size_of::<rfalNfcDepPduTxRxParam>(),
	           32usize,
	           concat!("Size of: ", stringify!(rfalNfcDepPduTxRxParam))
	);
	assert_eq!(
	           ::core::mem::align_of::<rfalNfcDepPduTxRxParam>(),
	           4usize,
	           concat!("Alignment of ", stringify!(rfalNfcDepPduTxRxParam))
	);
	fn test_field_txBuf() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcDepPduTxRxParam>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).txBuf) as usize - ptr as usize
		           },
		           0usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalNfcDepPduTxRxParam),
			"::",
			stringify!(txBuf)
		)
		);
	}
	test_field_txBuf();
	fn test_field_txBufLen() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcDepPduTxRxParam>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).txBufLen) as usize - ptr as usize
		           },
		           4usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalNfcDepPduTxRxParam),
			"::",
			stringify!(txBufLen)
		)
		);
	}
	test_field_txBufLen();
	fn test_field_rxBuf() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcDepPduTxRxParam>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).rxBuf) as usize - ptr as usize
		           },
		           8usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalNfcDepPduTxRxParam),
			"::",
			stringify!(rxBuf)
		)
		);
	}
	test_field_rxBuf();
	fn test_field_rxLen() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcDepPduTxRxParam>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).rxLen) as usize - ptr as usize
		           },
		           12usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalNfcDepPduTxRxParam),
			"::",
			stringify!(rxLen)
		)
		);
	}
	test_field_rxLen();
	fn test_field_tmpBuf() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcDepPduTxRxParam>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).tmpBuf) as usize - ptr as usize
		           },
		           16usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalNfcDepPduTxRxParam),
			"::",
			stringify!(tmpBuf)
		)
		);
	}
	test_field_tmpBuf();
	fn test_field_FWT() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcDepPduTxRxParam>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).FWT) as usize - ptr as usize
		           },
		           20usize,
		           concat!("Offset of field: ", stringify!(rfalNfcDepPduTxRxParam), "::", stringify!(FWT))
		);
	}
	test_field_FWT();
	fn test_field_dFWT() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcDepPduTxRxParam>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).dFWT) as usize - ptr as usize
		           },
		           24usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalNfcDepPduTxRxParam),
			"::",
			stringify!(dFWT)
		)
		);
	}
	test_field_dFWT();
	fn test_field_FSx() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcDepPduTxRxParam>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).FSx) as usize - ptr as usize
		           },
		           28usize,
		           concat!("Offset of field: ", stringify!(rfalNfcDepPduTxRxParam), "::", stringify!(FSx))
		);
	}
	test_field_FSx();
	fn test_field_DID() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcDepPduTxRxParam>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).DID) as usize - ptr as usize
		           },
		           30usize,
		           concat!("Offset of field: ", stringify!(rfalNfcDepPduTxRxParam), "::", stringify!(DID))
		);
	}
	test_field_DID();
}
extern "C" {
	#[doc = " \\brief NFCIP Initialize"]
	#[doc = ""]
	#[doc = " This method resets all NFC-DEP inner states, counters and context and sets"]
	#[doc = " default values"]
	#[doc = ""]
	#[doc = ""]
	pub fn rfalNfcDepInitialize();
}
extern "C" {
	#[doc = " \\brief Set deactivating callback"]
	#[doc = ""]
	#[doc = " Sets the deactivating callback so that nfcip layer can check if upper layer"]
	#[doc = " has a deactivation pending, and not perform error recovery upon specific"]
	#[doc = " errors"]
	#[doc = ""]
	#[doc = " \\param[in] pFunc : method pointer to deactivation flag check"]
	#[doc = ""]
	pub fn rfalNfcDepSetDeactivatingCallback(pFunc: rfalNfcDepDeactCallback);
}
extern "C" {
	#[doc = " \\brief Calculate Response Waiting Time"]
	#[doc = ""]
	#[doc = " Calculates the Response Waiting Time (RWT) from the given Waiting Time (WT)"]
	#[doc = ""]
	#[doc = " \\param[in]  wt : the WT value to calculate RWT"]
	#[doc = ""]
	#[doc = " \\return RWT value in 1/fc"]
	#[doc = ""]
	pub fn rfalNfcDepCalculateRWT(wt: u8) -> u32;
}
extern "C" {
	#[doc = " \\brief NFC-DEP Initiator ATR (Attribute Request)"]
	#[doc = ""]
	#[doc = " This method configures the NFC-DEP layer with given parameters and then"]
	#[doc = " sends an ATR to the Target with and checks for a valid response response"]
	#[doc = ""]
	#[doc = " \\param[in]   param     : parameters to initialize and compose the ATR"]
	#[doc = " \\param[out]  atrRes    : location to store the ATR_RES"]
	#[doc = " \\param[out]  atrResLen : length of the ATR_RES received"]
	#[doc = ""]
	#[doc = " \\return ERR_NONE    : No error"]
	#[doc = " \\return ERR_TIMEOUT : Timeout occurred"]
	#[doc = " \\return ERR_PROTO   : Protocol error occurred"]
	#[doc = ""]
	pub fn rfalNfcDepATR(param: *const rfalNfcDepAtrParam, atrRes: *mut rfalNfcDepAtrRes, atrResLen: *mut u8) -> ReturnCode;
}
extern "C" {
	#[doc = " \\brief NFC-DEP Initiator PSL (Parameter Selection)"]
	#[doc = ""]
	#[doc = " This method sends a PSL to the Target with the given parameters and checks"]
	#[doc = " for a valid response response"]
	#[doc = ""]
	#[doc = " The parameters must be coded according to  Digital 1.1  16.7.1"]
	#[doc = ""]
	#[doc = " \\param[in] BRS : the selected Bit Rates for Initiator and Target"]
	#[doc = " \\param[in] FSL : the maximum length of Commands and Responses"]
	#[doc = ""]
	#[doc = " \\return ERR_NONE    : No error"]
	#[doc = " \\return ERR_TIMEOUT : Timeout occurred"]
	#[doc = " \\return ERR_PROTO   : Protocol error occurred"]
	#[doc = ""]
	pub fn rfalNfcDepPSL(BRS: u8, FSL: u8) -> ReturnCode;
}
extern "C" {
	#[doc = " \\brief NFC-DEP Initiator DSL (Deselect)"]
	#[doc = ""]
	#[doc = " This method checks if the NFCIP module is configured as initiator and if"]
	#[doc = " so sends a DSL REQ, waits  the target's response and checks it"]
	#[doc = ""]
	#[doc = " In case of performing as target no action is taken"]
	#[doc = ""]
	#[doc = " \\return ERR_NONE       : No error"]
	#[doc = " \\return ERR_TIMEOUT    : Timeout occurred"]
	#[doc = " \\return ERR_MAX_RERUNS : Timeout occurred"]
	#[doc = " \\return ERR_PROTO      : Protocol error occurred"]
	#[doc = ""]
	pub fn rfalNfcDepDSL() -> ReturnCode;
}
extern "C" {
	#[doc = " \\brief NFC-DEP Initiator RLS (Release)"]
	#[doc = ""]
	#[doc = " This method checks if the NFCIP module is configured as initiator and if"]
	#[doc = " so sends a RLS REQ, waits target's response and checks it"]
	#[doc = ""]
	#[doc = " In case of performing as target no action is taken"]
	#[doc = ""]
	#[doc = " \\return ERR_NONE       : No error"]
	#[doc = " \\return ERR_TIMEOUT    : Timeout occurred"]
	#[doc = " \\return ERR_MAX_RERUNS : Timeout occurred"]
	#[doc = " \\return ERR_PROTO      : Protocol error occurred"]
	#[doc = ""]
	pub fn rfalNfcDepRLS() -> ReturnCode;
}
extern "C" {
	#[doc = "  \\brief  NFC-DEP Initiator Handle  Activation"]
	#[doc = ""]
	#[doc = "  This performs a Activation into NFC-DEP layer with the given"]
	#[doc = "  parameters. It sends ATR_REQ and if the higher bit rates are supported by"]
	#[doc = "  both devices it additionally sends PSL"]
	#[doc = "  Once Activated all details of the device are provided on nfcDepDev"]
	#[doc = ""]
	#[doc = "  \\param[in]  param     : required parameters to initialize and send ATR_REQ"]
	#[doc = "  \\param[in]  desiredBR : Desired bit rate supported by the Poller"]
	#[doc = "  \\param[out] nfcDepDev : NFC-DEP information of the activated Listen device"]
	#[doc = ""]
	#[doc = "  \\return ERR_WRONG_STATE  : RFAL not initialized or incorrect mode"]
	#[doc = "  \\return ERR_PARAM        : Invalid parameters"]
	#[doc = "  \\return ERR_IO           : Generic internal error"]
	#[doc = "  \\return ERR_TIMEOUT      : Timeout error"]
	#[doc = "  \\return ERR_PAR          : Parity error detected"]
	#[doc = "  \\return ERR_CRC          : CRC error detected"]
	#[doc = "  \\return ERR_FRAMING      : Framing error detected"]
	#[doc = "  \\return ERR_PROTO        : Protocol error detected"]
	#[doc = "  \\return ERR_NONE         : No error, activation successful"]
	#[doc = ""]
	pub fn rfalNfcDepInitiatorHandleActivation(param: *mut rfalNfcDepAtrParam,
	                                           desiredBR: rfalBitRate,
	                                           nfcDepDev: *mut rfalNfcDepDevice)
	                                           -> ReturnCode;
}
extern "C" {
	#[doc = " \\brief Check if buffer contains valid ATR_REQ"]
	#[doc = ""]
	#[doc = " This method checks if the given ATR_REQ is valid"]
	#[doc = ""]
	#[doc = ""]
	#[doc = " \\param[in]  buf    : buffer holding Initiator's received request"]
	#[doc = " \\param[in]  bufLen : size of the msg contained on the buf in Bytes"]
	#[doc = " \\param[out] nfcid3 : pointer to where the NFCID3 may be outputed,"]
	#[doc = "                       nfcid3 has NFCF_SENSF_NFCID3_LEN as length"]
	#[doc = "                       Pass NULL if output parameter not desired"]
	#[doc = ""]
	#[doc = " \\return true  : Valid ATR_REQ received, the ATR_RES has been computed in txBuf"]
	#[doc = " \\return false : Invalid protocol request"]
	#[doc = ""]
	#[doc = ""]
	pub fn rfalNfcDepIsAtrReq(buf: *const u8, bufLen: u16, nfcid3: *mut u8) -> bool;
}
extern "C" {
	#[doc = " \\brief Check is Target has received ATR"]
	#[doc = ""]
	#[doc = " This method checks if the NFCIP module is configured as target and if a"]
	#[doc = " ATR REQ has been received ( whether is in activation or in data exchange)"]
	#[doc = ""]
	#[doc = " \\return true  : a ATR has already been received"]
	#[doc = " \\return false : no ATR has been received"]
	#[doc = ""]
	pub fn rfalNfcDepTargetRcvdATR() -> bool;
}
extern "C" {
	#[doc = " \\brief NFCDEP Start Listen Activation Handling"]
	#[doc = ""]
	#[doc = " Start Activation Handling and setup to receive first frame which may"]
	#[doc = " contain complete or partial DEP-REQ after activation is completed"]
	#[doc = ""]
	#[doc = " Pass in ATR_REQ for NFC-DEP to handle ATR_RES. The Activation Handling"]
	#[doc = " handles ATR_RES and PSL_RES if a PSL_REQ is received"]
	#[doc = ""]
	#[doc = " Activation is completed if PSL_RES is sent or if first I-PDU is received"]
	#[doc = ""]
	#[doc = " \\ref rfalNfcDepListenGetActivationStatus() provide status of the"]
	#[doc = "       ongoing activation"]
	#[doc = ""]
	#[doc = " \\warning nfcDepGetTransceiveStatus() shall be called right after activation"]
	#[doc = " is completed (i.e. rfalNfcDepListenGetActivationStatus() return ERR_NONE)"]
	#[doc = " to check for first received frame."]
	#[doc = ""]
	#[doc = " \\param[in]  param       : Target parameters to be used"]
	#[doc = " \\param[in]  atrReq      : reference to buffer containing ATR_REQ"]
	#[doc = " \\param[in]  atrReqLength: Length of ATR_REQ"]
	#[doc = " \\param[out] rxParam     : references to buffer, length and chaining indication"]
	#[doc = "                           for first complete LLCP to be received"]
	#[doc = ""]
	#[doc = " \\return ERR_NONE      : ATR_REQ is valid and activation ongoing"]
	#[doc = " \\return ERR_PARAM     : ATR_REQ or other params are invalid"]
	#[doc = " \\return ERR_LINK_LOSS : Remote Field is turned off"]
	#[doc = ""]
	pub fn rfalNfcDepListenStartActivation(param: *const rfalNfcDepTargetParam,
	                                       atrReq: *const u8,
	                                       atrReqLength: u16,
	                                       rxParam: rfalNfcDepListenActvParam)
	                                       -> ReturnCode;
}
extern "C" {
	#[doc = " \\brief Get the current NFC-DEP Activation Status"]
	#[doc = ""]
	#[doc = " \\return ERR_NONE      : Activation has completed successfully"]
	#[doc = " \\return ERR_BUSY      : Activation is ongoing"]
	#[doc = " \\return ERR_LINK_LOSS : Remote Field was turned off"]
	#[doc = ""]
	pub fn rfalNfcDepListenGetActivationStatus() -> ReturnCode;
}
extern "C" {
	#[doc = " \\brief Start Transceive"]
	#[doc = ""]
	#[doc = " Transceives a complete or partial DEP block"]
	#[doc = ""]
	#[doc = " The txBuf contains complete or partial of DEP to be transmitted."]
	#[doc = " The Prologue field of the I-PDU is handled internally"]
	#[doc = ""]
	#[doc = " If the buffer contains partial LLCP and is not the last block, then"]
	#[doc = " isTxChaining must be set to true"]
	#[doc = ""]
	#[doc = " \\param[in] param: reference parameters to be used for the Transceive"]
	#[doc = ""]
	#[doc = " \\return ERR_PARAM       : Bad request"]
	#[doc = " \\return ERR_WRONG_STATE : The module is not in a proper state"]
	#[doc = " \\return ERR_NONE        : The Transceive request has been started"]
	#[doc = ""]
	pub fn rfalNfcDepStartTransceive(param: *const rfalNfcDepTxRxParam) -> ReturnCode;
}
extern "C" {
	#[doc = " \\brief Return the Transceive status"]
	#[doc = ""]
	#[doc = " Returns the status of the NFC-DEP Transceive"]
	#[doc = ""]
	#[doc = " \\warning  When the other device is performing chaining once a chained"]
	#[doc = "            block is received the error ERR_AGAIN is sent. At this point"]
	#[doc = "            caller must handle the received data immediately."]
	#[doc = "            When ERR_AGAIN is returned an ACK has already been sent to"]
	#[doc = "            the other device and the next block might be incoming."]
	#[doc = "            If rfalWorker() is called frequently it will place the next"]
	#[doc = "            block on the given buffer"]
	#[doc = ""]
	#[doc = " \\return ERR_NONE      : Transceive has been completed successfully"]
	#[doc = " \\return ERR_BUSY      : Transceive is ongoing"]
	#[doc = " \\return ERR_PROTO     : Protocol error occurred"]
	#[doc = " \\return ERR_TIMEOUT   : Timeout error occurred"]
	#[doc = " \\return ERR_SLEEP_REQ : Deselect has been received and responded"]
	#[doc = " \\return ERR_NOMEM     : The received I-PDU does not fit into the"]
	#[doc = "                            receive buffer"]
	#[doc = " \\return ERR_LINK_LOSS : Communication is lost because Reader/Writer"]
	#[doc = "                            has turned off its field"]
	#[doc = " \\return ERR_AGAIN     : received one chaining block, continue to call"]
	#[doc = "                            this method to retrieve the remaining blocks"]
	#[doc = ""]
	pub fn rfalNfcDepGetTransceiveStatus() -> ReturnCode;
}
extern "C" {
	#[doc = " \\brief Start PDU Transceive"]
	#[doc = ""]
	#[doc = " This method triggers a NFC-DEP Transceive containing a complete PDU"]
	#[doc = " It transmits the given message and handles all protocol retransmitions,"]
	#[doc = " error handling and control messages"]
	#[doc = ""]
	#[doc = " The txBuf  contains a complete PDU to be transmitted"]
	#[doc = " The Prologue field will be manipulated by the Transceive"]
	#[doc = ""]
	#[doc = " \\warning the txBuf will be modified during the transmission"]
	#[doc = " \\warning the maximum RF frame which can be received is limited by param.tmpBuf"]
	#[doc = ""]
	#[doc = " \\param[in] param: reference parameters to be used for the Transceive"]
	#[doc = ""]
	#[doc = " \\return ERR_PARAM       : Bad request"]
	#[doc = " \\return ERR_WRONG_STATE : The module is not in a proper state"]
	#[doc = " \\return ERR_NONE        : The Transceive request has been started"]
	#[doc = ""]
	pub fn rfalNfcDepStartPduTransceive(param: rfalNfcDepPduTxRxParam) -> ReturnCode;
}
extern "C" {
	#[doc = " \\brief Return the PSU Transceive status"]
	#[doc = ""]
	#[doc = " Returns the status of the NFC-DEP PDU Transceive"]
	#[doc = ""]
	#[doc = ""]
	#[doc = " \\return ERR_NONE      : Transceive has been completed successfully"]
	#[doc = " \\return ERR_BUSY      : Transceive is ongoing"]
	#[doc = " \\return ERR_PROTO     : Protocol error occurred"]
	#[doc = " \\return ERR_TIMEOUT   : Timeout error occurred"]
	#[doc = " \\return ERR_SLEEP_REQ : Deselect has been received and responded"]
	#[doc = " \\return ERR_NOMEM     : The received I-PDU does not fit into the"]
	#[doc = "                            receive buffer"]
	#[doc = " \\return ERR_LINK_LOSS : Communication is lost because Reader/Writer"]
	#[doc = "                            has turned off its field"]
	#[doc = ""]
	pub fn rfalNfcDepGetPduTransceiveStatus() -> ReturnCode;
}
#[repr(u32)]
#[non_exhaustive]
#[doc = " Frame Size for Proximity Card Integer definitions"]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum rfalIsoDepFSxI {
	RFAL_ISODEP_FSXI_16 = 0,
	RFAL_ISODEP_FSXI_24 = 1,
	RFAL_ISODEP_FSXI_32 = 2,
	RFAL_ISODEP_FSXI_40 = 3,
	RFAL_ISODEP_FSXI_48 = 4,
	RFAL_ISODEP_FSXI_64 = 5,
	RFAL_ISODEP_FSXI_96 = 6,
	RFAL_ISODEP_FSXI_128 = 7,
	RFAL_ISODEP_FSXI_256 = 8,
	RFAL_ISODEP_FSXI_512 = 9,
	RFAL_ISODEP_FSXI_1024 = 10,
	RFAL_ISODEP_FSXI_2048 = 11,
	RFAL_ISODEP_FSXI_4096 = 12,
}
#[doc = " RATS format  Digital 1.1 13.6.1"]
#[repr(C)]
pub struct rfalIsoDepRats {
	#[doc = "< RATS command byte: 0xE0"]
	pub CMD: u8,
	#[doc = "< Param indicating FSDI and DID"]
	pub PARAM: u8,
}
#[test]
fn bindgen_test_layout_rfalIsoDepRats() {
	assert_eq!(
	           ::core::mem::size_of::<rfalIsoDepRats>(),
	           2usize,
	           concat!("Size of: ", stringify!(rfalIsoDepRats))
	);
	assert_eq!(
	           ::core::mem::align_of::<rfalIsoDepRats>(),
	           1usize,
	           concat!("Alignment of ", stringify!(rfalIsoDepRats))
	);
	fn test_field_CMD() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalIsoDepRats>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).CMD) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(rfalIsoDepRats), "::", stringify!(CMD))
		);
	}
	test_field_CMD();
	fn test_field_PARAM() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalIsoDepRats>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).PARAM) as usize - ptr as usize
		           },
		           1usize,
		           concat!("Offset of field: ", stringify!(rfalIsoDepRats), "::", stringify!(PARAM))
		);
	}
	test_field_PARAM();
}
#[doc = " ATS response format  Digital 1.1 13.6.2"]
#[repr(C)]
pub struct rfalIsoDepAts {
	#[doc = "< Length Byte, including TL byte itself"]
	pub TL: u8,
	#[doc = "< Format Byte T0 indicating if TA, TB, TC"]
	pub T0: u8,
	#[doc = "< Interface Byte TA(1)"]
	pub TA: u8,
	#[doc = "< Interface Byte TB(1)"]
	pub TB: u8,
	#[doc = "< Interface Byte TC(1)"]
	pub TC: u8,
	#[doc = "< Historical Bytes"]
	pub HB: [u8; 15usize],
}
#[test]
fn bindgen_test_layout_rfalIsoDepAts() {
	assert_eq!(
	           ::core::mem::size_of::<rfalIsoDepAts>(),
	           20usize,
	           concat!("Size of: ", stringify!(rfalIsoDepAts))
	);
	assert_eq!(
	           ::core::mem::align_of::<rfalIsoDepAts>(),
	           1usize,
	           concat!("Alignment of ", stringify!(rfalIsoDepAts))
	);
	fn test_field_TL() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalIsoDepAts>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).TL) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(rfalIsoDepAts), "::", stringify!(TL))
		);
	}
	test_field_TL();
	fn test_field_T0() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalIsoDepAts>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).T0) as usize - ptr as usize
		           },
		           1usize,
		           concat!("Offset of field: ", stringify!(rfalIsoDepAts), "::", stringify!(T0))
		);
	}
	test_field_T0();
	fn test_field_TA() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalIsoDepAts>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).TA) as usize - ptr as usize
		           },
		           2usize,
		           concat!("Offset of field: ", stringify!(rfalIsoDepAts), "::", stringify!(TA))
		);
	}
	test_field_TA();
	fn test_field_TB() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalIsoDepAts>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).TB) as usize - ptr as usize
		           },
		           3usize,
		           concat!("Offset of field: ", stringify!(rfalIsoDepAts), "::", stringify!(TB))
		);
	}
	test_field_TB();
	fn test_field_TC() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalIsoDepAts>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).TC) as usize - ptr as usize
		           },
		           4usize,
		           concat!("Offset of field: ", stringify!(rfalIsoDepAts), "::", stringify!(TC))
		);
	}
	test_field_TC();
	fn test_field_HB() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalIsoDepAts>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).HB) as usize - ptr as usize
		           },
		           5usize,
		           concat!("Offset of field: ", stringify!(rfalIsoDepAts), "::", stringify!(HB))
		);
	}
	test_field_HB();
}
#[doc = " PPS Response format (Protocol and Parameter Selection) ISO14443-4  5.4"]
#[repr(C)]
pub struct rfalIsoDepPpsRes {
	#[doc = "< Start Byte:  [ 1101b | CID[4b] ]"]
	pub PPSS: u8,
}
#[test]
fn bindgen_test_layout_rfalIsoDepPpsRes() {
	assert_eq!(
	           ::core::mem::size_of::<rfalIsoDepPpsRes>(),
	           1usize,
	           concat!("Size of: ", stringify!(rfalIsoDepPpsRes))
	);
	assert_eq!(
	           ::core::mem::align_of::<rfalIsoDepPpsRes>(),
	           1usize,
	           concat!("Alignment of ", stringify!(rfalIsoDepPpsRes))
	);
	fn test_field_PPSS() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalIsoDepPpsRes>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).PPSS) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(rfalIsoDepPpsRes), "::", stringify!(PPSS))
		);
	}
	test_field_PPSS();
}
#[doc = " ATTRIB Command Format  Digital 1.1  15.6.1"]
#[repr(C)]
pub struct rfalIsoDepAttribCmd {
	#[doc = "< ATTRIB_REQ command byte"]
	pub cmd: u8,
	#[doc = "< NFCID0 of the card to be selected"]
	pub nfcid0: [u8; 4usize],
	#[doc = "< Parameter of ATTRIB command"]
	pub Param: rfalIsoDepAttribCmd__bindgen_ty_1,
	#[doc = "< Higher Layer Information"]
	pub HLInfo: [u8; 32usize],
}
#[repr(C)]
pub struct rfalIsoDepAttribCmd__bindgen_ty_1 {
	#[doc = "< PARAM1 of ATTRIB command"]
	pub PARAM1: u8,
	#[doc = "< PARAM2 of ATTRIB command"]
	pub PARAM2: u8,
	#[doc = "< PARAM3 of ATTRIB command"]
	pub PARAM3: u8,
	#[doc = "< PARAM4 of ATTRIB command"]
	pub PARAM4: u8,
}
#[test]
fn bindgen_test_layout_rfalIsoDepAttribCmd__bindgen_ty_1() {
	assert_eq!(
	           ::core::mem::size_of::<rfalIsoDepAttribCmd__bindgen_ty_1>(),
	           4usize,
	           concat!("Size of: ", stringify!(rfalIsoDepAttribCmd__bindgen_ty_1))
	);
	assert_eq!(
	           ::core::mem::align_of::<rfalIsoDepAttribCmd__bindgen_ty_1>(),
	           1usize,
	           concat!("Alignment of ", stringify!(rfalIsoDepAttribCmd__bindgen_ty_1))
	);
	fn test_field_PARAM1() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalIsoDepAttribCmd__bindgen_ty_1>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).PARAM1) as usize - ptr as usize
		           },
		           0usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalIsoDepAttribCmd__bindgen_ty_1),
			"::",
			stringify!(PARAM1)
		)
		);
	}
	test_field_PARAM1();
	fn test_field_PARAM2() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalIsoDepAttribCmd__bindgen_ty_1>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).PARAM2) as usize - ptr as usize
		           },
		           1usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalIsoDepAttribCmd__bindgen_ty_1),
			"::",
			stringify!(PARAM2)
		)
		);
	}
	test_field_PARAM2();
	fn test_field_PARAM3() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalIsoDepAttribCmd__bindgen_ty_1>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).PARAM3) as usize - ptr as usize
		           },
		           2usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalIsoDepAttribCmd__bindgen_ty_1),
			"::",
			stringify!(PARAM3)
		)
		);
	}
	test_field_PARAM3();
	fn test_field_PARAM4() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalIsoDepAttribCmd__bindgen_ty_1>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).PARAM4) as usize - ptr as usize
		           },
		           3usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalIsoDepAttribCmd__bindgen_ty_1),
			"::",
			stringify!(PARAM4)
		)
		);
	}
	test_field_PARAM4();
}
#[test]
fn bindgen_test_layout_rfalIsoDepAttribCmd() {
	assert_eq!(
	           ::core::mem::size_of::<rfalIsoDepAttribCmd>(),
	           41usize,
	           concat!("Size of: ", stringify!(rfalIsoDepAttribCmd))
	);
	assert_eq!(
	           ::core::mem::align_of::<rfalIsoDepAttribCmd>(),
	           1usize,
	           concat!("Alignment of ", stringify!(rfalIsoDepAttribCmd))
	);
	fn test_field_cmd() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalIsoDepAttribCmd>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).cmd) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(rfalIsoDepAttribCmd), "::", stringify!(cmd))
		);
	}
	test_field_cmd();
	fn test_field_nfcid0() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalIsoDepAttribCmd>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).nfcid0) as usize - ptr as usize
		           },
		           1usize,
		           concat!("Offset of field: ", stringify!(rfalIsoDepAttribCmd), "::", stringify!(nfcid0))
		);
	}
	test_field_nfcid0();
	fn test_field_Param() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalIsoDepAttribCmd>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).Param) as usize - ptr as usize
		           },
		           5usize,
		           concat!("Offset of field: ", stringify!(rfalIsoDepAttribCmd), "::", stringify!(Param))
		);
	}
	test_field_Param();
	fn test_field_HLInfo() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalIsoDepAttribCmd>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).HLInfo) as usize - ptr as usize
		           },
		           9usize,
		           concat!("Offset of field: ", stringify!(rfalIsoDepAttribCmd), "::", stringify!(HLInfo))
		);
	}
	test_field_HLInfo();
}
#[doc = " ATTRIB Response Format  Digital 1.1  15.6.2"]
#[repr(C)]
pub struct rfalIsoDepAttribRes {
	#[doc = "< Contains MBLI and DID"]
	pub mbliDid: u8,
	#[doc = "< Higher Layer Information"]
	pub HLInfo: [u8; 32usize],
}
#[test]
fn bindgen_test_layout_rfalIsoDepAttribRes() {
	assert_eq!(
	           ::core::mem::size_of::<rfalIsoDepAttribRes>(),
	           33usize,
	           concat!("Size of: ", stringify!(rfalIsoDepAttribRes))
	);
	assert_eq!(
	           ::core::mem::align_of::<rfalIsoDepAttribRes>(),
	           1usize,
	           concat!("Alignment of ", stringify!(rfalIsoDepAttribRes))
	);
	fn test_field_mbliDid() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalIsoDepAttribRes>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).mbliDid) as usize - ptr as usize
		           },
		           0usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalIsoDepAttribRes),
			"::",
			stringify!(mbliDid)
		)
		);
	}
	test_field_mbliDid();
	fn test_field_HLInfo() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalIsoDepAttribRes>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).HLInfo) as usize - ptr as usize
		           },
		           1usize,
		           concat!("Offset of field: ", stringify!(rfalIsoDepAttribRes), "::", stringify!(HLInfo))
		);
	}
	test_field_HLInfo();
}
#[doc = " Activation info as Poller and Listener for NFC-A and NFC-B"]
#[repr(C)]
pub struct rfalIsoDepActivation {
	pub A: __BindgenUnionField<rfalIsoDepActivation__bindgen_ty_1>,
	pub B: __BindgenUnionField<rfalIsoDepActivation__bindgen_ty_2>,
	pub bindgen_union_field: [u8; 42usize],
}
#[doc = " NFC-A information"]
#[repr(C)]
pub struct rfalIsoDepActivation__bindgen_ty_1 {
	pub Listener: __BindgenUnionField<rfalIsoDepActivation__bindgen_ty_1__bindgen_ty_1>,
	pub Poller: __BindgenUnionField<rfalIsoDepActivation__bindgen_ty_1__bindgen_ty_2>,
	pub bindgen_union_field: [u8; 21usize],
}
#[repr(C)]
pub struct rfalIsoDepActivation__bindgen_ty_1__bindgen_ty_1 {
	#[doc = "< ATS response            (Poller mode)"]
	pub ATS: rfalIsoDepAts,
	#[doc = "< ATS response length     (Poller mode)"]
	pub ATSLen: u8,
}
#[test]
fn bindgen_test_layout_rfalIsoDepActivation__bindgen_ty_1__bindgen_ty_1() {
	assert_eq!(
	           ::core::mem::size_of::<rfalIsoDepActivation__bindgen_ty_1__bindgen_ty_1>(),
	           21usize,
	           concat!("Size of: ", stringify!(rfalIsoDepActivation__bindgen_ty_1__bindgen_ty_1))
	);
	assert_eq!(
	           ::core::mem::align_of::<rfalIsoDepActivation__bindgen_ty_1__bindgen_ty_1>(),
	           1usize,
	           concat!("Alignment of ", stringify!(rfalIsoDepActivation__bindgen_ty_1__bindgen_ty_1))
	);
	fn test_field_ATS() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalIsoDepActivation__bindgen_ty_1__bindgen_ty_1>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).ATS) as usize - ptr as usize
		           },
		           0usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalIsoDepActivation__bindgen_ty_1__bindgen_ty_1),
			"::",
			stringify!(ATS)
		)
		);
	}
	test_field_ATS();
	fn test_field_ATSLen() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalIsoDepActivation__bindgen_ty_1__bindgen_ty_1>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).ATSLen) as usize - ptr as usize
		           },
		           20usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalIsoDepActivation__bindgen_ty_1__bindgen_ty_1),
			"::",
			stringify!(ATSLen)
		)
		);
	}
	test_field_ATSLen();
}
#[repr(C)]
pub struct rfalIsoDepActivation__bindgen_ty_1__bindgen_ty_2 {
	#[doc = "< RATS request          (Listener mode)"]
	pub RATS: rfalIsoDepRats,
}
#[test]
fn bindgen_test_layout_rfalIsoDepActivation__bindgen_ty_1__bindgen_ty_2() {
	assert_eq!(
	           ::core::mem::size_of::<rfalIsoDepActivation__bindgen_ty_1__bindgen_ty_2>(),
	           2usize,
	           concat!("Size of: ", stringify!(rfalIsoDepActivation__bindgen_ty_1__bindgen_ty_2))
	);
	assert_eq!(
	           ::core::mem::align_of::<rfalIsoDepActivation__bindgen_ty_1__bindgen_ty_2>(),
	           1usize,
	           concat!("Alignment of ", stringify!(rfalIsoDepActivation__bindgen_ty_1__bindgen_ty_2))
	);
	fn test_field_RATS() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalIsoDepActivation__bindgen_ty_1__bindgen_ty_2>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).RATS) as usize - ptr as usize
		           },
		           0usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalIsoDepActivation__bindgen_ty_1__bindgen_ty_2),
			"::",
			stringify!(RATS)
		)
		);
	}
	test_field_RATS();
}
#[test]
fn bindgen_test_layout_rfalIsoDepActivation__bindgen_ty_1() {
	assert_eq!(
	           ::core::mem::size_of::<rfalIsoDepActivation__bindgen_ty_1>(),
	           21usize,
	           concat!("Size of: ", stringify!(rfalIsoDepActivation__bindgen_ty_1))
	);
	assert_eq!(
	           ::core::mem::align_of::<rfalIsoDepActivation__bindgen_ty_1>(),
	           1usize,
	           concat!("Alignment of ", stringify!(rfalIsoDepActivation__bindgen_ty_1))
	);
	fn test_field_Listener() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalIsoDepActivation__bindgen_ty_1>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).Listener) as usize - ptr as usize
		           },
		           0usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalIsoDepActivation__bindgen_ty_1),
			"::",
			stringify!(Listener)
		)
		);
	}
	test_field_Listener();
	fn test_field_Poller() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalIsoDepActivation__bindgen_ty_1>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).Poller) as usize - ptr as usize
		           },
		           0usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalIsoDepActivation__bindgen_ty_1),
			"::",
			stringify!(Poller)
		)
		);
	}
	test_field_Poller();
}
#[doc = " NFC-B information"]
#[repr(C)]
pub struct rfalIsoDepActivation__bindgen_ty_2 {
	pub Listener: __BindgenUnionField<rfalIsoDepActivation__bindgen_ty_2__bindgen_ty_1>,
	pub Poller: __BindgenUnionField<rfalIsoDepActivation__bindgen_ty_2__bindgen_ty_2>,
	pub bindgen_union_field: [u8; 42usize],
}
#[repr(C)]
pub struct rfalIsoDepActivation__bindgen_ty_2__bindgen_ty_1 {
	#[doc = "< ATTRIB_RES              (Poller mode)"]
	pub ATTRIB_RES: rfalIsoDepAttribRes,
	#[doc = "< ATTRIB_RES length       (Poller mode)"]
	pub ATTRIB_RESLen: u8,
}
#[test]
fn bindgen_test_layout_rfalIsoDepActivation__bindgen_ty_2__bindgen_ty_1() {
	assert_eq!(
	           ::core::mem::size_of::<rfalIsoDepActivation__bindgen_ty_2__bindgen_ty_1>(),
	           34usize,
	           concat!("Size of: ", stringify!(rfalIsoDepActivation__bindgen_ty_2__bindgen_ty_1))
	);
	assert_eq!(
	           ::core::mem::align_of::<rfalIsoDepActivation__bindgen_ty_2__bindgen_ty_1>(),
	           1usize,
	           concat!("Alignment of ", stringify!(rfalIsoDepActivation__bindgen_ty_2__bindgen_ty_1))
	);
	fn test_field_ATTRIB_RES() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalIsoDepActivation__bindgen_ty_2__bindgen_ty_1>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).ATTRIB_RES) as usize - ptr as usize
		           },
		           0usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalIsoDepActivation__bindgen_ty_2__bindgen_ty_1),
			"::",
			stringify!(ATTRIB_RES)
		)
		);
	}
	test_field_ATTRIB_RES();
	fn test_field_ATTRIB_RESLen() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalIsoDepActivation__bindgen_ty_2__bindgen_ty_1>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).ATTRIB_RESLen) as usize - ptr as usize
		           },
		           33usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalIsoDepActivation__bindgen_ty_2__bindgen_ty_1),
			"::",
			stringify!(ATTRIB_RESLen)
		)
		);
	}
	test_field_ATTRIB_RESLen();
}
#[repr(C)]
pub struct rfalIsoDepActivation__bindgen_ty_2__bindgen_ty_2 {
	#[doc = "< ATTRIB request        (Listener mode)"]
	pub ATTRIB: rfalIsoDepAttribCmd,
	#[doc = "< ATTRIB request length (Listener mode)"]
	pub ATTRIBLen: u8,
}
#[test]
fn bindgen_test_layout_rfalIsoDepActivation__bindgen_ty_2__bindgen_ty_2() {
	assert_eq!(
	           ::core::mem::size_of::<rfalIsoDepActivation__bindgen_ty_2__bindgen_ty_2>(),
	           42usize,
	           concat!("Size of: ", stringify!(rfalIsoDepActivation__bindgen_ty_2__bindgen_ty_2))
	);
	assert_eq!(
	           ::core::mem::align_of::<rfalIsoDepActivation__bindgen_ty_2__bindgen_ty_2>(),
	           1usize,
	           concat!("Alignment of ", stringify!(rfalIsoDepActivation__bindgen_ty_2__bindgen_ty_2))
	);
	fn test_field_ATTRIB() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalIsoDepActivation__bindgen_ty_2__bindgen_ty_2>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).ATTRIB) as usize - ptr as usize
		           },
		           0usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalIsoDepActivation__bindgen_ty_2__bindgen_ty_2),
			"::",
			stringify!(ATTRIB)
		)
		);
	}
	test_field_ATTRIB();
	fn test_field_ATTRIBLen() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalIsoDepActivation__bindgen_ty_2__bindgen_ty_2>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).ATTRIBLen) as usize - ptr as usize
		           },
		           41usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalIsoDepActivation__bindgen_ty_2__bindgen_ty_2),
			"::",
			stringify!(ATTRIBLen)
		)
		);
	}
	test_field_ATTRIBLen();
}
#[test]
fn bindgen_test_layout_rfalIsoDepActivation__bindgen_ty_2() {
	assert_eq!(
	           ::core::mem::size_of::<rfalIsoDepActivation__bindgen_ty_2>(),
	           42usize,
	           concat!("Size of: ", stringify!(rfalIsoDepActivation__bindgen_ty_2))
	);
	assert_eq!(
	           ::core::mem::align_of::<rfalIsoDepActivation__bindgen_ty_2>(),
	           1usize,
	           concat!("Alignment of ", stringify!(rfalIsoDepActivation__bindgen_ty_2))
	);
	fn test_field_Listener() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalIsoDepActivation__bindgen_ty_2>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).Listener) as usize - ptr as usize
		           },
		           0usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalIsoDepActivation__bindgen_ty_2),
			"::",
			stringify!(Listener)
		)
		);
	}
	test_field_Listener();
	fn test_field_Poller() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalIsoDepActivation__bindgen_ty_2>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).Poller) as usize - ptr as usize
		           },
		           0usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalIsoDepActivation__bindgen_ty_2),
			"::",
			stringify!(Poller)
		)
		);
	}
	test_field_Poller();
}
#[test]
fn bindgen_test_layout_rfalIsoDepActivation() {
	assert_eq!(
	           ::core::mem::size_of::<rfalIsoDepActivation>(),
	           42usize,
	           concat!("Size of: ", stringify!(rfalIsoDepActivation))
	);
	assert_eq!(
	           ::core::mem::align_of::<rfalIsoDepActivation>(),
	           1usize,
	           concat!("Alignment of ", stringify!(rfalIsoDepActivation))
	);
	fn test_field_A() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalIsoDepActivation>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).A) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(rfalIsoDepActivation), "::", stringify!(A))
		);
	}
	test_field_A();
	fn test_field_B() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalIsoDepActivation>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).B) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(rfalIsoDepActivation), "::", stringify!(B))
		);
	}
	test_field_B();
}
#[doc = " ISO-DEP device Info"]
#[repr(C)]
pub struct rfalIsoDepInfo {
	#[doc = "< Frame Waiting Integer"]
	pub FWI: u8,
	#[doc = "< Frame Waiting Time (1/fc)"]
	pub FWT: u32,
	#[doc = "< Delta Frame Waiting Time (1/fc)"]
	pub dFWT: u32,
	#[doc = "< Start-up Frame Guard time Integer"]
	pub SFGI: u32,
	#[doc = "< Start-up Frame Guard Time (ms)"]
	pub SFGT: u32,
	#[doc = "< Frame Size Device/Card Integer (FSDI or FSCI)"]
	pub FSxI: u8,
	#[doc = "< Frame Size Device/Card (FSD or FSC)"]
	pub FSx: u16,
	#[doc = "< Maximum Buffer Length (optional for NFC-B)"]
	pub MBL: u32,
	#[doc = "< Bit Rate coding from Listener (PICC) to Poller (PCD)"]
	pub DSI: rfalBitRate,
	#[doc = "< Bit Rate coding from Poller (PCD) to Listener (PICC)"]
	pub DRI: rfalBitRate,
	#[doc = "< Device ID"]
	pub DID: u8,
	#[doc = "< Node ADdress"]
	pub NAD: u8,
	#[doc = "< DID supported flag"]
	pub supDID: bool,
	#[doc = "< NAD supported flag"]
	pub supNAD: bool,
	#[doc = "< Advanced Features supported flag"]
	pub supAdFt: bool,
}
#[test]
fn bindgen_test_layout_rfalIsoDepInfo() {
	assert_eq!(
	           ::core::mem::size_of::<rfalIsoDepInfo>(),
	           44usize,
	           concat!("Size of: ", stringify!(rfalIsoDepInfo))
	);
	assert_eq!(
	           ::core::mem::align_of::<rfalIsoDepInfo>(),
	           4usize,
	           concat!("Alignment of ", stringify!(rfalIsoDepInfo))
	);
	fn test_field_FWI() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalIsoDepInfo>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).FWI) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(rfalIsoDepInfo), "::", stringify!(FWI))
		);
	}
	test_field_FWI();
	fn test_field_FWT() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalIsoDepInfo>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).FWT) as usize - ptr as usize
		           },
		           4usize,
		           concat!("Offset of field: ", stringify!(rfalIsoDepInfo), "::", stringify!(FWT))
		);
	}
	test_field_FWT();
	fn test_field_dFWT() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalIsoDepInfo>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).dFWT) as usize - ptr as usize
		           },
		           8usize,
		           concat!("Offset of field: ", stringify!(rfalIsoDepInfo), "::", stringify!(dFWT))
		);
	}
	test_field_dFWT();
	fn test_field_SFGI() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalIsoDepInfo>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).SFGI) as usize - ptr as usize
		           },
		           12usize,
		           concat!("Offset of field: ", stringify!(rfalIsoDepInfo), "::", stringify!(SFGI))
		);
	}
	test_field_SFGI();
	fn test_field_SFGT() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalIsoDepInfo>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).SFGT) as usize - ptr as usize
		           },
		           16usize,
		           concat!("Offset of field: ", stringify!(rfalIsoDepInfo), "::", stringify!(SFGT))
		);
	}
	test_field_SFGT();
	fn test_field_FSxI() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalIsoDepInfo>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).FSxI) as usize - ptr as usize
		           },
		           20usize,
		           concat!("Offset of field: ", stringify!(rfalIsoDepInfo), "::", stringify!(FSxI))
		);
	}
	test_field_FSxI();
	fn test_field_FSx() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalIsoDepInfo>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).FSx) as usize - ptr as usize
		           },
		           22usize,
		           concat!("Offset of field: ", stringify!(rfalIsoDepInfo), "::", stringify!(FSx))
		);
	}
	test_field_FSx();
	fn test_field_MBL() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalIsoDepInfo>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).MBL) as usize - ptr as usize
		           },
		           24usize,
		           concat!("Offset of field: ", stringify!(rfalIsoDepInfo), "::", stringify!(MBL))
		);
	}
	test_field_MBL();
	fn test_field_DSI() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalIsoDepInfo>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).DSI) as usize - ptr as usize
		           },
		           28usize,
		           concat!("Offset of field: ", stringify!(rfalIsoDepInfo), "::", stringify!(DSI))
		);
	}
	test_field_DSI();
	fn test_field_DRI() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalIsoDepInfo>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).DRI) as usize - ptr as usize
		           },
		           32usize,
		           concat!("Offset of field: ", stringify!(rfalIsoDepInfo), "::", stringify!(DRI))
		);
	}
	test_field_DRI();
	fn test_field_DID() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalIsoDepInfo>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).DID) as usize - ptr as usize
		           },
		           36usize,
		           concat!("Offset of field: ", stringify!(rfalIsoDepInfo), "::", stringify!(DID))
		);
	}
	test_field_DID();
	fn test_field_NAD() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalIsoDepInfo>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).NAD) as usize - ptr as usize
		           },
		           37usize,
		           concat!("Offset of field: ", stringify!(rfalIsoDepInfo), "::", stringify!(NAD))
		);
	}
	test_field_NAD();
	fn test_field_supDID() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalIsoDepInfo>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).supDID) as usize - ptr as usize
		           },
		           38usize,
		           concat!("Offset of field: ", stringify!(rfalIsoDepInfo), "::", stringify!(supDID))
		);
	}
	test_field_supDID();
	fn test_field_supNAD() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalIsoDepInfo>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).supNAD) as usize - ptr as usize
		           },
		           39usize,
		           concat!("Offset of field: ", stringify!(rfalIsoDepInfo), "::", stringify!(supNAD))
		);
	}
	test_field_supNAD();
	fn test_field_supAdFt() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalIsoDepInfo>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).supAdFt) as usize - ptr as usize
		           },
		           40usize,
		           concat!("Offset of field: ", stringify!(rfalIsoDepInfo), "::", stringify!(supAdFt))
		);
	}
	test_field_supAdFt();
}
#[doc = " ISO-DEP Device structure"]
#[repr(C)]
pub struct rfalIsoDepDevice {
	#[doc = "< Activation Info"]
	pub activation: rfalIsoDepActivation,
	#[doc = "< ISO-DEP (ISO14443-4) device Info"]
	pub info: rfalIsoDepInfo,
}
#[test]
fn bindgen_test_layout_rfalIsoDepDevice() {
	assert_eq!(
	           ::core::mem::size_of::<rfalIsoDepDevice>(),
	           88usize,
	           concat!("Size of: ", stringify!(rfalIsoDepDevice))
	);
	assert_eq!(
	           ::core::mem::align_of::<rfalIsoDepDevice>(),
	           4usize,
	           concat!("Alignment of ", stringify!(rfalIsoDepDevice))
	);
	fn test_field_activation() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalIsoDepDevice>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).activation) as usize - ptr as usize
		           },
		           0usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalIsoDepDevice),
			"::",
			stringify!(activation)
		)
		);
	}
	test_field_activation();
	fn test_field_info() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalIsoDepDevice>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).info) as usize - ptr as usize
		           },
		           44usize,
		           concat!("Offset of field: ", stringify!(rfalIsoDepDevice), "::", stringify!(info))
		);
	}
	test_field_info();
}
#[doc = " ATTRIB Response parameters"]
#[repr(C)]
pub struct rfalIsoDepAttribResParam {
	#[doc = "< MBLI"]
	pub mbli: u8,
	#[doc = "< Hi Layer Information"]
	pub HLInfo: [u8; 32usize],
	#[doc = "< Hi Layer Information Length"]
	pub HLInfoLen: u8,
}
#[test]
fn bindgen_test_layout_rfalIsoDepAttribResParam() {
	assert_eq!(
	           ::core::mem::size_of::<rfalIsoDepAttribResParam>(),
	           34usize,
	           concat!("Size of: ", stringify!(rfalIsoDepAttribResParam))
	);
	assert_eq!(
	           ::core::mem::align_of::<rfalIsoDepAttribResParam>(),
	           1usize,
	           concat!("Alignment of ", stringify!(rfalIsoDepAttribResParam))
	);
	fn test_field_mbli() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalIsoDepAttribResParam>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).mbli) as usize - ptr as usize
		           },
		           0usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalIsoDepAttribResParam),
			"::",
			stringify!(mbli)
		)
		);
	}
	test_field_mbli();
	fn test_field_HLInfo() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalIsoDepAttribResParam>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).HLInfo) as usize - ptr as usize
		           },
		           1usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalIsoDepAttribResParam),
			"::",
			stringify!(HLInfo)
		)
		);
	}
	test_field_HLInfo();
	fn test_field_HLInfoLen() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalIsoDepAttribResParam>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).HLInfoLen) as usize - ptr as usize
		           },
		           33usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalIsoDepAttribResParam),
			"::",
			stringify!(HLInfoLen)
		)
		);
	}
	test_field_HLInfoLen();
}
#[doc = " ATS Response parameter"]
#[repr(C)]
pub struct rfalIsoDepAtsParam {
	#[doc = "< Frame Size of Proximity Card Integer"]
	pub fsci: u8,
	#[doc = "< Frame Waiting Time Integer"]
	pub fwi: u8,
	#[doc = "< Start-Up Frame Guard Time Integer"]
	pub sfgi: u8,
	#[doc = "< DID Supported"]
	pub didSupport: bool,
	#[doc = "< Max supported bitrate both direction"]
	pub ta: u8,
	#[doc = "< Historical Bytes data"]
	pub hb: *mut u8,
	#[doc = "< Historical Bytes Length"]
	pub hbLen: u8,
}
#[test]
fn bindgen_test_layout_rfalIsoDepAtsParam() {
	assert_eq!(
	           ::core::mem::size_of::<rfalIsoDepAtsParam>(),
	           16usize,
	           concat!("Size of: ", stringify!(rfalIsoDepAtsParam))
	);
	assert_eq!(
	           ::core::mem::align_of::<rfalIsoDepAtsParam>(),
	           4usize,
	           concat!("Alignment of ", stringify!(rfalIsoDepAtsParam))
	);
	fn test_field_fsci() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalIsoDepAtsParam>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).fsci) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(rfalIsoDepAtsParam), "::", stringify!(fsci))
		);
	}
	test_field_fsci();
	fn test_field_fwi() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalIsoDepAtsParam>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).fwi) as usize - ptr as usize
		           },
		           1usize,
		           concat!("Offset of field: ", stringify!(rfalIsoDepAtsParam), "::", stringify!(fwi))
		);
	}
	test_field_fwi();
	fn test_field_sfgi() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalIsoDepAtsParam>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).sfgi) as usize - ptr as usize
		           },
		           2usize,
		           concat!("Offset of field: ", stringify!(rfalIsoDepAtsParam), "::", stringify!(sfgi))
		);
	}
	test_field_sfgi();
	fn test_field_didSupport() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalIsoDepAtsParam>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).didSupport) as usize - ptr as usize
		           },
		           3usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalIsoDepAtsParam),
			"::",
			stringify!(didSupport)
		)
		);
	}
	test_field_didSupport();
	fn test_field_ta() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalIsoDepAtsParam>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).ta) as usize - ptr as usize
		           },
		           4usize,
		           concat!("Offset of field: ", stringify!(rfalIsoDepAtsParam), "::", stringify!(ta))
		);
	}
	test_field_ta();
	fn test_field_hb() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalIsoDepAtsParam>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).hb) as usize - ptr as usize
		           },
		           8usize,
		           concat!("Offset of field: ", stringify!(rfalIsoDepAtsParam), "::", stringify!(hb))
		);
	}
	test_field_hb();
	fn test_field_hbLen() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalIsoDepAtsParam>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).hbLen) as usize - ptr as usize
		           },
		           12usize,
		           concat!("Offset of field: ", stringify!(rfalIsoDepAtsParam), "::", stringify!(hbLen))
		);
	}
	test_field_hbLen();
}
#[doc = " Structure of I-Block Buffer format from caller"]
#[repr(C)]
pub struct rfalIsoDepBufFormat {
	#[doc = "< Prologue/SoD buffer"]
	pub prologue: [u8; 3usize],
	#[doc = "< INF/Payload buffer"]
	pub inf: [u8; 256usize],
}
#[test]
fn bindgen_test_layout_rfalIsoDepBufFormat() {
	assert_eq!(
	           ::core::mem::size_of::<rfalIsoDepBufFormat>(),
	           259usize,
	           concat!("Size of: ", stringify!(rfalIsoDepBufFormat))
	);
	assert_eq!(
	           ::core::mem::align_of::<rfalIsoDepBufFormat>(),
	           1usize,
	           concat!("Alignment of ", stringify!(rfalIsoDepBufFormat))
	);
	fn test_field_prologue() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalIsoDepBufFormat>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).prologue) as usize - ptr as usize
		           },
		           0usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalIsoDepBufFormat),
			"::",
			stringify!(prologue)
		)
		);
	}
	test_field_prologue();
	fn test_field_inf() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalIsoDepBufFormat>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).inf) as usize - ptr as usize
		           },
		           3usize,
		           concat!("Offset of field: ", stringify!(rfalIsoDepBufFormat), "::", stringify!(inf))
		);
	}
	test_field_inf();
}
#[doc = " Structure of APDU Buffer format from caller"]
#[repr(C)]
pub struct rfalIsoDepApduBufFormat {
	#[doc = "< Prologue/SoD buffer"]
	pub prologue: [u8; 3usize],
	#[doc = "< APDU/Payload buffer"]
	pub apdu: [u8; 512usize],
}
#[test]
fn bindgen_test_layout_rfalIsoDepApduBufFormat() {
	assert_eq!(
	           ::core::mem::size_of::<rfalIsoDepApduBufFormat>(),
	           515usize,
	           concat!("Size of: ", stringify!(rfalIsoDepApduBufFormat))
	);
	assert_eq!(
	           ::core::mem::align_of::<rfalIsoDepApduBufFormat>(),
	           1usize,
	           concat!("Alignment of ", stringify!(rfalIsoDepApduBufFormat))
	);
	fn test_field_prologue() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalIsoDepApduBufFormat>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).prologue) as usize - ptr as usize
		           },
		           0usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalIsoDepApduBufFormat),
			"::",
			stringify!(prologue)
		)
		);
	}
	test_field_prologue();
	fn test_field_apdu() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalIsoDepApduBufFormat>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).apdu) as usize - ptr as usize
		           },
		           3usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalIsoDepApduBufFormat),
			"::",
			stringify!(apdu)
		)
		);
	}
	test_field_apdu();
}
#[doc = " Listen Activation Parameters Structure"]
#[repr(C)]
pub struct rfalIsoDepListenActvParam {
	#[doc = "< Receive Buffer struct reference"]
	pub rxBuf: *mut rfalIsoDepBufFormat,
	#[doc = "< Received INF data length in Bytes"]
	pub rxLen: *mut u16,
	#[doc = "< Received data is not complete"]
	pub isRxChaining: *mut bool,
	#[doc = "< ISO-DEP device info"]
	pub isoDepDev: *mut rfalIsoDepDevice,
}
#[test]
fn bindgen_test_layout_rfalIsoDepListenActvParam() {
	assert_eq!(
	           ::core::mem::size_of::<rfalIsoDepListenActvParam>(),
	           16usize,
	           concat!("Size of: ", stringify!(rfalIsoDepListenActvParam))
	);
	assert_eq!(
	           ::core::mem::align_of::<rfalIsoDepListenActvParam>(),
	           4usize,
	           concat!("Alignment of ", stringify!(rfalIsoDepListenActvParam))
	);
	fn test_field_rxBuf() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalIsoDepListenActvParam>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).rxBuf) as usize - ptr as usize
		           },
		           0usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalIsoDepListenActvParam),
			"::",
			stringify!(rxBuf)
		)
		);
	}
	test_field_rxBuf();
	fn test_field_rxLen() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalIsoDepListenActvParam>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).rxLen) as usize - ptr as usize
		           },
		           4usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalIsoDepListenActvParam),
			"::",
			stringify!(rxLen)
		)
		);
	}
	test_field_rxLen();
	fn test_field_isRxChaining() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalIsoDepListenActvParam>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).isRxChaining) as usize - ptr as usize
		           },
		           8usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalIsoDepListenActvParam),
			"::",
			stringify!(isRxChaining)
		)
		);
	}
	test_field_isRxChaining();
	fn test_field_isoDepDev() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalIsoDepListenActvParam>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).isoDepDev) as usize - ptr as usize
		           },
		           12usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalIsoDepListenActvParam),
			"::",
			stringify!(isoDepDev)
		)
		);
	}
	test_field_isoDepDev();
}
#[doc = " Structure of parameters used on ISO DEP Transceive"]
#[repr(C)]
pub struct rfalIsoDepTxRxParam {
	#[doc = "< Transmit Buffer struct reference"]
	pub txBuf: *mut rfalIsoDepBufFormat,
	#[doc = "< Transmit Buffer INF field length in Bytes"]
	pub txBufLen: u16,
	#[doc = "< Transmit data is not complete"]
	pub isTxChaining: bool,
	#[doc = "< Receive Buffer struct reference in Bytes"]
	pub rxBuf: *mut rfalIsoDepBufFormat,
	#[doc = "< Received INF data length in Bytes"]
	pub rxLen: *mut u16,
	#[doc = "< Received data is not complete"]
	pub isRxChaining: *mut bool,
	#[doc = "< FWT to be used (ignored in Listen Mode)"]
	pub FWT: u32,
	#[doc = "< Delta FWT to be used"]
	pub dFWT: u32,
	#[doc = "< Our device Frame Size (FSD or FSC)"]
	pub ourFSx: u16,
	#[doc = "< Other device Frame Size (FSD or FSC)"]
	pub FSx: u16,
	#[doc = "< Device ID (RFAL_ISODEP_NO_DID if no DID)"]
	pub DID: u8,
}
#[test]
fn bindgen_test_layout_rfalIsoDepTxRxParam() {
	assert_eq!(
	           ::core::mem::size_of::<rfalIsoDepTxRxParam>(),
	           36usize,
	           concat!("Size of: ", stringify!(rfalIsoDepTxRxParam))
	);
	assert_eq!(
	           ::core::mem::align_of::<rfalIsoDepTxRxParam>(),
	           4usize,
	           concat!("Alignment of ", stringify!(rfalIsoDepTxRxParam))
	);
	fn test_field_txBuf() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalIsoDepTxRxParam>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).txBuf) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(rfalIsoDepTxRxParam), "::", stringify!(txBuf))
		);
	}
	test_field_txBuf();
	fn test_field_txBufLen() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalIsoDepTxRxParam>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).txBufLen) as usize - ptr as usize
		           },
		           4usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalIsoDepTxRxParam),
			"::",
			stringify!(txBufLen)
		)
		);
	}
	test_field_txBufLen();
	fn test_field_isTxChaining() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalIsoDepTxRxParam>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).isTxChaining) as usize - ptr as usize
		           },
		           6usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalIsoDepTxRxParam),
			"::",
			stringify!(isTxChaining)
		)
		);
	}
	test_field_isTxChaining();
	fn test_field_rxBuf() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalIsoDepTxRxParam>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).rxBuf) as usize - ptr as usize
		           },
		           8usize,
		           concat!("Offset of field: ", stringify!(rfalIsoDepTxRxParam), "::", stringify!(rxBuf))
		);
	}
	test_field_rxBuf();
	fn test_field_rxLen() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalIsoDepTxRxParam>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).rxLen) as usize - ptr as usize
		           },
		           12usize,
		           concat!("Offset of field: ", stringify!(rfalIsoDepTxRxParam), "::", stringify!(rxLen))
		);
	}
	test_field_rxLen();
	fn test_field_isRxChaining() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalIsoDepTxRxParam>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).isRxChaining) as usize - ptr as usize
		           },
		           16usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalIsoDepTxRxParam),
			"::",
			stringify!(isRxChaining)
		)
		);
	}
	test_field_isRxChaining();
	fn test_field_FWT() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalIsoDepTxRxParam>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).FWT) as usize - ptr as usize
		           },
		           20usize,
		           concat!("Offset of field: ", stringify!(rfalIsoDepTxRxParam), "::", stringify!(FWT))
		);
	}
	test_field_FWT();
	fn test_field_dFWT() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalIsoDepTxRxParam>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).dFWT) as usize - ptr as usize
		           },
		           24usize,
		           concat!("Offset of field: ", stringify!(rfalIsoDepTxRxParam), "::", stringify!(dFWT))
		);
	}
	test_field_dFWT();
	fn test_field_ourFSx() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalIsoDepTxRxParam>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).ourFSx) as usize - ptr as usize
		           },
		           28usize,
		           concat!("Offset of field: ", stringify!(rfalIsoDepTxRxParam), "::", stringify!(ourFSx))
		);
	}
	test_field_ourFSx();
	fn test_field_FSx() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalIsoDepTxRxParam>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).FSx) as usize - ptr as usize
		           },
		           30usize,
		           concat!("Offset of field: ", stringify!(rfalIsoDepTxRxParam), "::", stringify!(FSx))
		);
	}
	test_field_FSx();
	fn test_field_DID() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalIsoDepTxRxParam>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).DID) as usize - ptr as usize
		           },
		           32usize,
		           concat!("Offset of field: ", stringify!(rfalIsoDepTxRxParam), "::", stringify!(DID))
		);
	}
	test_field_DID();
}
#[doc = " Structure of parameters used on ISO DEP APDU Transceive"]
#[repr(C)]
pub struct rfalIsoDepApduTxRxParam {
	#[doc = "< Transmit Buffer struct reference"]
	pub txBuf: *mut rfalIsoDepApduBufFormat,
	#[doc = "< Transmit Buffer INF field length in Bytes"]
	pub txBufLen: u16,
	#[doc = "< Receive Buffer struct reference in Bytes"]
	pub rxBuf: *mut rfalIsoDepApduBufFormat,
	#[doc = "< Received INF data length in Bytes"]
	pub rxLen: *mut u16,
	#[doc = "< Temp buffer for Rx I-Blocks (internal)"]
	pub tmpBuf: *mut rfalIsoDepBufFormat,
	#[doc = "< FWT to be used (ignored in Listen Mode)"]
	pub FWT: u32,
	#[doc = "< Delta FWT to be used"]
	pub dFWT: u32,
	#[doc = "< Other device Frame Size (FSD or FSC)"]
	pub FSx: u16,
	#[doc = "< Our device Frame Size (FSD or FSC)"]
	pub ourFSx: u16,
	#[doc = "< Device ID (RFAL_ISODEP_NO_DID if no DID)"]
	pub DID: u8,
}
#[test]
fn bindgen_test_layout_rfalIsoDepApduTxRxParam() {
	assert_eq!(
	           ::core::mem::size_of::<rfalIsoDepApduTxRxParam>(),
	           36usize,
	           concat!("Size of: ", stringify!(rfalIsoDepApduTxRxParam))
	);
	assert_eq!(
	           ::core::mem::align_of::<rfalIsoDepApduTxRxParam>(),
	           4usize,
	           concat!("Alignment of ", stringify!(rfalIsoDepApduTxRxParam))
	);
	fn test_field_txBuf() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalIsoDepApduTxRxParam>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).txBuf) as usize - ptr as usize
		           },
		           0usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalIsoDepApduTxRxParam),
			"::",
			stringify!(txBuf)
		)
		);
	}
	test_field_txBuf();
	fn test_field_txBufLen() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalIsoDepApduTxRxParam>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).txBufLen) as usize - ptr as usize
		           },
		           4usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalIsoDepApduTxRxParam),
			"::",
			stringify!(txBufLen)
		)
		);
	}
	test_field_txBufLen();
	fn test_field_rxBuf() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalIsoDepApduTxRxParam>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).rxBuf) as usize - ptr as usize
		           },
		           8usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalIsoDepApduTxRxParam),
			"::",
			stringify!(rxBuf)
		)
		);
	}
	test_field_rxBuf();
	fn test_field_rxLen() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalIsoDepApduTxRxParam>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).rxLen) as usize - ptr as usize
		           },
		           12usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalIsoDepApduTxRxParam),
			"::",
			stringify!(rxLen)
		)
		);
	}
	test_field_rxLen();
	fn test_field_tmpBuf() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalIsoDepApduTxRxParam>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).tmpBuf) as usize - ptr as usize
		           },
		           16usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalIsoDepApduTxRxParam),
			"::",
			stringify!(tmpBuf)
		)
		);
	}
	test_field_tmpBuf();
	fn test_field_FWT() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalIsoDepApduTxRxParam>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).FWT) as usize - ptr as usize
		           },
		           20usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalIsoDepApduTxRxParam),
			"::",
			stringify!(FWT)
		)
		);
	}
	test_field_FWT();
	fn test_field_dFWT() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalIsoDepApduTxRxParam>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).dFWT) as usize - ptr as usize
		           },
		           24usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalIsoDepApduTxRxParam),
			"::",
			stringify!(dFWT)
		)
		);
	}
	test_field_dFWT();
	fn test_field_FSx() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalIsoDepApduTxRxParam>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).FSx) as usize - ptr as usize
		           },
		           28usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalIsoDepApduTxRxParam),
			"::",
			stringify!(FSx)
		)
		);
	}
	test_field_FSx();
	fn test_field_ourFSx() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalIsoDepApduTxRxParam>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).ourFSx) as usize - ptr as usize
		           },
		           30usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalIsoDepApduTxRxParam),
			"::",
			stringify!(ourFSx)
		)
		);
	}
	test_field_ourFSx();
	fn test_field_DID() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalIsoDepApduTxRxParam>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).DID) as usize - ptr as usize
		           },
		           32usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalIsoDepApduTxRxParam),
			"::",
			stringify!(DID)
		)
		);
	}
	test_field_DID();
}
extern "C" {
	#[doc = " \\brief Initialize the ISO-DEP protocol"]
	#[doc = ""]
	#[doc = " Initialize the ISO-DEP protocol layer with default config"]
	#[doc = ""]
	pub fn rfalIsoDepInitialize();
}
extern "C" {
	#[doc = " \\brief Initialize the ISO-DEP protocol"]
	#[doc = ""]
	#[doc = " Initialize the ISO-DEP protocol layer with additional parameters allowing"]
	#[doc = " to customise the protocol layer for specific behaviours"]
	#[doc = ""]
	#[doc = ""]
	#[doc = "  \\param[in] compMode        : Compliance mode to be performed"]
	#[doc = "  \\param[in] maxRetriesR     : Number of retries for a R-Block"]
	#[doc = "                                Digital 2.0 B9 - nRETRY ACK/NAK: [2,5]"]
	#[doc = "  \\param[in] maxRetriesSnWTX : Number of retries for a S(WTX) (only in case"]
	#[doc = "                               of NAKs)   Digital 2.0 B9 - nRETRY WTX[2,5]"]
	#[doc = "  \\param[in] maxRetriesSWTX  : Number of overall S(WTX) retries."]
	#[doc = "                                Use RFAL_ISODEP_MAX_WTX_RETRYS_ULTD for disabling"]
	#[doc = "                                this limit check   Digital 2.0  16.2.5.2"]
	#[doc = "  \\param[in] maxRetriesSDSL  : Number of retries for a S(DESELECT)"]
	#[doc = "                                Digital 2.0 B9 - nRETRY DESELECT: [0,5]"]
	#[doc = "  \\param[in] maxRetriesI     : Number of retries for a I-Block"]
	#[doc = "                                Digital 2.0  16.2.5.4"]
	#[doc = "  \\param[in] maxRetriesRATS  : Number of retries for RATS"]
	#[doc = "                                Digital 2.0 B7 - nRETRY RATS [0,1]"]
	#[doc = ""]
	#[doc = ""]
	pub fn rfalIsoDepInitializeWithParams(compMode: rfalComplianceMode,
	                                      maxRetriesR: u8,
	                                      maxRetriesSnWTX: u8,
	                                      maxRetriesSWTX: u8,
	                                      maxRetriesSDSL: u8,
	                                      maxRetriesI: u8,
	                                      maxRetriesRATS: u8);
}
extern "C" {
	#[doc = "  \\brief  FSxI to FSx"]
	#[doc = ""]
	#[doc = "  Convert Frame Size for proximity coupling Device Integer (FSxI) to"]
	#[doc = "  Frame Size for proximity coupling Device (FSx)"]
	#[doc = ""]
	#[doc = "  FSD - maximum frame size for NFC Forum Device in Poll Mode"]
	#[doc = "  FSC - maximum frame size for NFC Forum Device in Listen Mode"]
	#[doc = ""]
	#[doc = "  FSxI = FSDI or FSCI"]
	#[doc = "  FSx  = FSD or FSC"]
	#[doc = ""]
	#[doc = "  The FSD/FSC value includes the header and CRC"]
	#[doc = ""]
	#[doc = "  \\param[in] FSxI :  Frame Size for proximity coupling Device Integer"]
	#[doc = ""]
	#[doc = "  \\return fsx : Frame Size for proximity coupling Device (FSD or FSC)"]
	#[doc = ""]
	#[doc = ""]
	pub fn rfalIsoDepFSxI2FSx(FSxI: u8) -> u16;
}
extern "C" {
	#[doc = "  \\brief  FWI to FWT"]
	#[doc = ""]
	#[doc = "  Convert Frame Waiting time Integer (FWI) to Frame Waiting Time (FWT) in"]
	#[doc = "  1/fc units"]
	#[doc = ""]
	#[doc = "  \\param[in] fwi : Frame Waiting time Integer"]
	#[doc = ""]
	#[doc = "  \\return fwt : Frame Waiting Time in 1/fc units"]
	#[doc = ""]
	#[doc = ""]
	pub fn rfalIsoDepFWI2FWT(fwi: u8) -> u32;
}
extern "C" {
	#[doc = "  \\brief  Check if the buffer data contains a valid RATS command"]
	#[doc = ""]
	#[doc = "  Check if it is a  well formed RATS command with 2 bytes"]
	#[doc = "  This function does not check the validity of FSDI and DID"]
	#[doc = ""]
	#[doc = "  \\param[in] buf    : reference to buffer containing the data to be checked"]
	#[doc = "  \\param[in] bufLen : length of data in the buffer in bytes"]
	#[doc = ""]
	#[doc = "  \\return true if the data indicates a RATS command; false otherwise"]
	#[doc = ""]
	pub fn rfalIsoDepIsRats(buf: *const u8, bufLen: u8) -> bool;
}
extern "C" {
	#[doc = "  \\brief  Check if the buffer data contains a valid ATTRIB command"]
	#[doc = ""]
	#[doc = "  Check if it is a well formed ATTRIB command, but does not check the"]
	#[doc = "  validity of the information inside"]
	#[doc = ""]
	#[doc = "  \\param[in] buf    : reference to buffer containing the data to be checked"]
	#[doc = "  \\param[in] bufLen : length of data in the buffer in bytes"]
	#[doc = ""]
	#[doc = "  \\return true if the data indicates a ATTRIB command; false otherwise"]
	#[doc = ""]
	pub fn rfalIsoDepIsAttrib(buf: *const u8, bufLen: u8) -> bool;
}
extern "C" {
	#[doc = " \\brief Start Listen Activation Handling"]
	#[doc = ""]
	#[doc = " Start Listen Activation Handling and setup to receive first I-block which may"]
	#[doc = " contain complete or partial APDU after activation is completed"]
	#[doc = ""]
	#[doc = "  Pass in RATS for T4AT, or ATTRIB for T4BT, to handle ATS or ATTRIB Response respectively"]
	#[doc = "  The Activation Handling handles ATS and ATTRIB Response; and additionally PPS Response"]
	#[doc = "  if a PPS is received for T4AT."]
	#[doc = "  The method uses the current RFAL state machine to determine if it is expecting RATS or ATTRIB"]
	#[doc = ""]
	#[doc = "  Activation is completed if PPS Response is sent or if first PDU is received in T4T-A"]
	#[doc = "  Activation is completed if ATTRIB Response is sent in T4T-B"]
	#[doc = ""]
	#[doc = "  \\ref rfalIsoDepListenGetActivationStatus provide status if activation is completed."]
	#[doc = "  \\ref rfalIsoDepStartTransceive shall be called right after activation is completed"]
	#[doc = ""]
	#[doc = "  \\param[in] atsParam       : reference to ATS parameters"]
	#[doc = "  \\param[in] attribResParam : reference to ATTRIB_RES parameters"]
	#[doc = "  \\param[in] buf            : reference to buffer containing RATS or ATTRIB"]
	#[doc = "  \\param[in] bufLen         : length in bytes of the given bufffer"]
	#[doc = "  \\param[in] actParam       : reference to incoming reception information will be placed"]
	#[doc = ""]
	#[doc = ""]
	#[doc = "  \\warning Once the Activation has been completed the method"]
	#[doc = "  rfalIsoDepGetTransceiveStatus() must be called."]
	#[doc = "  If activation has completed due to reception of a data block (not PPS) the"]
	#[doc = "  buffer owned by the caller and passed on actParam must still contain this data."]
	#[doc = "  The first data will be processed (I-Block or S-DSL) by rfalIsoDepGetTransceiveStatus()"]
	#[doc = "  inform the caller and then for the next transaction use rfalIsoDepStartTransceive()"]
	#[doc = ""]
	#[doc = "  \\return ERR_NONE    : RATS/ATTRIB is valid and activation has started"]
	#[doc = "  \\return ERR_PARAM   : Invalid parameters"]
	#[doc = "  \\return ERR_PROTO   : Invalid request"]
	#[doc = "  \\return ERR_NOTSUPP : Feature not supported"]
	#[doc = ""]
	pub fn rfalIsoDepListenStartActivation(atsParam: *mut rfalIsoDepAtsParam,
	                                       attribResParam: *const rfalIsoDepAttribResParam,
	                                       buf: *const u8,
	                                       bufLen: u16,
	                                       actParam: rfalIsoDepListenActvParam)
	                                       -> ReturnCode;
}
extern "C" {
	#[doc = "  \\brief Get the current Activation Status"]
	#[doc = ""]
	#[doc = "  \\return ERR_NONE if Activation is already completed"]
	#[doc = "  \\return ERR_BUSY if Activation is ongoing"]
	#[doc = "  \\return ERR_LINK_LOSS if Remote Field is turned off"]
	#[doc = ""]
	pub fn rfalIsoDepListenGetActivationStatus() -> ReturnCode;
}
extern "C" {
	#[doc = "  \\brief Get the ISO-DEP Communication Information"]
	#[doc = ""]
	#[doc = "  Gets the maximum INF length in bytes based on current Frame Size"]
	#[doc = "  for proximity coupling Device (FSD or FSC) excluding the header and CRC"]
	#[doc = ""]
	#[doc = "  \\return maximum INF length in bytes"]
	#[doc = ""]
	pub fn rfalIsoDepGetMaxInfLen() -> u16;
}
extern "C" {
	#[doc = "  \\brief ISO-DEP Start Transceive"]
	#[doc = ""]
	#[doc = "  This method triggers a ISO-DEP Transceive containing a complete or"]
	#[doc = "  partial APDU"]
	#[doc = "  It transmits the given message and handles all protocol retransmitions,"]
	#[doc = "  error handling and control messages"]
	#[doc = ""]
	#[doc = "  The txBuf  contains a complete or partial APDU (INF) to be transmitted"]
	#[doc = "  The Prologue field will be manipulated by the Transceive"]
	#[doc = ""]
	#[doc = "  If the buffer contains a partial APDU and is not the last block,"]
	#[doc = "  then isTxChaining must be set to true"]
	#[doc = ""]
	#[doc = "  \\param[in] param: reference parameters to be used for the Transceive"]
	#[doc = ""]
	#[doc = "  \\return ERR_PARAM       : Bad request"]
	#[doc = "  \\return ERR_WRONG_STATE : The module is not in a proper state"]
	#[doc = "  \\return ERR_NONE        : The Transceive request has been started"]
	#[doc = ""]
	pub fn rfalIsoDepStartTransceive(param: rfalIsoDepTxRxParam) -> ReturnCode;
}
extern "C" {
	#[doc = "  \\brief Get the Transceive status"]
	#[doc = ""]
	#[doc = "  Returns the status of the ISO-DEP Transceive"]
	#[doc = ""]
	#[doc = "  \\warning  When the other device is performing chaining once a chained"]
	#[doc = "            block is received the error ERR_AGAIN is sent. At this point"]
	#[doc = "            caller must handle the received data immediately."]
	#[doc = "            When ERR_AGAIN is returned an ACK has already been sent to"]
	#[doc = "            the other device and the next block might be incoming."]
	#[doc = "            If rfalWorker() is called frequently it will place the next"]
	#[doc = "            block on the given buffer"]
	#[doc = ""]
	#[doc = ""]
	#[doc = "  \\return ERR_NONE      : Transceive has been completed successfully"]
	#[doc = "  \\return ERR_BUSY      : Transceive is ongoing"]
	#[doc = "  \\return ERR_PROTO     : Protocol error occurred"]
	#[doc = "  \\return ERR_TIMEOUT   : Timeout error occurred"]
	#[doc = "  \\return ERR_SLEEP_REQ : Deselect has been received and responded"]
	#[doc = "  \\return ERR_NOMEM     : The received INF does not fit into the"]
	#[doc = "                            receive buffer"]
	#[doc = "  \\return ERR_LINK_LOSS : Communication is lost because Reader/Writer"]
	#[doc = "                            has turned off its field"]
	#[doc = "  \\return ERR_AGAIN     : received one chaining block, continue to call"]
	#[doc = "                            this method to retrieve the remaining blocks"]
	#[doc = ""]
	pub fn rfalIsoDepGetTransceiveStatus() -> ReturnCode;
}
extern "C" {
	#[doc = "  \\brief ISO-DEP Start APDU Transceive"]
	#[doc = ""]
	#[doc = "  This method triggers a ISO-DEP Transceive containing a complete APDU"]
	#[doc = "  It transmits the given message and handles all protocol retransmitions,"]
	#[doc = "  error handling and control messages"]
	#[doc = ""]
	#[doc = "  The txBuf  contains a complete APDU to be transmitted"]
	#[doc = "  The Prologue field will be manipulated by the Transceive"]
	#[doc = ""]
	#[doc = "  \\warning the txBuf will be modified during the transmission"]
	#[doc = "  \\warning the maximum RF frame which can be received is limited by param.tmpBuf"]
	#[doc = ""]
	#[doc = "  \\param[in] param: reference parameters to be used for the Transceive"]
	#[doc = ""]
	#[doc = "  \\return ERR_PARAM       : Bad request"]
	#[doc = "  \\return ERR_WRONG_STATE : The module is not in a proper state"]
	#[doc = "  \\return ERR_NONE        : The Transceive request has been started"]
	#[doc = ""]
	pub fn rfalIsoDepStartApduTransceive(param: rfalIsoDepApduTxRxParam) -> ReturnCode;
}
extern "C" {
	#[doc = "  \\brief Get the APDU Transceive status"]
	#[doc = ""]
	#[doc = "  \\return ERR_NONE      : if Transceive has been completed successfully"]
	#[doc = "  \\return ERR_BUSY      : if Transceive is ongoing"]
	#[doc = "  \\return ERR_PROTO     : if a protocol error occurred"]
	#[doc = "  \\return ERR_TIMEOUT   : if a timeout error occurred"]
	#[doc = "  \\return ERR_SLEEP_REQ : if Deselect is received and responded"]
	#[doc = "  \\return ERR_NOMEM     : if the received INF does not fit into the"]
	#[doc = "                            receive buffer"]
	#[doc = "  \\return ERR_LINK_LOSS : if communication is lost because Reader/Writer"]
	#[doc = "                            has turned off its field"]
	#[doc = ""]
	pub fn rfalIsoDepGetApduTransceiveStatus() -> ReturnCode;
}
extern "C" {
	#[doc = "  \\brief  ISO-DEP Send RATS"]
	#[doc = ""]
	#[doc = "  This sends a RATS to make a NFC-A Listen Device to enter"]
	#[doc = "  ISO-DEP layer (ISO14443-4) and checks if the received ATS is valid"]
	#[doc = ""]
	#[doc = "  \\param[in]  FSDI   : Frame Size Device Integer to be used"]
	#[doc = "  \\param[in]  DID    : Device ID to be used or RFAL_ISODEP_NO_DID for not use DID"]
	#[doc = "  \\param[out] ats    : pointer to place the ATS Response"]
	#[doc = "  \\param[out] atsLen : pointer to place the ATS length"]
	#[doc = ""]
	#[doc = "  \\return ERR_WRONG_STATE  : RFAL not initialized or incorrect mode"]
	#[doc = "  \\return ERR_PARAM        : Invalid parameters"]
	#[doc = "  \\return ERR_IO           : Generic internal error"]
	#[doc = "  \\return ERR_TIMEOUT      : Timeout error"]
	#[doc = "  \\return ERR_PAR          : Parity error detected"]
	#[doc = "  \\return ERR_CRC          : CRC error detected"]
	#[doc = "  \\return ERR_FRAMING      : Framing error detected"]
	#[doc = "  \\return ERR_PROTO        : Protocol error detected"]
	#[doc = "  \\return ERR_NONE         : No error, ATS received"]
	#[doc = ""]
	pub fn rfalIsoDepRATS(FSDI: rfalIsoDepFSxI, DID: u8, ats: *mut rfalIsoDepAts, atsLen: *mut u8) -> ReturnCode;
}
extern "C" {
	#[doc = "  \\brief  ISO-DEP Send PPS"]
	#[doc = ""]
	#[doc = "  This sends a PPS to make a NFC-A Listen Device change the communications"]
	#[doc = "  bit rate from 106kbps to one of the supported bit rates"]
	#[doc = "  Additionally checks if the received PPS response is valid"]
	#[doc = ""]
	#[doc = "  \\param[in]  DID    : Device ID"]
	#[doc = "  \\param[in]  DSI    : DSI code the divisor from Listener (PICC) to Poller (PCD)"]
	#[doc = "  \\param[in]  DRI    : DRI code the divisor from Poller (PCD) to Listener (PICC)"]
	#[doc = "  \\param[out] ppsRes : pointer to place the PPS Response"]
	#[doc = ""]
	#[doc = "  \\return ERR_WRONG_STATE  : RFAL not initialized or incorrect mode"]
	#[doc = "  \\return ERR_PARAM        : Invalid parameters"]
	#[doc = "  \\return ERR_IO           : Generic internal error"]
	#[doc = "  \\return ERR_TIMEOUT      : Timeout error"]
	#[doc = "  \\return ERR_PAR          : Parity error detected"]
	#[doc = "  \\return ERR_CRC          : CRC error detected"]
	#[doc = "  \\return ERR_FRAMING      : Framing error detected"]
	#[doc = "  \\return ERR_PROTO        : Protocol error detected"]
	#[doc = "  \\return ERR_NONE         : No error, PPS Response received"]
	#[doc = ""]
	pub fn rfalIsoDepPPS(DID: u8, DSI: rfalBitRate, DRI: rfalBitRate, ppsRes: *mut rfalIsoDepPpsRes) -> ReturnCode;
}
extern "C" {
	#[doc = "  \\brief  ISO-DEP Send ATTRIB"]
	#[doc = ""]
	#[doc = "  This sends a ATTRIB to make a NFC-B Listen Device to enter"]
	#[doc = "  ISO-DEP layer (ISO14443-4) and checks if the received ATTRIB Response is valid"]
	#[doc = ""]
	#[doc = "  \\param[in]  nfcid0    : NFCID0 to be used for the ATTRIB"]
	#[doc = "  \\param[in]  PARAM1    : ATTRIB PARAM1 byte (communication parameters)"]
	#[doc = "  \\param[in]  DSI       : DSI code the divisor from Listener (PICC) to Poller (PCD)"]
	#[doc = "  \\param[in]  DRI       : DRI code the divisor from Poller (PCD) to Listener (PICC)"]
	#[doc = "  \\param[in]  FSDI      : PCD's Frame Size to be announced on the ATTRIB"]
	#[doc = "  \\param[in]  PARAM3    : ATTRIB PARAM1 byte (protocol type)"]
	#[doc = "  \\param[in]  DID       : Device ID to be used or RFAL_ISODEP_NO_DID for not use DID"]
	#[doc = "  \\param[in]  HLInfo    : pointer to Higher layer INF (NULL if none)"]
	#[doc = "  \\param[in]  HLInfoLen : Length HLInfo"]
	#[doc = "  \\param[in]  fwt       : Frame Waiting Time to be used (from SENSB_RES)"]
	#[doc = "  \\param[out] attribRes    : pointer to place the ATTRIB Response"]
	#[doc = "  \\param[out] attribResLen : pointer to place the ATTRIB Response length"]
	#[doc = ""]
	#[doc = "  \\return ERR_WRONG_STATE  : RFAL not initialized or incorrect mode"]
	#[doc = "  \\return ERR_PARAM        : Invalid parameters"]
	#[doc = "  \\return ERR_IO           : Generic internal error"]
	#[doc = "  \\return ERR_TIMEOUT      : Timeout error"]
	#[doc = "  \\return ERR_CRC          : CRC error detected"]
	#[doc = "  \\return ERR_FRAMING      : Framing error detected"]
	#[doc = "  \\return ERR_PROTO        : Protocol error detected"]
	#[doc = "  \\return ERR_NONE         : No error, ATTRIB Response received"]
	#[doc = ""]
	pub fn rfalIsoDepATTRIB(nfcid0: *const u8,
	                        PARAM1: u8,
	                        DSI: rfalBitRate,
	                        DRI: rfalBitRate,
	                        FSDI: rfalIsoDepFSxI,
	                        PARAM3: u8,
	                        DID: u8,
	                        HLInfo: *const u8,
	                        HLInfoLen: u8,
	                        fwt: u32,
	                        attribRes: *mut rfalIsoDepAttribRes,
	                        attribResLen: *mut u8)
	                        -> ReturnCode;
}
extern "C" {
	#[doc = "  \\brief  Deselects PICC"]
	#[doc = ""]
	#[doc = "  This function sends a deselect command to PICC and waits for it`s"]
	#[doc = "  responce in a blocking way"]
	#[doc = ""]
	#[doc = "  \\return ERR_NONE   : Deselect successfully sent and acknowledged by PICC"]
	#[doc = "  \\return ERR_TIMEOUT: No response rcvd from PICC"]
	#[doc = ""]
	#[doc = ""]
	pub fn rfalIsoDepDeselect() -> ReturnCode;
}
extern "C" {
	#[doc = "  \\brief  ISO-DEP Poller Handle NFC-A Activation"]
	#[doc = ""]
	#[doc = "  This performs a NFC-A Activation into ISO-DEP layer (ISO14443-4) with the given"]
	#[doc = "  parameters. It sends RATS and if the higher bit rates are supported by"]
	#[doc = "  both devices it additionally sends PPS"]
	#[doc = "  Once Activated all details of the device are provided on isoDepDev"]
	#[doc = ""]
	#[doc = "  \\param[in]  FSDI      : Frame Size Device Integer to be used"]
	#[doc = "  \\param[in]  DID       : Device ID to be used or RFAL_ISODEP_NO_DID for not use DID"]
	#[doc = "  \\param[in]  maxBR     : Max bit rate supported by the Poller"]
	#[doc = "  \\param[out] isoDepDev : ISO-DEP information of the activated Listen device"]
	#[doc = ""]
	#[doc = "  \\return ERR_WRONG_STATE  : RFAL not initialized or incorrect mode"]
	#[doc = "  \\return ERR_PARAM        : Invalid parameters"]
	#[doc = "  \\return ERR_IO           : Generic internal error"]
	#[doc = "  \\return ERR_TIMEOUT      : Timeout error"]
	#[doc = "  \\return ERR_PAR          : Parity error detected"]
	#[doc = "  \\return ERR_CRC          : CRC error detected"]
	#[doc = "  \\return ERR_FRAMING      : Framing error detected"]
	#[doc = "  \\return ERR_PROTO        : Protocol error detected"]
	#[doc = "  \\return ERR_NONE         : No error, activation successful"]
	#[doc = ""]
	pub fn rfalIsoDepPollAHandleActivation(FSDI: rfalIsoDepFSxI,
	                                       DID: u8,
	                                       maxBR: rfalBitRate,
	                                       isoDepDev: *mut rfalIsoDepDevice)
	                                       -> ReturnCode;
}
extern "C" {
	#[doc = "  \\brief  ISO-DEP Poller Handle NFC-B Activation"]
	#[doc = ""]
	#[doc = "  This performs a NFC-B Activation into ISO-DEP layer (ISO14443-4) with the given"]
	#[doc = "  parameters. It sends ATTRIB and calculates supported higher bit rates of both"]
	#[doc = "  devices and performs activation."]
	#[doc = "  Once Activated all details of the device are provided on isoDepDev"]
	#[doc = ""]
	#[doc = "  \\param[in]  FSDI         : Frame Size Device Integer to be used"]
	#[doc = "  \\param[in]  DID          : Device ID to be used or RFAL_ISODEP_NO_DID for not use DID"]
	#[doc = "  \\param[in]  maxBR        : Max bit rate supported by the Poller"]
	#[doc = "  \\param[in]  PARAM1       : ATTRIB PARAM1 byte (communication parameters)"]
	#[doc = "  \\param[in]  nfcbDev      : pointer to the NFC-B Device containing the SENSB_RES"]
	#[doc = "  \\param[in]  HLInfo       : pointer to Higher layer INF (NULL if none)"]
	#[doc = "  \\param[in]  HLInfoLen    : Length HLInfo"]
	#[doc = "  \\param[out] isoDepDev    : ISO-DEP information of the activated Listen device"]
	#[doc = ""]
	#[doc = "  \\return ERR_WRONG_STATE  : RFAL not initialized or incorrect mode"]
	#[doc = "  \\return ERR_PARAM        : Invalid parameters"]
	#[doc = "  \\return ERR_IO           : Generic internal error"]
	#[doc = "  \\return ERR_TIMEOUT      : Timeout error"]
	#[doc = "  \\return ERR_PAR          : Parity error detected"]
	#[doc = "  \\return ERR_CRC          : CRC error detected"]
	#[doc = "  \\return ERR_FRAMING      : Framing error detected"]
	#[doc = "  \\return ERR_PROTO        : Protocol error detected"]
	#[doc = "  \\return ERR_NONE         : No error, activation successful"]
	#[doc = ""]
	pub fn rfalIsoDepPollBHandleActivation(FSDI: rfalIsoDepFSxI,
	                                       DID: u8,
	                                       maxBR: rfalBitRate,
	                                       PARAM1: u8,
	                                       nfcbDev: *const rfalNfcbListenDevice,
	                                       HLInfo: *const u8,
	                                       HLInfoLen: u8,
	                                       isoDepDev: *mut rfalIsoDepDevice)
	                                       -> ReturnCode;
}
extern "C" {
	#[doc = "  \\brief  ISO-DEP Poller Handle S(Parameters)"]
	#[doc = ""]
	#[doc = "  This checks if PICC supports S(PARAMETERS), retieves PICC's"]
	#[doc = "  capabilities and sets the Bit Rate at the highest supported by both"]
	#[doc = "  devices"]
	#[doc = ""]
	#[doc = "  \\param[out] isoDepDev    : ISO-DEP information of the activated Listen device"]
	#[doc = "  \\param[in]  maxTxBR      : Maximum Tx bit rate supported by PCD"]
	#[doc = "  \\param[in]  maxRxBR      : Maximum Rx bit rate supported by PCD"]
	#[doc = ""]
	#[doc = "  \\return ERR_WRONG_STATE  : RFAL not initialized or incorrect mode"]
	#[doc = "  \\return ERR_PARAM        : Invalid parameters"]
	#[doc = "  \\return ERR_IO           : Generic internal error"]
	#[doc = "  \\return ERR_TIMEOUT      : Timeout error"]
	#[doc = "  \\return ERR_FRAMING      : Framing error detected"]
	#[doc = "  \\return ERR_PROTO        : Protocol error detected"]
	#[doc = "  \\return ERR_NONE         : No error, S(PARAMETERS) selection successful"]
	#[doc = ""]
	pub fn rfalIsoDepPollHandleSParameters(isoDepDev: *mut rfalIsoDepDevice, maxTxBR: rfalBitRate, maxRxBR: rfalBitRate)
	                                       -> ReturnCode;
}
extern "C" {
	#[doc = "  \\brief  ISO-DEP Poller Start NFC-A Activation"]
	#[doc = ""]
	#[doc = "  This starts a NFC-A Activation into ISO-DEP layer (ISO14443-4) with the given"]
	#[doc = "  parameters. It sends RATS and if the higher bit rates are supported by"]
	#[doc = "  both devices it additionally sends PPS"]
	#[doc = "  Once Activated all details of the device are provided on isoDepDev"]
	#[doc = ""]
	#[doc = ""]
	#[doc = "  \\see rfalIsoDepPollAGetActivationStatus"]
	#[doc = ""]
	#[doc = "  \\param[in]  FSDI      : Frame Size Device Integer to be used"]
	#[doc = "  \\param[in]  DID       : Device ID to be used or RFAL_ISODEP_NO_DID for not use DID"]
	#[doc = "  \\param[in]  maxBR     : Max bit rate supported by the Poller"]
	#[doc = "  \\param[out] isoDepDev : ISO-DEP information of the activated Listen device"]
	#[doc = ""]
	#[doc = "  \\return ERR_WRONG_STATE  : RFAL not initialized or incorrect mode"]
	#[doc = "  \\return ERR_PARAM        : Invalid parameters"]
	#[doc = "  \\return ERR_IO           : Generic internal error"]
	#[doc = "  \\return ERR_TIMEOUT      : Timeout error"]
	#[doc = "  \\return ERR_PAR          : Parity error detected"]
	#[doc = "  \\return ERR_CRC          : CRC error detected"]
	#[doc = "  \\return ERR_FRAMING      : Framing error detected"]
	#[doc = "  \\return ERR_PROTO        : Protocol error detected"]
	#[doc = "  \\return ERR_NONE         : No error, start of asynchronous operation successful"]
	#[doc = ""]
	pub fn rfalIsoDepPollAStartActivation(FSDI: rfalIsoDepFSxI,
	                                      DID: u8,
	                                      maxBR: rfalBitRate,
	                                      isoDepDev: *mut rfalIsoDepDevice)
	                                      -> ReturnCode;
}
extern "C" {
	#[doc = "  \\brief  ISO-DEP Poller Get NFC-A Activation Status"]
	#[doc = ""]
	#[doc = "  Returns the activation status started by rfalIsoDepPollAStartActivation"]
	#[doc = ""]
	#[doc = "  \\see rfalIsoDepPollAStartActivation"]
	#[doc = ""]
	#[doc = "  \\return ERR_BUSY         : Operation is ongoing"]
	#[doc = "  \\return ERR_WRONG_STATE  : RFAL not initialized or incorrect mode"]
	#[doc = "  \\return ERR_PARAM        : Invalid parameters"]
	#[doc = "  \\return ERR_IO           : Generic internal error"]
	#[doc = "  \\return ERR_TIMEOUT      : Timeout error"]
	#[doc = "  \\return ERR_PAR          : Parity error detected"]
	#[doc = "  \\return ERR_CRC          : CRC error detected"]
	#[doc = "  \\return ERR_FRAMING      : Framing error detected"]
	#[doc = "  \\return ERR_PROTO        : Protocol error detected"]
	#[doc = "  \\return ERR_NONE         : No error, activation successful"]
	#[doc = ""]
	pub fn rfalIsoDepPollAGetActivationStatus() -> ReturnCode;
}
extern "C" {
	#[doc = "  \\brief  ISO-DEP Poller Start NFC-B Activation"]
	#[doc = ""]
	#[doc = "  This starts a NFC-B Activation into ISO-DEP layer (ISO14443-4) with the given"]
	#[doc = "  parameters. It will send ATTRIB and calculate supported higher bit rates of both"]
	#[doc = "  devices and perform activation."]
	#[doc = "  Once Activated all details of the device are provided on isoDepDev"]
	#[doc = ""]
	#[doc = "  \\see rfalIsoDepPollBGetActivationStatus"]
	#[doc = ""]
	#[doc = "  \\param[in]  FSDI         : Frame Size Device Integer to be used"]
	#[doc = "  \\param[in]  DID          : Device ID to be used or RFAL_ISODEP_NO_DID for not use DID"]
	#[doc = "  \\param[in]  maxBR        : Max bit rate supported by the Poller"]
	#[doc = "  \\param[in]  PARAM1       : ATTRIB PARAM1 byte (communication parameters)"]
	#[doc = "  \\param[in]  nfcbDev      : pointer to the NFC-B Device containing the SENSB_RES"]
	#[doc = "  \\param[in]  HLInfo       : pointer to Higher layer INF (NULL if none)"]
	#[doc = "  \\param[in]  HLInfoLen    : Length HLInfo"]
	#[doc = "  \\param[out] isoDepDev    : ISO-DEP information of the activated Listen device"]
	#[doc = ""]
	#[doc = "  \\return ERR_WRONG_STATE  : RFAL not initialized or incorrect mode"]
	#[doc = "  \\return ERR_PARAM        : Invalid parameters"]
	#[doc = "  \\return ERR_IO           : Generic internal error"]
	#[doc = "  \\return ERR_TIMEOUT      : Timeout error"]
	#[doc = "  \\return ERR_PAR          : Parity error detected"]
	#[doc = "  \\return ERR_CRC          : CRC error detected"]
	#[doc = "  \\return ERR_FRAMING      : Framing error detected"]
	#[doc = "  \\return ERR_PROTO        : Protocol error detected"]
	#[doc = "  \\return ERR_NONE         : No error, start of asynchronous operation successful"]
	#[doc = ""]
	pub fn rfalIsoDepPollBStartActivation(FSDI: rfalIsoDepFSxI,
	                                      DID: u8,
	                                      maxBR: rfalBitRate,
	                                      PARAM1: u8,
	                                      nfcbDev: *const rfalNfcbListenDevice,
	                                      HLInfo: *const u8,
	                                      HLInfoLen: u8,
	                                      isoDepDev: *mut rfalIsoDepDevice)
	                                      -> ReturnCode;
}
extern "C" {
	#[doc = "  \\brief  ISO-DEP Poller Get NFC-B Activation Status"]
	#[doc = ""]
	#[doc = "  Returns the activation status started by rfalIsoDepPollBStartActivation"]
	#[doc = ""]
	#[doc = "  \\see rfalIsoDepPollBStartActivation"]
	#[doc = ""]
	#[doc = "  \\return ERR_BUSY         : Operation is ongoing"]
	#[doc = "  \\return ERR_WRONG_STATE  : RFAL not initialized or incorrect mode"]
	#[doc = "  \\return ERR_PARAM        : Invalid parameters"]
	#[doc = "  \\return ERR_IO           : Generic internal error"]
	#[doc = "  \\return ERR_TIMEOUT      : Timeout error"]
	#[doc = "  \\return ERR_PAR          : Parity error detected"]
	#[doc = "  \\return ERR_CRC          : CRC error detected"]
	#[doc = "  \\return ERR_FRAMING      : Framing error detected"]
	#[doc = "  \\return ERR_PROTO        : Protocol error detected"]
	#[doc = "  \\return ERR_NONE         : No error, activation successful"]
	#[doc = ""]
	pub fn rfalIsoDepPollBGetActivationStatus() -> ReturnCode;
}
#[repr(u32)]
#[non_exhaustive]
#[doc = " Main state"]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum rfalNfcState {
	#[doc = "< Not Initialized state"]
	RFAL_NFC_STATE_NOTINIT = 0,
	#[doc = "< Initialize state"]
	RFAL_NFC_STATE_IDLE = 1,
	#[doc = "< Start Discovery loop state"]
	RFAL_NFC_STATE_START_DISCOVERY = 2,
	#[doc = "< Wake-Up state"]
	RFAL_NFC_STATE_WAKEUP_MODE = 3,
	#[doc = "< Technology Detection state"]
	RFAL_NFC_STATE_POLL_TECHDETECT = 10,
	#[doc = "< Collision Avoidance state"]
	RFAL_NFC_STATE_POLL_COLAVOIDANCE = 11,
	#[doc = "< Wait for Selection state"]
	RFAL_NFC_STATE_POLL_SELECT = 12,
	#[doc = "< Activation state"]
	RFAL_NFC_STATE_POLL_ACTIVATION = 13,
	#[doc = "< Listen Tech Detect"]
	RFAL_NFC_STATE_LISTEN_TECHDETECT = 20,
	#[doc = "< Listen Collision Avoidance"]
	RFAL_NFC_STATE_LISTEN_COLAVOIDANCE = 21,
	#[doc = "< Listen Activation state"]
	RFAL_NFC_STATE_LISTEN_ACTIVATION = 22,
	#[doc = "< Listen Sleep state"]
	RFAL_NFC_STATE_LISTEN_SLEEP = 23,
	#[doc = "< Activated state"]
	RFAL_NFC_STATE_ACTIVATED = 30,
	#[doc = "< Data Exchange Start state"]
	RFAL_NFC_STATE_DATAEXCHANGE = 31,
	#[doc = "< Data Exchange terminated"]
	RFAL_NFC_STATE_DATAEXCHANGE_DONE = 33,
	#[doc = "< Deactivation state"]
	RFAL_NFC_STATE_DEACTIVATION = 34,
}
#[repr(u32)]
#[non_exhaustive]
#[doc = " Device type"]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum rfalNfcDevType {
	#[doc = "< NFC-A Listener device type"]
	RFAL_NFC_LISTEN_TYPE_NFCA = 0,
	#[doc = "< NFC-B Listener device type"]
	RFAL_NFC_LISTEN_TYPE_NFCB = 1,
	#[doc = "< NFC-F Listener device type"]
	RFAL_NFC_LISTEN_TYPE_NFCF = 2,
	#[doc = "< NFC-V Listener device type"]
	RFAL_NFC_LISTEN_TYPE_NFCV = 3,
	#[doc = "< ST25TB Listener device type"]
	RFAL_NFC_LISTEN_TYPE_ST25TB = 4,
	#[doc = "< AP2P Listener device type"]
	RFAL_NFC_LISTEN_TYPE_AP2P = 5,
	#[doc = "< NFC-A Poller device type"]
	RFAL_NFC_POLL_TYPE_NFCA = 10,
	#[doc = "< NFC-B Poller device type"]
	RFAL_NFC_POLL_TYPE_NFCB = 11,
	#[doc = "< NFC-F Poller device type"]
	RFAL_NFC_POLL_TYPE_NFCF = 12,
	#[doc = "< NFC-V Poller device type"]
	RFAL_NFC_POLL_TYPE_NFCV = 13,
	#[doc = "< AP2P Poller device type"]
	RFAL_NFC_POLL_TYPE_AP2P = 15,
}
#[repr(u32)]
#[non_exhaustive]
#[doc = " Device interface"]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum rfalNfcRfInterface {
	#[doc = "< RF Frame interface"]
	RFAL_NFC_INTERFACE_RF = 0,
	#[doc = "< ISO-DEP interface"]
	RFAL_NFC_INTERFACE_ISODEP = 1,
	#[doc = "< NFC-DEP interface"]
	RFAL_NFC_INTERFACE_NFCDEP = 2,
}
#[doc = " Device struct containing all its details"]
#[repr(C)]
pub struct rfalNfcDevice {
	#[doc = "< Device's type"]
	pub type_: rfalNfcDevType,
	#[doc = "< Device's instance"]
	pub dev: rfalNfcDevice__bindgen_ty_1,
	#[doc = "< Device's NFCID"]
	pub nfcid: *mut u8,
	#[doc = "< Device's NFCID length"]
	pub nfcidLen: u8,
	#[doc = "< Device's interface"]
	pub rfInterface: rfalNfcRfInterface,
	#[doc = "< Device's protocol"]
	pub proto: rfalNfcDevice__bindgen_ty_2,
}
#[repr(C)]
pub struct rfalNfcDevice__bindgen_ty_1 {
	#[doc = "< NFC-A Listen Device instance"]
	pub nfca: __BindgenUnionField<rfalNfcaListenDevice>,
	#[doc = "< NFC-B Listen Device instance"]
	pub nfcb: __BindgenUnionField<rfalNfcbListenDevice>,
	#[doc = "< NFC-F Listen Device instance"]
	pub nfcf: __BindgenUnionField<rfalNfcfListenDevice>,
	#[doc = "< NFC-V Listen Device instance"]
	pub nfcv: __BindgenUnionField<rfalNfcvListenDevice>,
	#[doc = "< ST25TB Listen Device instance"]
	pub st25tb: __BindgenUnionField<rfalSt25tbListenDevice>,
	pub bindgen_union_field: [u32; 7usize],
}
#[test]
fn bindgen_test_layout_rfalNfcDevice__bindgen_ty_1() {
	assert_eq!(
	           ::core::mem::size_of::<rfalNfcDevice__bindgen_ty_1>(),
	           28usize,
	           concat!("Size of: ", stringify!(rfalNfcDevice__bindgen_ty_1))
	);
	assert_eq!(
	           ::core::mem::align_of::<rfalNfcDevice__bindgen_ty_1>(),
	           4usize,
	           concat!("Alignment of ", stringify!(rfalNfcDevice__bindgen_ty_1))
	);
	fn test_field_nfca() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcDevice__bindgen_ty_1>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).nfca) as usize - ptr as usize
		           },
		           0usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalNfcDevice__bindgen_ty_1),
			"::",
			stringify!(nfca)
		)
		);
	}
	test_field_nfca();
	fn test_field_nfcb() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcDevice__bindgen_ty_1>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).nfcb) as usize - ptr as usize
		           },
		           0usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalNfcDevice__bindgen_ty_1),
			"::",
			stringify!(nfcb)
		)
		);
	}
	test_field_nfcb();
	fn test_field_nfcf() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcDevice__bindgen_ty_1>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).nfcf) as usize - ptr as usize
		           },
		           0usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalNfcDevice__bindgen_ty_1),
			"::",
			stringify!(nfcf)
		)
		);
	}
	test_field_nfcf();
	fn test_field_nfcv() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcDevice__bindgen_ty_1>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).nfcv) as usize - ptr as usize
		           },
		           0usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalNfcDevice__bindgen_ty_1),
			"::",
			stringify!(nfcv)
		)
		);
	}
	test_field_nfcv();
	fn test_field_st25tb() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcDevice__bindgen_ty_1>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).st25tb) as usize - ptr as usize
		           },
		           0usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalNfcDevice__bindgen_ty_1),
			"::",
			stringify!(st25tb)
		)
		);
	}
	test_field_st25tb();
}
#[repr(C)]
pub struct rfalNfcDevice__bindgen_ty_2 {
	#[doc = "< ISO-DEP instance"]
	pub isoDep: __BindgenUnionField<rfalIsoDepDevice>,
	#[doc = "< NFC-DEP instance"]
	pub nfcDep: __BindgenUnionField<rfalNfcDepDevice>,
	pub bindgen_union_field: [u32; 24usize],
}
#[test]
fn bindgen_test_layout_rfalNfcDevice__bindgen_ty_2() {
	assert_eq!(
	           ::core::mem::size_of::<rfalNfcDevice__bindgen_ty_2>(),
	           96usize,
	           concat!("Size of: ", stringify!(rfalNfcDevice__bindgen_ty_2))
	);
	assert_eq!(
	           ::core::mem::align_of::<rfalNfcDevice__bindgen_ty_2>(),
	           4usize,
	           concat!("Alignment of ", stringify!(rfalNfcDevice__bindgen_ty_2))
	);
	fn test_field_isoDep() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcDevice__bindgen_ty_2>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).isoDep) as usize - ptr as usize
		           },
		           0usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalNfcDevice__bindgen_ty_2),
			"::",
			stringify!(isoDep)
		)
		);
	}
	test_field_isoDep();
	fn test_field_nfcDep() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcDevice__bindgen_ty_2>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).nfcDep) as usize - ptr as usize
		           },
		           0usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalNfcDevice__bindgen_ty_2),
			"::",
			stringify!(nfcDep)
		)
		);
	}
	test_field_nfcDep();
}
#[test]
fn bindgen_test_layout_rfalNfcDevice() {
	assert_eq!(
	           ::core::mem::size_of::<rfalNfcDevice>(),
	           140usize,
	           concat!("Size of: ", stringify!(rfalNfcDevice))
	);
	assert_eq!(
	           ::core::mem::align_of::<rfalNfcDevice>(),
	           4usize,
	           concat!("Alignment of ", stringify!(rfalNfcDevice))
	);
	fn test_field_type() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcDevice>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(rfalNfcDevice), "::", stringify!(type_))
		);
	}
	test_field_type();
	fn test_field_dev() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcDevice>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).dev) as usize - ptr as usize
		           },
		           4usize,
		           concat!("Offset of field: ", stringify!(rfalNfcDevice), "::", stringify!(dev))
		);
	}
	test_field_dev();
	fn test_field_nfcid() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcDevice>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).nfcid) as usize - ptr as usize
		           },
		           32usize,
		           concat!("Offset of field: ", stringify!(rfalNfcDevice), "::", stringify!(nfcid))
		);
	}
	test_field_nfcid();
	fn test_field_nfcidLen() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcDevice>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).nfcidLen) as usize - ptr as usize
		           },
		           36usize,
		           concat!("Offset of field: ", stringify!(rfalNfcDevice), "::", stringify!(nfcidLen))
		);
	}
	test_field_nfcidLen();
	fn test_field_rfInterface() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcDevice>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).rfInterface) as usize - ptr as usize
		           },
		           40usize,
		           concat!("Offset of field: ", stringify!(rfalNfcDevice), "::", stringify!(rfInterface))
		);
	}
	test_field_rfInterface();
	fn test_field_proto() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcDevice>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).proto) as usize - ptr as usize
		           },
		           44usize,
		           concat!("Offset of field: ", stringify!(rfalNfcDevice), "::", stringify!(proto))
		);
	}
	test_field_proto();
}
#[doc = " Discovery parameters"]
#[repr(C)]
pub struct rfalNfcDiscoverParam {
	#[doc = "< Compliancy mode to be used"]
	pub compMode: rfalComplianceMode,
	#[doc = "< Technologies to search for"]
	pub techs2Find: u16,
	#[doc = "< Duration of a whole Poll + Listen cycle"]
	pub totalDuration: u16,
	#[doc = "< Max number of devices"]
	pub devLimit: u8,
	#[doc = "< Max Bit rate to be used for communications"]
	pub maxBR: rfalBitRate,
	#[doc = "< Bit rate to poll for NFC-F"]
	pub nfcfBR: rfalBitRate,
	#[doc = "< NFCID3 to be used on the ATR_REQ/ATR_RES"]
	pub nfcid3: [u8; 10usize],
	#[doc = "< General bytes to be used on the ATR-REQ"]
	pub GB: [u8; 48usize],
	#[doc = "< Length of the General Bytes"]
	pub GBLen: u8,
	#[doc = "< Bit rate to poll for AP2P"]
	pub ap2pBR: rfalBitRate,
	#[doc = "< Configuration for Passive Listen mode NFC-A"]
	pub lmConfigPA: rfalLmConfPA,
	#[doc = "< Configuration for Passive Listen mode NFC-A"]
	pub lmConfigPF: rfalLmConfPF,
	#[doc = "< Callback to Notify upper layer"]
	pub notifyCb: ::core::option::Option<unsafe extern "C" fn(st: rfalNfcState)>,
	#[doc = "< Enable Wake-Up mode before polling"]
	pub wakeupEnabled: bool,
	#[doc = "< Wake-Up mode default configuration"]
	pub wakeupConfigDefault: bool,
	#[doc = "< Wake-Up mode configuration"]
	pub wakeupConfig: rfalWakeUpConfig,
	pub activate_after_sak: bool,
}
#[test]
fn bindgen_test_layout_rfalNfcDiscoverParam() {
	assert_eq!(
	           ::core::mem::size_of::<rfalNfcDiscoverParam>(),
	           184usize,
	           concat!("Size of: ", stringify!(rfalNfcDiscoverParam))
	);
	assert_eq!(
	           ::core::mem::align_of::<rfalNfcDiscoverParam>(),
	           4usize,
	           concat!("Alignment of ", stringify!(rfalNfcDiscoverParam))
	);
	fn test_field_compMode() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcDiscoverParam>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).compMode) as usize - ptr as usize
		           },
		           0usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalNfcDiscoverParam),
			"::",
			stringify!(compMode)
		)
		);
	}
	test_field_compMode();
	fn test_field_techs2Find() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcDiscoverParam>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).techs2Find) as usize - ptr as usize
		           },
		           4usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalNfcDiscoverParam),
			"::",
			stringify!(techs2Find)
		)
		);
	}
	test_field_techs2Find();
	fn test_field_totalDuration() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcDiscoverParam>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).totalDuration) as usize - ptr as usize
		           },
		           6usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalNfcDiscoverParam),
			"::",
			stringify!(totalDuration)
		)
		);
	}
	test_field_totalDuration();
	fn test_field_devLimit() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcDiscoverParam>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).devLimit) as usize - ptr as usize
		           },
		           8usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalNfcDiscoverParam),
			"::",
			stringify!(devLimit)
		)
		);
	}
	test_field_devLimit();
	fn test_field_maxBR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcDiscoverParam>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).maxBR) as usize - ptr as usize
		           },
		           12usize,
		           concat!("Offset of field: ", stringify!(rfalNfcDiscoverParam), "::", stringify!(maxBR))
		);
	}
	test_field_maxBR();
	fn test_field_nfcfBR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcDiscoverParam>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).nfcfBR) as usize - ptr as usize
		           },
		           16usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalNfcDiscoverParam),
			"::",
			stringify!(nfcfBR)
		)
		);
	}
	test_field_nfcfBR();
	fn test_field_nfcid3() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcDiscoverParam>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).nfcid3) as usize - ptr as usize
		           },
		           20usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalNfcDiscoverParam),
			"::",
			stringify!(nfcid3)
		)
		);
	}
	test_field_nfcid3();
	fn test_field_GB() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcDiscoverParam>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).GB) as usize - ptr as usize
		           },
		           30usize,
		           concat!("Offset of field: ", stringify!(rfalNfcDiscoverParam), "::", stringify!(GB))
		);
	}
	test_field_GB();
	fn test_field_GBLen() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcDiscoverParam>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).GBLen) as usize - ptr as usize
		           },
		           78usize,
		           concat!("Offset of field: ", stringify!(rfalNfcDiscoverParam), "::", stringify!(GBLen))
		);
	}
	test_field_GBLen();
	fn test_field_ap2pBR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcDiscoverParam>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).ap2pBR) as usize - ptr as usize
		           },
		           80usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalNfcDiscoverParam),
			"::",
			stringify!(ap2pBR)
		)
		);
	}
	test_field_ap2pBR();
	fn test_field_lmConfigPA() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcDiscoverParam>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).lmConfigPA) as usize - ptr as usize
		           },
		           84usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalNfcDiscoverParam),
			"::",
			stringify!(lmConfigPA)
		)
		);
	}
	test_field_lmConfigPA();
	fn test_field_lmConfigPF() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcDiscoverParam>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).lmConfigPF) as usize - ptr as usize
		           },
		           104usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalNfcDiscoverParam),
			"::",
			stringify!(lmConfigPF)
		)
		);
	}
	test_field_lmConfigPF();
	fn test_field_notifyCb() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcDiscoverParam>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).notifyCb) as usize - ptr as usize
		           },
		           128usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalNfcDiscoverParam),
			"::",
			stringify!(notifyCb)
		)
		);
	}
	test_field_notifyCb();
	fn test_field_wakeupEnabled() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcDiscoverParam>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).wakeupEnabled) as usize - ptr as usize
		           },
		           132usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalNfcDiscoverParam),
			"::",
			stringify!(wakeupEnabled)
		)
		);
	}
	test_field_wakeupEnabled();
	fn test_field_wakeupConfigDefault() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcDiscoverParam>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).wakeupConfigDefault) as usize - ptr as usize
		           },
		           133usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalNfcDiscoverParam),
			"::",
			stringify!(wakeupConfigDefault)
		)
		);
	}
	test_field_wakeupConfigDefault();
	fn test_field_wakeupConfig() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcDiscoverParam>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).wakeupConfig) as usize - ptr as usize
		           },
		           136usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalNfcDiscoverParam),
			"::",
			stringify!(wakeupConfig)
		)
		);
	}
	test_field_wakeupConfig();
	fn test_field_activate_after_sak() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<rfalNfcDiscoverParam>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).activate_after_sak) as usize - ptr as usize
		           },
		           180usize,
		           concat!(
			"Offset of field: ",
			stringify!(rfalNfcDiscoverParam),
			"::",
			stringify!(activate_after_sak)
		)
		);
	}
	test_field_activate_after_sak();
}
extern "C" {
	#[doc = " \\brief  RFAL NFC Worker"]
	#[doc = ""]
	#[doc = " It runs the internal state machine and runs the RFAL RF worker."]
	#[doc = ""]
	pub fn rfalNfcWorker();
}
extern "C" {
	#[doc = " \\brief  RFAL NFC Initialize"]
	#[doc = ""]
	#[doc = " It initializes this module and its dependencies"]
	#[doc = ""]
	#[doc = " \\return ERR_WRONG_STATE  : Incorrect state for this operation"]
	#[doc = " \\return ERR_IO           : Generic internal error"]
	#[doc = " \\return ERR_NONE         : No error"]
	#[doc = ""]
	pub fn rfalNfcInitialize() -> ReturnCode;
}
extern "C" {
	#[doc = " \\brief  RFAL NFC Discovery"]
	#[doc = ""]
	#[doc = " It set the device in Discovery state."]
	#[doc = " In discovery it will Poll and/or Listen for the technologies configured,"]
	#[doc = " and perform Wake-up mode if configured to do so."]
	#[doc = ""]
	#[doc = " The device list passed on disParams must not be empty."]
	#[doc = " The number of devices on the list is indicated by the devLimit and shall"]
	#[doc = " be at >= 1."]
	#[doc = ""]
	#[doc = " \\param[in]  disParams    : discovery configuration parameters"]
	#[doc = ""]
	#[doc = " \\return ERR_WRONG_STATE  : Incorrect state for this operation"]
	#[doc = " \\return ERR_PARAM        : Invalid parameters"]
	#[doc = " \\return ERR_NONE         : No error"]
	#[doc = ""]
	pub fn rfalNfcDiscover(disParams: *const rfalNfcDiscoverParam) -> ReturnCode;
}
extern "C" {
	#[doc = " \\brief  RFAL NFC Get State"]
	#[doc = ""]
	#[doc = " It returns the current state"]
	#[doc = ""]
	#[doc = " \\return rfalNfcState : the current state"]
	#[doc = ""]
	pub fn rfalNfcGetState() -> rfalNfcState;
}
extern "C" {
	#[doc = " \\brief  RFAL NFC Get Devices Found"]
	#[doc = ""]
	#[doc = " It returns the location of the device list and the number of"]
	#[doc = " devices found."]
	#[doc = ""]
	#[doc = " \\param[out]  devList     : device list location"]
	#[doc = " \\param[out]  devCnt      : number of devices found"]
	#[doc = ""]
	#[doc = " \\return ERR_WRONG_STATE  : Incorrect state for this operation"]
	#[doc = "                            Discovery still ongoing"]
	#[doc = " \\return ERR_PARAM        : Invalid parameters"]
	#[doc = " \\return ERR_NONE         : No error"]
	#[doc = ""]
	pub fn rfalNfcGetDevicesFound(devList: *mut *mut rfalNfcDevice, devCnt: *mut u8) -> ReturnCode;
}
extern "C" {
	#[doc = " \\brief  RFAL NFC Get Active Device"]
	#[doc = ""]
	#[doc = " It returns the location of the device current Active device"]
	#[doc = ""]
	#[doc = " \\param[out]  dev           : device info location"]
	#[doc = ""]
	#[doc = " \\return ERR_WRONG_STATE    : Incorrect state for this operation"]
	#[doc = "                              No device activated"]
	#[doc = " \\return ERR_PARAM          : Invalid parameters"]
	#[doc = " \\return ERR_NONE           : No error"]
	#[doc = ""]
	pub fn rfalNfcGetActiveDevice(dev: *mut *mut rfalNfcDevice) -> ReturnCode;
}
extern "C" {
	#[doc = " \\brief  RFAL NFC Select Device"]
	#[doc = ""]
	#[doc = " It selects the device to be activated."]
	#[doc = " It shall be called when more than one device has been identified to"]
	#[doc = " indiacte which device shall be actived"]
	#[doc = ""]
	#[doc = " \\param[in]  devIdx       : device index to be activated"]
	#[doc = ""]
	#[doc = " \\return ERR_WRONG_STATE  : Incorrect state for this operation"]
	#[doc = "                            Not in select state"]
	#[doc = " \\return ERR_PARAM        : Invalid parameters"]
	#[doc = " \\return ERR_NONE         : No error"]
	#[doc = ""]
	pub fn rfalNfcSelect(devIdx: u8) -> ReturnCode;
}
extern "C" {
	#[doc = " \\brief  RFAL NFC Start Data Exchange"]
	#[doc = ""]
	#[doc = " After a device has been activated, it starts a data exchange."]
	#[doc = " It handles automatically which interface/protocol to be used and acts accordingly."]
	#[doc = ""]
	#[doc = " In Listen mode the first frame/data shall be sent by the Reader/Initiator"]
	#[doc = " therefore this method must be called first with txDataLen set to zero"]
	#[doc = " to retrieve the rxData and rcvLen locations."]
	#[doc = ""]
	#[doc = ""]
	#[doc = " \\param[in]  txData       : data to be transmitted"]
	#[doc = " \\param[in]  txDataLen    : size of the data to be transmitted"]
	#[doc = " \\param[out] rxData       : location of the received data after operation is completed"]
	#[doc = " \\param[out] rvdLen       : location of thelength of the received data"]
	#[doc = " \\param[in]  fwt          : FWT to be used in case of RF interface."]
	#[doc = "                            If ISO-DEP or NFC-DEP interface is used, this will be ignored"]
	#[doc = ""]
	#[doc = " \\return ERR_WRONG_STATE  : Incorrect state for this operation"]
	#[doc = " \\return ERR_PARAM        : Invalid parameters"]
	#[doc = " \\return ERR_NONE         : No error"]
	#[doc = ""]
	pub fn rfalNfcDataExchangeStart(txData: *mut u8,
	                                txDataLen: u16,
	                                rxData: *mut *mut u8,
	                                rvdLen: *mut *mut u16,
	                                fwt: u32,
	                                tx_flag: u32)
	                                -> ReturnCode;
}
extern "C" {
	pub fn rfalNfcDataExchangeCustomStart(txData: *mut u8,
	                                      txDataLen: u16,
	                                      rxData: *mut *mut u8,
	                                      rvdLen: *mut *mut u16,
	                                      fwt: u32,
	                                      flags: u32)
	                                      -> ReturnCode;
}
extern "C" {
	#[doc = " \\brief  RFAL NFC Get Data Exchange Status"]
	#[doc = ""]
	#[doc = " Gets current Data Exchange status"]
	#[doc = ""]
	#[doc = " \\return  ERR_NONE         : Transceive done with no error"]
	#[doc = " \\return  ERR_BUSY         : Transceive ongoing"]
	#[doc = "  \\return ERR_AGAIN        : received one chaining block, copy received data"]
	#[doc = "                             and continue to call this method to retrieve the"]
	#[doc = "                             remaining blocks"]
	#[doc = " \\return  ERR_XXXX         : Error occurred"]
	#[doc = " \\return  ERR_TIMEOUT      : No response"]
	#[doc = " \\return  ERR_FRAMING      : Framing error detected"]
	#[doc = " \\return  ERR_PAR          : Parity error detected"]
	#[doc = " \\return  ERR_CRC          : CRC error detected"]
	#[doc = " \\return  ERR_LINK_LOSS    : Link Loss - External Field is Off"]
	#[doc = " \\return  ERR_RF_COLLISION : Collision detected"]
	#[doc = " \\return  ERR_IO           : Internal error"]
	#[doc = ""]
	pub fn rfalNfcDataExchangeGetStatus() -> ReturnCode;
}
extern "C" {
	#[doc = " \\brief  RFAL NFC Deactivate"]
	#[doc = ""]
	#[doc = " It triggers the deactivation procedure to terminate communications with"]
	#[doc = " remote device. At the end the field will be turned off."]
	#[doc = ""]
	#[doc = " \\param[in]  discovery    : TRUE if after deactivation go back into discovery"]
	#[doc = "                          : FALSE if after deactivation remain in idle"]
	#[doc = ""]
	#[doc = " \\return ERR_WRONG_STATE  : Incorrect state for this operation"]
	#[doc = " \\return ERR_NONE         : No error"]
	#[doc = ""]
	pub fn rfalNfcDeactivate(discovery: bool) -> ReturnCode;
}
#[repr(C)]
pub struct DigitalSignal {
	pub start_level: bool,
	pub edge_cnt: u32,
	pub edges_max_cnt: u32,
	pub edge_timings: *mut u32,
	pub reload_reg_buff: *mut u32,
}
#[test]
fn bindgen_test_layout_DigitalSignal() {
	assert_eq!(
	           ::core::mem::size_of::<DigitalSignal>(),
	           20usize,
	           concat!("Size of: ", stringify!(DigitalSignal))
	);
	assert_eq!(
	           ::core::mem::align_of::<DigitalSignal>(),
	           4usize,
	           concat!("Alignment of ", stringify!(DigitalSignal))
	);
	fn test_field_start_level() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<DigitalSignal>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).start_level) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(DigitalSignal), "::", stringify!(start_level))
		);
	}
	test_field_start_level();
	fn test_field_edge_cnt() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<DigitalSignal>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).edge_cnt) as usize - ptr as usize
		           },
		           4usize,
		           concat!("Offset of field: ", stringify!(DigitalSignal), "::", stringify!(edge_cnt))
		);
	}
	test_field_edge_cnt();
	fn test_field_edges_max_cnt() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<DigitalSignal>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).edges_max_cnt) as usize - ptr as usize
		           },
		           8usize,
		           concat!(
			"Offset of field: ",
			stringify!(DigitalSignal),
			"::",
			stringify!(edges_max_cnt)
		)
		);
	}
	test_field_edges_max_cnt();
	fn test_field_edge_timings() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<DigitalSignal>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).edge_timings) as usize - ptr as usize
		           },
		           12usize,
		           concat!("Offset of field: ", stringify!(DigitalSignal), "::", stringify!(edge_timings))
		);
	}
	test_field_edge_timings();
	fn test_field_reload_reg_buff() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<DigitalSignal>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).reload_reg_buff) as usize - ptr as usize
		           },
		           16usize,
		           concat!(
			"Offset of field: ",
			stringify!(DigitalSignal),
			"::",
			stringify!(reload_reg_buff)
		)
		);
	}
	test_field_reload_reg_buff();
}
extern "C" {
	pub fn digital_signal_alloc(max_edges_cnt: u32) -> *mut DigitalSignal;
}
extern "C" {
	pub fn digital_signal_free(signal: *mut DigitalSignal);
}
extern "C" {
	pub fn digital_signal_append(signal_a: *mut DigitalSignal, signal_b: *mut DigitalSignal) -> bool;
}
extern "C" {
	pub fn digital_signal_prepare_arr(signal: *mut DigitalSignal);
}
extern "C" {
	pub fn digital_signal_get_start_level(signal: *mut DigitalSignal) -> bool;
}
extern "C" {
	pub fn digital_signal_get_edges_cnt(signal: *mut DigitalSignal) -> u32;
}
extern "C" {
	pub fn digital_signal_get_edge(signal: *mut DigitalSignal, edge_num: u32) -> u32;
}
extern "C" {
	pub fn digital_signal_send(signal: *mut DigitalSignal, gpio: *const GpioPin);
}
#[repr(C)]
pub struct NfcaSignal {
	pub one: *mut DigitalSignal,
	pub zero: *mut DigitalSignal,
	pub tx_signal: *mut DigitalSignal,
}
#[test]
fn bindgen_test_layout_NfcaSignal() {
	assert_eq!(
	           ::core::mem::size_of::<NfcaSignal>(),
	           12usize,
	           concat!("Size of: ", stringify!(NfcaSignal))
	);
	assert_eq!(
	           ::core::mem::align_of::<NfcaSignal>(),
	           4usize,
	           concat!("Alignment of ", stringify!(NfcaSignal))
	);
	fn test_field_one() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<NfcaSignal>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).one) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(NfcaSignal), "::", stringify!(one))
		);
	}
	test_field_one();
	fn test_field_zero() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<NfcaSignal>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).zero) as usize - ptr as usize
		           },
		           4usize,
		           concat!("Offset of field: ", stringify!(NfcaSignal), "::", stringify!(zero))
		);
	}
	test_field_zero();
	fn test_field_tx_signal() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<NfcaSignal>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).tx_signal) as usize - ptr as usize
		           },
		           8usize,
		           concat!("Offset of field: ", stringify!(NfcaSignal), "::", stringify!(tx_signal))
		);
	}
	test_field_tx_signal();
}
extern "C" {
	pub fn nfca_get_crc16(buff: *mut u8, len: u16) -> u16;
}
extern "C" {
	pub fn nfca_append_crc16(buff: *mut u8, len: u16);
}
extern "C" {
	pub fn nfca_emulation_handler(buff_rx: *mut u8, buff_rx_len: u16, buff_tx: *mut u8, buff_tx_len: *mut u16) -> bool;
}
extern "C" {
	pub fn nfca_signal_alloc() -> *mut NfcaSignal;
}
extern "C" {
	pub fn nfca_signal_free(nfca_signal: *mut NfcaSignal);
}
extern "C" {
	pub fn nfca_signal_encode(nfca_signal: *mut NfcaSignal, data: *mut u8, bits: u16, parity: *mut u8);
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum FuriHalNfcTxRxType {
	FuriHalNfcTxRxTypeDefault = 0,
	FuriHalNfcTxRxTypeRxNoCrc = 1,
	FuriHalNfcTxRxTypeRxKeepPar = 2,
	FuriHalNfcTxRxTypeRaw = 3,
	FuriHalNfcTxRxTypeRxRaw = 4,
	FuriHalNfcTxRxTransparent = 5,
}
pub type FuriHalNfcEmulateCallback = ::core::option::Option<unsafe extern "C" fn(buff_rx: *mut u8,
                                                                                 buff_rx_len: u16,
                                                                                 buff_tx: *mut u8,
                                                                                 buff_tx_len: *mut u16,
                                                                                 flags: *mut u32,
                                                                                 context: *mut core::ffi::c_void)
                                                                                 -> bool>;
#[repr(u32)]
#[non_exhaustive]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum FuriHalNfcType {
	FuriHalNfcTypeA = 0,
	FuriHalNfcTypeB = 1,
	FuriHalNfcTypeF = 2,
	FuriHalNfcTypeV = 3,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum FuriHalNfcInterface {
	FuriHalNfcInterfaceRf = 0,
	FuriHalNfcInterfaceIsoDep = 1,
	FuriHalNfcInterfaceNfcDep = 2,
}
#[repr(C)]
pub struct FuriHalNfcDevData {
	pub type_: FuriHalNfcType,
	pub interface: FuriHalNfcInterface,
	pub uid_len: u8,
	pub uid: [u8; 10usize],
	pub cuid: u32,
	pub atqa: [u8; 2usize],
	pub sak: u8,
}
#[test]
fn bindgen_test_layout_FuriHalNfcDevData() {
	assert_eq!(
	           ::core::mem::size_of::<FuriHalNfcDevData>(),
	           28usize,
	           concat!("Size of: ", stringify!(FuriHalNfcDevData))
	);
	assert_eq!(
	           ::core::mem::align_of::<FuriHalNfcDevData>(),
	           4usize,
	           concat!("Alignment of ", stringify!(FuriHalNfcDevData))
	);
	fn test_field_type() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<FuriHalNfcDevData>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(FuriHalNfcDevData), "::", stringify!(type_))
		);
	}
	test_field_type();
	fn test_field_interface() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<FuriHalNfcDevData>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).interface) as usize - ptr as usize
		           },
		           4usize,
		           concat!(
			"Offset of field: ",
			stringify!(FuriHalNfcDevData),
			"::",
			stringify!(interface)
		)
		);
	}
	test_field_interface();
	fn test_field_uid_len() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<FuriHalNfcDevData>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).uid_len) as usize - ptr as usize
		           },
		           8usize,
		           concat!("Offset of field: ", stringify!(FuriHalNfcDevData), "::", stringify!(uid_len))
		);
	}
	test_field_uid_len();
	fn test_field_uid() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<FuriHalNfcDevData>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).uid) as usize - ptr as usize
		           },
		           9usize,
		           concat!("Offset of field: ", stringify!(FuriHalNfcDevData), "::", stringify!(uid))
		);
	}
	test_field_uid();
	fn test_field_cuid() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<FuriHalNfcDevData>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).cuid) as usize - ptr as usize
		           },
		           20usize,
		           concat!("Offset of field: ", stringify!(FuriHalNfcDevData), "::", stringify!(cuid))
		);
	}
	test_field_cuid();
	fn test_field_atqa() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<FuriHalNfcDevData>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).atqa) as usize - ptr as usize
		           },
		           24usize,
		           concat!("Offset of field: ", stringify!(FuriHalNfcDevData), "::", stringify!(atqa))
		);
	}
	test_field_atqa();
	fn test_field_sak() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<FuriHalNfcDevData>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).sak) as usize - ptr as usize
		           },
		           26usize,
		           concat!("Offset of field: ", stringify!(FuriHalNfcDevData), "::", stringify!(sak))
		);
	}
	test_field_sak();
}
pub type FuriHalNfcTxRxSniffCallback =
	::core::option::Option<unsafe extern "C" fn(data: *mut u8, bits: u16, crc_dropped: bool, context: *mut core::ffi::c_void)>;
#[repr(C)]
pub struct FuriHalNfcTxRxContext {
	pub tx_data: [u8; 512usize],
	pub tx_parity: [u8; 64usize],
	pub tx_bits: u16,
	pub rx_data: [u8; 512usize],
	pub rx_parity: [u8; 64usize],
	pub rx_bits: u16,
	pub tx_rx_type: FuriHalNfcTxRxType,
	pub nfca_signal: *mut NfcaSignal,
	pub sniff_tx: FuriHalNfcTxRxSniffCallback,
	pub sniff_rx: FuriHalNfcTxRxSniffCallback,
	pub sniff_context: *mut core::ffi::c_void,
}
#[test]
fn bindgen_test_layout_FuriHalNfcTxRxContext() {
	assert_eq!(
	           ::core::mem::size_of::<FuriHalNfcTxRxContext>(),
	           1176usize,
	           concat!("Size of: ", stringify!(FuriHalNfcTxRxContext))
	);
	assert_eq!(
	           ::core::mem::align_of::<FuriHalNfcTxRxContext>(),
	           4usize,
	           concat!("Alignment of ", stringify!(FuriHalNfcTxRxContext))
	);
	fn test_field_tx_data() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<FuriHalNfcTxRxContext>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).tx_data) as usize - ptr as usize
		           },
		           0usize,
		           concat!(
			"Offset of field: ",
			stringify!(FuriHalNfcTxRxContext),
			"::",
			stringify!(tx_data)
		)
		);
	}
	test_field_tx_data();
	fn test_field_tx_parity() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<FuriHalNfcTxRxContext>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).tx_parity) as usize - ptr as usize
		           },
		           512usize,
		           concat!(
			"Offset of field: ",
			stringify!(FuriHalNfcTxRxContext),
			"::",
			stringify!(tx_parity)
		)
		);
	}
	test_field_tx_parity();
	fn test_field_tx_bits() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<FuriHalNfcTxRxContext>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).tx_bits) as usize - ptr as usize
		           },
		           576usize,
		           concat!(
			"Offset of field: ",
			stringify!(FuriHalNfcTxRxContext),
			"::",
			stringify!(tx_bits)
		)
		);
	}
	test_field_tx_bits();
	fn test_field_rx_data() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<FuriHalNfcTxRxContext>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).rx_data) as usize - ptr as usize
		           },
		           578usize,
		           concat!(
			"Offset of field: ",
			stringify!(FuriHalNfcTxRxContext),
			"::",
			stringify!(rx_data)
		)
		);
	}
	test_field_rx_data();
	fn test_field_rx_parity() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<FuriHalNfcTxRxContext>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).rx_parity) as usize - ptr as usize
		           },
		           1090usize,
		           concat!(
			"Offset of field: ",
			stringify!(FuriHalNfcTxRxContext),
			"::",
			stringify!(rx_parity)
		)
		);
	}
	test_field_rx_parity();
	fn test_field_rx_bits() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<FuriHalNfcTxRxContext>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).rx_bits) as usize - ptr as usize
		           },
		           1154usize,
		           concat!(
			"Offset of field: ",
			stringify!(FuriHalNfcTxRxContext),
			"::",
			stringify!(rx_bits)
		)
		);
	}
	test_field_rx_bits();
	fn test_field_tx_rx_type() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<FuriHalNfcTxRxContext>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).tx_rx_type) as usize - ptr as usize
		           },
		           1156usize,
		           concat!(
			"Offset of field: ",
			stringify!(FuriHalNfcTxRxContext),
			"::",
			stringify!(tx_rx_type)
		)
		);
	}
	test_field_tx_rx_type();
	fn test_field_nfca_signal() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<FuriHalNfcTxRxContext>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).nfca_signal) as usize - ptr as usize
		           },
		           1160usize,
		           concat!(
			"Offset of field: ",
			stringify!(FuriHalNfcTxRxContext),
			"::",
			stringify!(nfca_signal)
		)
		);
	}
	test_field_nfca_signal();
	fn test_field_sniff_tx() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<FuriHalNfcTxRxContext>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).sniff_tx) as usize - ptr as usize
		           },
		           1164usize,
		           concat!(
			"Offset of field: ",
			stringify!(FuriHalNfcTxRxContext),
			"::",
			stringify!(sniff_tx)
		)
		);
	}
	test_field_sniff_tx();
	fn test_field_sniff_rx() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<FuriHalNfcTxRxContext>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).sniff_rx) as usize - ptr as usize
		           },
		           1168usize,
		           concat!(
			"Offset of field: ",
			stringify!(FuriHalNfcTxRxContext),
			"::",
			stringify!(sniff_rx)
		)
		);
	}
	test_field_sniff_rx();
	fn test_field_sniff_context() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<FuriHalNfcTxRxContext>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).sniff_context) as usize - ptr as usize
		           },
		           1172usize,
		           concat!(
			"Offset of field: ",
			stringify!(FuriHalNfcTxRxContext),
			"::",
			stringify!(sniff_context)
		)
		);
	}
	test_field_sniff_context();
}
extern "C" {
	#[doc = " Init nfc"]
	pub fn furi_hal_nfc_init();
}
extern "C" {
	#[doc = " Check if nfc worker is busy"]
	#[doc = ""]
	#[doc = " @return     true if busy"]
	pub fn furi_hal_nfc_is_busy() -> bool;
}
extern "C" {
	#[doc = " Check if nfc is initialized"]
	#[doc = ""]
	#[doc = " @return     true if initialized"]
	pub fn furi_hal_nfc_is_init() -> bool;
}
extern "C" {
	#[doc = " NFC field on"]
	pub fn furi_hal_nfc_field_on();
}
extern "C" {
	#[doc = " NFC field off"]
	pub fn furi_hal_nfc_field_off();
}
extern "C" {
	#[doc = " NFC start sleep"]
	pub fn furi_hal_nfc_start_sleep();
}
extern "C" {
	pub fn furi_hal_nfc_stop_cmd();
}
extern "C" {
	#[doc = " NFC stop sleep"]
	pub fn furi_hal_nfc_exit_sleep();
}
extern "C" {
	#[doc = " NFC poll"]
	#[doc = ""]
	#[doc = " @param      dev_list    pointer to rfalNfcDevice buffer"]
	#[doc = " @param      dev_cnt     pointer device count"]
	#[doc = " @param      timeout     timeout in ms"]
	#[doc = " @param      deactivate  deactivate flag"]
	#[doc = ""]
	#[doc = " @return     true on success"]
	pub fn furi_hal_nfc_detect(nfc_data: *mut FuriHalNfcDevData, timeout: u32) -> bool;
}
extern "C" {
	#[doc = " Activate NFC-A tag"]
	#[doc = ""]
	#[doc = " @param      timeout      timeout in ms"]
	#[doc = " @param      cuid         pointer to 32bit uid"]
	#[doc = ""]
	#[doc = " @return     true on succeess"]
	pub fn furi_hal_nfc_activate_nfca(timeout: u32, cuid: *mut u32) -> bool;
}
extern "C" {
	#[doc = " NFC listen"]
	#[doc = ""]
	#[doc = " @param      uid                 pointer to uid buffer"]
	#[doc = " @param      uid_len             uid length"]
	#[doc = " @param      atqa                pointer to atqa"]
	#[doc = " @param      sak                 sak"]
	#[doc = " @param      activate_after_sak  activate after sak flag"]
	#[doc = " @param      timeout             timeout in ms"]
	#[doc = ""]
	#[doc = " @return     true on success"]
	pub fn furi_hal_nfc_listen(uid: *mut u8, uid_len: u8, atqa: *mut u8, sak: u8, activate_after_sak: bool, timeout: u32) -> bool;
}
extern "C" {
	#[doc = " Start Target Listen mode"]
	#[doc = " @note RFAL free implementation"]
	#[doc = ""]
	#[doc = " @param       nfc_data            FuriHalNfcDevData instance"]
	pub fn furi_hal_nfc_listen_start(nfc_data: *mut FuriHalNfcDevData);
}
extern "C" {
	#[doc = " Read data in Target Listen mode"]
	#[doc = " @note Must be called only after furi_hal_nfc_listen_start()"]
	#[doc = ""]
	#[doc = " @param       tx_rx               FuriHalNfcTxRxContext instance"]
	#[doc = " @param       timeout_ms          timeout im ms"]
	#[doc = ""]
	#[doc = " @return      true on not empty receive"]
	pub fn furi_hal_nfc_listen_rx(tx_rx: *mut FuriHalNfcTxRxContext, timeout_ms: u32) -> bool;
}
extern "C" {
	#[doc = " Set Target in Sleep state"]
	pub fn furi_hal_nfc_listen_sleep();
}
extern "C" {
	#[doc = " Emulate NFC-A Target"]
	#[doc = " @note RFAL based implementation"]
	#[doc = ""]
	#[doc = " @param       uid                 NFC-A UID"]
	#[doc = " @param       uid_len             NFC-A UID length"]
	#[doc = " @param       atqa                NFC-A ATQA"]
	#[doc = " @param       sak                 NFC-A SAK"]
	#[doc = " @param       callback            FuriHalNfcEmulateCallback instance"]
	#[doc = " @param       context             pointer to context for callback"]
	#[doc = " @param       timeout             timeout in ms"]
	#[doc = ""]
	#[doc = " @return      true on success"]
	pub fn furi_hal_nfc_emulate_nfca(uid: *mut u8,
	                                 uid_len: u8,
	                                 atqa: *mut u8,
	                                 sak: u8,
	                                 callback: FuriHalNfcEmulateCallback,
	                                 context: *mut core::ffi::c_void,
	                                 timeout: u32)
	                                 -> bool;
}
extern "C" {
	#[doc = " NFC data exchange"]
	#[doc = ""]
	#[doc = " @param       tx_rx_ctx   FuriHalNfcTxRxContext instance"]
	#[doc = ""]
	#[doc = " @return      true on success"]
	pub fn furi_hal_nfc_tx_rx(tx_rx: *mut FuriHalNfcTxRxContext, timeout_ms: u16) -> bool;
}
extern "C" {
	#[doc = " NFC data full exhange"]
	#[doc = ""]
	#[doc = " @param       tx_rx_ctx   FuriHalNfcTxRxContext instance"]
	#[doc = ""]
	#[doc = " @return      true on success"]
	pub fn furi_hal_nfc_tx_rx_full(tx_rx: *mut FuriHalNfcTxRxContext) -> bool;
}
extern "C" {
	#[doc = " NFC deactivate and start sleep"]
	pub fn furi_hal_nfc_sleep();
}
extern "C" {
	pub fn furi_hal_nfc_stop();
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum FuriHalNfcReturn {
	#[doc = "< no error occurred"]
	FuriHalNfcReturnOk = 0,
	#[doc = "< not enough memory to perform the requested operation"]
	FuriHalNfcReturnNomem = 1,
	#[doc = "< device or resource busy"]
	FuriHalNfcReturnBusy = 2,
	#[doc = "< generic IO error"]
	FuriHalNfcReturnIo = 3,
	#[doc = "< error due to timeout"]
	FuriHalNfcReturnTimeout = 4,
	#[doc = "< invalid request or requested function can't be executed at the moment"]
	FuriHalNfcReturnRequest = 5,
	#[doc = "< No message of desired type"]
	FuriHalNfcReturnNomsg = 6,
	#[doc = "< Parameter error"]
	FuriHalNfcReturnParam = 7,
	#[doc = "< System error"]
	FuriHalNfcReturnSystem = 8,
	#[doc = "< Framing error"]
	FuriHalNfcReturnFraming = 9,
	#[doc = "< lost one or more received bytes"]
	FuriHalNfcReturnOverrun = 10,
	#[doc = "< protocol error"]
	FuriHalNfcReturnProto = 11,
	#[doc = "< Internal Error"]
	FuriHalNfcReturnInternal = 12,
	#[doc = "< Call again"]
	FuriHalNfcReturnAgain = 13,
	#[doc = "< memory corruption"]
	FuriHalNfcReturnMemCorrupt = 14,
	#[doc = "< not implemented"]
	FuriHalNfcReturnNotImplemented = 15,
	#[doc = "< Program Counter has been manipulated or spike/noise trigger illegal operation"]
	FuriHalNfcReturnPcCorrupt = 16,
	#[doc = "< error sending"]
	FuriHalNfcReturnSend = 17,
	#[doc = "< indicates error detected but to be ignored"]
	FuriHalNfcReturnIgnore = 18,
	#[doc = "< indicates error in state machine (unexpected cmd)"]
	FuriHalNfcReturnSemantic = 19,
	#[doc = "< indicates error in state machine (unknown cmd)"]
	FuriHalNfcReturnSyntax = 20,
	#[doc = "< crc error"]
	FuriHalNfcReturnCrc = 21,
	#[doc = "< transponder not found"]
	FuriHalNfcReturnNotfound = 22,
	#[doc = "< transponder not unique - more than one transponder in field"]
	FuriHalNfcReturnNotunique = 23,
	#[doc = "< requested operation not supported"]
	FuriHalNfcReturnNotsupp = 24,
	#[doc = "< write error"]
	FuriHalNfcReturnWrite = 25,
	#[doc = "< fifo over or underflow error"]
	FuriHalNfcReturnFifo = 26,
	#[doc = "< parity error"]
	FuriHalNfcReturnPar = 27,
	#[doc = "< transfer has already finished"]
	FuriHalNfcReturnDone = 28,
	#[doc = "< collision error (Bit Collision or during RF Collision avoidance )"]
	FuriHalNfcReturnRfCollision = 29,
	#[doc = "< lost one or more received bytes"]
	FuriHalNfcReturnHwOverrun = 30,
	#[doc = "< device requested release"]
	FuriHalNfcReturnReleaseReq = 31,
	#[doc = "< device requested sleep"]
	FuriHalNfcReturnSleepReq = 32,
	#[doc = "< incorrent state for requested operation"]
	FuriHalNfcReturnWrongState = 33,
	#[doc = "< blocking procedure reached maximum runs"]
	FuriHalNfcReturnMaxReruns = 34,
	#[doc = "< operation aborted due to disabled configuration"]
	FuriHalNfcReturnDisabled = 35,
	#[doc = "< expected hw do not match"]
	FuriHalNfcReturnHwMismatch = 36,
	#[doc = "< Other device's field didn't behave as expected: turned off by Initiator in Passive mode, or AP2P did not turn on field"]
	FuriHalNfcReturnLinkLoss = 37,
	#[doc = "< invalid or not initalized device handle"]
	FuriHalNfcReturnInvalidHandle = 38,
	#[doc = "< Incomplete byte rcvd"]
	FuriHalNfcReturnIncompleteByte = 40,
	#[doc = "< Incomplete byte rcvd - 1 bit"]
	FuriHalNfcReturnIncompleteByte01 = 41,
	#[doc = "< Incomplete byte rcvd - 2 bit"]
	FuriHalNfcReturnIncompleteByte02 = 42,
	#[doc = "< Incomplete byte rcvd - 3 bit"]
	FuriHalNfcReturnIncompleteByte03 = 43,
	#[doc = "< Incomplete byte rcvd - 4 bit"]
	FuriHalNfcReturnIncompleteByte04 = 44,
	#[doc = "< Incomplete byte rcvd - 5 bit"]
	FuriHalNfcReturnIncompleteByte05 = 45,
	#[doc = "< Incomplete byte rcvd - 6 bit"]
	FuriHalNfcReturnIncompleteByte06 = 46,
	#[doc = "< Incomplete byte rcvd - 7 bit"]
	FuriHalNfcReturnIncompleteByte07 = 47,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum FuriHalNfcMode {
	#[doc = "< No mode selected/defined"]
	FuriHalNfcModeNone = 0,
	#[doc = "< Mode to perform as NFCA (ISO14443A) Poller (PCD)"]
	FuriHalNfcModePollNfca = 1,
	#[doc = "< Mode to perform as NFCA T1T (Topaz) Poller (PCD)"]
	FuriHalNfcModePollNfcaT1t = 2,
	#[doc = "< Mode to perform as NFCB (ISO14443B) Poller (PCD)"]
	FuriHalNfcModePollNfcb = 3,
	#[doc = "< Mode to perform as B' Calypso (Innovatron) (PCD)"]
	FuriHalNfcModePollBPrime = 4,
	#[doc = "< Mode to perform as CTS Poller (PCD)"]
	FuriHalNfcModePollBCts = 5,
	#[doc = "< Mode to perform as NFCF (FeliCa) Poller (PCD)"]
	FuriHalNfcModePollNfcf = 6,
	#[doc = "< Mode to perform as NFCV (ISO15963) Poller (PCD)"]
	FuriHalNfcModePollNfcv = 7,
	#[doc = "< Mode to perform as PicoPass / iClass Poller (PCD)"]
	FuriHalNfcModePollPicopass = 8,
	#[doc = "< Mode to perform as Active P2P (ISO18092) Initiator"]
	FuriHalNfcModePollActiveP2p = 9,
	#[doc = "< Mode to perform as NFCA (ISO14443A) Listener (PICC)"]
	FuriHalNfcModeListenNfca = 10,
	#[doc = "< Mode to perform as NFCA (ISO14443B) Listener (PICC)"]
	FuriHalNfcModeListenNfcb = 11,
	#[doc = "< Mode to perform as NFCA (ISO15963) Listener (PICC)"]
	FuriHalNfcModeListenNfcf = 12,
	#[doc = "< Mode to perform as Active P2P (ISO18092) Target"]
	FuriHalNfcModeListenActiveP2p = 13,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum FuriHalNfcBitrate {
	#[doc = "< Bit Rate 106 kbit/s (fc/128)"]
	FuriHalNfcBitrate106 = 0,
	#[doc = "< Bit Rate 212 kbit/s (fc/64)"]
	FuriHalNfcBitrate212 = 1,
	#[doc = "< Bit Rate 424 kbit/s (fc/32)"]
	FuriHalNfcBitrate424 = 2,
	#[doc = "< Bit Rate 848 kbit/s (fc/16)"]
	FuriHalNfcBitrate848 = 3,
	#[doc = "< Bit Rate 1695 kbit/s (fc/8)"]
	FuriHalNfcBitrate1695 = 4,
	#[doc = "< Bit Rate 3390 kbit/s (fc/4)"]
	FuriHalNfcBitrate3390 = 5,
	#[doc = "< Bit Rate 6780 kbit/s (fc/2)"]
	FuriHalNfcBitrate6780 = 6,
	#[doc = "< Bit Rate 13560 kbit/s (fc)"]
	FuriHalNfcBitrate13560 = 7,
	#[doc = "< Bit Rate 52.97 kbit/s (fc/256) Fast Mode VICC->VCD"]
	FuriHalNfcBitrate52p97 = 235,
	#[doc = "< Bit Rate 26,48 kbit/s (fc/512) NFCV VICC->VCD & VCD->VICC 1of4"]
	FuriHalNfcBitrate26p48 = 236,
	#[doc = "< Bit Rate 1,66 kbit/s (fc/8192) NFCV VCD->VICC 1of256"]
	FuriHalNfcBitrate1p66 = 237,
	#[doc = "< Value indicating to keep the same previous bit rate"]
	FuriHalNfcBitrateKeep = 255,
}
extern "C" {
	pub fn furi_hal_nfc_ll_set_mode(mode: FuriHalNfcMode, txBR: FuriHalNfcBitrate, rxBR: FuriHalNfcBitrate) -> FuriHalNfcReturn;
}
extern "C" {
	pub fn furi_hal_nfc_ll_set_guard_time(cycles: u32);
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum FuriHalNfcErrorHandling {
	#[doc = "< No special error handling will be performed"]
	FuriHalNfcErrorHandlingNone = 0,
	#[doc = "< Error handling set to perform as NFC compliant device"]
	FuriHalNfcErrorHandlingNfc = 1,
	#[doc = "< Error handling set to perform as EMVCo compliant device"]
	FuriHalNfcErrorHandlingEmvco = 2,
}
extern "C" {
	pub fn furi_hal_nfc_ll_set_error_handling(eHandling: FuriHalNfcErrorHandling);
}
extern "C" {
	pub fn furi_hal_nfc_ll_set_fdt_listen(cycles: u32);
}
extern "C" {
	pub fn furi_hal_nfc_ll_set_fdt_poll(FDTPoll: u32);
}
extern "C" {
	pub fn furi_hal_nfc_ll_txrx_on();
}
extern "C" {
	pub fn furi_hal_nfc_ll_txrx_off();
}
extern "C" {
	pub fn furi_hal_nfc_ll_txrx(txBuf: *mut u8,
	                            txBufLen: u16,
	                            rxBuf: *mut u8,
	                            rxBufLen: u16,
	                            actLen: *mut u16,
	                            flags: u32,
	                            fwt: u32)
	                            -> FuriHalNfcReturn;
}
extern "C" {
	pub fn furi_hal_nfc_ll_poll();
}
#[repr(u32)]
#[non_exhaustive]
#[doc = "\\brief Reporting status results."]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum _usbd_respond {
	#[doc = "<\\brief Function has an error, STALLPID will be issued."]
	usbd_fail = 0,
	#[doc = "<\\brief Function completes request accepted ZLP or data will be send."]
	usbd_ack = 1,
	#[doc = "<\\brief Function is busy. NAK handshake."]
	usbd_nak = 2,
}
#[doc = "\\brief Reporting status results."]
pub use self::_usbd_respond as usbd_respond;
#[doc = "\\brief Represents a USB device data."]
pub type usbd_device = _usbd_device;
#[doc = "\\brief Represents generic USB control request."]
#[repr(C)]
pub struct usbd_ctlreq {
	#[doc = "<\\brief This bitmapped field identifies the characteristics of"]
	#[doc = " the specific request."]
	pub bmRequestType: u8,
	#[doc = "<\\brief This field specifies the particular request."]
	pub bRequest: u8,
	#[doc = "<\\brief It is used to pass a parameter to the device, specific to"]
	#[doc = " the request."]
	pub wValue: u16,
	#[doc = "<\\brief It is used to pass a parameter to the device, specific to"]
	#[doc = " the request."]
	pub wIndex: u16,
	#[doc = "<\\brief This field specifies the length of the data transferred"]
	#[doc = " during the second phase of the control transfer."]
	pub wLength: u16,
	#[doc = "<\\brief Data payload."]
	pub data: __IncompleteArrayField<u8>,
}
#[test]
fn bindgen_test_layout_usbd_ctlreq() {
	assert_eq!(
	           ::core::mem::size_of::<usbd_ctlreq>(),
	           8usize,
	           concat!("Size of: ", stringify!(usbd_ctlreq))
	);
	assert_eq!(
	           ::core::mem::align_of::<usbd_ctlreq>(),
	           2usize,
	           concat!("Alignment of ", stringify!(usbd_ctlreq))
	);
	fn test_field_bmRequestType() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<usbd_ctlreq>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).bmRequestType) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(usbd_ctlreq), "::", stringify!(bmRequestType))
		);
	}
	test_field_bmRequestType();
	fn test_field_bRequest() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<usbd_ctlreq>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).bRequest) as usize - ptr as usize
		           },
		           1usize,
		           concat!("Offset of field: ", stringify!(usbd_ctlreq), "::", stringify!(bRequest))
		);
	}
	test_field_bRequest();
	fn test_field_wValue() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<usbd_ctlreq>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).wValue) as usize - ptr as usize
		           },
		           2usize,
		           concat!("Offset of field: ", stringify!(usbd_ctlreq), "::", stringify!(wValue))
		);
	}
	test_field_wValue();
	fn test_field_wIndex() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<usbd_ctlreq>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).wIndex) as usize - ptr as usize
		           },
		           4usize,
		           concat!("Offset of field: ", stringify!(usbd_ctlreq), "::", stringify!(wIndex))
		);
	}
	test_field_wIndex();
	fn test_field_wLength() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<usbd_ctlreq>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).wLength) as usize - ptr as usize
		           },
		           6usize,
		           concat!("Offset of field: ", stringify!(usbd_ctlreq), "::", stringify!(wLength))
		);
	}
	test_field_wLength();
	fn test_field_data() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<usbd_ctlreq>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).data) as usize - ptr as usize
		           },
		           8usize,
		           concat!("Offset of field: ", stringify!(usbd_ctlreq), "::", stringify!(data))
		);
	}
	test_field_data();
}
#[doc = " USB device status data."]
#[repr(C)]
pub struct usbd_status {
	#[doc = "<\\brief Pointer to data buffer used for control requests."]
	pub data_buf: *mut core::ffi::c_void,
	#[doc = "<\\brief Pointer to current data for control request."]
	pub data_ptr: *mut core::ffi::c_void,
	#[doc = "<\\brief Count remained data for control request."]
	pub data_count: u16,
	#[doc = "<\\brief Size of the data buffer for control requests."]
	pub data_maxsize: u16,
	#[doc = "<\\brief Size of the control endpoint."]
	pub ep0size: u8,
	#[doc = "<\\brief Current device configuration number."]
	pub device_cfg: u8,
	#[doc = "<\\brief Current \\ref usbd_machine_state."]
	pub device_state: u8,
	#[doc = "<\\brief Current \\ref usbd_ctl_state."]
	pub control_state: u8,
}
#[test]
fn bindgen_test_layout_usbd_status() {
	assert_eq!(
	           ::core::mem::size_of::<usbd_status>(),
	           16usize,
	           concat!("Size of: ", stringify!(usbd_status))
	);
	assert_eq!(
	           ::core::mem::align_of::<usbd_status>(),
	           4usize,
	           concat!("Alignment of ", stringify!(usbd_status))
	);
	fn test_field_data_buf() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<usbd_status>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).data_buf) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(usbd_status), "::", stringify!(data_buf))
		);
	}
	test_field_data_buf();
	fn test_field_data_ptr() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<usbd_status>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).data_ptr) as usize - ptr as usize
		           },
		           4usize,
		           concat!("Offset of field: ", stringify!(usbd_status), "::", stringify!(data_ptr))
		);
	}
	test_field_data_ptr();
	fn test_field_data_count() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<usbd_status>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).data_count) as usize - ptr as usize
		           },
		           8usize,
		           concat!("Offset of field: ", stringify!(usbd_status), "::", stringify!(data_count))
		);
	}
	test_field_data_count();
	fn test_field_data_maxsize() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<usbd_status>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).data_maxsize) as usize - ptr as usize
		           },
		           10usize,
		           concat!("Offset of field: ", stringify!(usbd_status), "::", stringify!(data_maxsize))
		);
	}
	test_field_data_maxsize();
	fn test_field_ep0size() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<usbd_status>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).ep0size) as usize - ptr as usize
		           },
		           12usize,
		           concat!("Offset of field: ", stringify!(usbd_status), "::", stringify!(ep0size))
		);
	}
	test_field_ep0size();
	fn test_field_device_cfg() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<usbd_status>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).device_cfg) as usize - ptr as usize
		           },
		           13usize,
		           concat!("Offset of field: ", stringify!(usbd_status), "::", stringify!(device_cfg))
		);
	}
	test_field_device_cfg();
	fn test_field_device_state() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<usbd_status>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).device_state) as usize - ptr as usize
		           },
		           14usize,
		           concat!("Offset of field: ", stringify!(usbd_status), "::", stringify!(device_state))
		);
	}
	test_field_device_state();
	fn test_field_control_state() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<usbd_status>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).control_state) as usize - ptr as usize
		           },
		           15usize,
		           concat!("Offset of field: ", stringify!(usbd_status), "::", stringify!(control_state))
		);
	}
	test_field_control_state();
}
#[doc = "\\brief Generic USB device event callback for events and endpoints processing"]
#[doc = " \\param[in] dev pointer to USB device"]
#[doc = " \\param event \\ref USB_EVENTS \"USB event\""]
#[doc = " \\param ep active endpoint number"]
#[doc = " \\note endpoints with same indexes i.e. 0x01 and 0x81 shares same callback."]
pub type usbd_evt_callback = ::core::option::Option<unsafe extern "C" fn(dev: *mut usbd_device, event: u8, ep: u8)>;
#[doc = "\\brief USB control transfer completed callback function."]
#[doc = " \\param[in] dev pointer to USB device"]
#[doc = " \\param[in] req pointer to usb request structure"]
#[doc = " \\note usbd_device->complete_callback will be set to NULL after this callback completion."]
pub type usbd_rqc_callback = ::core::option::Option<unsafe extern "C" fn(dev: *mut usbd_device, req: *mut usbd_ctlreq)>;
#[doc = "\\brief USB control callback function."]
#[doc = " \\details Uses for the control request processing."]
#[doc = "          Some requests will be handled by core if callback don't process it (returns FALSE)."]
#[doc = "            If request was not processed STALL PID will be issued."]
#[doc = "          - GET_CONFIGURATION"]
#[doc = "          - SET_CONFIGURATION (passes to \\ref usbd_cfg_callback)"]
#[doc = "          - GET_DESCRIPTOR (passes to \\ref usbd_dsc_callback)"]
#[doc = "          - GET_STATUS"]
#[doc = "          - SET_FEATURE, CLEAR_FEATURE (endpoints only)"]
#[doc = "          - SET_ADDRESS"]
#[doc = " \\param[in] dev points to USB device"]
#[doc = " \\param[in] req points to usb control request"]
#[doc = " \\param[out] *callback USB control transfer completion callback, default is NULL (no callback)"]
#[doc = " \\return usbd_respond status."]
pub type usbd_ctl_callback = ::core::option::Option<unsafe extern "C" fn(dev: *mut usbd_device,
                                                                         req: *mut usbd_ctlreq,
                                                                         callback: *mut usbd_rqc_callback)
                                                                         -> usbd_respond>;
#[doc = "\\brief USB get descriptor callback function"]
#[doc = " \\details Called when GET_DESCRIPTOR request issued"]
#[doc = " \\param[in] req pointer to usb control request structure"]
#[doc = " \\param[in,out] address pointer to the descriptor in memory. Points to req->data by default. You"]
#[doc = " can use this buffer."]
#[doc = " \\param[in,out] dsize descriptor size. maximum buffer size by default."]
#[doc = " \\return usbd_ack if you passed the correct descriptor, usbd_fail otherwise."]
pub type usbd_dsc_callback = ::core::option::Option<unsafe extern "C" fn(req: *mut usbd_ctlreq,
                                                                         address: *mut *mut core::ffi::c_void,
                                                                         dsize: *mut u16)
                                                                         -> usbd_respond>;
#[doc = "\\brief USB set configuration callback function"]
#[doc = " \\details called when SET_CONFIGURATION request issued"]
#[doc = " \\param[in] dev pointer to USB device"]
#[doc = " \\param[in] cfg configuration number."]
#[doc = " \\note if config is 0 device endpoints should be de-configured"]
#[doc = " \\return TRUE if success"]
pub type usbd_cfg_callback = ::core::option::Option<unsafe extern "C" fn(dev: *mut usbd_device, cfg: u8) -> usbd_respond>;
#[doc = "\\addtogroup USBD_HW"]
#[doc = " @{ */"]
#[doc = " \\return Hardware status and capabilities \\ref USBD_HW_CAPS"]
pub type usbd_hw_getinfo = ::core::option::Option<unsafe extern "C" fn() -> u32>;
#[doc = "\\brief Enables or disables USB hardware"]
#[doc = " \\param enable Enables USB when TRUE disables otherwise."]
pub type usbd_hw_enable = ::core::option::Option<unsafe extern "C" fn(enable: bool)>;
#[doc = " Connects or disconnects USB hardware to/from usb host"]
#[doc = " \\param connect Connects USB to host if TRUE, disconnects otherwise"]
#[doc = " \\return lanes connection status."]
pub type usbd_hw_connect = ::core::option::Option<unsafe extern "C" fn(connect: bool) -> u8>;
#[doc = "\\brief Sets USB hardware address"]
#[doc = " \\param address USB address"]
pub type usbd_hw_setaddr = ::core::option::Option<unsafe extern "C" fn(address: u8)>;
#[doc = "\\brief Configures endpoint"]
#[doc = " \\param ep endpoint address. Use USB_EPDIR_ macros to set endpoint direction"]
#[doc = " \\param eptype endpoint type. Use USB_EPTYPE_* macros."]
#[doc = " \\param epsize endpoint size in bytes"]
#[doc = " \\return TRUE if success"]
pub type usbd_hw_ep_config = ::core::option::Option<unsafe extern "C" fn(ep: u8, eptype: u8, epsize: u16) -> bool>;
#[doc = "\\brief De-configures, cleans and disables endpoint"]
#[doc = " \\param ep endpoint index"]
#[doc = " \\note if you have two one-direction single-buffered endpoints with same index (i.e. 0x02 and 0x82)"]
#[doc = " both will be deconfigured."]
pub type usbd_hw_ep_deconfig = ::core::option::Option<unsafe extern "C" fn(ep: u8)>;
#[doc = "\\brief Reads data from OUT or control endpoint"]
#[doc = " \\param ep endpoint index, should belong to OUT or CONTROL endpoint."]
#[doc = " \\param buf pointer to read buffer"]
#[doc = " \\param blen size of the read buffer in bytes"]
#[doc = " \\return size of the actually received data, -1 on error."]
#[doc = " \\note if data does not fit buffer it will be truncated"]
pub type usbd_hw_ep_read = ::core::option::Option<unsafe extern "C" fn(ep: u8, buf: *mut core::ffi::c_void, blen: u16) -> i32>;
#[doc = "\\brief Writes data to IN or control endpoint"]
#[doc = " \\param ep endpoint index, hould belong to IN or CONTROL endpoint"]
#[doc = " \\param buf pointer to data buffer"]
#[doc = " \\param blen size of data will be written"]
#[doc = " \\return number of written bytes"]
pub type usbd_hw_ep_write = ::core::option::Option<unsafe extern "C" fn(ep: u8, buf: *mut core::ffi::c_void, blen: u16) -> i32>;
#[doc = " Stalls and unstalls endpoint"]
#[doc = " \\param ep endpoint address"]
#[doc = " \\param stall endpoint will be stalled if TRUE and unstalled otherwise."]
#[doc = " \\note Has no effect on inactive endpoints."]
pub type usbd_hw_ep_setstall = ::core::option::Option<unsafe extern "C" fn(ep: u8, stall: bool)>;
#[doc = "\\brief Checks endpoint for stalled state"]
#[doc = " \\param ep endpoint address"]
#[doc = " \\return TRUE if endpoint is stalled"]
pub type usbd_hw_ep_isstalled = ::core::option::Option<unsafe extern "C" fn(ep: u8) -> bool>;
#[doc = "\\brief Polls USB hardware for the events"]
#[doc = " \\param[in] dev pointer to usb device structure"]
#[doc = " \\param callback callback to event processing subroutine"]
pub type usbd_hw_poll = ::core::option::Option<unsafe extern "C" fn(dev: *mut usbd_device, callback: usbd_evt_callback)>;
#[doc = "\\brief Gets frame number from usb hardware."]
pub type usbd_hw_get_frameno = ::core::option::Option<unsafe extern "C" fn() -> u16>;
#[doc = "\\brief Makes a string descriptor contains unique serial number from hardware ID's"]
#[doc = " \\param[in] buffer pointer to buffer for the descriptor"]
#[doc = " \\return of the descriptor in bytes"]
pub type usbd_hw_get_serialno = ::core::option::Option<unsafe extern "C" fn(buffer: *mut core::ffi::c_void) -> u16>;
#[doc = "\\brief Represents a hardware USB driver call table."]
#[repr(C)]
pub struct usbd_driver {
	#[doc = "<\\copybrief usbd_hw_getinfo"]
	pub getinfo: usbd_hw_getinfo,
	#[doc = "<\\copybrief usbd_hw_enable"]
	pub enable: usbd_hw_enable,
	#[doc = "<\\copybrief usbd_hw_connect"]
	pub connect: usbd_hw_connect,
	#[doc = "<\\copybrief usbd_hw_setaddr"]
	pub setaddr: usbd_hw_setaddr,
	#[doc = "<\\copybrief usbd_hw_ep_config"]
	pub ep_config: usbd_hw_ep_config,
	#[doc = "<\\copybrief usbd_hw_ep_deconfig"]
	pub ep_deconfig: usbd_hw_ep_deconfig,
	#[doc = "<\\copybrief usbd_hw_ep_read"]
	pub ep_read: usbd_hw_ep_read,
	#[doc = "<\\copybrief usbd_hw_ep_write"]
	pub ep_write: usbd_hw_ep_write,
	#[doc = "<\\copybrief usbd_hw_ep_setstall"]
	pub ep_setstall: usbd_hw_ep_setstall,
	#[doc = "<\\copybrief usbd_hw_ep_isstalled"]
	pub ep_isstalled: usbd_hw_ep_isstalled,
	#[doc = "<\\copybrief usbd_hw_poll"]
	pub poll: usbd_hw_poll,
	#[doc = "<\\copybrief usbd_hw_get_frameno"]
	pub frame_no: usbd_hw_get_frameno,
	#[doc = "<\\copybrief usbd_hw_get_serialno"]
	pub get_serialno_desc: usbd_hw_get_serialno,
}
#[test]
fn bindgen_test_layout_usbd_driver() {
	assert_eq!(
	           ::core::mem::size_of::<usbd_driver>(),
	           52usize,
	           concat!("Size of: ", stringify!(usbd_driver))
	);
	assert_eq!(
	           ::core::mem::align_of::<usbd_driver>(),
	           4usize,
	           concat!("Alignment of ", stringify!(usbd_driver))
	);
	fn test_field_getinfo() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<usbd_driver>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).getinfo) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(usbd_driver), "::", stringify!(getinfo))
		);
	}
	test_field_getinfo();
	fn test_field_enable() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<usbd_driver>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).enable) as usize - ptr as usize
		           },
		           4usize,
		           concat!("Offset of field: ", stringify!(usbd_driver), "::", stringify!(enable))
		);
	}
	test_field_enable();
	fn test_field_connect() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<usbd_driver>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).connect) as usize - ptr as usize
		           },
		           8usize,
		           concat!("Offset of field: ", stringify!(usbd_driver), "::", stringify!(connect))
		);
	}
	test_field_connect();
	fn test_field_setaddr() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<usbd_driver>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).setaddr) as usize - ptr as usize
		           },
		           12usize,
		           concat!("Offset of field: ", stringify!(usbd_driver), "::", stringify!(setaddr))
		);
	}
	test_field_setaddr();
	fn test_field_ep_config() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<usbd_driver>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).ep_config) as usize - ptr as usize
		           },
		           16usize,
		           concat!("Offset of field: ", stringify!(usbd_driver), "::", stringify!(ep_config))
		);
	}
	test_field_ep_config();
	fn test_field_ep_deconfig() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<usbd_driver>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).ep_deconfig) as usize - ptr as usize
		           },
		           20usize,
		           concat!("Offset of field: ", stringify!(usbd_driver), "::", stringify!(ep_deconfig))
		);
	}
	test_field_ep_deconfig();
	fn test_field_ep_read() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<usbd_driver>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).ep_read) as usize - ptr as usize
		           },
		           24usize,
		           concat!("Offset of field: ", stringify!(usbd_driver), "::", stringify!(ep_read))
		);
	}
	test_field_ep_read();
	fn test_field_ep_write() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<usbd_driver>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).ep_write) as usize - ptr as usize
		           },
		           28usize,
		           concat!("Offset of field: ", stringify!(usbd_driver), "::", stringify!(ep_write))
		);
	}
	test_field_ep_write();
	fn test_field_ep_setstall() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<usbd_driver>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).ep_setstall) as usize - ptr as usize
		           },
		           32usize,
		           concat!("Offset of field: ", stringify!(usbd_driver), "::", stringify!(ep_setstall))
		);
	}
	test_field_ep_setstall();
	fn test_field_ep_isstalled() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<usbd_driver>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).ep_isstalled) as usize - ptr as usize
		           },
		           36usize,
		           concat!("Offset of field: ", stringify!(usbd_driver), "::", stringify!(ep_isstalled))
		);
	}
	test_field_ep_isstalled();
	fn test_field_poll() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<usbd_driver>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).poll) as usize - ptr as usize
		           },
		           40usize,
		           concat!("Offset of field: ", stringify!(usbd_driver), "::", stringify!(poll))
		);
	}
	test_field_poll();
	fn test_field_frame_no() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<usbd_driver>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).frame_no) as usize - ptr as usize
		           },
		           44usize,
		           concat!("Offset of field: ", stringify!(usbd_driver), "::", stringify!(frame_no))
		);
	}
	test_field_frame_no();
	fn test_field_get_serialno_desc() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<usbd_driver>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).get_serialno_desc) as usize - ptr as usize
		           },
		           48usize,
		           concat!(
			"Offset of field: ",
			stringify!(usbd_driver),
			"::",
			stringify!(get_serialno_desc)
		)
		);
	}
	test_field_get_serialno_desc();
}
#[doc = "\\brief Represents a USB device data."]
#[repr(C)]
pub struct _usbd_device {
	#[doc = "<\\copybrief usbd_driver"]
	pub driver: *const usbd_driver,
	#[doc = "<\\copybrief usbd_ctl_callback"]
	pub control_callback: usbd_ctl_callback,
	#[doc = "<\\copybrief usbd_rqc_callback"]
	pub complete_callback: usbd_rqc_callback,
	#[doc = "<\\copybrief usbd_cfg_callback"]
	pub config_callback: usbd_cfg_callback,
	#[doc = "<\\copybrief usbd_dsc_callback"]
	pub descriptor_callback: usbd_dsc_callback,
	#[doc = "<\\brief array of the event callbacks."]
	pub events: [usbd_evt_callback; 8usize],
	#[doc = "<\\brief array of the endpoint callbacks."]
	pub endpoint: [usbd_evt_callback; 8usize],
	#[doc = "<\\copybrief usbd_status"]
	pub status: usbd_status,
}
#[test]
fn bindgen_test_layout__usbd_device() {
	assert_eq!(
	           ::core::mem::size_of::<_usbd_device>(),
	           100usize,
	           concat!("Size of: ", stringify!(_usbd_device))
	);
	assert_eq!(
	           ::core::mem::align_of::<_usbd_device>(),
	           4usize,
	           concat!("Alignment of ", stringify!(_usbd_device))
	);
	fn test_field_driver() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<_usbd_device>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).driver) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(_usbd_device), "::", stringify!(driver))
		);
	}
	test_field_driver();
	fn test_field_control_callback() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<_usbd_device>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).control_callback) as usize - ptr as usize
		           },
		           4usize,
		           concat!(
			"Offset of field: ",
			stringify!(_usbd_device),
			"::",
			stringify!(control_callback)
		)
		);
	}
	test_field_control_callback();
	fn test_field_complete_callback() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<_usbd_device>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).complete_callback) as usize - ptr as usize
		           },
		           8usize,
		           concat!(
			"Offset of field: ",
			stringify!(_usbd_device),
			"::",
			stringify!(complete_callback)
		)
		);
	}
	test_field_complete_callback();
	fn test_field_config_callback() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<_usbd_device>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).config_callback) as usize - ptr as usize
		           },
		           12usize,
		           concat!(
			"Offset of field: ",
			stringify!(_usbd_device),
			"::",
			stringify!(config_callback)
		)
		);
	}
	test_field_config_callback();
	fn test_field_descriptor_callback() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<_usbd_device>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).descriptor_callback) as usize - ptr as usize
		           },
		           16usize,
		           concat!(
			"Offset of field: ",
			stringify!(_usbd_device),
			"::",
			stringify!(descriptor_callback)
		)
		);
	}
	test_field_descriptor_callback();
	fn test_field_events() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<_usbd_device>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).events) as usize - ptr as usize
		           },
		           20usize,
		           concat!("Offset of field: ", stringify!(_usbd_device), "::", stringify!(events))
		);
	}
	test_field_events();
	fn test_field_endpoint() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<_usbd_device>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).endpoint) as usize - ptr as usize
		           },
		           52usize,
		           concat!("Offset of field: ", stringify!(_usbd_device), "::", stringify!(endpoint))
		);
	}
	test_field_endpoint();
	fn test_field_status() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<_usbd_device>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).status) as usize - ptr as usize
		           },
		           84usize,
		           concat!("Offset of field: ", stringify!(_usbd_device), "::", stringify!(status))
		);
	}
	test_field_status();
}
extern "C" {
	#[doc = "\\brief Polls USB for events"]
	#[doc = " \\param dev Pointer to device structure"]
	#[doc = " \\note can be called as from main routine as from USB interrupt"]
	pub fn usbd_poll(dev: *mut usbd_device);
}
#[doc = "\\brief Represents a USB device descriptor"]
#[doc = " \\details A device descriptor describes general information about a USB device. It includes"]
#[doc = " information that applies globally to the device and all of the devices configurations. A USB"]
#[doc = " device has only one device descriptor. A high-speed capable device that has different device"]
#[doc = " information for full-speed and high-speed must also  have a \\ref usb_qualifier_descriptor."]
#[repr(C, packed)]
pub struct usb_device_descriptor {
	#[doc = "<\\brief Size of the descriptor, in bytes."]
	pub bLength: u8,
	#[doc = "<\\brief \\ref USB_DTYPE_DEVICE Device descriptor."]
	pub bDescriptorType: u8,
	#[doc = "<\\brief BCD of the supported USB specification."]
	pub bcdUSB: u16,
	#[doc = "<\\brief USB device class."]
	pub bDeviceClass: u8,
	#[doc = "<\\brief USB device subclass."]
	pub bDeviceSubClass: u8,
	#[doc = "<\\brief USB device protocol."]
	pub bDeviceProtocol: u8,
	#[doc = "<\\brief Size of the control endpoint's bank in bytes."]
	pub bMaxPacketSize0: u8,
	#[doc = "<\\brief Vendor ID for the USB product."]
	pub idVendor: u16,
	#[doc = "<\\brief Unique product ID for the USB product."]
	pub idProduct: u16,
	#[doc = "<\\brief Product release (version) number."]
	pub bcdDevice: u16,
	#[doc = "<\\brief String index for the manufacturer's name."]
	pub iManufacturer: u8,
	#[doc = "<\\brief String index for the product name/details."]
	pub iProduct: u8,
	#[doc = "<\\brief String index for the product serial number."]
	pub iSerialNumber: u8,
	#[doc = "<\\brief Total number of configurations supported by the device."]
	pub bNumConfigurations: u8,
}
#[test]
fn bindgen_test_layout_usb_device_descriptor() {
	assert_eq!(
	           ::core::mem::size_of::<usb_device_descriptor>(),
	           18usize,
	           concat!("Size of: ", stringify!(usb_device_descriptor))
	);
	assert_eq!(
	           ::core::mem::align_of::<usb_device_descriptor>(),
	           1usize,
	           concat!("Alignment of ", stringify!(usb_device_descriptor))
	);
	fn test_field_bLength() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<usb_device_descriptor>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).bLength) as usize - ptr as usize
		           },
		           0usize,
		           concat!(
			"Offset of field: ",
			stringify!(usb_device_descriptor),
			"::",
			stringify!(bLength)
		)
		);
	}
	test_field_bLength();
	fn test_field_bDescriptorType() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<usb_device_descriptor>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).bDescriptorType) as usize - ptr as usize
		           },
		           1usize,
		           concat!(
			"Offset of field: ",
			stringify!(usb_device_descriptor),
			"::",
			stringify!(bDescriptorType)
		)
		);
	}
	test_field_bDescriptorType();
	fn test_field_bcdUSB() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<usb_device_descriptor>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).bcdUSB) as usize - ptr as usize
		           },
		           2usize,
		           concat!(
			"Offset of field: ",
			stringify!(usb_device_descriptor),
			"::",
			stringify!(bcdUSB)
		)
		);
	}
	test_field_bcdUSB();
	fn test_field_bDeviceClass() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<usb_device_descriptor>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).bDeviceClass) as usize - ptr as usize
		           },
		           4usize,
		           concat!(
			"Offset of field: ",
			stringify!(usb_device_descriptor),
			"::",
			stringify!(bDeviceClass)
		)
		);
	}
	test_field_bDeviceClass();
	fn test_field_bDeviceSubClass() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<usb_device_descriptor>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).bDeviceSubClass) as usize - ptr as usize
		           },
		           5usize,
		           concat!(
			"Offset of field: ",
			stringify!(usb_device_descriptor),
			"::",
			stringify!(bDeviceSubClass)
		)
		);
	}
	test_field_bDeviceSubClass();
	fn test_field_bDeviceProtocol() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<usb_device_descriptor>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).bDeviceProtocol) as usize - ptr as usize
		           },
		           6usize,
		           concat!(
			"Offset of field: ",
			stringify!(usb_device_descriptor),
			"::",
			stringify!(bDeviceProtocol)
		)
		);
	}
	test_field_bDeviceProtocol();
	fn test_field_bMaxPacketSize0() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<usb_device_descriptor>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).bMaxPacketSize0) as usize - ptr as usize
		           },
		           7usize,
		           concat!(
			"Offset of field: ",
			stringify!(usb_device_descriptor),
			"::",
			stringify!(bMaxPacketSize0)
		)
		);
	}
	test_field_bMaxPacketSize0();
	fn test_field_idVendor() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<usb_device_descriptor>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).idVendor) as usize - ptr as usize
		           },
		           8usize,
		           concat!(
			"Offset of field: ",
			stringify!(usb_device_descriptor),
			"::",
			stringify!(idVendor)
		)
		);
	}
	test_field_idVendor();
	fn test_field_idProduct() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<usb_device_descriptor>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).idProduct) as usize - ptr as usize
		           },
		           10usize,
		           concat!(
			"Offset of field: ",
			stringify!(usb_device_descriptor),
			"::",
			stringify!(idProduct)
		)
		);
	}
	test_field_idProduct();
	fn test_field_bcdDevice() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<usb_device_descriptor>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).bcdDevice) as usize - ptr as usize
		           },
		           12usize,
		           concat!(
			"Offset of field: ",
			stringify!(usb_device_descriptor),
			"::",
			stringify!(bcdDevice)
		)
		);
	}
	test_field_bcdDevice();
	fn test_field_iManufacturer() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<usb_device_descriptor>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).iManufacturer) as usize - ptr as usize
		           },
		           14usize,
		           concat!(
			"Offset of field: ",
			stringify!(usb_device_descriptor),
			"::",
			stringify!(iManufacturer)
		)
		);
	}
	test_field_iManufacturer();
	fn test_field_iProduct() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<usb_device_descriptor>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).iProduct) as usize - ptr as usize
		           },
		           15usize,
		           concat!(
			"Offset of field: ",
			stringify!(usb_device_descriptor),
			"::",
			stringify!(iProduct)
		)
		);
	}
	test_field_iProduct();
	fn test_field_iSerialNumber() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<usb_device_descriptor>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).iSerialNumber) as usize - ptr as usize
		           },
		           16usize,
		           concat!(
			"Offset of field: ",
			stringify!(usb_device_descriptor),
			"::",
			stringify!(iSerialNumber)
		)
		);
	}
	test_field_iSerialNumber();
	fn test_field_bNumConfigurations() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<usb_device_descriptor>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).bNumConfigurations) as usize - ptr as usize
		           },
		           17usize,
		           concat!(
			"Offset of field: ",
			stringify!(usb_device_descriptor),
			"::",
			stringify!(bNumConfigurations)
		)
		);
	}
	test_field_bNumConfigurations();
}
extern "C" {
	pub static usbd_devfs: usbd_driver;
}
#[repr(C)]
pub struct FuriHalUsbInterface {
	pub init: ::core::option::Option<unsafe extern "C" fn(dev: *mut usbd_device,
	                                                      intf: *mut FuriHalUsbInterface,
	                                                      ctx: *mut core::ffi::c_void)>,
	pub deinit: ::core::option::Option<unsafe extern "C" fn(dev: *mut usbd_device)>,
	pub wakeup: ::core::option::Option<unsafe extern "C" fn(dev: *mut usbd_device)>,
	pub suspend: ::core::option::Option<unsafe extern "C" fn(dev: *mut usbd_device)>,
	pub dev_descr: *mut usb_device_descriptor,
	pub str_manuf_descr: *mut core::ffi::c_void,
	pub str_prod_descr: *mut core::ffi::c_void,
	pub str_serial_descr: *mut core::ffi::c_void,
	pub cfg_descr: *mut core::ffi::c_void,
}
#[test]
fn bindgen_test_layout_FuriHalUsbInterface() {
	assert_eq!(
	           ::core::mem::size_of::<FuriHalUsbInterface>(),
	           36usize,
	           concat!("Size of: ", stringify!(FuriHalUsbInterface))
	);
	assert_eq!(
	           ::core::mem::align_of::<FuriHalUsbInterface>(),
	           4usize,
	           concat!("Alignment of ", stringify!(FuriHalUsbInterface))
	);
	fn test_field_init() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<FuriHalUsbInterface>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).init) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(FuriHalUsbInterface), "::", stringify!(init))
		);
	}
	test_field_init();
	fn test_field_deinit() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<FuriHalUsbInterface>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).deinit) as usize - ptr as usize
		           },
		           4usize,
		           concat!("Offset of field: ", stringify!(FuriHalUsbInterface), "::", stringify!(deinit))
		);
	}
	test_field_deinit();
	fn test_field_wakeup() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<FuriHalUsbInterface>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).wakeup) as usize - ptr as usize
		           },
		           8usize,
		           concat!("Offset of field: ", stringify!(FuriHalUsbInterface), "::", stringify!(wakeup))
		);
	}
	test_field_wakeup();
	fn test_field_suspend() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<FuriHalUsbInterface>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).suspend) as usize - ptr as usize
		           },
		           12usize,
		           concat!(
			"Offset of field: ",
			stringify!(FuriHalUsbInterface),
			"::",
			stringify!(suspend)
		)
		);
	}
	test_field_suspend();
	fn test_field_dev_descr() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<FuriHalUsbInterface>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).dev_descr) as usize - ptr as usize
		           },
		           16usize,
		           concat!(
			"Offset of field: ",
			stringify!(FuriHalUsbInterface),
			"::",
			stringify!(dev_descr)
		)
		);
	}
	test_field_dev_descr();
	fn test_field_str_manuf_descr() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<FuriHalUsbInterface>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).str_manuf_descr) as usize - ptr as usize
		           },
		           20usize,
		           concat!(
			"Offset of field: ",
			stringify!(FuriHalUsbInterface),
			"::",
			stringify!(str_manuf_descr)
		)
		);
	}
	test_field_str_manuf_descr();
	fn test_field_str_prod_descr() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<FuriHalUsbInterface>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).str_prod_descr) as usize - ptr as usize
		           },
		           24usize,
		           concat!(
			"Offset of field: ",
			stringify!(FuriHalUsbInterface),
			"::",
			stringify!(str_prod_descr)
		)
		);
	}
	test_field_str_prod_descr();
	fn test_field_str_serial_descr() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<FuriHalUsbInterface>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).str_serial_descr) as usize - ptr as usize
		           },
		           28usize,
		           concat!(
			"Offset of field: ",
			stringify!(FuriHalUsbInterface),
			"::",
			stringify!(str_serial_descr)
		)
		);
	}
	test_field_str_serial_descr();
	fn test_field_cfg_descr() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<FuriHalUsbInterface>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).cfg_descr) as usize - ptr as usize
		           },
		           32usize,
		           concat!(
			"Offset of field: ",
			stringify!(FuriHalUsbInterface),
			"::",
			stringify!(cfg_descr)
		)
		);
	}
	test_field_cfg_descr();
}
extern "C" {
	#[doc = " USB device interface modes"]
	pub static mut usb_cdc_single: FuriHalUsbInterface;
}
extern "C" {
	pub static mut usb_cdc_dual: FuriHalUsbInterface;
}
extern "C" {
	pub static mut usb_hid: FuriHalUsbInterface;
}
extern "C" {
	pub static mut usb_hid_u2f: FuriHalUsbInterface;
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum FuriHalUsbStateEvent {
	FuriHalUsbStateEventReset = 0,
	FuriHalUsbStateEventWakeup = 1,
	FuriHalUsbStateEventSuspend = 2,
	FuriHalUsbStateEventDescriptorRequest = 3,
}
pub type FuriHalUsbStateCallback =
	::core::option::Option<unsafe extern "C" fn(state: FuriHalUsbStateEvent, context: *mut core::ffi::c_void)>;
extern "C" {
	#[doc = " USB device low-level initialization"]
	pub fn furi_hal_usb_init();
}
extern "C" {
	#[doc = " Set USB device configuration"]
	#[doc = ""]
	#[doc = " @param      mode new USB device mode"]
	#[doc = " @param      ctx context passed to device mode init function"]
	#[doc = " @return     true - mode switch started, false - mode switch is locked"]
	pub fn furi_hal_usb_set_config(new_if: *mut FuriHalUsbInterface, ctx: *mut core::ffi::c_void) -> bool;
}
extern "C" {
	#[doc = " Get USB device configuration"]
	#[doc = ""]
	#[doc = " @return    current USB device mode"]
	pub fn furi_hal_usb_get_config() -> *mut FuriHalUsbInterface;
}
extern "C" {
	#[doc = " Lock USB device mode switch"]
	pub fn furi_hal_usb_lock();
}
extern "C" {
	#[doc = " Unlock USB device mode switch"]
	pub fn furi_hal_usb_unlock();
}
extern "C" {
	#[doc = " Check if USB device mode switch locked"]
	#[doc = ""]
	#[doc = " @return    lock state"]
	pub fn furi_hal_usb_is_locked() -> bool;
}
extern "C" {
	#[doc = " Disable USB device"]
	pub fn furi_hal_usb_disable();
}
extern "C" {
	#[doc = " Enable USB device"]
	pub fn furi_hal_usb_enable();
}
extern "C" {
	#[doc = " Set USB state callback"]
	pub fn furi_hal_usb_set_state_callback(cb: FuriHalUsbStateCallback, ctx: *mut core::ffi::c_void);
}
extern "C" {
	#[doc = " Restart USB device"]
	pub fn furi_hal_usb_reinit();
}
pub type HidStateCallback = ::core::option::Option<unsafe extern "C" fn(state: bool, context: *mut core::ffi::c_void)>;
extern "C" {
	#[doc = " Get USB HID connection state"]
	#[doc = ""]
	#[doc = " @return      true / false"]
	pub fn furi_hal_hid_is_connected() -> bool;
}
extern "C" {
	#[doc = " Get USB HID keyboard leds state"]
	#[doc = ""]
	#[doc = " @return      leds state"]
	pub fn furi_hal_hid_get_led_state() -> u8;
}
extern "C" {
	#[doc = " Set USB HID connect/disconnect callback"]
	#[doc = ""]
	#[doc = " @param      cb  callback"]
	#[doc = " @param      ctx  callback context"]
	pub fn furi_hal_hid_set_state_callback(cb: HidStateCallback, ctx: *mut core::ffi::c_void);
}
extern "C" {
	#[doc = " Set the following key to pressed state and send HID report"]
	#[doc = ""]
	#[doc = " @param      button  key code"]
	pub fn furi_hal_hid_kb_press(button: u16) -> bool;
}
extern "C" {
	#[doc = " Set the following key to released state and send HID report"]
	#[doc = ""]
	#[doc = " @param      button  key code"]
	pub fn furi_hal_hid_kb_release(button: u16) -> bool;
}
extern "C" {
	#[doc = " Clear all pressed keys and send HID report"]
	#[doc = ""]
	pub fn furi_hal_hid_kb_release_all() -> bool;
}
extern "C" {
	#[doc = " Set mouse movement and send HID report"]
	#[doc = ""]
	#[doc = " @param      dx  x coordinate delta"]
	#[doc = " @param      dy  y coordinate delta"]
	pub fn furi_hal_hid_mouse_move(dx: i8, dy: i8) -> bool;
}
extern "C" {
	#[doc = " Set mouse button to pressed state and send HID report"]
	#[doc = ""]
	#[doc = " @param      button  key code"]
	pub fn furi_hal_hid_mouse_press(button: u8) -> bool;
}
extern "C" {
	#[doc = " Set mouse button to released state and send HID report"]
	#[doc = ""]
	#[doc = " @param      button  key code"]
	pub fn furi_hal_hid_mouse_release(button: u8) -> bool;
}
extern "C" {
	#[doc = " Set mouse wheel position and send HID report"]
	#[doc = ""]
	#[doc = " @param      delta  number of scroll steps"]
	pub fn furi_hal_hid_mouse_scroll(delta: i8) -> bool;
}
extern "C" {
	#[doc = " Set the following consumer key to pressed state and send HID report"]
	#[doc = ""]
	#[doc = " @param      button  key code"]
	pub fn furi_hal_hid_consumer_key_press(button: u16) -> bool;
}
extern "C" {
	#[doc = " Set the following consumer key to released state and send HID report"]
	#[doc = ""]
	#[doc = " @param      button  key code"]
	pub fn furi_hal_hid_consumer_key_release(button: u16) -> bool;
}
#[repr(C)]
pub struct FuriHalCompress {
	_unused: [u8; 0],
}
extern "C" {
	#[doc = " Initialize icon decoder"]
	pub fn furi_hal_compress_icon_init();
}
extern "C" {
	#[doc = " Icon decoder"]
	#[doc = ""]
	#[doc = " @param   icon_data    pointer to icon data"]
	#[doc = " @param   decoded_buff pointer to decoded buffer"]
	pub fn furi_hal_compress_icon_decode(icon_data: *const u8, decoded_buff: *mut *mut u8);
}
extern "C" {
	#[doc = " Allocate encoder and decoder"]
	#[doc = ""]
	#[doc = " @param   compress_buff_size  size of decoder and encoder buffer to allocate"]
	#[doc = ""]
	#[doc = " @return  FuriHalCompress instance"]
	pub fn furi_hal_compress_alloc(compress_buff_size: u16) -> *mut FuriHalCompress;
}
extern "C" {
	#[doc = " Free encoder and decoder"]
	#[doc = ""]
	#[doc = " @param   compress  FuriHalCompress instance"]
	pub fn furi_hal_compress_free(compress: *mut FuriHalCompress);
}
extern "C" {
	#[doc = " Encode data"]
	#[doc = ""]
	#[doc = " @param   compress FuriHalCompress instance"]
	#[doc = " @param   data_in pointer to input data"]
	#[doc = " @param   data_in_size size of input data"]
	#[doc = " @param   data_out maximum size of output data"]
	#[doc = " @param   data_res_size pointer to result output data size"]
	#[doc = ""]
	#[doc = " @return  true on success"]
	pub fn furi_hal_compress_encode(compress: *mut FuriHalCompress,
	                                data_in: *mut u8,
	                                data_in_size: usize,
	                                data_out: *mut u8,
	                                data_out_size: usize,
	                                data_res_size: *mut usize)
	                                -> bool;
}
extern "C" {
	#[doc = " Decode data"]
	#[doc = ""]
	#[doc = " @param   compress FuriHalCompress instance"]
	#[doc = " @param   data_in pointer to input data"]
	#[doc = " @param   data_in_size size of input data"]
	#[doc = " @param   data_out maximum size of output data"]
	#[doc = " @param   data_res_size pointer to result output data size"]
	#[doc = ""]
	#[doc = " @return  true on success"]
	pub fn furi_hal_compress_decode(compress: *mut FuriHalCompress,
	                                data_in: *mut u8,
	                                data_in_size: usize,
	                                data_out: *mut u8,
	                                data_out_size: usize,
	                                data_res_size: *mut usize)
	                                -> bool;
}
#[doc = " Callback type called every time another key-value pair of device information is ready"]
#[doc = ""]
#[doc = " @param      key[in]      device information type identifier"]
#[doc = " @param      value[in]    device information value"]
#[doc = " @param      last[in]     whether the passed key-value pair is the last one"]
#[doc = " @param      context[in]  to pass to callback"]
pub type FuriHalInfoValueCallback = ::core::option::Option<unsafe extern "C" fn(key: *const core::ffi::c_char,
                                                                                value: *const core::ffi::c_char,
                                                                                last: bool,
                                                                                context: *mut core::ffi::c_void)>;
extern "C" {
	#[doc = " Get device information"]
	#[doc = ""]
	#[doc = " @param[in]  callback     callback to provide with new data"]
	#[doc = " @param[in]  context      context to pass to callback"]
	pub fn furi_hal_info_get(callback: FuriHalInfoValueCallback, context: *mut core::ffi::c_void);
}
extern "C" {
	#[doc = " Get random value"]
	#[doc = ""]
	#[doc = " @return     random value"]
	pub fn furi_hal_random_get() -> u32;
}
extern "C" {
	#[doc = " Fill buffer with random data"]
	#[doc = ""]
	#[doc = " @param      buf  buffer pointer"]
	#[doc = " @param      data buffer len"]
	pub fn furi_hal_random_fill_buf(buf: *mut u8, len: u32);
}
extern "C" {
	#[doc = " Early FuriHal init, only essential subsystems"]
	pub fn furi_hal_init_early();
}
extern "C" {
	#[doc = " Early FuriHal deinit"]
	pub fn furi_hal_deinit_early();
}
extern "C" {
	#[doc = " Init FuriHal"]
	pub fn furi_hal_init();
}
extern "C" {
	#[doc = " Transfer execution to address"]
	#[doc = ""]
	#[doc = " @param[in]  address  pointer to new executable"]
	pub fn furi_hal_switch(address: *mut core::ffi::c_void);
}
extern "C" {
	#[doc = " Start Hid Keyboard Profile"]
	pub fn furi_hal_bt_hid_start();
}
extern "C" {
	#[doc = " Stop Hid Keyboard Profile"]
	pub fn furi_hal_bt_hid_stop();
}
extern "C" {
	#[doc = " Press keyboard button"]
	#[doc = ""]
	#[doc = " @param button    button code from HID specification"]
	#[doc = ""]
	#[doc = " @return          true on success"]
	pub fn furi_hal_bt_hid_kb_press(button: u16) -> bool;
}
extern "C" {
	#[doc = " Release keyboard button"]
	#[doc = ""]
	#[doc = " @param button    button code from HID specification"]
	#[doc = ""]
	#[doc = " @return          true on success"]
	pub fn furi_hal_bt_hid_kb_release(button: u16) -> bool;
}
extern "C" {
	#[doc = " Release all keyboard buttons"]
	#[doc = ""]
	#[doc = " @return          true on success"]
	pub fn furi_hal_bt_hid_kb_release_all() -> bool;
}
extern "C" {
	#[doc = " Set mouse movement and send HID report"]
	#[doc = ""]
	#[doc = " @param      dx  x coordinate delta"]
	#[doc = " @param      dy  y coordinate delta"]
	pub fn furi_hal_bt_hid_mouse_move(dx: i8, dy: i8) -> bool;
}
extern "C" {
	#[doc = " Set mouse button to pressed state and send HID report"]
	#[doc = ""]
	#[doc = " @param      button  key code"]
	pub fn furi_hal_bt_hid_mouse_press(button: u8) -> bool;
}
extern "C" {
	#[doc = " Set mouse button to released state and send HID report"]
	#[doc = ""]
	#[doc = " @param      button  key code"]
	pub fn furi_hal_bt_hid_mouse_release(button: u8) -> bool;
}
extern "C" {
	#[doc = " Set mouse button to released state and send HID report"]
	#[doc = ""]
	#[doc = " @param      button  key code"]
	pub fn furi_hal_bt_hid_mouse_release_all() -> bool;
}
extern "C" {
	#[doc = " Set mouse wheel position and send HID report"]
	#[doc = ""]
	#[doc = " @param      delta  number of scroll steps"]
	pub fn furi_hal_bt_hid_mouse_scroll(delta: i8) -> bool;
}
extern "C" {
	#[doc = " Set the following consumer key to pressed state and send HID report"]
	#[doc = ""]
	#[doc = " @param      button  key code"]
	pub fn furi_hal_bt_hid_consumer_key_press(button: u16) -> bool;
}
extern "C" {
	#[doc = " Set the following consumer key to released state and send HID report"]
	#[doc = ""]
	#[doc = " @param      button  key code"]
	pub fn furi_hal_bt_hid_consumer_key_release(button: u16) -> bool;
}
extern "C" {
	#[doc = " Set consumer key to released state and send HID report"]
	#[doc = ""]
	#[doc = " @param      button  key code"]
	pub fn furi_hal_bt_hid_consumer_key_release_all() -> bool;
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum FuriHalInfraredTxGetDataState {
	#[doc = "< New data obtained"]
	FuriHalInfraredTxGetDataStateOk = 0,
	#[doc = "< New data obtained, and this is end of package"]
	FuriHalInfraredTxGetDataStateDone = 1,
	#[doc = "< New data obtained, and this is end of package and no more data available"]
	FuriHalInfraredTxGetDataStateLastDone = 2,
}
#[doc = " Callback type for providing data to INFRARED DMA TX system. It is called every tim"]
pub type FuriHalInfraredTxGetDataISRCallback = ::core::option::Option<unsafe extern "C" fn(context: *mut core::ffi::c_void,
                                                                                           duration: *mut u32,
                                                                                           level: *mut bool)
                                                                                           -> FuriHalInfraredTxGetDataState>;
#[doc = " Callback type called every time signal is sent by DMA to Timer."]
#[doc = ""]
#[doc = " Actually, it means there are 2 timings left to send for this signal, which is"]
#[doc = " almost end. Don't use this callback to stop transmission, as far as there are"]
#[doc = " next signal is charged for transmission by DMA."]
pub type FuriHalInfraredTxSignalSentISRCallback = ::core::option::Option<unsafe extern "C" fn(context: *mut core::ffi::c_void)>;
#[doc = " Signature of callback function for receiving continuous INFRARED rx signal."]
#[doc = ""]
#[doc = " @param      ctx[in]       context to pass to callback"]
#[doc = " @param      level[in]     level of input INFRARED rx signal"]
#[doc = " @param      duration[in]  duration of continuous rx signal level in us"]
pub type FuriHalInfraredRxCaptureCallback =
	::core::option::Option<unsafe extern "C" fn(ctx: *mut core::ffi::c_void, level: bool, duration: u32)>;
#[doc = " Signature of callback function for reaching silence timeout on INFRARED port."]
#[doc = ""]
#[doc = " @param      ctx[in]  context to pass to callback"]
pub type FuriHalInfraredRxTimeoutCallback = ::core::option::Option<unsafe extern "C" fn(ctx: *mut core::ffi::c_void)>;
extern "C" {
	#[doc = " Initialize INFRARED RX timer to receive interrupts."]
	#[doc = ""]
	#[doc = " It provides interrupts for every RX-signal edge changing with its duration."]
	pub fn furi_hal_infrared_async_rx_start();
}
extern "C" {
	#[doc = " Deinitialize INFRARED RX interrupt."]
	pub fn furi_hal_infrared_async_rx_stop();
}
extern "C" {
	#[doc = " Setup hal for receiving silence timeout."]
	#[doc = ""]
	#[doc = " Should be used with 'furi_hal_infrared_timeout_irq_set_callback()'."]
	#[doc = ""]
	#[doc = " @param[in]  timeout_us  time to wait for silence on INFRARED port before"]
	#[doc = "                         generating IRQ."]
	pub fn furi_hal_infrared_async_rx_set_timeout(timeout_us: u32);
}
extern "C" {
	#[doc = " Setup callback for previously initialized INFRARED RX interrupt."]
	#[doc = ""]
	#[doc = " @param[in]  callback  callback to call when RX signal edge changing occurs"]
	#[doc = " @param[in]  ctx       context for callback"]
	pub fn furi_hal_infrared_async_rx_set_capture_isr_callback(callback: FuriHalInfraredRxCaptureCallback,
	                                                           ctx: *mut core::ffi::c_void);
}
extern "C" {
	#[doc = " Setup callback for reaching silence timeout on INFRARED port."]
	#[doc = ""]
	#[doc = " Should setup hal with 'furi_hal_infrared_setup_rx_timeout_irq()' first."]
	#[doc = ""]
	#[doc = " @param[in]  callback  callback for silence timeout"]
	#[doc = " @param[in]  ctx       context to pass to callback"]
	pub fn furi_hal_infrared_async_rx_set_timeout_isr_callback(callback: FuriHalInfraredRxTimeoutCallback,
	                                                           ctx: *mut core::ffi::c_void);
}
extern "C" {
	#[doc = " Check if INFRARED is in use now."]
	#[doc = ""]
	#[doc = " @return     true if INFRARED is busy, false otherwise."]
	pub fn furi_hal_infrared_is_busy() -> bool;
}
extern "C" {
	#[doc = " Set callback providing new data."]
	#[doc = ""]
	#[doc = " This function has to be called before furi_hal_infrared_async_tx_start()."]
	#[doc = ""]
	#[doc = " @param[in]  callback  function to provide new data"]
	#[doc = " @param[in]  context   context for callback"]
	pub fn furi_hal_infrared_async_tx_set_data_isr_callback(callback: FuriHalInfraredTxGetDataISRCallback,
	                                                        context: *mut core::ffi::c_void);
}
extern "C" {
	#[doc = " Start IR asynchronous transmission."]
	#[doc = ""]
	#[doc = " It can be stopped by 2 reasons:"]
	#[doc = " 1. implicit call for furi_hal_infrared_async_tx_stop()"]
	#[doc = " 2. callback can provide FuriHalInfraredTxGetDataStateLastDone response which"]
	#[doc = "    means no more data available for transmission."]
	#[doc = ""]
	#[doc = " Any func (furi_hal_infrared_async_tx_stop() or"]
	#[doc = " furi_hal_infrared_async_tx_wait_termination()) has to be called to wait end of"]
	#[doc = " transmission and free resources."]
	#[doc = ""]
	#[doc = " @param[in]  freq        frequency for PWM"]
	#[doc = " @param[in]  duty_cycle  duty cycle for PWM"]
	pub fn furi_hal_infrared_async_tx_start(freq: u32, duty_cycle: core::ffi::c_float);
}
extern "C" {
	#[doc = " Stop IR asynchronous transmission and free resources."]
	#[doc = ""]
	#[doc = " Transmission will stop as soon as transmission reaches end of package"]
	#[doc = " (FuriHalInfraredTxGetDataStateDone or FuriHalInfraredTxGetDataStateLastDone)."]
	pub fn furi_hal_infrared_async_tx_stop();
}
extern "C" {
	#[doc = " Wait for end of IR asynchronous transmission and free resources."]
	#[doc = ""]
	#[doc = " Transmission will stop as soon as transmission reaches end of transmission"]
	#[doc = " (FuriHalInfraredTxGetDataStateLastDone)."]
	pub fn furi_hal_infrared_async_tx_wait_termination();
}
extern "C" {
	#[doc = " Set callback for end of signal transmission"]
	#[doc = ""]
	#[doc = " @param[in]  callback  function to call when signal is sent"]
	#[doc = " @param[in]  context   context for callback"]
	pub fn furi_hal_infrared_async_tx_set_signal_sent_isr_callback(callback: FuriHalInfraredTxSignalSentISRCallback,
	                                                               context: *mut core::ffi::c_void);
}
extern "C" {
	#[doc = " @brief Init memory pool manager"]
	pub fn furi_hal_memory_init();
}
extern "C" {
	#[doc = " @brief Allocate memory from separate memory pool. That memory can't be freed."]
	#[doc = ""]
	#[doc = " @param size"]
	#[doc = " @return void*"]
	pub fn furi_hal_memory_alloc(size: usize) -> *mut core::ffi::c_void;
}
extern "C" {
	#[doc = " @brief Get free memory pool size"]
	#[doc = ""]
	#[doc = " @return size_t"]
	pub fn furi_hal_memory_get_free() -> usize;
}
extern "C" {
	#[doc = " @brief Get max free block size from memory pool"]
	#[doc = ""]
	#[doc = " @return size_t"]
	pub fn furi_hal_memory_max_pool_block() -> usize;
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum FuriHalMpuRegion {
	FuriHalMpuRegionNULL = 0,
	FuriHalMpuRegionStack = 1,
	FuriHalMpuRegion2 = 2,
	FuriHalMpuRegion3 = 3,
	FuriHalMpuRegion4 = 4,
	FuriHalMpuRegion5 = 5,
	FuriHalMpuRegion6 = 6,
	FuriHalMpuRegion7 = 7,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum FuriHalMPURegionSize {
	FuriHalMPURegionSize32B = 4,
	FuriHalMPURegionSize64B = 5,
	FuriHalMPURegionSize128B = 6,
	FuriHalMPURegionSize256B = 7,
	FuriHalMPURegionSize512B = 8,
	FuriHalMPURegionSize1KB = 9,
	FuriHalMPURegionSize2KB = 10,
	FuriHalMPURegionSize4KB = 11,
	FuriHalMPURegionSize8KB = 12,
	FuriHalMPURegionSize16KB = 13,
	FuriHalMPURegionSize32KB = 14,
	FuriHalMPURegionSize64KB = 15,
	FuriHalMPURegionSize128KB = 16,
	FuriHalMPURegionSize256KB = 17,
	FuriHalMPURegionSize512KB = 18,
	FuriHalMPURegionSize1MB = 19,
	FuriHalMPURegionSize2MB = 20,
	FuriHalMPURegionSize4MB = 21,
	FuriHalMPURegionSize8MB = 22,
	FuriHalMPURegionSize16MB = 23,
	FuriHalMPURegionSize32MB = 24,
	FuriHalMPURegionSize64MB = 25,
	FuriHalMPURegionSize128MB = 26,
	FuriHalMPURegionSize256MB = 27,
	FuriHalMPURegionSize512MB = 28,
	FuriHalMPURegionSize1GB = 29,
	FuriHalMPURegionSize2GB = 30,
	FuriHalMPURegionSize4GB = 31,
}
extern "C" {
	#[doc = " @brief Initialize memory protection unit"]
	pub fn furi_hal_mpu_init();
}
extern "C" {
	#[doc = " @brief Enable memory protection unit"]
	pub fn furi_hal_mpu_enable();
}
extern "C" {
	#[doc = " @brief Disable memory protection unit"]
	pub fn furi_hal_mpu_disable();
}
extern "C" {
	pub fn furi_hal_mpu_protect_no_access(region: FuriHalMpuRegion, address: u32, size: FuriHalMPURegionSize);
}
extern "C" {
	pub fn furi_hal_mpu_protect_read_only(region: FuriHalMpuRegion, address: u32, size: FuriHalMPURegionSize);
}
extern "C" {
	pub fn furi_hal_mpu_protect_disable(region: FuriHalMpuRegion);
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum HidU2fEvent {
	HidU2fDisconnected = 0,
	HidU2fConnected = 1,
	HidU2fRequest = 2,
}
pub type HidU2fCallback = ::core::option::Option<unsafe extern "C" fn(ev: HidU2fEvent, context: *mut core::ffi::c_void)>;
extern "C" {
	#[doc = " Get HID U2F connection state"]
	#[doc = ""]
	#[doc = " @return      true / false"]
	pub fn furi_hal_hid_u2f_is_connected() -> bool;
}
extern "C" {
	#[doc = " Set HID U2F event callback"]
	#[doc = ""]
	#[doc = " @param      cb  callback"]
	#[doc = " @param      ctx  callback context"]
	pub fn furi_hal_hid_u2f_set_callback(cb: HidU2fCallback, ctx: *mut core::ffi::c_void);
}
extern "C" {
	#[doc = " Get received U2F HID packet"]
	#[doc = ""]
	pub fn furi_hal_hid_u2f_get_request(data: *mut u8) -> u32;
}
extern "C" {
	#[doc = " Send U2F HID response packet"]
	#[doc = ""]
	#[doc = " @param      data  response data"]
	#[doc = " @param      len  packet length"]
	pub fn furi_hal_hid_u2f_send_response(data: *mut u8, len: u8);
}
#[doc = " @brief  Structure definition of some features of ADC common parameters"]
#[doc = "         and multimode"]
#[doc = "         (all ADC instances belonging to the same ADC common instance)."]
#[doc = " @note   The setting of these parameters by function @ref LL_ADC_CommonInit()"]
#[doc = "         is conditioned to ADC instances state (all ADC instances"]
#[doc = "         sharing the same ADC common instance):"]
#[doc = "         All ADC instances sharing the same ADC common instance must be"]
#[doc = "         disabled."]
#[repr(C)]
pub struct LL_ADC_CommonInitTypeDef {
	#[doc = "< Set parameter common to several ADC: Clock source and prescaler."]
	#[doc = "This parameter can be a value of @ref ADC_LL_EC_COMMON_CLOCK_SOURCE"]
	#[doc = "@note On this STM32 serie, if ADC group injected is used, some"]
	#[doc = "clock ratio constraints between ADC clock and AHB clock"]
	#[doc = "must be respected. Refer to reference manual."]
	#[doc = ""]
	#[doc = "This feature can be modified afterwards using unitary function @ref LL_ADC_SetCommonClock()."]
	pub CommonClock: u32,
}
#[test]
fn bindgen_test_layout_LL_ADC_CommonInitTypeDef() {
	assert_eq!(
	           ::core::mem::size_of::<LL_ADC_CommonInitTypeDef>(),
	           4usize,
	           concat!("Size of: ", stringify!(LL_ADC_CommonInitTypeDef))
	);
	assert_eq!(
	           ::core::mem::align_of::<LL_ADC_CommonInitTypeDef>(),
	           4usize,
	           concat!("Alignment of ", stringify!(LL_ADC_CommonInitTypeDef))
	);
	fn test_field_CommonClock() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_ADC_CommonInitTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).CommonClock) as usize - ptr as usize
		           },
		           0usize,
		           concat!(
			"Offset of field: ",
			stringify!(LL_ADC_CommonInitTypeDef),
			"::",
			stringify!(CommonClock)
		)
		);
	}
	test_field_CommonClock();
}
#[doc = " @brief  Structure definition of some features of ADC instance."]
#[doc = " @note   These parameters have an impact on ADC scope: ADC instance."]
#[doc = "         Affects both group regular and group injected (availability"]
#[doc = "         of ADC group injected depends on STM32 families)."]
#[doc = "         Refer to corresponding unitary functions into"]
#[doc = "         @ref ADC_LL_EF_Configuration_ADC_Instance ."]
#[doc = " @note   The setting of these parameters by function @ref LL_ADC_Init()"]
#[doc = "         is conditioned to ADC state:"]
#[doc = "         ADC instance must be disabled."]
#[doc = "         This condition is applied to all ADC features, for efficiency"]
#[doc = "         and compatibility over all STM32 families. However, the different"]
#[doc = "         features can be set under different ADC state conditions"]
#[doc = "         (setting possible with ADC enabled without conversion on going,"]
#[doc = "         ADC enabled with conversion on going, ...)"]
#[doc = "         Each feature can be updated afterwards with a unitary function"]
#[doc = "         and potentially with ADC in a different state than disabled,"]
#[doc = "         refer to description of each function for setting"]
#[doc = "         conditioned to ADC state."]
#[repr(C)]
pub struct LL_ADC_InitTypeDef {
	#[doc = "< Set ADC resolution."]
	#[doc = "This parameter can be a value of @ref ADC_LL_EC_RESOLUTION"]
	#[doc = ""]
	#[doc = "This feature can be modified afterwards using unitary function @ref LL_ADC_SetResolution()."]
	pub Resolution: u32,
	#[doc = "< Set ADC conversion data alignment."]
	#[doc = "This parameter can be a value of @ref ADC_LL_EC_DATA_ALIGN"]
	#[doc = ""]
	#[doc = "This feature can be modified afterwards using unitary function @ref LL_ADC_SetDataAlignment()."]
	pub DataAlignment: u32,
	#[doc = "< Set ADC low power mode."]
	#[doc = "This parameter can be a value of @ref ADC_LL_EC_LP_MODE"]
	#[doc = ""]
	#[doc = "This feature can be modified afterwards using unitary function @ref LL_ADC_SetLowPowerMode()."]
	pub LowPowerMode: u32,
}
#[test]
fn bindgen_test_layout_LL_ADC_InitTypeDef() {
	assert_eq!(
	           ::core::mem::size_of::<LL_ADC_InitTypeDef>(),
	           12usize,
	           concat!("Size of: ", stringify!(LL_ADC_InitTypeDef))
	);
	assert_eq!(
	           ::core::mem::align_of::<LL_ADC_InitTypeDef>(),
	           4usize,
	           concat!("Alignment of ", stringify!(LL_ADC_InitTypeDef))
	);
	fn test_field_Resolution() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_ADC_InitTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).Resolution) as usize - ptr as usize
		           },
		           0usize,
		           concat!(
			"Offset of field: ",
			stringify!(LL_ADC_InitTypeDef),
			"::",
			stringify!(Resolution)
		)
		);
	}
	test_field_Resolution();
	fn test_field_DataAlignment() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_ADC_InitTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).DataAlignment) as usize - ptr as usize
		           },
		           4usize,
		           concat!(
			"Offset of field: ",
			stringify!(LL_ADC_InitTypeDef),
			"::",
			stringify!(DataAlignment)
		)
		);
	}
	test_field_DataAlignment();
	fn test_field_LowPowerMode() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_ADC_InitTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).LowPowerMode) as usize - ptr as usize
		           },
		           8usize,
		           concat!(
			"Offset of field: ",
			stringify!(LL_ADC_InitTypeDef),
			"::",
			stringify!(LowPowerMode)
		)
		);
	}
	test_field_LowPowerMode();
}
#[doc = " @brief  Structure definition of some features of ADC group regular."]
#[doc = " @note   These parameters have an impact on ADC scope: ADC group regular."]
#[doc = "         Refer to corresponding unitary functions into"]
#[doc = "         @ref ADC_LL_EF_Configuration_ADC_Group_Regular"]
#[doc = "         (functions with prefix \"REG\")."]
#[doc = " @note   The setting of these parameters by function @ref LL_ADC_REG_Init()"]
#[doc = "         is conditioned to ADC state:"]
#[doc = "         ADC instance must be disabled."]
#[doc = "         This condition is applied to all ADC features, for efficiency"]
#[doc = "         and compatibility over all STM32 families. However, the different"]
#[doc = "         features can be set under different ADC state conditions"]
#[doc = "         (setting possible with ADC enabled without conversion on going,"]
#[doc = "         ADC enabled with conversion on going, ...)"]
#[doc = "         Each feature can be updated afterwards with a unitary function"]
#[doc = "         and potentially with ADC in a different state than disabled,"]
#[doc = "         refer to description of each function for setting"]
#[doc = "         conditioned to ADC state."]
#[repr(C)]
pub struct LL_ADC_REG_InitTypeDef {
	#[doc = "< Set ADC group regular conversion trigger source: internal (SW start) or from external peripheral (timer event, external interrupt line)."]
	#[doc = "This parameter can be a value of @ref ADC_LL_EC_REG_TRIGGER_SOURCE"]
	#[doc = "@note On this STM32 serie, setting trigger source to external trigger also set trigger polarity to rising edge"]
	#[doc = "(default setting for compatibility with some ADC on other STM32 families having this setting set by HW default value)."]
	#[doc = "In case of need to modify trigger edge, use function @ref LL_ADC_REG_SetTriggerEdge()."]
	#[doc = ""]
	#[doc = "This feature can be modified afterwards using unitary function @ref LL_ADC_REG_SetTriggerSource()."]
	pub TriggerSource: u32,
	#[doc = "< Set ADC group regular sequencer length."]
	#[doc = "This parameter can be a value of @ref ADC_LL_EC_REG_SEQ_SCAN_LENGTH"]
	#[doc = ""]
	#[doc = "This feature can be modified afterwards using unitary function @ref LL_ADC_REG_SetSequencerLength()."]
	pub SequencerLength: u32,
	#[doc = "< Set ADC group regular sequencer discontinuous mode: sequence subdivided and scan conversions interrupted every selected number of ranks."]
	#[doc = "This parameter can be a value of @ref ADC_LL_EC_REG_SEQ_DISCONT_MODE"]
	#[doc = "@note This parameter has an effect only if group regular sequencer is enabled"]
	#[doc = "(scan length of 2 ranks or more)."]
	#[doc = ""]
	#[doc = "This feature can be modified afterwards using unitary function @ref LL_ADC_REG_SetSequencerDiscont()."]
	pub SequencerDiscont: u32,
	#[doc = "< Set ADC continuous conversion mode on ADC group regular, whether ADC conversions are performed in single mode (one conversion per trigger) or in continuous mode (after the first trigger, following conversions launched successively automatically)."]
	#[doc = "This parameter can be a value of @ref ADC_LL_EC_REG_CONTINUOUS_MODE"]
	#[doc = "Note: It is not possible to enable both ADC group regular continuous mode and discontinuous mode."]
	#[doc = ""]
	#[doc = "This feature can be modified afterwards using unitary function @ref LL_ADC_REG_SetContinuousMode()."]
	pub ContinuousMode: u32,
	#[doc = "< Set ADC group regular conversion data transfer: no transfer or transfer by DMA, and DMA requests mode."]
	#[doc = "This parameter can be a value of @ref ADC_LL_EC_REG_DMA_TRANSFER"]
	#[doc = ""]
	#[doc = "This feature can be modified afterwards using unitary function @ref LL_ADC_REG_SetDMATransfer()."]
	pub DMATransfer: u32,
	#[doc = "< Set ADC group regular behavior in case of overrun:"]
	#[doc = "data preserved or overwritten."]
	#[doc = "This parameter can be a value of @ref ADC_LL_EC_REG_OVR_DATA_BEHAVIOR"]
	#[doc = ""]
	#[doc = "This feature can be modified afterwards using unitary function @ref LL_ADC_REG_SetOverrun()."]
	pub Overrun: u32,
}
#[test]
fn bindgen_test_layout_LL_ADC_REG_InitTypeDef() {
	assert_eq!(
	           ::core::mem::size_of::<LL_ADC_REG_InitTypeDef>(),
	           24usize,
	           concat!("Size of: ", stringify!(LL_ADC_REG_InitTypeDef))
	);
	assert_eq!(
	           ::core::mem::align_of::<LL_ADC_REG_InitTypeDef>(),
	           4usize,
	           concat!("Alignment of ", stringify!(LL_ADC_REG_InitTypeDef))
	);
	fn test_field_TriggerSource() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_ADC_REG_InitTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).TriggerSource) as usize - ptr as usize
		           },
		           0usize,
		           concat!(
			"Offset of field: ",
			stringify!(LL_ADC_REG_InitTypeDef),
			"::",
			stringify!(TriggerSource)
		)
		);
	}
	test_field_TriggerSource();
	fn test_field_SequencerLength() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_ADC_REG_InitTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).SequencerLength) as usize - ptr as usize
		           },
		           4usize,
		           concat!(
			"Offset of field: ",
			stringify!(LL_ADC_REG_InitTypeDef),
			"::",
			stringify!(SequencerLength)
		)
		);
	}
	test_field_SequencerLength();
	fn test_field_SequencerDiscont() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_ADC_REG_InitTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).SequencerDiscont) as usize - ptr as usize
		           },
		           8usize,
		           concat!(
			"Offset of field: ",
			stringify!(LL_ADC_REG_InitTypeDef),
			"::",
			stringify!(SequencerDiscont)
		)
		);
	}
	test_field_SequencerDiscont();
	fn test_field_ContinuousMode() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_ADC_REG_InitTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).ContinuousMode) as usize - ptr as usize
		           },
		           12usize,
		           concat!(
			"Offset of field: ",
			stringify!(LL_ADC_REG_InitTypeDef),
			"::",
			stringify!(ContinuousMode)
		)
		);
	}
	test_field_ContinuousMode();
	fn test_field_DMATransfer() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_ADC_REG_InitTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).DMATransfer) as usize - ptr as usize
		           },
		           16usize,
		           concat!(
			"Offset of field: ",
			stringify!(LL_ADC_REG_InitTypeDef),
			"::",
			stringify!(DMATransfer)
		)
		);
	}
	test_field_DMATransfer();
	fn test_field_Overrun() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_ADC_REG_InitTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).Overrun) as usize - ptr as usize
		           },
		           20usize,
		           concat!(
			"Offset of field: ",
			stringify!(LL_ADC_REG_InitTypeDef),
			"::",
			stringify!(Overrun)
		)
		);
	}
	test_field_Overrun();
}
#[doc = " @brief  Structure definition of some features of ADC group injected."]
#[doc = " @note   These parameters have an impact on ADC scope: ADC group injected."]
#[doc = "         Refer to corresponding unitary functions into"]
#[doc = "         @ref ADC_LL_EF_Configuration_ADC_Group_Regular"]
#[doc = "         (functions with prefix \"INJ\")."]
#[doc = " @note   The setting of these parameters by function @ref LL_ADC_INJ_Init()"]
#[doc = "         is conditioned to ADC state:"]
#[doc = "         ADC instance must be disabled."]
#[doc = "         This condition is applied to all ADC features, for efficiency"]
#[doc = "         and compatibility over all STM32 families. However, the different"]
#[doc = "         features can be set under different ADC state conditions"]
#[doc = "         (setting possible with ADC enabled without conversion on going,"]
#[doc = "         ADC enabled with conversion on going, ...)"]
#[doc = "         Each feature can be updated afterwards with a unitary function"]
#[doc = "         and potentially with ADC in a different state than disabled,"]
#[doc = "         refer to description of each function for setting"]
#[doc = "         conditioned to ADC state."]
#[repr(C)]
pub struct LL_ADC_INJ_InitTypeDef {
	#[doc = "< Set ADC group injected conversion trigger source: internal (SW start) or from external peripheral (timer event, external interrupt line)."]
	#[doc = "This parameter can be a value of @ref ADC_LL_EC_INJ_TRIGGER_SOURCE"]
	#[doc = "@note On this STM32 serie, setting trigger source to external trigger also set trigger polarity to rising edge"]
	#[doc = "(default setting for compatibility with some ADC on other STM32 families having this setting set by HW default value)."]
	#[doc = "In case of need to modify trigger edge, use function @ref LL_ADC_INJ_SetTriggerEdge()."]
	#[doc = ""]
	#[doc = "This feature can be modified afterwards using unitary function @ref LL_ADC_INJ_SetTriggerSource()."]
	pub TriggerSource: u32,
	#[doc = "< Set ADC group injected sequencer length."]
	#[doc = "This parameter can be a value of @ref ADC_LL_EC_INJ_SEQ_SCAN_LENGTH"]
	#[doc = ""]
	#[doc = "This feature can be modified afterwards using unitary function @ref LL_ADC_INJ_SetSequencerLength()."]
	pub SequencerLength: u32,
	#[doc = "< Set ADC group injected sequencer discontinuous mode: sequence subdivided and scan conversions interrupted every selected number of ranks."]
	#[doc = "This parameter can be a value of @ref ADC_LL_EC_INJ_SEQ_DISCONT_MODE"]
	#[doc = "@note This parameter has an effect only if group injected sequencer is enabled"]
	#[doc = "(scan length of 2 ranks or more)."]
	#[doc = ""]
	#[doc = "This feature can be modified afterwards using unitary function @ref LL_ADC_INJ_SetSequencerDiscont()."]
	pub SequencerDiscont: u32,
	#[doc = "< Set ADC group injected conversion trigger: independent or from ADC group regular."]
	#[doc = "This parameter can be a value of @ref ADC_LL_EC_INJ_TRIG_AUTO"]
	#[doc = "Note: This parameter must be set to set to independent trigger if injected trigger source is set to an external trigger."]
	#[doc = ""]
	#[doc = "This feature can be modified afterwards using unitary function @ref LL_ADC_INJ_SetTrigAuto()."]
	pub TrigAuto: u32,
}
#[test]
fn bindgen_test_layout_LL_ADC_INJ_InitTypeDef() {
	assert_eq!(
	           ::core::mem::size_of::<LL_ADC_INJ_InitTypeDef>(),
	           16usize,
	           concat!("Size of: ", stringify!(LL_ADC_INJ_InitTypeDef))
	);
	assert_eq!(
	           ::core::mem::align_of::<LL_ADC_INJ_InitTypeDef>(),
	           4usize,
	           concat!("Alignment of ", stringify!(LL_ADC_INJ_InitTypeDef))
	);
	fn test_field_TriggerSource() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_ADC_INJ_InitTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).TriggerSource) as usize - ptr as usize
		           },
		           0usize,
		           concat!(
			"Offset of field: ",
			stringify!(LL_ADC_INJ_InitTypeDef),
			"::",
			stringify!(TriggerSource)
		)
		);
	}
	test_field_TriggerSource();
	fn test_field_SequencerLength() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_ADC_INJ_InitTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).SequencerLength) as usize - ptr as usize
		           },
		           4usize,
		           concat!(
			"Offset of field: ",
			stringify!(LL_ADC_INJ_InitTypeDef),
			"::",
			stringify!(SequencerLength)
		)
		);
	}
	test_field_SequencerLength();
	fn test_field_SequencerDiscont() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_ADC_INJ_InitTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).SequencerDiscont) as usize - ptr as usize
		           },
		           8usize,
		           concat!(
			"Offset of field: ",
			stringify!(LL_ADC_INJ_InitTypeDef),
			"::",
			stringify!(SequencerDiscont)
		)
		);
	}
	test_field_SequencerDiscont();
	fn test_field_TrigAuto() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_ADC_INJ_InitTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).TrigAuto) as usize - ptr as usize
		           },
		           12usize,
		           concat!(
			"Offset of field: ",
			stringify!(LL_ADC_INJ_InitTypeDef),
			"::",
			stringify!(TrigAuto)
		)
		);
	}
	test_field_TrigAuto();
}
extern "C" {
	#[doc = " @defgroup ADC_LL_EF_Init Initialization and de-initialization functions"]
	#[doc = " @{"]
	pub fn LL_ADC_CommonDeInit(ADCxy_COMMON: *mut ADC_Common_TypeDef) -> ErrorStatus;
}
extern "C" {
	pub fn LL_ADC_CommonInit(ADCxy_COMMON: *mut ADC_Common_TypeDef,
	                         ADC_CommonInitStruct: *mut LL_ADC_CommonInitTypeDef)
	                         -> ErrorStatus;
}
extern "C" {
	pub fn LL_ADC_CommonStructInit(ADC_CommonInitStruct: *mut LL_ADC_CommonInitTypeDef);
}
extern "C" {
	pub fn LL_ADC_DeInit(ADCx: *mut ADC_TypeDef) -> ErrorStatus;
}
extern "C" {
	pub fn LL_ADC_Init(ADCx: *mut ADC_TypeDef, ADC_InitStruct: *mut LL_ADC_InitTypeDef) -> ErrorStatus;
}
extern "C" {
	pub fn LL_ADC_StructInit(ADC_InitStruct: *mut LL_ADC_InitTypeDef);
}
extern "C" {
	pub fn LL_ADC_REG_Init(ADCx: *mut ADC_TypeDef, ADC_REG_InitStruct: *mut LL_ADC_REG_InitTypeDef) -> ErrorStatus;
}
extern "C" {
	pub fn LL_ADC_REG_StructInit(ADC_REG_InitStruct: *mut LL_ADC_REG_InitTypeDef);
}
extern "C" {
	pub fn LL_ADC_INJ_Init(ADCx: *mut ADC_TypeDef, ADC_INJ_InitStruct: *mut LL_ADC_INJ_InitTypeDef) -> ErrorStatus;
}
extern "C" {
	pub fn LL_ADC_INJ_StructInit(ADC_INJ_InitStruct: *mut LL_ADC_INJ_InitTypeDef);
}
#[doc = " @brief  Structure definition of some features of COMP instance."]
#[repr(C)]
pub struct LL_COMP_InitTypeDef {
	#[doc = "< Set comparator operating mode to adjust power and speed."]
	#[doc = "This parameter can be a value of @ref COMP_LL_EC_POWERMODE"]
	#[doc = ""]
	#[doc = "This feature can be modified afterwards using unitary function @ref LL_COMP_SetPowerMode()."]
	pub PowerMode: u32,
	#[doc = "< Set comparator input plus (non-inverting input)."]
	#[doc = "This parameter can be a value of @ref COMP_LL_EC_INPUT_PLUS"]
	#[doc = ""]
	#[doc = "This feature can be modified afterwards using unitary function @ref LL_COMP_SetInputPlus()."]
	pub InputPlus: u32,
	#[doc = "< Set comparator input minus (inverting input)."]
	#[doc = "This parameter can be a value of @ref COMP_LL_EC_INPUT_MINUS"]
	#[doc = ""]
	#[doc = "This feature can be modified afterwards using unitary function @ref LL_COMP_SetInputMinus()."]
	pub InputMinus: u32,
	#[doc = "< Set comparator hysteresis mode of the input minus."]
	#[doc = "This parameter can be a value of @ref COMP_LL_EC_INPUT_HYSTERESIS"]
	#[doc = ""]
	#[doc = "This feature can be modified afterwards using unitary function @ref LL_COMP_SetInputHysteresis()."]
	pub InputHysteresis: u32,
	#[doc = "< Set comparator output polarity."]
	#[doc = "This parameter can be a value of @ref COMP_LL_EC_OUTPUT_POLARITY"]
	#[doc = ""]
	#[doc = "This feature can be modified afterwards using unitary function @ref LL_COMP_SetOutputPolarity()."]
	pub OutputPolarity: u32,
	#[doc = "< Set comparator blanking source."]
	#[doc = "This parameter can be a value of @ref COMP_LL_EC_OUTPUT_BLANKING_SOURCE"]
	#[doc = ""]
	#[doc = "This feature can be modified afterwards using unitary function @ref LL_COMP_SetOutputBlankingSource()."]
	pub OutputBlankingSource: u32,
}
#[test]
fn bindgen_test_layout_LL_COMP_InitTypeDef() {
	assert_eq!(
	           ::core::mem::size_of::<LL_COMP_InitTypeDef>(),
	           24usize,
	           concat!("Size of: ", stringify!(LL_COMP_InitTypeDef))
	);
	assert_eq!(
	           ::core::mem::align_of::<LL_COMP_InitTypeDef>(),
	           4usize,
	           concat!("Alignment of ", stringify!(LL_COMP_InitTypeDef))
	);
	fn test_field_PowerMode() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_COMP_InitTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).PowerMode) as usize - ptr as usize
		           },
		           0usize,
		           concat!(
			"Offset of field: ",
			stringify!(LL_COMP_InitTypeDef),
			"::",
			stringify!(PowerMode)
		)
		);
	}
	test_field_PowerMode();
	fn test_field_InputPlus() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_COMP_InitTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).InputPlus) as usize - ptr as usize
		           },
		           4usize,
		           concat!(
			"Offset of field: ",
			stringify!(LL_COMP_InitTypeDef),
			"::",
			stringify!(InputPlus)
		)
		);
	}
	test_field_InputPlus();
	fn test_field_InputMinus() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_COMP_InitTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).InputMinus) as usize - ptr as usize
		           },
		           8usize,
		           concat!(
			"Offset of field: ",
			stringify!(LL_COMP_InitTypeDef),
			"::",
			stringify!(InputMinus)
		)
		);
	}
	test_field_InputMinus();
	fn test_field_InputHysteresis() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_COMP_InitTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).InputHysteresis) as usize - ptr as usize
		           },
		           12usize,
		           concat!(
			"Offset of field: ",
			stringify!(LL_COMP_InitTypeDef),
			"::",
			stringify!(InputHysteresis)
		)
		);
	}
	test_field_InputHysteresis();
	fn test_field_OutputPolarity() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_COMP_InitTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).OutputPolarity) as usize - ptr as usize
		           },
		           16usize,
		           concat!(
			"Offset of field: ",
			stringify!(LL_COMP_InitTypeDef),
			"::",
			stringify!(OutputPolarity)
		)
		);
	}
	test_field_OutputPolarity();
	fn test_field_OutputBlankingSource() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_COMP_InitTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).OutputBlankingSource) as usize - ptr as usize
		           },
		           20usize,
		           concat!(
			"Offset of field: ",
			stringify!(LL_COMP_InitTypeDef),
			"::",
			stringify!(OutputBlankingSource)
		)
		);
	}
	test_field_OutputBlankingSource();
}
extern "C" {
	#[doc = " @defgroup COMP_LL_EF_Init Initialization and de-initialization functions"]
	#[doc = " @{"]
	pub fn LL_COMP_DeInit(COMPx: *mut COMP_TypeDef) -> ErrorStatus;
}
extern "C" {
	pub fn LL_COMP_Init(COMPx: *mut COMP_TypeDef, COMP_InitStruct: *mut LL_COMP_InitTypeDef) -> ErrorStatus;
}
extern "C" {
	pub fn LL_COMP_StructInit(COMP_InitStruct: *mut LL_COMP_InitTypeDef);
}
extern "C" {
	#[doc = " @defgroup CRC_LL_EF_Init Initialization and de-initialization functions"]
	#[doc = " @{"]
	pub fn LL_CRC_DeInit(CRCx: *mut CRC_TypeDef) -> ErrorStatus;
}
extern "C" {
	#[doc = " @defgroup CRS_LL_EF_Init Initialization and de-initialization functions"]
	#[doc = " @{"]
	pub fn LL_CRS_DeInit() -> ErrorStatus;
}
#[doc = " @defgroup DMA_LL_ES_INIT DMA Exported Init structure"]
#[doc = " @{"]
#[repr(C)]
pub struct LL_DMA_InitTypeDef {
	#[doc = "< Specifies the peripheral base address for DMA transfer"]
	#[doc = "or as Source base address in case of memory to memory transfer direction."]
	#[doc = ""]
	#[doc = "This parameter must be a value between Min_Data = 0 and Max_Data = 0xFFFFFFFF."]
	pub PeriphOrM2MSrcAddress: u32,
	#[doc = "< Specifies the memory base address for DMA transfer"]
	#[doc = "or as Destination base address in case of memory to memory transfer direction."]
	#[doc = ""]
	#[doc = "This parameter must be a value between Min_Data = 0 and Max_Data = 0xFFFFFFFF."]
	pub MemoryOrM2MDstAddress: u32,
	#[doc = "< Specifies if the data will be transferred from memory to peripheral,"]
	#[doc = "from memory to memory or from peripheral to memory."]
	#[doc = "This parameter can be a value of @ref DMA_LL_EC_DIRECTION"]
	#[doc = ""]
	#[doc = "This feature can be modified afterwards using unitary function @ref LL_DMA_SetDataTransferDirection()."]
	pub Direction: u32,
	#[doc = "< Specifies the normal or circular operation mode."]
	#[doc = "This parameter can be a value of @ref DMA_LL_EC_MODE"]
	#[doc = "@note: The circular buffer mode cannot be used if the memory to memory"]
	#[doc = "data transfer direction is configured on the selected Channel"]
	#[doc = ""]
	#[doc = "This feature can be modified afterwards using unitary function @ref LL_DMA_SetMode()."]
	pub Mode: u32,
	#[doc = "< Specifies whether the Peripheral address or Source address in case of memory to memory transfer direction"]
	#[doc = "is incremented or not."]
	#[doc = "This parameter can be a value of @ref DMA_LL_EC_PERIPH"]
	#[doc = ""]
	#[doc = "This feature can be modified afterwards using unitary function @ref LL_DMA_SetPeriphIncMode()."]
	pub PeriphOrM2MSrcIncMode: u32,
	#[doc = "< Specifies whether the Memory address or Destination address in case of memory to memory transfer direction"]
	#[doc = "is incremented or not."]
	#[doc = "This parameter can be a value of @ref DMA_LL_EC_MEMORY"]
	#[doc = ""]
	#[doc = "This feature can be modified afterwards using unitary function @ref LL_DMA_SetMemoryIncMode()."]
	pub MemoryOrM2MDstIncMode: u32,
	#[doc = "< Specifies the Peripheral data size alignment or Source data size alignment (byte, half word, word)"]
	#[doc = "in case of memory to memory transfer direction."]
	#[doc = "This parameter can be a value of @ref DMA_LL_EC_PDATAALIGN"]
	#[doc = ""]
	#[doc = "This feature can be modified afterwards using unitary function @ref LL_DMA_SetPeriphSize()."]
	pub PeriphOrM2MSrcDataSize: u32,
	#[doc = "< Specifies the Memory data size alignment or Destination data size alignment (byte, half word, word)"]
	#[doc = "in case of memory to memory transfer direction."]
	#[doc = "This parameter can be a value of @ref DMA_LL_EC_MDATAALIGN"]
	#[doc = ""]
	#[doc = "This feature can be modified afterwards using unitary function @ref LL_DMA_SetMemorySize()."]
	pub MemoryOrM2MDstDataSize: u32,
	#[doc = "< Specifies the number of data to transfer, in data unit."]
	#[doc = "The data unit is equal to the source buffer configuration set in PeripheralSize"]
	#[doc = "or MemorySize parameters depending in the transfer direction."]
	#[doc = "This parameter must be a value between Min_Data = 0 and Max_Data = 0x0000FFFF"]
	#[doc = ""]
	#[doc = "This feature can be modified afterwards using unitary function @ref LL_DMA_SetDataLength()."]
	pub NbData: u32,
	#[doc = "< Specifies the peripheral request."]
	#[doc = "This parameter can be a value of @ref DMAMUX_LL_EC_REQUEST"]
	#[doc = ""]
	#[doc = "This feature can be modified afterwards using unitary function @ref LL_DMA_SetPeriphRequest()."]
	pub PeriphRequest: u32,
	#[doc = "< Specifies the channel priority level."]
	#[doc = "This parameter can be a value of @ref DMA_LL_EC_PRIORITY"]
	#[doc = ""]
	#[doc = "This feature can be modified afterwards using unitary function @ref LL_DMA_SetChannelPriorityLevel()."]
	pub Priority: u32,
}
#[test]
fn bindgen_test_layout_LL_DMA_InitTypeDef() {
	assert_eq!(
	           ::core::mem::size_of::<LL_DMA_InitTypeDef>(),
	           44usize,
	           concat!("Size of: ", stringify!(LL_DMA_InitTypeDef))
	);
	assert_eq!(
	           ::core::mem::align_of::<LL_DMA_InitTypeDef>(),
	           4usize,
	           concat!("Alignment of ", stringify!(LL_DMA_InitTypeDef))
	);
	fn test_field_PeriphOrM2MSrcAddress() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_DMA_InitTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).PeriphOrM2MSrcAddress) as usize - ptr as usize
		           },
		           0usize,
		           concat!(
			"Offset of field: ",
			stringify!(LL_DMA_InitTypeDef),
			"::",
			stringify!(PeriphOrM2MSrcAddress)
		)
		);
	}
	test_field_PeriphOrM2MSrcAddress();
	fn test_field_MemoryOrM2MDstAddress() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_DMA_InitTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).MemoryOrM2MDstAddress) as usize - ptr as usize
		           },
		           4usize,
		           concat!(
			"Offset of field: ",
			stringify!(LL_DMA_InitTypeDef),
			"::",
			stringify!(MemoryOrM2MDstAddress)
		)
		);
	}
	test_field_MemoryOrM2MDstAddress();
	fn test_field_Direction() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_DMA_InitTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).Direction) as usize - ptr as usize
		           },
		           8usize,
		           concat!(
			"Offset of field: ",
			stringify!(LL_DMA_InitTypeDef),
			"::",
			stringify!(Direction)
		)
		);
	}
	test_field_Direction();
	fn test_field_Mode() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_DMA_InitTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).Mode) as usize - ptr as usize
		           },
		           12usize,
		           concat!("Offset of field: ", stringify!(LL_DMA_InitTypeDef), "::", stringify!(Mode))
		);
	}
	test_field_Mode();
	fn test_field_PeriphOrM2MSrcIncMode() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_DMA_InitTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).PeriphOrM2MSrcIncMode) as usize - ptr as usize
		           },
		           16usize,
		           concat!(
			"Offset of field: ",
			stringify!(LL_DMA_InitTypeDef),
			"::",
			stringify!(PeriphOrM2MSrcIncMode)
		)
		);
	}
	test_field_PeriphOrM2MSrcIncMode();
	fn test_field_MemoryOrM2MDstIncMode() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_DMA_InitTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).MemoryOrM2MDstIncMode) as usize - ptr as usize
		           },
		           20usize,
		           concat!(
			"Offset of field: ",
			stringify!(LL_DMA_InitTypeDef),
			"::",
			stringify!(MemoryOrM2MDstIncMode)
		)
		);
	}
	test_field_MemoryOrM2MDstIncMode();
	fn test_field_PeriphOrM2MSrcDataSize() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_DMA_InitTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).PeriphOrM2MSrcDataSize) as usize - ptr as usize
		           },
		           24usize,
		           concat!(
			"Offset of field: ",
			stringify!(LL_DMA_InitTypeDef),
			"::",
			stringify!(PeriphOrM2MSrcDataSize)
		)
		);
	}
	test_field_PeriphOrM2MSrcDataSize();
	fn test_field_MemoryOrM2MDstDataSize() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_DMA_InitTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).MemoryOrM2MDstDataSize) as usize - ptr as usize
		           },
		           28usize,
		           concat!(
			"Offset of field: ",
			stringify!(LL_DMA_InitTypeDef),
			"::",
			stringify!(MemoryOrM2MDstDataSize)
		)
		);
	}
	test_field_MemoryOrM2MDstDataSize();
	fn test_field_NbData() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_DMA_InitTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).NbData) as usize - ptr as usize
		           },
		           32usize,
		           concat!("Offset of field: ", stringify!(LL_DMA_InitTypeDef), "::", stringify!(NbData))
		);
	}
	test_field_NbData();
	fn test_field_PeriphRequest() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_DMA_InitTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).PeriphRequest) as usize - ptr as usize
		           },
		           36usize,
		           concat!(
			"Offset of field: ",
			stringify!(LL_DMA_InitTypeDef),
			"::",
			stringify!(PeriphRequest)
		)
		);
	}
	test_field_PeriphRequest();
	fn test_field_Priority() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_DMA_InitTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).Priority) as usize - ptr as usize
		           },
		           40usize,
		           concat!(
			"Offset of field: ",
			stringify!(LL_DMA_InitTypeDef),
			"::",
			stringify!(Priority)
		)
		);
	}
	test_field_Priority();
}
extern "C" {
	#[doc = " @defgroup DMA_LL_EF_Init Initialization and de-initialization functions"]
	#[doc = " @{"]
	pub fn LL_DMA_Init(DMAx: *mut DMA_TypeDef, Channel: u32, DMA_InitStruct: *mut LL_DMA_InitTypeDef) -> ErrorStatus;
}
extern "C" {
	pub fn LL_DMA_DeInit(DMAx: *mut DMA_TypeDef, Channel: u32) -> ErrorStatus;
}
extern "C" {
	pub fn LL_DMA_StructInit(DMA_InitStruct: *mut LL_DMA_InitTypeDef);
}
#[doc = " @brief LL LPUART Init Structure definition"]
#[repr(C)]
pub struct LL_LPUART_InitTypeDef {
	#[doc = "< Specifies the Prescaler to compute the communication baud rate."]
	#[doc = "This parameter can be a value of @ref LPUART_LL_EC_PRESCALER."]
	#[doc = ""]
	#[doc = "This feature can be modified afterwards using unitary"]
	#[doc = "function @ref LL_LPUART_SetPrescaler()."]
	pub PrescalerValue: u32,
	#[doc = "< This field defines expected LPUART communication baud rate."]
	#[doc = ""]
	#[doc = "This feature can be modified afterwards using unitary"]
	#[doc = "function @ref LL_LPUART_SetBaudRate()."]
	pub BaudRate: u32,
	#[doc = "< Specifies the number of data bits transmitted or received in a frame."]
	#[doc = "This parameter can be a value of @ref LPUART_LL_EC_DATAWIDTH."]
	#[doc = ""]
	#[doc = "This feature can be modified afterwards using unitary"]
	#[doc = "function @ref LL_LPUART_SetDataWidth()."]
	pub DataWidth: u32,
	#[doc = "< Specifies the number of stop bits transmitted."]
	#[doc = "This parameter can be a value of @ref LPUART_LL_EC_STOPBITS."]
	#[doc = ""]
	#[doc = "This feature can be modified afterwards using unitary"]
	#[doc = "function @ref LL_LPUART_SetStopBitsLength()."]
	pub StopBits: u32,
	#[doc = "< Specifies the parity mode."]
	#[doc = "This parameter can be a value of @ref LPUART_LL_EC_PARITY."]
	#[doc = ""]
	#[doc = "This feature can be modified afterwards using unitary"]
	#[doc = "function @ref LL_LPUART_SetParity()."]
	pub Parity: u32,
	#[doc = "< Specifies whether the Receive and/or Transmit mode is enabled or disabled."]
	#[doc = "This parameter can be a value of @ref LPUART_LL_EC_DIRECTION."]
	#[doc = ""]
	#[doc = "This feature can be modified afterwards using unitary"]
	#[doc = "function @ref LL_LPUART_SetTransferDirection()."]
	pub TransferDirection: u32,
	#[doc = "< Specifies whether the hardware flow control mode is enabled or disabled."]
	#[doc = "This parameter can be a value of @ref LPUART_LL_EC_HWCONTROL."]
	#[doc = ""]
	#[doc = "This feature can be modified afterwards using unitary"]
	#[doc = "function @ref LL_LPUART_SetHWFlowCtrl()."]
	pub HardwareFlowControl: u32,
}
#[test]
fn bindgen_test_layout_LL_LPUART_InitTypeDef() {
	assert_eq!(
	           ::core::mem::size_of::<LL_LPUART_InitTypeDef>(),
	           28usize,
	           concat!("Size of: ", stringify!(LL_LPUART_InitTypeDef))
	);
	assert_eq!(
	           ::core::mem::align_of::<LL_LPUART_InitTypeDef>(),
	           4usize,
	           concat!("Alignment of ", stringify!(LL_LPUART_InitTypeDef))
	);
	fn test_field_PrescalerValue() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_LPUART_InitTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).PrescalerValue) as usize - ptr as usize
		           },
		           0usize,
		           concat!(
			"Offset of field: ",
			stringify!(LL_LPUART_InitTypeDef),
			"::",
			stringify!(PrescalerValue)
		)
		);
	}
	test_field_PrescalerValue();
	fn test_field_BaudRate() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_LPUART_InitTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).BaudRate) as usize - ptr as usize
		           },
		           4usize,
		           concat!(
			"Offset of field: ",
			stringify!(LL_LPUART_InitTypeDef),
			"::",
			stringify!(BaudRate)
		)
		);
	}
	test_field_BaudRate();
	fn test_field_DataWidth() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_LPUART_InitTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).DataWidth) as usize - ptr as usize
		           },
		           8usize,
		           concat!(
			"Offset of field: ",
			stringify!(LL_LPUART_InitTypeDef),
			"::",
			stringify!(DataWidth)
		)
		);
	}
	test_field_DataWidth();
	fn test_field_StopBits() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_LPUART_InitTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).StopBits) as usize - ptr as usize
		           },
		           12usize,
		           concat!(
			"Offset of field: ",
			stringify!(LL_LPUART_InitTypeDef),
			"::",
			stringify!(StopBits)
		)
		);
	}
	test_field_StopBits();
	fn test_field_Parity() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_LPUART_InitTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).Parity) as usize - ptr as usize
		           },
		           16usize,
		           concat!(
			"Offset of field: ",
			stringify!(LL_LPUART_InitTypeDef),
			"::",
			stringify!(Parity)
		)
		);
	}
	test_field_Parity();
	fn test_field_TransferDirection() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_LPUART_InitTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).TransferDirection) as usize - ptr as usize
		           },
		           20usize,
		           concat!(
			"Offset of field: ",
			stringify!(LL_LPUART_InitTypeDef),
			"::",
			stringify!(TransferDirection)
		)
		);
	}
	test_field_TransferDirection();
	fn test_field_HardwareFlowControl() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_LPUART_InitTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).HardwareFlowControl) as usize - ptr as usize
		           },
		           24usize,
		           concat!(
			"Offset of field: ",
			stringify!(LL_LPUART_InitTypeDef),
			"::",
			stringify!(HardwareFlowControl)
		)
		);
	}
	test_field_HardwareFlowControl();
}
extern "C" {
	#[doc = " @defgroup LPUART_LL_EF_Init Initialization and de-initialization functions"]
	#[doc = " @{"]
	pub fn LL_LPUART_DeInit(LPUARTx: *mut USART_TypeDef) -> ErrorStatus;
}
extern "C" {
	pub fn LL_LPUART_Init(LPUARTx: *mut USART_TypeDef, LPUART_InitStruct: *mut LL_LPUART_InitTypeDef) -> ErrorStatus;
}
extern "C" {
	pub fn LL_LPUART_StructInit(LPUART_InitStruct: *mut LL_LPUART_InitTypeDef);
}
#[doc = " @brief  PKA Init structures definition"]
#[repr(C)]
pub struct LL_PKA_InitTypeDef {
	#[doc = "< Specifies the PKA operation mode."]
	#[doc = "This parameter can be a value of @ref PKA_LL_EC_MODE."]
	#[doc = ""]
	#[doc = "This feature can be modified afterwards using unitary function @ref LL_PKA_SetMode()."]
	pub Mode: u32,
}
#[test]
fn bindgen_test_layout_LL_PKA_InitTypeDef() {
	assert_eq!(
	           ::core::mem::size_of::<LL_PKA_InitTypeDef>(),
	           4usize,
	           concat!("Size of: ", stringify!(LL_PKA_InitTypeDef))
	);
	assert_eq!(
	           ::core::mem::align_of::<LL_PKA_InitTypeDef>(),
	           4usize,
	           concat!("Alignment of ", stringify!(LL_PKA_InitTypeDef))
	);
	fn test_field_Mode() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_PKA_InitTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).Mode) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(LL_PKA_InitTypeDef), "::", stringify!(Mode))
		);
	}
	test_field_Mode();
}
extern "C" {
	#[doc = " @defgroup PKA_LL_EF_Init Initialization and de-initialization functions"]
	#[doc = " @{"]
	pub fn LL_PKA_DeInit(PKAx: *mut PKA_TypeDef) -> ErrorStatus;
}
extern "C" {
	pub fn LL_PKA_Init(PKAx: *mut PKA_TypeDef, PKA_InitStruct: *mut LL_PKA_InitTypeDef) -> ErrorStatus;
}
extern "C" {
	pub fn LL_PKA_StructInit(PKA_InitStruct: *mut LL_PKA_InitTypeDef);
}
extern "C" {
	#[doc = " @defgroup PWR_LL_EF_Init De-initialization function"]
	#[doc = " @{"]
	pub fn LL_PWR_DeInit() -> ErrorStatus;
}
#[doc = " @brief LL RNG Init Structure Definition"]
#[repr(C)]
pub struct LL_RNG_InitTypeDef {
	#[doc = "< Clock error detection."]
	#[doc = "This parameter can be one value of @ref RNG_LL_CED."]
	#[doc = ""]
	#[doc = "This parameter can be modified using unitary functions @ref LL_RNG_EnableClkErrorDetect()."]
	pub ClockErrorDetection: u32,
}
#[test]
fn bindgen_test_layout_LL_RNG_InitTypeDef() {
	assert_eq!(
	           ::core::mem::size_of::<LL_RNG_InitTypeDef>(),
	           4usize,
	           concat!("Size of: ", stringify!(LL_RNG_InitTypeDef))
	);
	assert_eq!(
	           ::core::mem::align_of::<LL_RNG_InitTypeDef>(),
	           4usize,
	           concat!("Alignment of ", stringify!(LL_RNG_InitTypeDef))
	);
	fn test_field_ClockErrorDetection() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_RNG_InitTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).ClockErrorDetection) as usize - ptr as usize
		           },
		           0usize,
		           concat!(
			"Offset of field: ",
			stringify!(LL_RNG_InitTypeDef),
			"::",
			stringify!(ClockErrorDetection)
		)
		);
	}
	test_field_ClockErrorDetection();
}
extern "C" {
	#[doc = " @defgroup RNG_LL_EF_Init Initialization and de-initialization functions"]
	#[doc = " @{"]
	pub fn LL_RNG_Init(RNGx: *mut RNG_TypeDef, RNG_InitStruct: *mut LL_RNG_InitTypeDef) -> ErrorStatus;
}
extern "C" {
	pub fn LL_RNG_StructInit(RNG_InitStruct: *mut LL_RNG_InitTypeDef);
}
extern "C" {
	pub fn LL_RNG_DeInit(RNGx: *mut RNG_TypeDef) -> ErrorStatus;
}
#[doc = " @brief  RTC Init structures definition"]
#[repr(C)]
pub struct LL_RTC_InitTypeDef {
	#[doc = "< Specifies the RTC Hours Format."]
	#[doc = "This parameter can be a value of @ref RTC_LL_EC_HOURFORMAT"]
	#[doc = ""]
	#[doc = "This feature can be modified afterwards using unitary function"]
	#[doc = "@ref LL_RTC_SetHourFormat()."]
	pub HourFormat: u32,
	#[doc = "< Specifies the RTC Asynchronous Predivider value."]
	#[doc = "This parameter must be a number between Min_Data = 0x00 and Max_Data = 0x7F"]
	#[doc = ""]
	#[doc = "This feature can be modified afterwards using unitary function"]
	#[doc = "@ref LL_RTC_SetAsynchPrescaler()."]
	pub AsynchPrescaler: u32,
	#[doc = "< Specifies the RTC Synchronous Predivider value."]
	#[doc = "This parameter must be a number between Min_Data = 0x00 and Max_Data = 0x7FFF"]
	#[doc = ""]
	#[doc = "This feature can be modified afterwards using unitary function"]
	#[doc = "@ref LL_RTC_SetSynchPrescaler()."]
	pub SynchPrescaler: u32,
}
#[test]
fn bindgen_test_layout_LL_RTC_InitTypeDef() {
	assert_eq!(
	           ::core::mem::size_of::<LL_RTC_InitTypeDef>(),
	           12usize,
	           concat!("Size of: ", stringify!(LL_RTC_InitTypeDef))
	);
	assert_eq!(
	           ::core::mem::align_of::<LL_RTC_InitTypeDef>(),
	           4usize,
	           concat!("Alignment of ", stringify!(LL_RTC_InitTypeDef))
	);
	fn test_field_HourFormat() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_RTC_InitTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).HourFormat) as usize - ptr as usize
		           },
		           0usize,
		           concat!(
			"Offset of field: ",
			stringify!(LL_RTC_InitTypeDef),
			"::",
			stringify!(HourFormat)
		)
		);
	}
	test_field_HourFormat();
	fn test_field_AsynchPrescaler() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_RTC_InitTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).AsynchPrescaler) as usize - ptr as usize
		           },
		           4usize,
		           concat!(
			"Offset of field: ",
			stringify!(LL_RTC_InitTypeDef),
			"::",
			stringify!(AsynchPrescaler)
		)
		);
	}
	test_field_AsynchPrescaler();
	fn test_field_SynchPrescaler() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_RTC_InitTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).SynchPrescaler) as usize - ptr as usize
		           },
		           8usize,
		           concat!(
			"Offset of field: ",
			stringify!(LL_RTC_InitTypeDef),
			"::",
			stringify!(SynchPrescaler)
		)
		);
	}
	test_field_SynchPrescaler();
}
#[doc = " @brief  RTC Time structure definition"]
#[repr(C)]
pub struct LL_RTC_TimeTypeDef {
	#[doc = "< Specifies the RTC AM/PM Time."]
	#[doc = "This parameter can be a value of @ref RTC_LL_EC_TIME_FORMAT"]
	#[doc = ""]
	#[doc = "This feature can be modified afterwards using unitary function @ref LL_RTC_TIME_SetFormat()."]
	pub TimeFormat: u32,
	#[doc = "< Specifies the RTC Time Hours."]
	#[doc = "This parameter must be a number between Min_Data = 0 and Max_Data = 12 if the @ref LL_RTC_TIME_FORMAT_PM is selected."]
	#[doc = "This parameter must be a number between Min_Data = 0 and Max_Data = 23 if the @ref LL_RTC_TIME_FORMAT_AM_OR_24 is selected."]
	#[doc = ""]
	#[doc = "This feature can be modified afterwards using unitary function @ref LL_RTC_TIME_SetHour()."]
	pub Hours: u8,
	#[doc = "< Specifies the RTC Time Minutes."]
	#[doc = "This parameter must be a number between Min_Data = 0 and Max_Data = 59"]
	#[doc = ""]
	#[doc = "This feature can be modified afterwards using unitary function @ref LL_RTC_TIME_SetMinute()."]
	pub Minutes: u8,
	#[doc = "< Specifies the RTC Time Seconds."]
	#[doc = "This parameter must be a number between Min_Data = 0 and Max_Data = 59"]
	#[doc = ""]
	#[doc = "This feature can be modified afterwards using unitary function @ref LL_RTC_TIME_SetSecond()."]
	pub Seconds: u8,
}
#[test]
fn bindgen_test_layout_LL_RTC_TimeTypeDef() {
	assert_eq!(
	           ::core::mem::size_of::<LL_RTC_TimeTypeDef>(),
	           8usize,
	           concat!("Size of: ", stringify!(LL_RTC_TimeTypeDef))
	);
	assert_eq!(
	           ::core::mem::align_of::<LL_RTC_TimeTypeDef>(),
	           4usize,
	           concat!("Alignment of ", stringify!(LL_RTC_TimeTypeDef))
	);
	fn test_field_TimeFormat() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_RTC_TimeTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).TimeFormat) as usize - ptr as usize
		           },
		           0usize,
		           concat!(
			"Offset of field: ",
			stringify!(LL_RTC_TimeTypeDef),
			"::",
			stringify!(TimeFormat)
		)
		);
	}
	test_field_TimeFormat();
	fn test_field_Hours() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_RTC_TimeTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).Hours) as usize - ptr as usize
		           },
		           4usize,
		           concat!("Offset of field: ", stringify!(LL_RTC_TimeTypeDef), "::", stringify!(Hours))
		);
	}
	test_field_Hours();
	fn test_field_Minutes() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_RTC_TimeTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).Minutes) as usize - ptr as usize
		           },
		           5usize,
		           concat!("Offset of field: ", stringify!(LL_RTC_TimeTypeDef), "::", stringify!(Minutes))
		);
	}
	test_field_Minutes();
	fn test_field_Seconds() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_RTC_TimeTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).Seconds) as usize - ptr as usize
		           },
		           6usize,
		           concat!("Offset of field: ", stringify!(LL_RTC_TimeTypeDef), "::", stringify!(Seconds))
		);
	}
	test_field_Seconds();
}
#[doc = " @brief  RTC Date structure definition"]
#[repr(C)]
pub struct LL_RTC_DateTypeDef {
	#[doc = "< Specifies the RTC Date WeekDay."]
	#[doc = "This parameter can be a value of @ref RTC_LL_EC_WEEKDAY"]
	#[doc = ""]
	#[doc = "This feature can be modified afterwards using unitary function @ref LL_RTC_DATE_SetWeekDay()."]
	pub WeekDay: u8,
	#[doc = "< Specifies the RTC Date Month."]
	#[doc = "This parameter can be a value of @ref RTC_LL_EC_MONTH"]
	#[doc = ""]
	#[doc = "This feature can be modified afterwards using unitary function @ref LL_RTC_DATE_SetMonth()."]
	pub Month: u8,
	#[doc = "< Specifies the RTC Date Day."]
	#[doc = "This parameter must be a number between Min_Data = 1 and Max_Data = 31"]
	#[doc = ""]
	#[doc = "This feature can be modified afterwards using unitary function @ref LL_RTC_DATE_SetDay()."]
	pub Day: u8,
	#[doc = "< Specifies the RTC Date Year."]
	#[doc = "This parameter must be a number between Min_Data = 0 and Max_Data = 99"]
	#[doc = ""]
	#[doc = "This feature can be modified afterwards using unitary function @ref LL_RTC_DATE_SetYear()."]
	pub Year: u8,
}
#[test]
fn bindgen_test_layout_LL_RTC_DateTypeDef() {
	assert_eq!(
	           ::core::mem::size_of::<LL_RTC_DateTypeDef>(),
	           4usize,
	           concat!("Size of: ", stringify!(LL_RTC_DateTypeDef))
	);
	assert_eq!(
	           ::core::mem::align_of::<LL_RTC_DateTypeDef>(),
	           1usize,
	           concat!("Alignment of ", stringify!(LL_RTC_DateTypeDef))
	);
	fn test_field_WeekDay() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_RTC_DateTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).WeekDay) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(LL_RTC_DateTypeDef), "::", stringify!(WeekDay))
		);
	}
	test_field_WeekDay();
	fn test_field_Month() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_RTC_DateTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).Month) as usize - ptr as usize
		           },
		           1usize,
		           concat!("Offset of field: ", stringify!(LL_RTC_DateTypeDef), "::", stringify!(Month))
		);
	}
	test_field_Month();
	fn test_field_Day() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_RTC_DateTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).Day) as usize - ptr as usize
		           },
		           2usize,
		           concat!("Offset of field: ", stringify!(LL_RTC_DateTypeDef), "::", stringify!(Day))
		);
	}
	test_field_Day();
	fn test_field_Year() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_RTC_DateTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).Year) as usize - ptr as usize
		           },
		           3usize,
		           concat!("Offset of field: ", stringify!(LL_RTC_DateTypeDef), "::", stringify!(Year))
		);
	}
	test_field_Year();
}
#[doc = " @brief  RTC Alarm structure definition"]
#[repr(C)]
pub struct LL_RTC_AlarmTypeDef {
	#[doc = "< Specifies the RTC Alarm Time members."]
	pub AlarmTime: LL_RTC_TimeTypeDef,
	#[doc = "< Specifies the RTC Alarm Masks."]
	#[doc = "This parameter can be a value of @ref RTC_LL_EC_ALMA_MASK for ALARM A or @ref RTC_LL_EC_ALMB_MASK for ALARM B."]
	#[doc = ""]
	#[doc = "This feature can be modified afterwards using unitary function @ref LL_RTC_ALMA_SetMask() for ALARM A"]
	#[doc = "or @ref LL_RTC_ALMB_SetMask() for ALARM B"]
	pub AlarmMask: u32,
	#[doc = "< Specifies the RTC Alarm is on day or WeekDay."]
	#[doc = "This parameter can be a value of @ref RTC_LL_EC_ALMA_WEEKDAY_SELECTION for ALARM A or @ref RTC_LL_EC_ALMB_WEEKDAY_SELECTION for ALARM B"]
	#[doc = ""]
	#[doc = "This feature can be modified afterwards using unitary function @ref LL_RTC_ALMA_EnableWeekday() or @ref LL_RTC_ALMA_DisableWeekday()"]
	#[doc = "for ALARM A or @ref LL_RTC_ALMB_EnableWeekday() or @ref LL_RTC_ALMB_DisableWeekday() for ALARM B"]
	pub AlarmDateWeekDaySel: u32,
	#[doc = "< Specifies the RTC Alarm Day/WeekDay."]
	#[doc = "If AlarmDateWeekDaySel set to day, this parameter  must be a number between Min_Data = 1 and Max_Data = 31."]
	#[doc = ""]
	#[doc = "This feature can be modified afterwards using unitary function @ref LL_RTC_ALMA_SetDay()"]
	#[doc = "for ALARM A or @ref LL_RTC_ALMB_SetDay() for ALARM B."]
	#[doc = ""]
	#[doc = "If AlarmDateWeekDaySel set to Weekday, this parameter can be a value of @ref RTC_LL_EC_WEEKDAY."]
	#[doc = ""]
	#[doc = "This feature can be modified afterwards using unitary function @ref LL_RTC_ALMA_SetWeekDay()"]
	#[doc = "for ALARM A or @ref LL_RTC_ALMB_SetWeekDay() for ALARM B."]
	pub AlarmDateWeekDay: u8,
}
#[test]
fn bindgen_test_layout_LL_RTC_AlarmTypeDef() {
	assert_eq!(
	           ::core::mem::size_of::<LL_RTC_AlarmTypeDef>(),
	           20usize,
	           concat!("Size of: ", stringify!(LL_RTC_AlarmTypeDef))
	);
	assert_eq!(
	           ::core::mem::align_of::<LL_RTC_AlarmTypeDef>(),
	           4usize,
	           concat!("Alignment of ", stringify!(LL_RTC_AlarmTypeDef))
	);
	fn test_field_AlarmTime() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_RTC_AlarmTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).AlarmTime) as usize - ptr as usize
		           },
		           0usize,
		           concat!(
			"Offset of field: ",
			stringify!(LL_RTC_AlarmTypeDef),
			"::",
			stringify!(AlarmTime)
		)
		);
	}
	test_field_AlarmTime();
	fn test_field_AlarmMask() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_RTC_AlarmTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).AlarmMask) as usize - ptr as usize
		           },
		           8usize,
		           concat!(
			"Offset of field: ",
			stringify!(LL_RTC_AlarmTypeDef),
			"::",
			stringify!(AlarmMask)
		)
		);
	}
	test_field_AlarmMask();
	fn test_field_AlarmDateWeekDaySel() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_RTC_AlarmTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).AlarmDateWeekDaySel) as usize - ptr as usize
		           },
		           12usize,
		           concat!(
			"Offset of field: ",
			stringify!(LL_RTC_AlarmTypeDef),
			"::",
			stringify!(AlarmDateWeekDaySel)
		)
		);
	}
	test_field_AlarmDateWeekDaySel();
	fn test_field_AlarmDateWeekDay() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_RTC_AlarmTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).AlarmDateWeekDay) as usize - ptr as usize
		           },
		           16usize,
		           concat!(
			"Offset of field: ",
			stringify!(LL_RTC_AlarmTypeDef),
			"::",
			stringify!(AlarmDateWeekDay)
		)
		);
	}
	test_field_AlarmDateWeekDay();
}
extern "C" {
	#[doc = " @defgroup RTC_LL_EF_Init Initialization and de-initialization functions"]
	#[doc = " @{"]
	pub fn LL_RTC_DeInit(RTCx: *mut RTC_TypeDef) -> ErrorStatus;
}
extern "C" {
	pub fn LL_RTC_Init(RTCx: *mut RTC_TypeDef, RTC_InitStruct: *mut LL_RTC_InitTypeDef) -> ErrorStatus;
}
extern "C" {
	pub fn LL_RTC_StructInit(RTC_InitStruct: *mut LL_RTC_InitTypeDef);
}
extern "C" {
	pub fn LL_RTC_TIME_Init(RTCx: *mut RTC_TypeDef, RTC_Format: u32, RTC_TimeStruct: *mut LL_RTC_TimeTypeDef) -> ErrorStatus;
}
extern "C" {
	pub fn LL_RTC_TIME_StructInit(RTC_TimeStruct: *mut LL_RTC_TimeTypeDef);
}
extern "C" {
	pub fn LL_RTC_DATE_Init(RTCx: *mut RTC_TypeDef, RTC_Format: u32, RTC_DateStruct: *mut LL_RTC_DateTypeDef) -> ErrorStatus;
}
extern "C" {
	pub fn LL_RTC_DATE_StructInit(RTC_DateStruct: *mut LL_RTC_DateTypeDef);
}
extern "C" {
	pub fn LL_RTC_ALMA_Init(RTCx: *mut RTC_TypeDef, RTC_Format: u32, RTC_AlarmStruct: *mut LL_RTC_AlarmTypeDef) -> ErrorStatus;
}
extern "C" {
	pub fn LL_RTC_ALMB_Init(RTCx: *mut RTC_TypeDef, RTC_Format: u32, RTC_AlarmStruct: *mut LL_RTC_AlarmTypeDef) -> ErrorStatus;
}
extern "C" {
	pub fn LL_RTC_ALMA_StructInit(RTC_AlarmStruct: *mut LL_RTC_AlarmTypeDef);
}
extern "C" {
	pub fn LL_RTC_ALMB_StructInit(RTC_AlarmStruct: *mut LL_RTC_AlarmTypeDef);
}
extern "C" {
	pub fn LL_RTC_EnterInitMode(RTCx: *mut RTC_TypeDef) -> ErrorStatus;
}
extern "C" {
	pub fn LL_RTC_ExitInitMode(RTCx: *mut RTC_TypeDef) -> ErrorStatus;
}
extern "C" {
	pub fn LL_RTC_WaitForSynchro(RTCx: *mut RTC_TypeDef) -> ErrorStatus;
}
#[doc = " @brief LL USART Init Structure definition"]
#[repr(C)]
pub struct LL_USART_InitTypeDef {
	#[doc = "< Specifies the Prescaler to compute the communication baud rate."]
	#[doc = "This parameter can be a value of @ref USART_LL_EC_PRESCALER."]
	#[doc = ""]
	#[doc = "This feature can be modified afterwards using unitary"]
	#[doc = "function @ref LL_USART_SetPrescaler()."]
	pub PrescalerValue: u32,
	#[doc = "< This field defines expected Usart communication baud rate."]
	#[doc = ""]
	#[doc = "This feature can be modified afterwards using unitary"]
	#[doc = "function @ref LL_USART_SetBaudRate()."]
	pub BaudRate: u32,
	#[doc = "< Specifies the number of data bits transmitted or received in a frame."]
	#[doc = "This parameter can be a value of @ref USART_LL_EC_DATAWIDTH."]
	#[doc = ""]
	#[doc = "This feature can be modified afterwards using unitary"]
	#[doc = "function @ref LL_USART_SetDataWidth()."]
	pub DataWidth: u32,
	#[doc = "< Specifies the number of stop bits transmitted."]
	#[doc = "This parameter can be a value of @ref USART_LL_EC_STOPBITS."]
	#[doc = ""]
	#[doc = "This feature can be modified afterwards using unitary"]
	#[doc = "function @ref LL_USART_SetStopBitsLength()."]
	pub StopBits: u32,
	#[doc = "< Specifies the parity mode."]
	#[doc = "This parameter can be a value of @ref USART_LL_EC_PARITY."]
	#[doc = ""]
	#[doc = "This feature can be modified afterwards using unitary"]
	#[doc = "function @ref LL_USART_SetParity()."]
	pub Parity: u32,
	#[doc = "< Specifies whether the Receive and/or Transmit mode is enabled or disabled."]
	#[doc = "This parameter can be a value of @ref USART_LL_EC_DIRECTION."]
	#[doc = ""]
	#[doc = "This feature can be modified afterwards using unitary"]
	#[doc = "function @ref LL_USART_SetTransferDirection()."]
	pub TransferDirection: u32,
	#[doc = "< Specifies whether the hardware flow control mode is enabled or disabled."]
	#[doc = "This parameter can be a value of @ref USART_LL_EC_HWCONTROL."]
	#[doc = ""]
	#[doc = "This feature can be modified afterwards using unitary"]
	#[doc = "function @ref LL_USART_SetHWFlowCtrl()."]
	pub HardwareFlowControl: u32,
	#[doc = "< Specifies whether USART oversampling mode is 16 or 8."]
	#[doc = "This parameter can be a value of @ref USART_LL_EC_OVERSAMPLING."]
	#[doc = ""]
	#[doc = "This feature can be modified afterwards using unitary"]
	#[doc = "function @ref LL_USART_SetOverSampling()."]
	pub OverSampling: u32,
}
#[test]
fn bindgen_test_layout_LL_USART_InitTypeDef() {
	assert_eq!(
	           ::core::mem::size_of::<LL_USART_InitTypeDef>(),
	           32usize,
	           concat!("Size of: ", stringify!(LL_USART_InitTypeDef))
	);
	assert_eq!(
	           ::core::mem::align_of::<LL_USART_InitTypeDef>(),
	           4usize,
	           concat!("Alignment of ", stringify!(LL_USART_InitTypeDef))
	);
	fn test_field_PrescalerValue() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_USART_InitTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).PrescalerValue) as usize - ptr as usize
		           },
		           0usize,
		           concat!(
			"Offset of field: ",
			stringify!(LL_USART_InitTypeDef),
			"::",
			stringify!(PrescalerValue)
		)
		);
	}
	test_field_PrescalerValue();
	fn test_field_BaudRate() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_USART_InitTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).BaudRate) as usize - ptr as usize
		           },
		           4usize,
		           concat!(
			"Offset of field: ",
			stringify!(LL_USART_InitTypeDef),
			"::",
			stringify!(BaudRate)
		)
		);
	}
	test_field_BaudRate();
	fn test_field_DataWidth() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_USART_InitTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).DataWidth) as usize - ptr as usize
		           },
		           8usize,
		           concat!(
			"Offset of field: ",
			stringify!(LL_USART_InitTypeDef),
			"::",
			stringify!(DataWidth)
		)
		);
	}
	test_field_DataWidth();
	fn test_field_StopBits() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_USART_InitTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).StopBits) as usize - ptr as usize
		           },
		           12usize,
		           concat!(
			"Offset of field: ",
			stringify!(LL_USART_InitTypeDef),
			"::",
			stringify!(StopBits)
		)
		);
	}
	test_field_StopBits();
	fn test_field_Parity() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_USART_InitTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).Parity) as usize - ptr as usize
		           },
		           16usize,
		           concat!(
			"Offset of field: ",
			stringify!(LL_USART_InitTypeDef),
			"::",
			stringify!(Parity)
		)
		);
	}
	test_field_Parity();
	fn test_field_TransferDirection() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_USART_InitTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).TransferDirection) as usize - ptr as usize
		           },
		           20usize,
		           concat!(
			"Offset of field: ",
			stringify!(LL_USART_InitTypeDef),
			"::",
			stringify!(TransferDirection)
		)
		);
	}
	test_field_TransferDirection();
	fn test_field_HardwareFlowControl() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_USART_InitTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).HardwareFlowControl) as usize - ptr as usize
		           },
		           24usize,
		           concat!(
			"Offset of field: ",
			stringify!(LL_USART_InitTypeDef),
			"::",
			stringify!(HardwareFlowControl)
		)
		);
	}
	test_field_HardwareFlowControl();
	fn test_field_OverSampling() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_USART_InitTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).OverSampling) as usize - ptr as usize
		           },
		           28usize,
		           concat!(
			"Offset of field: ",
			stringify!(LL_USART_InitTypeDef),
			"::",
			stringify!(OverSampling)
		)
		);
	}
	test_field_OverSampling();
}
#[doc = " @brief LL USART Clock Init Structure definition"]
#[repr(C)]
pub struct LL_USART_ClockInitTypeDef {
	#[doc = "< Specifies whether the USART clock is enabled or disabled."]
	#[doc = "This parameter can be a value of @ref USART_LL_EC_CLOCK."]
	#[doc = ""]
	#[doc = "USART HW configuration can be modified afterwards using unitary functions"]
	#[doc = "@ref LL_USART_EnableSCLKOutput() or @ref LL_USART_DisableSCLKOutput()."]
	#[doc = "For more details, refer to description of this function."]
	pub ClockOutput: u32,
	#[doc = "< Specifies the steady state of the serial clock."]
	#[doc = "This parameter can be a value of @ref USART_LL_EC_POLARITY."]
	#[doc = ""]
	#[doc = "USART HW configuration can be modified afterwards using unitary"]
	#[doc = "functions @ref LL_USART_SetClockPolarity()."]
	#[doc = "For more details, refer to description of this function."]
	pub ClockPolarity: u32,
	#[doc = "< Specifies the clock transition on which the bit capture is made."]
	#[doc = "This parameter can be a value of @ref USART_LL_EC_PHASE."]
	#[doc = ""]
	#[doc = "USART HW configuration can be modified afterwards using unitary"]
	#[doc = "functions @ref LL_USART_SetClockPhase()."]
	#[doc = "For more details, refer to description of this function."]
	pub ClockPhase: u32,
	#[doc = "< Specifies whether the clock pulse corresponding to the last transmitted"]
	#[doc = "data bit (MSB) has to be output on the SCLK pin in synchronous mode."]
	#[doc = "This parameter can be a value of @ref USART_LL_EC_LASTCLKPULSE."]
	#[doc = ""]
	#[doc = "USART HW configuration can be modified afterwards using unitary"]
	#[doc = "functions @ref LL_USART_SetLastClkPulseOutput()."]
	#[doc = "For more details, refer to description of this function."]
	pub LastBitClockPulse: u32,
}
#[test]
fn bindgen_test_layout_LL_USART_ClockInitTypeDef() {
	assert_eq!(
	           ::core::mem::size_of::<LL_USART_ClockInitTypeDef>(),
	           16usize,
	           concat!("Size of: ", stringify!(LL_USART_ClockInitTypeDef))
	);
	assert_eq!(
	           ::core::mem::align_of::<LL_USART_ClockInitTypeDef>(),
	           4usize,
	           concat!("Alignment of ", stringify!(LL_USART_ClockInitTypeDef))
	);
	fn test_field_ClockOutput() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_USART_ClockInitTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).ClockOutput) as usize - ptr as usize
		           },
		           0usize,
		           concat!(
			"Offset of field: ",
			stringify!(LL_USART_ClockInitTypeDef),
			"::",
			stringify!(ClockOutput)
		)
		);
	}
	test_field_ClockOutput();
	fn test_field_ClockPolarity() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_USART_ClockInitTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).ClockPolarity) as usize - ptr as usize
		           },
		           4usize,
		           concat!(
			"Offset of field: ",
			stringify!(LL_USART_ClockInitTypeDef),
			"::",
			stringify!(ClockPolarity)
		)
		);
	}
	test_field_ClockPolarity();
	fn test_field_ClockPhase() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_USART_ClockInitTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).ClockPhase) as usize - ptr as usize
		           },
		           8usize,
		           concat!(
			"Offset of field: ",
			stringify!(LL_USART_ClockInitTypeDef),
			"::",
			stringify!(ClockPhase)
		)
		);
	}
	test_field_ClockPhase();
	fn test_field_LastBitClockPulse() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_USART_ClockInitTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).LastBitClockPulse) as usize - ptr as usize
		           },
		           12usize,
		           concat!(
			"Offset of field: ",
			stringify!(LL_USART_ClockInitTypeDef),
			"::",
			stringify!(LastBitClockPulse)
		)
		);
	}
	test_field_LastBitClockPulse();
}
extern "C" {
	#[doc = " @defgroup USART_LL_EF_Init Initialization and de-initialization functions"]
	#[doc = " @{"]
	pub fn LL_USART_DeInit(USARTx: *mut USART_TypeDef) -> ErrorStatus;
}
extern "C" {
	pub fn LL_USART_Init(USARTx: *mut USART_TypeDef, USART_InitStruct: *mut LL_USART_InitTypeDef) -> ErrorStatus;
}
extern "C" {
	pub fn LL_USART_StructInit(USART_InitStruct: *mut LL_USART_InitTypeDef);
}
extern "C" {
	pub fn LL_USART_ClockInit(USARTx: *mut USART_TypeDef, USART_ClockInitStruct: *mut LL_USART_ClockInitTypeDef) -> ErrorStatus;
}
extern "C" {
	pub fn LL_USART_ClockStructInit(USART_ClockInitStruct: *mut LL_USART_ClockInitTypeDef);
}
#[doc = " @defgroup UTILS_LL_ES_INIT UTILS Exported structures"]
#[doc = " @{"]
#[doc = " @brief  UTILS PLL structure definition"]
#[repr(C)]
pub struct LL_UTILS_PLLInitTypeDef {
	#[doc = "< Division factor for PLL VCO input clock."]
	#[doc = "This parameter can be a value of @ref RCC_LL_EC_PLLM_DIV."]
	#[doc = ""]
	#[doc = "This feature can be modified afterwards using unitary function"]
	#[doc = "@ref LL_RCC_PLL_ConfigDomain_SYS()."]
	pub PLLM: u32,
	#[doc = "< Multiplication factor for PLL VCO output clock."]
	#[doc = "This parameter must be a number between Min_Data = 6 and Max_Data = 127."]
	#[doc = ""]
	#[doc = "This feature can be modified afterwards using unitary function"]
	#[doc = "@ref LL_RCC_PLL_ConfigDomain_SYS()."]
	pub PLLN: u32,
	#[doc = "< Division for the main system clock."]
	#[doc = "This parameter can be a value of @ref RCC_LL_EC_PLLR_DIV."]
	#[doc = ""]
	#[doc = "This feature can be modified afterwards using unitary function"]
	#[doc = "@ref LL_RCC_PLL_ConfigDomain_SYS()."]
	pub PLLR: u32,
}
#[test]
fn bindgen_test_layout_LL_UTILS_PLLInitTypeDef() {
	assert_eq!(
	           ::core::mem::size_of::<LL_UTILS_PLLInitTypeDef>(),
	           12usize,
	           concat!("Size of: ", stringify!(LL_UTILS_PLLInitTypeDef))
	);
	assert_eq!(
	           ::core::mem::align_of::<LL_UTILS_PLLInitTypeDef>(),
	           4usize,
	           concat!("Alignment of ", stringify!(LL_UTILS_PLLInitTypeDef))
	);
	fn test_field_PLLM() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_UTILS_PLLInitTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).PLLM) as usize - ptr as usize
		           },
		           0usize,
		           concat!(
			"Offset of field: ",
			stringify!(LL_UTILS_PLLInitTypeDef),
			"::",
			stringify!(PLLM)
		)
		);
	}
	test_field_PLLM();
	fn test_field_PLLN() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_UTILS_PLLInitTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).PLLN) as usize - ptr as usize
		           },
		           4usize,
		           concat!(
			"Offset of field: ",
			stringify!(LL_UTILS_PLLInitTypeDef),
			"::",
			stringify!(PLLN)
		)
		);
	}
	test_field_PLLN();
	fn test_field_PLLR() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_UTILS_PLLInitTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).PLLR) as usize - ptr as usize
		           },
		           8usize,
		           concat!(
			"Offset of field: ",
			stringify!(LL_UTILS_PLLInitTypeDef),
			"::",
			stringify!(PLLR)
		)
		);
	}
	test_field_PLLR();
}
#[doc = " @brief  UTILS System, AHB and APB buses clock configuration structure definition"]
#[repr(C)]
pub struct LL_UTILS_ClkInitTypeDef {
	#[doc = "< The CPU1 clock (HCLK1) divider. This clock is derived from the system clock (SYSCLK)."]
	#[doc = "This parameter can be a value of @ref RCC_LL_EC_SYSCLK_DIV."]
	#[doc = ""]
	#[doc = "This feature can be modified afterwards using unitary function"]
	#[doc = "@ref LL_RCC_SetAHBPrescaler()."]
	pub CPU1CLKDivider: u32,
	#[doc = "< The CPU2 clock (HCLK2) divider. This clock is derived from the system clock (SYSCLK)."]
	#[doc = "This parameter can be a value of @ref RCC_LL_EC_SYSCLK_DIV."]
	#[doc = ""]
	#[doc = "This feature can be modified afterwards using unitary function"]
	#[doc = "@ref LL_C2_RCC_SetAHBPrescaler()."]
	pub CPU2CLKDivider: u32,
	#[doc = "< The AHBS clock (HCLK4) divider. This clock is derived from the system clock (SYSCLK)."]
	#[doc = "This parameter can be a value of @ref RCC_LL_EC_SYSCLK_DIV."]
	#[doc = ""]
	#[doc = "This feature can be modified afterwards using unitary function"]
	#[doc = "@ref LL_RCC_SetAHB4Prescaler()."]
	pub AHB4CLKDivider: u32,
	#[doc = "< The APB1 clock (PCLK1) divider. This clock is derived from the AHB clock (HCLK1)."]
	#[doc = "This parameter can be a value of @ref RCC_LL_EC_APB1_DIV."]
	#[doc = ""]
	#[doc = "This feature can be modified afterwards using unitary function"]
	#[doc = "@ref LL_RCC_SetAPB1Prescaler()."]
	pub APB1CLKDivider: u32,
	#[doc = "< The APB2 clock (PCLK2) divider. This clock is derived from the AHB clock (HCLK1)."]
	#[doc = "This parameter can be a value of @ref RCC_LL_EC_APB2_DIV."]
	#[doc = ""]
	#[doc = "This feature can be modified afterwards using unitary function"]
	#[doc = "@ref LL_RCC_SetAPB2Prescaler()."]
	pub APB2CLKDivider: u32,
}
#[test]
fn bindgen_test_layout_LL_UTILS_ClkInitTypeDef() {
	assert_eq!(
	           ::core::mem::size_of::<LL_UTILS_ClkInitTypeDef>(),
	           20usize,
	           concat!("Size of: ", stringify!(LL_UTILS_ClkInitTypeDef))
	);
	assert_eq!(
	           ::core::mem::align_of::<LL_UTILS_ClkInitTypeDef>(),
	           4usize,
	           concat!("Alignment of ", stringify!(LL_UTILS_ClkInitTypeDef))
	);
	fn test_field_CPU1CLKDivider() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_UTILS_ClkInitTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).CPU1CLKDivider) as usize - ptr as usize
		           },
		           0usize,
		           concat!(
			"Offset of field: ",
			stringify!(LL_UTILS_ClkInitTypeDef),
			"::",
			stringify!(CPU1CLKDivider)
		)
		);
	}
	test_field_CPU1CLKDivider();
	fn test_field_CPU2CLKDivider() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_UTILS_ClkInitTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).CPU2CLKDivider) as usize - ptr as usize
		           },
		           4usize,
		           concat!(
			"Offset of field: ",
			stringify!(LL_UTILS_ClkInitTypeDef),
			"::",
			stringify!(CPU2CLKDivider)
		)
		);
	}
	test_field_CPU2CLKDivider();
	fn test_field_AHB4CLKDivider() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_UTILS_ClkInitTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).AHB4CLKDivider) as usize - ptr as usize
		           },
		           8usize,
		           concat!(
			"Offset of field: ",
			stringify!(LL_UTILS_ClkInitTypeDef),
			"::",
			stringify!(AHB4CLKDivider)
		)
		);
	}
	test_field_AHB4CLKDivider();
	fn test_field_APB1CLKDivider() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_UTILS_ClkInitTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).APB1CLKDivider) as usize - ptr as usize
		           },
		           12usize,
		           concat!(
			"Offset of field: ",
			stringify!(LL_UTILS_ClkInitTypeDef),
			"::",
			stringify!(APB1CLKDivider)
		)
		);
	}
	test_field_APB1CLKDivider();
	fn test_field_APB2CLKDivider() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LL_UTILS_ClkInitTypeDef>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).APB2CLKDivider) as usize - ptr as usize
		           },
		           16usize,
		           concat!(
			"Offset of field: ",
			stringify!(LL_UTILS_ClkInitTypeDef),
			"::",
			stringify!(APB2CLKDivider)
		)
		);
	}
	test_field_APB2CLKDivider();
}
extern "C" {
	pub fn LL_Init1msTick(HCLKFrequency: u32);
}
extern "C" {
	pub fn LL_mDelay(Delay: u32);
}
extern "C" {
	#[doc = " @defgroup UTILS_EF_SYSTEM SYSTEM"]
	#[doc = " @{"]
	pub fn LL_SetSystemCoreClock(HCLKFrequency: u32);
}
extern "C" {
	pub fn LL_SetFlashLatency(HCLK4Frequency: u32) -> ErrorStatus;
}
extern "C" {
	pub fn LL_PLL_ConfigSystemClock_MSI(UTILS_PLLInitStruct: *mut LL_UTILS_PLLInitTypeDef,
	                                    UTILS_ClkInitStruct: *mut LL_UTILS_ClkInitTypeDef)
	                                    -> ErrorStatus;
}
extern "C" {
	pub fn LL_PLL_ConfigSystemClock_HSI(UTILS_PLLInitStruct: *mut LL_UTILS_PLLInitTypeDef,
	                                    UTILS_ClkInitStruct: *mut LL_UTILS_ClkInitTypeDef)
	                                    -> ErrorStatus;
}
extern "C" {
	pub fn LL_PLL_ConfigSystemClock_HSE(HSEBypass: u32,
	                                    UTILS_PLLInitStruct: *mut LL_UTILS_PLLInitTypeDef,
	                                    UTILS_ClkInitStruct: *mut LL_UTILS_ClkInitTypeDef)
	                                    -> ErrorStatus;
}
pub type Elf32_Addr = u32;
#[repr(C)]
pub struct ElfApiInterface {
	pub api_version_major: u16,
	pub api_version_minor: u16,
	pub resolver_callback:
		::core::option::Option<unsafe extern "C" fn(name: *const core::ffi::c_char, address: *mut Elf32_Addr) -> bool>,
}
#[test]
fn bindgen_test_layout_ElfApiInterface() {
	assert_eq!(
	           ::core::mem::size_of::<ElfApiInterface>(),
	           8usize,
	           concat!("Size of: ", stringify!(ElfApiInterface))
	);
	assert_eq!(
	           ::core::mem::align_of::<ElfApiInterface>(),
	           4usize,
	           concat!("Alignment of ", stringify!(ElfApiInterface))
	);
	fn test_field_api_version_major() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<ElfApiInterface>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).api_version_major) as usize - ptr as usize
		           },
		           0usize,
		           concat!(
			"Offset of field: ",
			stringify!(ElfApiInterface),
			"::",
			stringify!(api_version_major)
		)
		);
	}
	test_field_api_version_major();
	fn test_field_api_version_minor() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<ElfApiInterface>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).api_version_minor) as usize - ptr as usize
		           },
		           2usize,
		           concat!(
			"Offset of field: ",
			stringify!(ElfApiInterface),
			"::",
			stringify!(api_version_minor)
		)
		);
	}
	test_field_api_version_minor();
	fn test_field_resolver_callback() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<ElfApiInterface>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).resolver_callback) as usize - ptr as usize
		           },
		           4usize,
		           concat!(
			"Offset of field: ",
			stringify!(ElfApiInterface),
			"::",
			stringify!(resolver_callback)
		)
		);
	}
	test_field_resolver_callback();
}
#[repr(C, packed)]
pub struct FlipperApplicationManifestBase {
	pub manifest_magic: u32,
	pub manifest_version: u32,
	pub api_version: FlipperApplicationManifestBase__bindgen_ty_1,
	pub hardware_target_id: u16,
}
#[repr(C, packed)]
pub struct FlipperApplicationManifestBase__bindgen_ty_1 {
	pub __bindgen_anon_1: __BindgenUnionField<FlipperApplicationManifestBase__bindgen_ty_1__bindgen_ty_1>,
	pub version: __BindgenUnionField<u32>,
	pub bindgen_union_field: [u8; 4usize],
}
#[repr(C, packed)]
pub struct FlipperApplicationManifestBase__bindgen_ty_1__bindgen_ty_1 {
	pub minor: u16,
	pub major: u16,
}
#[test]
fn bindgen_test_layout_FlipperApplicationManifestBase__bindgen_ty_1__bindgen_ty_1() {
	assert_eq!(
	           ::core::mem::size_of::<FlipperApplicationManifestBase__bindgen_ty_1__bindgen_ty_1>(),
	           4usize,
	           concat!(
		"Size of: ",
		stringify!(FlipperApplicationManifestBase__bindgen_ty_1__bindgen_ty_1)
	)
	);
	assert_eq!(
	           ::core::mem::align_of::<FlipperApplicationManifestBase__bindgen_ty_1__bindgen_ty_1>(),
	           1usize,
	           concat!(
		"Alignment of ",
		stringify!(FlipperApplicationManifestBase__bindgen_ty_1__bindgen_ty_1)
	)
	);
	fn test_field_minor() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<FlipperApplicationManifestBase__bindgen_ty_1__bindgen_ty_1>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).minor) as usize - ptr as usize
		           },
		           0usize,
		           concat!(
			"Offset of field: ",
			stringify!(FlipperApplicationManifestBase__bindgen_ty_1__bindgen_ty_1),
			"::",
			stringify!(minor)
		)
		);
	}
	test_field_minor();
	fn test_field_major() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<FlipperApplicationManifestBase__bindgen_ty_1__bindgen_ty_1>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).major) as usize - ptr as usize
		           },
		           2usize,
		           concat!(
			"Offset of field: ",
			stringify!(FlipperApplicationManifestBase__bindgen_ty_1__bindgen_ty_1),
			"::",
			stringify!(major)
		)
		);
	}
	test_field_major();
}
#[test]
fn bindgen_test_layout_FlipperApplicationManifestBase__bindgen_ty_1() {
	assert_eq!(
	           ::core::mem::size_of::<FlipperApplicationManifestBase__bindgen_ty_1>(),
	           4usize,
	           concat!("Size of: ", stringify!(FlipperApplicationManifestBase__bindgen_ty_1))
	);
	assert_eq!(
	           ::core::mem::align_of::<FlipperApplicationManifestBase__bindgen_ty_1>(),
	           1usize,
	           concat!("Alignment of ", stringify!(FlipperApplicationManifestBase__bindgen_ty_1))
	);
	fn test_field_version() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<FlipperApplicationManifestBase__bindgen_ty_1>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).version) as usize - ptr as usize
		           },
		           0usize,
		           concat!(
			"Offset of field: ",
			stringify!(FlipperApplicationManifestBase__bindgen_ty_1),
			"::",
			stringify!(version)
		)
		);
	}
	test_field_version();
}
#[test]
fn bindgen_test_layout_FlipperApplicationManifestBase() {
	assert_eq!(
	           ::core::mem::size_of::<FlipperApplicationManifestBase>(),
	           14usize,
	           concat!("Size of: ", stringify!(FlipperApplicationManifestBase))
	);
	assert_eq!(
	           ::core::mem::align_of::<FlipperApplicationManifestBase>(),
	           1usize,
	           concat!("Alignment of ", stringify!(FlipperApplicationManifestBase))
	);
	fn test_field_manifest_magic() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<FlipperApplicationManifestBase>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).manifest_magic) as usize - ptr as usize
		           },
		           0usize,
		           concat!(
			"Offset of field: ",
			stringify!(FlipperApplicationManifestBase),
			"::",
			stringify!(manifest_magic)
		)
		);
	}
	test_field_manifest_magic();
	fn test_field_manifest_version() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<FlipperApplicationManifestBase>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).manifest_version) as usize - ptr as usize
		           },
		           4usize,
		           concat!(
			"Offset of field: ",
			stringify!(FlipperApplicationManifestBase),
			"::",
			stringify!(manifest_version)
		)
		);
	}
	test_field_manifest_version();
	fn test_field_api_version() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<FlipperApplicationManifestBase>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).api_version) as usize - ptr as usize
		           },
		           8usize,
		           concat!(
			"Offset of field: ",
			stringify!(FlipperApplicationManifestBase),
			"::",
			stringify!(api_version)
		)
		);
	}
	test_field_api_version();
	fn test_field_hardware_target_id() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<FlipperApplicationManifestBase>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).hardware_target_id) as usize - ptr as usize
		           },
		           12usize,
		           concat!(
			"Offset of field: ",
			stringify!(FlipperApplicationManifestBase),
			"::",
			stringify!(hardware_target_id)
		)
		);
	}
	test_field_hardware_target_id();
}
#[repr(C, packed)]
pub struct FlipperApplicationManifestV1 {
	pub base: FlipperApplicationManifestBase,
	pub stack_size: u16,
	pub app_version: u32,
	pub name: [core::ffi::c_char; 32usize],
	pub has_icon: core::ffi::c_char,
	pub icon: [core::ffi::c_char; 32usize],
}
#[test]
fn bindgen_test_layout_FlipperApplicationManifestV1() {
	assert_eq!(
	           ::core::mem::size_of::<FlipperApplicationManifestV1>(),
	           85usize,
	           concat!("Size of: ", stringify!(FlipperApplicationManifestV1))
	);
	assert_eq!(
	           ::core::mem::align_of::<FlipperApplicationManifestV1>(),
	           1usize,
	           concat!("Alignment of ", stringify!(FlipperApplicationManifestV1))
	);
	fn test_field_base() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<FlipperApplicationManifestV1>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).base) as usize - ptr as usize
		           },
		           0usize,
		           concat!(
			"Offset of field: ",
			stringify!(FlipperApplicationManifestV1),
			"::",
			stringify!(base)
		)
		);
	}
	test_field_base();
	fn test_field_stack_size() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<FlipperApplicationManifestV1>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).stack_size) as usize - ptr as usize
		           },
		           14usize,
		           concat!(
			"Offset of field: ",
			stringify!(FlipperApplicationManifestV1),
			"::",
			stringify!(stack_size)
		)
		);
	}
	test_field_stack_size();
	fn test_field_app_version() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<FlipperApplicationManifestV1>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).app_version) as usize - ptr as usize
		           },
		           16usize,
		           concat!(
			"Offset of field: ",
			stringify!(FlipperApplicationManifestV1),
			"::",
			stringify!(app_version)
		)
		);
	}
	test_field_app_version();
	fn test_field_name() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<FlipperApplicationManifestV1>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).name) as usize - ptr as usize
		           },
		           20usize,
		           concat!(
			"Offset of field: ",
			stringify!(FlipperApplicationManifestV1),
			"::",
			stringify!(name)
		)
		);
	}
	test_field_name();
	fn test_field_has_icon() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<FlipperApplicationManifestV1>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).has_icon) as usize - ptr as usize
		           },
		           52usize,
		           concat!(
			"Offset of field: ",
			stringify!(FlipperApplicationManifestV1),
			"::",
			stringify!(has_icon)
		)
		);
	}
	test_field_has_icon();
	fn test_field_icon() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<FlipperApplicationManifestV1>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).icon) as usize - ptr as usize
		           },
		           53usize,
		           concat!(
			"Offset of field: ",
			stringify!(FlipperApplicationManifestV1),
			"::",
			stringify!(icon)
		)
		);
	}
	test_field_icon();
}
pub type FlipperApplicationManifest = FlipperApplicationManifestV1;
extern "C" {
	#[doc = " @brief Check if manifest is valid"]
	#[doc = ""]
	#[doc = " @param manifest"]
	#[doc = " @return bool"]
	pub fn flipper_application_manifest_is_valid(manifest: *const FlipperApplicationManifest) -> bool;
}
extern "C" {
	#[doc = " @brief Check if manifest is compatible with current ELF API interface"]
	#[doc = ""]
	#[doc = " @param manifest"]
	#[doc = " @param api_interface"]
	#[doc = " @return bool"]
	pub fn flipper_application_manifest_is_compatible(manifest: *const FlipperApplicationManifest,
	                                                  api_interface: *const ElfApiInterface)
	                                                  -> bool;
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum FlipperApplicationPreloadStatus {
	FlipperApplicationPreloadStatusSuccess = 0,
	FlipperApplicationPreloadStatusUnspecifiedError = 1,
	FlipperApplicationPreloadStatusInvalidFile = 2,
	FlipperApplicationPreloadStatusInvalidManifest = 3,
	FlipperApplicationPreloadStatusApiMismatch = 4,
	FlipperApplicationPreloadStatusTargetMismatch = 5,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum FlipperApplicationLoadStatus {
	FlipperApplicationLoadStatusSuccess = 0,
	FlipperApplicationLoadStatusUnspecifiedError = 1,
	FlipperApplicationLoadStatusNoFreeMemory = 2,
	FlipperApplicationLoadStatusMissingImports = 3,
}
extern "C" {
	#[doc = " @brief Get text description of preload status"]
	#[doc = " @param status Status code"]
	#[doc = " @return String pointer to description"]
	pub fn flipper_application_preload_status_to_string(status: FlipperApplicationPreloadStatus) -> *const core::ffi::c_char;
}
extern "C" {
	#[doc = " @brief Get text description of load status"]
	#[doc = " @param status Status code"]
	#[doc = " @return String pointer to description"]
	pub fn flipper_application_load_status_to_string(status: FlipperApplicationLoadStatus) -> *const core::ffi::c_char;
}
#[repr(C)]
pub struct FlipperApplication {
	_unused: [u8; 0],
}
extern "C" {
	#[doc = " @brief Initialize FlipperApplication object"]
	#[doc = " @param storage Storage instance"]
	#[doc = " @param api_interface ELF API interface to use for pre-loading and symbol resolving"]
	#[doc = " @return Application instance"]
	pub fn flipper_application_alloc(storage: *mut Storage, api_interface: *const ElfApiInterface) -> *mut FlipperApplication;
}
extern "C" {
	#[doc = " @brief Destroy FlipperApplication object"]
	#[doc = " @param app Application pointer"]
	pub fn flipper_application_free(app: *mut FlipperApplication);
}
extern "C" {
	#[doc = " @brief Validate elf file and load application metadata"]
	#[doc = " @param app Application pointer"]
	#[doc = " @return Preload result code"]
	pub fn flipper_application_preload(app: *mut FlipperApplication,
	                                   path: *const core::ffi::c_char)
	                                   -> FlipperApplicationPreloadStatus;
}
extern "C" {
	#[doc = " @brief Validate elf file and load application manifest"]
	#[doc = " @param app Application pointer"]
	#[doc = " @return Preload result code"]
	pub fn flipper_application_preload_manifest(app: *mut FlipperApplication,
	                                            path: *const core::ffi::c_char)
	                                            -> FlipperApplicationPreloadStatus;
}
extern "C" {
	#[doc = " @brief Get pointer to application manifest for preloaded application"]
	#[doc = " @param app Application pointer"]
	#[doc = " @return Pointer to application manifest"]
	pub fn flipper_application_get_manifest(app: *mut FlipperApplication) -> *const FlipperApplicationManifest;
}
extern "C" {
	#[doc = " @brief Load sections and process relocations for already pre-loaded application"]
	#[doc = " @param app Application pointer"]
	#[doc = " @return Load result code"]
	pub fn flipper_application_map_to_memory(app: *mut FlipperApplication) -> FlipperApplicationLoadStatus;
}
extern "C" {
	#[doc = " @brief Create application thread at entry point address, using app name and"]
	#[doc = " stack size from metadata. Returned thread isn't started yet."]
	#[doc = " Can be only called once for application instance."]
	#[doc = " @param app Applicaiton pointer"]
	#[doc = " @param args Object to pass to app's entry point"]
	#[doc = " @return Created thread"]
	pub fn flipper_application_spawn(app: *mut FlipperApplication, args: *mut core::ffi::c_void) -> *mut FuriThread;
}
#[repr(C)]
pub struct FlipperFormat {
	_unused: [u8; 0],
}
extern "C" {
	#[doc = " Allocate FlipperFormat as string."]
	#[doc = " @return FlipperFormat* pointer to a FlipperFormat instance"]
	pub fn flipper_format_string_alloc() -> *mut FlipperFormat;
}
extern "C" {
	#[doc = " Allocate FlipperFormat as file."]
	#[doc = " @return FlipperFormat* pointer to a FlipperFormat instance"]
	pub fn flipper_format_file_alloc(storage: *mut Storage) -> *mut FlipperFormat;
}
extern "C" {
	#[doc = " Allocate FlipperFormat as file, buffered mode."]
	#[doc = " @return FlipperFormat* pointer to a FlipperFormat instance"]
	pub fn flipper_format_buffered_file_alloc(storage: *mut Storage) -> *mut FlipperFormat;
}
extern "C" {
	#[doc = " Open existing file."]
	#[doc = " Use only if FlipperFormat allocated as a file."]
	#[doc = " @param flipper_format Pointer to a FlipperFormat instance"]
	#[doc = " @param path File path"]
	#[doc = " @return True on success"]
	pub fn flipper_format_file_open_existing(flipper_format: *mut FlipperFormat, path: *const core::ffi::c_char) -> bool;
}
extern "C" {
	#[doc = " Open existing file, buffered mode."]
	#[doc = " Use only if FlipperFormat allocated as a file."]
	#[doc = " @param flipper_format Pointer to a FlipperFormat instance"]
	#[doc = " @param path File path"]
	#[doc = " @return True on success"]
	pub fn flipper_format_buffered_file_open_existing(flipper_format: *mut FlipperFormat, path: *const core::ffi::c_char) -> bool;
}
extern "C" {
	#[doc = " Open existing file for writing and add values to the end of file."]
	#[doc = " Use only if FlipperFormat allocated as a file."]
	#[doc = " @param flipper_format Pointer to a FlipperFormat instance"]
	#[doc = " @param path File path"]
	#[doc = " @return True on success"]
	pub fn flipper_format_file_open_append(flipper_format: *mut FlipperFormat, path: *const core::ffi::c_char) -> bool;
}
extern "C" {
	#[doc = " Open file. Creates a new file, or deletes the contents of the file if it already exists."]
	#[doc = " Use only if FlipperFormat allocated as a file."]
	#[doc = " @param flipper_format Pointer to a FlipperFormat instance"]
	#[doc = " @param path File path"]
	#[doc = " @return True on success"]
	pub fn flipper_format_file_open_always(flipper_format: *mut FlipperFormat, path: *const core::ffi::c_char) -> bool;
}
extern "C" {
	#[doc = " Open file. Creates a new file, fails if file already exists."]
	#[doc = " Use only if FlipperFormat allocated as a file."]
	#[doc = " @param flipper_format Pointer to a FlipperFormat instance"]
	#[doc = " @param path File path"]
	#[doc = " @return True on success"]
	pub fn flipper_format_file_open_new(flipper_format: *mut FlipperFormat, path: *const core::ffi::c_char) -> bool;
}
extern "C" {
	#[doc = " Closes the file, use only if FlipperFormat allocated as a file."]
	#[doc = " @param flipper_format"]
	#[doc = " @return true"]
	#[doc = " @return false"]
	pub fn flipper_format_file_close(flipper_format: *mut FlipperFormat) -> bool;
}
extern "C" {
	#[doc = " Closes the file, use only if FlipperFormat allocated as a buffered file."]
	#[doc = " @param flipper_format"]
	#[doc = " @return true"]
	#[doc = " @return false"]
	pub fn flipper_format_buffered_file_close(flipper_format: *mut FlipperFormat) -> bool;
}
extern "C" {
	#[doc = " Free FlipperFormat."]
	#[doc = " @param flipper_format Pointer to a FlipperFormat instance"]
	pub fn flipper_format_free(flipper_format: *mut FlipperFormat);
}
extern "C" {
	#[doc = " Set FlipperFormat mode."]
	#[doc = " @param flipper_format Pointer to a FlipperFormat instance"]
	#[doc = " @param strict_mode True obligates not to skip valid fields. False by default."]
	pub fn flipper_format_set_strict_mode(flipper_format: *mut FlipperFormat, strict_mode: bool);
}
extern "C" {
	#[doc = " Rewind the RW pointer."]
	#[doc = " @param flipper_format Pointer to a FlipperFormat instance"]
	#[doc = " @return True on success"]
	pub fn flipper_format_rewind(flipper_format: *mut FlipperFormat) -> bool;
}
extern "C" {
	#[doc = " Move the RW pointer at the end. Can be useful if you want to add some data after reading."]
	#[doc = " @param flipper_format Pointer to a FlipperFormat instance"]
	#[doc = " @return True on success"]
	pub fn flipper_format_seek_to_end(flipper_format: *mut FlipperFormat) -> bool;
}
extern "C" {
	#[doc = " Check if the key exists."]
	#[doc = " @param flipper_format Pointer to a FlipperFormat instance"]
	#[doc = " @param key Key"]
	#[doc = " @return true key exists"]
	#[doc = " @return false key is not exists"]
	pub fn flipper_format_key_exist(flipper_format: *mut FlipperFormat, key: *const core::ffi::c_char) -> bool;
}
extern "C" {
	#[doc = " Read the header (file type and version)."]
	#[doc = " @param flipper_format Pointer to a FlipperFormat instance"]
	#[doc = " @param filetype File type string"]
	#[doc = " @param version Version Value"]
	#[doc = " @return True on success"]
	pub fn flipper_format_read_header(flipper_format: *mut FlipperFormat, filetype: *mut string_t, version: *mut u32) -> bool;
}
extern "C" {
	#[doc = " Write the header (file type and version)."]
	#[doc = " @param flipper_format Pointer to a FlipperFormat instance"]
	#[doc = " @param filetype File type string"]
	#[doc = " @param version Version Value"]
	#[doc = " @return True on success"]
	pub fn flipper_format_write_header(flipper_format: *mut FlipperFormat, filetype: *mut string_t, version: u32) -> bool;
}
extern "C" {
	#[doc = " Write the header (file type and version). Plain C string version."]
	#[doc = " @param flipper_format Pointer to a FlipperFormat instance"]
	#[doc = " @param filetype File type string"]
	#[doc = " @param version Version Value"]
	#[doc = " @return True on success"]
	pub fn flipper_format_write_header_cstr(flipper_format: *mut FlipperFormat,
	                                        filetype: *const core::ffi::c_char,
	                                        version: u32)
	                                        -> bool;
}
extern "C" {
	#[doc = " Get the count of values by key"]
	#[doc = " @param flipper_format Pointer to a FlipperFormat instance"]
	#[doc = " @param key"]
	#[doc = " @param count"]
	#[doc = " @return bool"]
	pub fn flipper_format_get_value_count(flipper_format: *mut FlipperFormat, key: *const core::ffi::c_char, count: *mut u32) -> bool;
}
extern "C" {
	#[doc = " Read a string by key"]
	#[doc = " @param flipper_format Pointer to a FlipperFormat instance"]
	#[doc = " @param key Key"]
	#[doc = " @param data Value"]
	#[doc = " @return True on success"]
	pub fn flipper_format_read_string(flipper_format: *mut FlipperFormat, key: *const core::ffi::c_char, data: *mut string_t) -> bool;
}
extern "C" {
	#[doc = " Write key and string"]
	#[doc = " @param flipper_format Pointer to a FlipperFormat instance"]
	#[doc = " @param key Key"]
	#[doc = " @param data Value"]
	#[doc = " @return True on success"]
	pub fn flipper_format_write_string(flipper_format: *mut FlipperFormat, key: *const core::ffi::c_char, data: *mut string_t)
	                                   -> bool;
}
extern "C" {
	#[doc = " Write key and string. Plain C string version."]
	#[doc = " @param flipper_format Pointer to a FlipperFormat instance"]
	#[doc = " @param key Key"]
	#[doc = " @param data Value"]
	#[doc = " @return True on success"]
	pub fn flipper_format_write_string_cstr(flipper_format: *mut FlipperFormat,
	                                        key: *const core::ffi::c_char,
	                                        data: *const core::ffi::c_char)
	                                        -> bool;
}
extern "C" {
	#[doc = " Read array of uint64 in hex format by key"]
	#[doc = " @param flipper_format Pointer to a FlipperFormat instance"]
	#[doc = " @param key Key"]
	#[doc = " @param data Value"]
	#[doc = " @param data_size Values count"]
	#[doc = " @return True on success"]
	pub fn flipper_format_read_hex_uint64(flipper_format: *mut FlipperFormat,
	                                      key: *const core::ffi::c_char,
	                                      data: *mut u64,
	                                      data_size: u16)
	                                      -> bool;
}
extern "C" {
	#[doc = " Write key and array of uint64 in hex format"]
	#[doc = " @param flipper_format Pointer to a FlipperFormat instance"]
	#[doc = " @param key Key"]
	#[doc = " @param data Value"]
	#[doc = " @param data_size Values count"]
	#[doc = " @return True on success"]
	pub fn flipper_format_write_hex_uint64(flipper_format: *mut FlipperFormat,
	                                       key: *const core::ffi::c_char,
	                                       data: *const u64,
	                                       data_size: u16)
	                                       -> bool;
}
extern "C" {
	#[doc = " Read array of uint32 by key"]
	#[doc = " @param flipper_format Pointer to a FlipperFormat instance"]
	#[doc = " @param key Key"]
	#[doc = " @param data Value"]
	#[doc = " @param data_size Values count"]
	#[doc = " @return True on success"]
	pub fn flipper_format_read_uint32(flipper_format: *mut FlipperFormat,
	                                  key: *const core::ffi::c_char,
	                                  data: *mut u32,
	                                  data_size: u16)
	                                  -> bool;
}
extern "C" {
	#[doc = " Write key and array of uint32"]
	#[doc = " @param flipper_format Pointer to a FlipperFormat instance"]
	#[doc = " @param key Key"]
	#[doc = " @param data Value"]
	#[doc = " @param data_size Values count"]
	#[doc = " @return True on success"]
	pub fn flipper_format_write_uint32(flipper_format: *mut FlipperFormat,
	                                   key: *const core::ffi::c_char,
	                                   data: *const u32,
	                                   data_size: u16)
	                                   -> bool;
}
extern "C" {
	#[doc = " Read array of int32 by key"]
	#[doc = " @param flipper_format Pointer to a FlipperFormat instance"]
	#[doc = " @param key Key"]
	#[doc = " @param data Value"]
	#[doc = " @param data_size Values count"]
	#[doc = " @return True on success"]
	pub fn flipper_format_read_int32(flipper_format: *mut FlipperFormat,
	                                 key: *const core::ffi::c_char,
	                                 data: *mut i32,
	                                 data_size: u16)
	                                 -> bool;
}
extern "C" {
	#[doc = " Write key and array of int32"]
	#[doc = " @param flipper_format Pointer to a FlipperFormat instance"]
	#[doc = " @param key Key"]
	#[doc = " @param data Value"]
	#[doc = " @param data_size Values count"]
	#[doc = " @return True on success"]
	pub fn flipper_format_write_int32(flipper_format: *mut FlipperFormat,
	                                  key: *const core::ffi::c_char,
	                                  data: *const i32,
	                                  data_size: u16)
	                                  -> bool;
}
extern "C" {
	#[doc = " Read array of bool by key"]
	#[doc = " @param flipper_format Pointer to a FlipperFormat instance"]
	#[doc = " @param key Key"]
	#[doc = " @param data Value"]
	#[doc = " @param data_size Values count"]
	#[doc = " @return True on success"]
	pub fn flipper_format_read_bool(flipper_format: *mut FlipperFormat,
	                                key: *const core::ffi::c_char,
	                                data: *mut bool,
	                                data_size: u16)
	                                -> bool;
}
extern "C" {
	#[doc = " Write key and array of bool"]
	#[doc = " @param flipper_format Pointer to a FlipperFormat instance"]
	#[doc = " @param key Key"]
	#[doc = " @param data Value"]
	#[doc = " @param data_size Values count"]
	#[doc = " @return True on success"]
	pub fn flipper_format_write_bool(flipper_format: *mut FlipperFormat,
	                                 key: *const core::ffi::c_char,
	                                 data: *const bool,
	                                 data_size: u16)
	                                 -> bool;
}
extern "C" {
	#[doc = " Read array of float by key"]
	#[doc = " @param flipper_format Pointer to a FlipperFormat instance"]
	#[doc = " @param key Key"]
	#[doc = " @param data Value"]
	#[doc = " @param data_size Values count"]
	#[doc = " @return True on success"]
	pub fn flipper_format_read_float(flipper_format: *mut FlipperFormat,
	                                 key: *const core::ffi::c_char,
	                                 data: *mut core::ffi::c_float,
	                                 data_size: u16)
	                                 -> bool;
}
extern "C" {
	#[doc = " Write key and array of float"]
	#[doc = " @param flipper_format Pointer to a FlipperFormat instance"]
	#[doc = " @param key Key"]
	#[doc = " @param data Value"]
	#[doc = " @param data_size Values count"]
	#[doc = " @return True on success"]
	pub fn flipper_format_write_float(flipper_format: *mut FlipperFormat,
	                                  key: *const core::ffi::c_char,
	                                  data: *const core::ffi::c_float,
	                                  data_size: u16)
	                                  -> bool;
}
extern "C" {
	#[doc = " Read array of hex-formatted bytes by key"]
	#[doc = " @param flipper_format Pointer to a FlipperFormat instance"]
	#[doc = " @param key Key"]
	#[doc = " @param data Value"]
	#[doc = " @param data_size Values count"]
	#[doc = " @return True on success"]
	pub fn flipper_format_read_hex(flipper_format: *mut FlipperFormat,
	                               key: *const core::ffi::c_char,
	                               data: *mut u8,
	                               data_size: u16)
	                               -> bool;
}
extern "C" {
	#[doc = " Write key and array of hex-formatted bytes"]
	#[doc = " @param flipper_format Pointer to a FlipperFormat instance"]
	#[doc = " @param key Key"]
	#[doc = " @param data Value"]
	#[doc = " @param data_size Values count"]
	#[doc = " @return True on success"]
	pub fn flipper_format_write_hex(flipper_format: *mut FlipperFormat,
	                                key: *const core::ffi::c_char,
	                                data: *const u8,
	                                data_size: u16)
	                                -> bool;
}
extern "C" {
	#[doc = " Write comment"]
	#[doc = " @param flipper_format Pointer to a FlipperFormat instance"]
	#[doc = " @param data Comment text"]
	#[doc = " @return True on success"]
	pub fn flipper_format_write_comment(flipper_format: *mut FlipperFormat, data: *mut string_t) -> bool;
}
extern "C" {
	#[doc = " Write comment. Plain C string version."]
	#[doc = " @param flipper_format Pointer to a FlipperFormat instance"]
	#[doc = " @param data Comment text"]
	#[doc = " @return True on success"]
	pub fn flipper_format_write_comment_cstr(flipper_format: *mut FlipperFormat, data: *const core::ffi::c_char) -> bool;
}
extern "C" {
	#[doc = " Removes the first matching key and its value. Sets the RW pointer to a position of deleted data."]
	#[doc = " @param flipper_format Pointer to a FlipperFormat instance"]
	#[doc = " @param key Key"]
	#[doc = " @return True on success"]
	pub fn flipper_format_delete_key(flipper_format: *mut FlipperFormat, key: *const core::ffi::c_char) -> bool;
}
extern "C" {
	#[doc = " Updates the value of the first matching key to a string value. Sets the RW pointer to a position at the end of inserted data."]
	#[doc = " @param flipper_format Pointer to a FlipperFormat instance"]
	#[doc = " @param key Key"]
	#[doc = " @param data Value"]
	#[doc = " @return True on success"]
	pub fn flipper_format_update_string(flipper_format: *mut FlipperFormat,
	                                    key: *const core::ffi::c_char,
	                                    data: *mut string_t)
	                                    -> bool;
}
extern "C" {
	#[doc = " Updates the value of the first matching key to a string value. Plain C version. Sets the RW pointer to a position at the end of inserted data."]
	#[doc = " @param flipper_format Pointer to a FlipperFormat instance"]
	#[doc = " @param key Key"]
	#[doc = " @param data Value"]
	#[doc = " @return True on success"]
	pub fn flipper_format_update_string_cstr(flipper_format: *mut FlipperFormat,
	                                         key: *const core::ffi::c_char,
	                                         data: *const core::ffi::c_char)
	                                         -> bool;
}
extern "C" {
	#[doc = " Updates the value of the first matching key to a uint32 array value. Sets the RW pointer to a position at the end of inserted data."]
	#[doc = " @param flipper_format Pointer to a FlipperFormat instance"]
	#[doc = " @param key Key"]
	#[doc = " @param data Value"]
	#[doc = " @return True on success"]
	pub fn flipper_format_update_uint32(flipper_format: *mut FlipperFormat,
	                                    key: *const core::ffi::c_char,
	                                    data: *const u32,
	                                    data_size: u16)
	                                    -> bool;
}
extern "C" {
	#[doc = " Updates the value of the first matching key to a int32 array value. Sets the RW pointer to a position at the end of inserted data."]
	#[doc = " @param flipper_format Pointer to a FlipperFormat instance"]
	#[doc = " @param key Key"]
	#[doc = " @param data Value"]
	#[doc = " @return True on success"]
	pub fn flipper_format_update_int32(flipper_format: *mut FlipperFormat,
	                                   key: *const core::ffi::c_char,
	                                   data: *const i32,
	                                   data_size: u16)
	                                   -> bool;
}
extern "C" {
	#[doc = " Updates the value of the first matching key to a bool array value. Sets the RW pointer to a position at the end of inserted data."]
	#[doc = " @param flipper_format Pointer to a FlipperFormat instance"]
	#[doc = " @param key Key"]
	#[doc = " @param data Value"]
	#[doc = " @return True on success"]
	pub fn flipper_format_update_bool(flipper_format: *mut FlipperFormat,
	                                  key: *const core::ffi::c_char,
	                                  data: *const bool,
	                                  data_size: u16)
	                                  -> bool;
}
extern "C" {
	#[doc = " Updates the value of the first matching key to a float array value. Sets the RW pointer to a position at the end of inserted data."]
	#[doc = " @param flipper_format Pointer to a FlipperFormat instance"]
	#[doc = " @param key Key"]
	#[doc = " @param data Value"]
	#[doc = " @return True on success"]
	pub fn flipper_format_update_float(flipper_format: *mut FlipperFormat,
	                                   key: *const core::ffi::c_char,
	                                   data: *const core::ffi::c_float,
	                                   data_size: u16)
	                                   -> bool;
}
extern "C" {
	#[doc = " Updates the value of the first matching key to an array of hex-formatted bytes. Sets the RW pointer to a position at the end of inserted data."]
	#[doc = " @param flipper_format Pointer to a FlipperFormat instance"]
	#[doc = " @param key Key"]
	#[doc = " @param data Value"]
	#[doc = " @return True on success"]
	pub fn flipper_format_update_hex(flipper_format: *mut FlipperFormat,
	                                 key: *const core::ffi::c_char,
	                                 data: *const u8,
	                                 data_size: u16)
	                                 -> bool;
}
extern "C" {
	#[doc = " Updates the value of the first matching key to a string value, or adds the key and value if the key did not exist."]
	#[doc = " Sets the RW pointer to a position at the end of inserted data."]
	#[doc = " @param flipper_format Pointer to a FlipperFormat instance"]
	#[doc = " @param key Key"]
	#[doc = " @param data Value"]
	#[doc = " @return True on success"]
	pub fn flipper_format_insert_or_update_string(flipper_format: *mut FlipperFormat,
	                                              key: *const core::ffi::c_char,
	                                              data: *mut string_t)
	                                              -> bool;
}
extern "C" {
	#[doc = " Updates the value of the first matching key to a string value, or adds the key and value if the key did not exist."]
	#[doc = " Plain C version."]
	#[doc = " Sets the RW pointer to a position at the end of inserted data."]
	#[doc = " @param flipper_format Pointer to a FlipperFormat instance"]
	#[doc = " @param key Key"]
	#[doc = " @param data Value"]
	#[doc = " @return True on success"]
	pub fn flipper_format_insert_or_update_string_cstr(flipper_format: *mut FlipperFormat,
	                                                   key: *const core::ffi::c_char,
	                                                   data: *const core::ffi::c_char)
	                                                   -> bool;
}
extern "C" {
	#[doc = " Updates the value of the first matching key to a uint32 array value, or adds the key and value if the key did not exist."]
	#[doc = "  Sets the RW pointer to a position at the end of inserted data."]
	#[doc = " @param flipper_format Pointer to a FlipperFormat instance"]
	#[doc = " @param key Key"]
	#[doc = " @param data Value"]
	#[doc = " @return True on success"]
	pub fn flipper_format_insert_or_update_uint32(flipper_format: *mut FlipperFormat,
	                                              key: *const core::ffi::c_char,
	                                              data: *const u32,
	                                              data_size: u16)
	                                              -> bool;
}
extern "C" {
	#[doc = " Updates the value of the first matching key to a int32 array value, or adds the key and value if the key did not exist."]
	#[doc = " Sets the RW pointer to a position at the end of inserted data."]
	#[doc = " @param flipper_format Pointer to a FlipperFormat instance"]
	#[doc = " @param key Key"]
	#[doc = " @param data Value"]
	#[doc = " @return True on success"]
	pub fn flipper_format_insert_or_update_int32(flipper_format: *mut FlipperFormat,
	                                             key: *const core::ffi::c_char,
	                                             data: *const i32,
	                                             data_size: u16)
	                                             -> bool;
}
extern "C" {
	#[doc = " Updates the value of the first matching key to a bool array value, or adds the key and value if the key did not exist."]
	#[doc = " Sets the RW pointer to a position at the end of inserted data."]
	#[doc = " @param flipper_format Pointer to a FlipperFormat instance"]
	#[doc = " @param key Key"]
	#[doc = " @param data Value"]
	#[doc = " @return True on success"]
	pub fn flipper_format_insert_or_update_bool(flipper_format: *mut FlipperFormat,
	                                            key: *const core::ffi::c_char,
	                                            data: *const bool,
	                                            data_size: u16)
	                                            -> bool;
}
extern "C" {
	#[doc = " Updates the value of the first matching key to a float array value, or adds the key and value if the key did not exist."]
	#[doc = " Sets the RW pointer to a position at the end of inserted data."]
	#[doc = " @param flipper_format Pointer to a FlipperFormat instance"]
	#[doc = " @param key Key"]
	#[doc = " @param data Value"]
	#[doc = " @return True on success"]
	pub fn flipper_format_insert_or_update_float(flipper_format: *mut FlipperFormat,
	                                             key: *const core::ffi::c_char,
	                                             data: *const core::ffi::c_float,
	                                             data_size: u16)
	                                             -> bool;
}
extern "C" {
	#[doc = " Updates the value of the first matching key to an array of hex-formatted bytes, or adds the key and value if the key did not exist."]
	#[doc = "Sets the RW pointer to a position at the end of inserted data."]
	#[doc = " @param flipper_format Pointer to a FlipperFormat instance"]
	#[doc = " @param key Key"]
	#[doc = " @param data Value"]
	#[doc = " @return True on success"]
	pub fn flipper_format_insert_or_update_hex(flipper_format: *mut FlipperFormat,
	                                           key: *const core::ffi::c_char,
	                                           data: *const u8,
	                                           data_size: u16)
	                                           -> bool;
}
#[repr(C)]
pub struct Stream {
	_unused: [u8; 0],
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum StreamOffset {
	StreamOffsetFromCurrent = 0,
	StreamOffsetFromStart = 1,
	StreamOffsetFromEnd = 2,
}
pub type StreamWriteCB = ::core::option::Option<unsafe extern "C" fn(stream: *mut Stream, context: *const core::ffi::c_void) -> bool>;
extern "C" {
	#[doc = " Free Stream"]
	#[doc = " @param stream Stream instance"]
	pub fn stream_free(stream: *mut Stream);
}
extern "C" {
	#[doc = " Clean (empty) Stream"]
	#[doc = " @param stream Stream instance"]
	pub fn stream_clean(stream: *mut Stream);
}
extern "C" {
	#[doc = " Indicates that the rw pointer is at the end of the stream"]
	#[doc = " @param stream Stream instance"]
	#[doc = " @return true if rw pointer is at the end of the stream"]
	#[doc = " @return false if rw pointer is not at the end of the stream"]
	pub fn stream_eof(stream: *mut Stream) -> bool;
}
extern "C" {
	#[doc = " Moves the rw pointer."]
	#[doc = " @param stream Stream instance"]
	#[doc = " @param offset how much to move the pointer"]
	#[doc = " @param offset_type starting from what"]
	#[doc = " @return true"]
	#[doc = " @return false"]
	pub fn stream_seek(stream: *mut Stream, offset: i32, offset_type: StreamOffset) -> bool;
}
extern "C" {
	#[doc = " Gets the value of the rw pointer"]
	#[doc = " @param stream Stream instance"]
	#[doc = " @return size_t value of the rw pointer"]
	pub fn stream_tell(stream: *mut Stream) -> usize;
}
extern "C" {
	#[doc = " Gets the size of the stream"]
	#[doc = " @param stream Stream instance"]
	#[doc = " @return size_t size of the stream"]
	pub fn stream_size(stream: *mut Stream) -> usize;
}
extern "C" {
	#[doc = " Write N bytes to the stream"]
	#[doc = " @param stream Stream instance"]
	#[doc = " @param data data to write"]
	#[doc = " @param size size of data to be written"]
	#[doc = " @return size_t how many bytes was written"]
	pub fn stream_write(stream: *mut Stream, data: *const u8, size: usize) -> usize;
}
extern "C" {
	#[doc = " Read N bytes from stream"]
	#[doc = " @param stream Stream instance"]
	#[doc = " @param data data to be read"]
	#[doc = " @param count size of data to be read"]
	#[doc = " @return size_t how many bytes was read"]
	pub fn stream_read(stream: *mut Stream, data: *mut u8, count: usize) -> usize;
}
extern "C" {
	#[doc = " Delete N chars from the stream and write data by calling write_callback(context)"]
	#[doc = " @param stream Stream instance"]
	#[doc = " @param delete_size size of data to be deleted"]
	#[doc = " @param write_callback write callback"]
	#[doc = " @param context write callback context"]
	#[doc = " @return true if the operation was successful"]
	#[doc = " @return false on error"]
	pub fn stream_delete_and_insert(stream: *mut Stream,
	                                delete_size: usize,
	                                write_callback: StreamWriteCB,
	                                context: *const core::ffi::c_void)
	                                -> bool;
}
extern "C" {
	#[doc = " Read line from a stream (supports LF and CRLF line endings)"]
	#[doc = " @param stream"]
	#[doc = " @param str_result"]
	#[doc = " @return true if line lenght is not zero"]
	#[doc = " @return false otherwise"]
	pub fn stream_read_line(stream: *mut Stream, str_result: *mut string_t) -> bool;
}
extern "C" {
	#[doc = " Moves the rw pointer to the start"]
	#[doc = " @param stream Stream instance"]
	pub fn stream_rewind(stream: *mut Stream) -> bool;
}
extern "C" {
	#[doc = " Write char to the stream"]
	#[doc = " @param stream Stream instance"]
	#[doc = " @param c char value"]
	#[doc = " @return size_t how many bytes was written"]
	pub fn stream_write_char(stream: *mut Stream, c: core::ffi::c_char) -> usize;
}
extern "C" {
	#[doc = " Write string to the stream"]
	#[doc = " @param stream Stream instance"]
	#[doc = " @param string string value"]
	#[doc = " @return size_t how many bytes was written"]
	pub fn stream_write_string(stream: *mut Stream, string: *mut string_t) -> usize;
}
extern "C" {
	#[doc = " Write const char* to the stream"]
	#[doc = " @param stream Stream instance"]
	#[doc = " @param string c-string value"]
	#[doc = " @return size_t how many bytes was written"]
	pub fn stream_write_cstring(stream: *mut Stream, string: *const core::ffi::c_char) -> usize;
}
extern "C" {
	#[doc = " Write formatted string to the stream"]
	#[doc = " @param stream Stream instance"]
	#[doc = " @param format"]
	#[doc = " @param ..."]
	#[doc = " @return size_t how many bytes was written"]
	pub fn stream_write_format(stream: *mut Stream, format: *const core::ffi::c_char, ...) -> usize;
}
extern "C" {
	#[doc = " Write formatted string to the stream, va_list version"]
	#[doc = " @param stream Stream instance"]
	#[doc = " @param format"]
	#[doc = " @param args"]
	#[doc = " @return size_t how many bytes was written"]
	pub fn stream_write_vaformat(stream: *mut Stream, format: *const core::ffi::c_char, args: va_list) -> usize;
}
extern "C" {
	#[doc = " Insert N chars to the stream, starting at the current pointer."]
	#[doc = " Data will be inserted, not overwritte, so the stream will be increased in size."]
	#[doc = " @param stream Stream instance"]
	#[doc = " @param data data to be inserted"]
	#[doc = " @param size size of data to be inserted"]
	#[doc = " @return true if the operation was successful"]
	#[doc = " @return false on error"]
	pub fn stream_insert(stream: *mut Stream, data: *const u8, size: usize) -> bool;
}
extern "C" {
	#[doc = " Insert char to the stream"]
	#[doc = " @param stream Stream instance"]
	#[doc = " @param c char value"]
	#[doc = " @return true if the operation was successful"]
	#[doc = " @return false on error"]
	pub fn stream_insert_char(stream: *mut Stream, c: core::ffi::c_char) -> bool;
}
extern "C" {
	#[doc = " Insert string to the stream"]
	#[doc = " @param stream Stream instance"]
	#[doc = " @param string string value"]
	#[doc = " @return true if the operation was successful"]
	#[doc = " @return false on error"]
	pub fn stream_insert_string(stream: *mut Stream, string: *mut string_t) -> bool;
}
extern "C" {
	#[doc = " Insert const char* to the stream"]
	#[doc = " @param stream Stream instance"]
	#[doc = " @param string c-string value"]
	#[doc = " @return true if the operation was successful"]
	#[doc = " @return false on error"]
	pub fn stream_insert_cstring(stream: *mut Stream, string: *const core::ffi::c_char) -> bool;
}
extern "C" {
	#[doc = " Insert formatted string to the stream"]
	#[doc = " @param stream Stream instance"]
	#[doc = " @param format"]
	#[doc = " @param ..."]
	#[doc = " @return true if the operation was successful"]
	#[doc = " @return false on error"]
	pub fn stream_insert_format(stream: *mut Stream, format: *const core::ffi::c_char, ...) -> bool;
}
extern "C" {
	#[doc = " Insert formatted string to the stream, va_list version"]
	#[doc = " @param stream Stream instance"]
	#[doc = " @param format"]
	#[doc = " @param args"]
	#[doc = " @return true if the operation was successful"]
	#[doc = " @return false on error"]
	pub fn stream_insert_vaformat(stream: *mut Stream, format: *const core::ffi::c_char, args: va_list) -> bool;
}
extern "C" {
	#[doc = " Delete N chars from the stream and insert char to the stream"]
	#[doc = " @param stream Stream instance"]
	#[doc = " @param delete_size size of data to be deleted"]
	#[doc = " @param c char value"]
	#[doc = " @return true if the operation was successful"]
	#[doc = " @return false on error"]
	pub fn stream_delete_and_insert_char(stream: *mut Stream, delete_size: usize, c: core::ffi::c_char) -> bool;
}
extern "C" {
	#[doc = " Delete N chars from the stream and insert string to the stream"]
	#[doc = " @param stream Stream instance"]
	#[doc = " @param delete_size size of data to be deleted"]
	#[doc = " @param string string value"]
	#[doc = " @return true if the operation was successful"]
	#[doc = " @return false on error"]
	pub fn stream_delete_and_insert_string(stream: *mut Stream, delete_size: usize, string: *mut string_t) -> bool;
}
extern "C" {
	#[doc = " Delete N chars from the stream and insert const char* to the stream"]
	#[doc = " @param stream Stream instance"]
	#[doc = " @param delete_size size of data to be deleted"]
	#[doc = " @param string c-string value"]
	#[doc = " @return true if the operation was successful"]
	#[doc = " @return false on error"]
	pub fn stream_delete_and_insert_cstring(stream: *mut Stream, delete_size: usize, string: *const core::ffi::c_char) -> bool;
}
extern "C" {
	#[doc = " Delete N chars from the stream and insert formatted string to the stream"]
	#[doc = " @param stream Stream instance"]
	#[doc = " @param delete_size size of data to be deleted"]
	#[doc = " @param format"]
	#[doc = " @param ..."]
	#[doc = " @return true if the operation was successful"]
	#[doc = " @return false on error"]
	pub fn stream_delete_and_insert_format(stream: *mut Stream, delete_size: usize, format: *const core::ffi::c_char, ...) -> bool;
}
extern "C" {
	#[doc = " Delete N chars from the stream and insert formatted string to the stream, va_list version"]
	#[doc = " @param stream Stream instance"]
	#[doc = " @param delete_size size of data to be deleted"]
	#[doc = " @param format"]
	#[doc = " @param args"]
	#[doc = " @return true if the operation was successful"]
	#[doc = " @return false on error"]
	pub fn stream_delete_and_insert_vaformat(stream: *mut Stream,
	                                         delete_size: usize,
	                                         format: *const core::ffi::c_char,
	                                         args: va_list)
	                                         -> bool;
}
extern "C" {
	#[doc = " Remove N chars from the stream, starting at the current pointer."]
	#[doc = " The size may be larger than stream size, the stream will be cleared from current rw pointer to the end."]
	#[doc = " @param stream Stream instance"]
	#[doc = " @param size how many chars need to be deleted"]
	#[doc = " @return true if the operation was successful"]
	#[doc = " @return false on error"]
	pub fn stream_delete(stream: *mut Stream, size: usize) -> bool;
}
extern "C" {
	#[doc = " Copy data from one stream to another. Data will be copied from current rw pointer and to current rw pointer."]
	#[doc = " @param stream_from"]
	#[doc = " @param stream_to"]
	#[doc = " @param size"]
	#[doc = " @return size_t"]
	pub fn stream_copy(stream_from: *mut Stream, stream_to: *mut Stream, size: usize) -> usize;
}
extern "C" {
	#[doc = " Copy data from one stream to another. Data will be copied from start of one stream and to start of other stream."]
	#[doc = " @param stream_from"]
	#[doc = " @param stream_to"]
	#[doc = " @return size_t"]
	pub fn stream_copy_full(stream_from: *mut Stream, stream_to: *mut Stream) -> usize;
}
extern "C" {
	#[doc = " Splits one stream into two others. The original stream will remain untouched."]
	#[doc = " @param stream"]
	#[doc = " @param stream_left"]
	#[doc = " @param stream_right"]
	#[doc = " @return true"]
	#[doc = " @return false"]
	pub fn stream_split(stream: *mut Stream, stream_left: *mut Stream, stream_right: *mut Stream) -> bool;
}
extern "C" {
	#[doc = " Loads data to the stream from a file. Data will be loaded to the current RW pointer. RW pointer will be moved to the end of the stream."]
	#[doc = " @param stream Stream instance"]
	#[doc = " @param storage"]
	#[doc = " @param path"]
	#[doc = " @return size_t"]
	pub fn stream_load_from_file(stream: *mut Stream, storage: *mut Storage, path: *const core::ffi::c_char) -> usize;
}
extern "C" {
	#[doc = " Writes data from a stream to a file. Data will be saved starting from the current RW pointer. RW pointer will be moved to the end of the stream."]
	#[doc = " @param stream Stream instance"]
	#[doc = " @param storage"]
	#[doc = " @param path"]
	#[doc = " @param mode"]
	#[doc = " @return size_t"]
	pub fn stream_save_to_file(stream: *mut Stream, storage: *mut Storage, path: *const core::ffi::c_char, mode: FS_OpenMode)
	                           -> usize;
}
extern "C" {
	#[doc = " Dump stream inner data (size, RW positiot, content)"]
	#[doc = " @param stream Stream instance"]
	pub fn stream_dump_data(stream: *mut Stream);
}
extern "C" {
	#[doc = " Returns the underlying stream instance."]
	#[doc = " Use only if you know what you are doing."]
	#[doc = " @param flipper_format"]
	#[doc = " @return Stream*"]
	pub fn flipper_format_get_raw_stream(flipper_format: *mut FlipperFormat) -> *mut Stream;
}
pub type ProtocolAlloc = ::core::option::Option<unsafe extern "C" fn() -> *mut core::ffi::c_void>;
pub type ProtocolFree = ::core::option::Option<unsafe extern "C" fn(protocol: *mut core::ffi::c_void)>;
pub type ProtocolGetData = ::core::option::Option<unsafe extern "C" fn(protocol: *mut core::ffi::c_void) -> *mut u8>;
pub type ProtocolDecoderStart = ::core::option::Option<unsafe extern "C" fn(protocol: *mut core::ffi::c_void)>;
pub type ProtocolDecoderFeed =
	::core::option::Option<unsafe extern "C" fn(protocol: *mut core::ffi::c_void, level: bool, duration: u32) -> bool>;
pub type ProtocolEncoderStart = ::core::option::Option<unsafe extern "C" fn(protocol: *mut core::ffi::c_void) -> bool>;
pub type ProtocolEncoderYield = ::core::option::Option<unsafe extern "C" fn(protocol: *mut core::ffi::c_void) -> LevelDuration>;
pub type ProtocolRenderData = ::core::option::Option<unsafe extern "C" fn(protocol: *mut core::ffi::c_void, result: *mut string_t)>;
pub type ProtocolWriteData =
	::core::option::Option<unsafe extern "C" fn(protocol: *mut core::ffi::c_void, data: *mut core::ffi::c_void) -> bool>;
#[repr(C)]
pub struct ProtocolDecoder {
	pub start: ProtocolDecoderStart,
	pub feed: ProtocolDecoderFeed,
}
#[test]
fn bindgen_test_layout_ProtocolDecoder() {
	assert_eq!(
	           ::core::mem::size_of::<ProtocolDecoder>(),
	           8usize,
	           concat!("Size of: ", stringify!(ProtocolDecoder))
	);
	assert_eq!(
	           ::core::mem::align_of::<ProtocolDecoder>(),
	           4usize,
	           concat!("Alignment of ", stringify!(ProtocolDecoder))
	);
	fn test_field_start() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<ProtocolDecoder>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).start) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(ProtocolDecoder), "::", stringify!(start))
		);
	}
	test_field_start();
	fn test_field_feed() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<ProtocolDecoder>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).feed) as usize - ptr as usize
		           },
		           4usize,
		           concat!("Offset of field: ", stringify!(ProtocolDecoder), "::", stringify!(feed))
		);
	}
	test_field_feed();
}
#[repr(C)]
pub struct ProtocolEncoder {
	pub start: ProtocolEncoderStart,
	pub yield_: ProtocolEncoderYield,
}
#[test]
fn bindgen_test_layout_ProtocolEncoder() {
	assert_eq!(
	           ::core::mem::size_of::<ProtocolEncoder>(),
	           8usize,
	           concat!("Size of: ", stringify!(ProtocolEncoder))
	);
	assert_eq!(
	           ::core::mem::align_of::<ProtocolEncoder>(),
	           4usize,
	           concat!("Alignment of ", stringify!(ProtocolEncoder))
	);
	fn test_field_start() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<ProtocolEncoder>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).start) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(ProtocolEncoder), "::", stringify!(start))
		);
	}
	test_field_start();
	fn test_field_yield() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<ProtocolEncoder>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).yield_) as usize - ptr as usize
		           },
		           4usize,
		           concat!("Offset of field: ", stringify!(ProtocolEncoder), "::", stringify!(yield_))
		);
	}
	test_field_yield();
}
#[repr(C)]
pub struct ProtocolBase {
	pub data_size: usize,
	pub name: *const core::ffi::c_char,
	pub manufacturer: *const core::ffi::c_char,
	pub features: u32,
	pub validate_count: u8,
	pub alloc: ProtocolAlloc,
	pub free: ProtocolFree,
	pub get_data: ProtocolGetData,
	pub decoder: ProtocolDecoder,
	pub encoder: ProtocolEncoder,
	pub render_data: ProtocolRenderData,
	pub render_brief_data: ProtocolRenderData,
	pub write_data: ProtocolWriteData,
}
#[test]
fn bindgen_test_layout_ProtocolBase() {
	assert_eq!(
	           ::core::mem::size_of::<ProtocolBase>(),
	           60usize,
	           concat!("Size of: ", stringify!(ProtocolBase))
	);
	assert_eq!(
	           ::core::mem::align_of::<ProtocolBase>(),
	           4usize,
	           concat!("Alignment of ", stringify!(ProtocolBase))
	);
	fn test_field_data_size() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<ProtocolBase>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).data_size) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(ProtocolBase), "::", stringify!(data_size))
		);
	}
	test_field_data_size();
	fn test_field_name() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<ProtocolBase>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).name) as usize - ptr as usize
		           },
		           4usize,
		           concat!("Offset of field: ", stringify!(ProtocolBase), "::", stringify!(name))
		);
	}
	test_field_name();
	fn test_field_manufacturer() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<ProtocolBase>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).manufacturer) as usize - ptr as usize
		           },
		           8usize,
		           concat!("Offset of field: ", stringify!(ProtocolBase), "::", stringify!(manufacturer))
		);
	}
	test_field_manufacturer();
	fn test_field_features() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<ProtocolBase>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).features) as usize - ptr as usize
		           },
		           12usize,
		           concat!("Offset of field: ", stringify!(ProtocolBase), "::", stringify!(features))
		);
	}
	test_field_features();
	fn test_field_validate_count() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<ProtocolBase>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).validate_count) as usize - ptr as usize
		           },
		           16usize,
		           concat!(
			"Offset of field: ",
			stringify!(ProtocolBase),
			"::",
			stringify!(validate_count)
		)
		);
	}
	test_field_validate_count();
	fn test_field_alloc() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<ProtocolBase>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).alloc) as usize - ptr as usize
		           },
		           20usize,
		           concat!("Offset of field: ", stringify!(ProtocolBase), "::", stringify!(alloc))
		);
	}
	test_field_alloc();
	fn test_field_free() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<ProtocolBase>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).free) as usize - ptr as usize
		           },
		           24usize,
		           concat!("Offset of field: ", stringify!(ProtocolBase), "::", stringify!(free))
		);
	}
	test_field_free();
	fn test_field_get_data() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<ProtocolBase>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).get_data) as usize - ptr as usize
		           },
		           28usize,
		           concat!("Offset of field: ", stringify!(ProtocolBase), "::", stringify!(get_data))
		);
	}
	test_field_get_data();
	fn test_field_decoder() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<ProtocolBase>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).decoder) as usize - ptr as usize
		           },
		           32usize,
		           concat!("Offset of field: ", stringify!(ProtocolBase), "::", stringify!(decoder))
		);
	}
	test_field_decoder();
	fn test_field_encoder() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<ProtocolBase>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).encoder) as usize - ptr as usize
		           },
		           40usize,
		           concat!("Offset of field: ", stringify!(ProtocolBase), "::", stringify!(encoder))
		);
	}
	test_field_encoder();
	fn test_field_render_data() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<ProtocolBase>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).render_data) as usize - ptr as usize
		           },
		           48usize,
		           concat!("Offset of field: ", stringify!(ProtocolBase), "::", stringify!(render_data))
		);
	}
	test_field_render_data();
	fn test_field_render_brief_data() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<ProtocolBase>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).render_brief_data) as usize - ptr as usize
		           },
		           52usize,
		           concat!(
			"Offset of field: ",
			stringify!(ProtocolBase),
			"::",
			stringify!(render_brief_data)
		)
		);
	}
	test_field_render_brief_data();
	fn test_field_write_data() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<ProtocolBase>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).write_data) as usize - ptr as usize
		           },
		           56usize,
		           concat!("Offset of field: ", stringify!(ProtocolBase), "::", stringify!(write_data))
		);
	}
	test_field_write_data();
}
#[repr(C)]
pub struct ProtocolDict {
	_unused: [u8; 0],
}
pub type ProtocolId = i32;
extern "C" {
	pub fn protocol_dict_alloc(protocols: *mut *const ProtocolBase, protocol_count: usize) -> *mut ProtocolDict;
}
extern "C" {
	pub fn protocol_dict_free(dict: *mut ProtocolDict);
}
extern "C" {
	pub fn protocol_dict_set_data(dict: *mut ProtocolDict, protocol_index: usize, data: *const u8, data_size: usize);
}
extern "C" {
	pub fn protocol_dict_get_data(dict: *mut ProtocolDict, protocol_index: usize, data: *mut u8, data_size: usize);
}
extern "C" {
	pub fn protocol_dict_get_data_size(dict: *mut ProtocolDict, protocol_index: usize) -> usize;
}
extern "C" {
	pub fn protocol_dict_get_max_data_size(dict: *mut ProtocolDict) -> usize;
}
extern "C" {
	pub fn protocol_dict_get_name(dict: *mut ProtocolDict, protocol_index: usize) -> *const core::ffi::c_char;
}
extern "C" {
	pub fn protocol_dict_get_manufacturer(dict: *mut ProtocolDict, protocol_index: usize) -> *const core::ffi::c_char;
}
extern "C" {
	pub fn protocol_dict_decoders_start(dict: *mut ProtocolDict);
}
extern "C" {
	pub fn protocol_dict_get_features(dict: *mut ProtocolDict, protocol_index: usize) -> u32;
}
extern "C" {
	pub fn protocol_dict_decoders_feed(dict: *mut ProtocolDict, level: bool, duration: u32) -> ProtocolId;
}
extern "C" {
	pub fn protocol_dict_decoders_feed_by_feature(dict: *mut ProtocolDict, feature: u32, level: bool, duration: u32) -> ProtocolId;
}
extern "C" {
	pub fn protocol_dict_decoders_feed_by_id(dict: *mut ProtocolDict, protocol_index: usize, level: bool, duration: u32)
	                                         -> ProtocolId;
}
extern "C" {
	pub fn protocol_dict_encoder_start(dict: *mut ProtocolDict, protocol_index: usize) -> bool;
}
extern "C" {
	pub fn protocol_dict_encoder_yield(dict: *mut ProtocolDict, protocol_index: usize) -> LevelDuration;
}
extern "C" {
	pub fn protocol_dict_render_data(dict: *mut ProtocolDict, result: *mut string_t, protocol_index: usize);
}
extern "C" {
	pub fn protocol_dict_render_brief_data(dict: *mut ProtocolDict, result: *mut string_t, protocol_index: usize);
}
extern "C" {
	pub fn protocol_dict_get_validate_count(dict: *mut ProtocolDict, protocol_index: usize) -> u32;
}
extern "C" {
	pub fn protocol_dict_get_protocol_by_name(dict: *mut ProtocolDict, name: *const core::ffi::c_char) -> ProtocolId;
}
extern "C" {
	pub fn protocol_dict_get_write_data(dict: *mut ProtocolDict, protocol_index: usize, data: *mut core::ffi::c_void) -> bool;
}
#[repr(C)]
pub struct LFRFIDT5577 {
	pub block: [u32; 8usize],
	pub blocks_to_write: u32,
}
#[test]
fn bindgen_test_layout_LFRFIDT5577() {
	assert_eq!(
	           ::core::mem::size_of::<LFRFIDT5577>(),
	           36usize,
	           concat!("Size of: ", stringify!(LFRFIDT5577))
	);
	assert_eq!(
	           ::core::mem::align_of::<LFRFIDT5577>(),
	           4usize,
	           concat!("Alignment of ", stringify!(LFRFIDT5577))
	);
	fn test_field_block() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LFRFIDT5577>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).block) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(LFRFIDT5577), "::", stringify!(block))
		);
	}
	test_field_block();
	fn test_field_blocks_to_write() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<LFRFIDT5577>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).blocks_to_write) as usize - ptr as usize
		           },
		           32usize,
		           concat!(
			"Offset of field: ",
			stringify!(LFRFIDT5577),
			"::",
			stringify!(blocks_to_write)
		)
		);
	}
	test_field_blocks_to_write();
}
extern "C" {
	#[doc = " @brief Write T5577 tag data to tag"]
	#[doc = ""]
	#[doc = " @param data"]
	pub fn t5577_write(data: *mut LFRFIDT5577);
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum LFRFIDProtocol {
	LFRFIDProtocolEM4100 = 0,
	LFRFIDProtocolH10301 = 1,
	LFRFIDProtocolIndala26 = 2,
	LFRFIDProtocolIOProxXSF = 3,
	LFRFIDProtocolAwid = 4,
	LFRFIDProtocolFDXA = 5,
	LFRFIDProtocolFDXB = 6,
	LFRFIDProtocolHidGeneric = 7,
	LFRFIDProtocolHidExGeneric = 8,
	LFRFIDProtocolPyramid = 9,
	LFRFIDProtocolViking = 10,
	LFRFIDProtocolJablotron = 11,
	LFRFIDProtocolParadox = 12,
	LFRFIDProtocolPACStanley = 13,
	LFRFIDProtocolKeri = 14,
	LFRFIDProtocolGallagher = 15,
	LFRFIDProtocolMax = 16,
}
extern "C" {
	pub static mut lfrfid_protocols: [*const ProtocolBase; 0usize];
}
extern "C" {
	#[doc = " @brief Save protocol from dictionary to file"]
	#[doc = ""]
	#[doc = " @param dict"]
	#[doc = " @param protocol"]
	#[doc = " @param filename"]
	#[doc = " @return true"]
	#[doc = " @return false"]
	pub fn lfrfid_dict_file_save(dict: *mut ProtocolDict, protocol: ProtocolId, filename: *const core::ffi::c_char) -> bool;
}
extern "C" {
	#[doc = " @brief Load protocol from file to dictionary"]
	#[doc = ""]
	#[doc = " @param dict"]
	#[doc = " @param filename"]
	#[doc = " @return ProtocolId"]
	pub fn lfrfid_dict_file_load(dict: *mut ProtocolDict, filename: *const core::ffi::c_char) -> ProtocolId;
}
#[repr(C)]
pub struct LFRFIDRawFile {
	_unused: [u8; 0],
}
extern "C" {
	#[doc = " @brief Allocate a new LFRFIDRawFile instance"]
	#[doc = ""]
	#[doc = " @param storage"]
	#[doc = " @return LFRFIDRawFile*"]
	pub fn lfrfid_raw_file_alloc(storage: *mut Storage) -> *mut LFRFIDRawFile;
}
extern "C" {
	#[doc = " @brief Free a LFRFIDRawFile instance"]
	#[doc = ""]
	#[doc = " @param file"]
	pub fn lfrfid_raw_file_free(file: *mut LFRFIDRawFile);
}
extern "C" {
	#[doc = " @brief Open RAW file for writing"]
	#[doc = ""]
	#[doc = " @param file"]
	#[doc = " @param file_path"]
	#[doc = " @return bool"]
	pub fn lfrfid_raw_file_open_write(file: *mut LFRFIDRawFile, file_path: *const core::ffi::c_char) -> bool;
}
extern "C" {
	#[doc = " @brief Open RAW file for reading"]
	#[doc = " @param file"]
	#[doc = " @param file_path"]
	#[doc = " @return bool"]
	pub fn lfrfid_raw_file_open_read(file: *mut LFRFIDRawFile, file_path: *const core::ffi::c_char) -> bool;
}
extern "C" {
	#[doc = " @brief Write RAW file header"]
	#[doc = ""]
	#[doc = " @param file"]
	#[doc = " @param frequency"]
	#[doc = " @param duty_cycle"]
	#[doc = " @param max_buffer_size"]
	#[doc = " @return bool"]
	pub fn lfrfid_raw_file_write_header(file: *mut LFRFIDRawFile,
	                                    frequency: core::ffi::c_float,
	                                    duty_cycle: core::ffi::c_float,
	                                    max_buffer_size: u32)
	                                    -> bool;
}
extern "C" {
	#[doc = " @brief Write data to RAW file"]
	#[doc = ""]
	#[doc = " @param file"]
	#[doc = " @param buffer_data"]
	#[doc = " @param buffer_size"]
	#[doc = " @return bool"]
	pub fn lfrfid_raw_file_write_buffer(file: *mut LFRFIDRawFile, buffer_data: *mut u8, buffer_size: usize) -> bool;
}
extern "C" {
	#[doc = " @brief Read RAW file header"]
	#[doc = ""]
	#[doc = " @param file"]
	#[doc = " @param frequency"]
	#[doc = " @param duty_cycle"]
	#[doc = " @return bool"]
	pub fn lfrfid_raw_file_read_header(file: *mut LFRFIDRawFile,
	                                   frequency: *mut core::ffi::c_float,
	                                   duty_cycle: *mut core::ffi::c_float)
	                                   -> bool;
}
extern "C" {
	#[doc = " @brief Read varint-encoded pair from RAW file"]
	#[doc = ""]
	#[doc = " @param file"]
	#[doc = " @param duration"]
	#[doc = " @param pulse"]
	#[doc = " @param pass_end file was wrapped around, can be NULL"]
	#[doc = " @return bool"]
	pub fn lfrfid_raw_file_read_pair(file: *mut LFRFIDRawFile, duration: *mut u32, pulse: *mut u32, pass_end: *mut bool) -> bool;
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum LFRFIDWorkerWriteResult {
	LFRFIDWorkerWriteOK = 0,
	LFRFIDWorkerWriteProtocolCannotBeWritten = 1,
	LFRFIDWorkerWriteFobCannotBeWritten = 2,
	LFRFIDWorkerWriteTooLongToWrite = 3,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum LFRFIDWorkerReadType {
	LFRFIDWorkerReadTypeAuto = 0,
	LFRFIDWorkerReadTypeASKOnly = 1,
	LFRFIDWorkerReadTypePSKOnly = 2,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum LFRFIDWorkerReadResult {
	LFRFIDWorkerReadSenseStart = 0,
	LFRFIDWorkerReadSenseEnd = 1,
	LFRFIDWorkerReadSenseCardStart = 2,
	LFRFIDWorkerReadSenseCardEnd = 3,
	LFRFIDWorkerReadStartASK = 4,
	LFRFIDWorkerReadStartPSK = 5,
	LFRFIDWorkerReadDone = 6,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum LFRFIDWorkerReadRawResult {
	LFRFIDWorkerReadRawFileError = 0,
	LFRFIDWorkerReadRawOverrun = 1,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum LFRFIDWorkerEmulateRawResult {
	LFRFIDWorkerEmulateRawFileError = 0,
	LFRFIDWorkerEmulateRawOverrun = 1,
}
pub type LFRFIDWorkerReadCallback = ::core::option::Option<unsafe extern "C" fn(result: LFRFIDWorkerReadResult,
                                                                                protocol: ProtocolId,
                                                                                context: *mut core::ffi::c_void)>;
pub type LFRFIDWorkerWriteCallback =
	::core::option::Option<unsafe extern "C" fn(result: LFRFIDWorkerWriteResult, context: *mut core::ffi::c_void)>;
pub type LFRFIDWorkerReadRawCallback =
	::core::option::Option<unsafe extern "C" fn(result: LFRFIDWorkerReadRawResult, context: *mut core::ffi::c_void)>;
pub type LFRFIDWorkerEmulateRawCallback =
	::core::option::Option<unsafe extern "C" fn(result: LFRFIDWorkerEmulateRawResult, context: *mut core::ffi::c_void)>;
#[repr(C)]
pub struct LFRFIDWorker {
	_unused: [u8; 0],
}
extern "C" {
	#[doc = " Allocate LF-RFID worker"]
	#[doc = " @return LFRFIDWorker*"]
	pub fn lfrfid_worker_alloc(dict: *mut ProtocolDict) -> *mut LFRFIDWorker;
}
extern "C" {
	#[doc = " Free LF-RFID worker"]
	#[doc = " @param worker"]
	pub fn lfrfid_worker_free(worker: *mut LFRFIDWorker);
}
extern "C" {
	#[doc = " Start LF-RFID worker thread"]
	#[doc = " @param worker"]
	pub fn lfrfid_worker_start_thread(worker: *mut LFRFIDWorker);
}
extern "C" {
	#[doc = " Stop LF-RFID worker thread"]
	#[doc = " @param worker"]
	pub fn lfrfid_worker_stop_thread(worker: *mut LFRFIDWorker);
}
extern "C" {
	#[doc = " @brief Start read mode"]
	#[doc = ""]
	#[doc = " @param worker"]
	#[doc = " @param type"]
	#[doc = " @param callback"]
	#[doc = " @param context"]
	pub fn lfrfid_worker_read_start(worker: *mut LFRFIDWorker,
	                                type_: LFRFIDWorkerReadType,
	                                callback: LFRFIDWorkerReadCallback,
	                                context: *mut core::ffi::c_void);
}
extern "C" {
	#[doc = " @brief Start write mode"]
	#[doc = ""]
	#[doc = " @param worker"]
	#[doc = " @param protocol"]
	#[doc = " @param callback"]
	#[doc = " @param context"]
	pub fn lfrfid_worker_write_start(worker: *mut LFRFIDWorker,
	                                 protocol: LFRFIDProtocol,
	                                 callback: LFRFIDWorkerWriteCallback,
	                                 context: *mut core::ffi::c_void);
}
extern "C" {
	#[doc = " Start emulate mode"]
	#[doc = " @param worker"]
	pub fn lfrfid_worker_emulate_start(worker: *mut LFRFIDWorker, protocol: LFRFIDProtocol);
}
extern "C" {
	#[doc = " @brief Start raw read mode"]
	#[doc = ""]
	#[doc = " @param worker"]
	#[doc = " @param filename"]
	#[doc = " @param type"]
	#[doc = " @param callback"]
	#[doc = " @param context"]
	pub fn lfrfid_worker_read_raw_start(worker: *mut LFRFIDWorker,
	                                    filename: *const core::ffi::c_char,
	                                    type_: LFRFIDWorkerReadType,
	                                    callback: LFRFIDWorkerReadRawCallback,
	                                    context: *mut core::ffi::c_void);
}
extern "C" {
	#[doc = " Emulate raw read mode"]
	#[doc = " @param worker"]
	#[doc = " @param filename"]
	#[doc = " @param callback"]
	#[doc = " @param context"]
	pub fn lfrfid_worker_emulate_raw_start(worker: *mut LFRFIDWorker,
	                                       filename: *const core::ffi::c_char,
	                                       callback: LFRFIDWorkerEmulateRawCallback,
	                                       context: *mut core::ffi::c_void);
}
extern "C" {
	#[doc = " Stop all modes"]
	#[doc = " @param worker"]
	pub fn lfrfid_worker_stop(worker: *mut LFRFIDWorker);
}
#[repr(C)]
pub struct LFRFIDRawWorker {
	_unused: [u8; 0],
}
extern "C" {
	#[doc = " @brief Allocate a new LFRFIDRawWorker instance"]
	#[doc = ""]
	#[doc = " @return LFRFIDRawWorker*"]
	pub fn lfrfid_raw_worker_alloc() -> *mut LFRFIDRawWorker;
}
extern "C" {
	#[doc = " @brief Free a LFRFIDRawWorker instance"]
	#[doc = ""]
	#[doc = " @param worker LFRFIDRawWorker instance"]
	pub fn lfrfid_raw_worker_free(worker: *mut LFRFIDRawWorker);
}
extern "C" {
	#[doc = " @brief Start reading"]
	#[doc = ""]
	#[doc = " @param worker LFRFIDRawWorker instance"]
	#[doc = " @param file_path path where file will be saved"]
	#[doc = " @param frequency HW frequency"]
	#[doc = " @param duty_cycle HW duty cycle"]
	#[doc = " @param callback callback for read event"]
	#[doc = " @param context context for callback"]
	pub fn lfrfid_raw_worker_start_read(worker: *mut LFRFIDRawWorker,
	                                    file_path: *const core::ffi::c_char,
	                                    frequency: core::ffi::c_float,
	                                    duty_cycle: core::ffi::c_float,
	                                    callback: LFRFIDWorkerReadRawCallback,
	                                    context: *mut core::ffi::c_void);
}
extern "C" {
	#[doc = " @brief Start emulate"]
	#[doc = ""]
	#[doc = " @param worker LFRFIDRawWorker instance"]
	#[doc = " @param file_path path to file that will be emulated"]
	#[doc = " @param callback callback for emulate event"]
	#[doc = " @param context context for callback"]
	pub fn lfrfid_raw_worker_start_emulate(worker: *mut LFRFIDRawWorker,
	                                       file_path: *const core::ffi::c_char,
	                                       callback: LFRFIDWorkerEmulateRawCallback,
	                                       context: *mut core::ffi::c_void);
}
extern "C" {
	#[doc = " @brief Stop worker"]
	#[doc = ""]
	#[doc = " @param worker"]
	pub fn lfrfid_raw_worker_stop(worker: *mut LFRFIDRawWorker);
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum BitLibParity {
	BitLibParityEven = 0,
	BitLibParityOdd = 1,
	BitLibParityAlways0 = 2,
	BitLibParityAlways1 = 3,
}
extern "C" {
	#[doc = " @brief Push a bit into a byte array."]
	#[doc = "  @param data array to push bit into"]
	#[doc = "  @param data_size array size"]
	#[doc = "  @param bit bit to push"]
	pub fn bit_lib_push_bit(data: *mut u8, data_size: usize, bit: bool);
}
extern "C" {
	#[doc = " @brief Set a bit in a byte array."]
	#[doc = "  @param data array to set bit in"]
	#[doc = "  @param position The position of the bit to set."]
	#[doc = "  @param bit bit value to set"]
	pub fn bit_lib_set_bit(data: *mut u8, position: usize, bit: bool);
}
extern "C" {
	#[doc = " @brief Set the bit at the given position to the given value."]
	#[doc = " @param data The data to set the bit in."]
	#[doc = " @param position The position of the bit to set."]
	#[doc = " @param byte The data to set the bit to."]
	#[doc = " @param length The length of the data."]
	pub fn bit_lib_set_bits(data: *mut u8, position: usize, byte: u8, length: u8);
}
extern "C" {
	#[doc = " @brief Get the bit of a byte."]
	#[doc = " @param data The byte to get the bits from."]
	#[doc = " @param position The position of the bit."]
	#[doc = " @return The bit."]
	pub fn bit_lib_get_bit(data: *const u8, position: usize) -> bool;
}
extern "C" {
	#[doc = " @brief Get the bits of a data, as uint8_t."]
	#[doc = " @param data The data to get the bits from."]
	#[doc = " @param position The position of the first bit."]
	#[doc = " @param length The length of the bits."]
	#[doc = " @return The bits."]
	pub fn bit_lib_get_bits(data: *const u8, position: usize, length: u8) -> u8;
}
extern "C" {
	#[doc = " @brief Get the bits of a data, as uint16_t."]
	#[doc = " @param data The data to get the bits from."]
	#[doc = " @param position The position of the first bit."]
	#[doc = " @param length The length of the bits."]
	#[doc = " @return The bits."]
	pub fn bit_lib_get_bits_16(data: *const u8, position: usize, length: u8) -> u16;
}
extern "C" {
	#[doc = " @brief Get the bits of a data, as uint32_t."]
	#[doc = " @param data The data to get the bits from."]
	#[doc = " @param position The position of the first bit."]
	#[doc = " @param length The length of the bits."]
	#[doc = " @return The bits."]
	pub fn bit_lib_get_bits_32(data: *const u8, position: usize, length: u8) -> u32;
}
extern "C" {
	#[doc = " @brief Test parity of given bits"]
	#[doc = " @param bits Bits to test parity of"]
	#[doc = " @param parity Parity to test against"]
	#[doc = " @return true if parity is correct, false otherwise"]
	pub fn bit_lib_test_parity_32(bits: u32, parity: BitLibParity) -> bool;
}
extern "C" {
	#[doc = " @brief Test parity of bit array, check parity for every parity_length block from start"]
	#[doc = ""]
	#[doc = " @param data Bit array"]
	#[doc = " @param position Start position"]
	#[doc = " @param length Bit count"]
	#[doc = " @param parity Parity to test against"]
	#[doc = " @param parity_length Parity block length"]
	#[doc = " @return true"]
	#[doc = " @return false"]
	pub fn bit_lib_test_parity(data: *const u8, position: usize, length: u8, parity: BitLibParity, parity_length: u8) -> bool;
}
extern "C" {
	#[doc = " @brief Add parity to bit array"]
	#[doc = ""]
	#[doc = " @param data Source bit array"]
	#[doc = " @param position Start position"]
	#[doc = " @param dest Destination bit array"]
	#[doc = " @param dest_position Destination position"]
	#[doc = " @param source_length Source bit count"]
	#[doc = " @param parity_length Parity block length"]
	#[doc = " @param parity Parity to test against"]
	#[doc = " @return size_t"]
	pub fn bit_lib_add_parity(data: *const u8,
	                          position: usize,
	                          dest: *mut u8,
	                          dest_position: usize,
	                          source_length: u8,
	                          parity_length: u8,
	                          parity: BitLibParity)
	                          -> usize;
}
extern "C" {
	#[doc = " @brief Remove bit every n in array and shift array left. Useful to remove parity."]
	#[doc = ""]
	#[doc = " @param data Bit array"]
	#[doc = " @param position Start position"]
	#[doc = " @param length Bit count"]
	#[doc = " @param n every n bit will be removed"]
	#[doc = " @return size_t"]
	pub fn bit_lib_remove_bit_every_nth(data: *mut u8, position: usize, length: u8, n: u8) -> usize;
}
extern "C" {
	#[doc = " @brief Copy bits from source to destination."]
	#[doc = ""]
	#[doc = " @param data destination array"]
	#[doc = " @param position position in destination array"]
	#[doc = " @param length length of bits to copy"]
	#[doc = " @param source source array"]
	#[doc = " @param source_position position in source array"]
	pub fn bit_lib_copy_bits(data: *mut u8, position: usize, length: usize, source: *const u8, source_position: usize);
}
extern "C" {
	#[doc = " @brief Reverse bits in bit array"]
	#[doc = ""]
	#[doc = " @param data Bit array"]
	#[doc = " @param position start position"]
	#[doc = " @param length length of bits to reverse"]
	pub fn bit_lib_reverse_bits(data: *mut u8, position: usize, length: u8);
}
extern "C" {
	#[doc = " @brief Count 1 bits in data"]
	#[doc = ""]
	#[doc = " @param data"]
	#[doc = " @return uint8_t set bit count"]
	pub fn bit_lib_get_bit_count(data: u32) -> u8;
}
extern "C" {
	#[doc = " @brief Print data as bit array"]
	#[doc = ""]
	#[doc = " @param data"]
	#[doc = " @param length"]
	pub fn bit_lib_print_bits(data: *const u8, length: usize);
}
#[repr(C)]
pub struct BitLibRegion {
	pub mark: core::ffi::c_char,
	pub start: usize,
	pub length: usize,
}
#[test]
fn bindgen_test_layout_BitLibRegion() {
	assert_eq!(
	           ::core::mem::size_of::<BitLibRegion>(),
	           12usize,
	           concat!("Size of: ", stringify!(BitLibRegion))
	);
	assert_eq!(
	           ::core::mem::align_of::<BitLibRegion>(),
	           4usize,
	           concat!("Alignment of ", stringify!(BitLibRegion))
	);
	fn test_field_mark() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<BitLibRegion>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).mark) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(BitLibRegion), "::", stringify!(mark))
		);
	}
	test_field_mark();
	fn test_field_start() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<BitLibRegion>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).start) as usize - ptr as usize
		           },
		           4usize,
		           concat!("Offset of field: ", stringify!(BitLibRegion), "::", stringify!(start))
		);
	}
	test_field_start();
	fn test_field_length() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<BitLibRegion>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).length) as usize - ptr as usize
		           },
		           8usize,
		           concat!("Offset of field: ", stringify!(BitLibRegion), "::", stringify!(length))
		);
	}
	test_field_length();
}
extern "C" {
	#[doc = " @brief Print data as bit array and mark regions. Regions needs to be sorted by start position."]
	#[doc = ""]
	#[doc = " @param regions"]
	#[doc = " @param region_count"]
	#[doc = " @param data"]
	#[doc = " @param length"]
	pub fn bit_lib_print_regions(regions: *const BitLibRegion, region_count: usize, data: *const u8, length: usize);
}
extern "C" {
	#[doc = " @brief Reverse bits in uint16_t, faster than generic bit_lib_reverse_bits."]
	#[doc = ""]
	#[doc = " @param data"]
	#[doc = " @return uint16_t"]
	pub fn bit_lib_reverse_16_fast(data: u16) -> u16;
}
extern "C" {
	#[doc = " @brief Reverse bits in uint8_t, faster than generic bit_lib_reverse_bits."]
	#[doc = ""]
	#[doc = " @param byte Byte"]
	#[doc = " @return uint8_t the reversed byte"]
	pub fn bit_lib_reverse_8_fast(byte: u8) -> u8;
}
extern "C" {
	#[doc = " @brief Slow, but generic CRC8 implementation"]
	#[doc = ""]
	#[doc = " @param data"]
	#[doc = " @param data_size"]
	#[doc = " @param polynom CRC polynom"]
	#[doc = " @param init init value"]
	#[doc = " @param ref_in true if the right bit is older"]
	#[doc = " @param ref_out true to reverse output"]
	#[doc = " @param xor_out xor output with this value"]
	#[doc = " @return uint8_t"]
	pub fn bit_lib_crc8(data: *const u8, data_size: usize, polynom: u8, init: u8, ref_in: bool, ref_out: bool, xor_out: u8) -> u16;
}
extern "C" {
	#[doc = " @brief Slow, but generic CRC16 implementation"]
	#[doc = ""]
	#[doc = " @param data"]
	#[doc = " @param data_size"]
	#[doc = " @param polynom CRC polynom"]
	#[doc = " @param init init value"]
	#[doc = " @param ref_in true if the right bit is older"]
	#[doc = " @param ref_out true to reverse output"]
	#[doc = " @param xor_out xor output with this value"]
	#[doc = " @return uint16_t"]
	pub fn bit_lib_crc16(data: *const u8, data_size: usize, polynom: u16, init: u16, ref_in: bool, ref_out: bool, xor_out: u16)
	                     -> u16;
}
#[repr(C)]
pub struct uECC_Curve_t {
	_unused: [u8; 0],
}
pub type uECC_Curve = *const uECC_Curve_t;
extern "C" {
	pub fn uECC_secp160r1() -> uECC_Curve;
}
extern "C" {
	pub fn uECC_secp192r1() -> uECC_Curve;
}
extern "C" {
	pub fn uECC_secp224r1() -> uECC_Curve;
}
extern "C" {
	pub fn uECC_secp256r1() -> uECC_Curve;
}
extern "C" {
	pub fn uECC_secp256k1() -> uECC_Curve;
}
pub type uECC_RNG_Function = ::core::option::Option<unsafe extern "C" fn(dest: *mut u8, size: core::ffi::c_uint) -> core::ffi::c_int>;
extern "C" {
	pub fn uECC_set_rng(rng_function: uECC_RNG_Function);
}
extern "C" {
	pub fn uECC_get_rng() -> uECC_RNG_Function;
}
extern "C" {
	pub fn uECC_curve_private_key_size(curve: uECC_Curve) -> core::ffi::c_int;
}
extern "C" {
	pub fn uECC_curve_public_key_size(curve: uECC_Curve) -> core::ffi::c_int;
}
extern "C" {
	pub fn uECC_make_key(public_key: *mut u8, private_key: *mut u8, curve: uECC_Curve) -> core::ffi::c_int;
}
extern "C" {
	pub fn uECC_shared_secret(public_key: *const u8, private_key: *const u8, secret: *mut u8, curve: uECC_Curve) -> core::ffi::c_int;
}
extern "C" {
	pub fn uECC_compress(public_key: *const u8, compressed: *mut u8, curve: uECC_Curve);
}
extern "C" {
	pub fn uECC_decompress(compressed: *const u8, public_key: *mut u8, curve: uECC_Curve);
}
extern "C" {
	pub fn uECC_valid_public_key(public_key: *const u8, curve: uECC_Curve) -> core::ffi::c_int;
}
extern "C" {
	pub fn uECC_compute_public_key(private_key: *const u8, public_key: *mut u8, curve: uECC_Curve) -> core::ffi::c_int;
}
extern "C" {
	pub fn uECC_sign(private_key: *const u8,
	                 message_hash: *const u8,
	                 hash_size: core::ffi::c_uint,
	                 signature: *mut u8,
	                 curve: uECC_Curve)
	                 -> core::ffi::c_int;
}
#[repr(C)]
pub struct uECC_HashContext {
	pub init_hash: ::core::option::Option<unsafe extern "C" fn(context: *const uECC_HashContext)>,
	pub update_hash: ::core::option::Option<unsafe extern "C" fn(context: *const uECC_HashContext,
	                                                             message: *const u8,
	                                                             message_size: core::ffi::c_uint)>,
	pub finish_hash: ::core::option::Option<unsafe extern "C" fn(context: *const uECC_HashContext, hash_result: *mut u8)>,
	pub block_size: core::ffi::c_uint,
	pub result_size: core::ffi::c_uint,
	pub tmp: *mut u8,
}
#[test]
fn bindgen_test_layout_uECC_HashContext() {
	assert_eq!(
	           ::core::mem::size_of::<uECC_HashContext>(),
	           24usize,
	           concat!("Size of: ", stringify!(uECC_HashContext))
	);
	assert_eq!(
	           ::core::mem::align_of::<uECC_HashContext>(),
	           4usize,
	           concat!("Alignment of ", stringify!(uECC_HashContext))
	);
	fn test_field_init_hash() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<uECC_HashContext>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).init_hash) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(uECC_HashContext), "::", stringify!(init_hash))
		);
	}
	test_field_init_hash();
	fn test_field_update_hash() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<uECC_HashContext>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).update_hash) as usize - ptr as usize
		           },
		           4usize,
		           concat!(
			"Offset of field: ",
			stringify!(uECC_HashContext),
			"::",
			stringify!(update_hash)
		)
		);
	}
	test_field_update_hash();
	fn test_field_finish_hash() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<uECC_HashContext>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).finish_hash) as usize - ptr as usize
		           },
		           8usize,
		           concat!(
			"Offset of field: ",
			stringify!(uECC_HashContext),
			"::",
			stringify!(finish_hash)
		)
		);
	}
	test_field_finish_hash();
	fn test_field_block_size() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<uECC_HashContext>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).block_size) as usize - ptr as usize
		           },
		           12usize,
		           concat!(
			"Offset of field: ",
			stringify!(uECC_HashContext),
			"::",
			stringify!(block_size)
		)
		);
	}
	test_field_block_size();
	fn test_field_result_size() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<uECC_HashContext>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).result_size) as usize - ptr as usize
		           },
		           16usize,
		           concat!(
			"Offset of field: ",
			stringify!(uECC_HashContext),
			"::",
			stringify!(result_size)
		)
		);
	}
	test_field_result_size();
	fn test_field_tmp() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<uECC_HashContext>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).tmp) as usize - ptr as usize
		           },
		           20usize,
		           concat!("Offset of field: ", stringify!(uECC_HashContext), "::", stringify!(tmp))
		);
	}
	test_field_tmp();
}
extern "C" {
	pub fn uECC_sign_deterministic(private_key: *const u8,
	                               message_hash: *const u8,
	                               hash_size: core::ffi::c_uint,
	                               hash_context: *const uECC_HashContext,
	                               signature: *mut u8,
	                               curve: uECC_Curve)
	                               -> core::ffi::c_int;
}
extern "C" {
	pub fn uECC_verify(public_key: *const u8,
	                   message_hash: *const u8,
	                   hash_size: core::ffi::c_uint,
	                   signature: *const u8,
	                   curve: uECC_Curve)
	                   -> core::ffi::c_int;
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum iButtonKeyType {
	iButtonKeyDS1990 = 0,
	iButtonKeyCyfral = 1,
	iButtonKeyMetakom = 2,
}
#[repr(C)]
pub struct iButtonKey {
	_unused: [u8; 0],
}
extern "C" {
	#[doc = " Allocate key"]
	#[doc = " @return iButtonKey*"]
	pub fn ibutton_key_alloc() -> *mut iButtonKey;
}
extern "C" {
	#[doc = " Free key"]
	#[doc = " @param key"]
	pub fn ibutton_key_free(key: *mut iButtonKey);
}
extern "C" {
	#[doc = " Copy key"]
	#[doc = " @param to"]
	#[doc = " @param from"]
	pub fn ibutton_key_set(to: *mut iButtonKey, from: *const iButtonKey);
}
extern "C" {
	#[doc = " Set key data"]
	#[doc = " @param key"]
	#[doc = " @param data"]
	#[doc = " @param data_count"]
	pub fn ibutton_key_set_data(key: *mut iButtonKey, data: *mut u8, data_count: u8);
}
extern "C" {
	#[doc = " Clear key data"]
	#[doc = " @param key"]
	pub fn ibutton_key_clear_data(key: *mut iButtonKey);
}
extern "C" {
	#[doc = " Get pointer to key data"]
	#[doc = " @param key"]
	#[doc = " @return const uint8_t*"]
	pub fn ibutton_key_get_data_p(key: *mut iButtonKey) -> *const u8;
}
extern "C" {
	#[doc = " Get key data size"]
	#[doc = " @param key"]
	#[doc = " @return uint8_t"]
	pub fn ibutton_key_get_data_size(key: *mut iButtonKey) -> u8;
}
extern "C" {
	#[doc = " Set key type"]
	#[doc = " @param key"]
	#[doc = " @param key_type"]
	pub fn ibutton_key_set_type(key: *mut iButtonKey, key_type: iButtonKeyType);
}
extern "C" {
	#[doc = " Get key type"]
	#[doc = " @param key"]
	#[doc = " @return iButtonKeyType"]
	pub fn ibutton_key_get_type(key: *mut iButtonKey) -> iButtonKeyType;
}
extern "C" {
	#[doc = " Get type string from key type"]
	#[doc = " @param key_type"]
	#[doc = " @return const char*"]
	pub fn ibutton_key_get_string_by_type(key_type: iButtonKeyType) -> *const core::ffi::c_char;
}
extern "C" {
	#[doc = " Get key type from string"]
	#[doc = " @param type_string"]
	#[doc = " @param key_type"]
	#[doc = " @return bool"]
	pub fn ibutton_key_get_type_by_string(type_string: *const core::ffi::c_char, key_type: *mut iButtonKeyType) -> bool;
}
extern "C" {
	#[doc = " Get key data size from type"]
	#[doc = " @param key_type"]
	#[doc = " @return uint8_t"]
	pub fn ibutton_key_get_size_by_type(key_type: iButtonKeyType) -> u8;
}
extern "C" {
	#[doc = " Get max key size"]
	#[doc = " @return uint8_t"]
	pub fn ibutton_key_get_max_size() -> u8;
}
extern "C" {
	#[doc = " Check if CRC for onewire key is valid"]
	#[doc = " @param key"]
	#[doc = " @return true"]
	#[doc = " @return false"]
	pub fn ibutton_key_dallas_crc_is_valid(key: *mut iButtonKey) -> bool;
}
extern "C" {
	#[doc = " Check if onewire key is a DS1990 key"]
	#[doc = " @param key"]
	#[doc = " @return true"]
	#[doc = " @return false"]
	pub fn ibutton_key_dallas_is_1990_key(key: *mut iButtonKey) -> bool;
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum iButtonWorkerWriteResult {
	iButtonWorkerWriteOK = 0,
	iButtonWorkerWriteSameKey = 1,
	iButtonWorkerWriteNoDetect = 2,
	iButtonWorkerWriteCannotWrite = 3,
}
pub type iButtonWorkerReadCallback = ::core::option::Option<unsafe extern "C" fn(context: *mut core::ffi::c_void)>;
pub type iButtonWorkerWriteCallback =
	::core::option::Option<unsafe extern "C" fn(context: *mut core::ffi::c_void, result: iButtonWorkerWriteResult)>;
pub type iButtonWorkerEmulateCallback = ::core::option::Option<unsafe extern "C" fn(context: *mut core::ffi::c_void, emulated: bool)>;
#[repr(C)]
pub struct iButtonWorker {
	_unused: [u8; 0],
}
extern "C" {
	#[doc = " Allocate ibutton worker"]
	#[doc = " @return iButtonWorker*"]
	pub fn ibutton_worker_alloc() -> *mut iButtonWorker;
}
extern "C" {
	#[doc = " Free ibutton worker"]
	#[doc = " @param worker"]
	pub fn ibutton_worker_free(worker: *mut iButtonWorker);
}
extern "C" {
	#[doc = " Start ibutton worker thread"]
	#[doc = " @param worker"]
	pub fn ibutton_worker_start_thread(worker: *mut iButtonWorker);
}
extern "C" {
	#[doc = " Stop ibutton worker thread"]
	#[doc = " @param worker"]
	pub fn ibutton_worker_stop_thread(worker: *mut iButtonWorker);
}
extern "C" {
	#[doc = " Set \"read success\" callback"]
	#[doc = " @param worker"]
	#[doc = " @param callback"]
	#[doc = " @param context"]
	pub fn ibutton_worker_read_set_callback(worker: *mut iButtonWorker,
	                                        callback: iButtonWorkerReadCallback,
	                                        context: *mut core::ffi::c_void);
}
extern "C" {
	#[doc = " Start read mode"]
	#[doc = " @param worker"]
	#[doc = " @param key"]
	pub fn ibutton_worker_read_start(worker: *mut iButtonWorker, key: *mut iButtonKey);
}
extern "C" {
	#[doc = " Set \"write event\" callback"]
	#[doc = " @param worker"]
	#[doc = " @param callback"]
	#[doc = " @param context"]
	pub fn ibutton_worker_write_set_callback(worker: *mut iButtonWorker,
	                                         callback: iButtonWorkerWriteCallback,
	                                         context: *mut core::ffi::c_void);
}
extern "C" {
	#[doc = " Start write mode"]
	#[doc = " @param worker"]
	#[doc = " @param key"]
	pub fn ibutton_worker_write_start(worker: *mut iButtonWorker, key: *mut iButtonKey);
}
extern "C" {
	#[doc = " Set \"emulate success\" callback"]
	#[doc = " @param worker"]
	#[doc = " @param callback"]
	#[doc = " @param context"]
	pub fn ibutton_worker_emulate_set_callback(worker: *mut iButtonWorker,
	                                           callback: iButtonWorkerEmulateCallback,
	                                           context: *mut core::ffi::c_void);
}
extern "C" {
	#[doc = " Start emulate mode"]
	#[doc = " @param worker"]
	#[doc = " @param key"]
	pub fn ibutton_worker_emulate_start(worker: *mut iButtonWorker, key: *mut iButtonKey);
}
extern "C" {
	#[doc = " Stop all modes"]
	#[doc = " @param worker"]
	pub fn ibutton_worker_stop(worker: *mut iButtonWorker);
}
extern "C" {
	pub fn maxim_crc8(data: *const u8, data_size: u8, crc_init: u8) -> u8;
}
#[repr(C)]
pub struct OneWireSlave {
	_unused: [u8; 0],
}
#[repr(C)]
pub struct OneWireDevice {
	_unused: [u8; 0],
}
extern "C" {
	#[doc = " Allocate onewire device with ID"]
	#[doc = " @param id_1"]
	#[doc = " @param id_2"]
	#[doc = " @param id_3"]
	#[doc = " @param id_4"]
	#[doc = " @param id_5"]
	#[doc = " @param id_6"]
	#[doc = " @param id_7"]
	#[doc = " @param id_8"]
	#[doc = " @return OneWireDevice*"]
	pub fn onewire_device_alloc(id_1: u8, id_2: u8, id_3: u8, id_4: u8, id_5: u8, id_6: u8, id_7: u8, id_8: u8) -> *mut OneWireDevice;
}
extern "C" {
	#[doc = " Deallocate onewire device"]
	#[doc = " @param device"]
	pub fn onewire_device_free(device: *mut OneWireDevice);
}
extern "C" {
	#[doc = " Send ID report, called from onewire slave"]
	#[doc = " @param device"]
	pub fn onewire_device_send_id(device: *mut OneWireDevice);
}
extern "C" {
	#[doc = " Attach device to onewire slave bus"]
	#[doc = " @param device"]
	#[doc = " @param bus"]
	pub fn onewire_device_attach(device: *mut OneWireDevice, bus: *mut OneWireSlave);
}
extern "C" {
	#[doc = " Attach device from onewire slave bus"]
	#[doc = " @param device"]
	pub fn onewire_device_detach(device: *mut OneWireDevice);
}
extern "C" {
	#[doc = " Get pointer to device id array"]
	#[doc = " @param device"]
	#[doc = " @return uint8_t*"]
	pub fn onewire_device_get_id_p(device: *mut OneWireDevice) -> *mut u8;
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum OneWireHostSearchMode {
	#[doc = "< Search for alarmed device"]
	CONDITIONAL_SEARCH = 0,
	#[doc = "< Search all devices"]
	NORMAL_SEARCH = 1,
}
#[repr(C)]
pub struct OneWireHost {
	_unused: [u8; 0],
}
extern "C" {
	#[doc = " Allocate onewire host bus"]
	#[doc = " @param gpio"]
	#[doc = " @return OneWireHost*"]
	pub fn onewire_host_alloc() -> *mut OneWireHost;
}
extern "C" {
	#[doc = " Deallocate onewire host bus"]
	#[doc = " @param host"]
	pub fn onewire_host_free(host: *mut OneWireHost);
}
extern "C" {
	#[doc = " Reset bus"]
	#[doc = " @param host"]
	#[doc = " @return bool"]
	pub fn onewire_host_reset(host: *mut OneWireHost) -> bool;
}
extern "C" {
	#[doc = " Read one bit"]
	#[doc = " @param host"]
	#[doc = " @return bool"]
	pub fn onewire_host_read_bit(host: *mut OneWireHost) -> bool;
}
extern "C" {
	#[doc = " Read one byte"]
	#[doc = " @param host"]
	#[doc = " @return uint8_t"]
	pub fn onewire_host_read(host: *mut OneWireHost) -> u8;
}
extern "C" {
	#[doc = " Read many bytes"]
	#[doc = " @param host"]
	#[doc = " @param buffer"]
	#[doc = " @param count"]
	pub fn onewire_host_read_bytes(host: *mut OneWireHost, buffer: *mut u8, count: u16);
}
extern "C" {
	#[doc = " Write one bit"]
	#[doc = " @param host"]
	#[doc = " @param value"]
	pub fn onewire_host_write_bit(host: *mut OneWireHost, value: bool);
}
extern "C" {
	#[doc = " Write one byte"]
	#[doc = " @param host"]
	#[doc = " @param value"]
	pub fn onewire_host_write(host: *mut OneWireHost, value: u8);
}
extern "C" {
	#[doc = " Skip ROM command"]
	#[doc = " @param host"]
	pub fn onewire_host_skip(host: *mut OneWireHost);
}
extern "C" {
	#[doc = " Start working with the bus"]
	#[doc = " @param host"]
	pub fn onewire_host_start(host: *mut OneWireHost);
}
extern "C" {
	#[doc = " Stop working with the bus"]
	#[doc = " @param host"]
	pub fn onewire_host_stop(host: *mut OneWireHost);
}
extern "C" {
	#[doc = " @param host"]
	pub fn onewire_host_reset_search(host: *mut OneWireHost);
}
extern "C" {
	#[doc = " @param host"]
	#[doc = " @param family_code"]
	pub fn onewire_host_target_search(host: *mut OneWireHost, family_code: u8);
}
extern "C" {
	#[doc = " @param host"]
	#[doc = " @param newAddr"]
	#[doc = " @param mode"]
	#[doc = " @return uint8_t"]
	pub fn onewire_host_search(host: *mut OneWireHost, newAddr: *mut u8, mode: OneWireHostSearchMode) -> u8;
}
pub type OneWireSlaveResultCallback = ::core::option::Option<unsafe extern "C" fn(context: *mut core::ffi::c_void)>;
extern "C" {
	#[doc = " Allocate onewire slave"]
	#[doc = " @param pin"]
	#[doc = " @return OneWireSlave*"]
	pub fn onewire_slave_alloc() -> *mut OneWireSlave;
}
extern "C" {
	#[doc = " Free onewire slave"]
	#[doc = " @param bus"]
	pub fn onewire_slave_free(bus: *mut OneWireSlave);
}
extern "C" {
	#[doc = " Start working with the bus"]
	#[doc = " @param bus"]
	pub fn onewire_slave_start(bus: *mut OneWireSlave);
}
extern "C" {
	#[doc = " Stop working with the bus"]
	#[doc = " @param bus"]
	pub fn onewire_slave_stop(bus: *mut OneWireSlave);
}
extern "C" {
	#[doc = " Attach device for emulation"]
	#[doc = " @param bus"]
	#[doc = " @param device"]
	pub fn onewire_slave_attach(bus: *mut OneWireSlave, device: *mut OneWireDevice);
}
extern "C" {
	#[doc = " Detach device from bus"]
	#[doc = " @param bus"]
	pub fn onewire_slave_detach(bus: *mut OneWireSlave);
}
extern "C" {
	#[doc = " Set a callback to report emulation success"]
	#[doc = " @param bus"]
	#[doc = " @param result_cb"]
	#[doc = " @param context"]
	pub fn onewire_slave_set_result_callback(bus: *mut OneWireSlave,
	                                         result_cb: OneWireSlaveResultCallback,
	                                         context: *mut core::ffi::c_void);
}
extern "C" {
	pub fn _putchar(character: core::ffi::c_char);
}
extern "C" {
	pub fn __wrap_printf(format: *const core::ffi::c_char, ...) -> core::ffi::c_int;
}
extern "C" {
	pub fn __wrap_vsnprintf(str_: *mut core::ffi::c_char,
	                        size: usize,
	                        format: *const core::ffi::c_char,
	                        args: va_list)
	                        -> core::ffi::c_int;
}
extern "C" {
	pub fn __wrap_puts(str_: *const core::ffi::c_char) -> core::ffi::c_int;
}
extern "C" {
	pub fn __wrap_putchar(ch: core::ffi::c_int) -> core::ffi::c_int;
}
extern "C" {
	pub fn __wrap_putc(ch: core::ffi::c_int, stream: *mut FILE) -> core::ffi::c_int;
}
extern "C" {
	pub fn __wrap_snprintf(str_: *mut core::ffi::c_char, size: usize, format: *const core::ffi::c_char, ...) -> core::ffi::c_int;
}
extern "C" {
	pub fn __wrap_fflush(stream: *mut FILE) -> core::ffi::c_int;
}
extern "C" {
	pub fn __wrap___assert(file: *const core::ffi::c_char, line: core::ffi::c_int, e: *const core::ffi::c_char);
}
extern "C" {
	pub fn __wrap___assert_func(file: *const core::ffi::c_char,
	                            line: core::ffi::c_int,
	                            func: *const core::ffi::c_char,
	                            e: *const core::ffi::c_char);
}
#[repr(C)]
pub struct SubGhzKey {
	pub name: string_t,
	pub key: u64,
	pub type_: u16,
}
#[test]
fn bindgen_test_layout_SubGhzKey() {
	assert_eq!(
	           ::core::mem::size_of::<SubGhzKey>(),
	           32usize,
	           concat!("Size of: ", stringify!(SubGhzKey))
	);
	assert_eq!(
	           ::core::mem::align_of::<SubGhzKey>(),
	           8usize,
	           concat!("Alignment of ", stringify!(SubGhzKey))
	);
	fn test_field_name() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<SubGhzKey>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).name) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(SubGhzKey), "::", stringify!(name))
		);
	}
	test_field_name();
	fn test_field_key() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<SubGhzKey>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).key) as usize - ptr as usize
		           },
		           16usize,
		           concat!("Offset of field: ", stringify!(SubGhzKey), "::", stringify!(key))
		);
	}
	test_field_key();
	fn test_field_type() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<SubGhzKey>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize
		           },
		           24usize,
		           concat!("Offset of field: ", stringify!(SubGhzKey), "::", stringify!(type_))
		);
	}
	test_field_type();
}
#[repr(C)]
pub struct SubGhzKeyArray_s {
	pub size: usize,
	pub alloc: usize,
	pub ptr: *mut SubGhzKey,
}
#[test]
fn bindgen_test_layout_SubGhzKeyArray_s() {
	assert_eq!(
	           ::core::mem::size_of::<SubGhzKeyArray_s>(),
	           12usize,
	           concat!("Size of: ", stringify!(SubGhzKeyArray_s))
	);
	assert_eq!(
	           ::core::mem::align_of::<SubGhzKeyArray_s>(),
	           4usize,
	           concat!("Alignment of ", stringify!(SubGhzKeyArray_s))
	);
	fn test_field_size() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<SubGhzKeyArray_s>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).size) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(SubGhzKeyArray_s), "::", stringify!(size))
		);
	}
	test_field_size();
	fn test_field_alloc() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<SubGhzKeyArray_s>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).alloc) as usize - ptr as usize
		           },
		           4usize,
		           concat!("Offset of field: ", stringify!(SubGhzKeyArray_s), "::", stringify!(alloc))
		);
	}
	test_field_alloc();
	fn test_field_ptr() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<SubGhzKeyArray_s>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).ptr) as usize - ptr as usize
		           },
		           8usize,
		           concat!("Offset of field: ", stringify!(SubGhzKeyArray_s), "::", stringify!(ptr))
		);
	}
	test_field_ptr();
}
pub type SubGhzKeyArray_t = [SubGhzKeyArray_s; 1usize];
#[repr(C)]
pub struct SubGhzKeystore {
	_unused: [u8; 0],
}
extern "C" {
	#[doc = " Allocate SubGhzKeystore."]
	#[doc = " @return SubGhzKeystore* pointer to a SubGhzKeystore instance"]
	pub fn subghz_keystore_alloc() -> *mut SubGhzKeystore;
}
extern "C" {
	#[doc = " Free SubGhzKeystore."]
	#[doc = " @param instance Pointer to a SubGhzKeystore instance"]
	pub fn subghz_keystore_free(instance: *mut SubGhzKeystore);
}
extern "C" {
	#[doc = " Loading manufacture key from file"]
	#[doc = " @param instance Pointer to a SubGhzKeystore instance"]
	#[doc = " @param filename Full path to the file"]
	pub fn subghz_keystore_load(instance: *mut SubGhzKeystore, filename: *const core::ffi::c_char) -> bool;
}
extern "C" {
	#[doc = " Save manufacture key to file"]
	#[doc = " @param instance Pointer to a SubGhzKeystore instance"]
	#[doc = " @param filename Full path to the file"]
	#[doc = " @return true On success"]
	pub fn subghz_keystore_save(instance: *mut SubGhzKeystore, filename: *const core::ffi::c_char, iv: *mut u8) -> bool;
}
extern "C" {
	#[doc = " Get array of keys and names manufacture"]
	#[doc = " @param instance Pointer to a SubGhzKeystore instance"]
	#[doc = " @return SubGhzKeyArray_t*"]
	pub fn subghz_keystore_get_data(instance: *mut SubGhzKeystore) -> *mut SubGhzKeyArray_t;
}
extern "C" {
	#[doc = " Save RAW encrypted to file"]
	#[doc = " @param input_file_name Full path to the input file"]
	#[doc = " @param output_file_name Full path to the output file"]
	#[doc = " @param iv IV, 16 bytes in hex"]
	pub fn subghz_keystore_raw_encrypted_save(input_file_name: *const core::ffi::c_char,
	                                          output_file_name: *const core::ffi::c_char,
	                                          iv: *mut u8)
	                                          -> bool;
}
extern "C" {
	#[doc = " Get decrypt RAW data to file"]
	#[doc = " @param file_name Full path to the input file"]
	#[doc = " @param offset Offset from the start of the RAW data"]
	#[doc = " @param data Returned array"]
	#[doc = " @param len Required data length"]
	#[doc = " @return true On success"]
	pub fn subghz_keystore_raw_get_data(file_name: *const core::ffi::c_char, offset: usize, data: *mut u8, len: usize) -> bool;
}
#[repr(C)]
pub struct SubGhzEnvironment {
	_unused: [u8; 0],
}
extern "C" {
	#[doc = " Allocate SubGhzEnvironment."]
	#[doc = " @return SubGhzEnvironment* pointer to a SubGhzEnvironment instance"]
	pub fn subghz_environment_alloc() -> *mut SubGhzEnvironment;
}
extern "C" {
	#[doc = " Free SubGhzEnvironment."]
	#[doc = " @param instance Pointer to a SubGhzEnvironment instance"]
	pub fn subghz_environment_free(instance: *mut SubGhzEnvironment);
}
extern "C" {
	#[doc = " Downloading the manufacture key file."]
	#[doc = " @param instance Pointer to a SubGhzEnvironment instance"]
	#[doc = " @param filename Full path to the file"]
	#[doc = " @return true On succes"]
	pub fn subghz_environment_load_keystore(instance: *mut SubGhzEnvironment, filename: *const core::ffi::c_char) -> bool;
}
extern "C" {
	#[doc = " Get pointer to a SubGhzKeystore* instance."]
	#[doc = " @return SubGhzEnvironment* pointer to a SubGhzEnvironment instance"]
	pub fn subghz_environment_get_keystore(instance: *mut SubGhzEnvironment) -> *mut SubGhzKeystore;
}
extern "C" {
	#[doc = " Set filename to work with Came Atomo."]
	#[doc = " @param instance Pointer to a SubGhzEnvironment instance"]
	#[doc = " @param filename Full path to the file"]
	pub fn subghz_environment_set_came_atomo_rainbow_table_file_name(instance: *mut SubGhzEnvironment,
	                                                                 filename: *const core::ffi::c_char);
}
extern "C" {
	#[doc = " Get filename to work with Came Atomo."]
	#[doc = " @param instance Pointer to a SubGhzEnvironment instance"]
	#[doc = " @return Full path to the file"]
	pub fn subghz_environment_get_came_atomo_rainbow_table_file_name(instance: *mut SubGhzEnvironment) -> *const core::ffi::c_char;
}
extern "C" {
	#[doc = " Set filename to work with Nice Flor-S."]
	#[doc = " @param instance Pointer to a SubGhzEnvironment instance"]
	#[doc = " @param filename Full path to the file"]
	pub fn subghz_environment_set_nice_flor_s_rainbow_table_file_name(instance: *mut SubGhzEnvironment,
	                                                                  filename: *const core::ffi::c_char);
}
extern "C" {
	#[doc = " Get filename to work with Nice Flor-S."]
	#[doc = " @param instance Pointer to a SubGhzEnvironment instance"]
	#[doc = " @return Full path to the file"]
	pub fn subghz_environment_get_nice_flor_s_rainbow_table_file_name(instance: *mut SubGhzEnvironment) -> *const core::ffi::c_char;
}
#[repr(C)]
pub struct SubGhzPresetDefinition {
	pub name: string_t,
	pub frequency: u32,
	pub data: *mut u8,
	pub data_size: usize,
}
#[test]
fn bindgen_test_layout_SubGhzPresetDefinition() {
	assert_eq!(
	           ::core::mem::size_of::<SubGhzPresetDefinition>(),
	           24usize,
	           concat!("Size of: ", stringify!(SubGhzPresetDefinition))
	);
	assert_eq!(
	           ::core::mem::align_of::<SubGhzPresetDefinition>(),
	           4usize,
	           concat!("Alignment of ", stringify!(SubGhzPresetDefinition))
	);
	fn test_field_name() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<SubGhzPresetDefinition>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).name) as usize - ptr as usize
		           },
		           0usize,
		           concat!(
			"Offset of field: ",
			stringify!(SubGhzPresetDefinition),
			"::",
			stringify!(name)
		)
		);
	}
	test_field_name();
	fn test_field_frequency() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<SubGhzPresetDefinition>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).frequency) as usize - ptr as usize
		           },
		           12usize,
		           concat!(
			"Offset of field: ",
			stringify!(SubGhzPresetDefinition),
			"::",
			stringify!(frequency)
		)
		);
	}
	test_field_frequency();
	fn test_field_data() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<SubGhzPresetDefinition>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).data) as usize - ptr as usize
		           },
		           16usize,
		           concat!(
			"Offset of field: ",
			stringify!(SubGhzPresetDefinition),
			"::",
			stringify!(data)
		)
		);
	}
	test_field_data();
	fn test_field_data_size() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<SubGhzPresetDefinition>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).data_size) as usize - ptr as usize
		           },
		           20usize,
		           concat!(
			"Offset of field: ",
			stringify!(SubGhzPresetDefinition),
			"::",
			stringify!(data_size)
		)
		);
	}
	test_field_data_size();
}
pub type SubGhzAlloc = ::core::option::Option<unsafe extern "C" fn(environment: *mut SubGhzEnvironment) -> *mut core::ffi::c_void>;
pub type SubGhzFree = ::core::option::Option<unsafe extern "C" fn(context: *mut core::ffi::c_void)>;
pub type SubGhzSerialize = ::core::option::Option<unsafe extern "C" fn(context: *mut core::ffi::c_void,
                                                                       flipper_format: *mut FlipperFormat,
                                                                       preset: *mut SubGhzPresetDefinition)
                                                                       -> bool>;
pub type SubGhzDeserialize =
	::core::option::Option<unsafe extern "C" fn(context: *mut core::ffi::c_void, flipper_format: *mut FlipperFormat) -> bool>;
pub type SubGhzDecoderFeed =
	::core::option::Option<unsafe extern "C" fn(decoder: *mut core::ffi::c_void, level: bool, duration: u32)>;
pub type SubGhzDecoderReset = ::core::option::Option<unsafe extern "C" fn(decoder: *mut core::ffi::c_void)>;
pub type SubGhzGetHashData = ::core::option::Option<unsafe extern "C" fn(decoder: *mut core::ffi::c_void) -> u8>;
pub type SubGhzGetString = ::core::option::Option<unsafe extern "C" fn(decoder: *mut core::ffi::c_void, output: *mut string_t)>;
pub type SubGhzEncoderStop = ::core::option::Option<unsafe extern "C" fn(encoder: *mut core::ffi::c_void)>;
pub type SubGhzEncoderYield = ::core::option::Option<unsafe extern "C" fn(context: *mut core::ffi::c_void) -> LevelDuration>;
#[repr(C)]
pub struct SubGhzProtocolDecoder {
	pub alloc: SubGhzAlloc,
	pub free: SubGhzFree,
	pub feed: SubGhzDecoderFeed,
	pub reset: SubGhzDecoderReset,
	pub get_hash_data: SubGhzGetHashData,
	pub get_string: SubGhzGetString,
	pub serialize: SubGhzSerialize,
	pub deserialize: SubGhzDeserialize,
}
#[test]
fn bindgen_test_layout_SubGhzProtocolDecoder() {
	assert_eq!(
	           ::core::mem::size_of::<SubGhzProtocolDecoder>(),
	           32usize,
	           concat!("Size of: ", stringify!(SubGhzProtocolDecoder))
	);
	assert_eq!(
	           ::core::mem::align_of::<SubGhzProtocolDecoder>(),
	           4usize,
	           concat!("Alignment of ", stringify!(SubGhzProtocolDecoder))
	);
	fn test_field_alloc() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<SubGhzProtocolDecoder>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).alloc) as usize - ptr as usize
		           },
		           0usize,
		           concat!(
			"Offset of field: ",
			stringify!(SubGhzProtocolDecoder),
			"::",
			stringify!(alloc)
		)
		);
	}
	test_field_alloc();
	fn test_field_free() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<SubGhzProtocolDecoder>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).free) as usize - ptr as usize
		           },
		           4usize,
		           concat!("Offset of field: ", stringify!(SubGhzProtocolDecoder), "::", stringify!(free))
		);
	}
	test_field_free();
	fn test_field_feed() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<SubGhzProtocolDecoder>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).feed) as usize - ptr as usize
		           },
		           8usize,
		           concat!("Offset of field: ", stringify!(SubGhzProtocolDecoder), "::", stringify!(feed))
		);
	}
	test_field_feed();
	fn test_field_reset() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<SubGhzProtocolDecoder>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).reset) as usize - ptr as usize
		           },
		           12usize,
		           concat!(
			"Offset of field: ",
			stringify!(SubGhzProtocolDecoder),
			"::",
			stringify!(reset)
		)
		);
	}
	test_field_reset();
	fn test_field_get_hash_data() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<SubGhzProtocolDecoder>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).get_hash_data) as usize - ptr as usize
		           },
		           16usize,
		           concat!(
			"Offset of field: ",
			stringify!(SubGhzProtocolDecoder),
			"::",
			stringify!(get_hash_data)
		)
		);
	}
	test_field_get_hash_data();
	fn test_field_get_string() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<SubGhzProtocolDecoder>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).get_string) as usize - ptr as usize
		           },
		           20usize,
		           concat!(
			"Offset of field: ",
			stringify!(SubGhzProtocolDecoder),
			"::",
			stringify!(get_string)
		)
		);
	}
	test_field_get_string();
	fn test_field_serialize() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<SubGhzProtocolDecoder>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).serialize) as usize - ptr as usize
		           },
		           24usize,
		           concat!(
			"Offset of field: ",
			stringify!(SubGhzProtocolDecoder),
			"::",
			stringify!(serialize)
		)
		);
	}
	test_field_serialize();
	fn test_field_deserialize() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<SubGhzProtocolDecoder>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).deserialize) as usize - ptr as usize
		           },
		           28usize,
		           concat!(
			"Offset of field: ",
			stringify!(SubGhzProtocolDecoder),
			"::",
			stringify!(deserialize)
		)
		);
	}
	test_field_deserialize();
}
#[repr(C)]
pub struct SubGhzProtocolEncoder {
	pub alloc: SubGhzAlloc,
	pub free: SubGhzFree,
	pub deserialize: SubGhzDeserialize,
	pub stop: SubGhzEncoderStop,
	pub yield_: SubGhzEncoderYield,
}
#[test]
fn bindgen_test_layout_SubGhzProtocolEncoder() {
	assert_eq!(
	           ::core::mem::size_of::<SubGhzProtocolEncoder>(),
	           20usize,
	           concat!("Size of: ", stringify!(SubGhzProtocolEncoder))
	);
	assert_eq!(
	           ::core::mem::align_of::<SubGhzProtocolEncoder>(),
	           4usize,
	           concat!("Alignment of ", stringify!(SubGhzProtocolEncoder))
	);
	fn test_field_alloc() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<SubGhzProtocolEncoder>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).alloc) as usize - ptr as usize
		           },
		           0usize,
		           concat!(
			"Offset of field: ",
			stringify!(SubGhzProtocolEncoder),
			"::",
			stringify!(alloc)
		)
		);
	}
	test_field_alloc();
	fn test_field_free() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<SubGhzProtocolEncoder>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).free) as usize - ptr as usize
		           },
		           4usize,
		           concat!("Offset of field: ", stringify!(SubGhzProtocolEncoder), "::", stringify!(free))
		);
	}
	test_field_free();
	fn test_field_deserialize() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<SubGhzProtocolEncoder>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).deserialize) as usize - ptr as usize
		           },
		           8usize,
		           concat!(
			"Offset of field: ",
			stringify!(SubGhzProtocolEncoder),
			"::",
			stringify!(deserialize)
		)
		);
	}
	test_field_deserialize();
	fn test_field_stop() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<SubGhzProtocolEncoder>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).stop) as usize - ptr as usize
		           },
		           12usize,
		           concat!("Offset of field: ", stringify!(SubGhzProtocolEncoder), "::", stringify!(stop))
		);
	}
	test_field_stop();
	fn test_field_yield() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<SubGhzProtocolEncoder>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).yield_) as usize - ptr as usize
		           },
		           16usize,
		           concat!(
			"Offset of field: ",
			stringify!(SubGhzProtocolEncoder),
			"::",
			stringify!(yield_)
		)
		);
	}
	test_field_yield();
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum SubGhzProtocolType {
	SubGhzProtocolTypeUnknown = 0,
	SubGhzProtocolTypeStatic = 1,
	SubGhzProtocolTypeDynamic = 2,
	SubGhzProtocolTypeRAW = 3,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum SubGhzProtocolFlag {
	SubGhzProtocolFlag_RAW = 1,
	SubGhzProtocolFlag_Decodable = 2,
	SubGhzProtocolFlag_315 = 4,
	SubGhzProtocolFlag_433 = 8,
	SubGhzProtocolFlag_868 = 16,
	SubGhzProtocolFlag_AM = 32,
	SubGhzProtocolFlag_FM = 64,
	SubGhzProtocolFlag_Save = 128,
	SubGhzProtocolFlag_Load = 256,
	SubGhzProtocolFlag_Send = 512,
}
#[repr(C)]
pub struct SubGhzProtocol {
	pub name: *const core::ffi::c_char,
	pub type_: SubGhzProtocolType,
	pub flag: SubGhzProtocolFlag,
	pub encoder: *const SubGhzProtocolEncoder,
	pub decoder: *const SubGhzProtocolDecoder,
}
#[test]
fn bindgen_test_layout_SubGhzProtocol() {
	assert_eq!(
	           ::core::mem::size_of::<SubGhzProtocol>(),
	           20usize,
	           concat!("Size of: ", stringify!(SubGhzProtocol))
	);
	assert_eq!(
	           ::core::mem::align_of::<SubGhzProtocol>(),
	           4usize,
	           concat!("Alignment of ", stringify!(SubGhzProtocol))
	);
	fn test_field_name() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<SubGhzProtocol>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).name) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(SubGhzProtocol), "::", stringify!(name))
		);
	}
	test_field_name();
	fn test_field_type() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<SubGhzProtocol>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize
		           },
		           4usize,
		           concat!("Offset of field: ", stringify!(SubGhzProtocol), "::", stringify!(type_))
		);
	}
	test_field_type();
	fn test_field_flag() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<SubGhzProtocol>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).flag) as usize - ptr as usize
		           },
		           8usize,
		           concat!("Offset of field: ", stringify!(SubGhzProtocol), "::", stringify!(flag))
		);
	}
	test_field_flag();
	fn test_field_encoder() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<SubGhzProtocol>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).encoder) as usize - ptr as usize
		           },
		           12usize,
		           concat!("Offset of field: ", stringify!(SubGhzProtocol), "::", stringify!(encoder))
		);
	}
	test_field_encoder();
	fn test_field_decoder() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<SubGhzProtocol>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).decoder) as usize - ptr as usize
		           },
		           16usize,
		           concat!("Offset of field: ", stringify!(SubGhzProtocol), "::", stringify!(decoder))
		);
	}
	test_field_decoder();
}
pub type SubGhzProtocolDecoderBaseRxCallback =
	::core::option::Option<unsafe extern "C" fn(instance: *mut SubGhzProtocolDecoderBase, context: *mut core::ffi::c_void)>;
#[repr(C)]
pub struct SubGhzProtocolDecoderBase {
	pub protocol: *const SubGhzProtocol,
	pub callback: SubGhzProtocolDecoderBaseRxCallback,
	pub context: *mut core::ffi::c_void,
}
#[test]
fn bindgen_test_layout_SubGhzProtocolDecoderBase() {
	assert_eq!(
	           ::core::mem::size_of::<SubGhzProtocolDecoderBase>(),
	           12usize,
	           concat!("Size of: ", stringify!(SubGhzProtocolDecoderBase))
	);
	assert_eq!(
	           ::core::mem::align_of::<SubGhzProtocolDecoderBase>(),
	           4usize,
	           concat!("Alignment of ", stringify!(SubGhzProtocolDecoderBase))
	);
	fn test_field_protocol() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<SubGhzProtocolDecoderBase>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).protocol) as usize - ptr as usize
		           },
		           0usize,
		           concat!(
			"Offset of field: ",
			stringify!(SubGhzProtocolDecoderBase),
			"::",
			stringify!(protocol)
		)
		);
	}
	test_field_protocol();
	fn test_field_callback() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<SubGhzProtocolDecoderBase>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).callback) as usize - ptr as usize
		           },
		           4usize,
		           concat!(
			"Offset of field: ",
			stringify!(SubGhzProtocolDecoderBase),
			"::",
			stringify!(callback)
		)
		);
	}
	test_field_callback();
	fn test_field_context() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<SubGhzProtocolDecoderBase>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).context) as usize - ptr as usize
		           },
		           8usize,
		           concat!(
			"Offset of field: ",
			stringify!(SubGhzProtocolDecoderBase),
			"::",
			stringify!(context)
		)
		);
	}
	test_field_context();
}
extern "C" {
	#[doc = " Set a callback upon completion of successful decoding of one of the protocols."]
	#[doc = " @param decoder_base Pointer to a SubGhzProtocolDecoderBase instance"]
	#[doc = " @param callback Callback, SubGhzProtocolDecoderBaseRxCallback"]
	#[doc = " @param context Context"]
	pub fn subghz_protocol_decoder_base_set_decoder_callback(decoder_base: *mut SubGhzProtocolDecoderBase,
	                                                         callback: SubGhzProtocolDecoderBaseRxCallback,
	                                                         context: *mut core::ffi::c_void);
}
extern "C" {
	#[doc = " Getting a textual representation of the received data."]
	#[doc = " @param decoder_base Pointer to a SubGhzProtocolDecoderBase instance"]
	#[doc = " @param output Resulting text"]
	pub fn subghz_protocol_decoder_base_get_string(decoder_base: *mut SubGhzProtocolDecoderBase, output: *mut string_t) -> bool;
}
extern "C" {
	#[doc = " Serialize data SubGhzProtocolDecoderBase."]
	#[doc = " @param decoder_base Pointer to a SubGhzProtocolDecoderBase instance"]
	#[doc = " @param flipper_format Pointer to a FlipperFormat instance"]
	#[doc = " @param preset The modulation on which the signal was received, SubGhzPresetDefinition"]
	#[doc = " @return true On success"]
	pub fn subghz_protocol_decoder_base_serialize(decoder_base: *mut SubGhzProtocolDecoderBase,
	                                              flipper_format: *mut FlipperFormat,
	                                              preset: *mut SubGhzPresetDefinition)
	                                              -> bool;
}
extern "C" {
	#[doc = " Deserialize data SubGhzProtocolDecoderBase."]
	#[doc = " @param decoder_base Pointer to a SubGhzProtocolDecoderBase instance"]
	#[doc = " @param flipper_format Pointer to a FlipperFormat instance"]
	#[doc = " @return true On success"]
	pub fn subghz_protocol_decoder_base_deserialize(decoder_base: *mut SubGhzProtocolDecoderBase,
	                                                flipper_format: *mut FlipperFormat)
	                                                -> bool;
}
extern "C" {
	#[doc = " Getting the hash sum of the last randomly received parcel."]
	#[doc = " @param decoder_base Pointer to a SubGhzProtocolDecoderBase instance"]
	#[doc = " @return hash Hash sum"]
	pub fn subghz_protocol_decoder_base_get_hash_data(decoder_base: *mut SubGhzProtocolDecoderBase) -> u8;
}
#[repr(C)]
pub struct SubGhzProtocolEncoderBase {
	pub protocol: *const SubGhzProtocol,
}
#[test]
fn bindgen_test_layout_SubGhzProtocolEncoderBase() {
	assert_eq!(
	           ::core::mem::size_of::<SubGhzProtocolEncoderBase>(),
	           4usize,
	           concat!("Size of: ", stringify!(SubGhzProtocolEncoderBase))
	);
	assert_eq!(
	           ::core::mem::align_of::<SubGhzProtocolEncoderBase>(),
	           4usize,
	           concat!("Alignment of ", stringify!(SubGhzProtocolEncoderBase))
	);
	fn test_field_protocol() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<SubGhzProtocolEncoderBase>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).protocol) as usize - ptr as usize
		           },
		           0usize,
		           concat!(
			"Offset of field: ",
			stringify!(SubGhzProtocolEncoderBase),
			"::",
			stringify!(protocol)
		)
		);
	}
	test_field_protocol();
}
pub type SubGhzProtocolEncoderRAWCallbackEnd = ::core::option::Option<unsafe extern "C" fn(context: *mut core::ffi::c_void)>;
#[repr(C)]
pub struct SubGhzProtocolDecoderRAW {
	_unused: [u8; 0],
}
#[repr(C)]
pub struct SubGhzProtocolEncoderRAW {
	_unused: [u8; 0],
}
extern "C" {
	pub static subghz_protocol_raw_decoder: SubGhzProtocolDecoder;
}
extern "C" {
	pub static subghz_protocol_raw_encoder: SubGhzProtocolEncoder;
}
extern "C" {
	pub static subghz_protocol_raw: SubGhzProtocol;
}
extern "C" {
	#[doc = " Open file for writing"]
	#[doc = " @param instance Pointer to a SubGhzProtocolDecoderRAW instance"]
	#[doc = " @param dev_name  File name"]
	#[doc = " @param preset The modulation on which the signal was received, SubGhzPresetDefinition"]
	#[doc = " @return true On success"]
	pub fn subghz_protocol_raw_save_to_file_init(instance: *mut SubGhzProtocolDecoderRAW,
	                                             dev_name: *const core::ffi::c_char,
	                                             preset: *mut SubGhzPresetDefinition)
	                                             -> bool;
}
extern "C" {
	#[doc = " Stop writing file to flash"]
	#[doc = " @param instance Pointer to a SubGhzProtocolDecoderRAW instance"]
	pub fn subghz_protocol_raw_save_to_file_stop(instance: *mut SubGhzProtocolDecoderRAW);
}
extern "C" {
	#[doc = " Get the number of samples received SubGhzProtocolDecoderRAW."]
	#[doc = " @param instance Pointer to a SubGhzProtocolDecoderRAW instance"]
	#[doc = " @return count of samples"]
	pub fn subghz_protocol_raw_get_sample_write(instance: *mut SubGhzProtocolDecoderRAW) -> usize;
}
extern "C" {
	#[doc = " Allocate SubGhzProtocolDecoderRAW."]
	#[doc = " @param environment Pointer to a SubGhzEnvironment instance"]
	#[doc = " @return SubGhzProtocolDecoderRAW* pointer to a SubGhzProtocolDecoderRAW instance"]
	pub fn subghz_protocol_decoder_raw_alloc(environment: *mut SubGhzEnvironment) -> *mut core::ffi::c_void;
}
extern "C" {
	#[doc = " Free SubGhzProtocolDecoderRAW."]
	#[doc = " @param context Pointer to a SubGhzProtocolDecoderRAW instance"]
	pub fn subghz_protocol_decoder_raw_free(context: *mut core::ffi::c_void);
}
extern "C" {
	#[doc = " Reset decoder SubGhzProtocolDecoderRAW."]
	#[doc = " @param context Pointer to a SubGhzProtocolDecoderRAW instance"]
	pub fn subghz_protocol_decoder_raw_reset(context: *mut core::ffi::c_void);
}
extern "C" {
	#[doc = " Parse a raw sequence of levels and durations received from the air."]
	#[doc = " @param context Pointer to a SubGhzProtocolDecoderRAW instance"]
	#[doc = " @param level Signal level true-high false-low"]
	#[doc = " @param duration Duration of this level in, us"]
	pub fn subghz_protocol_decoder_raw_feed(context: *mut core::ffi::c_void, level: bool, duration: u32);
}
extern "C" {
	#[doc = " Deserialize data SubGhzProtocolDecoderRAW."]
	#[doc = " @param context Pointer to a SubGhzProtocolDecoderRAW instance"]
	#[doc = " @param flipper_format Pointer to a FlipperFormat instance"]
	#[doc = " @return true On success"]
	pub fn subghz_protocol_decoder_raw_deserialize(context: *mut core::ffi::c_void, flipper_format: *mut FlipperFormat) -> bool;
}
extern "C" {
	#[doc = " Getting a textual representation of the received data."]
	#[doc = " @param context Pointer to a SubGhzProtocolDecoderRAW instance"]
	#[doc = " @param output Resulting text"]
	pub fn subghz_protocol_decoder_raw_get_string(context: *mut core::ffi::c_void, output: *mut string_t);
}
extern "C" {
	#[doc = " Allocate SubGhzProtocolEncoderRAW."]
	#[doc = " @param environment Pointer to a SubGhzEnvironment instance"]
	#[doc = " @return SubGhzProtocolEncoderRAW* pointer to a SubGhzProtocolEncoderRAW instance"]
	pub fn subghz_protocol_encoder_raw_alloc(environment: *mut SubGhzEnvironment) -> *mut core::ffi::c_void;
}
extern "C" {
	#[doc = " Free SubGhzProtocolEncoderRAW."]
	#[doc = " @param context Pointer to a SubGhzProtocolEncoderRAW instance"]
	pub fn subghz_protocol_encoder_raw_free(context: *mut core::ffi::c_void);
}
extern "C" {
	#[doc = " Forced transmission stop."]
	#[doc = " @param context Pointer to a SubGhzProtocolEncoderRAW instance"]
	pub fn subghz_protocol_encoder_raw_stop(context: *mut core::ffi::c_void);
}
extern "C" {
	#[doc = " Set callback on completion of file transfer."]
	#[doc = " @param instance Pointer to a SubGhzProtocolEncoderRAW instance"]
	#[doc = " @param callback_end Callback, SubGhzProtocolEncoderRAWCallbackEnd"]
	#[doc = " @param context_end Context"]
	pub fn subghz_protocol_raw_file_encoder_worker_set_callback_end(instance: *mut SubGhzProtocolEncoderRAW,
	                                                                callback_end: SubGhzProtocolEncoderRAWCallbackEnd,
	                                                                context_end: *mut core::ffi::c_void);
}
extern "C" {
	#[doc = " File generation for RAW work."]
	#[doc = " @param flipper_format Pointer to a FlipperFormat instance"]
	#[doc = " @param file_path File path"]
	pub fn subghz_protocol_raw_gen_fff_data(flipper_format: *mut FlipperFormat, file_path: *const core::ffi::c_char);
}
extern "C" {
	#[doc = " Deserialize and generating an upload to send."]
	#[doc = " @param context Pointer to a SubGhzProtocolEncoderRAW instance"]
	#[doc = " @param flipper_format Pointer to a FlipperFormat instance"]
	#[doc = " @return true On success"]
	pub fn subghz_protocol_encoder_raw_deserialize(context: *mut core::ffi::c_void, flipper_format: *mut FlipperFormat) -> bool;
}
extern "C" {
	#[doc = " Getting the level and duration of the upload to be loaded into DMA."]
	#[doc = " @param context Pointer to a SubGhzProtocolEncoderRAW instance"]
	#[doc = " @return LevelDuration"]
	pub fn subghz_protocol_encoder_raw_yield(context: *mut core::ffi::c_void) -> LevelDuration;
}
#[repr(C)]
pub struct SubGhzReceiver {
	_unused: [u8; 0],
}
pub type SubGhzReceiverCallback = ::core::option::Option<unsafe extern "C" fn(decoder: *mut SubGhzReceiver,
                                                                              decoder_base: *mut SubGhzProtocolDecoderBase,
                                                                              context: *mut core::ffi::c_void)>;
extern "C" {
	#[doc = " Allocate and init SubGhzReceiver."]
	#[doc = " @param environment Pointer to a SubGhzEnvironment instance"]
	#[doc = " @return SubGhzReceiver* pointer to a SubGhzReceiver instance"]
	pub fn subghz_receiver_alloc_init(environment: *mut SubGhzEnvironment) -> *mut SubGhzReceiver;
}
extern "C" {
	#[doc = " Free SubGhzReceiver."]
	#[doc = " @param instance Pointer to a SubGhzReceiver instance"]
	pub fn subghz_receiver_free(instance: *mut SubGhzReceiver);
}
extern "C" {
	#[doc = " Parse a raw sequence of levels and durations received from the air."]
	#[doc = " @param instance Pointer to a SubGhzReceiver instance"]
	#[doc = " @param level Signal level true-high false-low"]
	#[doc = " @param duration Duration of this level in, us"]
	pub fn subghz_receiver_decode(instance: *mut SubGhzReceiver, level: bool, duration: u32);
}
extern "C" {
	#[doc = " Reset decoder SubGhzReceiver."]
	#[doc = " @param instance Pointer to a SubGhzReceiver instance"]
	pub fn subghz_receiver_reset(instance: *mut SubGhzReceiver);
}
extern "C" {
	#[doc = " Set a callback upon completion of successful decoding of one of the protocols."]
	#[doc = " @param instance Pointer to a SubGhzReceiver instance"]
	#[doc = " @param callback Callback, SubGhzReceiverCallback"]
	#[doc = " @param context Context"]
	pub fn subghz_receiver_set_rx_callback(instance: *mut SubGhzReceiver,
	                                       callback: SubGhzReceiverCallback,
	                                       context: *mut core::ffi::c_void);
}
extern "C" {
	#[doc = " Set the filter of receivers that will work at the moment."]
	#[doc = " @param instance Pointer to a SubGhzReceiver instance"]
	#[doc = " @param filter Filter, SubGhzProtocolFlag"]
	pub fn subghz_receiver_set_filter(instance: *mut SubGhzReceiver, filter: SubGhzProtocolFlag);
}
extern "C" {
	#[doc = " Search for a cattery by his name."]
	#[doc = " @param instance Pointer to a SubGhzReceiver instance"]
	#[doc = " @param decoder_name Receiver name"]
	#[doc = " @return SubGhzProtocolDecoderBase* pointer to a SubGhzProtocolDecoderBase instance"]
	pub fn subghz_receiver_search_decoder_base_by_name(instance: *mut SubGhzReceiver,
	                                                   decoder_name: *const core::ffi::c_char)
	                                                   -> *mut SubGhzProtocolDecoderBase;
}
pub type SubGhzTxRxWorkerCallbackHaveRead = ::core::option::Option<unsafe extern "C" fn(context: *mut core::ffi::c_void)>;
#[repr(C)]
pub struct SubGhzTxRxWorker {
	_unused: [u8; 0],
}
extern "C" {
	#[doc = " SubGhzTxRxWorker, add data to transfer"]
	#[doc = " @param instance  Pointer to a SubGhzTxRxWorker instance"]
	#[doc = " @param data      *data"]
	#[doc = " @param size      data size"]
	#[doc = " @return bool     true if ok"]
	pub fn subghz_tx_rx_worker_write(instance: *mut SubGhzTxRxWorker, data: *mut u8, size: usize) -> bool;
}
extern "C" {
	#[doc = " SubGhzTxRxWorker, get available data"]
	#[doc = " @param instance   Pointer to a SubGhzTxRxWorker instance"]
	#[doc = " @return size_t    data size"]
	pub fn subghz_tx_rx_worker_available(instance: *mut SubGhzTxRxWorker) -> usize;
}
extern "C" {
	#[doc = " SubGhzTxRxWorker, read data"]
	#[doc = " @param instance   Pointer to a SubGhzTxRxWorker instance"]
	#[doc = " @param data       *data"]
	#[doc = " @param size       max data size, which can be read"]
	#[doc = " @return size_t    data size, how much is actually read"]
	pub fn subghz_tx_rx_worker_read(instance: *mut SubGhzTxRxWorker, data: *mut u8, size: usize) -> usize;
}
extern "C" {
	#[doc = " allback SubGhzTxRxWorker when there is data to read in an empty buffer"]
	#[doc = " @param instance Pointer to a SubGhzTxRxWorker instance"]
	#[doc = " @param callback SubGhzTxRxWorkerCallbackHaveRead callback"]
	#[doc = " @param context"]
	pub fn subghz_tx_rx_worker_set_callback_have_read(instance: *mut SubGhzTxRxWorker,
	                                                  callback: SubGhzTxRxWorkerCallbackHaveRead,
	                                                  context: *mut core::ffi::c_void);
}
extern "C" {
	#[doc = " Allocate SubGhzTxRxWorker"]
	#[doc = " @return SubGhzTxRxWorker* Pointer to a SubGhzTxRxWorker instance"]
	pub fn subghz_tx_rx_worker_alloc() -> *mut SubGhzTxRxWorker;
}
extern "C" {
	#[doc = " Free SubGhzTxRxWorker"]
	#[doc = " @param instance Pointer to a SubGhzTxRxWorker instance"]
	pub fn subghz_tx_rx_worker_free(instance: *mut SubGhzTxRxWorker);
}
extern "C" {
	#[doc = " Start SubGhzTxRxWorker"]
	#[doc = " @param instance Pointer to a SubGhzTxRxWorker instance"]
	#[doc = " @return bool - true if ok"]
	pub fn subghz_tx_rx_worker_start(instance: *mut SubGhzTxRxWorker, frequency: u32) -> bool;
}
extern "C" {
	#[doc = " Stop SubGhzTxRxWorker"]
	#[doc = " @param instance Pointer to a SubGhzTxRxWorker instance"]
	pub fn subghz_tx_rx_worker_stop(instance: *mut SubGhzTxRxWorker);
}
extern "C" {
	#[doc = " Check if worker is running"]
	#[doc = " @param instance Pointer to a SubGhzTxRxWorker instance"]
	#[doc = " @return bool - true if running"]
	pub fn subghz_tx_rx_worker_is_running(instance: *mut SubGhzTxRxWorker) -> bool;
}
#[repr(C)]
pub struct SubGhzWorker {
	_unused: [u8; 0],
}
pub type SubGhzWorkerOverrunCallback = ::core::option::Option<unsafe extern "C" fn(context: *mut core::ffi::c_void)>;
pub type SubGhzWorkerPairCallback =
	::core::option::Option<unsafe extern "C" fn(context: *mut core::ffi::c_void, level: bool, duration: u32)>;
extern "C" {
	pub fn subghz_worker_rx_callback(level: bool, duration: u32, context: *mut core::ffi::c_void);
}
extern "C" {
	#[doc = " Allocate SubGhzWorker."]
	#[doc = " @return SubGhzWorker* Pointer to a SubGhzWorker instance"]
	pub fn subghz_worker_alloc() -> *mut SubGhzWorker;
}
extern "C" {
	#[doc = " Free SubGhzWorker."]
	#[doc = " @param instance Pointer to a SubGhzWorker instance"]
	pub fn subghz_worker_free(instance: *mut SubGhzWorker);
}
extern "C" {
	#[doc = " Overrun callback SubGhzWorker."]
	#[doc = " @param instance Pointer to a SubGhzWorker instance"]
	#[doc = " @param callback SubGhzWorkerOverrunCallback callback"]
	pub fn subghz_worker_set_overrun_callback(instance: *mut SubGhzWorker, callback: SubGhzWorkerOverrunCallback);
}
extern "C" {
	#[doc = " Pair callback SubGhzWorker."]
	#[doc = " @param instance Pointer to a SubGhzWorker instance"]
	#[doc = " @param callback SubGhzWorkerOverrunCallback callback"]
	pub fn subghz_worker_set_pair_callback(instance: *mut SubGhzWorker, callback: SubGhzWorkerPairCallback);
}
extern "C" {
	#[doc = " Context callback SubGhzWorker."]
	#[doc = " @param instance Pointer to a SubGhzWorker instance"]
	#[doc = " @param context"]
	pub fn subghz_worker_set_context(instance: *mut SubGhzWorker, context: *mut core::ffi::c_void);
}
extern "C" {
	#[doc = " Start SubGhzWorker."]
	#[doc = " @param instance Pointer to a SubGhzWorker instance"]
	pub fn subghz_worker_start(instance: *mut SubGhzWorker);
}
extern "C" {
	#[doc = " Stop SubGhzWorker"]
	#[doc = " @param instance Pointer to a SubGhzWorker instance"]
	pub fn subghz_worker_stop(instance: *mut SubGhzWorker);
}
extern "C" {
	#[doc = " Check if worker is running."]
	#[doc = " @param instance Pointer to a SubGhzWorker instance"]
	#[doc = " @return bool - true if running"]
	pub fn subghz_worker_is_running(instance: *mut SubGhzWorker) -> bool;
}
#[repr(C)]
pub struct SubGhzTransmitter {
	_unused: [u8; 0],
}
extern "C" {
	#[doc = " Allocate and init SubGhzTransmitter."]
	#[doc = " @param environment Pointer to a SubGhzEnvironment instance"]
	#[doc = " @return SubGhzTransmitter* pointer to a SubGhzTransmitter instance"]
	pub fn subghz_transmitter_alloc_init(environment: *mut SubGhzEnvironment,
	                                     protocol_name: *const core::ffi::c_char)
	                                     -> *mut SubGhzTransmitter;
}
extern "C" {
	#[doc = " Free SubGhzTransmitter."]
	#[doc = " @param instance Pointer to a SubGhzTransmitter instance"]
	pub fn subghz_transmitter_free(instance: *mut SubGhzTransmitter);
}
extern "C" {
	#[doc = " Get protocol instance."]
	#[doc = " @param instance Pointer to a SubGhzTransmitter instance"]
	pub fn subghz_transmitter_get_protocol_instance(instance: *mut SubGhzTransmitter) -> *mut SubGhzProtocolEncoderBase;
}
extern "C" {
	#[doc = " Forced transmission stop."]
	#[doc = " @param instance Pointer to a SubGhzTransmitter instance"]
	pub fn subghz_transmitter_stop(instance: *mut SubGhzTransmitter) -> bool;
}
extern "C" {
	#[doc = " Deserialize and generating an upload to send."]
	#[doc = " @param instance Pointer to a SubGhzTransmitter instance"]
	#[doc = " @param flipper_format Pointer to a FlipperFormat instance"]
	#[doc = " @return true On success"]
	pub fn subghz_transmitter_deserialize(instance: *mut SubGhzTransmitter, flipper_format: *mut FlipperFormat) -> bool;
}
extern "C" {
	#[doc = " Getting the level and duration of the upload to be loaded into DMA."]
	#[doc = " @param context Pointer to a SubGhzTransmitter instance"]
	#[doc = " @return LevelDuration"]
	pub fn subghz_transmitter_yield(context: *mut core::ffi::c_void) -> LevelDuration;
}
extern "C" {
	#[doc = " Extract int value and trim arguments string"]
	#[doc = ""]
	#[doc = " @param args - arguments string"]
	#[doc = " @param word first argument, output"]
	#[doc = " @return true - success"]
	#[doc = " @return false - arguments string does not contain int"]
	pub fn args_read_int_and_trim(args: *mut string_t, value: *mut core::ffi::c_int) -> bool;
}
extern "C" {
	#[doc = " @brief Extract first argument from arguments string and trim arguments string"]
	#[doc = ""]
	#[doc = " @param args arguments string"]
	#[doc = " @param word first argument, output"]
	#[doc = " @return true - success"]
	#[doc = " @return false - arguments string does not contain anything"]
	pub fn args_read_string_and_trim(args: *mut string_t, word: *mut string_t) -> bool;
}
extern "C" {
	#[doc = " @brief Extract the first quoted argument from the argument string and trim the argument string. If the argument is not quoted, calls args_read_string_and_trim."]
	#[doc = ""]
	#[doc = " @param args arguments string"]
	#[doc = " @param word first argument, output, without quotes"]
	#[doc = " @return true - success"]
	#[doc = " @return false - arguments string does not contain anything"]
	pub fn args_read_probably_quoted_string_and_trim(args: *mut string_t, word: *mut string_t) -> bool;
}
extern "C" {
	#[doc = " @brief Convert hex ASCII values to byte array"]
	#[doc = ""]
	#[doc = " @param args arguments string"]
	#[doc = " @param bytes byte array pointer, output"]
	#[doc = " @param bytes_count needed bytes count"]
	#[doc = " @return true - success"]
	#[doc = " @return false - arguments string does not contain enough values, or contain non-hex ASCII values"]
	pub fn args_read_hex_bytes(args: *mut string_t, bytes: *mut u8, bytes_count: usize) -> bool;
}
extern "C" {
	#[doc = " @brief Get length of first word from arguments string"]
	#[doc = ""]
	#[doc = " @param args arguments string"]
	#[doc = " @return size_t length of first word"]
	pub fn args_get_first_word_length(args: *mut string_t) -> usize;
}
extern "C" {
	#[doc = " @brief Get length of arguments string"]
	#[doc = ""]
	#[doc = " @param args arguments string"]
	#[doc = " @return size_t length of arguments string"]
	pub fn args_length(args: *mut string_t) -> usize;
}
extern "C" {
	#[doc = " @brief Convert ASCII hex values to byte"]
	#[doc = ""]
	#[doc = " @param hi_nibble ASCII hi nibble character"]
	#[doc = " @param low_nibble ASCII low nibble character"]
	#[doc = " @param byte byte pointer, output"]
	#[doc = " @return bool conversion status"]
	pub fn args_char_to_hex(hi_nibble: core::ffi::c_char, low_nibble: core::ffi::c_char, byte: *mut u8) -> bool;
}
extern "C" {
	pub fn crc32_calc_buffer(crc: u32, buffer: *const core::ffi::c_void, size: usize) -> u32;
}
pub type FileCrcProgressCb = ::core::option::Option<unsafe extern "C" fn(progress: u8, context: *mut core::ffi::c_void)>;
extern "C" {
	pub fn crc32_calc_file(file: *mut File, progress_cb: FileCrcProgressCb, context: *mut core::ffi::c_void) -> u32;
}
#[repr(C)]
pub struct DirWalk {
	_unused: [u8; 0],
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum DirWalkResult {
	#[doc = "< OK"]
	DirWalkOK = 0,
	#[doc = "< Error"]
	DirWalkError = 1,
	#[doc = "< Last element"]
	DirWalkLast = 2,
}
pub type DirWalkFilterCb = ::core::option::Option<unsafe extern "C" fn(name: *const core::ffi::c_char,
                                                                       fileinfo: *mut FileInfo,
                                                                       ctx: *mut core::ffi::c_void)
                                                                       -> bool>;
extern "C" {
	#[doc = " Allocate DirWalk"]
	#[doc = " @param storage"]
	#[doc = " @return DirWalk*"]
	pub fn dir_walk_alloc(storage: *mut Storage) -> *mut DirWalk;
}
extern "C" {
	#[doc = " Free DirWalk"]
	#[doc = " @param dir_walk"]
	pub fn dir_walk_free(dir_walk: *mut DirWalk);
}
extern "C" {
	#[doc = " Set recursive mode (true by default)"]
	#[doc = " @param dir_walk"]
	#[doc = " @param recursive"]
	pub fn dir_walk_set_recursive(dir_walk: *mut DirWalk, recursive: bool);
}
extern "C" {
	#[doc = " Set filter callback (Should return true if the data is valid)"]
	#[doc = " @param dir_walk"]
	#[doc = " @param cb"]
	#[doc = " @param context"]
	pub fn dir_walk_set_filter_cb(dir_walk: *mut DirWalk, cb: DirWalkFilterCb, context: *mut core::ffi::c_void);
}
extern "C" {
	#[doc = " Open directory"]
	#[doc = " @param dir_walk"]
	#[doc = " @param path"]
	#[doc = " @return true"]
	#[doc = " @return false"]
	pub fn dir_walk_open(dir_walk: *mut DirWalk, path: *const core::ffi::c_char) -> bool;
}
extern "C" {
	#[doc = " Get error id"]
	#[doc = " @param dir_walk"]
	#[doc = " @return FS_Error"]
	pub fn dir_walk_get_error(dir_walk: *mut DirWalk) -> FS_Error;
}
extern "C" {
	#[doc = " Read next element from directory"]
	#[doc = " @param dir_walk"]
	#[doc = " @param return_path"]
	#[doc = " @param fileinfo"]
	#[doc = " @return DirWalkResult"]
	pub fn dir_walk_read(dir_walk: *mut DirWalk, return_path: *mut string_t, fileinfo: *mut FileInfo) -> DirWalkResult;
}
extern "C" {
	#[doc = " Close directory"]
	#[doc = " @param dir_walk"]
	pub fn dir_walk_close(dir_walk: *mut DirWalk);
}
#[repr(C)]
pub struct sha256_context {
	pub total: [u32; 2usize],
	pub state: [u32; 8usize],
	pub wbuf: [u32; 16usize],
}
#[test]
fn bindgen_test_layout_sha256_context() {
	assert_eq!(
	           ::core::mem::size_of::<sha256_context>(),
	           104usize,
	           concat!("Size of: ", stringify!(sha256_context))
	);
	assert_eq!(
	           ::core::mem::align_of::<sha256_context>(),
	           4usize,
	           concat!("Alignment of ", stringify!(sha256_context))
	);
	fn test_field_total() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<sha256_context>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).total) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(sha256_context), "::", stringify!(total))
		);
	}
	test_field_total();
	fn test_field_state() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<sha256_context>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).state) as usize - ptr as usize
		           },
		           8usize,
		           concat!("Offset of field: ", stringify!(sha256_context), "::", stringify!(state))
		);
	}
	test_field_state();
	fn test_field_wbuf() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<sha256_context>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).wbuf) as usize - ptr as usize
		           },
		           40usize,
		           concat!("Offset of field: ", stringify!(sha256_context), "::", stringify!(wbuf))
		);
	}
	test_field_wbuf();
}
extern "C" {
	pub fn sha256(input: *const core::ffi::c_uchar, ilen: core::ffi::c_uint, output: *mut [core::ffi::c_uchar; 32usize]);
}
extern "C" {
	pub fn sha256_start(ctx: *mut sha256_context);
}
extern "C" {
	pub fn sha256_finish(ctx: *mut sha256_context, output: *mut [core::ffi::c_uchar; 32usize]);
}
extern "C" {
	pub fn sha256_update(ctx: *mut sha256_context, input: *const core::ffi::c_uchar, ilen: core::ffi::c_uint);
}
extern "C" {
	pub fn sha256_process(ctx: *mut sha256_context);
}
#[repr(C)]
pub struct hmac_context {
	pub init_hash: ::core::option::Option<unsafe extern "C" fn(context: *const hmac_context)>,
	pub update_hash:
		::core::option::Option<unsafe extern "C" fn(context: *const hmac_context, message: *const u8, message_size: core::ffi::c_uint)>,
	pub finish_hash: ::core::option::Option<unsafe extern "C" fn(context: *const hmac_context, hash_result: *mut u8)>,
	pub block_size: core::ffi::c_uint,
	pub result_size: core::ffi::c_uint,
	pub tmp: *mut u8,
}
#[test]
fn bindgen_test_layout_hmac_context() {
	assert_eq!(
	           ::core::mem::size_of::<hmac_context>(),
	           24usize,
	           concat!("Size of: ", stringify!(hmac_context))
	);
	assert_eq!(
	           ::core::mem::align_of::<hmac_context>(),
	           4usize,
	           concat!("Alignment of ", stringify!(hmac_context))
	);
	fn test_field_init_hash() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<hmac_context>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).init_hash) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(hmac_context), "::", stringify!(init_hash))
		);
	}
	test_field_init_hash();
	fn test_field_update_hash() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<hmac_context>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).update_hash) as usize - ptr as usize
		           },
		           4usize,
		           concat!("Offset of field: ", stringify!(hmac_context), "::", stringify!(update_hash))
		);
	}
	test_field_update_hash();
	fn test_field_finish_hash() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<hmac_context>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).finish_hash) as usize - ptr as usize
		           },
		           8usize,
		           concat!("Offset of field: ", stringify!(hmac_context), "::", stringify!(finish_hash))
		);
	}
	test_field_finish_hash();
	fn test_field_block_size() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<hmac_context>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).block_size) as usize - ptr as usize
		           },
		           12usize,
		           concat!("Offset of field: ", stringify!(hmac_context), "::", stringify!(block_size))
		);
	}
	test_field_block_size();
	fn test_field_result_size() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<hmac_context>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).result_size) as usize - ptr as usize
		           },
		           16usize,
		           concat!("Offset of field: ", stringify!(hmac_context), "::", stringify!(result_size))
		);
	}
	test_field_result_size();
	fn test_field_tmp() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<hmac_context>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).tmp) as usize - ptr as usize
		           },
		           20usize,
		           concat!("Offset of field: ", stringify!(hmac_context), "::", stringify!(tmp))
		);
	}
	test_field_tmp();
}
#[repr(C)]
pub struct hmac_sha256_context {
	pub hmac_ctx: hmac_context,
	pub sha_ctx: sha256_context,
	pub tmp: [u8; 128usize],
}
#[test]
fn bindgen_test_layout_hmac_sha256_context() {
	assert_eq!(
	           ::core::mem::size_of::<hmac_sha256_context>(),
	           256usize,
	           concat!("Size of: ", stringify!(hmac_sha256_context))
	);
	assert_eq!(
	           ::core::mem::align_of::<hmac_sha256_context>(),
	           4usize,
	           concat!("Alignment of ", stringify!(hmac_sha256_context))
	);
	fn test_field_hmac_ctx() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<hmac_sha256_context>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).hmac_ctx) as usize - ptr as usize
		           },
		           0usize,
		           concat!(
			"Offset of field: ",
			stringify!(hmac_sha256_context),
			"::",
			stringify!(hmac_ctx)
		)
		);
	}
	test_field_hmac_ctx();
	fn test_field_sha_ctx() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<hmac_sha256_context>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).sha_ctx) as usize - ptr as usize
		           },
		           24usize,
		           concat!(
			"Offset of field: ",
			stringify!(hmac_sha256_context),
			"::",
			stringify!(sha_ctx)
		)
		);
	}
	test_field_sha_ctx();
	fn test_field_tmp() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<hmac_sha256_context>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).tmp) as usize - ptr as usize
		           },
		           128usize,
		           concat!("Offset of field: ", stringify!(hmac_sha256_context), "::", stringify!(tmp))
		);
	}
	test_field_tmp();
}
extern "C" {
	pub fn hmac_sha256_init(ctx: *mut hmac_sha256_context, K: *const u8);
}
extern "C" {
	pub fn hmac_sha256_update(ctx: *const hmac_sha256_context, message: *const u8, message_size: core::ffi::c_uint);
}
extern "C" {
	pub fn hmac_sha256_finish(ctx: *const hmac_sha256_context, K: *const u8, hash_result: *mut u8);
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum ManchesterEvent {
	ManchesterEventShortLow = 0,
	ManchesterEventShortHigh = 2,
	ManchesterEventLongLow = 4,
	ManchesterEventLongHigh = 6,
	ManchesterEventReset = 8,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum ManchesterState {
	ManchesterStateStart1 = 0,
	ManchesterStateMid1 = 1,
	ManchesterStateMid0 = 2,
	ManchesterStateStart0 = 3,
}
extern "C" {
	pub fn manchester_advance(state: ManchesterState,
	                          event: ManchesterEvent,
	                          next_state: *mut ManchesterState,
	                          data: *mut bool)
	                          -> bool;
}
#[repr(C)]
pub struct ManchesterEncoderState {
	pub prev_bit: bool,
	pub step: u8,
}
#[test]
fn bindgen_test_layout_ManchesterEncoderState() {
	assert_eq!(
	           ::core::mem::size_of::<ManchesterEncoderState>(),
	           2usize,
	           concat!("Size of: ", stringify!(ManchesterEncoderState))
	);
	assert_eq!(
	           ::core::mem::align_of::<ManchesterEncoderState>(),
	           1usize,
	           concat!("Alignment of ", stringify!(ManchesterEncoderState))
	);
	fn test_field_prev_bit() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<ManchesterEncoderState>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).prev_bit) as usize - ptr as usize
		           },
		           0usize,
		           concat!(
			"Offset of field: ",
			stringify!(ManchesterEncoderState),
			"::",
			stringify!(prev_bit)
		)
		);
	}
	test_field_prev_bit();
	fn test_field_step() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<ManchesterEncoderState>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).step) as usize - ptr as usize
		           },
		           1usize,
		           concat!(
			"Offset of field: ",
			stringify!(ManchesterEncoderState),
			"::",
			stringify!(step)
		)
		);
	}
	test_field_step();
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum ManchesterEncoderResult {
	ManchesterEncoderResultShortLow = 0,
	ManchesterEncoderResultLongLow = 1,
	ManchesterEncoderResultLongHigh = 2,
	ManchesterEncoderResultShortHigh = 3,
}
extern "C" {
	pub fn manchester_encoder_reset(state: *mut ManchesterEncoderState);
}
extern "C" {
	pub fn manchester_encoder_advance(state: *mut ManchesterEncoderState,
	                                  curr_bit: bool,
	                                  result: *mut ManchesterEncoderResult)
	                                  -> bool;
}
extern "C" {
	pub fn manchester_encoder_finish(state: *mut ManchesterEncoderState) -> ManchesterEncoderResult;
}
#[doc = " \\brief          MD5 context structure"]
#[repr(C)]
pub struct md5_context {
	#[doc = "< number of bytes processed"]
	pub total: [u32; 2usize],
	#[doc = "< intermediate digest state"]
	pub state: [u32; 4usize],
	#[doc = "< data block being processed"]
	pub buffer: [core::ffi::c_uchar; 64usize],
}
#[test]
fn bindgen_test_layout_md5_context() {
	assert_eq!(
	           ::core::mem::size_of::<md5_context>(),
	           88usize,
	           concat!("Size of: ", stringify!(md5_context))
	);
	assert_eq!(
	           ::core::mem::align_of::<md5_context>(),
	           4usize,
	           concat!("Alignment of ", stringify!(md5_context))
	);
	fn test_field_total() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<md5_context>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).total) as usize - ptr as usize
		           },
		           0usize,
		           concat!("Offset of field: ", stringify!(md5_context), "::", stringify!(total))
		);
	}
	test_field_total();
	fn test_field_state() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<md5_context>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).state) as usize - ptr as usize
		           },
		           8usize,
		           concat!("Offset of field: ", stringify!(md5_context), "::", stringify!(state))
		);
	}
	test_field_state();
	fn test_field_buffer() {
		assert_eq!(
		           unsafe {
			           let uninit = ::core::mem::MaybeUninit::<md5_context>::uninit();
			           let ptr = uninit.as_ptr();
			           ::core::ptr::addr_of!((*ptr).buffer) as usize - ptr as usize
		           },
		           24usize,
		           concat!("Offset of field: ", stringify!(md5_context), "::", stringify!(buffer))
		);
	}
	test_field_buffer();
}
extern "C" {
	#[doc = " \\brief          MD5 context setup"]
	#[doc = ""]
	#[doc = " \\param ctx      context to be initialized"]
	pub fn md5_starts(ctx: *mut md5_context);
}
extern "C" {
	#[doc = " \\brief          MD5 process buffer"]
	#[doc = ""]
	#[doc = " \\param ctx      MD5 context"]
	#[doc = " \\param input    buffer holding the  data"]
	#[doc = " \\param ilen     length of the input data"]
	pub fn md5_update(ctx: *mut md5_context, input: *const core::ffi::c_uchar, ilen: usize);
}
extern "C" {
	#[doc = " \\brief          MD5 final digest"]
	#[doc = ""]
	#[doc = " \\param ctx      MD5 context"]
	#[doc = " \\param output   MD5 checksum result"]
	pub fn md5_finish(ctx: *mut md5_context, output: *mut [core::ffi::c_uchar; 16usize]);
}
extern "C" {
	pub fn md5_process(ctx: *mut md5_context, data: *const [core::ffi::c_uchar; 64usize]);
}
extern "C" {
	#[doc = " \\brief          Output = MD5( input buffer )"]
	#[doc = ""]
	#[doc = " \\param input    buffer holding the  data"]
	#[doc = " \\param ilen     length of the input data"]
	#[doc = " \\param output   MD5 checksum result"]
	pub fn md5(input: *const core::ffi::c_uchar, ilen: usize, output: *mut [core::ffi::c_uchar; 16usize]);
}
extern "C" {
	#[doc = " @brief Extract filename without extension from path."]
	#[doc = ""]
	#[doc = " @param path path string"]
	#[doc = " @param filename output filename string. Must be initialized before."]
	pub fn path_extract_filename_no_ext(path: *const core::ffi::c_char, filename: *mut string_t);
}
extern "C" {
	#[doc = " @brief Extract filename string from path."]
	#[doc = ""]
	#[doc = " @param path path string"]
	#[doc = " @param filename output filename string. Must be initialized before."]
	#[doc = " @param trim_ext true - get filename without extension"]
	pub fn path_extract_filename(path: *mut string_t, filename: *mut string_t, trim_ext: bool);
}
extern "C" {
	#[doc = " @brief Extract file extension from path."]
	#[doc = ""]
	#[doc = " @param path path string"]
	#[doc = " @param ext output extension string"]
	#[doc = " @param ext_len_max maximum extension string length"]
	pub fn path_extract_extension(path: *mut string_t, ext: *mut core::ffi::c_char, ext_len_max: usize);
}
extern "C" {
	#[doc = " @brief Extract last path component"]
	#[doc = ""]
	#[doc = " @param path path string"]
	#[doc = " @param filename output string. Must be initialized before."]
	pub fn path_extract_basename(path: *const core::ffi::c_char, basename: *mut string_t);
}
extern "C" {
	#[doc = " @brief Extract path, except for last component"]
	#[doc = ""]
	#[doc = " @param path path string"]
	#[doc = " @param filename output string. Must be initialized before."]
	pub fn path_extract_dirname(path: *const core::ffi::c_char, dirname: *mut string_t);
}
extern "C" {
	#[doc = " @brief Appends new component to path, adding path delimiter"]
	#[doc = ""]
	#[doc = " @param path path string"]
	#[doc = " @param suffix path part to apply"]
	pub fn path_append(path: *mut string_t, suffix: *const core::ffi::c_char);
}
extern "C" {
	#[doc = " @brief Appends new component to path, adding path delimiter"]
	#[doc = ""]
	#[doc = " @param path first path part"]
	#[doc = " @param suffix second path part"]
	#[doc = " @param out_path output string to combine parts into. Must be initialized"]
	pub fn path_concat(path: *const core::ffi::c_char, suffix: *const core::ffi::c_char, out_path: *mut string_t);
}
extern "C" {
	#[doc = " @brief Check that path contains only ascii characters"]
	#[doc = ""]
	#[doc = " @param path"]
	#[doc = " @return true"]
	#[doc = " @return false"]
	pub fn path_contains_only_ascii(path: *const core::ffi::c_char) -> bool;
}
extern "C" {
	#[doc = " Generates random name"]
	#[doc = " @param name buffer to write random name"]
	#[doc = " @param max_name_size length of given buffer"]
	pub fn set_random_name(name: *mut core::ffi::c_char, max_name_size: u8);
}
extern "C" {
	pub fn saved_struct_load(path: *const core::ffi::c_char,
	                         data: *mut core::ffi::c_void,
	                         size: usize,
	                         magic: u8,
	                         version: u8)
	                         -> bool;
}
extern "C" {
	pub fn saved_struct_save(path: *const core::ffi::c_char,
	                         data: *mut core::ffi::c_void,
	                         size: usize,
	                         magic: u8,
	                         version: u8)
	                         -> bool;
}
extern "C" {
	#[doc = " Allocate a file stream with buffered read operations"]
	#[doc = " @return Stream*"]
	pub fn buffered_file_stream_alloc(storage: *mut Storage) -> *mut Stream;
}
extern "C" {
	#[doc = " Opens an existing file or creates a new one."]
	#[doc = " @param stream pointer to file stream object."]
	#[doc = " @param path path to file"]
	#[doc = " @param access_mode access mode from FS_AccessMode"]
	#[doc = " @param open_mode open mode from FS_OpenMode"]
	#[doc = " @return True on success, False on failure. You need to close the file even if the open operation failed."]
	pub fn buffered_file_stream_open(stream: *mut Stream,
	                                 path: *const core::ffi::c_char,
	                                 access_mode: FS_AccessMode,
	                                 open_mode: FS_OpenMode)
	                                 -> bool;
}
extern "C" {
	#[doc = " Closes the file."]
	#[doc = " @param stream pointer to file stream object."]
	#[doc = " @return True on success, False on failure."]
	pub fn buffered_file_stream_close(stream: *mut Stream) -> bool;
}
extern "C" {
	#[doc = " Forces write from cache to the underlying file."]
	#[doc = " @param stream pointer to file stream object."]
	#[doc = " @return True on success, False on failure."]
	pub fn buffered_file_stream_sync(stream: *mut Stream) -> bool;
}
extern "C" {
	#[doc = " Retrieves the error id from the file object"]
	#[doc = " @param stream pointer to stream object."]
	#[doc = " @return FS_Error error id"]
	pub fn buffered_file_stream_get_error(stream: *mut Stream) -> FS_Error;
}
extern "C" {
	#[doc = " Allocate file stream"]
	#[doc = " @return Stream*"]
	pub fn file_stream_alloc(storage: *mut Storage) -> *mut Stream;
}
extern "C" {
	#[doc = " Opens an existing file or create a new one."]
	#[doc = " @param stream pointer to file stream object."]
	#[doc = " @param path path to file"]
	#[doc = " @param access_mode access mode from FS_AccessMode"]
	#[doc = " @param open_mode open mode from FS_OpenMode"]
	#[doc = " @return success flag. You need to close the file even if the open operation failed."]
	pub fn file_stream_open(stream: *mut Stream,
	                        path: *const core::ffi::c_char,
	                        access_mode: FS_AccessMode,
	                        open_mode: FS_OpenMode)
	                        -> bool;
}
extern "C" {
	#[doc = " Closes the file."]
	#[doc = " @param stream"]
	#[doc = " @return true"]
	#[doc = " @return false"]
	pub fn file_stream_close(stream: *mut Stream) -> bool;
}
extern "C" {
	#[doc = " Retrieves the error id from the file object"]
	#[doc = " @param stream pointer to stream object."]
	#[doc = " @return FS_Error error id"]
	pub fn file_stream_get_error(stream: *mut Stream) -> FS_Error;
}
extern "C" {
	#[doc = " Allocate string stream"]
	#[doc = " @return Stream*"]
	pub fn string_stream_alloc() -> *mut Stream;
}
#[repr(C)]
pub struct TarArchive {
	_unused: [u8; 0],
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Clone, Hash, PartialEq, Eq)]
pub enum TarOpenMode {
	TAR_OPEN_MODE_READ = 114,
	TAR_OPEN_MODE_WRITE = 119,
	TAR_OPEN_MODE_STDOUT = 115,
}
extern "C" {
	pub fn tar_archive_alloc(storage: *mut Storage) -> *mut TarArchive;
}
extern "C" {
	pub fn tar_archive_open(archive: *mut TarArchive, path: *const core::ffi::c_char, mode: TarOpenMode) -> bool;
}
extern "C" {
	pub fn tar_archive_free(archive: *mut TarArchive);
}
extern "C" {
	pub fn tar_archive_unpack_to(archive: *mut TarArchive,
	                             destination: *const core::ffi::c_char,
	                             converter: Storage_name_converter)
	                             -> bool;
}
extern "C" {
	pub fn tar_archive_add_file(archive: *mut TarArchive,
	                            fs_file_path: *const core::ffi::c_char,
	                            archive_fname: *const core::ffi::c_char,
	                            file_size: i32)
	                            -> bool;
}
extern "C" {
	pub fn tar_archive_add_dir(archive: *mut TarArchive,
	                           fs_full_path: *const core::ffi::c_char,
	                           path_prefix: *const core::ffi::c_char)
	                           -> bool;
}
extern "C" {
	pub fn tar_archive_get_entries_count(archive: *mut TarArchive) -> i32;
}
extern "C" {
	pub fn tar_archive_unpack_file(archive: *mut TarArchive,
	                               archive_fname: *const core::ffi::c_char,
	                               destination: *const core::ffi::c_char)
	                               -> bool;
}
pub type tar_unpack_file_cb = ::core::option::Option<unsafe extern "C" fn(name: *const core::ffi::c_char,
                                                                          is_directory: bool,
                                                                          context: *mut core::ffi::c_void)
                                                                          -> bool>;
extern "C" {
	pub fn tar_archive_set_file_callback(archive: *mut TarArchive, callback: tar_unpack_file_cb, context: *mut core::ffi::c_void);
}
extern "C" {
	pub fn tar_archive_dir_add_element(archive: *mut TarArchive, dirpath: *const core::ffi::c_char) -> bool;
}
extern "C" {
	pub fn tar_archive_file_add_header(archive: *mut TarArchive, path: *const core::ffi::c_char, data_len: i32) -> bool;
}
extern "C" {
	pub fn tar_archive_file_add_data_block(archive: *mut TarArchive, data_block: *const u8, block_len: i32) -> bool;
}
extern "C" {
	pub fn tar_archive_file_finalize(archive: *mut TarArchive) -> bool;
}
extern "C" {
	pub fn tar_archive_store_data(archive: *mut TarArchive, path: *const core::ffi::c_char, data: *const u8, data_len: i32) -> bool;
}
extern "C" {
	pub fn tar_archive_finalize(archive: *mut TarArchive) -> bool;
}
