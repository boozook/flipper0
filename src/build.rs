#![feature(box_syntax)]
#![feature(fs_try_exists)]
#![feature(io_error_other)]
#![feature(option_result_contains)]

extern crate bindgen;

use std::env;
use std::error::Error;
use std::fs::try_exists;
use std::path::{PathBuf, Path};
use bindgen::{EnumVariation, RustTarget};
use semver::VersionReq;

mod consts;


const SDK_VER_SUPPORTED: &str = "~0.68";
const API_VER_SUPPORTED: &str = "~1.13";
#[allow(dead_code)] // for future validation
const TOOLCHAIN_VER_SUPPORTED: &str = "=15";


fn main() -> Result<(), Box<dyn Error>> {
	let pwd = std::env::current_dir()?;
	let cargo_profile = std::env::var("PROFILE").expect("PROFILE cargo env var");
	let cargo_target_triple = std::env::var("TARGET").expect("TARGET cargo env var");

	let debug = cargo_profile.to_lowercase().eq("debug");
	let output_filename = if debug { "flipper0-debug.rs" } else { "flipper0-release.rs" };

	// crate features:
	let prebuild = env::var("CARGO_FEATURE_PREBUILD").ok()
	                                                 .filter(|s| (s.to_lowercase() == "true" || s == "1"))
	                                                 .is_some();

	if prebuild {
		let root = std::env::var_os("CARGO_MANIFEST_DIR").expect("CARGO_MANIFEST_DIR cargo env var");
		let path = PathBuf::from(root).join("gen").join(output_filename);
		println!("cargo:rustc-env={}={}", consts::BINDINGS_ENV, path.display().to_string());
		return Ok(());
	}


	let root = sdk_path()?;

	validate_sdk(&root)?;

	// we have few possible sources:
	// - just headers from entire source code
	// - symbols.h generated by fbt on build
	// - api symbols table csv
	// - exported headers by `fbt sdk_tree`


	let (version, symbols) = read_api_table(&root)?;
	check_version(&version.as_deref().unwrap_or("n/a"), API_VER_SUPPORTED.parse()?, "API");

	let header = gen_api_table_header(&symbols)?;
	let extra = get_extra_headers(&symbols)?;


	let (mut builder, twd) = from_source(&root, &header, Some(&extra)).or_else(|_| from_build(&root, &header, Some(&extra)))
	                                                                  .or_else(|_| from_sdk_tree(&root, debug))?;
	builder = builder.rust_target(RustTarget::Nightly)
	                 .use_core()
	                 .ctypes_prefix("core::ffi")
	                 .size_t_is_usize(true)
	                 .no_convert_floats()
	                 .translate_enum_integer_types(true)
	                 .array_pointers_in_arguments(true)
	                 .explicit_padding(false)
	                 .default_enum_style(EnumVariation::Rust { non_exhaustive: true })
	                 .layout_tests(true)
	                 .conservative_inline_namespaces()
	                 .enable_function_attribute_detection()
	                 .allowlist_recursively(true)
	                 .detect_include_paths(true)
	                 .trust_clang_mangling(true)
	                 .derive_default(false)
	                 .derive_eq(false)
	                 .derive_copy(false)
	                 .derive_debug(false)
	                 .derive_hash(false)
	                 .derive_ord(false)
	                 .derive_partialeq(false)
	                 .derive_partialord(false)
	                 .generate_comments(true)
	                 .parse_callbacks(box DeriveCallbacks { exclude: exclustions([header, extra])? });


	// ARM toolchain
	let toolchain = find_arm_toolchain(&root)?;
	builder = builder.blocklist_file("stdlib.h")
	                 .clang_args(&["--include-directory", &toolchain.join("include").display().to_string()]);


	// specifically for the target:
	if let "thumbv7em-none-eabihf" = cargo_target_triple.as_ref() {
		builder = builder.clang_args(&["-target", "thumbv7em-none-eabihf"]);
		// Only `-l` and `-L` flags are allowed in build script :(
		// println!("cargo:rustc-flags='-C target-cpu=cortex-m4 -C target-feature=+long-calls'");
	}


	// extra code-gen for `debug` feature:
	if debug {
		builder = builder.derive_debug(true).clang_args(&["-DFURI_DEBUG", "-DNDEBUG"]);
	} else {
		builder = builder.derive_debug(false).no_debug(".*");
	}


	// finally:
	if let Some(path) = twd {
		std::env::set_current_dir(&path)?;
	}
	let bindings = builder.generate();
	std::env::set_current_dir(&pwd)?;
	bindings.map(|bindings| {
		        let out_path = PathBuf::from(env::var("OUT_DIR").expect("OUT_DIR cargo env var")).join(output_filename);
		        println!("bindings output: {}", out_path.display());
		        bindings.write_to_file(&out_path).expect("Couldn't write bindings!");
		        println!("cargo:rustc-env={}={}", consts::BINDINGS_ENV, out_path.display().to_string());
	        })
	        .map_err(|err| println!("cargo:error={err:}"))
	        .expect("Unable to generate bindings");

	Ok(())
}


fn validate_sdk<P: AsRef<Path>>(root: P) -> Result<(), Box<dyn Error>> {
	println!(
	         "cargo:rerun-if-changed={}",
	         root.as_ref().join(PathBuf::from(".git/HEAD")).display()
	);
	check_version_git(root.as_ref(), SDK_VER_SUPPORTED.parse()?, "SDK")?;
	Ok(())
}

// Unfortunately there are no VERSION file yet.
fn _check_version_file<S: std::fmt::Display>(path: &Path, supported: VersionReq, name: S) -> Result<(), Box<dyn Error>> {
	let version = std::fs::read_to_string(path)?;
	check_version(&version, supported, name);
	Ok(())
}

fn check_version<S: std::fmt::Display>(version: &str, supported: VersionReq, name: S) {
	if let Ok(version) = semver::Version::parse(version.trim()) {
		if !supported.matches(&version) {
			println!("cargo:warning={name} version not supported. Required version '{supported}' does not matches {version}.");
		}
	} else {
		println!("cargo:warning={name} version `{version}` is invalid.");
	}
}

fn check_version_git<S: std::fmt::Display>(root: &Path, supported: VersionReq, name: S) -> Result<(), Box<dyn Error>> {
	let root = PathBuf::from(root);
	let repo = rustygit::Repository::new(&root);
	let tags = repo.cmd_out(["tag", "--points-at", "HEAD"])?;
	let mut versions = tags.into_iter().filter_map(|t| semver::Version::parse(&t).ok());

	if let Some(version) = versions.next() {
		println!("cargo:info=Flipper SDK version determined from git tag: {version:}");
		if !supported.matches(&version) {
			println!("cargo:warning={name} version probably not supported. Supported version '{supported}' does not matches {version}.");
		} // else OK
	} else {
		println!("cargo:warning=Flipper SDK version not found");
	}

	Ok(())
}


/// Build list of excluded files such as generated by this crate that cargo do not need to watch.
/// If path points to directory, files in it will be in the result list.
fn exclustions<I: IntoIterator<Item = P>, P: AsRef<Path>>(paths: I) -> Result<Vec<PathBuf>, Box<dyn Error>> {
	let res = paths.into_iter()
	               .flat_map(|p| {
		               let def = vec![p.as_ref().to_owned()].into_iter();
		               if p.as_ref().is_dir() {
			               let res = std::fs::read_dir(p.as_ref()).ok().map(|iter| {
				                                                           iter.filter_map(|result| result.ok())
				                                                               .filter(|entry| entry.path().is_file())
				                                                               .filter(|entry| {
					                                                               entry.path()
					                                                                    .extension()
					                                                                    .unwrap_or_default()
					                                                                    .to_str()
					                                                                    .unwrap_or_default()
					                                                                    .to_owned() ==
					                                                               "h"
				                                                               })
			                                                           });
			               if let Some(res) = res {
				               res.map(|entry| entry.path().to_owned()).collect::<Vec<_>>().into_iter()
			               } else {
				               def
			               }
		               } else {
			               def
		               }
	               })
	               .collect();

	Ok(res)
}


fn read_api_table<P: AsRef<Path>>(root: P) -> Result<(Option<String>, Vec<ApiTableRow<String>>), Box<dyn Error>> {
	let root = root.as_ref();
	let path = root.join(PathBuf::from("firmware/targets/f7/api_symbols.csv"));
	println!("cargo:rerun-if-changed={}", path.display());

	let mut version = None;
	let mut symbols = Vec::new();

	let mut reader = csv::Reader::from_path(&path)?;
	for (i, result) in reader.records().enumerate() {
		match result {
			Ok(mut record) => {
				record.trim();

				if matches!(record.get(0), Some("Version")) {
					version = record.get(2).map(ToOwned::to_owned);
				} else {
					symbols.push(record.into());
				}
			},
			Err(err) => println!("cargo:warning=API table row {i} error: {err}"),
		}
	}

	Ok((version, symbols))
}


fn gen_api_table_header(symbols: &[ApiTableRow<String>]) -> Result<PathBuf, Box<dyn Error>> {
	let outdir = PathBuf::from(env::var("OUT_DIR")?);
	let mut result = String::new();

	// XXX: add missed import:
	result.push_str("#include <stdbool.h> \n\n");

	for h in symbols.iter().filter(|s| matches!(s, ApiTableRow::Header { .. })) {
		let path = h.name();
		let row = format!("#include <{path}> \n");
		result.push_str(&row);
	}


	result.push_str("\n/* valiables */\n\n");
	for v in symbols.iter().filter(|s| matches!(s, ApiTableRow::Variable { .. })) {
		let name = v.name();
		let ty = v.ty();
		if ty == "const Icon" {
			continue;
		}
		let _row = format!("extern {ty} {name}; \n");
		// result.push_str(&row); // not needed yet.
	}


	result.push_str("\n/* functions */\n\n");
	for f in symbols.iter().filter(|s| matches!(s, ApiTableRow::Function { .. })) {
		let name = f.name();
		let ret = f.ty();
		let args = f.args();
		let _row = format!("extern {ret} {name}({args}); \n");
		// result.push_str(&row); // not needed yet.
	}

	let path = outdir.join("flipper_bindings.h");
	std::fs::write(&path, result.as_bytes())?;

	Ok(path)
}


#[allow(dead_code)] // allow dead-code for status for future exclustions
#[derive(Debug, Clone)]
enum ApiTableRow<S: AsRef<str>> {
	Header { status: S, name: S },
	Variable { status: S, name: S, mut_ty: S, ty: S },
	Function { status: S, name: S, ret: S, args: S },
}

impl From<csv::StringRecord> for ApiTableRow<String> {
	fn from(row: csv::StringRecord) -> Self {
		match row.get(0).unwrap().to_lowercase().as_str() {
			"header" => {
				Self::Header { status: row.get(1).unwrap().to_owned(),
				               name: row.get(2).unwrap().to_owned() }
			},
			"variable" => {
				Self::Variable { status: row.get(1).unwrap().to_owned(),
				                 name: row.get(2).unwrap().to_owned(),
				                 mut_ty: row.get(3).unwrap().to_owned(),
				                 ty: row.get(4).unwrap().to_owned() }
			},
			"function" => {
				Self::Function { status: row.get(1).unwrap().to_owned(),
				                 name: row.get(2).unwrap().to_owned(),
				                 ret: row.get(3).unwrap().to_owned(),
				                 args: row.get(4).unwrap_or_default().to_owned() }
			},
			_ => {
				println!("cargo:error=Unable to parse API table row.");
				std::process::exit(1);
			},
		}
	}
}

impl<S: AsRef<str>> ApiTableRow<S> {
	fn name(&self) -> &str {
		match self {
			ApiTableRow::Header { name, .. } => name.as_ref(),
			ApiTableRow::Variable { name, .. } => name.as_ref(),
			ApiTableRow::Function { name, .. } => name.as_ref(),
		}
	}
	fn ty(&self) -> &str {
		match self {
			ApiTableRow::Header { .. } => "",
			ApiTableRow::Variable { mut_ty, .. } => mut_ty.as_ref(),
			ApiTableRow::Function { ret, .. } => ret.as_ref(),
		}
	}

	fn args(&self) -> &str {
		match self {
			ApiTableRow::Header { .. } => "",
			ApiTableRow::Variable { .. } => "",
			ApiTableRow::Function { args, .. } => args.as_ref(),
		}
	}
}


// allowing dead-code to ommit unnecessary `Debug` impl for `DeriveCallbacks`
// that needed to `ParseCallbacks`
#[allow(dead_code)]
#[derive(Debug)]
struct DeriveCallbacks<P: AsRef<Path>> {
	exclude: Vec<P>,
}

impl bindgen::callbacks::ParseCallbacks for DeriveCallbacks<PathBuf> {
	fn include_file(&self, filename: &str) {
		let path = PathBuf::from(filename);
		if !self.exclude.contains(&path) {
			bindgen::CargoCallbacks.include_file(filename)
		}
	}
}


fn from_source<P: AsRef<Path>>(root: P,
                               symbols_header: P,
                               extra_include: Option<P>)
                               -> Result<(bindgen::Builder, Option<PathBuf>), Box<dyn Error>> {
	let root = root.as_ref();
	let symbols_header = symbols_header.as_ref();

	if try_exists(&symbols_header)? {
		let mut builder =
			bindgen::Builder::default().header(format!("{}", symbols_header.display()))
			                           .clang_args(&["--include-directory", &root.display().to_string()])
			                           .clang_arg(format!("-I{}", &PathBuf::from("furi").display()))
			                           .clang_arg(format!("-I{}", &PathBuf::from("firmware/targets/f7").display()))
			                           .clang_arg(format!("-I{}", &PathBuf::from("firmware/targets/f7/ble_glue").display()))
			                           .clang_arg(format!("-I{}", &PathBuf::from("firmware/targets/f7/fatfs").display()))
			                           .clang_arg(format!("-I{}", &PathBuf::from("firmware/targets/f7/furi_hal").display()))
			                           .clang_arg(format!("-I{}", &PathBuf::from("firmware/targets/f7/Inc").display()))
			                           .clang_arg(format!("-I{}", &PathBuf::from("firmware/targets/furi_hal_include").display()))
			                           .clang_arg(format!("-I{}", &PathBuf::from("applications/services").display()))
			                           .clang_arg(format!("-I{}", &PathBuf::from("applications/main").display()))
			                           .clang_arg(format!("-DSTM32WB"))
			                           .clang_arg(format!("-DSTM32WB55xx"))
			                           .clang_arg(format!("-DUSE_FULL_LL_DRIVER"))
			                           .clang_args(&["-x", "c"])
			                           .clang_arg("-ferror-limit=100000");

		if let Some(include) = extra_include {
			builder = builder.clang_arg(format!("-I{}", &include.as_ref().display()))
		}

		// add lib/*:
		builder = builder.clang_arg(format!("-I{}", &PathBuf::from("lib").display()));
		let libs = std::fs::read_dir(&root.join("lib"))?.filter_map(|result| result.ok())
		                                                .filter(|entry| entry.path().is_dir())
		                                                .filter(|entry| {
			                                                let filename = entry.path()
			                                                                    .file_name()
			                                                                    .unwrap_or_default()
			                                                                    .to_str()
			                                                                    .unwrap_or_default()
			                                                                    .to_owned();
			                                                !filename.starts_with(".") &&
			                                                !filename.to_uppercase().starts_with("STM32") &&
			                                                !filename.to_uppercase().starts_with("FREERTOS")
		                                                });

		for lib in libs {
			let path = PathBuf::from("lib").join(lib.path());
			builder = builder.clang_arg(format!("-I{}", path.display()));
			if try_exists(path.join("include"))? {
				builder = builder.clang_arg(format!("-I{}", path.join("include").display()));
			}
		}

		// XXX: hardcoded extra include-paths:
		let libs = [
		            "STM32CubeWB/Drivers/CMSIS/Device/ST/STM32WBxx/Include",
		            "STM32CubeWB/Drivers/CMSIS/Include",
		            "STM32CubeWB/Drivers/STM32WBxx_HAL_Driver/Inc",
		            "FreeRTOS-Kernel/include",
		            "FreeRTOS-Kernel/portable/GCC/ARM_CM4F",
		            "ST25RFAL002/source/st25r3916",
		            "libusb_stm32/inc",
		];
		for lib in libs {
			let path = PathBuf::from("lib").join(PathBuf::from(lib));
			builder = builder.clang_arg(format!("-I{}", &path.display()));
			if try_exists(path.join("include"))? {
				builder = builder.clang_arg(format!("-I{}", path.join("include").display()));
			}
		}


		Ok((builder, Some(root.to_owned())))
	} else {
		Err(std::io::Error::new(std::io::ErrorKind::NotFound, symbols_header.display().to_string()).into())
	}
}


fn from_build<P: AsRef<Path>>(_root: P,
                              _symbols_headerr: P,
                              _extra_include: Option<P>)
                              -> Result<(bindgen::Builder, Option<PathBuf>), Box<dyn Error>> {
	Err(std::io::Error::other("Not implemented yet").into())
}


fn from_sdk_tree<P: AsRef<Path>>(root: P, _debug: bool) -> Result<(bindgen::Builder, Option<PathBuf>), Box<dyn Error>> {
	// #![allow(unreachable_code)]
	// return Err(std::io::Error::other("Not implemented yet").into());

	let dirname = if _debug { "f7-firmware-D" } else { "f7-firmware-R" };
	let sdk = root.as_ref().join(PathBuf::from(format!("build/{dirname}/sdk/")));
	let opts = std::fs::read_to_string(sdk.join("sdk.opts"))?;


	let glob = wax::Glob::new("**/*.h").unwrap();
	let headers = glob.walk_with_behavior(&sdk, wax::LinkBehavior::ReadTarget)
	                  .not(["**/.*"])?
	                  .filter_map(|entry| entry.map_err(|err| println!("cargo:warning=ERROR: {err}")).ok())
	                  .map(|entry| entry.path().to_owned());

	let mut builder = bindgen::Builder::default();
	for path in headers {
		println!("+ {}", path.display().to_string());
		builder = builder.header(path.display().to_string());
	}
	builder = builder.blocklist_file("portmacro.h")
	                 .blocklist_file("FreeRTOS.h")
	                 .clang_args(opts.split_ascii_whitespace().filter(|s| {
		                                                          s.starts_with("-I") ||
		                                                          s.starts_with("-D") ||
		                                                          s.starts_with("-m") ||
		                                                          s.starts_with("-W")
	                                                          }));


	Ok((builder, Some(sdk)))
}


fn get_extra_headers(symbols: &[ApiTableRow<String>]) -> Result<PathBuf, Box<dyn Error>> {
	let outdir = PathBuf::from(env::var("OUT_DIR")?).join("extras");
	std::fs::create_dir_all(&outdir)?;

	let mut result = String::new();

	result.push_str("#pragma once \n\n #include <gui/icon.h> \n\n");

	for v in symbols.iter()
	                .filter(|s| matches!(s, ApiTableRow::Variable { mut_ty, .. } if mut_ty.as_str() == "const Icon"))
	{
		let name = v.name();
		let ty = v.ty();
		let row = format!("extern {ty} {name}; \n");
		result.push_str(&row);
	}


	let path = outdir.join("assets_icons.h");
	std::fs::write(&path, result.as_bytes())?;

	Ok(outdir)
}


fn sdk_path() -> Result<PathBuf, Box<dyn Error>> {
	println!("cargo:rerun-if-env-changed={}", consts::FLIPPER_SDK_PATH_ENV);
	if let Some(sdk_path) = std::env::var_os(consts::FLIPPER_SDK_PATH_ENV) {
		Ok(PathBuf::from(sdk_path))
	} else {
		println!(
		         "cargo:warning=env var `{}` not found, please set it. \
		         You can enable `prebuild` feature to use prebuilt bindings.",
		         consts::FLIPPER_SDK_PATH_ENV
		);
		Err(env::VarError::NotPresent.into()).into()
	}
}


fn find_arm_toolchain<P: AsRef<Path>>(root: P) -> Result<PathBuf, Box<dyn Error>> {
	let find_arm_toolchain = |root: &Path| {
		println!("Searching ARM toolchain...");

		let glob = wax::Glob::new("toolchain/*/arm-none-eabi").unwrap();
		let result = glob.walk_with_behavior(&root, wax::LinkBehavior::ReadTarget)
		                 .not(["toolchain/.*/arm-none-eabi"])
		                 .map_err(|err| println!("cargo:warning=ERROR: Unable to walk fs. {err}"))
		                 .ok()?
		                 .filter_map(|entry| entry.map_err(|err| println!("cargo:warning=ERROR: {err}")).ok())
		                 .filter(|entry| try_exists(entry.path().join("include")).ok().unwrap_or_default())
		                 .map(|entry| {
			                 println!("Found ARM toolchain: {}", entry.to_candidate_path().to_string());
			                 entry.path().to_owned()
		                 })
		                 .next();
		result
	};

	let path = std::env::var(consts::ARM_TOOLCHAIN_PATH_ENV).map_or_else(
	                                                                     |err| {
		                                                                     println!("`{}` {err}.", consts::ARM_TOOLCHAIN_PATH_ENV);
		                                                                     find_arm_toolchain(&root.as_ref())
	                                                                     },
	                                                                     |path| {
		                                                                     let path = PathBuf::from(path);
		                                                                     if path.exists() && path.is_dir() {
			                                                                     Some(path)
		                                                                     } else {
			                                                                     println!(
				                                                                     "cargo:warning=`{}` points to non-existing dir.",
				                                                                     consts::ARM_TOOLCHAIN_PATH_ENV
			                                                                     );
			                                                                     find_arm_toolchain(&root.as_ref())
		                                                                     }
	                                                                     },
	);

	path.ok_or(std::io::Error::new(std::io::ErrorKind::NotFound, consts::ARM_TOOLCHAIN_PATH_ENV).into())
}
